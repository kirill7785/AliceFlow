#ifndef _CONSTR_STRUCT_CPP_ALICE_
#define _CONSTR_STRUCT_CPP_ALICE_ 1

// Модуль constr_struct_alice.cpp повторяет функционал модуля constr_struct, НО с учётом использования АЛИС сетки.
// начало разработки 9 сентября 2016. На данный момент уже 21 сентября 2016. На данный момент разработка не завершена 
// но сделан хороший задел и в основном идет уточнение деталей алгоритма которые приводят к существенным правкам кода.
// 21 сентября 2016 10911 строк кода.
// 22 сентября 2016 21529 строк кода. 
// 25 сентября 2016. 
// Учтено что есть flow.ptr и temp.ptr. На данный момент заполнено и flow.ptr и temp.ptr.
// 22237 строк кода.
// 26 сентября 2016. Не тестировалось. 
// 01.10.2016 Учтено iI1 и iI2 для внутреннего плоского источника тепла.
// 22484 строк кода. Первый успешный запуск данных алгоритмов 28 сентября 2016 года.

// Вычисляет количество элементов модели.
void calculate_max_elm(octTree* &oc, integer &maxelm, integer iflag, BLOCK* b, integer lb, bool binit_TD) {

	// Если binit_TD true то нужно обнулять octree1->inum_TD = 0; Иначе мы его не трогаем.

	maxelm = 0; // инициализация.
	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				// Гасим информацию о посещениях.
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				TOCHKA p;
				p.x = 0.125*(octree1->p0.x + octree1->p1.x + octree1->p2.x + octree1->p3.x + octree1->p4.x + octree1->p5.x + octree1->p6.x + octree1->p7.x);
				p.y = 0.125*(octree1->p0.y + octree1->p1.y + octree1->p2.y + octree1->p3.y + octree1->p4.y + octree1->p5.y + octree1->p6.y + octree1->p7.y);
				p.z = 0.125*(octree1->p0.z + octree1->p1.z + octree1->p2.z + octree1->p3.z + octree1->p4.z + octree1->p5.z + octree1->p6.z + octree1->p7.z);
				integer ib;
				bool inDomain = false;
				switch (iflag) {
				case TEMPERATURE: inDomain = in_model_temp(p, ib, b, lb); break;
				case HYDRODINAMIC: inDomain = in_model_flow(p, ib, b, lb); break;
				}
				if (inDomain) {
					maxelm++;
				}
				if (binit_TD) {
					octree1->inum_TD = 0; // По умолчанию не принадлежит расчётной области.
				}
				octree1->inum_FD = 0; // По умолчанию не принадлежит расчётной области.
				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}
} // calculate_max_elm


// визуализация в tecplot 360 с учётом hollow блоков в программной модели.
// Построение nodes, nvtx, prop. Частей 1..6 в программной модели.
void constr_nodes_nvtx_prop_alice(octTree* &oc, integer inx, integer iny, integer inz, integer &maxelm, doublereal* &xpos, doublereal* &ypos, doublereal* &zpos,
	integer iflag, BLOCK* b, integer lb, integer* &whot_is_block, TOCHKA* &pa, integer &maxnode, integer** &nvtx, 
	doublereal** &prop, doublereal* &Sc, integer* &ipower_time_depend, TPROP* matlist, integer* &ilevel_alice) {

	integer maxelm_loc = (inx + 1)*(iny + 1)*(inz + 1);
	// Вычисление maxelm.
	calculate_max_elm(oc, maxelm, iflag, b, lb, true);
#if doubleintprecision == 1
	//printf("maxelm=%lld inx=%lld iny=%lld inz=%lld all_in=%lld\n",maxelm,inx,iny,inz,inx*iny*inz);
#else
	//printf("maxelm=%d inx=%d iny=%d inz=%d all_in=%d\n",maxelm,inx,iny,inz,inx*iny*inz);
#endif
	
	//system("PAUSE");
	
	ilevel_alice = NULL;
	ilevel_alice = new integer[maxelm];
	if (ilevel_alice == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for ilevel_alice constr struct_alice...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}

	whot_is_block = NULL;
	whot_is_block = new integer[maxelm];
	if (whot_is_block == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for whot_is_block constr struct_alice...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}

	prop = NULL;
	prop = new doublereal*[8];
	if (prop == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for prop constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	for (integer i = 0; i<8; i++) prop[i] = NULL;
	for (integer i = 0; i<8; i++) {
		prop[i] = new doublereal[maxelm];
		if (prop[i] == NULL) {
			// недостаточно памяти на данном оборудовании.
#if doubleintprecision == 1
			printf("Problem : not enough memory on your equipment for prop[%lld] constr struct_alice...\n", i);
#else
			printf("Problem : not enough memory on your equipment for prop[%d] constr struct_alice...\n", i);
#endif

			
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
	}
	Sc = NULL;
	Sc = new doublereal[maxelm];
	if (Sc == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for Sc constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	ipower_time_depend = NULL;
	ipower_time_depend = new integer[maxelm];
	if (ipower_time_depend == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for ipower_time_depend constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}


	// Вычисление допуска.
	doublereal epsTolx = 1.0e40;
	doublereal epsToly = 1.0e40;
	doublereal epsTolz = 1.0e40;
	const doublereal mdop = 0.75;
	for (integer i = 0; i < inx; i++) {
		if (fabs(xpos[i + 1] - xpos[i]) < epsTolx) {
			epsTolx = mdop*fabs(xpos[i + 1] - xpos[i]);
		}
	}
	for (integer i = 0; i < iny; i++) {
		if (fabs(ypos[i + 1] - ypos[i]) < epsToly) {
			epsToly = mdop*fabs(ypos[i + 1] - ypos[i]);
		}
	}
	for (integer i = 0; i < inz; i++) {
		if (fabs(zpos[i + 1] - zpos[i]) < epsTolz) {
			epsTolz = mdop*fabs(zpos[i + 1] - zpos[i]);
		}
	}

	printf("geometric precision tolerance : epsTolx=%e epsToly=%e epsTolz=%e\n", epsTolx, epsToly, epsTolz);
	//system("PAUSE");

	
	
	HASH_POLE* hash_table_export = new HASH_POLE[(inx + 1)*(iny + 1)*(inz + 1)];
	for (integer i_1 = 0; i_1 < (inx + 1)*(iny + 1)*(inz + 1); i_1++) {
		hash_table_export[i_1].flag = false;
		hash_table_export[i_1].inum = -1;
	}


	// Вычисление необходимого объёма оперативной памяти.
	// 25 марта 2017

	integer marker_pa_local = 0;

	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}


	while (top_ALICE_STACK > 0) {

		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				// Гасим информацию о посещениях.
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

				// это лист update pa.
				integer i0, i1, i2, i3, i4, i5, i6, i7;

				bool bfound = false;

				TOCHKA p;
				p.x = 0.125*(octree1->p0.x + octree1->p1.x + octree1->p2.x + octree1->p3.x + octree1->p4.x + octree1->p5.x + octree1->p6.x + octree1->p7.x);
				p.y = 0.125*(octree1->p0.y + octree1->p1.y + octree1->p2.y + octree1->p3.y + octree1->p4.y + octree1->p5.y + octree1->p6.y + octree1->p7.y);
				p.z = 0.125*(octree1->p0.z + octree1->p1.z + octree1->p2.z + octree1->p3.z + octree1->p4.z + octree1->p5.z + octree1->p6.z + octree1->p7.z);
				integer ib;
				bool inDomain = false;
				switch (iflag) {
				case TEMPERATURE: inDomain = in_model_temp(p, ib, b, lb);
					break;
				case HYDRODINAMIC: inDomain = in_model_flow(p, ib, b, lb);
					break;
				}
				if (inDomain) {

					// Мы будем оперировать только над точувми принадлежащими РО.
					// Т.е. точки в HOLLOW блоках мы игнорируем.
					// Этот кусок кода занесён внутрь 08 ноября 2016.

					bfound = false;
					integer key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p0, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;

					if (!bfound) {
						i0 = marker_pa_local;
						
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa_local;
						marker_pa_local++;
					}
					else {
						i0 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p1, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i1 = marker_pa_local;
						
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa_local;
						marker_pa_local++;
					}
					else {
						i1 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p2, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i2 = marker_pa_local;
						
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa_local;
						marker_pa_local++;
					}
					else {
						i2 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p3, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i3 = marker_pa_local;
						
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa_local;
						marker_pa_local++;
					}
					else {
						i3 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p4, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i4 = marker_pa_local;
						
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa_local;
						marker_pa_local++;
					}
					else {
						i4 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p5, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i5 = marker_pa_local;
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa_local;
						marker_pa_local++;
					}
					else {
						i5 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p6, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i6 = marker_pa_local;
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa_local;
						marker_pa_local++;
					}
					else {
						i6 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p7, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i7 = marker_pa_local;
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa_local;
						marker_pa_local++;
					}
					else {
						i7 = hash_table_export[key_now].inum;
					}
									
				}

				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;


			}
			else {

				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}

			}
		}

	}
	delete[] hash_table_export;


	// сформировать pa.
	// заодно посчитать количество узловых точек.
	// сформировать nvtx которые ссылаются на pa.
	// визуализировать сетку.
	TOCHKA* pa_alice = NULL;
	//pa_alice = new TOCHKA[(inx + 1)*(iny + 1)*(inz + 1)];
	pa_alice = new TOCHKA[marker_pa_local+2];
	if (pa_alice == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for pa_alice in adaptive_local_refinement_mesh generator...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	integer marker_pa = 0;
	// И тут же сразу формируем nvtx:
	nvtx = NULL;
	nvtx = new integer*[8];
	if (nvtx == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for nvtx in adaptive_local_refinement_mesh generator...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	for (integer k_1 = 0; k_1 < 8; k_1++) {
		nvtx[k_1] = NULL;
		nvtx[k_1] = new integer[maxelm];
		//nvtx[k_1] = new integer[marker_pa_local + 2];
		if (nvtx[k_1] == NULL) {
			// недостаточно памяти на данном оборудовании.
#if doubleintprecision == 1
			printf("Problem : not enough memory on your equipment for nvtx[%lld] in adaptive_local_refinement_mesh generator...\n", k_1);
#else
			printf("Problem : not enough memory on your equipment for nvtx[%d] in adaptive_local_refinement_mesh generator...\n", k_1);
#endif
			
			printf("Please any key to exit...\n");
			exit(1);
		}
	}
	integer imarker_nvtx = 0;

	// Конец вычисления необходимого объема оперативной памяти.
	hash_table_export = new HASH_POLE[(inx + 1)*(iny + 1)*(inz + 1)];
	for (integer i_1 = 0; i_1 < (inx + 1)*(iny + 1)*(inz + 1); i_1++) {
		hash_table_export[i_1].flag = false;
		hash_table_export[i_1].inum = -1;
	}


	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}

	
	while (top_ALICE_STACK > 0) {
		
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				// Гасим информацию о посещениях.
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

				// это лист update pa.
				integer i0, i1, i2, i3, i4, i5, i6, i7;
				
				bool bfound = false;
				
				TOCHKA p;
				p.x = 0.125*(octree1->p0.x + octree1->p1.x + octree1->p2.x + octree1->p3.x + octree1->p4.x + octree1->p5.x + octree1->p6.x + octree1->p7.x);
				p.y = 0.125*(octree1->p0.y + octree1->p1.y + octree1->p2.y + octree1->p3.y + octree1->p4.y + octree1->p5.y + octree1->p6.y + octree1->p7.y);
				p.z = 0.125*(octree1->p0.z + octree1->p1.z + octree1->p2.z + octree1->p3.z + octree1->p4.z + octree1->p5.z + octree1->p6.z + octree1->p7.z);
				integer ib;
				bool inDomain = false;
				switch (iflag) {
				case TEMPERATURE: inDomain = in_model_temp(p, ib, b, lb);
					break;
				case HYDRODINAMIC: inDomain = in_model_flow(p, ib, b, lb);
					break;
				}
				if (inDomain) {

					// Мы будем оперировать только над точками принадлежащими РО.
					// Т.е. точки в HOLLOW блоках мы игнорируем.
					// Этот кусок кода занесён внутрь 08 ноября 2016.

					bfound = false;
					integer key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p0, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;

					if (!bfound) {
						i0 = marker_pa;
						pa_alice[marker_pa] = octree1->p0;
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa;
						marker_pa++;
					}
					else {
						i0 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p1, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i1 = marker_pa;
						pa_alice[marker_pa] = octree1->p1;
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa;
						marker_pa++;
					}
					else {
						i1 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p2, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i2 = marker_pa;
						pa_alice[marker_pa] = octree1->p2;
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa;
						marker_pa++;
					}
					else {
						i2 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p3, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i3 = marker_pa;
						pa_alice[marker_pa] = octree1->p3;
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa;
						marker_pa++;
					}
					else {
						i3 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p4, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i4 = marker_pa;
						pa_alice[marker_pa] = octree1->p4;
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa;
						marker_pa++;
					}
					else {
						i4 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p5, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i5 = marker_pa;
						pa_alice[marker_pa] = octree1->p5;
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa;
						marker_pa++;
					}
					else {
						i5 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p6, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i6 = marker_pa;
						pa_alice[marker_pa] = octree1->p6;
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa;
						marker_pa++;
					}
					else {
						i6 = hash_table_export[key_now].inum;
					}
					bfound = false;
					key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p7, epsTolx, epsToly, epsTolz);
					bfound = hash_table_export[key_now].flag;
					if (!bfound) {
						i7 = marker_pa;
						pa_alice[marker_pa] = octree1->p7;
						hash_table_export[key_now].flag = true;
						hash_table_export[key_now].inum = marker_pa;
						marker_pa++;
					}
					else {
						i7 = hash_table_export[key_now].inum;
					}





					integer l = imarker_nvtx;
					switch (iflag) {
					case TEMPERATURE: prop[RHO][l] = matlist[b[ib].imatid].rho;
						//prop[CP][l] = matlist[b[ib].imatid].cp;
						//prop[LAM][l] = matlist[b[ib].imatid].lam;
						prop[CP][l] = get_lam(matlist[b[ib].imatid].n_cp, matlist[b[ib].imatid].temp_cp, matlist[b[ib].imatid].arr_cp, 25.0);
						prop[LAM][l] = get_lam(matlist[b[ib].imatid].n_lam, matlist[b[ib].imatid].temp_lam, matlist[b[ib].imatid].arr_lam, 25.0);

						prop[MULT_LAM_X][l] = matlist[b[ib].imatid].orthotropy_multiplyer_x;
						prop[MULT_LAM_Y][l] = matlist[b[ib].imatid].orthotropy_multiplyer_y;
						prop[MULT_LAM_Z][l] = matlist[b[ib].imatid].orthotropy_multiplyer_z;
						// Коэффициенты Лямэ.
						prop[MU_LAME][l] = matlist[b[ib].imatid].mu_Lame;
						prop[LAMBDA_LAME][l] = matlist[b[ib].imatid].lambda_Lame;

						//Sc[l] = b[ib].Sc;
						Sc[l] = get_power(b[ib].n_Sc, b[ib].temp_Sc, b[ib].arr_Sc, 20.0);
						ipower_time_depend[l] = b[ib].ipower_time_depend;
						break;
					case HYDRODINAMIC:prop[RHO][l] = matlist[b[ib].imatid].rho;
						prop[MU][l] = matlist[b[ib].imatid].mu;
						prop[BETA_T][l] = matlist[b[ib].imatid].beta_t;
						break;
					}
					octree1->inum_TD = imarker_nvtx + 1; // Нумерация начинается с 1.

					// Нумерация начинается с единицы .
					nvtx[0][imarker_nvtx] = i0 + 1;
					nvtx[1][imarker_nvtx] = i1 + 1;
					nvtx[2][imarker_nvtx] = i2 + 1;
					nvtx[3][imarker_nvtx] = i3 + 1;
					nvtx[4][imarker_nvtx] = i4 + 1;
					nvtx[5][imarker_nvtx] = i5 + 1;
					nvtx[6][imarker_nvtx] = i6 + 1;
					nvtx[7][imarker_nvtx] = i7 + 1;
					// конструируем whot_is_block.
					whot_is_block[imarker_nvtx] = ib;
					ilevel_alice[imarker_nvtx] = octree1->ilevel;
					imarker_nvtx++;
				}

				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;


			}
			else {

				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}

			}
		}

	}
	delete[] hash_table_export;

	maxnode = marker_pa;
	pa = NULL;
	pa = new TOCHKA[maxnode];
	if (pa == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for pa constr struct alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	for (integer i = 0; i < maxnode; i++) {
		pa[i] = pa_alice[i];
	}
	delete[] pa_alice;
	pa_alice = NULL;

	// nvtx && pa сформированы, можно экспортировать в tecplot360
	FILE *fp_4 = NULL;
	errno_t err_4;
	err_4 = fopen_s(&fp_4, "ALICEFLOW0_24ALICEMESH.PLT", "w");

	if ((err_4) != 0) {
		printf("Create File temp Error\n");
		//getchar();
		system("pause");

	}
	else {

		if (fp_4 != NULL) {
			fprintf(fp_4, "TITLE = \"ALICEFLOW0_24\"\n");
			fprintf(fp_4, "VARIABLES = x, y, z\n");
#if doubleintprecision == 1
			fprintf(fp_4, "ZONE T=\"Rampant\", N=%lld, E=%lld, ET=BRICK, F=FEBLOCK\n\n", marker_pa, imarker_nvtx);
#else
			fprintf(fp_4, "ZONE T=\"Rampant\", N=%d, E=%d, ET=BRICK, F=FEBLOCK\n\n", marker_pa, imarker_nvtx);
#endif
			
			// запись x
			for (integer i = 0; i < marker_pa; i++) {
				fprintf(fp_4, "%+.16f ", pa[i].x);
				if (i % 10 == 0) fprintf(fp_4, "\n");
			}
			fprintf(fp_4, "\n");
			// запись y
			for (integer i = 0; i < marker_pa; i++) {
				fprintf(fp_4, "%+.16f ", pa[i].y);
				if (i % 10 == 0) fprintf(fp_4, "\n");
			}
			fprintf(fp_4, "\n");
			// запись z
			for (integer i = 0; i < marker_pa; i++) {
				fprintf(fp_4, "%+.16f ", pa[i].z);
				if (i % 10 == 0) fprintf(fp_4, "\n");
			}
			fprintf(fp_4, "\n");
			for (integer i = 0; i <= imarker_nvtx - 1; i++) {
#if doubleintprecision == 1
				fprintf(fp_4, "%lld %lld %lld %lld %lld %lld %lld %lld \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
#else
				fprintf(fp_4, "%d %d %d %d %d %d %d %d \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
#endif
				}
			fclose(fp_4);
			//WinExec("C:\\Program Files\\Tecplot\\Tecplot 360 EX 2014 R1\\bin\\tec360.exe ALICEFLOW0_24ALICEMESH.PLT", SW_NORMAL);
		}
	}
} // constr_nodes_nvtx_prop_alice


  // данная параллельная версия метода гаусса не даёт отличий от серийной версии
  // Это было проверено массовым тестированием (см. код eqsolve_simple_gauss).
  // Данная версия правильная.
  // Существует еще одна версия параллельной программы. В книге Анализ алгоритмов вводный курс
  // есть параллельный алгоритмом SIMD. Он пригоден для очень большого числа потока и возможно
  // более хорош чем данный код. 
bool my_version_gauss1(doublereal** &Amatr, integer nodesmatr, doublereal* &bmatr, doublereal* &xmatr, bool bparallel, integer id) {

	// если bparallel==true то параллельный режим работы иначе серийный.
	// можно использовать как то так и другой код они оба правильные.

	integer i = 0, j = 0, k = 0; // счётчики цикла for
	const doublereal epsilon = 1e-30;
	doublereal M, sum, akk;

	//omp_set_num_threads(inumcore); // установка числа потоков

	// приведение к треугольному виду:
	for (k = 0; k<nodesmatr; k++) {
		akk = Amatr[k][k];
		if (fabs(akk)<epsilon) {
			// решение не может быть получено, т.к.
			// на диагонали находится ноль.
			// Это может возникнуть в случае линейно зависимой системы.
#if doubleintprecision == 1
			printf("\nSolution is not exist! Gauss divizion by zero...k=%lld akk=%e id=%lld\n", k, akk, id);
#else
			printf("\nSolution is not exist! Gauss divizion by zero...k=%d akk=%e id=%d\n", k, akk, id);
#endif
			
			for (integer j1 = 0; j1 < nodesmatr; j1++) {
				for (integer j2 = 0; j2 < nodesmatr; j2++) {
					printf("%e ",Amatr[j1][j2]);
				}
				printf("%e ", bmatr[j1]);
				printf("\n");
			}
			getchar();
			//system("pause");
			//exit(0);
			return false;
		}

		if (bparallel) {
#pragma omp parallel for shared(k, nodesmatr, Amatr, bmatr) private(i,j,M) firstprivate(akk)
			for (i = k + 1; i<nodesmatr; i++) {

				M = Amatr[i][k] / akk;
				for (j = k; j<nodesmatr; j++) {
					Amatr[i][j] -= M * Amatr[k][j];
				}
				bmatr[i] -= M*bmatr[k];
			}
		}
		else {
			for (i = k + 1; i<nodesmatr; i++) {

				M = Amatr[i][k] / akk;
				for (j = k; j<nodesmatr; j++) {
					Amatr[i][j] -= M * Amatr[k][j];
				}
				bmatr[i] -= M*bmatr[k];
			}
		}
	}
	// процесс обратного исключения
	xmatr[nodesmatr - 1] = bmatr[nodesmatr - 1] / Amatr[nodesmatr - 1][nodesmatr - 1];
	for (i = nodesmatr - 2; i >= 0; i--) {
		sum = 0.0;
		if (bparallel) {
#pragma omp parallel for shared(Amatr,xmatr,i,nodesmatr) private(j) reduction (+: sum)
			for (j = i + 1; j<nodesmatr; j++) {
				sum += Amatr[i][j] * xmatr[j];
			}
		}
		else {
			for (j = i + 1; j<nodesmatr; j++) {
				sum += Amatr[i][j] * xmatr[j];
			}
		}
		xmatr[i] = (bmatr[i] - sum) / Amatr[i][i];
		if (xmatr[i] != xmatr[i]) return false;
	}
	return true;
} // my_version_gauss1



  // данная параллельная версия метода гаусса не даёт отличий от серийной версии
  // Это было проверено массовым тестированием (см. код eqsolve_simple_gauss).
  // Данная версия правильная.
  // Существует еще одна версия параллельной программы. В книге Анализ алгоритмов вводный курс
  // есть параллельный алгоритмом SIMD. Он пригоден для очень большого числа потока и возможно
  // более хорош чем данный код. 
bool my_version_gauss2(doublereal **A, integer nodes, doublereal *b, doublereal* &x, bool bparallel) {

	// если bparallel==true то параллельный режим работы иначе серийный.
	// можно использовать как то так и другой код они оба правильные.

	integer i = 0, j = 0, k = 0; // счётчики цикла for
	const doublereal epsilon = 1e-30;
	doublereal M, sum, akk;

	//omp_set_num_threads(inumcore); // установка числа потоков

	// приведение к треугольному виду:
	for (k = 0; k<nodes; k++) {
		akk = A[k][k];
		if (fabs(akk)<epsilon) {
			// решение не может быть получено, т.к.
			// на диагонали находится ноль.
#if doubleintprecision == 1
			printf("\nSolution is not exist! Gauss divizion by zero...k=%lld akk=%e\n", k, akk);
#else
			printf("\nSolution is not exist! Gauss divizion by zero...k=%d akk=%e\n", k, akk);
#endif
			
			  getchar();
			//system("pause");
			//exit(0);
			return false;
		}

		if (bparallel) {
#pragma omp parallel for shared(k, nodes, A, b) private(i,j,M) firstprivate(akk)
			for (i = k + 1; i<nodes; i++) {

				M = A[i][k] / akk;
				for (j = k; j<nodes; j++) {
					A[i][j] -= M * A[k][j];
				}
				b[i] -= M*b[k];
			}
		}
		else {
			for (i = k + 1; i<nodes; i++) {

				M = A[i][k] / akk;
				for (j = k; j<nodes; j++) {
					A[i][j] -= M * A[k][j];
				}
				b[i] -= M*b[k];
			}
		}
	}
	// процесс обратного исключения
	x[nodes - 1] = b[nodes - 1] / A[nodes - 1][nodes - 1];
	for (i = nodes - 2; i >= 0; i--) {
		sum = 0.0;
		if (bparallel) {
#pragma omp parallel for shared(A,x,i,nodes) private(j) reduction (+: sum)
			for (j = i + 1; j<nodes; j++) {
				sum += A[i][j] * x[j];
			}
		}
		else {
			for (j = i + 1; j<nodes; j++) {
				sum += A[i][j] * x[j];
			}
		}
		x[i] = (b[i] - sum) / A[i][i];
		if (x[i] != x[i]) return false;
	}
	return true;
} // my_version_gauss2

// Экспорт в программу техплот температуры.
//С АЛИС сетки.
void ANES_tecplot360_export_temperature(integer maxnod, TOCHKA* pa,
	integer maxelm, integer** nvtx, doublereal* potent, TEMPER &t, integer i_754) {

	// 2 ноября 2016. машинное эпсилон.
	//doublereal eps_mashine = 1.0e-44; // float
	doublereal eps_mashine = 1.0e-308; // double


	// nvtx && pa сформированы, можно экспортировать в tecplot360
	FILE *fp_4 = NULL;
	errno_t err_4;
	if (i_754 == 1) {
		err_4 = fopen_s(&fp_4, "ALICEFLOW0_07_temp_apparat_hot.PLT", "w");
	}
	else {
		err_4 = fopen_s(&fp_4, "ALICEFLOW0_07_temp.PLT", "w");
	}

	if ((err_4) != 0) {
		printf("Create File temp Error\n");
		//getchar();
		system("pause");

	}
	else {

		fprintf(fp_4, "TITLE = \"ALICEFLOW0_24\"\n");
		fprintf(fp_4, "VARIABLES = x, y, z, Temp, Lam, log10_heat_flux_X, log10_heat_flux_Y, log10_heat_flux_Z, log10_heat_flux_mag, total_deformation, x_deformation, y_deformation, z_deformation\n");
#if doubleintprecision == 1
		fprintf(fp_4, "ZONE T=\"Rampant\", N=%lld, E=%lld, ET=BRICK, F=FEBLOCK\n\n", maxnod, maxelm);
#else
		fprintf(fp_4, "ZONE T=\"Rampant\", N=%d, E=%d, ET=BRICK, F=FEBLOCK\n\n", maxnod, maxelm);
#endif
		
		// запись x
		for (integer i = 0; i < maxnod; i++) {
			fprintf(fp_4, "%+.16f ", pa[i].x);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");
		// запись y
		for (integer i = 0; i < maxnod; i++) {
			fprintf(fp_4, "%+.16f ", pa[i].y);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");
		// запись z
		for (integer i = 0; i < maxnod; i++) {
			fprintf(fp_4, "%+.16f ", pa[i].z);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");
		doublereal* temp = new doublereal[maxnod];
		doublereal* lam = new doublereal[maxnod];
		doublereal* vol = new doublereal[maxnod];
		doublereal* heat_flux_X = new doublereal[maxnod];
		doublereal* heat_flux_Y = new doublereal[maxnod];
		doublereal* heat_flux_Z = new doublereal[maxnod];
		doublereal* heat_flux_mag = new doublereal[maxnod];

		for (integer i = 0; i < maxnod; i++) {
			temp[i] = 0.0;
			vol[i] = 0.0;
			lam[i] = 0.0;
			heat_flux_X[i] = 0.0;
			heat_flux_Y[i] = 0.0;
			heat_flux_Z[i] = 0.0;
			heat_flux_mag[i] = 0.0;
		}
		/*
		// Здесь мы ловим конкретную исключительную ситуацию.
		bool bfound = false;
		for (integer i = 0; i <= maxelm - 1; i++) {
			for (integer j = 0; j <= 7; j++) {
				if (nvtx[j][i] - 1 == 69462) bfound = true;
				if (nvtx[j][i] - 1 == 69463) bfound = true;
				if (nvtx[j][i] - 1 == 69464) bfound = true;
				if (nvtx[j][i] - 1 == 69477) bfound = true;
				if (nvtx[j][i] - 1 == 69478) bfound = true;
			}
		}
		if (bfound) {
			printf("bfound\n");
		}
		else
		{
			printf("notfound\n");
		}
		*/

		if (0) {
			// Метод нулевого порядка.

			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}
			}
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {
					temp[i] = temp[i] / vol[i];
				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif
					
					//getchar();
					system("PAUSE");
					temp[i] = 0.0;
				}
			}
		}
		else if (0) {

			// Метод линейного порядка.
			doublereal min_x = 1e60;
			doublereal min_y = 1e60;
			doublereal min_z = 1e60;
			doublereal max_x = -1e60;
			doublereal max_y = -1e60;
			doublereal max_z = -1e60;

			for (integer i = 0; i < maxnod; i++) {
				if (pa[i].x < min_x) {
					min_x=pa[i].x;
				}
				if (pa[i].y < min_y) {
					min_y = pa[i].y;
				}
				if (pa[i].z < min_z) {
					min_z = pa[i].z;
				}
				if (pa[i].x > max_x) {
					max_x = pa[i].x;
				}
				if (pa[i].y > max_y) {
					max_y = pa[i].y;
				}
				if (pa[i].z > max_z) {
					max_z = pa[i].z;
				}
			}

			//min_x *= 1.2;
			//min_y *= 1.2;
			//min_z *= 1.2;

			

			min_x = 1.05*fabs(max_x - min_x);
			if (min_x < 1.0e-30) {
				min_x = 1.05*fabs(max_x);
			}
			min_y = 1.05*fabs(max_y - min_y);
			if (min_y < 1.0e-30) {
				min_y = 1.05*fabs(max_y);
			}
			min_z = 1.05*fabs(max_z - min_z);
			if (min_z < 1.0e-30) {
				min_z = 1.05*fabs(max_z);
			}


			/*
			if (min_x < 1.0e-30) {
				printf("error!!! negative min_x MNK!\n");
				printf("min_x=%e max_x=%e\n",min_x,max_x);
			}
			if (min_y < 1.0e-30) {
				printf("error!!! negative min_y MNK!\n");
				printf("min_y=%e max_y=%e\n", min_y, max_y);
			}
			if (min_z < 1.0e-30) {
				printf("error!!! negative min_z MNK!\n");
				printf("min_z=%e max_z=%e\n", min_z, max_z);
			}
			*/

			integer* inum_now = new integer[maxnod];

			for (integer i = 0; i < maxnod; i++) {
				temp[i] = 0.0;
				vol[i] = 0.0;
				inum_now[i] = 0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				for (integer j = 0; j <= 7; j++) {
					inum_now[nvtx[j][i] - 1] += 1;
				}
			}

			for (integer i = 0; i < maxnod; i++) {
				if (inum_now[i] < 1) {
#if doubleintprecision == 1
					printf("i=%lld maxnod=%lld inum_now[%lld]=%lld\n", i, maxnod, i, inum_now[i]);
#else
					printf("i=%d maxnod=%d inum_now[%d]=%d\n", i, maxnod, i, inum_now[i]);
#endif
					
					getchar();
				}
			}

			TOCHKA** pointerlist = new TOCHKA*[maxnod];
			doublereal** rthdsd_Gauss = new doublereal*[maxnod];
			for (integer i = 0; i < maxnod; i++) {
				pointerlist[i] = new TOCHKA[(inum_now[i])];
				rthdsd_Gauss[i] = new doublereal[(inum_now[i])];
			}

		
			for (integer i = 0; i < maxnod; i++) {
				inum_now[i] = 0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}

				TOCHKA p;
				center_cord3D(i, nvtx, pa, p, 100);
				p.x = p.x + min_x;
				p.y = p.y + min_y;
				p.z = p.z + min_z;

				
				for (integer j = 0; j <= 7; j++) {
					pointerlist[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = p;
					if (fabs(p.x) < 1.0e-30) {
						printf("problem x=%e\n",p.x);
						getchar();
					}
					if (fabs(p.y) < 1.0e-30) {
						printf("problem y=%e\n",p.y);
						getchar();
					}
					if (fabs(p.z) < 1.0e-30) {
						printf("problem z=%e\n",p.z);
						getchar();
					}
					rthdsd_Gauss[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = potent[i];
					inum_now[nvtx[j][i] - 1]++;
				}


				/*
				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}
				*/
			}
			

			//integer jcontrol = 0;
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {
					

					doublereal** Xmatr = new doublereal*[4];
					for (integer j = 0; j <= 3; j++) {
						Xmatr[j] = new doublereal[4];
					}


					doublereal* bmatr = new doublereal[4];
					doublereal* koefmatr = new doublereal[4];

					for (integer j1 = 0; j1 <= 3; j1++) {
						for (integer j2 = 0; j2 <= 3; j2++) {
							Xmatr[j1][j2] = 0.0;
						}
						bmatr[j1] = 0.0;
						koefmatr[j1] = 0.0;
					}

					

					for (integer j = 0; j < inum_now[i]; j++) {
						
						Xmatr[0][0] += 1.0; 
						Xmatr[0][1] += pointerlist[i][j].x;
						Xmatr[0][2] += pointerlist[i][j].y;
						Xmatr[0][3] += pointerlist[i][j].z;

						Xmatr[1][0] += pointerlist[i][j].x;
						Xmatr[1][1] += pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[1][2] += pointerlist[i][j].x*pointerlist[i][j].y;
						Xmatr[1][3] += pointerlist[i][j].x*pointerlist[i][j].z;
						
						Xmatr[2][0] += pointerlist[i][j].y;
						Xmatr[2][1] += pointerlist[i][j].y*pointerlist[i][j].x;
						Xmatr[2][2] += pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[2][3] += pointerlist[i][j].y*pointerlist[i][j].z;

						Xmatr[3][0] += pointerlist[i][j].z;
						Xmatr[3][1] += pointerlist[i][j].z*pointerlist[i][j].x;
						Xmatr[3][2] += pointerlist[i][j].z*pointerlist[i][j].y;
						Xmatr[3][3] += pointerlist[i][j].z*pointerlist[i][j].z;

						bmatr[0] += rthdsd_Gauss[i][j];
						bmatr[1] += pointerlist[i][j].x*rthdsd_Gauss[i][j];
						bmatr[2] += pointerlist[i][j].y*rthdsd_Gauss[i][j];
						bmatr[3] += pointerlist[i][j].z*rthdsd_Gauss[i][j];
						
						/*
						Xmatr[0][0] += 1.0;
						Xmatr[0][1] += pointerlist[i][j].x-min_x;
						Xmatr[0][2] += pointerlist[i][j].y-min_y;
						Xmatr[0][3] += pointerlist[i][j].z-min_z;

						Xmatr[1][0] += pointerlist[i][j].x-min_x;
						Xmatr[1][1] += (pointerlist[i][j].x-min_x)*(pointerlist[i][j].x-min_x);
						Xmatr[1][2] += (pointerlist[i][j].x-min_x)*(pointerlist[i][j].y-min_y);
						Xmatr[1][3] += (pointerlist[i][j].x-min_x)*(pointerlist[i][j].z-min_z);

						Xmatr[2][0] += pointerlist[i][j].y-min_y;
						Xmatr[2][1] += (pointerlist[i][j].y-min_y)*(pointerlist[i][j].x-min_x);
						Xmatr[2][2] += (pointerlist[i][j].y-min_y)*(pointerlist[i][j].y-min_y);
						Xmatr[2][3] += (pointerlist[i][j].y-min_y)*(pointerlist[i][j].z-min_z);

						Xmatr[3][0] += (pointerlist[i][j].z-min_z);
						Xmatr[3][1] += (pointerlist[i][j].z-min_z)*(pointerlist[i][j].x-min_x);
						Xmatr[3][2] += (pointerlist[i][j].z-min_z)*(pointerlist[i][j].y-min_y);
						Xmatr[3][3] += (pointerlist[i][j].z-min_z)*(pointerlist[i][j].z-min_z);

						bmatr[0] += rthdsd_Gauss[i][j];
						bmatr[1] += (pointerlist[i][j].x-min_x)*rthdsd_Gauss[i][j];
						bmatr[2] += (pointerlist[i][j].y-min_y)*rthdsd_Gauss[i][j];
						bmatr[3] += (pointerlist[i][j].z-min_z)*rthdsd_Gauss[i][j];
						*/
					}

					if ((fabs(Xmatr[0][0]) < 1.e-30) || (fabs(Xmatr[1][1]) < 1.e-30) || (fabs(Xmatr[2][2]) < 1.e-30) || (fabs(Xmatr[3][3]) < 1.e-30)) {
#if doubleintprecision == 1
						printf("inum_now[%lld]=%lld\n", i, inum_now[i]);
#else
						printf("inum_now[%d]=%d\n", i, inum_now[i]);
#endif
						
						getchar();
					}
				
					//Xmatr*koefmatr = bmatr;
					/*
					if (!my_version_gauss1(Xmatr, 4, bmatr, koefmatr, false, i)) {
						temp[i] = temp[i] / vol[i];
					}
					else {
						temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x+min_x) + koefmatr[2] * (pa[i].y+min_y) + koefmatr[3] * (pa[i].z+min_z);
					}
					*/
					for (integer j1 = 0; j1 <= 100; j1++) {
						koefmatr[0] = (bmatr[0] - Xmatr[0][1]*koefmatr[1] - Xmatr[0][2]*koefmatr[2] - Xmatr[0][3]*koefmatr[3])/ Xmatr[0][0];
						koefmatr[1] = (bmatr[1] - Xmatr[1][0] * koefmatr[0] - Xmatr[1][2] * koefmatr[2] - Xmatr[1][3] * koefmatr[3]) / Xmatr[1][1];
						koefmatr[2] = (bmatr[2] - Xmatr[2][0] * koefmatr[0] - Xmatr[2][1] * koefmatr[1] - Xmatr[2][3] * koefmatr[3]) / Xmatr[2][2];
						koefmatr[3] = (bmatr[3] - Xmatr[3][0] * koefmatr[0] - Xmatr[3][1] * koefmatr[1] - Xmatr[3][2] * koefmatr[2]) / Xmatr[3][3];
					}
					temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z);
					heat_flux_X[i] = koefmatr[1];
					heat_flux_Y[i] = koefmatr[2];
					heat_flux_Z[i] = koefmatr[3];


					for (integer j = 0; j <= 3; j++) {
						delete[] Xmatr[j];
					}
					delete[] Xmatr;
					delete[] bmatr;
					delete[] koefmatr;

				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif
					
					//getchar();
					system("PAUSE");
					temp[i] = 0.0;
				}
			}

			

			delete[] inum_now;
			for (integer i = 0; i < maxnod; i++) {
				delete[] pointerlist[i];
				delete[] rthdsd_Gauss[i];
			}
			delete[] pointerlist;
			delete[] rthdsd_Gauss;
		}
		else if (0) {

			// Метод второго порядка.
			doublereal min_x = 1e60;
			doublereal min_y = 1e60;
			doublereal min_z = 1e60;
			doublereal max_x = -1e60;
			doublereal max_y = -1e60;
			doublereal max_z = -1e60;

			for (integer i = 0; i < maxnod; i++) {
				if (pa[i].x < min_x) {
					min_x = pa[i].x;
				}
				if (pa[i].y < min_y) {
					min_y = pa[i].y;
				}
				if (pa[i].z < min_z) {
					min_z = pa[i].z;
				}
				if (pa[i].x > max_x) {
					max_x = pa[i].x;
				}
				if (pa[i].y > max_y) {
					max_y = pa[i].y;
				}
				if (pa[i].z > max_z) {
					max_z = pa[i].z;
				}
			}

			//min_x *= 1.2;
			//min_y *= 1.2;
			//min_z *= 1.2;

			

			min_x = 1.05*fabs(max_x - min_x);
			if (min_x < 1.0e-30) {
				min_x = 1.05*fabs(max_x);
			}
			min_y = 1.05*fabs(max_y - min_y);
			if (min_y < 1.0e-30) {
				min_y = 1.05*fabs(max_y);
			}
			min_z = 1.05*fabs(max_z - min_z);
			if (min_z < 1.0e-30) {
				min_z = 1.05*fabs(max_z);
			}


			/*
			if (min_x < 1.0e-30) {
				printf("error!!! negative min_x MNK!\n");
				printf("min_x=%e max_x=%e\n", min_x, max_x);
			}
			if (min_y < 1.0e-30) {
				printf("error!!! negative min_y MNK!\n");
				printf("min_y=%e max_y=%e\n", min_y, max_y);
			}
			if (min_z < 1.0e-30) {
				printf("error!!! negative min_z MNK!\n");
				printf("min_z=%e max_z=%e\n", min_z, max_z);
			}
			*/

			integer* inum_now = new integer[maxnod];

			for (integer i = 0; i < maxnod; i++) {
				temp[i] = 0.0;
				vol[i] = 0.0;
				inum_now[i] = 0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				for (integer j = 0; j <= 7; j++) {
					inum_now[nvtx[j][i] - 1] += 1;
				}
			}

			for (integer i = 0; i < maxnod; i++) {
				if (inum_now[i] < 1) {
#if doubleintprecision == 1
					printf("i=%lld maxnod=%lld inum_now[%lld]=%lld\n", i, maxnod, i, inum_now[i]);
#else
					printf("i=%d maxnod=%d inum_now[%d]=%d\n", i, maxnod, i, inum_now[i]);
#endif
					
					getchar();
				}
			}

			TOCHKA** pointerlist = new TOCHKA*[maxnod];
			doublereal** rthdsd_Gauss = new doublereal*[maxnod];
			for (integer i = 0; i < maxnod; i++) {
				pointerlist[i] = new TOCHKA[(inum_now[i])];
				rthdsd_Gauss[i] = new doublereal[(inum_now[i])];
			}


			for (integer i = 0; i < maxnod; i++) {
				inum_now[i] = 0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}

				TOCHKA p;
				center_cord3D(i, nvtx, pa, p, 100);
				p.x = p.x + min_x;
				p.y = p.y + min_y;
				p.z = p.z + min_z;


				for (integer j = 0; j <= 7; j++) {
					pointerlist[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = p;
					if (fabs(p.x) < 1.0e-30) {
						printf("problem x=%e\n", p.x);
						getchar();
					}
					if (fabs(p.y) < 1.0e-30) {
						printf("problem y=%e\n", p.y);
						getchar();
					}
					if (fabs(p.z) < 1.0e-30) {
						printf("problem z=%e\n", p.z);
						getchar();
					}
					rthdsd_Gauss[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = potent[i];
					inum_now[nvtx[j][i] - 1]++;
				}


				/*
				for (integer j = 0; j <= 7; j++) {
				vol[nvtx[j][i] - 1] += dx*dy*dz;
				temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}
				*/
			}


			//integer jcontrol = 0;
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {


					doublereal** Xmatr = new doublereal*[7];
					for (integer j = 0; j <= 6; j++) {
						Xmatr[j] = new doublereal[7];
					}


					doublereal* bmatr = new doublereal[7];
					doublereal* koefmatr = new doublereal[7];

					for (integer j1 = 0; j1 <= 6; j1++) {
						for (integer j2 = 0; j2 <= 6; j2++) {
							Xmatr[j1][j2] = 0.0;
						}
						bmatr[j1] = 0.0;
						koefmatr[j1] = 0.0;
					}



					for (integer j = 0; j < inum_now[i]; j++) {

						Xmatr[0][0] += 1.0;
						Xmatr[0][1] += pointerlist[i][j].x;
						Xmatr[0][2] += pointerlist[i][j].y;
						Xmatr[0][3] += pointerlist[i][j].z;
						Xmatr[0][4] += pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[0][5] += pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[0][6] += pointerlist[i][j].z*pointerlist[i][j].z;

						Xmatr[1][0] += pointerlist[i][j].x;
						Xmatr[1][1] += pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[1][2] += pointerlist[i][j].x*pointerlist[i][j].y;
						Xmatr[1][3] += pointerlist[i][j].x*pointerlist[i][j].z;
						Xmatr[1][4] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[1][5] += pointerlist[i][j].x*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[1][6] += pointerlist[i][j].x*pointerlist[i][j].z*pointerlist[i][j].z;

						Xmatr[2][0] += pointerlist[i][j].y;
						Xmatr[2][1] += pointerlist[i][j].y*pointerlist[i][j].x;
						Xmatr[2][2] += pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[2][3] += pointerlist[i][j].y*pointerlist[i][j].z;
						Xmatr[2][4] += pointerlist[i][j].y*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[2][5] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[2][6] += pointerlist[i][j].y*pointerlist[i][j].z*pointerlist[i][j].z;

						Xmatr[3][0] += pointerlist[i][j].z;
						Xmatr[3][1] += pointerlist[i][j].z*pointerlist[i][j].x;
						Xmatr[3][2] += pointerlist[i][j].z*pointerlist[i][j].y;
						Xmatr[3][3] += pointerlist[i][j].z*pointerlist[i][j].z;
						Xmatr[3][4] += pointerlist[i][j].z*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[3][5] += pointerlist[i][j].z*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[3][6] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].z;

						Xmatr[4][0] += pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[4][1] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[4][2] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].y;
						Xmatr[4][3] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].z;
						Xmatr[4][4] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[4][5] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[4][6] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].z*pointerlist[i][j].z;

						Xmatr[5][0] += pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[5][1] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].x;
						Xmatr[5][2] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[5][3] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].z;
						Xmatr[5][4] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[5][5] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[5][6] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].z*pointerlist[i][j].z;

						Xmatr[6][0] += pointerlist[i][j].z*pointerlist[i][j].z;
						Xmatr[6][1] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].x;
						Xmatr[6][2] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].y;
						Xmatr[6][3] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].z;
						Xmatr[6][4] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[6][5] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[6][6] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].z;

						bmatr[0] += rthdsd_Gauss[i][j];
						bmatr[1] += pointerlist[i][j].x*rthdsd_Gauss[i][j];
						bmatr[2] += pointerlist[i][j].y*rthdsd_Gauss[i][j];
						bmatr[3] += pointerlist[i][j].z*rthdsd_Gauss[i][j];
						bmatr[4] += pointerlist[i][j].x*pointerlist[i][j].x*rthdsd_Gauss[i][j];
						bmatr[5] += pointerlist[i][j].y*pointerlist[i][j].y*rthdsd_Gauss[i][j];
						bmatr[6] += pointerlist[i][j].z*pointerlist[i][j].z*rthdsd_Gauss[i][j];

					
					}

					if ((fabs(Xmatr[0][0]) < 1.e-30) || (fabs(Xmatr[1][1]) < 1.e-30) || (fabs(Xmatr[2][2]) < 1.e-30) || (fabs(Xmatr[3][3]) < 1.e-30)
						|| (fabs(Xmatr[4][4]) < 1.e-30) || (fabs(Xmatr[5][5]) < 1.e-30) || (fabs(Xmatr[6][6]) < 1.e-30)) {
#if doubleintprecision == 1
						printf("inum_now[%lld]=%lld\n", i, inum_now[i]);
#else
						printf("inum_now[%d]=%d\n", i, inum_now[i]);
#endif
						
						getchar();
					}

					//Xmatr*koefmatr = bmatr;
					/*
					if (!my_version_gauss1(Xmatr, 4, bmatr, koefmatr, false, i)) {
					temp[i] = temp[i] / vol[i];
					}
					else {
					temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x+min_x) + koefmatr[2] * (pa[i].y+min_y) + koefmatr[3] * (pa[i].z+min_z);
					}
					*/
					for (integer j1 = 0; j1 <= 2000; j1++) {
						koefmatr[0] = (bmatr[0] - Xmatr[0][1] * koefmatr[1] - Xmatr[0][2] * koefmatr[2] - Xmatr[0][3] * koefmatr[3] - Xmatr[0][4] * koefmatr[4] - Xmatr[0][5] * koefmatr[5] - Xmatr[0][6] * koefmatr[6]) / Xmatr[0][0];
						koefmatr[1] = (bmatr[1] - Xmatr[1][0] * koefmatr[0] - Xmatr[1][2] * koefmatr[2] - Xmatr[1][3] * koefmatr[3] - Xmatr[1][4] * koefmatr[4] - Xmatr[1][5] * koefmatr[5] - Xmatr[1][6] * koefmatr[6]) / Xmatr[1][1];
						koefmatr[2] = (bmatr[2] - Xmatr[2][0] * koefmatr[0] - Xmatr[2][1] * koefmatr[1] - Xmatr[2][3] * koefmatr[3] - Xmatr[2][4] * koefmatr[4] - Xmatr[2][5] * koefmatr[5] - Xmatr[2][6] * koefmatr[6]) / Xmatr[2][2];
						koefmatr[3] = (bmatr[3] - Xmatr[3][0] * koefmatr[0] - Xmatr[3][1] * koefmatr[1] - Xmatr[3][2] * koefmatr[2] - Xmatr[3][4] * koefmatr[4] - Xmatr[3][5] * koefmatr[5] - Xmatr[3][6] * koefmatr[6]) / Xmatr[3][3];
						koefmatr[4] = (bmatr[4] - Xmatr[4][0] * koefmatr[0] - Xmatr[4][1] * koefmatr[1] - Xmatr[4][2] * koefmatr[2] - Xmatr[4][3] * koefmatr[3] - Xmatr[4][5] * koefmatr[5] - Xmatr[4][6] * koefmatr[6]) / Xmatr[4][4];
						koefmatr[5] = (bmatr[5] - Xmatr[5][0] * koefmatr[0] - Xmatr[5][1] * koefmatr[1] - Xmatr[5][2] * koefmatr[2] - Xmatr[5][4] * koefmatr[4] - Xmatr[5][3] * koefmatr[3] - Xmatr[5][6] * koefmatr[6]) / Xmatr[5][5];
						koefmatr[6] = (bmatr[6] - Xmatr[6][0] * koefmatr[0] - Xmatr[6][1] * koefmatr[1] - Xmatr[6][2] * koefmatr[2] - Xmatr[6][4] * koefmatr[4] - Xmatr[6][5] * koefmatr[5] - Xmatr[6][3] * koefmatr[3]) / Xmatr[6][6];
					}
					temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z) + koefmatr[4] * (pa[i].x + min_x)*(pa[i].x + min_x) + koefmatr[5] * (pa[i].y + min_y) * (pa[i].y + min_y) + koefmatr[6] * (pa[i].z + min_z) * (pa[i].z + min_z);
					heat_flux_X[i] = koefmatr[1] + 2.0*koefmatr[4] * (pa[i].x + min_x);
					heat_flux_Y[i] = koefmatr[2] + 2.0*koefmatr[5] * (pa[i].y + min_y);
					heat_flux_Z[i] = koefmatr[3] + 2.0*koefmatr[6] * (pa[i].z + min_z);


					for (integer j = 0; j <= 6; j++) {
						delete[] Xmatr[j];
					}
					delete[] Xmatr;
					delete[] bmatr;
					delete[] koefmatr;

				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif
					
					//getchar();
					system("PAUSE");
					temp[i] = 0.0;
				}
			}



			delete[] inum_now;
			for (integer i = 0; i < maxnod; i++) {
				delete[] pointerlist[i];
				delete[] rthdsd_Gauss[i];
			}
			delete[] pointerlist;
			delete[] rthdsd_Gauss;
		}
		else if (1) {
			// линейная реконструкция, НО по расширенному шаблону.
			// Расширенный шаблон содержит больше опорных точек интерполляции, 
			// поэтому в теории реконструкция должна быть более точная.

			// Метод линейного порядка.
			doublereal min_x = 1e60;
			doublereal min_y = 1e60;
			doublereal min_z = 1e60;
			doublereal max_x = -1e60;
			doublereal max_y = -1e60;
			doublereal max_z = -1e60;

			for (integer i = 0; i < maxnod; i++) {
				if (pa[i].x < min_x) {
					min_x = pa[i].x;
				}
				if (pa[i].y < min_y) {
					min_y = pa[i].y;
				}
				if (pa[i].z < min_z) {
					min_z = pa[i].z;
				}
				if (pa[i].x > max_x) {
					max_x = pa[i].x;
				}
				if (pa[i].y > max_y) {
					max_y = pa[i].y;
				}
				if (pa[i].z > max_z) {
					max_z = pa[i].z;
				}
			}

			doublereal min_x1 = min_x;
			doublereal min_y1 = min_y;
			doublereal min_z1 = min_z;
			//min_x *= 1.2;
			//min_y *= 1.2;
			//min_z *= 1.2;

			// 05.07.2017
			
			min_x = 1.05*fabs(max_x - min_x);
			if (min_x < 1.0e-30) {
				min_x = 1.05*fabs(max_x);
			}
			min_y = 1.05*fabs(max_y - min_y);
			if (min_y < 1.0e-30) {
				min_y = 1.05*fabs(max_y);
			}
			min_z = 1.05*fabs(max_z - min_z);
			if (min_z < 1.0e-30) {
				min_z = 1.05*fabs(max_z);
			}

			/*
			if (min_x < 1.0e-30) {
				printf("error!!! negative min_x MNK!\n");
				printf("min_x=%e max_x=%e\n", min_x, max_x);
			}
			if (min_y < 1.0e-30) {
				printf("error!!! negative min_y MNK!\n");
				printf("min_y=%e max_y=%e\n", min_y, max_y);
			}
			if (min_z < 1.0e-30) {
				printf("error!!! negative min_z MNK!\n");
				printf("min_z=%e max_z=%e\n", min_z, max_z);
			}
			*/

			// Для ускорения сканирования в методе наименьших квадратов 8.07.2017.
			integer** q_hash = NULL;
			q_hash = new integer*[maxnod + 1];
			integer* q_ic = NULL;
			q_ic = new integer[maxnod + 1];
			for (integer j = 0; j <= maxnod; j++) {
				q_hash[j] = new integer[9];
				q_ic[j] = 0;
			}
			for (integer j = 0; j <= maxnod; j++) {
				for (integer i_1 = 0; i_1 < 9; i_1++) {
					q_hash[j][i_1] = -1;
				}
			}
			for (integer i_1 = 0; i_1 <= maxelm - 1; i_1++) {
				for (integer j_1 = 0; j_1 <= 7; j_1++) {
					q_hash[nvtx[j_1][i_1]][q_ic[nvtx[j_1][i_1]]] = i_1;
					q_ic[nvtx[j_1][i_1]]++;
				}
			}

			integer* inum_now = new integer[maxnod];

			for (integer i = 0; i < maxnod; i++) {
				temp[i] = 0.0;
				vol[i] = 0.0;
				inum_now[i] = 0;
			}

			// Идея расширения шаблона: мы рассматриваем не только текущий nvtx, но и всех
			// его соседей имеющих с ним хоть одну общую вершину. Этим самым шаблон используемый
			// для реконструкции будет расширен новыми точками.
			// Модификация 30.05.2017.
			for (integer i = 0; i <= maxelm - 1; i++) {
				if (((10 * i) % maxelm) == 0) printf("complete %d\n", (100 * i / maxelm));
				for (integer j = 0; j <= 7; j++) {
					inum_now[nvtx[j][i] - 1] += 1;
					//for (integer i_1 = 0; i_1 <= maxelm - 1; i_1++) {
					integer i_1 = -1;
					for (integer i_2 = 0; i_2<9; i_2++) {
						i_1 = q_hash[nvtx[j][i]][i_2];
						if (i_1 >= 0) {
							for (integer j_1 = 0; j_1 <= 7; j_1++) {
								if (i_1 != i) {
									if (nvtx[j][i] == nvtx[j_1][i_1]) {
										inum_now[nvtx[j][i] - 1] += 1;
									}
								}
							}
						}
					}
				}
			}

			for (integer i = 0; i < maxnod; i++) {
				if (inum_now[i] < 1) {
#if doubleintprecision == 1
					printf("i=%lld maxnod=%lld inum_now[%lld]=%lld\n", i, maxnod, i, inum_now[i]);
#else
					printf("i=%d maxnod=%d inum_now[%d]=%d\n", i, maxnod, i, inum_now[i]);
#endif
					
					getchar();
				}
			}

			TOCHKA** pointerlist = new TOCHKA*[maxnod];
			doublereal** rthdsd_Gauss = new doublereal*[maxnod];
			for (integer i = 0; i < maxnod; i++) {
				pointerlist[i] = new TOCHKA[(inum_now[i])];
				rthdsd_Gauss[i] = new doublereal[(inum_now[i])];
			}


			for (integer i = 0; i < maxnod; i++) {
				inum_now[i] = 0;
			}

			

			// Непосредственно само вычисление.
			for (integer i = 0; i <= maxelm - 1; i++) {
				if (((10 * i) % maxelm) == 0) printf("complete %d\n", (100 * i / maxelm));

				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контрольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}

				TOCHKA p;
				center_cord3D(i, nvtx, pa, p, 100);
				p.x = p.x + min_x;
				p.y = p.y + min_y;
				p.z = p.z + min_z;


				for (integer j = 0; j <= 7; j++) {
					pointerlist[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = p;
					if (fabs(p.x) < 1.0e-30) {
						printf("problem x=%e\n", p.x);
						getchar();
					}
					if (fabs(p.y) < 1.0e-30) {
						printf("problem y=%e\n", p.y);
						getchar();
					}
					if (fabs(p.z) < 1.0e-30) {
						printf("problem z=%e\n", p.z);
						getchar();
					}
					rthdsd_Gauss[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = potent[i];
					inum_now[nvtx[j][i] - 1]++;
				}


				


				for (integer j = 0; j <= 7; j++) {
					//for (integer i_1 = 0; i_1 <= maxelm - 1; i_1++) {
					integer i_1 = -1;
					for (integer i_2=0; i_2<9; i_2++) {
						i_1 = q_hash[nvtx[j][i]][i_2];
						if (i_1 >= 0) {
							for (integer j_1 = 0; j_1 <= 7; j_1++) {
								if (i_1 != i) {
									if (nvtx[j][i] == nvtx[j_1][i_1]) {
										TOCHKA p_1;
										center_cord3D(i_1, nvtx, pa, p_1, 100);
										p_1.x = p_1.x + min_x;
										p_1.y = p_1.y + min_y;
										p_1.z = p_1.z + min_z;

										pointerlist[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = p_1;
										if (fabs(p_1.x) < 1.0e-30) {
											printf("problem x=%e\n", p_1.x);
											getchar();
										}
										if (fabs(p_1.y) < 1.0e-30) {
											printf("problem y=%e\n", p_1.y);
											getchar();
										}
										if (fabs(p_1.z) < 1.0e-30) {
											printf("problem z=%e\n", p_1.z);
											getchar();
										}

										rthdsd_Gauss[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = potent[i_1];
										inum_now[nvtx[j][i] - 1]++;
									}
								}
							}
						}
					}
				}


				/*
				for (integer j = 0; j <= 7; j++) {
				vol[nvtx[j][i] - 1] += dx*dy*dz;
				temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}
				*/
			}


			for (integer j = 0; j <= maxnod; j++) {
				delete[] q_hash[j];
			}
			delete[] q_ic;
			delete[] q_hash;
			q_ic = NULL;
			q_hash = NULL;

			//integer jcontrol = 0;
			for (integer i = 0; i < maxnod; i++) {
				if (((10 * i) %  maxnod) == 0) printf("complete %d\n", (100 * i / maxnod));
				if (fabs(vol[i]) > eps_mashine) {


					doublereal** Xmatr = new doublereal*[4];
					for (integer j = 0; j <= 3; j++) {
						Xmatr[j] = new doublereal[4];
					}


					doublereal* bmatr = new doublereal[4];
					doublereal* koefmatr = new doublereal[4];

					for (integer j1 = 0; j1 <= 3; j1++) {
						for (integer j2 = 0; j2 <= 3; j2++) {
							Xmatr[j1][j2] = 0.0;
						}
						bmatr[j1] = 0.0;
						koefmatr[j1] = 0.0;
					}



					for (integer j = 0; j < inum_now[i]; j++) {

						Xmatr[0][0] += 1.0;
						Xmatr[0][1] += pointerlist[i][j].x;
						Xmatr[0][2] += pointerlist[i][j].y;
						Xmatr[0][3] += pointerlist[i][j].z;

						Xmatr[1][0] += pointerlist[i][j].x;
						Xmatr[1][1] += pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[1][2] += pointerlist[i][j].x*pointerlist[i][j].y;
						Xmatr[1][3] += pointerlist[i][j].x*pointerlist[i][j].z;

						Xmatr[2][0] += pointerlist[i][j].y;
						Xmatr[2][1] += pointerlist[i][j].y*pointerlist[i][j].x;
						Xmatr[2][2] += pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[2][3] += pointerlist[i][j].y*pointerlist[i][j].z;

						Xmatr[3][0] += pointerlist[i][j].z;
						Xmatr[3][1] += pointerlist[i][j].z*pointerlist[i][j].x;
						Xmatr[3][2] += pointerlist[i][j].z*pointerlist[i][j].y;
						Xmatr[3][3] += pointerlist[i][j].z*pointerlist[i][j].z;

						bmatr[0] += rthdsd_Gauss[i][j];
						bmatr[1] += pointerlist[i][j].x*rthdsd_Gauss[i][j];
						bmatr[2] += pointerlist[i][j].y*rthdsd_Gauss[i][j];
						bmatr[3] += pointerlist[i][j].z*rthdsd_Gauss[i][j];
						
					}

					if ((fabs(Xmatr[0][0]) < 1.e-30) || (fabs(Xmatr[1][1]) < 1.e-30) || (fabs(Xmatr[2][2]) < 1.e-30) || (fabs(Xmatr[3][3]) < 1.e-30)) {
#if doubleintprecision == 1
						printf("inum_now[%lld]=%lld\n", i, inum_now[i]);
#else
						printf("inum_now[%d]=%d\n", i, inum_now[i]);
#endif
						
						getchar();
					}

					//Xmatr*koefmatr = bmatr;
					/*
					// Метод Гаусса не работает т.к. система линейно зависима.
					if (!my_version_gauss1(Xmatr, 4, bmatr, koefmatr, false, i)) {
					temp[i] = temp[i] / vol[i];
					}
					else {
					temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x+min_x) + koefmatr[2] * (pa[i].y+min_y) + koefmatr[3] * (pa[i].z+min_z);
					}
					*/
					for (integer j1 = 0; j1 <= 3; j1++) {
						koefmatr[j1] = 0.0;
					}
					for (integer j1 = 0; j1 <= 250; j1++) {
						doublereal alpha = 0.2;
						doublereal d_0 = koefmatr[0];
						doublereal d_1 = koefmatr[1];
						doublereal d_2 = koefmatr[2];
						doublereal d_3 = koefmatr[3];
						koefmatr[0] = (1.0 - alpha)*d_0 + alpha*((bmatr[0] - Xmatr[0][1] * koefmatr[1] - Xmatr[0][2] * koefmatr[2] - Xmatr[0][3] * koefmatr[3]) / Xmatr[0][0]);
						koefmatr[1] = (1.0 - alpha)*d_1 + alpha*((bmatr[1] - Xmatr[1][0] * koefmatr[0] - Xmatr[1][2] * koefmatr[2] - Xmatr[1][3] * koefmatr[3]) / Xmatr[1][1]);
						koefmatr[2] = (1.0 - alpha)*d_2 + alpha*((bmatr[2] - Xmatr[2][0] * koefmatr[0] - Xmatr[2][1] * koefmatr[1] - Xmatr[2][3] * koefmatr[3]) / Xmatr[2][2]);
						koefmatr[3] = (1.0 - alpha)*d_3 + alpha*((bmatr[3] - Xmatr[3][0] * koefmatr[0] - Xmatr[3][1] * koefmatr[1] - Xmatr[3][2] * koefmatr[2]) / Xmatr[3][3]);
					}
					temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z);
					//temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x ) + koefmatr[2] * (pa[i].y ) + koefmatr[3] * (pa[i].z );
					heat_flux_X[i] = koefmatr[1];
					heat_flux_Y[i] = koefmatr[2];
					heat_flux_Z[i] = koefmatr[3];
					//heat_flux_X[i] = 0.0;
					//heat_flux_Y[i] = 0.0;
					//heat_flux_Z[i] = 0.0;
					// вычисление размеров текущего контрольного объёма:
					/*
					doublereal h_1= 1.0e-4*(max_x-min_x1);
					h_1 = pow(fabs(vol[i]), 0.333);
					//h_1 = 0.5*dx1;
					heat_flux_X[i] = ((koefmatr[0] + koefmatr[1] * (pa[i].x + min_x+h_1) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z)
					)-(koefmatr[0] + koefmatr[1] * (pa[i].x + min_x-h_1) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z)
					)) / (2 * h_1);
					//h_1 = 1.0e-4*(max_y - min_y1);
					//h_1 = 0.5*dy1;
					heat_flux_Y[i] = ((koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y+h_1) + koefmatr[3] * (pa[i].z + min_z)
					) - (koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y-h_1) + koefmatr[3] * (pa[i].z + min_z)
					)) / (2 * h_1);
					//h_1 = 1.0e-4*(max_z - min_z1);
					//h_1 = 0.5*dz1;
					heat_flux_Z[i] = ((koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z+h_1)
					) - (koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z-h_1)
					)) / (2 * h_1);
					*/

					for (integer j = 0; j <= 3; j++) {
						delete[] Xmatr[j];
					}
					delete[] Xmatr;
					delete[] bmatr;
					delete[] koefmatr;

				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif
					
					//getchar();
					system("PAUSE");
					temp[i] = 0.0;
				}
			}



			delete[] inum_now;
			for (integer i = 0; i < maxnod; i++) {
				delete[] pointerlist[i];
				delete[] rthdsd_Gauss[i];
			}
			delete[] pointerlist;
			delete[] rthdsd_Gauss;


		}
		else {

		}
		// запись temp
		for (integer i = 0; i < maxnod; i++) {
			fprintf(fp_4, "%+.16f ", temp[i]);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");


		if (1) {
			// Метод нулевого порядка.

			for (integer i = 0; i < maxnod; i++) {
				vol[i] = 0.0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					lam[nvtx[j][i] - 1] += dx*dy*dz*t.prop[LAM][i];
				}
			}
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {
					lam[i] = lam[i] / vol[i];
				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif
					
					//getchar();
					system("PAUSE");
					temp[i] = 0.0;
				}
			}
		}
		// запись теплопроводности
		for (integer i = 0; i < maxnod; i++) {
			fprintf(fp_4, "%+.16f ", lam[i]);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");

		// запись теплового потока по Х
		for (integer i = 0; i < maxnod; i++) {
			heat_flux_X[i] *= -lam[i];
			doublereal d_1 = heat_flux_X[i];
			if (d_1 > 2.0) {
				d_1 = log10(d_1);
			}
			else if (d_1<-2.0) {
				d_1 = -log10(fabs(d_1));
			}
			else {
				d_1 = 0.0;
			}
			fprintf(fp_4, "%+.16f ", d_1);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");

		// запись теплового потока по Y
		for (integer i = 0; i < maxnod; i++) {
			heat_flux_Y[i] *= -lam[i];
			doublereal d_1 = heat_flux_Y[i];
			if (d_1 > 2.0) {
				d_1 = log10(d_1);
			}
			else if (d_1<-2.0) {
				d_1 = -log10(fabs(d_1));
			}
			else {
				d_1 = 0.0;
			}
			fprintf(fp_4, "%+.16f ", d_1);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");

		// запись теплового потока по Z
		for (integer i = 0; i < maxnod; i++) {
			heat_flux_Z[i] *= -lam[i];
			doublereal d_1 = heat_flux_Z[i];
			if (d_1 > 2.0) {
				d_1 = log10(d_1);
			}
			else if (d_1<-2.0) {
				d_1 = -log10(fabs(d_1));
			}
			else {
				d_1 = 0.0;
			}
			fprintf(fp_4, "%+.16f ", d_1);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");


		// запись модуля теплового потока
		for (integer i = 0; i < maxnod; i++) {
			doublereal d_1 = sqrt(heat_flux_X[i] * heat_flux_X[i] + heat_flux_Y[i] * heat_flux_Y[i] + heat_flux_Z[i] * heat_flux_Z[i]);
			if (d_1 > 2.0) {
				d_1 = log10(d_1);
			}
			else {
				d_1 = 0.0;
			}
			fprintf(fp_4, "%+.16f ", d_1);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");

		// TOTAL X
		if (1) {
			// Метод нулевого порядка.

			for (integer i = 0; i < maxnod; i++) {
				vol[i] = 0.0;
				lam[i] = 0.0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					lam[nvtx[j][i] - 1] += dx*dy*dz*sqrt(t.total_deformation[XDEFORMATION][i]* t.total_deformation[XDEFORMATION][i]+ t.total_deformation[YDEFORMATION][i] * t.total_deformation[YDEFORMATION][i] + t.total_deformation[ZDEFORMATION][i] * t.total_deformation[ZDEFORMATION][i]);
				}
			}
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {
					lam[i] = lam[i] / vol[i];
				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif

					//getchar();
					system("PAUSE");
					lam[i] = 0.0;
				}
			}
		}
		// запись TOTAL DEFORMATION
		for (integer i = 0; i < maxnod; i++) {
			fprintf(fp_4, "%+.16f ", lam[i]);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");

		// Deformation X
		if (1) {
			// Метод нулевого порядка.

			for (integer i = 0; i < maxnod; i++) {
				vol[i] = 0.0;
				lam[i] = 0.0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					lam[nvtx[j][i] - 1] += dx*dy*dz*t.total_deformation[XDEFORMATION][i];
				}
			}
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {
					lam[i] = lam[i] / vol[i];
				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif

					//getchar();
					system("PAUSE");
					lam[i] = 0.0;
				}
			}
		}
		// запись XDEFORMATION
		for (integer i = 0; i < maxnod; i++) {
			fprintf(fp_4, "%+.16f ", lam[i]);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");

		// Deformation Y
		if (1) {
			// Метод нулевого порядка.

			for (integer i = 0; i < maxnod; i++) {
				vol[i] = 0.0;
				lam[i] = 0.0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					lam[nvtx[j][i] - 1] += dx*dy*dz*t.total_deformation[YDEFORMATION][i];
				}
			}
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {
					lam[i] = lam[i] / vol[i];
				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif

					//getchar();
					system("PAUSE");
					lam[i] = 0.0;
				}
			}
		}
		// запись YDEFORMATION
		for (integer i = 0; i < maxnod; i++) {
			fprintf(fp_4, "%+.16f ", lam[i]);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");

		// Deformation Z
		if (1) {
			// Метод нулевого порядка.

			for (integer i = 0; i < maxnod; i++) {
				vol[i] = 0.0;
				lam[i] = 0.0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					lam[nvtx[j][i] - 1] += dx*dy*dz*t.total_deformation[ZDEFORMATION][i];
				}
			}
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {
					lam[i] = lam[i] / vol[i];
				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif

					//getchar();
					system("PAUSE");
					lam[i] = 0.0;
				}
			}
		}
		// запись ZDEFORMATION
		for (integer i = 0; i < maxnod; i++) {
			fprintf(fp_4, "%+.16f ", lam[i]);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");

		delete[] temp;
		delete[] vol;
		delete[] lam;
		delete[] heat_flux_X;
		delete[] heat_flux_Y;
		delete[] heat_flux_Z;
		delete[] heat_flux_mag;


		for (integer i = 0; i <= maxelm - 1; i++) {
#if doubleintprecision == 1

			if (1) {
				// Контрольные объёмы состоят из кубиков. Вершины 
				// каждого такого кубика должны быть перечислены в строго порядке сортировки.
				// Сортировка : упорядочивание восьмерки по возракстанию координаты z.
				// Сортировка: упорядочивание каждой четверки по возрастанию координаты y. Всего 2 четверки.
				// Сортировка четырехз двоек по возрастанию х.


				integer invtx[8];
				doublereal znvtx[8];
				doublereal ynvtx[8];
				doublereal xnvtx[8];
				for (integer j28 = 0; j28 < 8; j28++) {
					invtx[j28] = nvtx[j28][i];
					znvtx[j28] = pa[nvtx[j28][i] - 1].z;
					ynvtx[j28] = pa[nvtx[j28][i] - 1].y;
					xnvtx[j28] = pa[nvtx[j28][i] - 1].x;
				}

				// Сортировка по возрастанию z.
				for (integer i28 = 1; i28 < 8; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 0) && (znvtx[location] > znewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию y. Часть 1.
				//0,1,2,3<4
				for (integer i28 = 1; i28 < 4; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 0) && (ynvtx[location] > ynewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// 4,5,6,7<8
				// Сортировка по возрастанию y. Часть 2.
				for (integer i28 = 5; i28 < 8; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 4) && (ynvtx[location] > ynewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				//0,1<2
				//2,3<4
				//4,5<6
				//6,7<8
				// Сортировка по возрастанию X. Часть 1.
				for (integer i28 = 1; i28 < 2; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 0) && (xnvtx[location] > xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 2.
				for (integer i28 = 3; i28 < 4; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 2) && (xnvtx[location] < xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 3.
				for (integer i28 = 5; i28 < 6; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 4) && (xnvtx[location] > xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 4.
				for (integer i28 = 7; i28 < 8; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 6) && (xnvtx[location] < xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}

				fprintf(fp_4, "%lld %lld %lld %lld %lld %lld %lld %lld \n", invtx[0], invtx[1], invtx[2], invtx[3], invtx[4], invtx[5], invtx[6], invtx[7]);
				if (nvtx[0][i] < 1) printf("bad nvtx[0][%lld]=%lld", i, nvtx[0][i]);
				if (nvtx[1][i] < 1) printf("bad nvtx[1][%lld]=%lld", i, nvtx[1][i]);
				if (nvtx[2][i] < 1) printf("bad nvtx[2][%lld]=%lld", i, nvtx[2][i]);
				if (nvtx[3][i] < 1) printf("bad nvtx[3][%lld]=%lld", i, nvtx[3][i]);
				if (nvtx[4][i] < 1) printf("bad nvtx[4][%lld]=%lld", i, nvtx[4][i]);
				if (nvtx[5][i] < 1) printf("bad nvtx[5][%lld]=%lld", i, nvtx[5][i]);
				if (nvtx[6][i] < 1) printf("bad nvtx[6][%lld]=%lld", i, nvtx[6][i]);
				if (nvtx[7][i] < 1) printf("bad nvtx[7][%lld]=%lld", i, nvtx[7][i]);
			}
			else {
				fprintf(fp_4, "%lld %lld %lld %lld %lld %lld %lld %lld \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
			}
#else

			if (1) {
				integer invtx[8];
				doublereal znvtx[8];
				doublereal ynvtx[8];
				doublereal xnvtx[8];
				for (integer j28 = 0; j28 < 8; j28++) {
					invtx[j28] = nvtx[j28][i];
					znvtx[j28] = pa[nvtx[j28][i] - 1].z;
					ynvtx[j28] = pa[nvtx[j28][i] - 1].y;
					xnvtx[j28] = pa[nvtx[j28][i] - 1].x;
				}

				// Сортировка по возрастанию z.
				for (integer i28 = 1; i28 < 8; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 0) && (znvtx[location] > znewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию y. Часть 1.
				for (integer i28 = 1; i28 < 4; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 0) && (ynvtx[location] > ynewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию y. Часть 2.
				for (integer i28 = 5; i28 < 8; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 4) && (ynvtx[location] > ynewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 1.
				for (integer i28 = 1; i28 < 2; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 0) && (xnvtx[location] > xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 2.
				for (integer i28 = 3; i28 < 4; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 2) && (xnvtx[location] < xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 3.
				for (integer i28 = 5; i28 < 6; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 4) && (xnvtx[location] > xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 4.
				for (integer i28 = 7; i28 < 8; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 6) && (xnvtx[location] < xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}

				fprintf_s(fp_4, "%d %d %d %d %d %d %d %d \n", invtx[0], invtx[1], invtx[2], invtx[3], invtx[4], invtx[5], invtx[6], invtx[7]);

				//debug
				//printf("%d %d %d %d %d %d %d %d \n", invtx[0], invtx[1], invtx[2], invtx[3], invtx[4], invtx[5], invtx[6], invtx[7]);
				//printf( "%d %d %d %d %d %d %d %d \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
				//getchar();

				if (nvtx[0][i] < 1) printf("bad nvtx[0][%d]=%d", i, nvtx[0][i]);
				if (nvtx[1][i] < 1) printf("bad nvtx[1][%d]=%d", i, nvtx[1][i]);
				if (nvtx[2][i] < 1) printf("bad nvtx[2][%d]=%d", i, nvtx[2][i]);
				if (nvtx[3][i] < 1) printf("bad nvtx[3][%d]=%d", i, nvtx[3][i]);
				if (nvtx[4][i] < 1) printf("bad nvtx[4][%d]=%d", i, nvtx[4][i]);
				if (nvtx[5][i] < 1) printf("bad nvtx[5][%d]=%d", i, nvtx[5][i]);
				if (nvtx[6][i] < 1) printf("bad nvtx[6][%d]=%d", i, nvtx[6][i]);
				if (nvtx[7][i] < 1) printf("bad nvtx[7][%d]=%d", i, nvtx[7][i]);
			}
			else {
				fprintf(fp_4, "%d %d %d %d %d %d %d %d \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
			}
#endif
			
		}
		fclose(fp_4);
		//WinExec("C:\\Program Files\\Tecplot\\Tecplot 360 EX 2014 R1\\bin\\tec360.exe ALICEFLOW0_24ALICEMESH.PLT", SW_NORMAL);
	}

} // ANES_tecplot360_export_temperature

// Переинтерполляция температуры с сетки на сетку. Конкретно с АЛИС сетки на обычную сетку.
// t_buf->potent
void ALICE_2_Structural(integer maxnod, TOCHKA* pa,
	integer maxelm, integer** nvtx, doublereal* &potent,
	doublereal* &x47, doublereal* &y47, doublereal* &z47, doublereal* &temp47, integer** &nvtx47, integer &m_sizeT, integer &maxelm47) {

	// Инициализация компонент скорости во внутренности расчётной области.
	// 26 марта 2017.

	

	// Метод линейного порядка.
	doublereal min_x = 1e60;
	doublereal min_y = 1e60;
	doublereal min_z = 1e60;
	doublereal max_x = -1e60;
	doublereal max_y = -1e60;
	doublereal max_z = -1e60;

	for (integer i_48 = 0; i_48 < maxelm47; i_48++) {
		for (integer i_47 = 0; i_47 < 8; i_47++) {
			if (x47[nvtx47[i_47][i_48]] < min_x) {
				min_x = x47[nvtx47[i_47][i_48]];
			}
			if (y47[nvtx47[i_47][i_48]] < min_y) {
				min_y = y47[nvtx47[i_47][i_48]];
			}
			if (z47[nvtx47[i_47][i_48]] < min_z) {
				min_z = z47[nvtx47[i_47][i_48]];
			}
			if (x47[nvtx47[i_47][i_48]] > max_x) {
				max_x = x47[nvtx47[i_47][i_48]];
			}
			if (y47[nvtx47[i_47][i_48]] > max_y) {
				max_y = y47[nvtx47[i_47][i_48]];
			}
			if (z47[nvtx47[i_47][i_48]] > max_z) {
				max_z = z47[nvtx47[i_47][i_48]];
			}
		}
	}

	min_x = 1.05*fabs(max_x - min_x);
	if (min_x < 1.0e-40) {
		min_x = 1.05*fabs(max_x);
	}
	min_y = 1.05*fabs(max_y - min_y);
	if (min_y < 1.0e-40) {
		min_y = 1.05*fabs(max_y);
	}
	min_z = 1.05*fabs(max_z - min_z);
	if (min_z < 1.0e-40) {
		min_z = 1.05*fabs(max_z);
	}


	TOCHKA** pointerlist = new TOCHKA*[maxelm];
	doublereal** rthdsd_Gauss = new doublereal*[maxelm];
	for (integer i_47 = 0; i_47 < maxelm; i_47++) {
		pointerlist[i_47] = new TOCHKA[8];
		rthdsd_Gauss[i_47] = new doublereal[8];
	}

	integer istart_i47 = maxelm47 - 1, ic76 = 0, ih64=0;

	for (integer i = 0; i < maxelm; i++) {
		doublereal xc47, yc47, zc47;

		TOCHKA p;
		center_cord3D(i, nvtx, pa, p, 100);
		xc47 = p.x;
		yc47 = p.y;
		zc47 = p.z;

		// Найдем номер конечного изопараметрического элемента 
		// в котором содержится точка p.
		bool bfound = false;
		integer ifound = -1;

		// Эвристика 02.01.2018 для существенного ускорения поиска при интерполляции.
		// Наиболее часто, следующий найденный элемент оказывается меньше либо равен предыдущему.
		// Первый вызов основан на этой эвристике и хочет быстро отсечь большинство сканирований.
		// Только в том случае когда он ничего не находит запускается повторный вызов.
		// Это работает потому что элеменеты -nvtx ячейки были занумерованы до интерполляции 
		// согласно определенному порядку обхода. Этот же порядок обхода в общем и целом справелив и для ячеек 
		// полученных после на обычной декартовой прямоугольной структурированной сетке. 
		// Здесь мы переводим информацию с АЛИС сетки на обычную декартовую
		// прямоугольную структурированную сетку с главной целью правильно и точно вычислить градиенты. Что проблематично на АЛИС.
		// 2.01.2018 Необходимо увеличить точность (доработать) сборку матрицы на АЛИС сетке.
		// АЛИС сетка необходима для увеличения скорости проводимого моделирования без существенной потери в точности.
		for (integer i_47 = istart_i47; i_47 >= 0; i_47--) {
			if ((xc47 >= x47[nvtx47[0][i_47]]) && (xc47 <= x47[nvtx47[1][i_47]]) && (yc47 >= y47[nvtx47[0][i_47]]) && (yc47 <= y47[nvtx47[3][i_47]]) &&
				(zc47 >= z47[nvtx47[0][i_47]]) && (zc47 <= z47[nvtx47[4][i_47]]))
			{
				ifound = i_47;
				bfound = true;
				break;
			}
		}
		// Повторный вызов в случае если ничего найти не удалось. 
		// Ресурсоёмко но запускается редко.
		if (!(bfound)) {
			for (integer i_47 = 0; i_47 < maxelm47; i_47++) {
				if ((xc47 >= x47[nvtx47[0][i_47]]) && (xc47 <= x47[nvtx47[1][i_47]]) && (yc47 >= y47[nvtx47[0][i_47]]) && (yc47 <= y47[nvtx47[3][i_47]]) &&
					(zc47 >= z47[nvtx47[0][i_47]]) && (zc47 <= z47[nvtx47[4][i_47]]))
				{
					ifound = i_47;
					bfound = true;
					break;
				}
			}
		}
		/*
		// Экспериментально установлено что ih64 почти в точности равно maxelm47 и с этой точки зрения ничего сэкономить нельзя.
		if (ifound > istart_i47) {
			ic76++;
			//printf("monotonnost narushena\n");
			//getchar();
			if (fabs(ifound - istart_i47) > ih64) {
				ih64 = ifound - istart_i47;
			}
		}
		*/
		// Запоминаем номер последнего найденного чтобы существенно ускорить поиск.
		istart_i47 = ifound;


		// МНК
		// Три раза, для каждой компоненты скорости.
		doublereal temp_47 = 0.0;

		if (bfound) {

			//TOCHKA p;
			//center_cord3D(i, nvtx, pa, p, 100);
			p.x = p.x + min_x;
			p.y = p.y + min_y;
			p.z = p.z + min_z;

			// VX

			for (integer j = 0; j <= 7; j++) {
				TOCHKA p1;
				p1.x = x47[nvtx47[j][ifound]];
				p1.y = y47[nvtx47[j][ifound]];
				p1.z = z47[nvtx47[j][ifound]];
				p1.x = p1.x + min_x;
				p1.y = p1.y + min_y;
				p1.z = p1.z + min_z;

				pointerlist[i][j] = p1;
				if (fabs(p1.x) < 1.0e-40) {
					printf("problem x=%e\n", p1.x);
					getchar();
				}
				if (fabs(p1.y) < 1.0e-40) {
					printf("problem y=%e\n", p1.y);
					getchar();
				}
				if (fabs(p1.z) < 1.0e-40) {
					printf("problem z=%e\n", p1.z);
					getchar();
				}
				rthdsd_Gauss[i][j] = temp47[nvtx47[j][ifound]];
			}

			doublereal** Xmatr = new doublereal*[4];
			for (integer j = 0; j <= 3; j++) {
				Xmatr[j] = new doublereal[4];
			}


			doublereal* bmatr = new doublereal[4];
			doublereal* koefmatr = new doublereal[4];

			for (integer j1 = 0; j1 <= 3; j1++) {
				for (integer j2 = 0; j2 <= 3; j2++) {
					Xmatr[j1][j2] = 0.0;
				}
				bmatr[j1] = 0.0;
				koefmatr[j1] = 0.0;
			}




			for (integer j = 0; j < 8; j++) {

				Xmatr[0][0] += 1.0;
				Xmatr[0][1] += pointerlist[i][j].x;
				Xmatr[0][2] += pointerlist[i][j].y;
				Xmatr[0][3] += pointerlist[i][j].z;

				Xmatr[1][0] += pointerlist[i][j].x;
				Xmatr[1][1] += pointerlist[i][j].x*pointerlist[i][j].x;
				Xmatr[1][2] += pointerlist[i][j].x*pointerlist[i][j].y;
				Xmatr[1][3] += pointerlist[i][j].x*pointerlist[i][j].z;

				Xmatr[2][0] += pointerlist[i][j].y;
				Xmatr[2][1] += pointerlist[i][j].y*pointerlist[i][j].x;
				Xmatr[2][2] += pointerlist[i][j].y*pointerlist[i][j].y;
				Xmatr[2][3] += pointerlist[i][j].y*pointerlist[i][j].z;

				Xmatr[3][0] += pointerlist[i][j].z;
				Xmatr[3][1] += pointerlist[i][j].z*pointerlist[i][j].x;
				Xmatr[3][2] += pointerlist[i][j].z*pointerlist[i][j].y;
				Xmatr[3][3] += pointerlist[i][j].z*pointerlist[i][j].z;

				bmatr[0] += rthdsd_Gauss[i][j];
				bmatr[1] += pointerlist[i][j].x*rthdsd_Gauss[i][j];
				bmatr[2] += pointerlist[i][j].y*rthdsd_Gauss[i][j];
				bmatr[3] += pointerlist[i][j].z*rthdsd_Gauss[i][j];
			}


			for (integer j1 = 0; j1 <= 100; j1++) {
				koefmatr[0] = (bmatr[0] - Xmatr[0][1] * koefmatr[1] - Xmatr[0][2] * koefmatr[2] - Xmatr[0][3] * koefmatr[3]) / Xmatr[0][0];
				koefmatr[1] = (bmatr[1] - Xmatr[1][0] * koefmatr[0] - Xmatr[1][2] * koefmatr[2] - Xmatr[1][3] * koefmatr[3]) / Xmatr[1][1];
				koefmatr[2] = (bmatr[2] - Xmatr[2][0] * koefmatr[0] - Xmatr[2][1] * koefmatr[1] - Xmatr[2][3] * koefmatr[3]) / Xmatr[2][2];
				koefmatr[3] = (bmatr[3] - Xmatr[3][0] * koefmatr[0] - Xmatr[3][1] * koefmatr[1] - Xmatr[3][2] * koefmatr[2]) / Xmatr[3][3];
			}
			temp_47 = koefmatr[0] + koefmatr[1] * (p.x) + koefmatr[2] * (p.y) + koefmatr[3] * (p.z);

			for (integer j = 0; j <= 3; j++) {
				delete[] Xmatr[j];
			}
			delete[] Xmatr;
			delete[] bmatr;
			delete[] koefmatr;
		}

		potent[i] = temp_47;
		
		}

		// Диагностическая печать для исследования закономерностей в процессе интерполляции.
		// Закономерности используются чтобы существенно ускорить процесс интерполляции.
		//if (ic76 > 0) {
			//printf("monotonnost narushena=%d %d h=%d\n",ic76, maxelm47,ih64);
			//getchar();
		//}

		for (integer i = 0; i < maxelm; i++) {
			delete[] pointerlist[i];
			delete[] rthdsd_Gauss[i];
		}
		delete[] pointerlist;
		delete[] rthdsd_Gauss;

		// Освобождение оперативной памяти.
		if (x47 != NULL) {
			delete[] x47;
			x47 = NULL;
		}
		if (y47 != NULL) {
			delete[] y47;
			y47 = NULL;
		}
		if (z47 != NULL) {
			delete[] z47;
			z47 = NULL;
		}
		if (temp47 != NULL) {
			delete[] temp47;
			temp47 = NULL;
		}
		
		if (nvtx47 != NULL) {
			for (integer i_47 = 0; i_47 < 8; i_47++) {
				if (nvtx47[i_47] != NULL) {
					delete[] nvtx47[i_47];
					nvtx47[i_47] = NULL;
				}
			}
			delete[] nvtx47;
			nvtx47 = NULL;
		}

		m_sizeT = 0;
		maxelm47 = 0;

		printf("done.\n");

}//ALICE_2_Structural

  // Экспорт в программу техплот температуры.
  //С АЛИС сетки.
void ANES_tecplot360_export_temperature_preobrazovatel(integer maxnod, TOCHKA* pa,
	integer maxelm, integer** nvtx, doublereal* potent, TEMPER &t, 
	doublereal* &x_buf, doublereal* &y_buf, doublereal* &z_buf, doublereal* &t_buf, integer** &nvtx_buf, integer &m_sizeT, integer &m_size_nvtx) {

	// 2 ноября 2016. машинное эпсилон.
	//doublereal eps_mashine = 1.0e-44; // float
	doublereal eps_mashine = 1.0e-308; // double


									   // nvtx && pa сформированы, можно экспортировать в tecplot360
	//FILE *fp_4 = NULL;
	//errno_t err_4;
	//err_4 = fopen_s(&fp_4, "ALICEFLOW0_07_temp.PLT", "w");

	//if ((err_4) != 0) {
		//printf("Create File temp Error\n");
		//getchar();
		//system("pause");

	//}
	//else {

		//fprintf(fp_4, "TITLE = \"ALICEFLOW0_24\"\n");
		//fprintf(fp_4, "VARIABLES = x, y, z, Temp, Lam, log10_heat_flux_X, log10_heat_flux_Y, log10_heat_flux_Z, log10_heat_flux_mag\n");
#if doubleintprecision == 1
		//fprintf(fp_4, "ZONE T=\"Rampant\", N=%lld, E=%lld, ET=BRICK, F=FEBLOCK\n\n", maxnod, maxelm);
#else
		//fprintf(fp_4, "ZONE T=\"Rampant\", N=%d, E=%d, ET=BRICK, F=FEBLOCK\n\n", maxnod, maxelm);
#endif

	m_sizeT = maxnod;
	m_size_nvtx = maxelm;

	x_buf = new doublereal[maxnod];
	y_buf = new doublereal[maxnod];
	z_buf = new doublereal[maxnod];
	t_buf = new doublereal[maxnod];

	nvtx_buf = new integer*[8];
	for (integer i = 0; i < 8; i++) {
		nvtx_buf[i] = new integer[maxelm];
	}

		// запись x
		for (integer i = 0; i < maxnod; i++) {
			//fprintf(fp_4, "%+.16f ", pa[i].x);
			x_buf[i] = pa[i].x;
			//if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		//fprintf(fp_4, "\n");
		// запись y
		for (integer i = 0; i < maxnod; i++) {
			//fprintf(fp_4, "%+.16f ", pa[i].y);
			//if (i % 10 == 0) fprintf(fp_4, "\n");
			y_buf[i] = pa[i].y;
		}
		//fprintf(fp_4, "\n");
		// запись z
		for (integer i = 0; i < maxnod; i++) {
			//fprintf(fp_4, "%+.16f ", pa[i].z);
			//if (i % 10 == 0) fprintf(fp_4, "\n");
			z_buf[i] = pa[i].z;
		}
		//fprintf(fp_4, "\n");
		doublereal* temp = new doublereal[maxnod];
		doublereal* lam = new doublereal[maxnod];
		doublereal* vol = new doublereal[maxnod];
		doublereal* heat_flux_X = new doublereal[maxnod];
		doublereal* heat_flux_Y = new doublereal[maxnod];
		doublereal* heat_flux_Z = new doublereal[maxnod];
		doublereal* heat_flux_mag = new doublereal[maxnod];

		for (integer i = 0; i < maxnod; i++) {
			temp[i] = 0.0;
			vol[i] = 0.0;
			lam[i] = 0.0;
			heat_flux_X[i] = 0.0;
			heat_flux_Y[i] = 0.0;
			heat_flux_Z[i] = 0.0;
			heat_flux_mag[i] = 0.0;
		}
		/*
		// Здесь мы ловим конкретную исключительную ситуацию.
		bool bfound = false;
		for (integer i = 0; i <= maxelm - 1; i++) {
		for (integer j = 0; j <= 7; j++) {
		if (nvtx[j][i] - 1 == 69462) bfound = true;
		if (nvtx[j][i] - 1 == 69463) bfound = true;
		if (nvtx[j][i] - 1 == 69464) bfound = true;
		if (nvtx[j][i] - 1 == 69477) bfound = true;
		if (nvtx[j][i] - 1 == 69478) bfound = true;
		}
		}
		if (bfound) {
		printf("bfound\n");
		}
		else
		{
		printf("notfound\n");
		}
		*/

		if (0) {
			// Метод нулевого порядка.

			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}
			}
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {
					temp[i] = temp[i] / vol[i];
				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif

					//getchar();
					system("PAUSE");
					temp[i] = 0.0;
				}
			}
		}
		else if (0) {

			// Метод линейного порядка.
			doublereal min_x = 1e60;
			doublereal min_y = 1e60;
			doublereal min_z = 1e60;
			doublereal max_x = -1e60;
			doublereal max_y = -1e60;
			doublereal max_z = -1e60;

			for (integer i = 0; i < maxnod; i++) {
				if (pa[i].x < min_x) {
					min_x = pa[i].x;
				}
				if (pa[i].y < min_y) {
					min_y = pa[i].y;
				}
				if (pa[i].z < min_z) {
					min_z = pa[i].z;
				}
				if (pa[i].x > max_x) {
					max_x = pa[i].x;
				}
				if (pa[i].y > max_y) {
					max_y = pa[i].y;
				}
				if (pa[i].z > max_z) {
					max_z = pa[i].z;
				}
			}

			//min_x *= 1.2;
			//min_y *= 1.2;
			//min_z *= 1.2;



			min_x = 1.05*fabs(max_x - min_x);
			if (min_x < 1.0e-30) {
				min_x = 1.05*fabs(max_x);
			}
			min_y = 1.05*fabs(max_y - min_y);
			if (min_y < 1.0e-30) {
				min_y = 1.05*fabs(max_y);
			}
			min_z = 1.05*fabs(max_z - min_z);
			if (min_z < 1.0e-30) {
				min_z = 1.05*fabs(max_z);
			}


			/*
			if (min_x < 1.0e-30) {
			printf("error!!! negative min_x MNK!\n");
			printf("min_x=%e max_x=%e\n",min_x,max_x);
			}
			if (min_y < 1.0e-30) {
			printf("error!!! negative min_y MNK!\n");
			printf("min_y=%e max_y=%e\n", min_y, max_y);
			}
			if (min_z < 1.0e-30) {
			printf("error!!! negative min_z MNK!\n");
			printf("min_z=%e max_z=%e\n", min_z, max_z);
			}
			*/

			integer* inum_now = new integer[maxnod];

			for (integer i = 0; i < maxnod; i++) {
				temp[i] = 0.0;
				vol[i] = 0.0;
				inum_now[i] = 0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				for (integer j = 0; j <= 7; j++) {
					inum_now[nvtx[j][i] - 1] += 1;
				}
			}

			for (integer i = 0; i < maxnod; i++) {
				if (inum_now[i] < 1) {
#if doubleintprecision == 1
					printf("i=%lld maxnod=%lld inum_now[%lld]=%lld\n", i, maxnod, i, inum_now[i]);
#else
					printf("i=%d maxnod=%d inum_now[%d]=%d\n", i, maxnod, i, inum_now[i]);
#endif

					getchar();
				}
			}

			TOCHKA** pointerlist = new TOCHKA*[maxnod];
			doublereal** rthdsd_Gauss = new doublereal*[maxnod];
			for (integer i = 0; i < maxnod; i++) {
				pointerlist[i] = new TOCHKA[(inum_now[i])];
				rthdsd_Gauss[i] = new doublereal[(inum_now[i])];
			}


			for (integer i = 0; i < maxnod; i++) {
				inum_now[i] = 0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}

				TOCHKA p;
				center_cord3D(i, nvtx, pa, p, 100);
				p.x = p.x + min_x;
				p.y = p.y + min_y;
				p.z = p.z + min_z;


				for (integer j = 0; j <= 7; j++) {
					pointerlist[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = p;
					if (fabs(p.x) < 1.0e-30) {
						printf("problem x=%e\n", p.x);
						getchar();
					}
					if (fabs(p.y) < 1.0e-30) {
						printf("problem y=%e\n", p.y);
						getchar();
					}
					if (fabs(p.z) < 1.0e-30) {
						printf("problem z=%e\n", p.z);
						getchar();
					}
					rthdsd_Gauss[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = potent[i];
					inum_now[nvtx[j][i] - 1]++;
				}


				/*
				for (integer j = 0; j <= 7; j++) {
				vol[nvtx[j][i] - 1] += dx*dy*dz;
				temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}
				*/
			}


			//integer jcontrol = 0;
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {


					doublereal** Xmatr = new doublereal*[4];
					for (integer j = 0; j <= 3; j++) {
						Xmatr[j] = new doublereal[4];
					}


					doublereal* bmatr = new doublereal[4];
					doublereal* koefmatr = new doublereal[4];

					for (integer j1 = 0; j1 <= 3; j1++) {
						for (integer j2 = 0; j2 <= 3; j2++) {
							Xmatr[j1][j2] = 0.0;
						}
						bmatr[j1] = 0.0;
						koefmatr[j1] = 0.0;
					}



					for (integer j = 0; j < inum_now[i]; j++) {

						Xmatr[0][0] += 1.0;
						Xmatr[0][1] += pointerlist[i][j].x;
						Xmatr[0][2] += pointerlist[i][j].y;
						Xmatr[0][3] += pointerlist[i][j].z;

						Xmatr[1][0] += pointerlist[i][j].x;
						Xmatr[1][1] += pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[1][2] += pointerlist[i][j].x*pointerlist[i][j].y;
						Xmatr[1][3] += pointerlist[i][j].x*pointerlist[i][j].z;

						Xmatr[2][0] += pointerlist[i][j].y;
						Xmatr[2][1] += pointerlist[i][j].y*pointerlist[i][j].x;
						Xmatr[2][2] += pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[2][3] += pointerlist[i][j].y*pointerlist[i][j].z;

						Xmatr[3][0] += pointerlist[i][j].z;
						Xmatr[3][1] += pointerlist[i][j].z*pointerlist[i][j].x;
						Xmatr[3][2] += pointerlist[i][j].z*pointerlist[i][j].y;
						Xmatr[3][3] += pointerlist[i][j].z*pointerlist[i][j].z;

						bmatr[0] += rthdsd_Gauss[i][j];
						bmatr[1] += pointerlist[i][j].x*rthdsd_Gauss[i][j];
						bmatr[2] += pointerlist[i][j].y*rthdsd_Gauss[i][j];
						bmatr[3] += pointerlist[i][j].z*rthdsd_Gauss[i][j];

						/*
						Xmatr[0][0] += 1.0;
						Xmatr[0][1] += pointerlist[i][j].x-min_x;
						Xmatr[0][2] += pointerlist[i][j].y-min_y;
						Xmatr[0][3] += pointerlist[i][j].z-min_z;

						Xmatr[1][0] += pointerlist[i][j].x-min_x;
						Xmatr[1][1] += (pointerlist[i][j].x-min_x)*(pointerlist[i][j].x-min_x);
						Xmatr[1][2] += (pointerlist[i][j].x-min_x)*(pointerlist[i][j].y-min_y);
						Xmatr[1][3] += (pointerlist[i][j].x-min_x)*(pointerlist[i][j].z-min_z);

						Xmatr[2][0] += pointerlist[i][j].y-min_y;
						Xmatr[2][1] += (pointerlist[i][j].y-min_y)*(pointerlist[i][j].x-min_x);
						Xmatr[2][2] += (pointerlist[i][j].y-min_y)*(pointerlist[i][j].y-min_y);
						Xmatr[2][3] += (pointerlist[i][j].y-min_y)*(pointerlist[i][j].z-min_z);

						Xmatr[3][0] += (pointerlist[i][j].z-min_z);
						Xmatr[3][1] += (pointerlist[i][j].z-min_z)*(pointerlist[i][j].x-min_x);
						Xmatr[3][2] += (pointerlist[i][j].z-min_z)*(pointerlist[i][j].y-min_y);
						Xmatr[3][3] += (pointerlist[i][j].z-min_z)*(pointerlist[i][j].z-min_z);

						bmatr[0] += rthdsd_Gauss[i][j];
						bmatr[1] += (pointerlist[i][j].x-min_x)*rthdsd_Gauss[i][j];
						bmatr[2] += (pointerlist[i][j].y-min_y)*rthdsd_Gauss[i][j];
						bmatr[3] += (pointerlist[i][j].z-min_z)*rthdsd_Gauss[i][j];
						*/
					}

					if ((fabs(Xmatr[0][0]) < 1.e-30) || (fabs(Xmatr[1][1]) < 1.e-30) || (fabs(Xmatr[2][2]) < 1.e-30) || (fabs(Xmatr[3][3]) < 1.e-30)) {
#if doubleintprecision == 1
						printf("inum_now[%lld]=%lld\n", i, inum_now[i]);
#else
						printf("inum_now[%d]=%d\n", i, inum_now[i]);
#endif

						getchar();
					}

					//Xmatr*koefmatr = bmatr;
					/*
					if (!my_version_gauss1(Xmatr, 4, bmatr, koefmatr, false, i)) {
					temp[i] = temp[i] / vol[i];
					}
					else {
					temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x+min_x) + koefmatr[2] * (pa[i].y+min_y) + koefmatr[3] * (pa[i].z+min_z);
					}
					*/
					for (integer j1 = 0; j1 <= 100; j1++) {
						koefmatr[0] = (bmatr[0] - Xmatr[0][1] * koefmatr[1] - Xmatr[0][2] * koefmatr[2] - Xmatr[0][3] * koefmatr[3]) / Xmatr[0][0];
						koefmatr[1] = (bmatr[1] - Xmatr[1][0] * koefmatr[0] - Xmatr[1][2] * koefmatr[2] - Xmatr[1][3] * koefmatr[3]) / Xmatr[1][1];
						koefmatr[2] = (bmatr[2] - Xmatr[2][0] * koefmatr[0] - Xmatr[2][1] * koefmatr[1] - Xmatr[2][3] * koefmatr[3]) / Xmatr[2][2];
						koefmatr[3] = (bmatr[3] - Xmatr[3][0] * koefmatr[0] - Xmatr[3][1] * koefmatr[1] - Xmatr[3][2] * koefmatr[2]) / Xmatr[3][3];
					}
					temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z);
					heat_flux_X[i] = koefmatr[1];
					heat_flux_Y[i] = koefmatr[2];
					heat_flux_Z[i] = koefmatr[3];


					for (integer j = 0; j <= 3; j++) {
						delete[] Xmatr[j];
					}
					delete[] Xmatr;
					delete[] bmatr;
					delete[] koefmatr;

				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif

					//getchar();
					system("PAUSE");
					temp[i] = 0.0;
				}
			}



			delete[] inum_now;
			for (integer i = 0; i < maxnod; i++) {
				delete[] pointerlist[i];
				delete[] rthdsd_Gauss[i];
			}
			delete[] pointerlist;
			delete[] rthdsd_Gauss;
		}
		else if (0) {

			// Метод второго порядка.
			doublereal min_x = 1e60;
			doublereal min_y = 1e60;
			doublereal min_z = 1e60;
			doublereal max_x = -1e60;
			doublereal max_y = -1e60;
			doublereal max_z = -1e60;

			for (integer i = 0; i < maxnod; i++) {
				if (pa[i].x < min_x) {
					min_x = pa[i].x;
				}
				if (pa[i].y < min_y) {
					min_y = pa[i].y;
				}
				if (pa[i].z < min_z) {
					min_z = pa[i].z;
				}
				if (pa[i].x > max_x) {
					max_x = pa[i].x;
				}
				if (pa[i].y > max_y) {
					max_y = pa[i].y;
				}
				if (pa[i].z > max_z) {
					max_z = pa[i].z;
				}
			}

			//min_x *= 1.2;
			//min_y *= 1.2;
			//min_z *= 1.2;



			min_x = 1.05*fabs(max_x - min_x);
			if (min_x < 1.0e-30) {
				min_x = 1.05*fabs(max_x);
			}
			min_y = 1.05*fabs(max_y - min_y);
			if (min_y < 1.0e-30) {
				min_y = 1.05*fabs(max_y);
			}
			min_z = 1.05*fabs(max_z - min_z);
			if (min_z < 1.0e-30) {
				min_z = 1.05*fabs(max_z);
			}


			/*
			if (min_x < 1.0e-30) {
			printf("error!!! negative min_x MNK!\n");
			printf("min_x=%e max_x=%e\n", min_x, max_x);
			}
			if (min_y < 1.0e-30) {
			printf("error!!! negative min_y MNK!\n");
			printf("min_y=%e max_y=%e\n", min_y, max_y);
			}
			if (min_z < 1.0e-30) {
			printf("error!!! negative min_z MNK!\n");
			printf("min_z=%e max_z=%e\n", min_z, max_z);
			}
			*/

			integer* inum_now = new integer[maxnod];

			for (integer i = 0; i < maxnod; i++) {
				temp[i] = 0.0;
				vol[i] = 0.0;
				inum_now[i] = 0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				for (integer j = 0; j <= 7; j++) {
					inum_now[nvtx[j][i] - 1] += 1;
				}
			}

			for (integer i = 0; i < maxnod; i++) {
				if (inum_now[i] < 1) {
#if doubleintprecision == 1
					printf("i=%lld maxnod=%lld inum_now[%lld]=%lld\n", i, maxnod, i, inum_now[i]);
#else
					printf("i=%d maxnod=%d inum_now[%d]=%d\n", i, maxnod, i, inum_now[i]);
#endif

					getchar();
				}
			}

			TOCHKA** pointerlist = new TOCHKA*[maxnod];
			doublereal** rthdsd_Gauss = new doublereal*[maxnod];
			for (integer i = 0; i < maxnod; i++) {
				pointerlist[i] = new TOCHKA[(inum_now[i])];
				rthdsd_Gauss[i] = new doublereal[(inum_now[i])];
			}


			for (integer i = 0; i < maxnod; i++) {
				inum_now[i] = 0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}

				TOCHKA p;
				center_cord3D(i, nvtx, pa, p, 100);
				p.x = p.x + min_x;
				p.y = p.y + min_y;
				p.z = p.z + min_z;


				for (integer j = 0; j <= 7; j++) {
					pointerlist[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = p;
					if (fabs(p.x) < 1.0e-30) {
						printf("problem x=%e\n", p.x);
						getchar();
					}
					if (fabs(p.y) < 1.0e-30) {
						printf("problem y=%e\n", p.y);
						getchar();
					}
					if (fabs(p.z) < 1.0e-30) {
						printf("problem z=%e\n", p.z);
						getchar();
					}
					rthdsd_Gauss[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = potent[i];
					inum_now[nvtx[j][i] - 1]++;
				}


				/*
				for (integer j = 0; j <= 7; j++) {
				vol[nvtx[j][i] - 1] += dx*dy*dz;
				temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}
				*/
			}


			//integer jcontrol = 0;
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {


					doublereal** Xmatr = new doublereal*[7];
					for (integer j = 0; j <= 6; j++) {
						Xmatr[j] = new doublereal[7];
					}


					doublereal* bmatr = new doublereal[7];
					doublereal* koefmatr = new doublereal[7];

					for (integer j1 = 0; j1 <= 6; j1++) {
						for (integer j2 = 0; j2 <= 6; j2++) {
							Xmatr[j1][j2] = 0.0;
						}
						bmatr[j1] = 0.0;
						koefmatr[j1] = 0.0;
					}



					for (integer j = 0; j < inum_now[i]; j++) {

						Xmatr[0][0] += 1.0;
						Xmatr[0][1] += pointerlist[i][j].x;
						Xmatr[0][2] += pointerlist[i][j].y;
						Xmatr[0][3] += pointerlist[i][j].z;
						Xmatr[0][4] += pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[0][5] += pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[0][6] += pointerlist[i][j].z*pointerlist[i][j].z;

						Xmatr[1][0] += pointerlist[i][j].x;
						Xmatr[1][1] += pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[1][2] += pointerlist[i][j].x*pointerlist[i][j].y;
						Xmatr[1][3] += pointerlist[i][j].x*pointerlist[i][j].z;
						Xmatr[1][4] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[1][5] += pointerlist[i][j].x*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[1][6] += pointerlist[i][j].x*pointerlist[i][j].z*pointerlist[i][j].z;

						Xmatr[2][0] += pointerlist[i][j].y;
						Xmatr[2][1] += pointerlist[i][j].y*pointerlist[i][j].x;
						Xmatr[2][2] += pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[2][3] += pointerlist[i][j].y*pointerlist[i][j].z;
						Xmatr[2][4] += pointerlist[i][j].y*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[2][5] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[2][6] += pointerlist[i][j].y*pointerlist[i][j].z*pointerlist[i][j].z;

						Xmatr[3][0] += pointerlist[i][j].z;
						Xmatr[3][1] += pointerlist[i][j].z*pointerlist[i][j].x;
						Xmatr[3][2] += pointerlist[i][j].z*pointerlist[i][j].y;
						Xmatr[3][3] += pointerlist[i][j].z*pointerlist[i][j].z;
						Xmatr[3][4] += pointerlist[i][j].z*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[3][5] += pointerlist[i][j].z*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[3][6] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].z;

						Xmatr[4][0] += pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[4][1] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[4][2] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].y;
						Xmatr[4][3] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].z;
						Xmatr[4][4] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[4][5] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[4][6] += pointerlist[i][j].x*pointerlist[i][j].x*pointerlist[i][j].z*pointerlist[i][j].z;

						Xmatr[5][0] += pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[5][1] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].x;
						Xmatr[5][2] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[5][3] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].z;
						Xmatr[5][4] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[5][5] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[5][6] += pointerlist[i][j].y*pointerlist[i][j].y*pointerlist[i][j].z*pointerlist[i][j].z;

						Xmatr[6][0] += pointerlist[i][j].z*pointerlist[i][j].z;
						Xmatr[6][1] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].x;
						Xmatr[6][2] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].y;
						Xmatr[6][3] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].z;
						Xmatr[6][4] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[6][5] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[6][6] += pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].z*pointerlist[i][j].z;

						bmatr[0] += rthdsd_Gauss[i][j];
						bmatr[1] += pointerlist[i][j].x*rthdsd_Gauss[i][j];
						bmatr[2] += pointerlist[i][j].y*rthdsd_Gauss[i][j];
						bmatr[3] += pointerlist[i][j].z*rthdsd_Gauss[i][j];
						bmatr[4] += pointerlist[i][j].x*pointerlist[i][j].x*rthdsd_Gauss[i][j];
						bmatr[5] += pointerlist[i][j].y*pointerlist[i][j].y*rthdsd_Gauss[i][j];
						bmatr[6] += pointerlist[i][j].z*pointerlist[i][j].z*rthdsd_Gauss[i][j];


					}

					if ((fabs(Xmatr[0][0]) < 1.e-30) || (fabs(Xmatr[1][1]) < 1.e-30) || (fabs(Xmatr[2][2]) < 1.e-30) || (fabs(Xmatr[3][3]) < 1.e-30)
						|| (fabs(Xmatr[4][4]) < 1.e-30) || (fabs(Xmatr[5][5]) < 1.e-30) || (fabs(Xmatr[6][6]) < 1.e-30)) {
#if doubleintprecision == 1
						printf("inum_now[%lld]=%lld\n", i, inum_now[i]);
#else
						printf("inum_now[%d]=%d\n", i, inum_now[i]);
#endif

						getchar();
					}

					//Xmatr*koefmatr = bmatr;
					/*
					if (!my_version_gauss1(Xmatr, 4, bmatr, koefmatr, false, i)) {
					temp[i] = temp[i] / vol[i];
					}
					else {
					temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x+min_x) + koefmatr[2] * (pa[i].y+min_y) + koefmatr[3] * (pa[i].z+min_z);
					}
					*/
					for (integer j1 = 0; j1 <= 2000; j1++) {
						koefmatr[0] = (bmatr[0] - Xmatr[0][1] * koefmatr[1] - Xmatr[0][2] * koefmatr[2] - Xmatr[0][3] * koefmatr[3] - Xmatr[0][4] * koefmatr[4] - Xmatr[0][5] * koefmatr[5] - Xmatr[0][6] * koefmatr[6]) / Xmatr[0][0];
						koefmatr[1] = (bmatr[1] - Xmatr[1][0] * koefmatr[0] - Xmatr[1][2] * koefmatr[2] - Xmatr[1][3] * koefmatr[3] - Xmatr[1][4] * koefmatr[4] - Xmatr[1][5] * koefmatr[5] - Xmatr[1][6] * koefmatr[6]) / Xmatr[1][1];
						koefmatr[2] = (bmatr[2] - Xmatr[2][0] * koefmatr[0] - Xmatr[2][1] * koefmatr[1] - Xmatr[2][3] * koefmatr[3] - Xmatr[2][4] * koefmatr[4] - Xmatr[2][5] * koefmatr[5] - Xmatr[2][6] * koefmatr[6]) / Xmatr[2][2];
						koefmatr[3] = (bmatr[3] - Xmatr[3][0] * koefmatr[0] - Xmatr[3][1] * koefmatr[1] - Xmatr[3][2] * koefmatr[2] - Xmatr[3][4] * koefmatr[4] - Xmatr[3][5] * koefmatr[5] - Xmatr[3][6] * koefmatr[6]) / Xmatr[3][3];
						koefmatr[4] = (bmatr[4] - Xmatr[4][0] * koefmatr[0] - Xmatr[4][1] * koefmatr[1] - Xmatr[4][2] * koefmatr[2] - Xmatr[4][3] * koefmatr[3] - Xmatr[4][5] * koefmatr[5] - Xmatr[4][6] * koefmatr[6]) / Xmatr[4][4];
						koefmatr[5] = (bmatr[5] - Xmatr[5][0] * koefmatr[0] - Xmatr[5][1] * koefmatr[1] - Xmatr[5][2] * koefmatr[2] - Xmatr[5][4] * koefmatr[4] - Xmatr[5][3] * koefmatr[3] - Xmatr[5][6] * koefmatr[6]) / Xmatr[5][5];
						koefmatr[6] = (bmatr[6] - Xmatr[6][0] * koefmatr[0] - Xmatr[6][1] * koefmatr[1] - Xmatr[6][2] * koefmatr[2] - Xmatr[6][4] * koefmatr[4] - Xmatr[6][5] * koefmatr[5] - Xmatr[6][3] * koefmatr[3]) / Xmatr[6][6];
					}
					temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z) + koefmatr[4] * (pa[i].x + min_x)*(pa[i].x + min_x) + koefmatr[5] * (pa[i].y + min_y) * (pa[i].y + min_y) + koefmatr[6] * (pa[i].z + min_z) * (pa[i].z + min_z);
					heat_flux_X[i] = koefmatr[1] + 2.0*koefmatr[4] * (pa[i].x + min_x);
					heat_flux_Y[i] = koefmatr[2] + 2.0*koefmatr[5] * (pa[i].y + min_y);
					heat_flux_Z[i] = koefmatr[3] + 2.0*koefmatr[6] * (pa[i].z + min_z);


					for (integer j = 0; j <= 6; j++) {
						delete[] Xmatr[j];
					}
					delete[] Xmatr;
					delete[] bmatr;
					delete[] koefmatr;

				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif

					//getchar();
					system("PAUSE");
					temp[i] = 0.0;
				}
			}



			delete[] inum_now;
			for (integer i = 0; i < maxnod; i++) {
				delete[] pointerlist[i];
				delete[] rthdsd_Gauss[i];
			}
			delete[] pointerlist;
			delete[] rthdsd_Gauss;
		}
		else if (1) {
			// линейная реконструкция, НО по расширенному шаблону.
			// Расширенный шаблон содержит больше опорных точек интерполляции, 
			// поэтому в теории реконструкция должна быть более точная.

			// Метод линейного порядка.
			doublereal min_x = 1e60;
			doublereal min_y = 1e60;
			doublereal min_z = 1e60;
			doublereal max_x = -1e60;
			doublereal max_y = -1e60;
			doublereal max_z = -1e60;

			for (integer i = 0; i < maxnod; i++) {
				if (pa[i].x < min_x) {
					min_x = pa[i].x;
				}
				if (pa[i].y < min_y) {
					min_y = pa[i].y;
				}
				if (pa[i].z < min_z) {
					min_z = pa[i].z;
				}
				if (pa[i].x > max_x) {
					max_x = pa[i].x;
				}
				if (pa[i].y > max_y) {
					max_y = pa[i].y;
				}
				if (pa[i].z > max_z) {
					max_z = pa[i].z;
				}
			}

			doublereal min_x1 = min_x;
			doublereal min_y1 = min_y;
			doublereal min_z1 = min_z;
			//min_x *= 1.2;
			//min_y *= 1.2;
			//min_z *= 1.2;

			// 05.07.2017

			min_x = 1.05*fabs(max_x - min_x);
			if (min_x < 1.0e-30) {
				min_x = 1.05*fabs(max_x);
			}
			min_y = 1.05*fabs(max_y - min_y);
			if (min_y < 1.0e-30) {
				min_y = 1.05*fabs(max_y);
			}
			min_z = 1.05*fabs(max_z - min_z);
			if (min_z < 1.0e-30) {
				min_z = 1.05*fabs(max_z);
			}

			/*
			if (min_x < 1.0e-30) {
			printf("error!!! negative min_x MNK!\n");
			printf("min_x=%e max_x=%e\n", min_x, max_x);
			}
			if (min_y < 1.0e-30) {
			printf("error!!! negative min_y MNK!\n");
			printf("min_y=%e max_y=%e\n", min_y, max_y);
			}
			if (min_z < 1.0e-30) {
			printf("error!!! negative min_z MNK!\n");
			printf("min_z=%e max_z=%e\n", min_z, max_z);
			}
			*/

			// Для ускорения сканирования в методе наименьших квадратов 8.07.2017.
			integer** q_hash = NULL;
			q_hash = new integer*[maxnod + 1];
			integer* q_ic = NULL;
			q_ic = new integer[maxnod + 1];
			for (integer j = 0; j <= maxnod; j++) {
				q_hash[j] = new integer[9];
				q_ic[j] = 0;
			}
			for (integer j = 0; j <= maxnod; j++) {
				for (integer i_1 = 0; i_1 < 9; i_1++) {
					q_hash[j][i_1] = -1;
				}
			}
			for (integer i_1 = 0; i_1 <= maxelm - 1; i_1++) {
				for (integer j_1 = 0; j_1 <= 7; j_1++) {
					q_hash[nvtx[j_1][i_1]][q_ic[nvtx[j_1][i_1]]] = i_1;
					q_ic[nvtx[j_1][i_1]]++;
				}
			}

			integer* inum_now = new integer[maxnod];

			for (integer i = 0; i < maxnod; i++) {
				temp[i] = 0.0;
				vol[i] = 0.0;
				inum_now[i] = 0;
			}

			// Идея расширения шаблона: мы рассматриваем не только текущий nvtx, но и всех
			// его соседей имеющих с ним хоть одну общую вершину. Этим самым шаблон используемый
			// для реконструкции будет расширен новыми точками.
			// Модификация 30.05.2017.
			for (integer i = 0; i <= maxelm - 1; i++) {
				for (integer j = 0; j <= 7; j++) {
					inum_now[nvtx[j][i] - 1] += 1;
					//for (integer i_1 = 0; i_1 <= maxelm - 1; i_1++) {
					integer i_1 = -1;
					for (integer i_2 = 0; i_2<9; i_2++) {
						i_1 = q_hash[nvtx[j][i]][i_2];
						if (i_1 >= 0) {
							for (integer j_1 = 0; j_1 <= 7; j_1++) {
								if (i_1 != i) {
									if (nvtx[j][i] == nvtx[j_1][i_1]) {
										inum_now[nvtx[j][i] - 1] += 1;
									}
								}
							}
						}
					}
				}
			}

			for (integer i = 0; i < maxnod; i++) {
				if (inum_now[i] < 1) {
#if doubleintprecision == 1
					printf("i=%lld maxnod=%lld inum_now[%lld]=%lld\n", i, maxnod, i, inum_now[i]);
#else
					printf("i=%d maxnod=%d inum_now[%d]=%d\n", i, maxnod, i, inum_now[i]);
#endif

					getchar();
				}
			}

			TOCHKA** pointerlist = new TOCHKA*[maxnod];
			doublereal** rthdsd_Gauss = new doublereal*[maxnod];
			for (integer i = 0; i < maxnod; i++) {
				pointerlist[i] = new TOCHKA[(inum_now[i])];
				rthdsd_Gauss[i] = new doublereal[(inum_now[i])];
			}


			for (integer i = 0; i < maxnod; i++) {
				inum_now[i] = 0;
			}



			// Непосредственно само вычисление.
			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контрольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}

				TOCHKA p;
				center_cord3D(i, nvtx, pa, p, 100);
				p.x = p.x + min_x;
				p.y = p.y + min_y;
				p.z = p.z + min_z;


				for (integer j = 0; j <= 7; j++) {
					pointerlist[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = p;
					if (fabs(p.x) < 1.0e-30) {
						printf("problem x=%e\n", p.x);
						getchar();
					}
					if (fabs(p.y) < 1.0e-30) {
						printf("problem y=%e\n", p.y);
						getchar();
					}
					if (fabs(p.z) < 1.0e-30) {
						printf("problem z=%e\n", p.z);
						getchar();
					}
					rthdsd_Gauss[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = potent[i];
					inum_now[nvtx[j][i] - 1]++;
				}





				for (integer j = 0; j <= 7; j++) {
					//for (integer i_1 = 0; i_1 <= maxelm - 1; i_1++) {
					integer i_1 = -1;
					for (integer i_2 = 0; i_2<9; i_2++) {
						i_1 = q_hash[nvtx[j][i]][i_2];
						if (i_1 >= 0) {
							for (integer j_1 = 0; j_1 <= 7; j_1++) {
								if (i_1 != i) {
									if (nvtx[j][i] == nvtx[j_1][i_1]) {
										TOCHKA p_1;
										center_cord3D(i_1, nvtx, pa, p_1, 100);
										p_1.x = p_1.x + min_x;
										p_1.y = p_1.y + min_y;
										p_1.z = p_1.z + min_z;

										pointerlist[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = p_1;
										if (fabs(p_1.x) < 1.0e-30) {
											printf("problem x=%e\n", p_1.x);
											getchar();
										}
										if (fabs(p_1.y) < 1.0e-30) {
											printf("problem y=%e\n", p_1.y);
											getchar();
										}
										if (fabs(p_1.z) < 1.0e-30) {
											printf("problem z=%e\n", p_1.z);
											getchar();
										}

										rthdsd_Gauss[nvtx[j][i] - 1][inum_now[nvtx[j][i] - 1]] = potent[i_1];
										inum_now[nvtx[j][i] - 1]++;
									}
								}
							}
						}
					}
				}


				/*
				for (integer j = 0; j <= 7; j++) {
				vol[nvtx[j][i] - 1] += dx*dy*dz;
				temp[nvtx[j][i] - 1] += dx*dy*dz*potent[i];
				}
				*/
			}


			for (integer j = 0; j <= maxnod; j++) {
				delete[] q_hash[j];
			}
			delete[] q_ic;
			delete[] q_hash;
			q_ic = NULL;
			q_hash = NULL;

			//integer jcontrol = 0;
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {


					doublereal** Xmatr = new doublereal*[4];
					for (integer j = 0; j <= 3; j++) {
						Xmatr[j] = new doublereal[4];
					}


					doublereal* bmatr = new doublereal[4];
					doublereal* koefmatr = new doublereal[4];

					for (integer j1 = 0; j1 <= 3; j1++) {
						for (integer j2 = 0; j2 <= 3; j2++) {
							Xmatr[j1][j2] = 0.0;
						}
						bmatr[j1] = 0.0;
						koefmatr[j1] = 0.0;
					}



					for (integer j = 0; j < inum_now[i]; j++) {

						Xmatr[0][0] += 1.0;
						Xmatr[0][1] += pointerlist[i][j].x;
						Xmatr[0][2] += pointerlist[i][j].y;
						Xmatr[0][3] += pointerlist[i][j].z;

						Xmatr[1][0] += pointerlist[i][j].x;
						Xmatr[1][1] += pointerlist[i][j].x*pointerlist[i][j].x;
						Xmatr[1][2] += pointerlist[i][j].x*pointerlist[i][j].y;
						Xmatr[1][3] += pointerlist[i][j].x*pointerlist[i][j].z;

						Xmatr[2][0] += pointerlist[i][j].y;
						Xmatr[2][1] += pointerlist[i][j].y*pointerlist[i][j].x;
						Xmatr[2][2] += pointerlist[i][j].y*pointerlist[i][j].y;
						Xmatr[2][3] += pointerlist[i][j].y*pointerlist[i][j].z;

						Xmatr[3][0] += pointerlist[i][j].z;
						Xmatr[3][1] += pointerlist[i][j].z*pointerlist[i][j].x;
						Xmatr[3][2] += pointerlist[i][j].z*pointerlist[i][j].y;
						Xmatr[3][3] += pointerlist[i][j].z*pointerlist[i][j].z;

						bmatr[0] += rthdsd_Gauss[i][j];
						bmatr[1] += pointerlist[i][j].x*rthdsd_Gauss[i][j];
						bmatr[2] += pointerlist[i][j].y*rthdsd_Gauss[i][j];
						bmatr[3] += pointerlist[i][j].z*rthdsd_Gauss[i][j];

					}

					if ((fabs(Xmatr[0][0]) < 1.e-30) || (fabs(Xmatr[1][1]) < 1.e-30) || (fabs(Xmatr[2][2]) < 1.e-30) || (fabs(Xmatr[3][3]) < 1.e-30)) {
#if doubleintprecision == 1
						printf("inum_now[%lld]=%lld\n", i, inum_now[i]);
#else
						printf("inum_now[%d]=%d\n", i, inum_now[i]);
#endif

						getchar();
					}

					//Xmatr*koefmatr = bmatr;
					/*
					// Метод Гаусса не работает т.к. система линейно зависима.
					if (!my_version_gauss1(Xmatr, 4, bmatr, koefmatr, false, i)) {
					temp[i] = temp[i] / vol[i];
					}
					else {
					temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x+min_x) + koefmatr[2] * (pa[i].y+min_y) + koefmatr[3] * (pa[i].z+min_z);
					}
					*/
					for (integer j1 = 0; j1 <= 3; j1++) {
						koefmatr[j1] = 0.0;
					}
					for (integer j1 = 0; j1 <= 250; j1++) {
						doublereal alpha = 0.2;
						doublereal d_0 = koefmatr[0];
						doublereal d_1 = koefmatr[1];
						doublereal d_2 = koefmatr[2];
						doublereal d_3 = koefmatr[3];
						koefmatr[0] = (1.0 - alpha)*d_0 + alpha*((bmatr[0] - Xmatr[0][1] * koefmatr[1] - Xmatr[0][2] * koefmatr[2] - Xmatr[0][3] * koefmatr[3]) / Xmatr[0][0]);
						koefmatr[1] = (1.0 - alpha)*d_1 + alpha*((bmatr[1] - Xmatr[1][0] * koefmatr[0] - Xmatr[1][2] * koefmatr[2] - Xmatr[1][3] * koefmatr[3]) / Xmatr[1][1]);
						koefmatr[2] = (1.0 - alpha)*d_2 + alpha*((bmatr[2] - Xmatr[2][0] * koefmatr[0] - Xmatr[2][1] * koefmatr[1] - Xmatr[2][3] * koefmatr[3]) / Xmatr[2][2]);
						koefmatr[3] = (1.0 - alpha)*d_3 + alpha*((bmatr[3] - Xmatr[3][0] * koefmatr[0] - Xmatr[3][1] * koefmatr[1] - Xmatr[3][2] * koefmatr[2]) / Xmatr[3][3]);
					}
					temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z);
					//temp[i] = koefmatr[0] + koefmatr[1] * (pa[i].x ) + koefmatr[2] * (pa[i].y ) + koefmatr[3] * (pa[i].z );
					//heat_flux_X[i] = koefmatr[1];
					//heat_flux_Y[i] = koefmatr[2];
					//heat_flux_Z[i] = koefmatr[3];
					heat_flux_X[i] = 0.0;
					heat_flux_Y[i] = 0.0;
					heat_flux_Z[i] = 0.0;
					// вычисление размеров текущего контрольного объёма:
					/*
					doublereal h_1= 1.0e-4*(max_x-min_x1);
					h_1 = pow(fabs(vol[i]), 0.333);
					//h_1 = 0.5*dx1;
					heat_flux_X[i] = ((koefmatr[0] + koefmatr[1] * (pa[i].x + min_x+h_1) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z)
					)-(koefmatr[0] + koefmatr[1] * (pa[i].x + min_x-h_1) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z)
					)) / (2 * h_1);
					//h_1 = 1.0e-4*(max_y - min_y1);
					//h_1 = 0.5*dy1;
					heat_flux_Y[i] = ((koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y+h_1) + koefmatr[3] * (pa[i].z + min_z)
					) - (koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y-h_1) + koefmatr[3] * (pa[i].z + min_z)
					)) / (2 * h_1);
					//h_1 = 1.0e-4*(max_z - min_z1);
					//h_1 = 0.5*dz1;
					heat_flux_Z[i] = ((koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z+h_1)
					) - (koefmatr[0] + koefmatr[1] * (pa[i].x + min_x) + koefmatr[2] * (pa[i].y + min_y) + koefmatr[3] * (pa[i].z + min_z-h_1)
					)) / (2 * h_1);
					*/

					for (integer j = 0; j <= 3; j++) {
						delete[] Xmatr[j];
					}
					delete[] Xmatr;
					delete[] bmatr;
					delete[] koefmatr;

				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif

					//getchar();
					system("PAUSE");
					temp[i] = 0.0;
				}
			}



			delete[] inum_now;
			for (integer i = 0; i < maxnod; i++) {
				delete[] pointerlist[i];
				delete[] rthdsd_Gauss[i];
			}
			delete[] pointerlist;
			delete[] rthdsd_Gauss;


		}
		
		// запись temp
		for (integer i = 0; i < maxnod; i++) {
			//fprintf(fp_4, "%+.16f ", temp[i]);
			//if (i % 10 == 0) fprintf(fp_4, "\n");
			t_buf[i] = temp[i];
		}
		//fprintf(fp_4, "\n");

/*
		if (1) {
			// Метод нулевого порядка.

			for (integer i = 0; i < maxnod; i++) {
				vol[i] = 0.0;
			}

			for (integer i = 0; i <= maxelm - 1; i++) {
				// вычисление размеров текущего контрольного объёма:
				doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
				volume3D(i, nvtx, pa, dx, dy, dz);

				for (integer j = 0; j <= 7; j++) {
					vol[nvtx[j][i] - 1] += dx*dy*dz;
					lam[nvtx[j][i] - 1] += dx*dy*dz*t.prop[LAM][i];
				}
			}
			for (integer i = 0; i < maxnod; i++) {
				if (fabs(vol[i]) > eps_mashine) {
					lam[i] = lam[i] / vol[i];
				}
				else {
#if doubleintprecision == 1
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
					printf("vol[%lld]==%e\n", i, vol[i]);
#else
					printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
					printf("vol[%d]==%e\n", i, vol[i]);
#endif

					//getchar();
					system("PAUSE");
					temp[i] = 0.0;
				}
			}
		}
		// запись теплопроводности
		for (integer i = 0; i < maxnod; i++) {
			fprintf(fp_4, "%+.16f ", lam[i]);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");

		// запись теплового потока по Х
		for (integer i = 0; i < maxnod; i++) {
			heat_flux_X[i] *= -lam[i];
			doublereal d_1 = heat_flux_X[i];
			if (d_1 > 2.0) {
				d_1 = log10(d_1);
			}
			else if (d_1<-2.0) {
				d_1 = -log10(fabs(d_1));
			}
			else {
				d_1 = 0.0;
			}
			fprintf(fp_4, "%+.16f ", d_1);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");

		// запись теплового потока по Y
		for (integer i = 0; i < maxnod; i++) {
			heat_flux_Y[i] *= -lam[i];
			doublereal d_1 = heat_flux_Y[i];
			if (d_1 > 2.0) {
				d_1 = log10(d_1);
			}
			else if (d_1<-2.0) {
				d_1 = -log10(fabs(d_1));
			}
			else {
				d_1 = 0.0;
			}
			fprintf(fp_4, "%+.16f ", d_1);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");

		// запись теплового потока по Z
		for (integer i = 0; i < maxnod; i++) {
			heat_flux_Z[i] *= -lam[i];
			doublereal d_1 = heat_flux_Z[i];
			if (d_1 > 2.0) {
				d_1 = log10(d_1);
			}
			else if (d_1<-2.0) {
				d_1 = -log10(fabs(d_1));
			}
			else {
				d_1 = 0.0;
			}
			fprintf(fp_4, "%+.16f ", d_1);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");


		// запись модуля теплового потока
		for (integer i = 0; i < maxnod; i++) {
			doublereal d_1 = sqrt(heat_flux_X[i] * heat_flux_X[i] + heat_flux_Y[i] * heat_flux_Y[i] + heat_flux_Z[i] * heat_flux_Z[i]);
			if (d_1 > 2.0) {
				d_1 = log10(d_1);
			}
			else {
				d_1 = 0.0;
			}
			fprintf(fp_4, "%+.16f ", d_1);
			if (i % 10 == 0) fprintf(fp_4, "\n");
		}
		fprintf(fp_4, "\n");
		*/

		delete[] temp;
		delete[] vol;
		delete[] lam;
		delete[] heat_flux_X;
		delete[] heat_flux_Y;
		delete[] heat_flux_Z;
		delete[] heat_flux_mag;


		for (integer i = 0; i <= maxelm - 1; i++) {
#if doubleintprecision == 1

			if (1) {
				// Контрольные объёмы состоят из кубиков. Вершины 
				// каждого такого кубика должны быть перечислены в строго порядке сортировки.
				// Сортировка : упорядочивание восьмерки по возракстанию координаты z.
				// Сортировка: упорядочивание каждой четверки по возрастанию координаты y. Всего 2 четверки.
				// Сортировка четырехз двоек по возрастанию х.


				integer invtx[8];
				doublereal znvtx[8];
				doublereal ynvtx[8];
				doublereal xnvtx[8];
				for (integer j28 = 0; j28 < 8; j28++) {
					invtx[j28] = nvtx[j28][i];
					znvtx[j28] = pa[nvtx[j28][i] - 1].z;
					ynvtx[j28] = pa[nvtx[j28][i] - 1].y;
					xnvtx[j28] = pa[nvtx[j28][i] - 1].x;
				}

				// Сортировка по возрастанию z.
				for (integer i28 = 1; i28 < 8; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 0) && (znvtx[location] > znewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию y. Часть 1.
				//0,1,2,3<4
				for (integer i28 = 1; i28 < 4; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 0) && (ynvtx[location] > ynewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// 4,5,6,7<8
				// Сортировка по возрастанию y. Часть 2.
				for (integer i28 = 5; i28 < 8; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 4) && (ynvtx[location] > ynewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				//0,1<2
				//2,3<4
				//4,5<6
				//6,7<8
				// Сортировка по возрастанию X. Часть 1.
				for (integer i28 = 1; i28 < 2; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 0) && (xnvtx[location] > xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 2.
				for (integer i28 = 3; i28 < 4; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 2) && (xnvtx[location] < xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 3.
				for (integer i28 = 5; i28 < 6; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 4) && (xnvtx[location] > xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 4.
				for (integer i28 = 7; i28 < 8; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 6) && (xnvtx[location] < xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}

				//fprintf(fp_4, "%lld %lld %lld %lld %lld %lld %lld %lld \n", invtx[0], invtx[1], invtx[2], invtx[3], invtx[4], invtx[5], invtx[6], invtx[7]);
				nvtx_buf[0][i] = invtx[0]-1;
				nvtx_buf[1][i] = invtx[1]-1;
				nvtx_buf[2][i] = invtx[2]-1;
				nvtx_buf[3][i] = invtx[3]-1;
				nvtx_buf[4][i] = invtx[4]-1;
				nvtx_buf[5][i] = invtx[5]-1;
				nvtx_buf[6][i] = invtx[6]-1;
				nvtx_buf[7][i] = invtx[7]-1;

				if (nvtx[0][i] < 1) printf("bad nvtx[0][%lld]=%lld", i, nvtx[0][i]);
				if (nvtx[1][i] < 1) printf("bad nvtx[1][%lld]=%lld", i, nvtx[1][i]);
				if (nvtx[2][i] < 1) printf("bad nvtx[2][%lld]=%lld", i, nvtx[2][i]);
				if (nvtx[3][i] < 1) printf("bad nvtx[3][%lld]=%lld", i, nvtx[3][i]);
				if (nvtx[4][i] < 1) printf("bad nvtx[4][%lld]=%lld", i, nvtx[4][i]);
				if (nvtx[5][i] < 1) printf("bad nvtx[5][%lld]=%lld", i, nvtx[5][i]);
				if (nvtx[6][i] < 1) printf("bad nvtx[6][%lld]=%lld", i, nvtx[6][i]);
				if (nvtx[7][i] < 1) printf("bad nvtx[7][%lld]=%lld", i, nvtx[7][i]);
			}
			else {
				//fprintf(fp_4, "%lld %lld %lld %lld %lld %lld %lld %lld \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
				nvtx_buf[0][i] = nvtx[0][i]-1;
				nvtx_buf[1][i] = nvtx[1][i]-1;
				nvtx_buf[2][i] = nvtx[2][i]-1;
				nvtx_buf[3][i] = nvtx[3][i]-1;
				nvtx_buf[4][i] = nvtx[4][i]-1;
				nvtx_buf[5][i] = nvtx[5][i]-1;
				nvtx_buf[6][i] = nvtx[6][i]-1;
				nvtx_buf[7][i] = nvtx[7][i]-1;
			}
#else

			if (1) {
				integer invtx[8];
				doublereal znvtx[8];
				doublereal ynvtx[8];
				doublereal xnvtx[8];
				for (integer j28 = 0; j28 < 8; j28++) {
					invtx[j28] = nvtx[j28][i];
					znvtx[j28] = pa[nvtx[j28][i] - 1].z;
					ynvtx[j28] = pa[nvtx[j28][i] - 1].y;
					xnvtx[j28] = pa[nvtx[j28][i] - 1].x;
				}

				// Сортировка по возрастанию z.
				for (integer i28 = 1; i28 < 8; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 0) && (znvtx[location] > znewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию y. Часть 1.
				for (integer i28 = 1; i28 < 4; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 0) && (ynvtx[location] > ynewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию y. Часть 2.
				for (integer i28 = 5; i28 < 8; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 4) && (ynvtx[location] > ynewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 1.
				for (integer i28 = 1; i28 < 2; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 0) && (xnvtx[location] > xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 2.
				for (integer i28 = 3; i28 < 4; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 2) && (xnvtx[location] < xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 3.
				for (integer i28 = 5; i28 < 6; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 4) && (xnvtx[location] > xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}
				// Сортировка по возрастанию X. Часть 4.
				for (integer i28 = 7; i28 < 8; i28++) {
					integer inewelm = invtx[i28];
					doublereal znewelm = znvtx[i28];
					doublereal ynewelm = ynvtx[i28];
					doublereal xnewelm = xnvtx[i28];
					integer location = i28 - 1;
					while ((location >= 6) && (xnvtx[location] < xnewelm)) {
						// сдвигаем все элементы большие очередного.
						invtx[location + 1] = invtx[location];
						znvtx[location + 1] = znvtx[location];
						ynvtx[location + 1] = ynvtx[location];
						xnvtx[location + 1] = xnvtx[location];
						location--;
					}
					invtx[location + 1] = inewelm;
					znvtx[location + 1] = znewelm;
					ynvtx[location + 1] = ynewelm;
					xnvtx[location + 1] = xnewelm;
				}

				//fprintf_s(fp_4, "%d %d %d %d %d %d %d %d \n", invtx[0], invtx[1], invtx[2], invtx[3], invtx[4], invtx[5], invtx[6], invtx[7]);

				nvtx_buf[0][i] = invtx[0]-1;
				nvtx_buf[1][i] = invtx[1]-1;
				nvtx_buf[2][i] = invtx[2]-1;
				nvtx_buf[3][i] = invtx[3]-1;
				nvtx_buf[4][i] = invtx[4]-1;
				nvtx_buf[5][i] = invtx[5]-1;
				nvtx_buf[6][i] = invtx[6]-1;
				nvtx_buf[7][i] = invtx[7]-1;

				//debug
				//printf("%d %d %d %d %d %d %d %d \n", invtx[0], invtx[1], invtx[2], invtx[3], invtx[4], invtx[5], invtx[6], invtx[7]);
				//printf( "%d %d %d %d %d %d %d %d \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
				//getchar();

				if (nvtx[0][i] < 1) printf("bad nvtx[0][%d]=%d", i, nvtx[0][i]);
				if (nvtx[1][i] < 1) printf("bad nvtx[1][%d]=%d", i, nvtx[1][i]);
				if (nvtx[2][i] < 1) printf("bad nvtx[2][%d]=%d", i, nvtx[2][i]);
				if (nvtx[3][i] < 1) printf("bad nvtx[3][%d]=%d", i, nvtx[3][i]);
				if (nvtx[4][i] < 1) printf("bad nvtx[4][%d]=%d", i, nvtx[4][i]);
				if (nvtx[5][i] < 1) printf("bad nvtx[5][%d]=%d", i, nvtx[5][i]);
				if (nvtx[6][i] < 1) printf("bad nvtx[6][%d]=%d", i, nvtx[6][i]);
				if (nvtx[7][i] < 1) printf("bad nvtx[7][%d]=%d", i, nvtx[7][i]);
			}
			else {
				//fprintf(fp_4, "%d %d %d %d %d %d %d %d \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
				
				nvtx_buf[0][i] = nvtx[0][i]-1;
				nvtx_buf[1][i] = nvtx[1][i]-1;
				nvtx_buf[2][i] = nvtx[2][i]-1;
				nvtx_buf[3][i] = nvtx[3][i]-1;
				nvtx_buf[4][i] = nvtx[4][i]-1;
				nvtx_buf[5][i] = nvtx[5][i]-1;
				nvtx_buf[6][i] = nvtx[6][i]-1;
				nvtx_buf[7][i] = nvtx[7][i]-1;
			}
#endif

		}
		//fclose(fp_4);
		//WinExec("C:\\Program Files\\Tecplot\\Tecplot 360 EX 2014 R1\\bin\\tec360.exe ALICEFLOW0_24ALICEMESH.PLT", SW_NORMAL);
	//}

} // ANES_tecplot360_export_temperature_preobrazovatel


  // Специальный проверяющий корректность код.
// Он должен проходить без предупреждающих сообщений.
void ANES_ALICE_CORRECT(integer maxnod, TOCHKA* pa,
	integer maxelm, integer** nvtx) {

	// Семантика вызова:
	//ANES_ALICE_CORRECT(maxnod, pa, maxelm, nvtx);

	// 2 ноября 2016. машинное эпсилон.
	//doublereal eps_mashine = 1.0e-44; // float
	doublereal eps_mashine = 1.0e-308; // double


	// nvtx && pa сформированы, можно экспортировать в tecplot360
	

		
		doublereal* vol = new doublereal[maxnod];
		for (integer i = 0; i < maxnod; i++) {
			vol[i] = 0.0;
		}
		/*
		// Здесь мы ловим конкретную исключительную ситуацию.
		bool bfound = false;
		for (integer i = 0; i <= maxelm - 1; i++) {
		for (integer j = 0; j <= 7; j++) {
		if (nvtx[j][i] - 1 == 69462) bfound = true;
		if (nvtx[j][i] - 1 == 69463) bfound = true;
		if (nvtx[j][i] - 1 == 69464) bfound = true;
		if (nvtx[j][i] - 1 == 69477) bfound = true;
		if (nvtx[j][i] - 1 == 69478) bfound = true;
		}
		}
		if (bfound) {
		printf("bfound\n");
		}
		else
		{
		printf("notfound\n");
		}
		*/

		for (integer i = 0; i <= maxelm - 1; i++) {
			// вычисление размеров текущего контрольного объёма:
			doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контроольного объёма
			volume3D(i, nvtx, pa, dx, dy, dz);

			// Проверка корректности нахождения объёма ячейки.
#if doubleintprecision == 1
			if (dx < 1.0e-37) {
				printf("error !!! i=%lld  dx=%e\n", i, dx);
			}
			if (dy < 1.0e-37) {
				printf("error !!! i=%lld dy=%e\n", i, dy);
			}
			if (dz < 1.0e-37) {
				printf("error !!! i=%lld dz=%e\n", i, dz);
			}
#else
			if (dx < 1.0e-37) {
				printf("error !!! i=%d  dx=%e\n", i, dx);
			}
			if (dy < 1.0e-37) {
				printf("error !!! i=%d dy=%e\n", i, dy);
			}
			if (dz < 1.0e-37) {
				printf("error !!! i=%d dz=%e\n", i, dz);
			}
#endif
			

			for (integer j = 0; j <= 7; j++) {
				// nvtx[j][i]-1 - это по определению номер в pa указывающий на координаты узла.
				vol[nvtx[j][i] - 1] += dx*dy*dz;
			}
		}
		for (integer i = 0; i < maxnod; i++) {
			if (fabs(vol[i])>eps_mashine) {
				// Здесь содержится код корректной обработки.
			}
			else {
#if doubleintprecision == 1
				printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%lld maxnod=%lld\n", i, maxnod);
				printf("vol[%lld]==%e x=%e y=%e z=%e\n", i, vol[i], pa[i].x, pa[i].y, pa[i].z);
#else
				printf("fatal error! ANES_tecplot_export in module constr_struct_alice.cpp. i=%d maxnod=%d\n", i, maxnod);
				printf("vol[%d]==%e x=%e y=%e z=%e\n", i, vol[i], pa[i].x, pa[i].y, pa[i].z);
#endif
				
				//getchar();
				system("PAUSE");
			}
		}
		
		delete[] vol;

		for (integer i = 0; i <= maxelm - 1; i++) {
#if doubleintprecision == 1
			if (nvtx[0][i] < 1) printf("bad nvtx[0][%lld]=%lld", i, nvtx[0][i]);
			if (nvtx[1][i] < 1) printf("bad nvtx[1][%lld]=%lld", i, nvtx[1][i]);
			if (nvtx[2][i] < 1) printf("bad nvtx[2][%lld]=%lld", i, nvtx[2][i]);
			if (nvtx[3][i] < 1) printf("bad nvtx[3][%lld]=%lld", i, nvtx[3][i]);
			if (nvtx[4][i] < 1) printf("bad nvtx[4][%lld]=%lld", i, nvtx[4][i]);
			if (nvtx[5][i] < 1) printf("bad nvtx[5][%lld]=%lld", i, nvtx[5][i]);
			if (nvtx[6][i] < 1) printf("bad nvtx[6][%lld]=%lld", i, nvtx[6][i]);
			if (nvtx[7][i] < 1) printf("bad nvtx[7][%lld]=%lld", i, nvtx[7][i]);
#else
			if (nvtx[0][i] < 1) printf("bad nvtx[0][%d]=%d", i, nvtx[0][i]);
			if (nvtx[1][i] < 1) printf("bad nvtx[1][%d]=%d", i, nvtx[1][i]);
			if (nvtx[2][i] < 1) printf("bad nvtx[2][%d]=%d", i, nvtx[2][i]);
			if (nvtx[3][i] < 1) printf("bad nvtx[3][%d]=%d", i, nvtx[3][i]);
			if (nvtx[4][i] < 1) printf("bad nvtx[4][%d]=%d", i, nvtx[4][i]);
			if (nvtx[5][i] < 1) printf("bad nvtx[5][%d]=%d", i, nvtx[5][i]);
			if (nvtx[6][i] < 1) printf("bad nvtx[6][%d]=%d", i, nvtx[6][i]);
			if (nvtx[7][i] < 1) printf("bad nvtx[7][%d]=%d", i, nvtx[7][i]);
#endif
			
		}
		

} // ANES_ALICE_CORRECT

// визуализация в tecplot 360 с учётом hollow блоков в программной модели.
// Построение nodes, nvtx, prop для гидродинамической подобласти. Частей 19..22 в программной модели. 
void constr_nodes_nvtx_prop_flow_alice(octTree* &oc, integer inx, integer iny, integer inz, integer &maxelm, doublereal* &xpos, doublereal* &ypos, doublereal* &zpos,
	integer iflag, BLOCK* b, integer lb,  TOCHKA* &pa, integer &maxnode, integer** &nvtx,
	doublereal** &prop, TPROP* matlist, integer* &ptr, integer* &whot_is_block, integer** &ptr_temp, integer maxelm_temp) {

	integer maxelm_loc = (inx + 1)*(iny + 1)*(inz + 1);
	// Вычисление maxelm. (maxelm_flow).
	calculate_max_elm(oc, maxelm, iflag, b, lb, false);
#if doubleintprecision == 1
	//printf("%lld \n",maxelm);
#else
	//printf("%d \n",maxelm);
#endif
	
	//getchar();


	// Выделение памяти :
	ptr_temp = NULL;
	ptr_temp = new integer*[2];
	if (ptr_temp == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for ptr_temp constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	for (integer i = 0; i<2; i++) ptr_temp[i] = NULL;

	for (integer i = 0; i<2; i++) {
		ptr_temp[i] = new integer[maxelm_temp];
		if (ptr_temp[i] == NULL) {
			// недостаточно памяти на данном оборудовании.
#if doubleintprecision == 1
			printf("Problem : not enough memory on your equipment for ptr[%lld] constr struct_alice...\n", i);
#else
			printf("Problem : not enough memory on your equipment for ptr[%d] constr struct_alice...\n", i);
#endif
			
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
	}

	for (integer i = 0; i < 2; i++) {
		for (integer i87 = 0; i87 < maxelm_temp; i87++) {
			ptr_temp[i][i87] = -1; // инициализация твердым телом.
		}
	}

	// ptr[1][temp_elm_id]==fluid_domain_id or -1.


	whot_is_block = NULL;
	whot_is_block = new integer[maxelm];
	if (whot_is_block == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for whot_is_block constr struct_alice...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}

	ptr = NULL; // maxelm_flow
	ptr = new integer[maxelm];
	if (ptr == NULL) { // -2N
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for ptr flow0 constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}

	prop = NULL;
	switch (iflag) {
	case TEMPERATURE: 
		prop = new doublereal*[6];
		if (prop == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for prop constr struct_alice...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		for (integer i = 0; i<6; i++) prop[i] = NULL;
		for (integer i = 0; i<6; i++) {
			prop[i] = new doublereal[maxelm];
			if (prop[i] == NULL) {
				// недостаточно памяти на данном оборудовании.
#if doubleintprecision == 1
				printf("Problem : not enough memory on your equipment for prop[%lld] constr struct_alice...\n", i);
#else
				printf("Problem : not enough memory on your equipment for prop[%d] constr struct_alice...\n", i);
#endif
				
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}
		}
		break;
		// Работает универсально и для гидродинамической подобласти.
	case HYDRODINAMIC: 
		prop = new doublereal*[3];
		if (prop == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for prop flow constr struct_alice...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		for (integer i = 0; i<3; i++) prop[i] = NULL;
		for (integer i = 0; i<3; i++) {
			prop[i] = new doublereal[maxelm];
			if (prop[i] == NULL) {
				// недостаточно памяти на данном оборудовании.
#if doubleintprecision == 1
				printf("Problem : not enough memory on your equipment for prop[%lld] flow constr struct_alice...\n", i);
#else
				printf("Problem : not enough memory on your equipment for prop[%d] flow constr struct_alice...\n", i);
#endif
				
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}
		}
		break;
	}


	
	
	


	// Вычисление допуска.
	doublereal epsTolx = 1.0e40;
	doublereal epsToly = 1.0e40;
	doublereal epsTolz = 1.0e40;
	const doublereal mdop = 0.75;
	for (integer i = 0; i < inx; i++) {
		if (fabs(xpos[i + 1] - xpos[i]) < epsTolx) {
			epsTolx = mdop*fabs(xpos[i + 1] - xpos[i]);
		}
	}
	for (integer i = 0; i < iny; i++) {
		if (fabs(ypos[i + 1] - ypos[i]) < epsToly) {
			epsToly = mdop*fabs(ypos[i + 1] - ypos[i]);
		}
	}
	for (integer i = 0; i < inz; i++) {
		if (fabs(zpos[i + 1] - zpos[i]) < epsTolz) {
			epsTolz = mdop*fabs(zpos[i + 1] - zpos[i]);
		}
	}

	printf("geometric precision tolerance : epsTolx=%e epsToly=%e epsTolz=%e\n", epsTolx, epsToly, epsTolz);
	//system("PAUSE");


	// сформировать pa.
	// заодно посчитать количество узловых точек.
	// сформировать nvtx которые ссылаются на pa.
	// визуализировать сетку.
	TOCHKA* pa_alice = NULL;
	pa_alice = new TOCHKA[(inx + 1)*(iny + 1)*(inz + 1)];
	if (pa_alice == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for pa_alice in adaptive_local_refinement_mesh generator...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	integer marker_pa = 0;
	// И тут же сразу формируем nvtx:
	nvtx = NULL;
	nvtx = new integer*[8];
	if (nvtx == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for nvtx in adaptive_local_refinement_mesh generator...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	for (integer k_1 = 0; k_1 < 8; k_1++) {
		nvtx[k_1] = NULL;
		nvtx[k_1] = new integer[maxelm];
		if (nvtx[k_1] == NULL) {
			// недостаточно памяти на данном оборудовании.
#if doubleintprecision == 1
			printf("Problem : not enough memory on your equipment for nvtx[%lld] in adaptive_local_refinement_mesh generator...\n", k_1);
#else
			printf("Problem : not enough memory on your equipment for nvtx[%d] in adaptive_local_refinement_mesh generator...\n", k_1);
#endif
			
			printf("Please any key to exit...\n");
			exit(1);
		}
	}
	integer imarker_nvtx = 0;

	HASH_POLE* hash_table_export = new HASH_POLE[(inx + 1)*(iny + 1)*(inz + 1)];
	for (integer i_1 = 0; i_1 < (inx + 1)*(iny + 1)*(inz + 1); i_1++) {
		hash_table_export[i_1].flag = false;
		hash_table_export[i_1].inum = -1;
	}

	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}


	while (top_ALICE_STACK > 0) {

		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				// Гасим информацию о посещениях.
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

				// это лист update pa.
				integer i0, i1, i2, i3, i4, i5, i6, i7;

				bool bfound = false;
				integer key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p0, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;

				if (!bfound) {
					i0 = marker_pa;
					pa_alice[marker_pa] = octree1->p0;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i0 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p1, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i1 = marker_pa;
					pa_alice[marker_pa] = octree1->p1;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i1 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p2, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i2 = marker_pa;
					pa_alice[marker_pa] = octree1->p2;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i2 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p3, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i3 = marker_pa;
					pa_alice[marker_pa] = octree1->p3;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i3 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p4, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i4 = marker_pa;
					pa_alice[marker_pa] = octree1->p4;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i4 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p5, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i5 = marker_pa;
					pa_alice[marker_pa] = octree1->p5;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i5 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p6, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i6 = marker_pa;
					pa_alice[marker_pa] = octree1->p6;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i6 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p7, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i7 = marker_pa;
					pa_alice[marker_pa] = octree1->p7;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i7 = hash_table_export[key_now].inum;
				}
				TOCHKA p;
				p.x = 0.125*(octree1->p0.x + octree1->p1.x + octree1->p2.x + octree1->p3.x + octree1->p4.x + octree1->p5.x + octree1->p6.x + octree1->p7.x);
				p.y = 0.125*(octree1->p0.y + octree1->p1.y + octree1->p2.y + octree1->p3.y + octree1->p4.y + octree1->p5.y + octree1->p6.y + octree1->p7.y);
				p.z = 0.125*(octree1->p0.z + octree1->p1.z + octree1->p2.z + octree1->p3.z + octree1->p4.z + octree1->p5.z + octree1->p6.z + octree1->p7.z);
				integer ib;
				bool inDomain = false;
				switch (iflag) {
				case TEMPERATURE: inDomain = in_model_temp(p, ib, b, lb);
					break;
					// Работает универсально и для гидродинамической подобласти.
				case HYDRODINAMIC: inDomain = in_model_flow(p, ib, b, lb);
					break;
				}
				if (inDomain) {
					integer l = imarker_nvtx;
					switch (iflag) {
					case TEMPERATURE: prop[RHO][l] = matlist[b[ib].imatid].rho;
						//prop[CP][l] = matlist[b[ib].imatid].cp;
						//prop[LAM][l] = matlist[b[ib].imatid].lam;
						prop[CP][l] = get_lam(matlist[b[ib].imatid].n_cp, matlist[b[ib].imatid].temp_cp, matlist[b[ib].imatid].arr_cp, 25.0);
						prop[LAM][l] = get_lam(matlist[b[ib].imatid].n_lam, matlist[b[ib].imatid].temp_lam, matlist[b[ib].imatid].arr_lam, 25.0);

						prop[MULT_LAM_X][l] = matlist[b[ib].imatid].orthotropy_multiplyer_x;
						prop[MULT_LAM_Y][l] = matlist[b[ib].imatid].orthotropy_multiplyer_y;
						prop[MULT_LAM_Z][l] = matlist[b[ib].imatid].orthotropy_multiplyer_z;
						// Эти объекты при гидродинамической обработке не передаются к заполнению.
						//Sc[l] = b[ib].Sc;
						//ipower_time_depend[l] = b[ib].ipower_time_depend;
						break;
					case HYDRODINAMIC:prop[RHO][l] = matlist[b[ib].imatid].rho;
						prop[MU][l] = matlist[b[ib].imatid].mu;
						prop[BETA_T][l] = matlist[b[ib].imatid].beta_t;
						break;
					}

					// Связь гидродинамики с теплопроводностью
					// для задач сопряжённого теплообмена.
					// ptr[fluid_elm_id]=соответствующий temper_elm_id.
					ptr[imarker_nvtx] = octree1->inum_TD-1;
					// Связь теплового внутреннего элемента с гидродинамическим внутреним элементом или -1.
					ptr_temp[0][octree1->inum_TD - 1] = imarker_nvtx; // 25.09.2016.
					// Теперь у нас все гидродинамические подобласти слиты в одну и это позволяет считать 
					// в одной модели сразу несколько несвязанных гидродинамически fluid областей которые 
					// связаны лишь уравнением теплопередачи. Поэтому заполняем следующую структуру : 
					ptr_temp[1][octree1->inum_TD - 1] = 0; // Одна единственная fluid зона с идентификатором 0.
					octree1->inum_FD = imarker_nvtx + 1; // Нумерация начинается с 1.

					// Нумерация начинается с единицы .
					nvtx[0][imarker_nvtx] = i0 + 1;
					nvtx[1][imarker_nvtx] = i1 + 1;
					nvtx[2][imarker_nvtx] = i2 + 1;
					nvtx[3][imarker_nvtx] = i3 + 1;
					nvtx[4][imarker_nvtx] = i4 + 1;
					nvtx[5][imarker_nvtx] = i5 + 1;
					nvtx[6][imarker_nvtx] = i6 + 1;
					nvtx[7][imarker_nvtx] = i7 + 1;

					whot_is_block[imarker_nvtx] = ib;

					imarker_nvtx++;
				}

				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;


			}
			else {

				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}

			}
		}

	}
	delete[] hash_table_export;

	maxnode = marker_pa;
	pa = NULL;
	pa = new TOCHKA[maxnode];
	if (pa == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for pa constr struct alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	for (integer i = 0; i < maxnode; i++) {
		pa[i] = pa_alice[i];
	}
	delete[] pa_alice;
	pa_alice = NULL;

	// nvtx && pa сформированы, можно экспортировать в tecplot360
	FILE *fp_4 = NULL;
	errno_t err_4;
	if ((err_4 = fopen_s(&fp_4, "ALICEFLOW0_24ALICEMESH.PLT", "w")) != 0) {
		printf("Create File temp Error\n");
		//getchar();
		system("pause");

	}
	else {
		if (fp_4 != NULL) {
			fprintf(fp_4, "TITLE = \"ALICEFLOW0_24\"\n");
			fprintf(fp_4, "VARIABLES = x, y, z\n");
#if doubleintprecision == 1
			fprintf(fp_4, "ZONE T=\"Rampant\", N=%lld, E=%lld, ET=BRICK, F=FEBLOCK\n\n", marker_pa, imarker_nvtx);
#else
			fprintf(fp_4, "ZONE T=\"Rampant\", N=%d, E=%d, ET=BRICK, F=FEBLOCK\n\n", marker_pa, imarker_nvtx);
#endif
			
			// запись x
			for (integer i = 0; i < marker_pa; i++) {
				fprintf(fp_4, "%+.16f ", pa[i].x);
				if (i % 10 == 0) fprintf(fp_4, "\n");
			}
			fprintf(fp_4, "\n");
			// запись y
			for (integer i = 0; i < marker_pa; i++) {
				fprintf(fp_4, "%+.16f ", pa[i].y);
				if (i % 10 == 0) fprintf(fp_4, "\n");
			}
			fprintf(fp_4, "\n");
			// запись z
			for (integer i = 0; i < marker_pa; i++) {
				fprintf(fp_4, "%+.16f ", pa[i].z);
				if (i % 10 == 0) fprintf(fp_4, "\n");
			}
			fprintf(fp_4, "\n");
			for (integer i = 0; i <= imarker_nvtx - 1; i++) {
#if doubleintprecision == 1
				fprintf(fp_4, "%lld %lld %lld %lld %lld %lld %lld %lld \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
#else
				fprintf(fp_4, "%d %d %d %d %d %d %d %d \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
#endif
			}
			fclose(fp_4);
			//WinExec("C:\\Program Files\\Tecplot\\Tecplot 360 EX 2014 R1\\bin\\tec360.exe ALICEFLOW0_24ALICEMESH.PLT", SW_NORMAL);
		}
	}
} // constr_nodes_nvtx_prop_flow_alice

// Увеличивает количество граничных граней при нахождении внутреннего источника тепла.
void patch_maxbound(integer iplane, SOURCE* s, integer ls, doublereal x_c, doublereal y_c, doublereal z_c, integer &maxbound, bool &binc, integer &lsid) {
	bool bfind = false;
	binc = false;
	for (integer j = 0; j<ls; j++) {
		if (s[j].iPlane == iplane) {
			switch (iplane) {
			case XY: s[j].g.zE = s[j].g.zS;
				if ((x_c>s[j].g.xS) && (x_c<s[j].g.xE) && (y_c>s[j].g.yS) && (y_c<s[j].g.yE) && (fabs(z_c - s[j].g.zE)<admission)) bfind = true;
				break;
			case XZ:  s[j].g.yE = s[j].g.yS;
				if ((x_c>s[j].g.xS) && (x_c<s[j].g.xE) && (z_c>s[j].g.zS) && (z_c<s[j].g.zE) && (fabs(y_c - s[j].g.yE)<admission)) bfind = true;
				break;
			case YZ: s[j].g.xE = s[j].g.xS;
				if ((z_c>s[j].g.zS) && (z_c<s[j].g.zE) && (y_c>s[j].g.yS) && (y_c<s[j].g.yE) && (fabs(x_c - s[j].g.xE)<admission)) bfind = true;
				break;
			}
		}
		if (bfind) {
			lsid = j;
			break; // досрочный выход из цикла for.
		}
	}
	if (bfind) {
		// нужно присвоить грани соответствующий номер maxbound.
		// gran[G][i]=maxbound++;
		maxbound++;
		binc = true;
	}
} // patch_maxbound

// Вычисляет количество граничных элементов модели для температуры.
// Внутренние источники тепла также пронумерованы.
void calculate_max_bound_temp(octTree* &oc, integer &maxbound, integer maxelm_memo, BLOCK* b, integer lb, 
	SOURCE* s, integer ls) {
	maxbound = 0; // инициализация.
	integer maxelm = 0;
	bool *bvisit = NULL;
	bvisit = new bool[maxelm_memo];
	if (bvisit == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for bvisit constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	for (integer j = 0; j<maxelm_memo; j++) bvisit[j] = false; // признак посещения узла.
	doublereal x_c, y_c, z_c;
	integer iplane;

	top_ALICE_STACK = 0;	
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				// Гасим информацию о посещениях.
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

				if (!((octree1->link0 == NULL) && (octree1->link1 == NULL) && (octree1->link2 == NULL) && (octree1->link3 == NULL) && (octree1->link4 == NULL) && (octree1->link5 == NULL) && (octree1->link6 == NULL) && (octree1->link7 == NULL))) {
					printf("eto ne list error!!!\n");
					//getchar();
					system("PAUSE");
				}

				TOCHKA p;
				p.x = 0.125*(octree1->p0.x + octree1->p1.x + octree1->p2.x + octree1->p3.x + octree1->p4.x + octree1->p5.x + octree1->p6.x + octree1->p7.x);
				p.y = 0.125*(octree1->p0.y + octree1->p1.y + octree1->p2.y + octree1->p3.y + octree1->p4.y + octree1->p5.y + octree1->p6.y + octree1->p7.y);
				p.z = 0.125*(octree1->p0.z + octree1->p1.z + octree1->p2.z + octree1->p3.z + octree1->p4.z + octree1->p5.z + octree1->p6.z + octree1->p7.z);
				integer ib;
				bool inDomain = false;
				
				inDomain = in_model_temp(p, ib, b, lb); // TEMPERATURE
				
				
				if (inDomain) {
					// Узел принадлекжит расчётной области и его номер maxelm==octree1->inum_TD.

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4E) {
						if (octree1->linkE == NULL) {
							maxbound++;
						}
						else {
							if (octree1->linkE->inum_TD == 0) {
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkE->inum_TD - 1]) {
									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = octree1->p1.x;  
									y_c = 0.5*(octree1->p1.y+octree1->p2.y);
									z_c = 0.5*(octree1->p1.z+octree1->p5.z);
									iplane = YZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound,binc,lsid);
								}
							}
						}
					}
					else {

						if ((octree1->linkE1 == NULL) && (octree1->linkE2 == NULL) && (octree1->linkE5 == NULL) && (octree1->linkE6 == NULL)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 != NULL) && (octree1->linkE5 != NULL) && (octree1->linkE6 != NULL)&&
							(octree1->linkE1->inum_TD == 0) && (octree1->linkE2->inum_TD == 0) && (octree1->linkE5->inum_TD == 0) && (octree1->linkE6->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 == NULL) && (octree1->linkE5 != NULL) && (octree1->linkE6 == NULL) &&
							(octree1->linkE1->inum_TD == 0) && (octree1->linkE5->inum_TD == 0) ) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 != NULL) && (octree1->linkE5 == NULL) && (octree1->linkE6 == NULL) &&
							(octree1->linkE1->inum_TD == 0) && (octree1->linkE2->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 == NULL) && (octree1->linkE5 == NULL) && (octree1->linkE6 == NULL) &&
							(octree1->linkE1->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkE1 == NULL) {
								//maxbound++;
								printf("Error!!! E1 is NULL\n");
								//getchar();
								system("PAUSE");
							}
							else {
								if (octree1->linkE1->inum_TD == 0) {
									maxbound++;
									
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE1->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE1->p0.y + octree1->linkE1->p3.y);
										z_c = 0.5*(octree1->linkE1->p0.z + octree1->linkE1->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										
									}
								}
							}

							if (octree1->linkE2 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkE2->inum_TD == 0) {
									maxbound++;
									
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE2->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE2->p0.y + octree1->linkE2->p3.y);
										z_c = 0.5*(octree1->linkE2->p0.z + octree1->linkE2->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										
									}
								}
							}

							if (octree1->linkE5 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkE5->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE5->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE5->p0.y + octree1->linkE5->p3.y);
										z_c = 0.5*(octree1->linkE5->p0.z + octree1->linkE5->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
									}
								}
							}

							if (octree1->linkE6 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkE6->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE6->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE6->p0.y + octree1->linkE6->p3.y);
										z_c = 0.5*(octree1->linkE6->p0.z + octree1->linkE6->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
									}
								}
							}
						}
					}
					
					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4W) {
						if (octree1->linkW == NULL) {
							maxbound++;
						}
						else {
							if (octree1->linkW->inum_TD == 0) {
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkW->inum_TD - 1]) {
									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = octree1->p0.x;
									y_c = 0.5*(octree1->p0.y + octree1->p3.y);
									z_c = 0.5*(octree1->p0.z + octree1->p4.z);
									iplane = YZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound,binc,lsid);
								}
							}
						}
					}
					else {
						if ((octree1->linkW0 == NULL) && (octree1->linkW3 == NULL) && (octree1->linkW4 == NULL) && (octree1->linkW7 == NULL)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 != NULL) && (octree1->linkW4 != NULL) && (octree1->linkW7 != NULL) &&
							(octree1->linkW0->inum_TD == 0) && (octree1->linkW3->inum_TD == 0) && (octree1->linkW4->inum_TD == 0) && (octree1->linkW7->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 == NULL) && (octree1->linkW4 != NULL) && (octree1->linkW7 == NULL) &&
							(octree1->linkW0->inum_TD == 0)  && (octree1->linkW4->inum_TD == 0) ) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}						
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 != NULL) && (octree1->linkW4 == NULL) && (octree1->linkW7 == NULL) &&
							(octree1->linkW0->inum_TD == 0) && (octree1->linkW3->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 == NULL) && (octree1->linkW4 == NULL) && (octree1->linkW7 == NULL) &&
							(octree1->linkW0->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkW0 == NULL) {
								//maxbound++;
								printf("Error!!! W0 is NULL\n");
								//getchar();
								system("PAUSE");
							}
							else {
								if (octree1->linkW0->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW0->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW0->p1.y + octree1->linkW0->p2.y);
										z_c = 0.5*(octree1->linkW0->p1.z + octree1->linkW0->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
									}
								}
							}

							if (octree1->linkW3 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkW3->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW3->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW3->p1.y + octree1->linkW3->p2.y);
										z_c = 0.5*(octree1->linkW3->p1.z + octree1->linkW3->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
									}
								}
							}

							if (octree1->linkW4 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkW4->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW4->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW4->p1.y + octree1->linkW4->p2.y);
										z_c = 0.5*(octree1->linkW4->p1.z + octree1->linkW4->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
									}
								}
							}

							if (octree1->linkW7 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkW7->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW7->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW7->p1.y + octree1->linkW7->p2.y);
										z_c = 0.5*(octree1->linkW7->p1.z + octree1->linkW7->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
									}
								}
							}
						}
					}

					
					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4N) {
						if (octree1->linkN == NULL) {
							maxbound++;
						}
						else {
							if (octree1->linkN->inum_TD == 0) {
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkN->inum_TD - 1]) {
									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c =  0.5*(octree1->p2.x + octree1->p3.x);
									y_c = octree1->p3.y;
									z_c = 0.5*(octree1->p3.z + octree1->p7.z);
									iplane = XZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound,binc,lsid);
								}
							}
						}
					}
					else {

						if ((octree1->linkN2 == NULL) && (octree1->linkN3 == NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 == NULL)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkN2 != NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 != NULL) && (octree1->linkN7 != NULL) &&
							(octree1->linkN2->inum_TD == 0) && (octree1->linkN3->inum_TD == 0) && (octree1->linkN6->inum_TD == 0) && (octree1->linkN7->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkN2 == NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 != NULL) &&
							 (octree1->linkN3->inum_TD == 0)  && (octree1->linkN7->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkN2 != NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 == NULL) &&
							(octree1->linkN2->inum_TD == 0) && (octree1->linkN3->inum_TD == 0) ) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkN2 == NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 == NULL) &&
							 (octree1->linkN3->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkN2 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkN2->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN2->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN2->p0.x + octree1->linkN2->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN2->p0.z + octree1->linkN2->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
									}
								}
							}

							if (octree1->linkN3 == NULL) {
								//maxbound++;
								printf("Error!!! N3 is NULL\n");
								//getchar();
								system("PAUSE");
							}
							else {
								if (octree1->linkN3->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN3->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN3->p0.x + octree1->linkN3->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN3->p0.z + octree1->linkN3->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
									}
								}
							}

							if (octree1->linkN6 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkN6->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN6->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN6->p0.x + octree1->linkN6->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN6->p0.z + octree1->linkN6->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
									}
								}
							}

							if (octree1->linkN7 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkN7->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN7->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN7->p0.x + octree1->linkN7->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN7->p0.z + octree1->linkN7->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4S) {
						if (octree1->linkS == NULL) {
							maxbound++;
						}
						else {
							if (octree1->linkS->inum_TD == 0) {
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkS->inum_TD - 1]) {
									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c =  0.5*(octree1->p0.x + octree1->p1.x);
									y_c = octree1->p0.y;
									z_c = 0.5*(octree1->p0.z + octree1->p4.z);
									iplane = XZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound,binc, lsid);
								}
							}
						}
					}
					else {
						if ((octree1->linkS0 == NULL) && (octree1->linkS1 == NULL) && (octree1->linkS4 == NULL) && (octree1->linkS5 == NULL)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 != NULL) && (octree1->linkS4 != NULL) && (octree1->linkS5 != NULL) &&
							(octree1->linkS0->inum_TD == 0) && (octree1->linkS1->inum_TD == 0) && (octree1->linkS4->inum_TD == 0) && (octree1->linkS5->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 == NULL) && (octree1->linkS4 != NULL) && (octree1->linkS5 == NULL) &&
							(octree1->linkS0->inum_TD == 0)  && (octree1->linkS4->inum_TD == 0) ) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 != NULL) && (octree1->linkS4 == NULL) && (octree1->linkS5 == NULL) &&
							(octree1->linkS0->inum_TD == 0) && (octree1->linkS1->inum_TD == 0) ) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 == NULL) && (octree1->linkS4 == NULL) && (octree1->linkS5 == NULL) &&
							(octree1->linkS0->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkS0 == NULL) {
								//maxbound++;
								printf("Error!!! S0 is NULL\n");
								//getchar();
								system("PAUSE");
							}
							else {
								if (octree1->linkS0->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS0->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS0->p3.x + octree1->linkS0->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS0->p3.z + octree1->linkS0->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
									}
								}
							}

							if (octree1->linkS1 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkS1->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS1->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS1->p3.x + octree1->linkS1->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS1->p3.z + octree1->linkS1->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
									}
								}
							}

							if (octree1->linkS4 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkS4->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS4->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS4->p3.x + octree1->linkS4->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS4->p3.z + octree1->linkS4->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
									}
								}
							}

							if (octree1->linkS5 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkS5->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS5->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS5->p3.x + octree1->linkS5->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS5->p3.z + octree1->linkS5->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4T) {
						if (octree1->linkT == NULL) {
							maxbound++;
						}
						else {
							if (octree1->linkT->inum_TD == 0) {
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkT->inum_TD - 1]) {
									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p4.x + octree1->p5.x);
									y_c = 0.5*(octree1->p4.y + octree1->p7.y);
									z_c = octree1->p4.z;
									iplane = XY;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
								}
							}
						}
					}
					else {

						if ((octree1->linkT4 == NULL) && (octree1->linkT5 == NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 == NULL)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 != NULL) && (octree1->linkT6 != NULL) && (octree1->linkT7 != NULL) &&
							(octree1->linkT4->inum_TD == 0) && (octree1->linkT5->inum_TD == 0) && (octree1->linkT6->inum_TD == 0) && (octree1->linkT7->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 == NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 != NULL) &&
							(octree1->linkT4->inum_TD == 0)  && (octree1->linkT7->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 != NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 == NULL) &&
							(octree1->linkT4->inum_TD == 0) && (octree1->linkT5->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 == NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 == NULL) &&
							(octree1->linkT4->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkT4 == NULL) {
								//maxbound++;
								printf("Error!!! T4 is NULL\n");
								//getchar();
								system("PAUSE");
							}
							else {
								if (octree1->linkT4->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT4->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT4->p0.x + octree1->linkT4->p1.x);
										y_c = 0.5*(octree1->linkT4->p0.y + octree1->linkT4->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
									}
								}
							}

							if (octree1->linkT5 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkT5->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT5->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT5->p0.x + octree1->linkT5->p1.x);
										y_c = 0.5*(octree1->linkT5->p0.y + octree1->linkT5->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
									}
								}
							}

							if (octree1->linkT6 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkT6->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT6->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT6->p0.x + octree1->linkT6->p1.x);
										y_c = 0.5*(octree1->linkT6->p0.y + octree1->linkT6->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
									}
								}
							}

							if (octree1->linkT7 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkT7->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT7->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT7->p0.x + octree1->linkT7->p1.x);
										y_c = 0.5*(octree1->linkT7->p0.y + octree1->linkT7->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4B) {
						if (octree1->linkB == NULL) {
							maxbound++;
						}
						else {
							if (octree1->linkB->inum_TD == 0) {
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkB->inum_TD - 1]) {
									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p0.x + octree1->p1.x);
									y_c = 0.5*(octree1->p0.y + octree1->p3.y);
									z_c = octree1->p0.z;
									iplane = XY;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
								}
							}
						}
					}
					else {

						if ((octree1->linkB0 == NULL) && (octree1->linkB1 == NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 == NULL)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 != NULL) && (octree1->linkB2 != NULL) && (octree1->linkB3 != NULL) &&
							(octree1->linkB0->inum_TD == 0) && (octree1->linkB1->inum_TD == 0) && (octree1->linkB2->inum_TD == 0) && (octree1->linkB3->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 == NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 != NULL) &&
							(octree1->linkB0->inum_TD == 0)  && (octree1->linkB3->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 != NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 == NULL) &&
							(octree1->linkB0->inum_TD == 0) && (octree1->linkB1->inum_TD == 0) ) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 == NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 == NULL) &&
							(octree1->linkB0->inum_TD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkB0 == NULL) {
								//maxbound++;
								printf("Error!!! B0 is NULL\n");
								//getchar();
								system("PAUSE");
							}
							else {
								if (octree1->linkB0->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB0->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB0->p4.x + octree1->linkB0->p5.x);
										y_c = 0.5*(octree1->linkB0->p4.y + octree1->linkB0->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
									}
								}
							}

							if (octree1->linkB1 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkB1->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB1->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB1->p4.x + octree1->linkB1->p5.x);
										y_c = 0.5*(octree1->linkB1->p4.y + octree1->linkB1->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
									}
								}
							}

							if (octree1->linkB2 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkB2->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB2->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB2->p4.x + octree1->linkB2->p5.x);
										y_c = 0.5*(octree1->linkB2->p4.y + octree1->linkB2->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
									}
								}
							}

							if (octree1->linkB3 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkB3->inum_TD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB3->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB3->p4.x + octree1->linkB3->p5.x);
										y_c = 0.5*(octree1->linkB3->p4.y + octree1->linkB3->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
									}
								}
							}
						}
					}


					bvisit[maxelm] = true; // Узел был посещён.
					maxelm++;
				}
				//octree1->inum_TD = 0; // По умолчанию не принадлежит расчётной области.
				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}

	delete[] bvisit;
	bvisit = NULL;
} // calculate_max_bound_temp


// Вычисляет количество граничных элементов модели для температуры.
// Внутренние источники тепла также пронумерованы.
void calculate_max_bound_flow(octTree* &oc, integer &maxbound, integer maxelm_memo, BLOCK* b, integer lb,
	SOURCE* s, integer ls) {
	maxbound = 0; // инициализация.
	integer maxelm = 0;
	bool *bvisit = NULL;
	bvisit = new bool[maxelm_memo];
	if (bvisit == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for bvisit constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	for (integer j = 0; j<maxelm_memo; j++) bvisit[j] = false; // признак посещения узла.
	doublereal x_c, y_c, z_c;
	integer iplane;

	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				// Гасим информацию о посещениях.
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

				if (!((octree1->link0 == NULL) && (octree1->link1 == NULL) && (octree1->link2 == NULL) && (octree1->link3 == NULL) && (octree1->link4 == NULL) && (octree1->link5 == NULL) && (octree1->link6 == NULL) && (octree1->link7 == NULL))) {
					printf("eto ne list error!!!\n");
					//getchar();
					system("PAUSE");
				}

				TOCHKA p;
				p.x = 0.125*(octree1->p0.x + octree1->p1.x + octree1->p2.x + octree1->p3.x + octree1->p4.x + octree1->p5.x + octree1->p6.x + octree1->p7.x);
				p.y = 0.125*(octree1->p0.y + octree1->p1.y + octree1->p2.y + octree1->p3.y + octree1->p4.y + octree1->p5.y + octree1->p6.y + octree1->p7.y);
				p.z = 0.125*(octree1->p0.z + octree1->p1.z + octree1->p2.z + octree1->p3.z + octree1->p4.z + octree1->p5.z + octree1->p6.z + octree1->p7.z);
				integer ib;
				bool inDomain = false;

				inDomain = in_model_flow(p, ib, b, lb); // HYDRODINAMIC  CFD!!!


				if (inDomain) {
					// Узел принадлекжит расчётной области и его номер maxelm==octree1->inum_FD.

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4E) {
						if (octree1->linkE == NULL) {
							maxbound++;
						}
						else {
							if (octree1->linkE->inum_FD == 0) {
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkE->inum_FD - 1]) {
									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = octree1->p1.x;
									y_c = 0.5*(octree1->p1.y + octree1->p2.y);
									z_c = 0.5*(octree1->p1.z + octree1->p5.z);
									iplane = YZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
									if (binc) {
										printf("error in calculate_max_bound_flow...\n");
										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										exit(1);
									}

								}
							}
						}
					}
					else {

						if ((octree1->linkE1 == NULL) && (octree1->linkE2 == NULL) && (octree1->linkE5 == NULL) && (octree1->linkE6 == NULL)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 != NULL) && (octree1->linkE5 != NULL) && (octree1->linkE6 != NULL) &&
							(octree1->linkE1->inum_FD == 0) && (octree1->linkE2->inum_FD == 0) && (octree1->linkE5->inum_FD == 0) && (octree1->linkE6->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 == NULL) && (octree1->linkE5 != NULL) && (octree1->linkE6 == NULL) &&
							(octree1->linkE1->inum_FD == 0) && (octree1->linkE5->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 != NULL) && (octree1->linkE5 == NULL) && (octree1->linkE6 == NULL) &&
							(octree1->linkE1->inum_FD == 0) && (octree1->linkE2->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 == NULL) && (octree1->linkE5 == NULL) && (octree1->linkE6 == NULL) &&
							(octree1->linkE1->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkE1 == NULL) {
								//maxbound++;
								printf("Error!!! E1 is NULL\n");
								//getchar();
								system("PAUSE");
							}
							else {
								if (octree1->linkE1->inum_FD == 0) {
									maxbound++;

								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE1->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE1->p0.y + octree1->linkE1->p3.y);
										z_c = 0.5*(octree1->linkE1->p0.z + octree1->linkE1->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);

									}
								}
							}

							if (octree1->linkE2 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkE2->inum_FD == 0) {
									maxbound++;

								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE2->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE2->p0.y + octree1->linkE2->p3.y);
										z_c = 0.5*(octree1->linkE2->p0.z + octree1->linkE2->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);

									}
								}
							}

							if (octree1->linkE5 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkE5->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE5->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE5->p0.y + octree1->linkE5->p3.y);
										z_c = 0.5*(octree1->linkE5->p0.z + octree1->linkE5->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
									}
								}
							}

							if (octree1->linkE6 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkE6->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE6->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE6->p0.y + octree1->linkE6->p3.y);
										z_c = 0.5*(octree1->linkE6->p0.z + octree1->linkE6->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4W) {
						if (octree1->linkW == NULL) {
							maxbound++;
						}
						else {
							if (octree1->linkW->inum_FD == 0) {
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkW->inum_FD - 1]) {
									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = octree1->p0.x;
									y_c = 0.5*(octree1->p0.y + octree1->p3.y);
									z_c = 0.5*(octree1->p0.z + octree1->p4.z);
									iplane = YZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
									if (binc) {
										printf("error in calculate_max_bound_flow...\n");
										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										exit(1);
									}

								}
							}
						}
					}
					else {
						if ((octree1->linkW0 == NULL) && (octree1->linkW3 == NULL) && (octree1->linkW4 == NULL) && (octree1->linkW7 == NULL)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 != NULL) && (octree1->linkW4 != NULL) && (octree1->linkW7 != NULL) &&
							(octree1->linkW0->inum_FD == 0) && (octree1->linkW3->inum_FD == 0) && (octree1->linkW4->inum_FD == 0) && (octree1->linkW7->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 == NULL) && (octree1->linkW4 != NULL) && (octree1->linkW7 == NULL) &&
							(octree1->linkW0->inum_FD == 0) && (octree1->linkW4->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 != NULL) && (octree1->linkW4 == NULL) && (octree1->linkW7 == NULL) &&
							(octree1->linkW0->inum_FD == 0) && (octree1->linkW3->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 == NULL) && (octree1->linkW4 == NULL) && (octree1->linkW7 == NULL) &&
							(octree1->linkW0->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkW0 == NULL) {
								//maxbound++;
								printf("Error!!! W0 is NULL\n");
								//getchar();
								system("PAUSE");
							}
							else {
								if (octree1->linkW0->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW0->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW0->p1.y + octree1->linkW0->p2.y);
										z_c = 0.5*(octree1->linkW0->p1.z + octree1->linkW0->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
									}
								}
							}

							if (octree1->linkW3 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkW3->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW3->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW3->p1.y + octree1->linkW3->p2.y);
										z_c = 0.5*(octree1->linkW3->p1.z + octree1->linkW3->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
									}
								}
							}

							if (octree1->linkW4 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkW4->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW4->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW4->p1.y + octree1->linkW4->p2.y);
										z_c = 0.5*(octree1->linkW4->p1.z + octree1->linkW4->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
									}
								}
							}

							if (octree1->linkW7 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkW7->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW7->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW7->p1.y + octree1->linkW7->p2.y);
										z_c = 0.5*(octree1->linkW7->p1.z + octree1->linkW7->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
									}
								}
							}
						}
					}


					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4N) {
						if (octree1->linkN == NULL) {
							maxbound++;
						}
						else {
							if (octree1->linkN->inum_FD == 0) {
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkN->inum_FD - 1]) {
									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p2.x + octree1->p3.x);
									y_c = octree1->p3.y;
									z_c = 0.5*(octree1->p3.z + octree1->p7.z);
									iplane = XZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
									if (binc) {
										printf("error in calculate_max_bound_flow...\n");
										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										exit(1);
									}

								}
							}
						}
					}
					else {

						if ((octree1->linkN2 == NULL) && (octree1->linkN3 == NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 == NULL)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkN2 != NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 != NULL) && (octree1->linkN7 != NULL) &&
							(octree1->linkN2->inum_FD == 0) && (octree1->linkN3->inum_FD == 0) && (octree1->linkN6->inum_FD == 0) && (octree1->linkN7->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkN2 == NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 != NULL) &&
							(octree1->linkN3->inum_FD == 0) && (octree1->linkN7->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkN2 != NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 == NULL) &&
							(octree1->linkN2->inum_FD == 0) && (octree1->linkN3->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkN2 == NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 == NULL) &&
							(octree1->linkN3->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkN2 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkN2->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN2->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN2->p0.x + octree1->linkN2->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN2->p0.z + octree1->linkN2->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
									}
								}
							}

							if (octree1->linkN3 == NULL) {
								//maxbound++;
								printf("Error!!! N3 is NULL\n");
								//getchar();
								system("PAUSE");
							}
							else {
								if (octree1->linkN3->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN3->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN3->p0.x + octree1->linkN3->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN3->p0.z + octree1->linkN3->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
									}
								}
							}

							if (octree1->linkN6 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkN6->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN6->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN6->p0.x + octree1->linkN6->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN6->p0.z + octree1->linkN6->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
									}
								}
							}

							if (octree1->linkN7 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkN7->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN7->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN7->p0.x + octree1->linkN7->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN7->p0.z + octree1->linkN7->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4S) {
						if (octree1->linkS == NULL) {
							maxbound++;
						}
						else {
							if (octree1->linkS->inum_FD == 0) {
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkS->inum_FD - 1]) {
									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p0.x + octree1->p1.x);
									y_c = octree1->p0.y;
									z_c = 0.5*(octree1->p0.z + octree1->p4.z);
									iplane = XZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
									if (binc) {
										printf("error in calculate_max_bound_flow...\n");
										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										exit(1);
									}

								}
							}
						}
					}
					else {
						if ((octree1->linkS0 == NULL) && (octree1->linkS1 == NULL) && (octree1->linkS4 == NULL) && (octree1->linkS5 == NULL)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 != NULL) && (octree1->linkS4 != NULL) && (octree1->linkS5 != NULL) &&
							(octree1->linkS0->inum_FD == 0) && (octree1->linkS1->inum_FD == 0) && (octree1->linkS4->inum_FD == 0) && (octree1->linkS5->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 == NULL) && (octree1->linkS4 != NULL) && (octree1->linkS5 == NULL) &&
							(octree1->linkS0->inum_FD == 0) && (octree1->linkS4->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 != NULL) && (octree1->linkS4 == NULL) && (octree1->linkS5 == NULL) &&
							(octree1->linkS0->inum_FD == 0) && (octree1->linkS1->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 == NULL) && (octree1->linkS4 == NULL) && (octree1->linkS5 == NULL) &&
							(octree1->linkS0->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkS0 == NULL) {
								//maxbound++;
								printf("Error!!! S0 is NULL\n");
								//getchar();
								system("PAUSE");
							}
							else {
								if (octree1->linkS0->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS0->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS0->p3.x + octree1->linkS0->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS0->p3.z + octree1->linkS0->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
									}
								}
							}

							if (octree1->linkS1 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkS1->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS1->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS1->p3.x + octree1->linkS1->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS1->p3.z + octree1->linkS1->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
									}
								}
							}

							if (octree1->linkS4 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkS4->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS4->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS4->p3.x + octree1->linkS4->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS4->p3.z + octree1->linkS4->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
									}
								}
							}

							if (octree1->linkS5 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkS5->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS5->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS5->p3.x + octree1->linkS5->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS5->p3.z + octree1->linkS5->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4T) {
						if (octree1->linkT == NULL) {
							maxbound++;
						}
						else {
							if (octree1->linkT->inum_FD == 0) {
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkT->inum_FD - 1]) {
									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p4.x + octree1->p5.x);
									y_c = 0.5*(octree1->p4.y + octree1->p7.y);
									z_c = octree1->p4.z;
									iplane = XY;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
									if (binc) {
										printf("error in calculate_max_bound_flow...\n");
										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										exit(1);
									}

								}
							}
						}
					}
					else {

						if ((octree1->linkT4 == NULL) && (octree1->linkT5 == NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 == NULL)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 != NULL) && (octree1->linkT6 != NULL) && (octree1->linkT7 != NULL) &&
							(octree1->linkT4->inum_FD == 0) && (octree1->linkT5->inum_FD == 0) && (octree1->linkT6->inum_FD == 0) && (octree1->linkT7->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 == NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 != NULL) &&
							(octree1->linkT4->inum_FD == 0) && (octree1->linkT7->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 != NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 == NULL) &&
							(octree1->linkT4->inum_FD == 0) && (octree1->linkT5->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 == NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 == NULL) &&
							(octree1->linkT4->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkT4 == NULL) {
								//maxbound++;
								printf("Error!!! T4 is NULL\n");
								//getchar();
								system("PAUSE");
							}
							else {
								if (octree1->linkT4->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT4->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT4->p0.x + octree1->linkT4->p1.x);
										y_c = 0.5*(octree1->linkT4->p0.y + octree1->linkT4->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
									}
								}
							}

							if (octree1->linkT5 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkT5->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT5->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT5->p0.x + octree1->linkT5->p1.x);
										y_c = 0.5*(octree1->linkT5->p0.y + octree1->linkT5->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
									}
								}
							}

							if (octree1->linkT6 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkT6->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT6->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT6->p0.x + octree1->linkT6->p1.x);
										y_c = 0.5*(octree1->linkT6->p0.y + octree1->linkT6->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
									}
								}
							}

							if (octree1->linkT7 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkT7->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT7->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT7->p0.x + octree1->linkT7->p1.x);
										y_c = 0.5*(octree1->linkT7->p0.y + octree1->linkT7->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4B) {
						if (octree1->linkB == NULL) {
							maxbound++;
						}
						else {
							if (octree1->linkB->inum_FD == 0) {
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkB->inum_FD - 1]) {
									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p0.x + octree1->p1.x);
									y_c = 0.5*(octree1->p0.y + octree1->p3.y);
									z_c = octree1->p0.z;
									iplane = XY;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
									if (binc) {
										printf("error in calculate_max_bound_flow...\n");
										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										exit(1);
									}

								}
							}
						}
					}
					else {

						if ((octree1->linkB0 == NULL) && (octree1->linkB1 == NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 == NULL)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 != NULL) && (octree1->linkB2 != NULL) && (octree1->linkB3 != NULL) &&
							(octree1->linkB0->inum_FD == 0) && (octree1->linkB1->inum_FD == 0) && (octree1->linkB2->inum_FD == 0) && (octree1->linkB3->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 == NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 != NULL) &&
							(octree1->linkB0->inum_FD == 0) && (octree1->linkB3->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 != NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 == NULL) &&
							(octree1->linkB0->inum_FD == 0) && (octree1->linkB1->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 == NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 == NULL) &&
							(octree1->linkB0->inum_FD == 0)) {
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkB0 == NULL) {
								//maxbound++;
								printf("Error!!! B0 is NULL\n");
								//getchar();
								system("PAUSE");
							}
							else {
								if (octree1->linkB0->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB0->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB0->p4.x + octree1->linkB0->p5.x);
										y_c = 0.5*(octree1->linkB0->p4.y + octree1->linkB0->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
									}
								}
							}

							if (octree1->linkB1 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkB1->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB1->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB1->p4.x + octree1->linkB1->p5.x);
										y_c = 0.5*(octree1->linkB1->p4.y + octree1->linkB1->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
									}
								}
							}

							if (octree1->linkB2 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkB2->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB2->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB2->p4.x + octree1->linkB2->p5.x);
										y_c = 0.5*(octree1->linkB2->p4.y + octree1->linkB2->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
									}
								}
							}

							if (octree1->linkB3 == NULL) {
								//maxbound++;
								// 21 сентября 2016 (вырождение ячейки).
							}
							else {
								if (octree1->linkB3->inum_FD == 0) {
									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB3->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB3->p4.x + octree1->linkB3->p5.x);
										y_c = 0.5*(octree1->linkB3->p4.y + octree1->linkB3->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
									}
								}
							}
						}
					}


					bvisit[maxelm] = true; // Узел был посещён.
					maxelm++;
				}
				//octree1->inum_FD = 0; // По умолчанию не принадлежит расчётной области.
				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}

	delete[] bvisit;
	bvisit = NULL;
} // calculate_max_bound_flow


// G - грань по которой ставится граничное условие.
// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
// bound_id - номер граничного узла, начиная с нуля.
// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
void obrabotka_granichnoi_grani(integer G, BOUND* &sosedb, integer **nvtx, TOCHKA* pa, integer elm_id, integer bound_id,
	integer elm_id_inverse, integer maxelm_out, integer* &whot_is_block, integer ls, integer lw, WALL* w, SOURCE* s, BLOCK* b,
	doublereal dS, bool binternalg, bool bvisit_g)
{
	// G - грань по которой ставится граничное условие.
	// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
	// bound_id - номер граничного узла, начиная с нуля.
	// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.

	doublereal x_c = 0.0, y_c = 0.0, z_c = 0.0; // координаты центра грани
	integer iplane; // плоскость в которой лежит грань.

	// Эта информация совсем неактивна при данной сборке.
	for (integer j = 0; j<6; j++) sosedb[bound_id].iW[j] = -1; // инициализация

	// узнать координаты центра грани и ориентацию в пространстве
	switch (G) {
	case ESIDE: x_c = pa[nvtx[1][elm_id] - 1].x;
		y_c = 0.5*(pa[nvtx[1][elm_id] - 1].y + pa[nvtx[3][elm_id] - 1].y);
		z_c = 0.5*(pa[nvtx[0][elm_id] - 1].z + pa[nvtx[4][elm_id] - 1].z);
		iplane = YZ;
		break;
	case WSIDE: x_c = pa[nvtx[0][elm_id] - 1].x;
		y_c = 0.5*(pa[nvtx[1][elm_id] - 1].y + pa[nvtx[3][elm_id] - 1].y);
		z_c = 0.5*(pa[nvtx[0][elm_id] - 1].z + pa[nvtx[4][elm_id] - 1].z);
		iplane = YZ;
		break;
	case NSIDE: x_c = 0.5*(pa[nvtx[0][elm_id] - 1].x + pa[nvtx[1][elm_id] - 1].x);
		y_c = pa[nvtx[2][elm_id] - 1].y;
		z_c = 0.5*(pa[nvtx[0][elm_id] - 1].z + pa[nvtx[4][elm_id] - 1].z);
		iplane = XZ;
		break;
	case SSIDE: x_c = 0.5*(pa[nvtx[0][elm_id] - 1].x + pa[nvtx[1][elm_id] - 1].x);
		y_c = pa[nvtx[0][elm_id] - 1].y;
		z_c = 0.5*(pa[nvtx[0][elm_id] - 1].z + pa[nvtx[4][elm_id] - 1].z);
		iplane = XZ;
		break;
	case TSIDE: x_c = 0.5*(pa[nvtx[0][elm_id] - 1].x + pa[nvtx[1][elm_id] - 1].x);
		y_c = 0.5*(pa[nvtx[1][elm_id] - 1].y + pa[nvtx[3][elm_id] - 1].y);
		z_c = pa[nvtx[4][elm_id] - 1].z;
		iplane = XY;
		break;
	case BSIDE: x_c = 0.5*(pa[nvtx[0][elm_id] - 1].x + pa[nvtx[1][elm_id] - 1].x);
		y_c = 0.5*(pa[nvtx[1][elm_id] - 1].y + pa[nvtx[3][elm_id] - 1].y);
		z_c = pa[nvtx[0][elm_id] - 1].z;
		iplane = XY;
		break;
	} // end case

	if ((fabs(x_c) > 1.0e20) || (fabs(y_c) > 1.0e20) || (fabs(z_c) > 1.0e20)) {
#if doubleintprecision == 1
		printf("elm_id=%lld maxelm=%lld bound_id=%lld\n", elm_id, maxelm_out, bound_id);
#else
		printf("elm_id=%d maxelm=%d bound_id=%d\n", elm_id, maxelm_out, bound_id);
#endif
		
		//getchar();
		system("PAUSE");
	}

	// Площадь грани передаётся извне.
	sosedb[bound_id].dS = dS; // Присваиваем площадь граничной грани.

	// грань лежит на границе расчётной области.
	switch (G) {
	case ESIDE: sosedb[bound_id].Norm = WSIDE;
		break;
	case WSIDE: sosedb[bound_id].Norm = ESIDE;
		break;
	case NSIDE: sosedb[bound_id].Norm = SSIDE;
		break;
	case SSIDE: sosedb[bound_id].Norm = NSIDE;
		break;
	case TSIDE: sosedb[bound_id].Norm = BSIDE;
		break;
	case BSIDE: sosedb[bound_id].Norm = TSIDE;	
		break;
	} // end определеиие внутренней нормали
	sosedb[bound_id].iII = elm_id_inverse;
	sosedb[bound_id].iB = maxelm_out + bound_id;
	sosedb[bound_id].iI = elm_id;
	
	if (binternalg) {
		// 1 октября 2016 (суббота).

		// Управляющая логика здесь не нужна т.к. она уже была выполнена при вызове obrabotka_granichnoi_grani.
		//TOCHKA p;
		//p.x = 0.125*(pa[nvtx[0][elm_id] - 1].x + pa[nvtx[1][elm_id] - 1].x + pa[nvtx[2][elm_id] - 1].x + pa[nvtx[3][elm_id] - 1].x + pa[nvtx[4][elm_id] - 1].x + pa[nvtx[5][elm_id] - 1].x + pa[nvtx[6][elm_id] - 1].x + pa[nvtx[7][elm_id] - 1].x);
		//p.y = 0.125*(pa[nvtx[0][elm_id] - 1].y + pa[nvtx[1][elm_id] - 1].y + pa[nvtx[2][elm_id] - 1].y + pa[nvtx[3][elm_id] - 1].y + pa[nvtx[4][elm_id] - 1].y + pa[nvtx[5][elm_id] - 1].y + pa[nvtx[6][elm_id] - 1].y + pa[nvtx[7][elm_id] - 1].y);
		//p.z = 0.125*(pa[nvtx[0][elm_id] - 1].z + pa[nvtx[1][elm_id] - 1].z + pa[nvtx[2][elm_id] - 1].z + pa[nvtx[3][elm_id] - 1].z + pa[nvtx[4][elm_id] - 1].z + pa[nvtx[5][elm_id] - 1].z + pa[nvtx[6][elm_id] - 1].z + pa[nvtx[7][elm_id] - 1].z);
		//integer ib;
		//if (in_model_flow(p, ib, b, lb)) {
			//sosedb[bound_id].iI1 = elm_id;
		//} else {sosedb[bound_id].iI1 = elm_id; }
		// В любом случае мы присваиваем iI позицию узла.
		if (!bvisit_g) {
			// грань еще не была посещена.
			sosedb[bound_id].iI1 = elm_id;
		}
		else {
			// грань уже была посещена.
			sosedb[bound_id].iI2 = elm_id;
		}
	}
	else {
		// Не внутренний источник тепла.
		sosedb[bound_id].iI1 = -1;
		sosedb[bound_id].iI2 = -1;
	}
	//bvisit[bound_id] = true; // грань была посещена
	// Вычисляем emissivity:
	integer ibfound = -1;
	ibfound = whot_is_block[elm_id];
	if (ibfound >= 0) {
		// блок найден.
		// Определяем внутреннюю нормаль:
		switch (sosedb[bound_id].Norm) {
		case WSIDE: sosedb[bound_id].emissivity = b[ibfound].radiation.emissE;
			break;
		case ESIDE: sosedb[bound_id].emissivity = b[ibfound].radiation.emissW;
			break;
		case SSIDE: sosedb[bound_id].emissivity = b[ibfound].radiation.emissN;
			break;
		case NSIDE: sosedb[bound_id].emissivity = b[ibfound].radiation.emissS;
			break;
		case BSIDE: sosedb[bound_id].emissivity = b[ibfound].radiation.emissT;
			break;
		case TSIDE: sosedb[bound_id].emissivity = b[ibfound].radiation.emissB;
			break;
		}
	}
	else {
		printf("error: emissivity calculation block unfound. in constr_sosedb_temp.\n");
		system("PAUSE");
		exit(1);
	}
	integer jpos;

	bool bfind = false;
	for (integer j = 0; j<ls; j++) {
		if (s[j].iPlane == iplane) {
			// Важно не только попадание в фокус объекта но и нахождение с объектом на одном уровне:
			switch (iplane) {
			case XY: if ((x_c>s[j].g.xS) && (x_c<s[j].g.xE) && (y_c>s[j].g.yS) && (y_c<s[j].g.yE) && (fabs(z_c - s[j].g.zE)<admission)) { bfind = true; jpos = j; } break;
			case YZ: if ((z_c>s[j].g.zS) && (z_c<s[j].g.zE) && (y_c>s[j].g.yS) && (y_c<s[j].g.yE) && (fabs(x_c - s[j].g.xE)<admission)) { bfind = true; jpos = j; } break;
			case XZ: if ((x_c>s[j].g.xS) && (x_c<s[j].g.xE) && (z_c>s[j].g.zS) && (z_c<s[j].g.zE) && (fabs(y_c - s[j].g.yE)<admission)) { bfind = true; jpos = j; } break;
			}
		}
	}
	if (bfind) {
		// внешний источник тепла
		//printf("source out found...\n"); // debug
		//getchar();
		sosedb[bound_id].MCB = jpos;
	}
	else {
		for (integer j = 0; j<lw; j++) {
			if (w[j].iPlane == iplane) {
				// Важно не только попадание в фокус объекта но и нахождение с объектом на одном уровне:
				switch (iplane) {
				case XY: if ((x_c>w[j].g.xS) && (x_c<w[j].g.xE) && (y_c>w[j].g.yS) && (y_c<w[j].g.yE) && (fabs(z_c - w[j].g.zE)<admission)) { bfind = true; jpos = j; } break;
				case YZ: if ((z_c>w[j].g.zS) && (z_c<w[j].g.zE) && (y_c>w[j].g.yS) && (y_c<w[j].g.yE) && (fabs(x_c - w[j].g.xE)<admission)) { bfind = true; jpos = j; } break;
				case XZ: if ((x_c>w[j].g.xS) && (x_c<w[j].g.xE) && (z_c>w[j].g.zS) && (z_c<w[j].g.zE) && (fabs(y_c - w[j].g.yE)<admission)) { bfind = true; jpos = j; } break;
				}
			}
		}
		if (bfind) {
			// найдена стека
			//printf("ambient wall found...\n"); // debug
			//getchar();
			sosedb[bound_id].MCB = ls + jpos;
		}
		else {
			// граничное условие по умолчанию
			sosedb[bound_id].MCB = ls + lw;
		}

	}

} // obrabotka_granichnoi_grani

// Вычисление соседей для каждого внутреннего узла. 
// Причём множество соседей выбирается и среди внутренних КО и 
// среди граничных КО.
// Создана на базе calculate_max_bound_temp.
// Самое начало реализации. 10.сентября.2016 14_20. 
//  Середина разработки 21 сентября 2016.
// Окончил писать и жду запуска для тестирования 22 сетября 2016.
void constr_sosedi_prop_b_alice(octTree* &oc, BOUND* &sosedb, bool* &binternalsource, 
	ALICE_PARTITION** &sosedi, doublereal **prop, doublereal** &prop_b,
	integer maxbound_out, integer maxelm_memo, integer maxelm_memo1,
	BLOCK* b, integer lb, SOURCE* s, integer ls, WALL* w, integer lw, 
	integer* &whot_is_block,
	integer** nvtx, TOCHKA* &pa) {

	integer G, GG;

	// Выделение оперативной памяти.
	sosedi = NULL;
	sosedi = new ALICE_PARTITION*[12];
	if (sosedi == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for sosedi constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	for (integer i = 0; i<12; i++) sosedi[i] = NULL;
	for (integer i = 0; i<12; i++) {
		sosedi[i] = new ALICE_PARTITION[maxelm_memo+2];
		if (sosedi[i] == NULL) {
			// недостаточно памяти на данном оборудовании.
#if doubleintprecision == 1
			printf("Problem : not enough memory on your equipment for sosedi[%lld] constr struct_alice...\n", i);
#else
			printf("Problem : not enough memory on your equipment for sosedi[%d] constr struct_alice...\n", i);
#endif
			
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
	}

	// Выделение оперативной памяти:
	prop_b = NULL;
	prop_b = new doublereal*[6];
	if (prop_b == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for prop_b constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	
	for (integer i = 0; i<6; i++) prop_b[i] = NULL;
	for (integer i = 0; i<6; i++) {
		prop_b[i] = new doublereal[maxbound_out];
		if (prop_b[i] == NULL) {
			// недостаточно памяти на данном оборудовании.
#if doubleintprecision == 1
			printf("Problem : not enough memory on your equipment for prop_b[%lld] constr struct_alice...\n", i);
#else
			printf("Problem : not enough memory on your equipment for prop_b[%d] constr struct_alice...\n", i);
#endif
			
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
	}

	// Алгоритм:
	// Выделение оперативной памяти:
	// gran[0..5][0..maxbound-1]
	sosedb = NULL;
	sosedb = new BOUND[maxbound_out];
	if (sosedb == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for sosedb constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	binternalsource = NULL;
	binternalsource = new bool[maxbound_out];
	if (binternalsource == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for binternalsource constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	for (integer i = 0; i<maxbound_out; i++) binternalsource[i] = false; // инициализация.

	integer maxbound = 0; // инициализация.
	integer maxelm = 0;
	bool *bvisit = NULL;
	bvisit = new bool[maxelm_memo+2];
	if (bvisit == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for bvisit constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	for (integer j = 0; j<maxelm_memo+2; j++) bvisit[j] = false; // признак посещения узла.
	doublereal x_c, y_c, z_c;
	integer iplane;

	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {
				
				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				TOCHKA p;
				p.x = 0.125*(octree1->p0.x + octree1->p1.x + octree1->p2.x + octree1->p3.x + octree1->p4.x + octree1->p5.x + octree1->p6.x + octree1->p7.x);
				p.y = 0.125*(octree1->p0.y + octree1->p1.y + octree1->p2.y + octree1->p3.y + octree1->p4.y + octree1->p5.y + octree1->p6.y + octree1->p7.y);
				p.z = 0.125*(octree1->p0.z + octree1->p1.z + octree1->p2.z + octree1->p3.z + octree1->p4.z + octree1->p5.z + octree1->p6.z + octree1->p7.z);
				integer ib;
				bool inDomain = false;
				inDomain = in_model_temp(p, ib, b, lb); // TEMPERATURE

				if (inDomain) {
					// Узел принадлекжит расчётной области и его номер maxelm==octree1->inum_TD.

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4E) {
						if (octree1->linkE == NULL) {
							G = ESIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkW == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}
							maxbound++;
						}
						else {
							if (octree1->linkE->inum_TD == 0) {
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = false;
								sosedi[G][maxelm].iNODE2 = -1;
								sosedi[G][maxelm].iNODE3 = -1;
								sosedi[G][maxelm].iNODE4 = -1;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = false;
								sosedi[GG][maxelm].iNODE2 = -1;
								sosedi[GG][maxelm].iNODE3 = -1;
								sosedi[GG][maxelm].iNODE4 = -1;

								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


								// вычисление размеров текущего контрольного объёма:
								doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контроольного объёма
								volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
								doublereal dSloc = dy_loc*dz_loc;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4W) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									if (octree1->linkW == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
								}
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkE->inum_TD - 1]) {
									

									integer inode_now = sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE1;
									if (octree1->linkE->b4W) {
										integer etalon_id = octree1->inum_TD - 1;
										bool bcontinue = true;
										if (bcontinue) {
											if (octree1->linkE->linkW0 != NULL) {
												if (octree1->linkE->linkW0->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE1
													if (sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE1 == etalon_id) {
														inode_now = sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE1;
													}
													else {
														printf("takogo bjtx ne moshet E W0\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkE->linkW3!=NULL) {
												if (octree1->linkE->linkW3->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE2
													if (sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE2 == etalon_id) {
														inode_now = sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE2;
													}
													else {
														printf("takogo bjtx ne moshet E W3\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkE->linkW4!=NULL) {
												if (octree1->linkE->linkW4->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE3
													if (sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE3 == etalon_id) {
														inode_now = sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE3;
													}
													else {
														printf("takogo bjtx ne moshet E W4\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkE->linkW7!=NULL) {
												if (octree1->linkE->linkW7->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE4
													if (sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE4 == etalon_id) {
														inode_now = sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE4;
													}
													else {
														printf("takogo bjtx ne moshet E W7\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}

									}


									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
									if (inode_now >= maxelm_memo) {
										// Это граничная грань внутреннего источника тепла.
										G = ESIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][sosedi[G][maxelm].iNODE1-maxelm_memo] = prop[RHO][octree1->linkE->inum_TD - 1];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][octree1->linkE->inum_TD - 1];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][octree1->linkE->inum_TD - 1];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][octree1->linkE->inum_TD - 1];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][octree1->linkE->inum_TD - 1];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][octree1->linkE->inum_TD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][maxelm];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][maxelm];
										}

										binternalsource[sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE1 - maxelm_memo] = true; // внутренний источник тепла на границе жидкости и твёрдого тела

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dy_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4W) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE1 - maxelm_memo,
												octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
										}
										else {
											if (octree1->linkW == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE1 - maxelm_memo,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[WSIDE][octree1->linkE->inum_TD - 1].iNODE1 - maxelm_memo,
													octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
										}

									}
									else {
										// Это строго внутренний узел.
										// Внутренний узел.
										G = ESIDE;
										// внутренняя грань (нумерация начинается с нуля):
										sosedi[G][maxelm].iNODE1 = octree1->linkE->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}
										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}

								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = octree1->p1.x;
									y_c = 0.5*(octree1->p1.y + octree1->p2.y);
									z_c = 0.5*(octree1->p1.z + octree1->p5.z);
									iplane = YZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound,binc,lsid);
									if (binc) {
										// Внутренний источник тепла.
										G = ESIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound-1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][maxbound - 1] = prop[RHO][octree1->linkE->inum_TD - 1];
											prop_b[CP][maxbound - 1] = prop[CP][octree1->linkE->inum_TD - 1];
											prop_b[LAM][maxbound - 1] = prop[LAM][octree1->linkE->inum_TD - 1];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][octree1->linkE->inum_TD - 1];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][octree1->linkE->inum_TD - 1];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][octree1->linkE->inum_TD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][maxbound - 1] = prop[RHO][maxelm];
											prop_b[CP][maxbound - 1] = prop[CP][maxelm];
											prop_b[LAM][maxbound - 1] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][maxelm];
										}

										binternalsource[maxbound - 1] = true; // внутренний источник тепла на границе жидкости и твёрдого тела

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dy_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4W) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound-1,
												octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
										}
										else {
											if (octree1->linkW == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound-1,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound-1,
													octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
										}

									}
									else {
										// Внутренний узел.
										G = ESIDE;
										// внутренняя грань (нумерация начинается с нуля):
										sosedi[G][maxelm].iNODE1 = octree1->linkE->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										// Определение дальнего соседа :
										// TODO 13 сентября 2016.

									}

								}
							}
						}
					}
					else {

						if ((octree1->linkE1 == NULL) && (octree1->linkE2 == NULL) && (octree1->linkE5 == NULL) && (octree1->linkE6 == NULL)) {
							G = ESIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkW == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {

									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 != NULL) && (octree1->linkE5 != NULL) && (octree1->linkE6 != NULL) &&
							(octree1->linkE1->inum_TD == 0) && (octree1->linkE2->inum_TD == 0) && (octree1->linkE5->inum_TD == 0) && (octree1->linkE6->inum_TD == 0)) {
							G = ESIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkW == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 == NULL) && (octree1->linkE5 != NULL) && (octree1->linkE6 == NULL) &&
							(octree1->linkE1->inum_TD == 0) && (octree1->linkE5->inum_TD == 0)) {
							G = ESIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkW == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 != NULL) && (octree1->linkE5 == NULL) && (octree1->linkE6 == NULL) &&
							(octree1->linkE1->inum_TD == 0) && (octree1->linkE2->inum_TD == 0)) {
							G = ESIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkW == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 == NULL) && (octree1->linkE5 == NULL) && (octree1->linkE6 == NULL) &&
							(octree1->linkE1->inum_TD == 0)) {
							G = ESIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkW == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkE1 == NULL) {
#if doubleintprecision == 1
								printf("error NULL sosedi E1 elm=%lld\n", maxelm);
#else
								printf("error NULL sosedi E1 elm=%d\n", maxelm);
#endif
								
								//getchar();
								system("PAUSE");
								/*
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;
								#if doubleintprecision == 1
									printf("error NULL sosedi E1 elm=%lld\n", maxelm);
								#else
									printf("error NULL sosedi E1 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь нужно предусмотреть обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4W) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkW == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkE1->inum_TD == 0) {
									G = ESIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;

									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi E1 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi E1 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь нужно предусмотреть обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkE1->p4.z - octree1->linkE1->p0.z)*fabs(octree1->linkE1->p3.y - octree1->linkE1->p0.y);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4W) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkW == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE1->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Здесь не может быть внутреннего источника тепла иначе 
										// выдавалось бы предупреждение 
#if doubleintprecision == 1
										//printf("error internal source E1 elm=%lld\n", maxelm);
#else
										//printf("error internal source E1 elm=%d\n", maxelm);
#endif
										
										//getchar();
										// В узле octree1->linkE1->inum_TD - 1 Который был посещен ранее.
										// Здесь возможен только внутренний узел.
										// Внутренний узел.
										G = ESIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkE1->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;

										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.

									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE1->p0.y + octree1->linkE1->p3.y);
										z_c = 0.5*(octree1->linkE1->p0.z + octree1->linkE1->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										if (binc1) {
#if doubleintprecision == 1
											printf("error internal source E1 elm=%lld\n", maxelm);
#else
											printf("error internal source E1 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Внутренний узел.
											G = ESIDE;
											// Внутренняя грань:
											sosedi[G][maxelm].iNODE1 = octree1->linkE1->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;

											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											  case ESIDE: GG = EE; break; // E
											  case NSIDE: GG = NN; break; // NSIDE
											  case TSIDE: GG = TTSIDE; break; // T
											  case WSIDE: GG = WW; break; // W
											  case SSIDE: GG = SS; break; // S
											  case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.

										}
									}
								}
							}

							if (octree1->linkE2 == NULL) {
								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE2 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;


								/*
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE2 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
									printf("error NULL sosedi E2 elm=%lld\n", maxelm);
								#else
									printf("error NULL sosedi E2 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь нужно предусмотреть обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4W) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkW == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}



								maxbound++;
								*/
							}
							else {
								if (octree1->linkE2->inum_TD == 0) {
									G = ESIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;

									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE2 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi E2 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi E2 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь нужно предусмотреть обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkE2->p4.z - octree1->linkE2->p0.z)*fabs(octree1->linkE2->p3.y - octree1->linkE2->p0.y);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4W) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkW == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE2->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Здесь тоже возможен лишь строго внутренний узел.
										// Внутренний узел.
										G = ESIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE2 = octree1->linkE2->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;

										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.

									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE2->p0.y + octree1->linkE2->p3.y);
										z_c = 0.5*(octree1->linkE2->p0.z + octree1->linkE2->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										if (binc2) {
#if doubleintprecision == 1
											printf("error internal source E2 elm=%lld\n", maxelm);
#else
											printf("error internal source E2 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Внутренний узел.
											G = ESIDE;
											// Внутренняя грань:
											sosedi[G][maxelm].iNODE2 = octree1->linkE2->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;

											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.

										}
									}
								}
							}

							if (octree1->linkE5 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE3 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE3 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;
								#if doubleintprecision == 1
									printf("error NULL sosedi E5 elm=%lld\n", maxelm);
								#else
									printf("error NULL sosedi E5 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь нужно предусмотреть обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4W) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkW == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkE5->inum_TD == 0) {
									G = ESIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;

									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE3 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;
#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi E5 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi E5 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь нужно предусмотреть обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkE5->p4.z - octree1->linkE5->p0.z)*fabs(octree1->linkE5->p3.y - octree1->linkE5->p0.y);


									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4W) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkW == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE5->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Здесь тоже возможен лишь строго внутренний узел.
										// Внутренний узел.
										G = ESIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE3 = octree1->linkE5->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;

										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE5->p0.y + octree1->linkE5->p3.y);
										z_c = 0.5*(octree1->linkE5->p0.z + octree1->linkE5->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
										if (binc3) {
#if doubleintprecision == 1
											printf("error internal source E5 elm=%lld\n", maxelm);
#else
											printf("error internal source E5 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Внутренний узел.
											G = ESIDE;
											// Внутренняя грань:
											sosedi[G][maxelm].iNODE3 = octree1->linkE5->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;

											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											  case ESIDE: GG = EE; break; // E
											  case NSIDE: GG = NN; break; // NSIDE
											  case TSIDE: GG = TTSIDE; break; // T
											  case WSIDE: GG = WW; break; // W
											  case SSIDE: GG = SS; break; // S
											  case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkE6 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE4 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;


								/*
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								  case ESIDE: GG = EE; break; // E
								  case NSIDE: GG = NN; break; // NSIDE
								  case TSIDE: GG = TTSIDE; break; // T
								  case WSIDE: GG = WW; break; // W
								  case SSIDE: GG = SS; break; // S
								  case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE4 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;
								#if doubleintprecision == 1
										printf("error NULL sosedi E6 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi E6 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь нужно предусмотреть обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4W) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkW == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}


								maxbound++;
								*/
							}
							else {
								if (octree1->linkE6->inum_TD == 0) {
									G = ESIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;

									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									  case ESIDE: GG = EE; break; // E
									  case NSIDE: GG = NN; break; // NSIDE
									  case TSIDE: GG = TTSIDE; break; // T
									  case WSIDE: GG = WW; break; // W
									  case SSIDE: GG = SS; break; // S
								      case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE4 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;
#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi E6 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi E6 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь нужно предусмотреть обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkE6->p4.z - octree1->linkE6->p0.z)*fabs(octree1->linkE6->p3.y - octree1->linkE6->p0.y);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4W) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkW == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkW->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE6->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Здесь тоже возможен лишь строго внутренний узел.
										// Внутренний узел.
										G = ESIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE4 = octree1->linkE6->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;

										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE6->p0.y + octree1->linkE6->p3.y);
										z_c = 0.5*(octree1->linkE6->p0.z + octree1->linkE6->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
										if (binc4) {
#if doubleintprecision == 1
											printf("error internal source E6 elm=%lld\n", maxelm);
#else
											printf("error internal source E6 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Внутренний узел.
											G = ESIDE;
											// Внутренняя грань:
											sosedi[G][maxelm].iNODE4 = octree1->linkE6->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;

											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											  case ESIDE: GG = EE; break; // E
											  case NSIDE: GG = NN; break; // NSIDE
											  case TSIDE: GG = TTSIDE; break; // T
											  case WSIDE: GG = WW; break; // W
											  case SSIDE: GG = SS; break; // S
											  case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4W) {
						if (octree1->linkW == NULL) {
							G = WSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkE == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							maxbound++;
						}
						else {
							if (octree1->linkW->inum_TD == 0) {
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = false;
								sosedi[G][maxelm].iNODE2 = -1;
								sosedi[G][maxelm].iNODE3 = -1;
								sosedi[G][maxelm].iNODE4 = -1;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = false;
								sosedi[GG][maxelm].iNODE2 = -1;
								sosedi[GG][maxelm].iNODE3 = -1;
								sosedi[GG][maxelm].iNODE4 = -1;

								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								// вычисление размеров текущего контрольного объёма:
								doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
								volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
								doublereal dSloc = dy_loc*dz_loc;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4E) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									if (octree1->linkE == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
								}

								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkW->inum_TD - 1]) {

									
									integer inode_now = sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE1;
									if (octree1->linkW->b4E) {
										integer etalon_id = octree1->inum_TD - 1;
										bool bcontinue = true;
										if (bcontinue) {
											if (octree1->linkW->linkE1 != NULL) {
												if (octree1->linkW->linkE1->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE1
													if (sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE1 == etalon_id) {
														inode_now = sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE1;
													}
													else {
														printf("takogo bjtx ne moshet W E1\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkW->linkE2 != NULL) {
												if (octree1->linkW->linkE2->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE2
													if (sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE2 == etalon_id) {
														inode_now = sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE2;
													}
													else {
														printf("takogo bjtx ne moshet W E2\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkW->linkE5 != NULL) {
												if (octree1->linkW->linkE5->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE3
													if (sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE3 == etalon_id) {
														inode_now = sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE3;
													}
													else {
														printf("takogo bjtx ne moshet W E5\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkW->linkE6 != NULL) {
												if (octree1->linkW->linkE6->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE4
													if (sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE4 == etalon_id) {
														inode_now = sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE4;
													}
													else {
														printf("takogo bjtx ne moshet W E6\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}

									}

									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
									if (inode_now >= maxelm_memo) {
										// Это граничная грань внутреннего источника тепла.
										// Внутренний источник тепла.
										G = WSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][octree1->linkW->inum_TD - 1];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][octree1->linkW->inum_TD - 1];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][octree1->linkW->inum_TD - 1];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][octree1->linkW->inum_TD - 1];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][octree1->linkW->inum_TD - 1];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][octree1->linkW->inum_TD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][maxelm];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dy_loc*dz_loc;


										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4E) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE1 - maxelm_memo,
												octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
										}
										else {
											if (octree1->linkE == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE1 - maxelm_memo,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc,true, true);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE1 - maxelm_memo,
													octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc,true, true);
											}
										}
										binternalsource[sosedi[ESIDE][octree1->linkW->inum_TD - 1].iNODE1 - maxelm_memo] = true; // внутренний источник тепла на границе жидкости и твёрдого тела

									}
									else {
										// Это строго внутренний узел.
										G = WSIDE;
										// внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkW->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}

								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = octree1->p0.x;
									y_c = 0.5*(octree1->p0.y + octree1->p3.y);
									z_c = 0.5*(octree1->p0.z + octree1->p4.z);
									iplane = YZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound,binc, lsid);
									if (binc) {
										// Внутренний источник тепла.
										G = WSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound-1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][maxbound - 1] = prop[RHO][octree1->linkW->inum_TD - 1];
											prop_b[CP][maxbound - 1] = prop[CP][octree1->linkW->inum_TD - 1];
											prop_b[LAM][maxbound - 1] = prop[LAM][octree1->linkW->inum_TD - 1];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][octree1->linkW->inum_TD - 1];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][octree1->linkW->inum_TD - 1];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][octree1->linkW->inum_TD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][maxbound - 1] = prop[RHO][maxelm];
											prop_b[CP][maxbound - 1] = prop[CP][maxelm];
											prop_b[LAM][maxbound - 1] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dy_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4E) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound-1,
												octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
										}
										else {
											if (octree1->linkE == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound-1,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound-1,
													octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
										}

										binternalsource[maxbound - 1] = true; // внутренний источник тепла на границе жидкости и твёрдого тела

									}
									else {
										// Внутренний узел.
										G = WSIDE;
										// внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkW->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}
										// Определение дальнего соседа :
										// TODO 13 сентября 2016.

									}
								}
							}
						}
					}
					else {

						if ((octree1->linkW0 == NULL) && (octree1->linkW3 == NULL) && (octree1->linkW4 == NULL) && (octree1->linkW7 == NULL)) {
							G = WSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkE == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 != NULL) && (octree1->linkW4 != NULL) && (octree1->linkW7 != NULL) &&
							(octree1->linkW0->inum_TD == 0) && (octree1->linkW3->inum_TD == 0) && (octree1->linkW4->inum_TD == 0) && (octree1->linkW7->inum_TD == 0)) {
							G = WSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkE == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 == NULL) && (octree1->linkW4 != NULL) && (octree1->linkW7 == NULL) &&
							(octree1->linkW0->inum_TD == 0) && (octree1->linkW4->inum_TD == 0)) {
							G = WSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkE == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 != NULL) && (octree1->linkW4 == NULL) && (octree1->linkW7 == NULL) &&
							(octree1->linkW0->inum_TD == 0) && (octree1->linkW3->inum_TD == 0)) {
							G = WSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkE == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 == NULL) && (octree1->linkW4 == NULL) && (octree1->linkW7 == NULL) &&
							(octree1->linkW0->inum_TD == 0) ) {
							G = WSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkE == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkW0 == NULL) {

#if doubleintprecision == 1
								printf("error NULL sosedi W0 elm=%lld\n", maxelm);
#else
								printf("error NULL sosedi W0 elm=%d\n", maxelm);
#endif
								
								//getchar();
								system("PAUSE");

								/*
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;
								#if doubleintprecision == 1
									printf("error NULL sosedi W0 elm=%lld\n", maxelm);
								#else
									printf("error NULL sosedi W0 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4E) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkE == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkW0->inum_TD == 0) {
									G = WSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;
#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi W0 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi W0 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkW0->p5.z - octree1->linkW0->p1.z)*fabs(octree1->linkW0->p2.y - octree1->linkW0->p1.y);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4E) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkE == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW0->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = WSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkW0->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.

									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW0->p1.y + octree1->linkW0->p2.y);
										z_c = 0.5*(octree1->linkW0->p1.z + octree1->linkW0->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										if (binc1) {
#if doubleintprecision == 1
											printf("error internal source W0 elm=%lld\n", maxelm);
#else
											printf("error internal source W0 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = WSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE1 = octree1->linkW0->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkW3 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE2 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE2 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
									printf("error NULL sosedi W3 elm=%lld\n", maxelm);
								#else
									printf("error NULL sosedi W3 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4E) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkE == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/

							}
							else {
								if (octree1->linkW3->inum_TD == 0) {
									G = WSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE2 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;
#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi W3 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi W3 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkW3->p5.z - octree1->linkW3->p1.z)*fabs(octree1->linkW3->p2.y - octree1->linkW3->p1.y);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4E) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkE == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}


									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW3->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = WSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE2 = octree1->linkW3->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW3->p1.y + octree1->linkW3->p2.y);
										z_c = 0.5*(octree1->linkW3->p1.z + octree1->linkW3->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										if (binc2) {
#if doubleintprecision == 1
											printf("error internal source W3 elm=%lld\n", maxelm);
#else
											printf("error internal source W3 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = WSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE2 = octree1->linkW3->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkW4 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE3 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE3 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi W4 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi W4 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4E) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkE == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/

							}
							else {
								if (octree1->linkW4->inum_TD == 0) {
									G = WSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE3 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi W4 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi W4 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkW4->p5.z - octree1->linkW4->p1.z)*fabs(octree1->linkW4->p2.y - octree1->linkW4->p1.y);


									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4E) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkE == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW4->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = WSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE3 = octree1->linkW4->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW4->p1.y + octree1->linkW4->p2.y);
										z_c = 0.5*(octree1->linkW4->p1.z + octree1->linkW4->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
										if (binc3) {
#if doubleintprecision == 1
											printf("error internal source W4 elm=%lld\n", maxelm);
#else
											printf("error internal source W4 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = WSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE3 = octree1->linkW4->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkW7 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE4 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE4 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi W7 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi W7 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4E) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkE == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/

							}
							else {
								if (octree1->linkW7->inum_TD == 0) {
									G = WSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE4 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi W7 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi W7 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkW7->p5.z - octree1->linkW7->p1.z)*fabs(octree1->linkW7->p2.y - octree1->linkW7->p1.y);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4E) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE1->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkE == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkE->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW7->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = WSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE4 = octree1->linkW7->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW7->p1.y + octree1->linkW7->p2.y);
										z_c = 0.5*(octree1->linkW7->p1.z + octree1->linkW7->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
										if (binc4) {
#if doubleintprecision == 1
											printf("error internal source W7 elm=%lld\n", maxelm);
#else
											printf("error internal source W7 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = WSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE4 = octree1->linkW7->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											  case ESIDE: GG = EE; break; // E
											  case NSIDE: GG = NN; break; // NSIDE
											  case TSIDE: GG = TTSIDE; break; // T
											  case WSIDE: GG = WW; break; // W
										      case SSIDE: GG = SS; break; // S
											  case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}
						}
					}


					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4N) {
						if (octree1->linkN == NULL) {
							G = NSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkS == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							maxbound++;
						}
						else {
							if (octree1->linkN->inum_TD == 0) {
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = false;
								sosedi[G][maxelm].iNODE2 = -1;
								sosedi[G][maxelm].iNODE3 = -1;
								sosedi[G][maxelm].iNODE4 = -1;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = false;
								sosedi[GG][maxelm].iNODE2 = -1;
								sosedi[GG][maxelm].iNODE3 = -1;
								sosedi[GG][maxelm].iNODE4 = -1;

								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								// вычисление размеров текущего контрольного объёма:
								doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
								volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
								doublereal dSloc = dx_loc*dz_loc;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4S) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									if (octree1->linkS == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
								}

								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkN->inum_TD - 1]) {

									integer inode_now = sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE1;
									//S0 NODE1,
									//S1 NODE2,
									//S4 NODE3,
									//S5 NODE4.
									// TODO 23 сентября 2016.
									if (octree1->linkN->b4S) {
										integer etalon_id = octree1->inum_TD - 1;
										bool bcontinue = true;
										if (bcontinue) {
											if (octree1->linkN->linkS0 != NULL) {
												if (octree1->linkN->linkS0->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE1
													if (sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE1 == etalon_id) {
														inode_now = sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE1;
													}
													else {
														printf("takogo bjtx ne moshet N S0\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkN->linkS1 != NULL) {
												if (octree1->linkN->linkS1->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE2
													if (sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE2 == etalon_id) {
														inode_now = sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE2;
													}
													else {
														printf("takogo bjtx ne moshet N S1\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkN->linkS4 != NULL) {
												if (octree1->linkN->linkS4->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE3
													if (sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE3 == etalon_id) {
														inode_now = sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE3;
													}
													else {
														printf("takogo bjtx ne moshet N S4\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkN->linkS5 != NULL) {
												if (octree1->linkN->linkS5->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE4
													if (sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE4 == etalon_id) {
														inode_now = sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE4;
													}
													else {
														printf("takogo bjtx ne moshet N S5\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}

									}

									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
									if (inode_now >= maxelm_memo) {
										// Это граничная грань внутреннего источника тепла.
										// Внутренний источник тепла.
										G = NSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][sosedi[G][maxelm].iNODE1-maxelm_memo] = prop[RHO][octree1->linkN->inum_TD - 1];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][octree1->linkN->inum_TD - 1];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][octree1->linkN->inum_TD - 1];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][octree1->linkN->inum_TD - 1];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][octree1->linkN->inum_TD - 1];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][octree1->linkN->inum_TD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][maxelm];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4S) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE1 - maxelm_memo,
												octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
										}
										else {
											if (octree1->linkS == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE1 - maxelm_memo,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE1 - maxelm_memo,
													octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
										}
										binternalsource[sosedi[SSIDE][octree1->linkN->inum_TD - 1].iNODE1 - maxelm_memo] = true; // внутренний источник тепла на границе жидкости и твёрдого тела

									}
									else {
										// Это строго внутренний узел.
										// Внутренний узел.
										G = NSIDE;
										// внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkN->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа.
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}

								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p2.x + octree1->p3.x);
									y_c = octree1->p3.y;
									z_c = 0.5*(octree1->p3.z + octree1->p7.z);
									iplane = XZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound,binc,lsid);
									if (binc) {
										// Внутренний источник тепла.
										G = NSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound-1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][maxbound - 1] = prop[RHO][octree1->linkN->inum_TD - 1];
											prop_b[CP][maxbound - 1] = prop[CP][octree1->linkN->inum_TD - 1];
											prop_b[LAM][maxbound - 1] = prop[LAM][octree1->linkN->inum_TD - 1];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][octree1->linkN->inum_TD - 1];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][octree1->linkN->inum_TD - 1];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][octree1->linkN->inum_TD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][maxbound - 1] = prop[RHO][maxelm];
											prop_b[CP][maxbound - 1] = prop[CP][maxelm];
											prop_b[LAM][maxbound - 1] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4S) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
												octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
										}
										else {
											if (octree1->linkS == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
										}
										binternalsource[maxbound - 1] = true; // внутренний источник тепла на границе жидкости и твёрдого тела

									}
									else {
										// Внутренний узел.
										G = NSIDE;
										// внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkN->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа.
										switch (G) {
										 case ESIDE: GG = EE; break; // E
										 case NSIDE: GG = NN; break; // NSIDE
										 case TSIDE: GG = TTSIDE; break; // T
										 case WSIDE: GG = WW; break; // W
										 case SSIDE: GG = SS; break; // S
										 case BSIDE: GG = BB; break; // B
										}
										// Определение дальнего соседа :
										// TODO 13 сентября 2016.

									}
									
								}
							}
						}
					}
					else {

						if ((octree1->linkN2 == NULL) && (octree1->linkN3 == NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 == NULL)) {
							G = NSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;


							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkS == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkN2 != NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 != NULL) && (octree1->linkN7 != NULL) &&
							(octree1->linkN2->inum_TD == 0) && (octree1->linkN3->inum_TD == 0) && (octree1->linkN6->inum_TD == 0) && (octree1->linkN7->inum_TD == 0)) {
							G = NSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkS == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkN2 == NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 != NULL) &&
							(octree1->linkN3->inum_TD == 0) && (octree1->linkN7->inum_TD == 0)) {
							G = NSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkS == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkN2 != NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 == NULL) &&
							(octree1->linkN2->inum_TD == 0) && (octree1->linkN3->inum_TD == 0)) {
							G = NSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkS == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkN2 == NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 == NULL) &&
							 (octree1->linkN3->inum_TD == 0)) {
							G = NSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkS == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkN2 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).
								
								// Заглушка.
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE1 = -1; // нет соседа,
								sosedi[GG][maxelm].bdroblenie4 = true;


								/*
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								  case ESIDE: GG = EE; break; // E
								  case NSIDE: GG = NN; break; // NSIDE
								  case TSIDE: GG = TTSIDE; break; // T
								  case WSIDE: GG = WW; break; // W
								  case SSIDE: GG = SS; break; // S
								  case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE1 = -1; // нет соседа,
								sosedi[GG][maxelm].bdroblenie4 = true;
								#if doubleintprecision == 1
									printf("error NULL sosedi N2 elm=%lld\n", maxelm);
								#else
									printf("error NULL sosedi N2 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4S) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkS == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}


								maxbound++;
								*/
							}
							else {
								if (octree1->linkN2->inum_TD == 0) {

									G = NSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									  case ESIDE: GG = EE; break; // E
									  case NSIDE: GG = NN; break; // NSIDE
									  case TSIDE: GG = TTSIDE; break; // T
									  case WSIDE: GG = WW; break; // W
									  case SSIDE: GG = SS; break; // S
									  case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE1 = -1; // нет соседа,
									sosedi[GG][maxelm].bdroblenie4 = true;
#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi N2 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi N2 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkN2->p4.z - octree1->linkN2->p0.z)*fabs(octree1->linkN2->p1.x - octree1->linkN2->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4S) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkS == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN2->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = NSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkN2->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN2->p0.x + octree1->linkN2->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN2->p0.z + octree1->linkN2->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										if (binc1) {
#if doubleintprecision == 1
											printf("error internal source N2 elm=%lld\n", maxelm);
#else
											printf("error internal source N2 elm=%d\n", maxelm);
#endif
											
											///getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = NSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE1 = octree1->linkN2->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkN3 == NULL) {
#if doubleintprecision == 1
								printf("error NULL sosedi N3 elm=%lld\n", maxelm);
#else
								printf("error NULL sosedi N3 elm=%d\n", maxelm);
#endif
								
								//getchar();
								system("PAUSE");

								/*
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								  case ESIDE: GG = EE; break; // E
								  case NSIDE: GG = NN; break; // NSIDE
								  case TSIDE: GG = TTSIDE; break; // T
								  case WSIDE: GG = WW; break; // W
								  case SSIDE: GG = SS; break; // S
							      case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // нет соседей,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi N3 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi N3 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4S) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkS == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}


								maxbound++;
								*/

							}
							else {
								if (octree1->linkN3->inum_TD == 0) {

									G = NSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE2 = -1; // нет соседей,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi N3 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi N3 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkN3->p4.z - octree1->linkN3->p0.z)*fabs(octree1->linkN3->p1.x - octree1->linkN3->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4S) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkS == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}


									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN3->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = NSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE2 = octree1->linkN3->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN3->p0.x + octree1->linkN3->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN3->p0.z + octree1->linkN3->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										if (binc2) {
#if doubleintprecision == 1
											printf("error internal source N3 elm=%lld\n", maxelm);
#else
											printf("error internal source N3 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = NSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE2 = octree1->linkN3->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkN6 == NULL) {
								
								// 21 сентября 2016 (вырождение ячейки).
								
								// Заглушка.
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								  case ESIDE: GG = EE; break; // E
								  case NSIDE: GG = NN; break; // NSIDE
								  case TSIDE: GG = TTSIDE; break; // T
								  case WSIDE: GG = WW; break; // W
								  case SSIDE: GG = SS; break; // S
								  case BSIDE: GG = BB; break; // B
								}
								
								sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi N6 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi N6 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4S) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkS == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/

							}
							else {
								if (octree1->linkN6->inum_TD == 0) {

									G = NSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi N6 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi N6 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkN6->p4.z - octree1->linkN6->p0.z)*fabs(octree1->linkN6->p1.x - octree1->linkN6->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4S) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkS == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN6->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = NSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE3 = octree1->linkN6->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN6->p0.x + octree1->linkN6->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN6->p0.z + octree1->linkN6->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
										if (binc3) {
#if doubleintprecision == 1
											printf("error internal source N6 elm=%lld\n", maxelm);
#else
											printf("error internal source N6 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = NSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE3 = octree1->linkN6->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkN7 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[GG][maxelm].bdroblenie4 = true;


								/*
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = - 1; // граничные КО нумеруются в последнюю очередь,
								sosedi[GG][maxelm].bdroblenie4 = true;
								#if doubleintprecision == 1
										printf("error NULL sosedi N7 elm=%lld\n", maxelm);
#else
		printf("error NULL sosedi N7 elm=%d\n", maxelm);
#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4S) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkS == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}


								maxbound++;
								*/
							}
							else {
								if (octree1->linkN7->inum_TD == 0) {

									G = NSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi N7 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi N7 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkN7->p4.z - octree1->linkN7->p0.z)*fabs(octree1->linkN7->p1.x - octree1->linkN7->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4S) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkS == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkS->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN7->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = NSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE4 = octree1->linkN7->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN7->p0.x + octree1->linkN7->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN7->p0.z + octree1->linkN7->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
										if (binc4) {
#if doubleintprecision == 1
											printf("error internal source N7 elm=%lld\n", maxelm);
#else
											printf("error internal source N7 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = NSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE4 = octree1->linkN7->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											  case ESIDE: GG = EE; break; // E
											  case NSIDE: GG = NN; break; // NSIDE
											  case TSIDE: GG = TTSIDE; break; // T
											  case WSIDE: GG = WW; break; // W
											  case SSIDE: GG = SS; break; // S
											  case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4S) {
						if (octree1->linkS == NULL) {
							G = SSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							
							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkN == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							maxbound++;
						}
						else {
							if (octree1->linkS->inum_TD == 0) {
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = false;
								sosedi[G][maxelm].iNODE2 = -1;
								sosedi[G][maxelm].iNODE3 = -1;
								sosedi[G][maxelm].iNODE4 = -1;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								  case ESIDE: GG = EE; break; // E
								  case NSIDE: GG = NN; break; // NSIDE
								  case TSIDE: GG = TTSIDE; break; // T
								  case WSIDE: GG = WW; break; // W
								  case SSIDE: GG = SS; break; // S
								  case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = false;
								sosedi[GG][maxelm].iNODE2 = -1;
								sosedi[GG][maxelm].iNODE3 = -1;
								sosedi[GG][maxelm].iNODE4 = -1;

								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								// вычисление размеров текущего контрольного объёма:
								doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
								volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
								doublereal dSloc = dx_loc*dz_loc;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4N) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									if (octree1->linkN == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
								}

								maxbound++;
							}
							else {
								//bool binc;
								//integer lsid;
								// сосед существует.
								if (bvisit[octree1->linkS->inum_TD - 1]) {

									integer inode_now = sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE1;
									//N2 NODE1,
									//N3 NODE2,
									//N6 NODE3,
									//N7 NODE4.
									// TODO 23 сентября 2016.
									if (octree1->linkS->b4N) {
										integer etalon_id = octree1->inum_TD - 1;
										bool bcontinue = true;
										if (bcontinue) {
											if (octree1->linkS->linkN2!=NULL) {
												if (octree1->linkS->linkN2->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE1
													if (sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE1 == etalon_id) {
														inode_now = sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE1;
													}
													else {
														printf("takogo bjtx ne moshet S N2\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkS->linkN3!=NULL) {
												if (octree1->linkS->linkN3->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE2
													if (sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE2 == etalon_id) {
														inode_now = sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE2;
													}
													else {
														printf("takogo bjtx ne moshet S N3\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkS->linkN6!=NULL) {
												if (octree1->linkS->linkN6->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE3
													if (sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE3 == etalon_id) {
														inode_now = sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE3;
													}
													else {
														printf("takogo bjtx ne moshet S N6\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkS->linkN7 != NULL) {
												if (octree1->linkS->linkN7->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE4
													if (sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE4 == etalon_id) {
														inode_now = sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE4;
													}
													else {
														printf("takogo bjtx ne moshet S N7\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}

									}


									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
									if (inode_now >= maxelm_memo) {
										// Это граничная грань внутреннего источника тепла.
										// Внутренний источник тепла.
										G = SSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][sosedi[G][maxelm].iNODE1-maxelm_memo] = prop[RHO][octree1->linkS->inum_TD - 1];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][octree1->linkS->inum_TD - 1];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][octree1->linkS->inum_TD - 1];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][octree1->linkS->inum_TD - 1];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][octree1->linkS->inum_TD - 1];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][octree1->linkS->inum_TD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][maxelm];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4N) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE1 - maxelm_memo,
												octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
										}
										else {
											if (octree1->linkN == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE1 - maxelm_memo,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE1 - maxelm_memo,
													octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
										}
										binternalsource[sosedi[NSIDE][octree1->linkS->inum_TD - 1].iNODE1 - maxelm_memo] = true; // внутренний источник тепла на границе жидкости и твёрдого тела

									}
									else {
										// Это строго внутренний узел.
										// Внутренний узел.
										G = SSIDE;
										// внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkS->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}

								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p0.x + octree1->p1.x);
									y_c = octree1->p0.y;
									z_c = 0.5*(octree1->p0.z + octree1->p4.z);
									iplane = XZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound,binc,lsid);
									if (binc) {
										// Внутренний источник тепла.
										G = SSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound-1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][maxbound - 1] = prop[RHO][octree1->linkS->inum_TD - 1];
											prop_b[CP][maxbound - 1] = prop[CP][octree1->linkS->inum_TD - 1];
											prop_b[LAM][maxbound - 1] = prop[LAM][octree1->linkS->inum_TD - 1];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][octree1->linkS->inum_TD - 1];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][octree1->linkS->inum_TD - 1];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][octree1->linkS->inum_TD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][maxbound - 1] = prop[RHO][maxelm];
											prop_b[CP][maxbound - 1] = prop[CP][maxelm];
											prop_b[LAM][maxbound - 1] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4N) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound-1,
												octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
										}
										else {
											if (octree1->linkN == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound-1,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound-1,
													octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
										}
										binternalsource[maxbound - 1] = true; // внутренний источник тепла на границе жидкости и твёрдого тела

									}
									else {
										// Внутренний узел.
										G = SSIDE;
										// внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkS->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										 case ESIDE: GG = EE; break; // E
										 case NSIDE: GG = NN; break; // NSIDE
										 case TSIDE: GG = TTSIDE; break; // T
										 case WSIDE: GG = WW; break; // W
										 case SSIDE: GG = SS; break; // S
										 case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
								}
							}
						}
					}
					else {

						if ((octree1->linkS0 == NULL) && (octree1->linkS1 == NULL) && (octree1->linkS4 == NULL) && (octree1->linkS5 == NULL)) {
							G = SSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkN == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 != NULL) && (octree1->linkS4 != NULL) && (octree1->linkS5 != NULL) &&
							(octree1->linkS0->inum_TD == 0) && (octree1->linkS1->inum_TD == 0) && (octree1->linkS4->inum_TD == 0) && (octree1->linkS5->inum_TD == 0)) {
							G = SSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;


							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkN == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 == NULL) && (octree1->linkS4 != NULL) && (octree1->linkS5 == NULL) &&
							(octree1->linkS0->inum_TD == 0) && (octree1->linkS4->inum_TD == 0)) {
							G = SSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkN == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 != NULL) && (octree1->linkS4 == NULL) && (octree1->linkS5 == NULL) &&
							(octree1->linkS0->inum_TD == 0) && (octree1->linkS1->inum_TD == 0)) {
							G = SSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkN == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 == NULL) && (octree1->linkS4 == NULL) && (octree1->linkS5 == NULL) &&
							(octree1->linkS0->inum_TD == 0)) {
							G = SSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkN == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {


							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkS0 == NULL) {
#if doubleintprecision == 1
								printf("error NULL sosedi S0 elm=%lld\n", maxelm);
#else
								printf("error NULL sosedi S0 elm=%d\n", maxelm);
#endif
								
								//getchar();
								system("PAUSE");

								/*

								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет,
								sosedi[GG][maxelm].bdroblenie4 = true;
								#if doubleintprecision == 1
									printf("error NULL sosedi S0 elm=%lld\n", maxelm);
								#else
									printf("error NULL sosedi S0 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4N) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkN == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}


								maxbound++;
								*/
							}
							else {
								if (octree1->linkS0->inum_TD == 0) {
									
									G = SSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE1 = -1; // соседа нет,
									sosedi[GG][maxelm].bdroblenie4 = true;
									
#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi S0 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi S0 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkS0->p7.z - octree1->linkS0->p3.z)*fabs(octree1->linkS0->p2.x - octree1->linkS0->p3.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4N) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkN == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS0->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = SSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkS0->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS0->p3.x + octree1->linkS0->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS0->p3.z + octree1->linkS0->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										if (binc1) {
#if doubleintprecision == 1
											printf("error internal source S0 elm=%lld\n", maxelm);
#else
											printf("error internal source S0 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = SSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE1 = octree1->linkS0->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkS1 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;


								/*
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								  case ESIDE: GG = EE; break; // E
								  case NSIDE: GG = NN; break; // NSIDE
								  case TSIDE: GG = TTSIDE; break; // T
								  case WSIDE: GG = WW; break; // W
								  case SSIDE: GG = SS; break; // S
								  case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;
								#if doubleintprecision == 1
									printf("error NULL sosedi S1 elm=%lld\n", maxelm);
								#else
									printf("error NULL sosedi S1 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4N) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkN == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkS1->inum_TD == 0) {
									
									G = SSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									  case ESIDE: GG = EE; break; // E
									  case NSIDE: GG = NN; break; // NSIDE
									  case TSIDE: GG = TTSIDE; break; // T
									  case WSIDE: GG = WW; break; // W
									  case SSIDE: GG = SS; break; // S
									  case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE2 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;
#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi S1 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi S1 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkS1->p7.z - octree1->linkS1->p3.z)*fabs(octree1->linkS1->p2.x - octree1->linkS1->p3.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4N) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkN == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}


									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS1->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = SSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE2 = octree1->linkS1->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS1->p3.x + octree1->linkS1->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS1->p3.z + octree1->linkS1->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										if (binc2) {
#if doubleintprecision == 1
											printf("error internal source S1 elm=%lld\n", maxelm);
#else
											printf("error internal source S1 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = SSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE2 = octree1->linkS1->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkS4 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;


								/*
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								  case ESIDE: GG = EE; break; // E
								  case NSIDE: GG = NN; break; // NSIDE
								  case TSIDE: GG = TTSIDE; break; // T
								  case WSIDE: GG = WW; break; // W
								  case SSIDE: GG = SS; break; // S
								  case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi S4 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi S4 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4N) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkN == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkS4->inum_TD == 0) {
									
									G = SSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;
									
#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi S4 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi S4 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkS4->p7.z - octree1->linkS4->p3.z)*fabs(octree1->linkS4->p2.x - octree1->linkS4->p3.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4N) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkN == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS4->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = SSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE3 = octree1->linkS4->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS4->p3.x + octree1->linkS4->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS4->p3.z + octree1->linkS4->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
										if (binc3) {
#if doubleintprecision == 1
											printf("error internal source S4 elm=%lld\n", maxelm);
#else
											printf("error internal source S4 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = SSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE3 = octree1->linkS4->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											 case ESIDE: GG = EE; break; // E
											 case NSIDE: GG = NN; break; // NSIDE
											 case TSIDE: GG = TTSIDE; break; // T
											 case WSIDE: GG = WW; break; // W
											 case SSIDE: GG = SS; break; // S
											 case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkS5 == NULL) {
								
								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								
								sosedi[GG][maxelm].iNODE4 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi S5 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi S5 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4N) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkN == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkS5->inum_TD == 0) {
									
									G = SSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE4 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi S5 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi S5 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkS5->p7.z - octree1->linkS5->p3.z)*fabs(octree1->linkS5->p2.x - octree1->linkS5->p3.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4N) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN3->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkN == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkN->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS5->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = SSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE4 = octree1->linkS5->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										 case ESIDE: GG = EE; break; // E
										 case NSIDE: GG = NN; break; // NSIDE
										 case TSIDE: GG = TTSIDE; break; // T
										 case WSIDE: GG = WW; break; // W
										 case SSIDE: GG = SS; break; // S
										 case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS5->p3.x + octree1->linkS5->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS5->p3.z + octree1->linkS5->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
										if (binc4) {
#if doubleintprecision == 1
											printf("error internal source S5 elm=%lld\n", maxelm);
#else
											printf("error internal source S5 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = SSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE4 = octree1->linkS5->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											 case ESIDE: GG = EE; break; // E
											 case NSIDE: GG = NN; break; // NSIDE
											 case TSIDE: GG = TTSIDE; break; // T
											 case WSIDE: GG = WW; break; // W
											 case SSIDE: GG = SS; break; // S
											 case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4T) {
						if (octree1->linkT == NULL) {
							G = TSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;


							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkB == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								
							}

							maxbound++;
						}
						else {
							if (octree1->linkT->inum_TD == 0) {
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = false;
								sosedi[G][maxelm].iNODE2 = -1;
								sosedi[G][maxelm].iNODE3 = -1;
								sosedi[G][maxelm].iNODE4 = -1;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = false;
								sosedi[GG][maxelm].iNODE2 = -1;
								sosedi[GG][maxelm].iNODE3 = -1;
								sosedi[GG][maxelm].iNODE4 = -1;

								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								// вычисление размеров текущего контрольного объёма:
								doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
								volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
								doublereal dSloc = dx_loc*dy_loc;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4B) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									if (octree1->linkB == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
								}

								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkT->inum_TD - 1]) {

									integer inode_now = sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE1;
									if (octree1->linkT->b4B) {
										integer etalon_id = octree1->inum_TD - 1;
										bool bcontinue = true;
										if (bcontinue) {
											if (octree1->linkT->linkB0 != NULL) {
												if (octree1->linkT->linkB0->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE1
													if (sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE1 == etalon_id) {
														inode_now = sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE1;
													}
													else {
														printf("takogo bjtx ne moshet T B0\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkT->linkB1 != NULL) {
												if (octree1->linkT->linkB1->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE2
													if (sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE2 == etalon_id) {
														inode_now = sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE2;
													}
													else {
														printf("takogo bjtx ne moshet T B1\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkT->linkB2 != NULL) {
												if (octree1->linkT->linkB2->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE3
													if (sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE3 == etalon_id) {
														inode_now = sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE3;
													}
													else {
														printf("takogo bjtx ne moshet T B2\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkT->linkB3 != NULL) {
												if (octree1->linkT->linkB3->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE4
													if (sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE4 == etalon_id) {
														inode_now = sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE4;
													}
													else {
														printf("takogo bjtx ne moshet T B3\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}

									}

									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
									if (inode_now >= maxelm_memo) {
										// Это граничная грань внутреннего источника тепла.
										// Внутренний источник тепла.
										G = TSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;


										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][octree1->linkT->inum_TD - 1];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][octree1->linkT->inum_TD - 1];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][octree1->linkT->inum_TD - 1];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][octree1->linkT->inum_TD - 1];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][octree1->linkT->inum_TD - 1];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][octree1->linkT->inum_TD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][maxelm];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dy_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4B) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE1 - maxelm_memo,
												octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
										}
										else {
											if (octree1->linkB == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE1 - maxelm_memo,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE1 - maxelm_memo,
													octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
										}
										binternalsource[sosedi[BSIDE][octree1->linkT->inum_TD - 1].iNODE1 - maxelm_memo] = true; // внутренний источник тепла на границе жидкости и твёрдого тела

									}
									else {
										// Это строго внутренний узел.
										// Внутренняя грань.
										G = TSIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkT->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}

								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p4.x + octree1->p5.x);
									y_c = 0.5*(octree1->p4.y + octree1->p7.y);
									z_c = octree1->p4.z;
									iplane = XY;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound,binc,lsid);
									if (binc) {
										// Внутренний источник тепла.
										G = TSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound-1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][maxbound - 1] = prop[RHO][octree1->linkT->inum_TD - 1];
											prop_b[CP][maxbound - 1] = prop[CP][octree1->linkT->inum_TD - 1];
											prop_b[LAM][maxbound - 1] = prop[LAM][octree1->linkT->inum_TD - 1];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][octree1->linkT->inum_TD - 1];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][octree1->linkT->inum_TD - 1];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][octree1->linkT->inum_TD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][maxbound - 1] = prop[RHO][maxelm];
											prop_b[CP][maxbound - 1] = prop[CP][maxelm];
											prop_b[LAM][maxbound - 1] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dy_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4B) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
												octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
										}
										else {
											if (octree1->linkB == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
										}
										binternalsource[maxbound - 1] = true; // внутренний источник тепла на границе жидкости и твёрдого тела
									}
									else {
										// Внутренняя грань.
										G = TSIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkT->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
								}
							}
						}
					}
					else {

						if ((octree1->linkT4 == NULL) && (octree1->linkT5 == NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 == NULL)) {
							G = TSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkB == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 != NULL) && (octree1->linkT6 != NULL) && (octree1->linkT7 != NULL) &&
							(octree1->linkT4->inum_TD == 0) && (octree1->linkT5->inum_TD == 0) && (octree1->linkT6->inum_TD == 0) && (octree1->linkT7->inum_TD == 0)) {
							G = TSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkB == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 == NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 != NULL) &&
							(octree1->linkT4->inum_TD == 0) && (octree1->linkT7->inum_TD == 0)) {
							G = TSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkB == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 != NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 == NULL) &&
							(octree1->linkT4->inum_TD == 0) && (octree1->linkT5->inum_TD == 0)) {
							G = TSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkB == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 == NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 == NULL) &&
							(octree1->linkT4->inum_TD == 0)) {
							G = TSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkB == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {


							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkT4 == NULL) {
#if doubleintprecision == 1
								printf("error NULL sosedi T4 elm=%lld\n", maxelm);
#else
								printf("error NULL sosedi T4 elm=%d\n", maxelm);
#endif
								
								//getchar();
								system("PAUSE");

								/*

								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE1 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi T4 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi T4 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4B) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkB == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}

								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkT4->inum_TD == 0) {

									G = TSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE1 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;
#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi T4 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi T4 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkT4->p3.y - octree1->linkT4->p0.y)*fabs(octree1->linkT4->p1.x - octree1->linkT4->p0.x);


									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4B) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkB == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}

									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT4->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = TSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkT4->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT4->p0.x + octree1->linkT4->p1.x);
										y_c = 0.5*(octree1->linkT4->p0.y + octree1->linkT4->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										if (binc1) {
#if doubleintprecision == 1
											printf("error internal source T4 elm=%lld\n", maxelm);
#else
											printf("error internal source T4 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = TSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE1 = octree1->linkT4->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkT5 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // соседа нет,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // соседа нет,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi T5 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi T5 elm=%d\n", maxelm);
								#endif
								
								getchar();
								
								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4B) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkB == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}

								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkT5->inum_TD == 0) {
									
									G = TSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE2 = -1; // соседа нет,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi T5 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi T5 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkT5->p3.y - octree1->linkT5->p0.y)*fabs(octree1->linkT5->p1.x - octree1->linkT5->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4B) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkB == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}

									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT5->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = TSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE2 = octree1->linkT5->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT5->p0.x + octree1->linkT5->p1.x);
										y_c = 0.5*(octree1->linkT5->p0.y + octree1->linkT5->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										if (binc2) {
#if doubleintprecision == 1
											printf("error internal source T5 elm=%lld\n", maxelm);
#else
											printf("error internal source T5 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = TSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE2 = octree1->linkT5->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											  case ESIDE: GG = EE; break; // E
											  case NSIDE: GG = NN; break; // NSIDE
											  case TSIDE: GG = TTSIDE; break; // T
											  case WSIDE: GG = WW; break; // W
											  case SSIDE: GG = SS; break; // S
											  case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkT6 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi T6 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi T6 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4B) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkB == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}

								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkT6->inum_TD == 0) {
									
									G = TSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi T6 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi T6 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkT6->p3.y - octree1->linkT6->p0.y)*fabs(octree1->linkT6->p1.x - octree1->linkT6->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4B) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkB == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}

									}


									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT6->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = TSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE3 = octree1->linkT6->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT6->p0.x + octree1->linkT6->p1.x);
										y_c = 0.5*(octree1->linkT6->p0.y + octree1->linkT6->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
										if (binc3) {
#if doubleintprecision == 1
											printf("error internal source T6 elm=%lld\n", maxelm);
#else
											printf("error internal source T6 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = TSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE3 = octree1->linkT6->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkT7 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // соседа нет,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // соседа нет,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi T7 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi T7 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4B) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkB == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}

								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkT7->inum_TD == 0) {
									
									G = TSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE4 = -1; // соседа нет,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi T7 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi T7 elm=%d\n", maxelm);
#endif
									
									//getchar();
									
									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkT7->p3.y - octree1->linkT7->p0.y)*fabs(octree1->linkT7->p1.x - octree1->linkT7->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4B) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB0->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkB == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkB->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}

									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT7->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = TSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE4 = octree1->linkT7->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT7->p0.x + octree1->linkT7->p1.x);
										y_c = 0.5*(octree1->linkT7->p0.y + octree1->linkT7->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
										if (binc4) {
#if doubleintprecision == 1
											printf("error internal source T7 elm=%lld\n", maxelm);
#else
											printf("error internal source T7 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = TSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE4 = octree1->linkT7->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4B) {
						if (octree1->linkB == NULL) {
							G = BSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkT == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							maxbound++;
						}
						else {
							if (octree1->linkB->inum_TD == 0) {
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = false;
								sosedi[G][maxelm].iNODE2 = -1;
								sosedi[G][maxelm].iNODE3 = -1;
								sosedi[G][maxelm].iNODE4 = -1;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = false;
								sosedi[GG][maxelm].iNODE2 = -1;
								sosedi[GG][maxelm].iNODE3 = -1;
								sosedi[GG][maxelm].iNODE4 = -1;

								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								// вычисление размеров текущего контрольного объёма:
								doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
								volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
								doublereal dSloc = dx_loc*dy_loc;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4T) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									if (octree1->linkT == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
								}

								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkB->inum_TD - 1]) {

									integer inode_now = sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE1;
									if (octree1->linkB->b4B) {
										integer etalon_id = octree1->inum_TD - 1;
										bool bcontinue = true;
										if (bcontinue) {
											if (octree1->linkB->linkT4 != NULL) {
												if (octree1->linkB->linkT4->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE1
													if (sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE1 == etalon_id) {
														inode_now = sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE1;
													}
													else {
														printf("takogo bjtx ne moshet B T4\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkB->linkT5 != NULL) {
												if (octree1->linkB->linkT5->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE2
													if (sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE2 == etalon_id) {
														inode_now = sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE2;
													}
													else {
														printf("takogo bjtx ne moshet B T5\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkB->linkT6 != NULL) {
												if (octree1->linkB->linkT6->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE3
													if (sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE3 == etalon_id) {
														inode_now = sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE3;
													}
													else {
														printf("takogo bjtx ne moshet B T6\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkB->linkT7 != NULL) {
												if (octree1->linkB->linkT7->inum_TD - 1 == etalon_id) {
													bcontinue = false; // iNODE4
													if (sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE4 == etalon_id) {
														inode_now = sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE4;
													}
													else {
														printf("takogo bjtx ne moshet B T7\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}

									}

									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
									if (inode_now >= maxelm_memo) {
										// Это граничная грань внутреннего источника тепла.
										// Внутренний источник тепла.
										G = BSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][sosedi[G][maxelm].iNODE1-maxelm_memo] = prop[RHO][octree1->linkB->inum_TD - 1];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][octree1->linkB->inum_TD - 1];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][octree1->linkB->inum_TD - 1];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][octree1->linkB->inum_TD - 1];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][octree1->linkB->inum_TD - 1];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][octree1->linkB->inum_TD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][maxelm];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dy_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4T) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE1 - maxelm_memo,
												octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
										}
										else {
											if (octree1->linkT == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE1 - maxelm_memo,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE1 - maxelm_memo,
													octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
										}
										binternalsource[sosedi[TSIDE][octree1->linkB->inum_TD - 1].iNODE1 - maxelm_memo] = true; // внутренний источник тепла на границе жидкости и твёрдого тела

									}
									else {
										// Это строго внутренний узел.
										// Внутренняя грань.
										G = BSIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkB->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}

								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p0.x + octree1->p1.x);
									y_c = 0.5*(octree1->p0.y + octree1->p3.y);
									z_c = octree1->p0.z;
									iplane = XY;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound,binc,lsid);
									if (binc) {
										// Внутренний источник тепла.
										G = BSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound-1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][maxbound - 1] = prop[RHO][octree1->linkB->inum_TD - 1];
											prop_b[CP][maxbound - 1] = prop[CP][octree1->linkB->inum_TD - 1];
											prop_b[LAM][maxbound - 1] = prop[LAM][octree1->linkB->inum_TD - 1];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][octree1->linkB->inum_TD - 1];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][octree1->linkB->inum_TD - 1];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][octree1->linkB->inum_TD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][maxbound - 1] = prop[RHO][maxelm];
											prop_b[CP][maxbound - 1] = prop[CP][maxelm];
											prop_b[LAM][maxbound - 1] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dy_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4T) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
												octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
										}
										else {
											if (octree1->linkT == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
										}
										binternalsource[maxbound - 1] = true; // внутренний источник тепла на границе жидкости и твёрдого тела

									}
									else {
										// Внутренняя грань.
										G = BSIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkB->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										  case ESIDE: GG = EE; break; // E
										  case NSIDE: GG = NN; break; // NSIDE
										  case TSIDE: GG = TTSIDE; break; // T
										  case WSIDE: GG = WW; break; // W
										  case SSIDE: GG = SS; break; // S
										  case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
								}
							}
						}
					}
					else {

						if ((octree1->linkB0 == NULL) && (octree1->linkB1 == NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 == NULL)) {
							G = BSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkT == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 != NULL) && (octree1->linkB2 != NULL) && (octree1->linkB3 != NULL) &&
							(octree1->linkB0->inum_TD == 0) && (octree1->linkB1->inum_TD == 0) && (octree1->linkB2->inum_TD == 0) && (octree1->linkB3->inum_TD == 0)) {
							G = BSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkT == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 == NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 != NULL) &&
							(octree1->linkB0->inum_TD == 0) && (octree1->linkB3->inum_TD == 0)) {
							G = BSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkT == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 != NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 == NULL) &&
							(octree1->linkB0->inum_TD == 0) && (octree1->linkB1->inum_TD == 0)) {
							G = BSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;


							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkT == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 == NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 == NULL) &&
							(octree1->linkB0->inum_TD == 0)) {
							G = BSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[CP][maxbound] = prop[CP][maxelm];
							prop_b[LAM][maxbound] = prop[LAM][maxelm];
							prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
							prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
							prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkT == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkB0 == NULL) {
#if doubleintprecision == 1
								printf("error NULL sosedi B0 elm=%lld\n", maxelm);
#else
								printf("error NULL sosedi B0 elm=%d\n", maxelm);
#endif
								
								//getchar();
								system("PAUSE");

								/*
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE1 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi B0 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi B0 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4T) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkT == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkB0->inum_TD == 0) {

									G = BSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE1 = -1; // граничные КО нумеруются в последнюю очередь,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi B0 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi B0 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkB0->p7.y - octree1->linkB0->p4.y)*fabs(octree1->linkB0->p6.x - octree1->linkB0->p7.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4T) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkT == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB0->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = BSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkB0->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB0->p4.x + octree1->linkB0->p5.x);
										y_c = 0.5*(octree1->linkB0->p4.y + octree1->linkB0->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										if (binc1) {
#if doubleintprecision == 1
											printf("error internal source B0 elm=%lld\n", maxelm);
#else
											printf("error internal source B0 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = BSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE1 = octree1->linkB0->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkB1 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi B1 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi B1 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4T) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkT == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkB1->inum_TD == 0) {
									
									G = BSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE2 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi B1 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi B1 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkB1->p7.y - octree1->linkB1->p4.y)*fabs(octree1->linkB1->p6.x - octree1->linkB1->p7.x);


									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4T) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkT == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB1->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = BSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE2 = octree1->linkB1->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB1->p4.x + octree1->linkB1->p5.x);
										y_c = 0.5*(octree1->linkB1->p4.y + octree1->linkB1->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										if (binc2) {
#if doubleintprecision == 1
											printf("error internal source B1 elm=%lld\n", maxelm);
#else
											printf("error internal source B1 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = BSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE2 = octree1->linkB1->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkB2 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).
								
								// Заглушка.
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								
								sosedi[GG][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi B2 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi B2 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4T) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkT == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}


								maxbound++;
								*/
							}
							else {
								if (octree1->linkB2->inum_TD == 0) {
									
									G = BSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
									sosedi[GG][maxelm].bdroblenie4 = true;
									
#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi B2 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi B2 elm=%d\n", maxelm);
#endif
									
									//getchar();


									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkB2->p7.y - octree1->linkB2->p4.y)*fabs(octree1->linkB2->p6.x - octree1->linkB2->p7.x);


									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4T) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkT == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB2->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = BSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE3 = octree1->linkB2->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB2->p4.x + octree1->linkB2->p5.x);
										y_c = 0.5*(octree1->linkB2->p4.y + octree1->linkB2->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
										if (binc3) {
#if doubleintprecision == 1
											printf("error internal source B2 elm=%lld\n", maxelm);
#else
											printf("error internal source B2 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = BSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE3 = octree1->linkB2->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkB3 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;
								#if doubleintprecision == 1
										printf("error NULL sosedi B3 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi B3 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[CP][maxbound] = prop[CP][maxelm];
								prop_b[LAM][maxbound] = prop[LAM][maxelm];
								prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
								prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
								prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4T) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
									if (octree1->linkT == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkB3->inum_TD == 0) {
									

									G = BSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE4 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_TD == 0 sosedi B3 elm=%lld\n", maxelm);
#else
									//printf("error inum_TD == 0 sosedi B3 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[CP][maxbound] = prop[CP][maxelm];
									prop_b[LAM][maxbound] = prop[LAM][maxelm];
									prop_b[MULT_LAM_X][maxbound] = prop[MULT_LAM_X][maxelm];
									prop_b[MULT_LAM_Y][maxbound] = prop[MULT_LAM_Y][maxelm];
									prop_b[MULT_LAM_Z][maxbound] = prop[MULT_LAM_Z][maxelm];

									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkB3->p7.y - octree1->linkB3->p4.y)*fabs(octree1->linkB3->p6.x - octree1->linkB3->p7.x);


									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4T) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT4->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkT == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkT->inum_TD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB3->inum_TD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = BSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE4 = octree1->linkB3->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB3->p4.x + octree1->linkB3->p5.x);
										y_c = 0.5*(octree1->linkB3->p4.y + octree1->linkB3->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
										if (binc4) {
#if doubleintprecision == 1
											printf("error internal source B3 elm=%lld\n", maxelm);
#else
											printf("error internal source B3 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = BSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE4 = octree1->linkB3->inum_TD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											  case ESIDE: GG = EE; break; // E
											  case NSIDE: GG = NN; break; // NSIDE
											  case TSIDE: GG = TTSIDE; break; // T
											  case WSIDE: GG = WW; break; // W
											  case SSIDE: GG = SS; break; // S
											  case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}
						}
					}


					bvisit[maxelm] = true; // Узел был посещён.
					maxelm++;
				}
				//octree1->inum_TD = 0; // По умолчанию не принадлежит расчётной области.
				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}

	delete[] bvisit;
	bvisit = NULL;
} // constr_sosedi_prop_b_alice


// Вычисление соседей для каждого внутреннего узла. 
// Причём множество соседей выбирается и среди внутренних КО и 
// среди граничных КО.
// Создана на базе calculate_max_bound_temp.
// Самое начало реализации. 10.сентября.2016 14_20. 
//  Середина разработки 21 сентября 2016.
// Окончил писать и жду запуска для тестирования 22 сетября 2016.
void constr_sosedi_prop_b_flow_alice(octTree* &oc, BOUND* &sosedb,
	ALICE_PARTITION** &sosedi, doublereal **prop, doublereal** &prop_b,
	integer maxbound_out, integer maxelm_memo, integer maxelm_memo1,
	BLOCK* b, integer lb, SOURCE* s, integer ls, WALL* w, integer lw,
	integer* &whot_is_block,
	integer** nvtx, TOCHKA* &pa) {

	integer G, GG;

	// Выделение оперативной памяти.
	sosedi = NULL;
	sosedi = new ALICE_PARTITION*[12];
	if (sosedi == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for sosedi constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	for (integer i = 0; i<12; i++) sosedi[i] = NULL;
	for (integer i = 0; i<12; i++) {
		sosedi[i] = new ALICE_PARTITION[maxelm_memo + 2];
		if (sosedi[i] == NULL) {
			// недостаточно памяти на данном оборудовании.
#if doubleintprecision == 1
			printf("Problem : not enough memory on your equipment for sosedi[%lld] constr struct_alice...\n", i);
#else
			printf("Problem : not enough memory on your equipment for sosedi[%d] constr struct_alice...\n", i);
#endif
			
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
	}

	// Выделение оперативной памяти:
	prop_b = NULL;
	prop_b = new doublereal*[3];
	if (prop_b == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for prop_b constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}

	for (integer i = 0; i<3; i++) prop_b[i] = NULL;
	for (integer i = 0; i<3; i++) {
		prop_b[i] = new doublereal[maxbound_out];
		if (prop_b[i] == NULL) {
			// недостаточно памяти на данном оборудовании.
#if doubleintprecision == 1
			printf("Problem : not enough memory on your equipment for prop_b[%lld] constr struct_alice...\n", i);
#else
			printf("Problem : not enough memory on your equipment for prop_b[%d] constr struct_alice...\n", i);
#endif
			
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
	}

	// Алгоритм:
	// Выделение оперативной памяти:
	// gran[0..5][0..maxbound-1]
	sosedb = NULL;
	sosedb = new BOUND[maxbound_out];
	if (sosedb == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for sosedb constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}


	integer maxbound = 0; // инициализация.
	integer maxelm = 0;
	bool *bvisit = NULL;
	bvisit = new bool[maxelm_memo + 2];
	if (bvisit == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for bvisit constr struct_alice...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	for (integer j = 0; j<maxelm_memo + 2; j++) bvisit[j] = false; // признак посещения узла.
	doublereal x_c, y_c, z_c;
	integer iplane;

	top_ALICE_STACK = 0;
	if (oc->link0 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != NULL) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != NULL) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist == true) {

				octTree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				TOCHKA p;
				p.x = 0.125*(octree1->p0.x + octree1->p1.x + octree1->p2.x + octree1->p3.x + octree1->p4.x + octree1->p5.x + octree1->p6.x + octree1->p7.x);
				p.y = 0.125*(octree1->p0.y + octree1->p1.y + octree1->p2.y + octree1->p3.y + octree1->p4.y + octree1->p5.y + octree1->p6.y + octree1->p7.y);
				p.z = 0.125*(octree1->p0.z + octree1->p1.z + octree1->p2.z + octree1->p3.z + octree1->p4.z + octree1->p5.z + octree1->p6.z + octree1->p7.z);
				integer ib;
				bool inDomain = false;

				inDomain = in_model_flow(p, ib, b, lb); // HYDRODINAMIC  CFD!!!

				if (inDomain) {
					// Узел принадлекжит расчётной области и его номер maxelm==octree1->inum_FD.

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4E) {
						if (octree1->linkE == NULL) {
							G = ESIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];
							

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkW == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}
							maxbound++;
						}
						else {
							if (octree1->linkE->inum_FD == 0) {
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = false;
								sosedi[G][maxelm].iNODE2 = -1;
								sosedi[G][maxelm].iNODE3 = -1;
								sosedi[G][maxelm].iNODE4 = -1;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = false;
								sosedi[GG][maxelm].iNODE2 = -1;
								sosedi[GG][maxelm].iNODE3 = -1;
								sosedi[GG][maxelm].iNODE4 = -1;

								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];
								


								// вычисление размеров текущего контрольного объёма:
								doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контроольного объёма
								volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
								doublereal dSloc = dy_loc*dz_loc;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4W) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									if (octree1->linkW == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
								}
								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkE->inum_FD - 1]) {

									integer inode_now = sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE1;
									if (octree1->linkE->b4W) {
										integer etalon_id = octree1->inum_FD - 1;
										bool bcontinue = true;
										if (bcontinue) {
											if (octree1->linkE->linkW0!=NULL) {
												if (octree1->linkE->linkW0->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE1
													if (sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE1 == etalon_id) {
														inode_now = sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE1;
													}
													else {
														printf("takogo bjtx ne moshet E W0\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkE->linkW3 != NULL) {
												if (octree1->linkE->linkW3->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE2
													if (sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE2 == etalon_id) {
														inode_now = sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE2;
													}
													else {
														printf("takogo bjtx ne moshet E W3\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkE->linkW4 != NULL) {
												if (octree1->linkE->linkW4->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE3
													if (sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE3 == etalon_id) {
														inode_now = sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE3;
													}
													else {
														printf("takogo bjtx ne moshet E W4\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkE->linkW7 != NULL) {
												if (octree1->linkE->linkW7->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE4
													if (sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE4 == etalon_id) {
														inode_now = sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE4;
													}
													else {
														printf("takogo bjtx ne moshet E W7\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}

									}


									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
									if (inode_now >= maxelm_memo) {

										printf("bvisit error  E ...\n");
										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										//exit(1);

										/*
										// Это граничная грань внутреннего источника тепла.
										G = ESIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;

										prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
										prop_b[MU][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MU][maxelm];
										prop_b[BETA_T][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[BETA_T][maxelm];

										// TODO 22.09.2016
										// Проблема. Надо подумать над ситуацией.
										printf("nado podumat nad situaciei.\n");
										getchar();

										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][octree1->linkE->inum_FD - 1];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][octree1->linkE->inum_FD - 1];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][octree1->linkE->inum_FD - 1];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][octree1->linkE->inum_FD - 1];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][octree1->linkE->inum_FD - 1];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][octree1->linkE->inum_FD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][maxelm];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][maxelm];
										}



										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dy_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4W) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE1 - maxelm_memo,
												octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
										}
										else {
											if (octree1->linkW == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE1 - maxelm_memo,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[WSIDE][octree1->linkE->inum_FD - 1].iNODE1 - maxelm_memo,
													octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
										}

										*/

									}
									else {
										// Это строго внутренний узел.
										// Внутренний узел.
										G = ESIDE;
										// внутренняя грань (нумерация начинается с нуля):
										sosedi[G][maxelm].iNODE1 = octree1->linkE->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}

								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = octree1->p1.x;
									y_c = 0.5*(octree1->p1.y + octree1->p2.y);
									z_c = 0.5*(octree1->p1.z + octree1->p5.z);
									iplane = YZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
									if (binc) {

										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										exit(1);

										/*
										// Внутренний источник тепла.
										G = ESIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										// Сосед E есть внутренний узел и он еще не был посещен.
										// На границе этих двух внутренних узлов расположен источник тепла.

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][maxbound - 1] = prop[RHO][octree1->linkE->inum_FD - 1];
											prop_b[CP][maxbound - 1] = prop[CP][octree1->linkE->inum_FD - 1];
											prop_b[LAM][maxbound - 1] = prop[LAM][octree1->linkE->inum_FD - 1];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][octree1->linkE->inum_FD - 1];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][octree1->linkE->inum_FD - 1];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][octree1->linkE->inum_FD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][maxbound - 1] = prop[RHO][maxelm];
											prop_b[CP][maxbound - 1] = prop[CP][maxelm];
											prop_b[LAM][maxbound - 1] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][maxelm];
										}



										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dy_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4W) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
												octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
										}
										else {
											if (octree1->linkW == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
										}

										*/

									}
									else {
										// Внутренний узел.
										G = ESIDE;
										// внутренняя грань (нумерация начинается с нуля):
										sosedi[G][maxelm].iNODE1 = octree1->linkE->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										// Определение дальнего соседа :
										// TODO 13 сентября 2016.

									}

								}
							}
						}
					}
					else {

						if ((octree1->linkE1 == NULL) && (octree1->linkE2 == NULL) && (octree1->linkE5 == NULL) && (octree1->linkE6 == NULL)) {
							G = ESIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];
							

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkW == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {

									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 != NULL) && (octree1->linkE5 != NULL) && (octree1->linkE6 != NULL) &&
							(octree1->linkE1->inum_FD == 0) && (octree1->linkE2->inum_FD == 0) && (octree1->linkE5->inum_FD == 0) && (octree1->linkE6->inum_FD == 0)) {
							G = ESIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];
							

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkW == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}
							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 == NULL) && (octree1->linkE5 != NULL) && (octree1->linkE6 == NULL) &&
							(octree1->linkE1->inum_FD == 0) && (octree1->linkE5->inum_FD == 0)) {
							G = ESIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];
							


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkW == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 != NULL) && (octree1->linkE5 == NULL) && (octree1->linkE6 == NULL) &&
							(octree1->linkE1->inum_FD == 0) && (octree1->linkE2->inum_FD == 0)) {
							G = ESIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

							

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkW == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkE1 != NULL) && (octree1->linkE2 == NULL) && (octree1->linkE5 == NULL) && (octree1->linkE6 == NULL) &&
							(octree1->linkE1->inum_FD == 0)) {
							G = ESIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

							


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkW == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkE1 == NULL) {
#if doubleintprecision == 1
								printf("error NULL sosedi E1 elm=%lld\n", maxelm);
#else
								printf("error NULL sosedi E1 elm=%d\n", maxelm);
#endif
								
								//getchar();
								system("PAUSE");
								/*
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi E1 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi E1 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь нужно предусмотреть обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

								

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkW == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkE1->inum_FD == 0) {
									G = ESIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;

									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi E1 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi E1 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь нужно предусмотреть обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

									

									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkE1->p4.z - octree1->linkE1->p0.z)*fabs(octree1->linkE1->p3.y - octree1->linkE1->p0.y);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4W) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkW == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE1->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Здесь не может быть внутреннего источника тепла иначе 
										// выдавалось бы предупреждение 
#if doubleintprecision == 1
										//printf("error internal source E1 elm=%lld\n", maxelm);
#else
										//printf("error internal source E1 elm=%d\n", maxelm);
#endif
										
										//getchar();
										// В узле octree1->linkE1->inum_FD - 1 Который был посещен ранее.
										// Здесь возможен только внутренний узел.
										// Внутренний узел.
										G = ESIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkE1->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;

										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.

									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE1->p0.y + octree1->linkE1->p3.y);
										z_c = 0.5*(octree1->linkE1->p0.z + octree1->linkE1->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										if (binc1) {
#if doubleintprecision == 1
											printf("error internal source E1 elm=%lld\n", maxelm);
#else
											printf("error internal source E1 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Внутренний узел.
											G = ESIDE;
											// Внутренняя грань:
											sosedi[G][maxelm].iNODE1 = octree1->linkE1->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;

											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.

										}
									}
								}
							}

							if (octree1->linkE2 == NULL) {
								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE2 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;


								/*
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE2 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
									printf("error NULL sosedi E2 elm=%lld\n", maxelm);
								#else
									printf("error NULL sosedi E2 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь нужно предусмотреть обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];



								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkW == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}



								maxbound++;
								*/
							}
							else {
								if (octree1->linkE2->inum_FD == 0) {
									G = ESIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;

									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE2 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi E2 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi E2 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь нужно предусмотреть обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkE2->p4.z - octree1->linkE2->p0.z)*fabs(octree1->linkE2->p3.y - octree1->linkE2->p0.y);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4W) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkW == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE2->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Здесь тоже возможен лишь строго внутренний узел.
										// Внутренний узел.
										G = ESIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE2 = octree1->linkE2->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;

										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.

									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE2->p0.y + octree1->linkE2->p3.y);
										z_c = 0.5*(octree1->linkE2->p0.z + octree1->linkE2->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										if (binc2) {
#if doubleintprecision == 1
											printf("error internal source E2 elm=%lld\n", maxelm);
#else
											printf("error internal source E2 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Внутренний узел.
											G = ESIDE;
											// Внутренняя грань:
											sosedi[G][maxelm].iNODE2 = octree1->linkE2->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;

											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.

										}
									}
								}
							}

							if (octree1->linkE5 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE3 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE3 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi E5 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi E5 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь нужно предусмотреть обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

								

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkW == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkE5->inum_FD == 0) {
									G = ESIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;

									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE3 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi E5 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi E5 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь нужно предусмотреть обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkE5->p4.z - octree1->linkE5->p0.z)*fabs(octree1->linkE5->p3.y - octree1->linkE5->p0.y);


									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4W) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkW == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE5->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Здесь тоже возможен лишь строго внутренний узел.
										// Внутренний узел.
										G = ESIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE3 = octree1->linkE5->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;

										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE5->p0.y + octree1->linkE5->p3.y);
										z_c = 0.5*(octree1->linkE5->p0.z + octree1->linkE5->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
										if (binc3) {
#if doubleintprecision == 1
											printf("error internal source E5 elm=%lld\n", maxelm);
#else
											printf("error internal source E5 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Внутренний узел.
											G = ESIDE;
											// Внутренняя грань:
											sosedi[G][maxelm].iNODE3 = octree1->linkE5->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;

											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkE6 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE4 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;


								/*
								G = ESIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;

								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE4 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
									printf("error NULL sosedi E6 elm=%lld\n", maxelm);
								#else
									printf("error NULL sosedi E6 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь нужно предусмотреть обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

								

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4W) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkW == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}


								maxbound++;
								*/
							}
							else {
								if (octree1->linkE6->inum_FD == 0) {
									G = ESIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;

									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE4 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi E6 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi E6 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь нужно предусмотреть обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

									

									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkE6->p4.z - octree1->linkE6->p0.z)*fabs(octree1->linkE6->p3.y - octree1->linkE6->p0.y);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4W) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkW0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkW == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkW->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkE6->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Здесь тоже возможен лишь строго внутренний узел.
										// Внутренний узел.
										G = ESIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE4 = octree1->linkE6->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;

										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p1.x;
										y_c = 0.5*(octree1->linkE6->p0.y + octree1->linkE6->p3.y);
										z_c = 0.5*(octree1->linkE6->p0.z + octree1->linkE6->p4.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
										if (binc4) {
#if doubleintprecision == 1
											printf("error internal source E6 elm=%lld\n", maxelm);
#else
											printf("error internal source E6 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Внутренний узел.
											G = ESIDE;
											// Внутренняя грань:
											sosedi[G][maxelm].iNODE4 = octree1->linkE6->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;

											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4W) {
						if (octree1->linkW == NULL) {
							G = WSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];



							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkE == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							maxbound++;
						}
						else {
							if (octree1->linkW->inum_FD == 0) {
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = false;
								sosedi[G][maxelm].iNODE2 = -1;
								sosedi[G][maxelm].iNODE3 = -1;
								sosedi[G][maxelm].iNODE4 = -1;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = false;
								sosedi[GG][maxelm].iNODE2 = -1;
								sosedi[GG][maxelm].iNODE3 = -1;
								sosedi[GG][maxelm].iNODE4 = -1;

								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];
								

								// вычисление размеров текущего контрольного объёма:
								doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
								volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
								doublereal dSloc = dy_loc*dz_loc;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4E) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									if (octree1->linkE == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
								}

								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkW->inum_FD - 1]) {


									integer inode_now = sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE1;
									if (octree1->linkW->b4E) {
										integer etalon_id = octree1->inum_FD - 1;
										bool bcontinue = true;
										if (bcontinue) {
											if (octree1->linkW->linkE1 != NULL) {
												if (octree1->linkW->linkE1->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE1
													if (sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE1 == etalon_id) {
														inode_now = sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE1;
													}
													else {
														printf("takogo bjtx ne moshet W E1\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkW->linkE2 != NULL) {
												if (octree1->linkW->linkE2->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE2
													if (sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE2 == etalon_id) {
														inode_now = sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE2;
													}
													else {
														printf("takogo bjtx ne moshet W E2\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkW->linkE5 != NULL) {
												if (octree1->linkW->linkE5->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE3
													if (sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE3 == etalon_id) {
														inode_now = sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE3;
													}
													else {
														printf("takogo bjtx ne moshet W E5\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkW->linkE6 != NULL) {
												if (octree1->linkW->linkE6->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE4
													if (sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE4 == etalon_id) {
														inode_now = sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE4;
													}
													else {
														printf("takogo bjtx ne moshet W E6\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}								

									}

									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
									if (inode_now >= maxelm_memo) {

										printf("bvisit error  W ...\n");
										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										//exit(1);

										/*

										// Это граничная грань внутреннего источника тепла.
										// Внутренний источник тепла.
										G = WSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][octree1->linkW->inum_FD - 1];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][octree1->linkW->inum_FD - 1];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][octree1->linkW->inum_FD - 1];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][octree1->linkW->inum_FD - 1];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][octree1->linkW->inum_FD - 1];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][octree1->linkW->inum_FD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][maxelm];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dy_loc*dz_loc;


										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4E) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE1 - maxelm_memo,
												octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
										}
										else {
											if (octree1->linkE == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE1 - maxelm_memo,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[ESIDE][octree1->linkW->inum_FD - 1].iNODE1 - maxelm_memo,
													octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
										}

										*/

									}
									else {
										// Это строго внутренний узел.
										G = WSIDE;
										// внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkW->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}

								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = octree1->p0.x;
									y_c = 0.5*(octree1->p0.y + octree1->p3.y);
									z_c = 0.5*(octree1->p0.z + octree1->p4.z);
									iplane = YZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
									if (binc) {

										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										exit(1);

										/*
										// Внутренний источник тепла.
										G = WSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][maxbound - 1] = prop[RHO][octree1->linkW->inum_FD - 1];
											prop_b[CP][maxbound - 1] = prop[CP][octree1->linkW->inum_FD - 1];
											prop_b[LAM][maxbound - 1] = prop[LAM][octree1->linkW->inum_FD - 1];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][octree1->linkW->inum_FD - 1];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][octree1->linkW->inum_FD - 1];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][octree1->linkW->inum_FD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][maxbound - 1] = prop[RHO][maxelm];
											prop_b[CP][maxbound - 1] = prop[CP][maxelm];
											prop_b[LAM][maxbound - 1] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dy_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4E) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
												octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
										}
										else {
											if (octree1->linkE == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
										}

										*/

									}
									else {
										// Внутренний узел.
										G = WSIDE;
										// внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkW->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										// Определение дальнего соседа :
										// TODO 13 сентября 2016.

									}
								}
							}
						}
					}
					else {

						if ((octree1->linkW0 == NULL) && (octree1->linkW3 == NULL) && (octree1->linkW4 == NULL) && (octree1->linkW7 == NULL)) {
							G = WSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkE == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 != NULL) && (octree1->linkW4 != NULL) && (octree1->linkW7 != NULL) &&
							(octree1->linkW0->inum_FD == 0) && (octree1->linkW3->inum_FD == 0) && (octree1->linkW4->inum_FD == 0) && (octree1->linkW7->inum_FD == 0)) {
							G = WSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkE == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 == NULL) && (octree1->linkW4 != NULL) && (octree1->linkW7 == NULL) &&
							(octree1->linkW0->inum_FD == 0) && (octree1->linkW4->inum_FD == 0)) {
							G = WSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

							

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkE == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 != NULL) && (octree1->linkW4 == NULL) && (octree1->linkW7 == NULL) &&
							(octree1->linkW0->inum_FD == 0) && (octree1->linkW3->inum_FD == 0)) {
							G = WSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkE == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkW0 != NULL) && (octree1->linkW3 == NULL) && (octree1->linkW4 == NULL) && (octree1->linkW7 == NULL) &&
							(octree1->linkW0->inum_FD == 0)) {
							G = WSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

							

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dy_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkE == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkW0 == NULL) {

#if doubleintprecision == 1
								printf("error NULL sosedi W0 elm=%lld\n", maxelm);
#else
								printf("error NULL sosedi W0 elm=%d\n", maxelm);
#endif
								
								//getchar();
								system("PAUSE");

								/*
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;
								#if doubleintprecision == 1
										printf("error NULL sosedi W0 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi W0 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkE == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkW0->inum_FD == 0) {
									G = WSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;
#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi W0 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi W0 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkW0->p5.z - octree1->linkW0->p1.z)*fabs(octree1->linkW0->p2.y - octree1->linkW0->p1.y);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4E) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkE == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW0->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = WSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkW0->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.

									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW0->p1.y + octree1->linkW0->p2.y);
										z_c = 0.5*(octree1->linkW0->p1.z + octree1->linkW0->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										if (binc1) {
#if doubleintprecision == 1
											printf("error internal source W0 elm=%lld\n", maxelm);
#else
											printf("error internal source W0 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = WSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE1 = octree1->linkW0->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkW3 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE2 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE2 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
									printf("error NULL sosedi W3 elm=%lld\n", maxelm);
								#else
									printf("error NULL sosedi W3 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkE == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/

							}
							else {
								if (octree1->linkW3->inum_FD == 0) {
									G = WSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE2 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi W3 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi W3 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkW3->p5.z - octree1->linkW3->p1.z)*fabs(octree1->linkW3->p2.y - octree1->linkW3->p1.y);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4E) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkE == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}


									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW3->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = WSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE2 = octree1->linkW3->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW3->p1.y + octree1->linkW3->p2.y);
										z_c = 0.5*(octree1->linkW3->p1.z + octree1->linkW3->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										if (binc2) {
#if doubleintprecision == 1
											printf("error internal source W3 elm=%lld\n", maxelm);
#else
											printf("error internal source W3 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = WSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE2 = octree1->linkW3->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkW4 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE3 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE3 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi W4 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi W4 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkE == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/

							}
							else {
								if (octree1->linkW4->inum_FD == 0) {
									G = WSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE3 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi W4 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi W4 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkW4->p5.z - octree1->linkW4->p1.z)*fabs(octree1->linkW4->p2.y - octree1->linkW4->p1.y);


									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4E) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkE == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW4->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = WSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE3 = octree1->linkW4->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW4->p1.y + octree1->linkW4->p2.y);
										z_c = 0.5*(octree1->linkW4->p1.z + octree1->linkW4->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
										if (binc3) {
#if doubleintprecision == 1
											printf("error internal source W4 elm=%lld\n", maxelm);
#else
											printf("error internal source W4 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = WSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE3 = octree1->linkW4->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkW7 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE4 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = WSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE4 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = true;
								#if doubleintprecision == 1
										printf("error NULL sosedi W7 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi W7 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4E) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkE == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/

							}
							else {
								if (octree1->linkW7->inum_FD == 0) {
									G = WSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE4 = -1; // соседа нет.
									sosedi[GG][maxelm].bdroblenie4 = true;
#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi W7 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi W7 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sy*Sz
									doublereal dS_loc = fabs(octree1->linkW7->p5.z - octree1->linkW7->p1.z)*fabs(octree1->linkW7->p2.y - octree1->linkW7->p1.y);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4E) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkE1->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkE == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkE->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkW7->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = WSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE4 = octree1->linkW7->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = octree1->p0.x;
										y_c = 0.5*(octree1->linkW7->p1.y + octree1->linkW7->p2.y);
										z_c = 0.5*(octree1->linkW7->p1.z + octree1->linkW7->p5.z);
										iplane = YZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
										if (binc4) {
#if doubleintprecision == 1
											printf("error internal source W7 elm=%lld\n", maxelm);
#else
											printf("error internal source W7 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = WSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE4 = octree1->linkW7->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}
						}
					}


					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4N) {
						if (octree1->linkN == NULL) {
							G = NSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkS == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							maxbound++;
						}
						else {
							if (octree1->linkN->inum_FD == 0) {
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = false;
								sosedi[G][maxelm].iNODE2 = -1;
								sosedi[G][maxelm].iNODE3 = -1;
								sosedi[G][maxelm].iNODE4 = -1;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = false;
								sosedi[GG][maxelm].iNODE2 = -1;
								sosedi[GG][maxelm].iNODE3 = -1;
								sosedi[GG][maxelm].iNODE4 = -1;

								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								// вычисление размеров текущего контрольного объёма:
								doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
								volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
								doublereal dSloc = dx_loc*dz_loc;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4S) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									if (octree1->linkS == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
								}

								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkN->inum_FD - 1]) {

									integer inode_now = sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE1;
									//S0 NODE1,
									//S1 NODE2,
									//S4 NODE3,
									//S5 NODE4.
									 // TODO 23 сентября 2016.
									if (octree1->linkN->b4S) {
										integer etalon_id = octree1->inum_FD - 1;
										bool bcontinue = true;
										if (bcontinue) {
											if (octree1->linkN->linkS0 != NULL) {
												if (octree1->linkN->linkS0->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE1
													if (sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE1 == etalon_id) {
														inode_now = sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE1;
													}
													else {
														printf("takogo bjtx ne moshet N S0\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkN->linkS1 != NULL) {
												if (octree1->linkN->linkS1->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE2
													if (sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE2 == etalon_id) {
														inode_now = sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE2;
													}
													else {
														printf("takogo bjtx ne moshet N S1\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkN->linkS4 != NULL) {
												if (octree1->linkN->linkS4->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE3
													if (sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE3 == etalon_id) {
														inode_now = sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE3;
													}
													else {
														printf("takogo bjtx ne moshet N S4\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkN->linkS5 != NULL) {
												if (octree1->linkN->linkS5->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE4
													if (sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE4 == etalon_id) {
														inode_now = sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE4;
													}
													else {
														printf("takogo bjtx ne moshet N S5\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}

									}
									

									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
									if (inode_now >= maxelm_memo) {

										printf("bvisit error  N ...\n");
										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										//exit(1);

										/*

										// Это граничная грань внутреннего источника тепла.
										// Внутренний источник тепла.
										G = NSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][octree1->linkN->inum_FD - 1];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][octree1->linkN->inum_FD - 1];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][octree1->linkN->inum_FD - 1];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][octree1->linkN->inum_FD - 1];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][octree1->linkN->inum_FD - 1];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][octree1->linkN->inum_FD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][maxelm];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4S) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE1 - maxelm_memo,
												octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
										}
										else {
											if (octree1->linkS == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE1 - maxelm_memo,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[SSIDE][octree1->linkN->inum_FD - 1].iNODE1 - maxelm_memo,
													octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
										}

										*/

									}
									else {
										// Это строго внутренний узел.
										// Внутренний узел.
										G = NSIDE;
										// внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkN->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа.
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}

								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p2.x + octree1->p3.x);
									y_c = octree1->p3.y;
									z_c = 0.5*(octree1->p3.z + octree1->p7.z);
									iplane = XZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
									if (binc) {

										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										exit(1);

										/*

										// Внутренний источник тепла.
										G = NSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][maxbound - 1] = prop[RHO][octree1->linkN->inum_FD - 1];
											prop_b[CP][maxbound - 1] = prop[CP][octree1->linkN->inum_FD - 1];
											prop_b[LAM][maxbound - 1] = prop[LAM][octree1->linkN->inum_FD - 1];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][octree1->linkN->inum_FD - 1];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][octree1->linkN->inum_FD - 1];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][octree1->linkN->inum_FD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][maxbound - 1] = prop[RHO][maxelm];
											prop_b[CP][maxbound - 1] = prop[CP][maxelm];
											prop_b[LAM][maxbound - 1] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4S) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
												octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
										}
										else {
											if (octree1->linkS == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
										}
                                        
										*/

									}
									else {
										// Внутренний узел.
										G = NSIDE;
										// внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkN->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа.
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										// Определение дальнего соседа :
										// TODO 13 сентября 2016.

									}

								}
							}
						}
					}
					else {

						if ((octree1->linkN2 == NULL) && (octree1->linkN3 == NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 == NULL)) {
							G = NSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];



							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;


							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkS == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkN2 != NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 != NULL) && (octree1->linkN7 != NULL) &&
							(octree1->linkN2->inum_FD == 0) && (octree1->linkN3->inum_FD == 0) && (octree1->linkN6->inum_FD == 0) && (octree1->linkN7->inum_FD == 0)) {
							G = NSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];



							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkS == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkN2 == NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 != NULL) &&
							(octree1->linkN3->inum_FD == 0) && (octree1->linkN7->inum_FD == 0)) {
							G = NSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkS == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkN2 != NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 == NULL) &&
							(octree1->linkN2->inum_FD == 0) && (octree1->linkN3->inum_FD == 0)) {
							G = NSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkS == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkN2 == NULL) && (octree1->linkN3 != NULL) && (octree1->linkN6 == NULL) && (octree1->linkN7 == NULL) &&
							(octree1->linkN3->inum_FD == 0)) {
							G = NSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkS == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkN2 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE1 = -1; // нет соседа,
								sosedi[GG][maxelm].bdroblenie4 = true;


								/*
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE1 = -1; // нет соседа,
								sosedi[GG][maxelm].bdroblenie4 = true;
								#if doubleintprecision == 1
										printf("error NULL sosedi N2 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi N2 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkS == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}


								maxbound++;
								*/
							}
							else {
								if (octree1->linkN2->inum_FD == 0) {

									G = NSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE1 = -1; // нет соседа,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi N2 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi N2 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];
									

									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkN2->p4.z - octree1->linkN2->p0.z)*fabs(octree1->linkN2->p1.x - octree1->linkN2->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4S) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkS == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN2->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = NSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkN2->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN2->p0.x + octree1->linkN2->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN2->p0.z + octree1->linkN2->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										if (binc1) {
#if doubleintprecision == 1
											printf("error internal source N2 elm=%lld\n", maxelm);
#else
											printf("error internal source N2 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = NSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE1 = octree1->linkN2->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkN3 == NULL) {

#if doubleintprecision == 1
								printf("error NULL sosedi N3 elm=%lld\n", maxelm);
#else
								printf("error NULL sosedi N3 elm=%d\n", maxelm);
#endif
								
								//getchar();
								system("PAUSE");

								/*
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // нет соседей,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi N3 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi N3 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];



								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkS == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}


								maxbound++;
								*/

							}
							else {
								if (octree1->linkN3->inum_FD == 0) {

									G = NSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE2 = -1; // нет соседей,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi N3 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi N3 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkN3->p4.z - octree1->linkN3->p0.z)*fabs(octree1->linkN3->p1.x - octree1->linkN3->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4S) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkS == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}


									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN3->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = NSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE2 = octree1->linkN3->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN3->p0.x + octree1->linkN3->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN3->p0.z + octree1->linkN3->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										if (binc2) {
#if doubleintprecision == 1
											printf("error internal source N3 elm=%lld\n", maxelm);
#else
											printf("error internal source N3 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = NSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE2 = octree1->linkN3->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkN6 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi N6 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi N6 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkS == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/

							}
							else {
								if (octree1->linkN6->inum_FD == 0) {

									G = NSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi N6 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi N6 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkN6->p4.z - octree1->linkN6->p0.z)*fabs(octree1->linkN6->p1.x - octree1->linkN6->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4S) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkS == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN6->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = NSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE3 = octree1->linkN6->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN6->p0.x + octree1->linkN6->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN6->p0.z + octree1->linkN6->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
										if (binc3) {
#if doubleintprecision == 1
											printf("error internal source N6 elm=%lld\n", maxelm);
#else
											printf("error internal source N6 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = NSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE3 = octree1->linkN6->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkN7 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[GG][maxelm].bdroblenie4 = true;


								/*
								G = NSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = - 1; // граничные КО нумеруются в последнюю очередь,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi N7 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi N7 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4S) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkS == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}


								maxbound++;
								*/
							}
							else {
								if (octree1->linkN7->inum_FD == 0) {

									G = NSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi N7 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi N7 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkN7->p4.z - octree1->linkN7->p0.z)*fabs(octree1->linkN7->p1.x - octree1->linkN7->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4S) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkS0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkS == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkS->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkN7->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = NSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE4 = octree1->linkN7->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkN7->p0.x + octree1->linkN7->p1.x);
										y_c = octree1->p3.y;
										z_c = 0.5*(octree1->linkN7->p0.z + octree1->linkN7->p4.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
										if (binc4) {
#if doubleintprecision == 1
											printf("error internal source N7 elm=%lld\n", maxelm);
#else
											printf("error internal source N7 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = NSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE4 = octree1->linkN7->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4S) {
						if (octree1->linkS == NULL) {
							G = SSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkN == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							maxbound++;
						}
						else {
							if (octree1->linkS->inum_FD == 0) {
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = false;
								sosedi[G][maxelm].iNODE2 = -1;
								sosedi[G][maxelm].iNODE3 = -1;
								sosedi[G][maxelm].iNODE4 = -1;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = false;
								sosedi[GG][maxelm].iNODE2 = -1;
								sosedi[GG][maxelm].iNODE3 = -1;
								sosedi[GG][maxelm].iNODE4 = -1;

								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								// вычисление размеров текущего контрольного объёма:
								doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
								volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
								doublereal dSloc = dx_loc*dz_loc;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4N) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									if (octree1->linkN == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
								}

								maxbound++;
							}
							else {
								//bool binc;
								//integer lsid;
								// сосед существует.
								if (bvisit[octree1->linkS->inum_FD - 1]) {

									integer inode_now = sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE1;
									//N2 NODE1,
									//N3 NODE2,
									//N6 NODE3,
									//N7 NODE4.
									// TODO 23 сентября 2016.
									if (octree1->linkS->b4N) {
										integer etalon_id = octree1->inum_FD - 1;
										bool bcontinue = true;
										if (bcontinue) {
											if (octree1->linkS->linkN2 != NULL) {
												if (octree1->linkS->linkN2->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE1
													if (sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE1 == etalon_id) {
														inode_now = sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE1;
													}
													else {
														printf("takogo bjtx ne moshet S N2\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkS->linkN3 != NULL) {
												if (octree1->linkS->linkN3->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE2
													if (sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE2 == etalon_id) {
														inode_now = sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE2;
													}
													else {
														printf("takogo bjtx ne moshet S N3\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkS->linkN6 != NULL) {
												if (octree1->linkS->linkN6->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE3
													if (sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE3 == etalon_id) {
														inode_now = sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE3;
													}
													else {
														printf("takogo bjtx ne moshet S N6\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkS->linkN7 != NULL) {
												if (octree1->linkS->linkN7->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE4
													if (sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE4 == etalon_id) {
														inode_now = sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE4;
													}
													else {
														printf("takogo bjtx ne moshet S N7\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}

									}


									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
									if (inode_now >= maxelm_memo) {

										printf("bvisit error S ...\n");
										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										//exit(1);


									    /*

										// Это граничная грань внутреннего источника тепла.
										// Внутренний источник тепла.
										G = SSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][octree1->linkS->inum_FD - 1];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][octree1->linkS->inum_FD - 1];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][octree1->linkS->inum_FD - 1];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][octree1->linkS->inum_FD - 1];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][octree1->linkS->inum_FD - 1];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][octree1->linkS->inum_FD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][maxelm];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4N) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE1 - maxelm_memo,
												octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc,true, true);
										}
										else {
											if (octree1->linkN == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE1 - maxelm_memo,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc,true, true);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[NSIDE][octree1->linkS->inum_FD - 1].iNODE1 - maxelm_memo,
													octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
										}

										*/

									}
									else {
										// Это строго внутренний узел.
										// Внутренний узел.
										G = SSIDE;
										// внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkS->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}

								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p0.x + octree1->p1.x);
									y_c = octree1->p0.y;
									z_c = 0.5*(octree1->p0.z + octree1->p4.z);
									iplane = XZ;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
									if (binc) {

										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										exit(1);

										/*

										// Внутренний источник тепла.
										G = SSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][maxbound - 1] = prop[RHO][octree1->linkS->inum_FD - 1];
											prop_b[CP][maxbound - 1] = prop[CP][octree1->linkS->inum_FD - 1];
											prop_b[LAM][maxbound - 1] = prop[LAM][octree1->linkS->inum_FD - 1];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][octree1->linkS->inum_FD - 1];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][octree1->linkS->inum_FD - 1];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][octree1->linkS->inum_FD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][maxbound - 1] = prop[RHO][maxelm];
											prop_b[CP][maxbound - 1] = prop[CP][maxelm];
											prop_b[LAM][maxbound - 1] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dz_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4N) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
												octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
										}
										else {
											if (octree1->linkN == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
										}

										*/

									}
									else {
										// Внутренний узел.
										G = SSIDE;
										// внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkS->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
								}
							}
						}
					}
					else {

						if ((octree1->linkS0 == NULL) && (octree1->linkS1 == NULL) && (octree1->linkS4 == NULL) && (octree1->linkS5 == NULL)) {
							G = SSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkN == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 != NULL) && (octree1->linkS4 != NULL) && (octree1->linkS5 != NULL) &&
							(octree1->linkS0->inum_FD == 0) && (octree1->linkS1->inum_FD == 0) && (octree1->linkS4->inum_FD == 0) && (octree1->linkS5->inum_FD == 0)) {
							G = SSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;


							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkN == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 == NULL) && (octree1->linkS4 != NULL) && (octree1->linkS5 == NULL) &&
							(octree1->linkS0->inum_FD == 0) && (octree1->linkS4->inum_FD == 0)) {
							G = SSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkN == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 != NULL) && (octree1->linkS4 == NULL) && (octree1->linkS5 == NULL) &&
							(octree1->linkS0->inum_FD == 0) && (octree1->linkS1->inum_FD == 0)) {
							G = SSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkN == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkS0 != NULL) && (octree1->linkS1 == NULL) && (octree1->linkS4 == NULL) && (octree1->linkS5 == NULL) &&
							(octree1->linkS0->inum_FD == 0)) {
							G = SSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dz_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkN == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {


							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkS0 == NULL) {
#if doubleintprecision == 1
								printf("error NULL sosedi S0 elm=%lld\n", maxelm);
#else
								printf("error NULL sosedi S0 elm=%d\n", maxelm);
#endif
								
								//getchar();
								system("PAUSE");

								/*

								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi S0 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi S0 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkN == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}


								maxbound++;
								*/
							}
							else {
								if (octree1->linkS0->inum_FD == 0) {

									G = SSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE1 = -1; // соседа нет,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi S0 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi S0 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkS0->p7.z - octree1->linkS0->p3.z)*fabs(octree1->linkS0->p2.x - octree1->linkS0->p3.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4N) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkN == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS0->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = SSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkS0->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS0->p3.x + octree1->linkS0->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS0->p3.z + octree1->linkS0->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										if (binc1) {
#if doubleintprecision == 1
											printf("error internal source S0 elm=%lld\n", maxelm);
#else
											printf("error internal source S0 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = SSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE1 = octree1->linkS0->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkS1 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;


								/*
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi S1 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi S1 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkN == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkS1->inum_FD == 0) {

									G = SSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE2 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi S1 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi S1 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkS1->p7.z - octree1->linkS1->p3.z)*fabs(octree1->linkS1->p2.x - octree1->linkS1->p3.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4N) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkN == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}


									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS1->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = SSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE2 = octree1->linkS1->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS1->p3.x + octree1->linkS1->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS1->p3.z + octree1->linkS1->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										if (binc2) {
#if doubleintprecision == 1
											printf("error internal source S1 elm=%lld\n", maxelm);
#else
											printf("error internal source S1 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = SSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE2 = octree1->linkS1->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkS4 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;


								/*
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi S4 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi S4 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkN == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkS4->inum_FD == 0) {

									G = SSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}
									sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi S4 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi S4 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkS4->p7.z - octree1->linkS4->p3.z)*fabs(octree1->linkS4->p2.x - octree1->linkS4->p3.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4N) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkN == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS4->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = SSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE3 = octree1->linkS4->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS4->p3.x + octree1->linkS4->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS4->p3.z + octree1->linkS4->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
										if (binc3) {
#if doubleintprecision == 1
											printf("error internal source S4 elm=%lld\n", maxelm);
#else
											printf("error internal source S4 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = SSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE3 = octree1->linkS4->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkS5 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = SSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi S5 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi S5 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4N) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkN == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkS5->inum_FD == 0) {

									G = SSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE4 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi S5 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi S5 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sx*Sz
									doublereal dS_loc = fabs(octree1->linkS5->p7.z - octree1->linkS5->p3.z)*fabs(octree1->linkS5->p2.x - octree1->linkS5->p3.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4N) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkN3->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkN == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkN->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkS5->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = SSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE4 = octree1->linkS5->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkS5->p3.x + octree1->linkS5->p2.x);
										y_c = octree1->p0.y;
										z_c = 0.5*(octree1->linkS5->p3.z + octree1->linkS5->p7.z);
										iplane = XZ;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
										if (binc4) {
#if doubleintprecision == 1
											printf("error internal source S5 elm=%lld\n", maxelm);
#else
											printf("error internal source S5 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = SSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE4 = octree1->linkS5->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4T) {
						if (octree1->linkT == NULL) {
							G = TSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;


							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkB == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}

							}

							maxbound++;
						}
						else {
							if (octree1->linkT->inum_FD == 0) {
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = false;
								sosedi[G][maxelm].iNODE2 = -1;
								sosedi[G][maxelm].iNODE3 = -1;
								sosedi[G][maxelm].iNODE4 = -1;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = false;
								sosedi[GG][maxelm].iNODE2 = -1;
								sosedi[GG][maxelm].iNODE3 = -1;
								sosedi[GG][maxelm].iNODE4 = -1;

								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

								// вычисление размеров текущего контрольного объёма:
								doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
								volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
								doublereal dSloc = dx_loc*dy_loc;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4B) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									if (octree1->linkB == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
								}

								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkT->inum_FD - 1]) {
									
									integer inode_now = sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE1;
									if (octree1->linkT->b4B) {
										integer etalon_id = octree1->inum_FD - 1;
										bool bcontinue = true;
										if (bcontinue) {
											if (octree1->linkT->linkB0 != NULL) {
												if (octree1->linkT->linkB0->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE1
													if (sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE1 == etalon_id) {
														inode_now = sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE1;
													}
													else {
														printf("takogo bjtx ne moshet T B0\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkT->linkB1 != NULL) {
												if (octree1->linkT->linkB1->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE2
													if (sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE2 == etalon_id) {
														inode_now = sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE2;
													}
													else {
														printf("takogo bjtx ne moshet T B1\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkT->linkB2 != NULL) {
												if (octree1->linkT->linkB2->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE3
													if (sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE3 == etalon_id) {
														inode_now = sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE3;
													}
													else {
														printf("takogo bjtx ne moshet T B2\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkT->linkB3 != NULL) {
												if (octree1->linkT->linkB3->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE4
													if (sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE4 == etalon_id) {
														inode_now = sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE4;
													}
													else {
														printf("takogo bjtx ne moshet T B3\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}

									}


									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
									if (inode_now >= maxelm_memo) {

#if doubleintprecision == 1
										printf("maxelm=%lld sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE1=%lld\n", maxelm_memo, sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE1);
										printf("inum_FD-1=%lld\n", octree1->linkT->inum_FD - 1);

										octTree* oc2 = octree1->linkT;
										if (oc2->b4B) {
											printf("b4B situation.\n");
											if (oc2->linkB0 == NULL) {
												printf("B0 is null\n");
											}
											else {
												printf("inum_FD-1=%lld\n", oc2->linkB0->inum_FD - 1);
											}
											if (oc2->linkB1 == NULL) {
												printf("B1 is null\n");
											}
											else {
												printf("inum_FD-1=%lld\n", oc2->linkB1->inum_FD - 1);
											}
											if (oc2->linkB2 == NULL) {
												printf("B2 is null\n");
											}
											else {
												printf("inum_FD-1=%lld\n", oc2->linkB2->inum_FD - 1);
											}
											if (oc2->linkB3 == NULL) {
												printf("B3 is null\n");
											}
											else {
												printf("inum_FD-1=%lld\n", oc2->linkB3->inum_FD - 1);
											}
											printf("octree1->inum_FD-1=%lld\n", octree1->inum_FD - 1);

										}
										else {
											if (oc2->linkB == NULL) {
												printf("linkB is null. \n");
											}
										}
#else
										printf("maxelm=%d sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE1=%d\n", maxelm_memo, sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE1);
										printf("inum_FD-1=%d\n", octree1->linkT->inum_FD - 1);

										octTree* oc2 = octree1->linkT;
										if (oc2->b4B) {
											printf("b4B situation.\n");
											if (oc2->linkB0 == NULL) {
												printf("B0 is null\n");
											}
											else {
												printf("inum_FD-1=%d\n", oc2->linkB0->inum_FD - 1);
											}
											if (oc2->linkB1 == NULL) {
												printf("B1 is null\n");
											}
											else {
												printf("inum_FD-1=%d\n", oc2->linkB1->inum_FD - 1);
											}
											if (oc2->linkB2 == NULL) {
												printf("B2 is null\n");
											}
											else {
												printf("inum_FD-1=%d\n", oc2->linkB2->inum_FD - 1);
											}
											if (oc2->linkB3 == NULL) {
												printf("B3 is null\n");
											}
											else {
												printf("inum_FD-1=%d\n", oc2->linkB3->inum_FD - 1);
											}
											printf("octree1->inum_FD-1=%d\n", octree1->inum_FD - 1);

										}
										else {
											if (oc2->linkB == NULL) {
												printf("linkB is null. \n");
											}
										}
#endif
										

										printf("bvisit error T ...\n");
										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										//exit(1);

										/*

										// Это граничная грань внутреннего источника тепла.
										// Внутренний источник тепла.
										G = TSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;


										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][octree1->linkT->inum_FD - 1];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][octree1->linkT->inum_FD - 1];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][octree1->linkT->inum_FD - 1];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][octree1->linkT->inum_FD - 1];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][octree1->linkT->inum_FD - 1];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][octree1->linkT->inum_FD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][maxelm];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dy_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4B) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE1 - maxelm_memo,
												octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
										}
										else {
											if (octree1->linkB == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE1 - maxelm_memo,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[BSIDE][octree1->linkT->inum_FD - 1].iNODE1 - maxelm_memo,
													octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
										}

										*/

									}
									else {
										// Это строго внутренний узел.
										// Внутренняя грань.
										G = TSIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkT->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}

								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p4.x + octree1->p5.x);
									y_c = 0.5*(octree1->p4.y + octree1->p7.y);
									z_c = octree1->p4.z;
									iplane = XY;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
									if (binc) {

										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										exit(1);

										/*

										// Внутренний источник тепла.
										G = TSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][maxbound - 1] = prop[RHO][octree1->linkT->inum_FD - 1];
											prop_b[CP][maxbound - 1] = prop[CP][octree1->linkT->inum_FD - 1];
											prop_b[LAM][maxbound - 1] = prop[LAM][octree1->linkT->inum_FD - 1];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][octree1->linkT->inum_FD - 1];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][octree1->linkT->inum_FD - 1];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][octree1->linkT->inum_FD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][maxbound - 1] = prop[RHO][maxelm];
											prop_b[CP][maxbound - 1] = prop[CP][maxelm];
											prop_b[LAM][maxbound - 1] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dy_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4B) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
												octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
										}
										else {
											if (octree1->linkB == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
										}

										*/

									}
									else {
										// Внутренняя грань.
										G = TSIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkT->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
								}
							}
						}
					}
					else {

						if ((octree1->linkT4 == NULL) && (octree1->linkT5 == NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 == NULL)) {
							G = TSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkB == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 != NULL) && (octree1->linkT6 != NULL) && (octree1->linkT7 != NULL) &&
							(octree1->linkT4->inum_FD == 0) && (octree1->linkT5->inum_FD == 0) && (octree1->linkT6->inum_FD == 0) && (octree1->linkT7->inum_FD == 0)) {
							G = TSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkB == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 == NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 != NULL) &&
							(octree1->linkT4->inum_FD == 0) && (octree1->linkT7->inum_FD == 0)) {
							G = TSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

							
							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkB == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 != NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 == NULL) &&
							(octree1->linkT4->inum_FD == 0) && (octree1->linkT5->inum_FD == 0)) {
							G = TSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkB == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkT4 != NULL) && (octree1->linkT5 == NULL) && (octree1->linkT6 == NULL) && (octree1->linkT7 == NULL) &&
							(octree1->linkT4->inum_FD == 0)) {
							G = TSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkB == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {


							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkT4 == NULL) {

#if doubleintprecision == 1
								printf("error NULL sosedi T4 elm=%lld\n", maxelm);
#else
								printf("error NULL sosedi T4 elm=%d\n", maxelm);
#endif
								
								//getchar();
								system("PAUSE");

								/*

								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE1 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi T4 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi T4 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkB == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}

								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkT4->inum_FD == 0) {

									G = TSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE1 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi T4 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi T4 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkT4->p3.y - octree1->linkT4->p0.y)*fabs(octree1->linkT4->p1.x - octree1->linkT4->p0.x);


									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4B) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkB == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}

									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT4->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = TSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkT4->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT4->p0.x + octree1->linkT4->p1.x);
										y_c = 0.5*(octree1->linkT4->p0.y + octree1->linkT4->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										if (binc1) {
#if doubleintprecision == 1
											printf("error internal source T4 elm=%lld\n", maxelm);
#else
											printf("error internal source T4 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = TSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE1 = octree1->linkT4->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkT5 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // соседа нет,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // соседа нет,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi T5 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi T5 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkB == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}

								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkT5->inum_FD == 0) {

									G = TSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE2 = -1; // соседа нет,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi T5 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi T5 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkT5->p3.y - octree1->linkT5->p0.y)*fabs(octree1->linkT5->p1.x - octree1->linkT5->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4B) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkB == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}

									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT5->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = TSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE2 = octree1->linkT5->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT5->p0.x + octree1->linkT5->p1.x);
										y_c = 0.5*(octree1->linkT5->p0.y + octree1->linkT5->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										if (binc2) {
#if doubleintprecision == 1
											printf("error internal source T5 elm=%lld\n", maxelm);
#else
											printf("error internal source T5 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = TSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE2 = octree1->linkT5->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkT6 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi T6 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi T6 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkB == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}

								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkT6->inum_FD == 0) {

									G = TSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE3 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi T6 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi T6 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkT6->p3.y - octree1->linkT6->p0.y)*fabs(octree1->linkT6->p1.x - octree1->linkT6->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4B) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkB == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}

									}


									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT6->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = TSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE3 = octree1->linkT6->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT6->p0.x + octree1->linkT6->p1.x);
										y_c = 0.5*(octree1->linkT6->p0.y + octree1->linkT6->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
										if (binc3) {
#if doubleintprecision == 1
											printf("error internal source T6 elm=%lld\n", maxelm);
#else
											printf("error internal source T6 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = TSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE3 = octree1->linkT6->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkT7 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // соседа нет,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = TSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // соседа нет,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi T7 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi T7 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4B) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkB == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}

								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkT7->inum_FD == 0) {

									G = TSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE4 = -1; // соседа нет,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi T7 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi T7 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkT7->p3.y - octree1->linkT7->p0.y)*fabs(octree1->linkT7->p1.x - octree1->linkT7->p0.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4B) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkB0->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkB == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkB->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}

									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkT7->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = TSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE4 = octree1->linkT7->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkT7->p0.x + octree1->linkT7->p1.x);
										y_c = 0.5*(octree1->linkT7->p0.y + octree1->linkT7->p3.y);
										z_c = octree1->p4.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
										if (binc4) {
#if doubleintprecision == 1
											printf("error internal source T7 elm=%lld\n", maxelm);
#else
											printf("error internal source T7 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = TSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE4 = octree1->linkT7->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}
						}
					}

					// сосед не существует
					// записываем идентификатор грани и
					// увеличиваем счётчик граней.
					if (!octree1->b4B) {
						if (octree1->linkB == NULL) {
							G = BSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkT == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							maxbound++;
						}
						else {
							if (octree1->linkB->inum_FD == 0) {
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = false;
								sosedi[G][maxelm].iNODE2 = -1;
								sosedi[G][maxelm].iNODE3 = -1;
								sosedi[G][maxelm].iNODE4 = -1;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}
								sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
								sosedi[GG][maxelm].bdroblenie4 = false;
								sosedi[GG][maxelm].iNODE2 = -1;
								sosedi[GG][maxelm].iNODE3 = -1;
								sosedi[GG][maxelm].iNODE4 = -1;

								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

								// вычисление размеров текущего контрольного объёма:
								doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
								volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
								doublereal dSloc = dx_loc*dy_loc;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4T) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									if (octree1->linkT == NULL) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
									else {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
									}
								}

								maxbound++;
							}
							else {
								// сосед существует.
								if (bvisit[octree1->linkB->inum_FD - 1]) {


									integer inode_now = sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE1;
									if (octree1->linkB->b4B) {
										integer etalon_id = octree1->inum_FD - 1;
										bool bcontinue = true;
										if (bcontinue) {
											if (octree1->linkB->linkT4 != NULL) {
												if (octree1->linkB->linkT4->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE1
													if (sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE1 == etalon_id) {
														inode_now = sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE1;
													}
													else {
														printf("takogo bjtx ne moshet B T4\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkB->linkT5 != NULL) {
												if (octree1->linkB->linkT5->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE2
													if (sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE2 == etalon_id) {
														inode_now = sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE2;
													}
													else {
														printf("takogo bjtx ne moshet B T5\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkB->linkT6 != NULL) {
												if (octree1->linkB->linkT6->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE3
													if (sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE3 == etalon_id) {
														inode_now = sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE3;
													}
													else {
														printf("takogo bjtx ne moshet B T6\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}
										if (bcontinue) {
											if (octree1->linkB->linkT7 != NULL) {
												if (octree1->linkB->linkT7->inum_FD - 1 == etalon_id) {
													bcontinue = false; // iNODE4
													if (sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE4 == etalon_id) {
														inode_now = sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE4;
													}
													else {
														printf("takogo bjtx ne moshet B T7\n");
														//getchar();
														system("PAUSE");
													}
												}
											}
										}

									}

									// узел уже был посещён
									// Здесь неким образом модифицировалось gran_t
									if (inode_now >= maxelm_memo) {

										printf("bvisit error B ...\n");
										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										//exit(1);

										/*
										// Это граничная грань внутреннего источника тепла.
										// Внутренний источник тепла.
										G = BSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][octree1->linkB->inum_FD - 1];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][octree1->linkB->inum_FD - 1];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][octree1->linkB->inum_FD - 1];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][octree1->linkB->inum_FD - 1];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][octree1->linkB->inum_FD - 1];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][octree1->linkB->inum_FD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[RHO][maxelm];
											prop_b[CP][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[CP][maxelm];
											prop_b[LAM][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][sosedi[G][maxelm].iNODE1 - maxelm_memo] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dy_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4T) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE1 - maxelm_memo,
												octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
										}
										else {
											if (octree1->linkT == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE1 - maxelm_memo,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, sosedi[TSIDE][octree1->linkB->inum_FD - 1].iNODE1 - maxelm_memo,
													octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, true);
											}
										}

										*/

									}
									else {
										// Это строго внутренний узел.
										// Внутренняя грань.
										G = BSIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkB->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}

								}
								else {
									bool binc;
									integer lsid;
									// узнать координаты центра грани и ориентацию в пространстве
									x_c = 0.5*(octree1->p0.x + octree1->p1.x);
									y_c = 0.5*(octree1->p0.y + octree1->p3.y);
									z_c = octree1->p0.z;
									iplane = XY;
									patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc, lsid);
									if (binc) {

										printf("model is incorrect. FATALL error!!!\n");
										printf("internal flat heat source can not be located\n");
										printf("inside the liquid.\n");
										printf("Please, press any key to exit...\n");
										//getchar();
										system("PAUSE");
										exit(1);

										/*

										// Внутренний источник тепла.
										G = BSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}
										sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
										sosedi[GG][maxelm].bdroblenie4 = false;
										sosedi[GG][maxelm].iNODE2 = -1;
										sosedi[GG][maxelm].iNODE3 = -1;
										sosedi[GG][maxelm].iNODE4 = -1;

										integer ib1;
										bool bi_fluid = in_model_flow(p, ib1, b, lb);

										if (bi_fluid) {
											// FLUID
											prop_b[RHO][maxbound - 1] = prop[RHO][octree1->linkB->inum_FD - 1];
											prop_b[CP][maxbound - 1] = prop[CP][octree1->linkB->inum_FD - 1];
											prop_b[LAM][maxbound - 1] = prop[LAM][octree1->linkB->inum_FD - 1];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][octree1->linkB->inum_FD - 1];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][octree1->linkB->inum_FD - 1];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][octree1->linkB->inum_FD - 1];
										}
										else {
											// SOLID
											prop_b[RHO][maxbound - 1] = prop[RHO][maxelm];
											prop_b[CP][maxbound - 1] = prop[CP][maxelm];
											prop_b[LAM][maxbound - 1] = prop[LAM][maxelm];
											prop_b[MULT_LAM_X][maxbound - 1] = prop[MULT_LAM_X][maxelm];
											prop_b[MULT_LAM_Y][maxbound - 1] = prop[MULT_LAM_Y][maxelm];
											prop_b[MULT_LAM_Z][maxbound - 1] = prop[MULT_LAM_Z][maxelm];
										}

										// вычисление размеров текущего контрольного объёма:
										doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
										volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
										doublereal dSloc = dx_loc*dy_loc;

										// G - грань по которой ставится граничное условие.
										// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
										// bound_id - номер граничного узла, начиная с нуля.
										// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
										if (octree1->b4T) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
												octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
										}
										else {
											if (octree1->linkT == NULL) {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
											else {
												obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound - 1,
													octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, true, false);
											}
										}

										*/

									}
									else {
										// Внутренняя грань.
										G = BSIDE;
										// Внутренняя грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkB->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = false;
										sosedi[G][maxelm].iNODE2 = -1;
										sosedi[G][maxelm].iNODE3 = -1;
										sosedi[G][maxelm].iNODE4 = -1;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
								}
							}
						}
					}
					else {

						if ((octree1->linkB0 == NULL) && (octree1->linkB1 == NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 == NULL)) {
							G = BSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkT == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 != NULL) && (octree1->linkB2 != NULL) && (octree1->linkB3 != NULL) &&
							(octree1->linkB0->inum_FD == 0) && (octree1->linkB1->inum_FD == 0) && (octree1->linkB2->inum_FD == 0) && (octree1->linkB3->inum_FD == 0)) {
							G = BSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkT == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо четырёх один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 == NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 != NULL) &&
							(octree1->linkB0->inum_FD == 0) && (octree1->linkB3->inum_FD == 0)) {
							G = BSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkT == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 != NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 == NULL) &&
							(octree1->linkB0->inum_FD == 0) && (octree1->linkB1->inum_FD == 0)) {
							G = BSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

							
							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;


							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkT == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else if ((octree1->linkB0 != NULL) && (octree1->linkB1 == NULL) && (octree1->linkB2 == NULL) && (octree1->linkB3 == NULL) &&
							(octree1->linkB0->inum_FD == 0)) {
							G = BSIDE;
							// граничная грань:
							sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
							sosedi[G][maxelm].bdroblenie4 = false;
							sosedi[G][maxelm].iNODE2 = -1;
							sosedi[G][maxelm].iNODE3 = -1;
							sosedi[G][maxelm].iNODE4 = -1;
							// после maxelm_memo внутренних КО.
							// Вычисление дальнего соседа
							switch (G) {
							case ESIDE: GG = EE; break; // E
							case NSIDE: GG = NN; break; // NSIDE
							case TSIDE: GG = TTSIDE; break; // T
							case WSIDE: GG = WW; break; // W
							case SSIDE: GG = SS; break; // S
							case BSIDE: GG = BB; break; // B
							}
							sosedi[GG][maxelm].iNODE1 = -1; // соседа нет.
							sosedi[GG][maxelm].bdroblenie4 = false;
							sosedi[GG][maxelm].iNODE2 = -1;
							sosedi[GG][maxelm].iNODE3 = -1;
							sosedi[GG][maxelm].iNODE4 = -1;

							// В граничный узел сносятся свойства прилегающего КО:
							prop_b[RHO][maxbound] = prop[RHO][maxelm];
							prop_b[MU][maxbound] = prop[MU][maxelm];
							prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


							// вычисление размеров текущего контрольного объёма:
							doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0; // объём текущего контроольного объёма
							volume3D(maxelm, nvtx, pa, dx_loc, dy_loc, dz_loc);
							doublereal dSloc = dx_loc*dy_loc;

							// G - грань по которой ставится граничное условие.
							// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
							// bound_id - номер граничного узла, начиная с нуля.
							// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
							if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
									octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
							}
							else {
								if (octree1->linkT == NULL) {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
								else {
									obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
										octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dSloc, false, false);
								}
							}

							// Зачем дробить если граница заканчивается NULL.
							maxbound++; // Вместо двух один.
						}
						else {

							bool binc1, binc2, binc3, binc4;
							integer lsid1, lsid2, lsid3, lsid4;

							if (octree1->linkB0 == NULL) {
#if doubleintprecision == 1
								printf("error NULL sosedi B0 elm=%lld\n", maxelm);
#else
								printf("error NULL sosedi B0 elm=%d\n", maxelm);
#endif
								
								//getchar();
								system("PAUSE");

								/*
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE1 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi B0 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi B0 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkT == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkB0->inum_FD == 0) {

									G = BSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE1 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE1 = -1; // граничные КО нумеруются в последнюю очередь,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi B0 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi B0 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkB0->p7.y - octree1->linkB0->p4.y)*fabs(octree1->linkB0->p6.x - octree1->linkB0->p7.x);

									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4T) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkT == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB0->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = BSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE1 = octree1->linkB0->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB0->p4.x + octree1->linkB0->p5.x);
										y_c = 0.5*(octree1->linkB0->p4.y + octree1->linkB0->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc1, lsid1);
										if (binc1) {
#if doubleintprecision == 1
											printf("error internal source B0 elm=%lld\n", maxelm);
#else
											printf("error internal source B0 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = BSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE1 = octree1->linkB0->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkB1 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE2 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi B1 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi B1 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkT == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkB1->inum_FD == 0) {

									G = BSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE2 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE2 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi B1 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi B1 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];

									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkB1->p7.y - octree1->linkB1->p4.y)*fabs(octree1->linkB1->p6.x - octree1->linkB1->p7.x);


									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4T) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkT == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB1->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = BSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE2 = octree1->linkB1->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB1->p4.x + octree1->linkB1->p5.x);
										y_c = 0.5*(octree1->linkB1->p4.y + octree1->linkB1->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc2, lsid2);
										if (binc2) {
#if doubleintprecision == 1
											printf("error internal source B1 elm=%lld\n", maxelm);
#else
											printf("error internal source B1 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = BSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE2 = octree1->linkB1->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkB2 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi B2 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi B2 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkT == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}


								maxbound++;
								*/
							}
							else {
								if (octree1->linkB2->inum_FD == 0) {

									G = BSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE3 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE3 = -1; // граничные КО нумеруются в последнюю очередь,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi B2 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi B2 elm=%d\n", maxelm);
#endif
									
									//getchar();


									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkB2->p7.y - octree1->linkB2->p4.y)*fabs(octree1->linkB2->p6.x - octree1->linkB2->p7.x);


									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4T) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkT == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB2->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = BSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE3 = octree1->linkB2->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB2->p4.x + octree1->linkB2->p5.x);
										y_c = 0.5*(octree1->linkB2->p4.y + octree1->linkB2->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc3, lsid3);
										if (binc3) {
#if doubleintprecision == 1
											printf("error internal source B2 elm=%lld\n", maxelm);
#else
											printf("error internal source B2 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = BSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE3 = octree1->linkB2->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}

							if (octree1->linkB3 == NULL) {

								// 21 сентября 2016 (вырождение ячейки).

								// Заглушка.
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = -1; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								/*
								G = BSIDE;
								// граничная грань:
								sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
								sosedi[G][maxelm].bdroblenie4 = true;
								// после maxelm_memo внутренних КО.
								// Вычисление дальнего соседа
								switch (G) {
								case ESIDE: GG = EE; break; // E
								case NSIDE: GG = NN; break; // NSIDE
								case TSIDE: GG = TTSIDE; break; // T
								case WSIDE: GG = WW; break; // W
								case SSIDE: GG = SS; break; // S
								case BSIDE: GG = BB; break; // B
								}

								sosedi[GG][maxelm].iNODE4 = -1; // сосед отсутствует,
								sosedi[GG][maxelm].bdroblenie4 = true;

								#if doubleintprecision == 1
										printf("error NULL sosedi B3 elm=%lld\n", maxelm);
								#else
										printf("error NULL sosedi B3 elm=%d\n", maxelm);
								#endif
								
								getchar();

								// Эта ситуация возможна и здесь надо предусмотреть её обработку.
								// В граничный узел сносятся свойства прилегающего КО:
								prop_b[RHO][maxbound] = prop[RHO][maxelm];
								prop_b[MU][maxbound] = prop[MU][maxelm];
								prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


								doublereal dS_loc = 0.0;

								// G - грань по которой ставится граничное условие.
								// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
								// bound_id - номер граничного узла, начиная с нуля.
								// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
								if (octree1->b4T) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								if (octree1->linkT == NULL) {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								else {
								obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
								octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
								}
								}

								maxbound++;
								*/
							}
							else {
								if (octree1->linkB3->inum_FD == 0) {


									G = BSIDE;
									// граничная грань:
									sosedi[G][maxelm].iNODE4 = maxelm_memo + maxbound; // граничные КО нумеруются в последнюю очередь,
									sosedi[G][maxelm].bdroblenie4 = true;
									// после maxelm_memo внутренних КО.
									// Вычисление дальнего соседа
									switch (G) {
									case ESIDE: GG = EE; break; // E
									case NSIDE: GG = NN; break; // NSIDE
									case TSIDE: GG = TTSIDE; break; // T
									case WSIDE: GG = WW; break; // W
									case SSIDE: GG = SS; break; // S
									case BSIDE: GG = BB; break; // B
									}

									sosedi[GG][maxelm].iNODE4 = -1; // сосед отсутствует,
									sosedi[GG][maxelm].bdroblenie4 = true;

#if doubleintprecision == 1
									//printf("error inum_FD == 0 sosedi B3 elm=%lld\n", maxelm);
#else
									//printf("error inum_FD == 0 sosedi B3 elm=%d\n", maxelm);
#endif
									
									//getchar();

									// Эта ситуация возможна и здесь надо предусмотреть её обработку.
									// В граничный узел сносятся свойства прилегающего КО:
									prop_b[RHO][maxbound] = prop[RHO][maxelm];
									prop_b[MU][maxbound] = prop[MU][maxelm];
									prop_b[BETA_T][maxbound] = prop[BETA_T][maxelm];


									// Sx*Sy
									doublereal dS_loc = fabs(octree1->linkB3->p7.y - octree1->linkB3->p4.y)*fabs(octree1->linkB3->p6.x - octree1->linkB3->p7.x);


									// G - грань по которой ставится граничное условие.
									// elm_id - номер конечного элемента, начиная с нуля для которго рассматривается граничный узел.
									// bound_id - номер граничного узла, начиная с нуля.
									// elm_id_inverse - это номер конечного элемента по другую сторону от границы для текущего элемента.
									if (octree1->b4T) {
										obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
											octree1->linkT4->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
									}
									else {
										if (octree1->linkT == NULL) {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												-1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
										else {
											obrabotka_granichnoi_grani(G, sosedb, nvtx, pa, maxelm, maxbound,
												octree1->linkT->inum_FD - 1, maxelm_memo, whot_is_block, ls, lw, w, s, b, dS_loc, false, false);
										}
									}

									maxbound++;
								}
								else {
									// сосед существует.
									if (bvisit[octree1->linkB3->inum_FD - 1]) {
										// узел уже был посещён
										// Здесь неким образом модифицировалось gran_t
										// Только внутренняя грань.
										G = BSIDE;
										// граничная грань:
										sosedi[G][maxelm].iNODE4 = octree1->linkB3->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
										sosedi[G][maxelm].bdroblenie4 = true;
										// после maxelm_memo внутренних КО.
										// Вычисление дальнего соседа
										switch (G) {
										case ESIDE: GG = EE; break; // E
										case NSIDE: GG = NN; break; // NSIDE
										case TSIDE: GG = TTSIDE; break; // T
										case WSIDE: GG = WW; break; // W
										case SSIDE: GG = SS; break; // S
										case BSIDE: GG = BB; break; // B
										}

										// Определение дальнего соседа :
										// TODO 13 сентября 2016.
									}
									else {
										// узнать координаты центра грани и ориентацию в пространстве
										x_c = 0.5*(octree1->linkB3->p4.x + octree1->linkB3->p5.x);
										y_c = 0.5*(octree1->linkB3->p4.y + octree1->linkB3->p7.y);
										z_c = octree1->p0.z;
										iplane = XY;
										patch_maxbound(iplane, s, ls, x_c, y_c, z_c, maxbound, binc4, lsid4);
										if (binc4) {
#if doubleintprecision == 1
											printf("error internal source B3 elm=%lld\n", maxelm);
#else
											printf("error internal source B3 elm=%d\n", maxelm);
#endif
											
											//getchar();
											system("PAUSE");
										}
										else {
											// Только внутренняя грань.
											G = BSIDE;
											// граничная грань:
											sosedi[G][maxelm].iNODE4 = octree1->linkB3->inum_FD - 1; // граничные КО нумеруются в последнюю очередь,
											sosedi[G][maxelm].bdroblenie4 = true;
											// после maxelm_memo внутренних КО.
											// Вычисление дальнего соседа
											switch (G) {
											case ESIDE: GG = EE; break; // E
											case NSIDE: GG = NN; break; // NSIDE
											case TSIDE: GG = TTSIDE; break; // T
											case WSIDE: GG = WW; break; // W
											case SSIDE: GG = SS; break; // S
											case BSIDE: GG = BB; break; // B
											}

											// Определение дальнего соседа :
											// TODO 13 сентября 2016.
										}
									}
								}
							}
						}
					}


					bvisit[maxelm] = true; // Узел был посещён.
					maxelm++;
				}
				//octree1->inum_FD = 0; // По умолчанию не принадлежит расчётной области.
				octree1 = NULL;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = NULL;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != NULL) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//getchar();
	}

	delete[] bvisit;
	bvisit = NULL;
} // constr_sosedi_prop_b_flow_alice

#endif