unit VisualUnit;
// визуализатор для трёхмерных тепловых расчётов
// распространяется на условиях FreeBSD подобной лицензии.

// файл dglOpenGL должен лежать в Borland Delphi7 Lib.
// Embarcadero Studio 16.0 lib / win32 (win64) / release (debug)
// Если этого не помогло то положить модуль в папку с исходным кодом даной программ.

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, ExtCtrls, ComCtrls, Buttons, ImgList, Menus, ExtDlgs, ShellAPI,
  dglOpenGL, DGLUT, System.ImageList, Vcl.Imaging.pngimage;

type

 // Для графической визуализации тепловых полей.
 telmpic = record
      i1, i2, i3, i4, i5, i6, i7, i8 : Integer;
 end;

 // координаты точки в 3D
 Pointxy = record
    x,y,z : GLfloat;
 end;

  // структура необходимая для умной каркасной визуализации :
  Visible_Line = record
     normal : Char; // 'X', 'Y', 'Z'
     xS, xE, yS, yE, zS, zE : Single;
  end;

  // В этой структуре хранятся признаки задания особых
  // граничных условий для каждой из шести сторон кабинета.
  Cabinet_out_boundary_condition = record
     bminX, bmaxX, bminY, bmaxY, bminZ, bmaxZ : Boolean;
  end;

  // Структура хранящая размер параллелепипеда и его
  // положение в пространстве.
  GBody = record
    redcolor, greencolor, bluecolor, transparency : GLFloat; // цвет и прозрачность.
    dcol : TColor;
    // 0 - Прямоугольная призма, 1 - Цилиндр.
    igeometry_type : Integer;
    xS, yS, zS, xE, yE, zE, key : Real;
    // индикаторы прорисовки линий на верхней грани.
    zE_xE2xS, zE_yE2yS, zE_xS2xE, zE_yS2yE : Boolean;
    // индикаторы прорисовки линий на нижней грани.
    zS_yE2yS, zS_xE2xS, zS_yS2yE, zS_xS2xE : Boolean;
    // индикация прорисовки линий на WEST грани.
    xS_zE2zS, xS_yE2yS, xS_zS2zE, xS_yS2yE : Boolean;
    // индикация прорисовки линий на EAST грани.
    xE_zE2zS, xE_yE2yS, xE_zS2zE, xE_yS2yE : Boolean;
    // North
    yE_zS2zE, yE_xS2xE, yE_zE2zS, yE_xE2xS : Boolean;
    // Soush
    yS_xS2xE, yS_zS2zE, yS_xE2xS, yS_zE2zS : Boolean;
    // 20_02_2017 Поддержка цилиндров.
    // Цилиндр аппроксимируется ступеньками.
    // Поддержка цилиндров это задел на будущее.
    //xC, yC, zC, Hcyl, R_out_cyl, R_in_cyl : Real;
    // плоскость в которой лежит визуализируемая нижняя грань цилиндра :
    // 1 - XY, 2 - XZ, 3 - YZ
    //iPlane : word;
  end;

  VisibleGran = record
      flagvisit : Boolean;  // посещалась ли грань однократно.
      xc, yc, zc : GLFloat; // позиция центра грани
      redcolor, greencolor, bluecolor, transparency : GLFloat; // цвет и прозрачность.
      // плоскость в которой лежит визуализируемая грань :
      // 1 - XY, 2 - XZ, 3 - YZ
      iPlane : word;
      xS, yS, zS : GLFloat; // координаты плоской
      xE, yE, zE : GLFloat; // фигуры
      key : GLFloat; // ключ для сортировки.

      // индикаторы прорисовки линий на верхней грани.
      zE_xE2xS, zE_yE2yS, zE_xS2xE, zE_yS2yE : Boolean;
      // индикаторы прорисовки линий на нижней грани.
      zS_yE2yS, zS_xE2xS, zS_yS2yE, zS_xS2xE : Boolean;
      // индикация прорисовки линий на WEST грани.
      xS_zE2zS, xS_yE2yS, xS_zS2zE, xS_yS2yE : Boolean;
      // индикация прорисовки линий на EAST грани.
      xE_zE2zS, xE_yE2yS, xE_zS2zE, xE_yS2yE : Boolean;
      // North
      yE_zS2zE, yE_xS2xE, yE_zE2zS, yE_xE2xS : Boolean;
      // Soush
      yS_xS2xE, yS_zS2zE, yS_xE2xS, yS_zE2zS : Boolean;

      start_on : Boolean; // true - xS or yS or zS. false - xE or yE or zE. 

  end;
       
  // трёхмерное тело
  TBody = record
     redcolor, greencolor, bluecolor, transparency : GLFloat; // цвет и прозрачность.
     BodyLineWidth : Integer;// толщина линии
     dcol : TColor;
     xS, yS, zS : Real; // координаты прямоугольной
     xE, yE, zE : Real; // области
     // Вспомогательные данные для ускорения графической визуализации.
     // Данные хранятся кратковременно только в момент работы функции ReadyPaint2
     ixS, iyS, izS : Integer; // координаты прямоугольной
     ixE, iyE, izE : Integer; // области
     sxS, syS, szS : String; // параметризованные координаты прямоугольной
     sxE, syE, szE : String; // области заданные пользователем
     // 0 - Прямоугольная призма, 1 - Цилиндр, 2 - Полигон.
     // Под объектом 2 - понимается полигон в более общем смысле.
     igeometry_type : Integer;
     // 20_02_2017 Поддержка цилиндров.
     // Цилиндр аппроксимируется ступеньками.
     // 06.09.2019 Цилиндры полностью поддерживаются.
     xC, yC, zC, Hcyl, R_out_cyl, R_in_cyl : Real;
     sxC, syC, szC, sHcyl, sR_out_cyl, sR_in_cyl : String;
     bCylinder2Prism : Boolean; // По умолчанию предусмотреть true,
     // т.е. преобразовываем если стоит соответствующая галочка при запуске солвера.

     // плоскость в которой лежит визуализируемая нижняя грань цилиндра :
     // 1 - XY, 2 - XZ, 3 - YZ
     iPlane : word;
     // 23_02_2017 Поддержка усечённого конуса:
     R_out_cyl2, R_in_cyl2 : Real;
     // Поддержка сектора на произвольный угол:
     angle_start, angle_end : Real; // В градусах.
     sR_out_cyl2, sR_in_cyl2, sangle_start, sangle_end : String;
     // 12_08_2017 Поддержка полигонов.
     xi, yi, zi, hi : array of Real;
     nsizei : Integer; // Количество точек в полигоне.
     // плоскость в которой лежит визуализируемая нижняя грань Полигона :
     // 1 - XY, 2 - XZ, 3 - YZ
     iPlane_obj2 : word;


     name : string; // имя объекта
     // Излучательные способности на гранях.
     emissW, emissE, emissS, emissN, emissB, emissT : Real;
     semissW, semissE, semissS, semissN, semissB, semissT : String;
     // Брать ли данный блок в качестве вакуумного промежутка:
     // 1 - да, 0 - нет.
     binternalRadiation : Integer;
     // Для кабинета также доступен тип HOLLOW который эмулируется
     // размером кабинета по размерам всех объектов в модели.
     // А при сохранении для солвера после кабинета пишется HOLLOW блок с размерами кабинета.
     //  Плюс при этом игнорируются все стенки привязанные к размерам кабинета.
     itype : Integer; // SOLID 1, HOLLOW 2, FLUID 3.
     //power : Real; // мощность тепловыделения  блока
     //spower : String; // параметризованная мощность тепловыделения внутри блока.
     n_power : Integer;
     temp_power, arr_power : array of Real;
     arr_s_power : array of String;
     // Зависимость мощности тепловыделения от времени.
     // 0 - не зависит от времени и выделяется постоянно,
     // 1 - squre wave зависимость от времени,
     // 2 - square wave 2 зависимость от времени,
     // 3 - hot cold режим для Евдокимовой Н.Л.
     // В случае зависимости от времени Square Wave 2
     // тепловыделение происходит на полную (multiplyer=1.0 для tau1 и tau2)
     // в моменты tau1 и tau2, а в остальные моменты нету тепловыделения.
     ipower_time_depend : Integer;
     iunion : Integer; // номер union`a которому принадлежит если 0 значит самый высокий уровень на уровне кабинета
     bvisible : Boolean; // видимость элемента

     imatid : Integer;  // уникальный номер в списке рабочих материалов

     // блок со старшим приоритетом в области
     // перекрытия перекрывает блок с младшим приоритетом.
     priority : Integer; // приоритет.
     // индекс priority не сохраняется явно в файл.
     // при считывании из файла блоки идут в определённом порядке,
     // в этом порядке им и назначается приоритет.
     // у кабинета приоритет всегда отрицательный, а у блоков строго положительный.

     // Фиксировать ли боковые стенки цилиндра или нет.
     // Для механических задач.
     CylinderFixed : Boolean;
  end;

  // Объединение
  TMyAssembles = record
      name : string; // имя объекта
      identifire : Integer; // идентификатор объединения.
      bVisible : Boolean; // видимость приписываемая всем элементам входящим в данное объединение.

      // Многоуровневые юнионы.
      iunionparent : Integer; // родительский юнион : -1 - кабинет, 0..lu-1 - другие юнионы.

      // Значения для блочно - структурированных сеток.
      bmesh_assembles_separately : Boolean; // нужно ли вводить индивидуальную сетку для данного юниона или нет.
      xmin, xmax, ymin, ymax, zmin, zmax : Real; // На сколько отстоит граница асемблеса от границ внутренних объектов.
      sxmin, sxmax, symin, symax, szmin, szmax : String; // параметризованные границы юниона, на сколько он отстоит от границ внутрених объектов.
      inxloc, inyloc, inzloc : Integer; // сеточное разбиение внутри юниона.

  end;

  TMYMat = record
     // Ниже приведено всё относящееся к свойствам материала:
     namemat : string; // имя материала
     rho, beta_t: Real; // тепловые свойства блока
     //lambda : Real;
     n_lam : Integer;
     temp_lam, arr_lam : array of Real;
     //cp : Real;
     n_cp : Integer;
     temp_cp, arr_cp : array of Real;
     // Ортотропность теплопроводности.
     mult_lam_x,  mult_lam_y, mult_lam_z : Real;
     bBoussinesq : Integer; // 0 - false, 1 - true;
     blibmat : Integer; // 1 - использовать внутрипрограммный библиотечный материал
     // 0 - использовать материал заданный пользователем.
     ilibident : Integer; // идентификатор билиотечного материала.
     // Динамическая вязкость
     mu : Real; // постоянное значение динамической вязкости для Ньютоновской жидкости
     // ilawmu :
     // 0 - const value
     // для псевдопластических неньютоновских материалов.
     // 1 - закон Оствальда-де Вела
     // 2 - Кессона
     // 3 - Прандтля
     // 4 - Carreau
     // 5 - Пауэлл-Эйринг
     // 6 - Уильямсон
     ilawmu : Integer; // номер закона для зависимости вязкости от скорости деформаций
     // Ограничители динамической вязкости (минимальное и максимальное значения)
     mumin, mumax : Real;
     // константы для законов предложенных выше
     Amu, Bmu, Cmu : Real;
     degreennmu : Real; // показатель степени в законе для не Ньютоновской жидкости
     // Thermal - Stress
     n_Poisson_ratio, n_Young_Module : Integer;
     // Ортотропность коэффициента линейного теплового расширения.
     mult_Linear_expansion_coefficient_x,  mult_Linear_expansion_coefficient_y, mult_Linear_expansion_coefficient_z : Real;
     mult_Young_Module_x, mult_Young_Module_y, mult_Young_Module_z : Real;
     mult_Poisson_ratio_xy,  mult_Poisson_ratio_xz, mult_Poisson_ratio_yz : Real;
     mult_Poisson_ratio_yx,  mult_Poisson_ratio_zx, mult_Poisson_ratio_zy : Real;
     // Модуль сдвига GPa.
     bShearModuleActive : Boolean;
     ShearModuleGxy, ShearModuleGyz, ShearModuleGxz : Real; // GPa
     temp_Poisson_ratio, temp_Young_Module : array of Real;
     arr_Poisson_ratio, arr_Young_Module : array of Real;
     n_Linear_expansion_coefficient  : Integer;
     temp_Linear_expansion_coefficient, arr_Linear_expansion_coefficient : array of Real;
  end;

  // либо источник тепла либо стенка  (идеальный теплоотвод или
  // граничное условие 2 или 3 рода)
  // В задачах гидродинамики это может быть место входа жидкости
  // в расчётную область, место выхода жидкости из расчётной области
  // или это может быть например граница с условиями симметрии, ну и
  // конечно же твёрдая стенка.
  TPlane = record
      // плоскость в которой лежит источник тепла :
      // 1 - XY, 2 - XZ, 3 - YZ
      iPlane : word;
      xS, yS, zS : Real; // координаты плоской
      xE, yE, zE : Real; // фигуры
      sxS, syS, szS : String; // параметризованные координаты прямоугольной
      sxE, syE, szE : String; // области заданные пользователем
      name : string; // имя источника
      // 0 - геометрические размеры задаются и редактируются пользователем.
      // от 1 до 6 : геометрические размеры определяются размерами кабинета и
      // автоматическим образом изменяются при изменении размеров кабинета.
      // 1 - minX, 2- maxX, 3 - minY, 4-maxY, 5-minZ, 6-maxZ.
      cabinet_depend : Integer;
      // параметры для источника тепла
      Power : Real; // мощность тепловыделения
      spower : String; // параметризованная пользователем мощность тепловыделения
      itempdep : Integer; // 0 const, 1 table.
      id_table : Integer; // номер таблицы
      operatingoffsetdrain : Real; // значение смещения стока.
      soperatingoffsetdrain : String; // параметризованное значение.
      ViewFactor : Real; // Фактор видимости. (Коэффициент уменьшения площади излучающей поверхности).
      emissivity : Real; // излучательная способность.
      heat_transfer_coefficient : Real; // коэффициент теплоотдачи.
      // параметризация 12 марта 2017.
      semissivity, sheat_transfer_coefficient : String;
      // параметры для стенок
      family : word; // тип краевого условия
      // family = 1 изотермическая стенка.
      Tamb : Real; // температура
      HF : Real; // тепловой поток
      // граничное условие 3 рода
      // заётся используя оба этих параметра.
      Vx, Vy, Vz, P : Real; // гидродинамические условия на стенке
      // Специально для задач моделирования естественной конвекции создано специальное
      // граничное условие bopening=true. 27.07.2016.
      // bopening=true это однородное условие Неймана на все компоненты скорости и на поправку давления.
      bpressure, bsymmetry, bopening : Boolean; // выходная граница или граница симметрии
      iunion : Integer; // номер union`a которому принадлежит если 0 значит самый высокий уровень на уровне кабинета
      bvisible : Boolean; // видимость элемента
      // Thermal - Stress  Boundary condition.
      // 0 - free,
      // 1 - x fixit,
      // 2 - y fixit,
      // 3 - z fixit,
      // 4 - xy fixit,
      // 5 - xz fixit,
      // 6 - yz fixit,
      // 7 - fixit all,
      // Значение большее 7 означает что задан вектор силы с тремя компонентами.
      // 8 - xForce,
      // 9 - yForce,
      // 10 - zForce.
      ithermal_stress_boundary_condition : Integer;
      xForce, yForce, zForce : Real; // Приложенный вектор сил.
  end;

  // библиотека твёрдых материалов
  TLibMatSolid = record
     name : String; // название материала
     rho : Real; // плотность
     cp : Real; // удельная теплоёмкость при постоянном давлении
     lam : Real; // теплопроводность
     // Ортотропность теплопроводности.
     mult_lam_x,  mult_lam_y, mult_lam_z : Real;
     Poisson_ratio, Young_Module, Linear_expansion_coefficient : Real;
  end;

  // библиотека жидких материалов
  TLibMatFluid = record
     // Осторожно реальные свойства газов
     // и жидкостей сильно зависят от температуры,
     // поэтому данные значения лишь опорные
     // верные при одной температуре.
     name : String; // название материала
     rho : Real; // плотность
     cp : Real; // удельная теплоёмкость при постоянном давлении
     lam : Real; // теплопроводность
     // Ортотропность теплопроводности.
     mult_lam_x,  mult_lam_y, mult_lam_z : Real;
     mu : Real;
     beta_t : Real;
  end;

  // Система уравнений гидродинамики:
  // В одной Fluid Domain (жидкой области).
  TmyFLUIDmodel = record
      // опорная точка в жидкости
      xc : Real;
      yc : Real;
      zc : Real;
      // считать ли поле течения
      iflow : Integer; // 0 - не считать, 1 - расчитать.
      iflowregime : Integer; // 0 - Ламинарный, 1 - Турбулентный.
      // 0 - Zero Equation Model (ZEM). (RANS)
      // 1 - Smagorinsky Model (LES) (в неё как опция включена динамическая модель Германо [1991])
      // 2 - RNG (LES)
      // 3 - Spalart Allmares (RANS)
      // 4 - K - Omega SST Menter (RANS)
      // 5 - Standart K-Epsilon (RANS)
      // 6 - модель лапминарно турбулентного перехода Ментора Лантгрии (RANS).
      iturbmodel : Integer; // выбор модели турбулентности
      // Параметры модели Смагоринского.
      SmagConst : Real; // константа Смагоринского.
      // использовать ли для определения константы Смагоринского динамическую модель.
      iDynamicStressGermano : Integer; // 0 - не использовать, 1 - использовать.
      // использовать ли ограничения на константу Смагоринского сверху и снизу.
      iLimitersCs : Integer; // 0 - не использовать, 1 - использовать.
      minCs, maxCs : Real; // минимаксные ограничители константы Смагоринского.
      itypeFiltrGermano : Integer; // тип фильтра в модели Германо.
      roughness : Real; // шероховатость твёрдой стенки.
      ipowerroughness : Integer; // показатель степени в модели учёта шероховатости.
      bfdelta : Boolean; // поправочный коэффициент связанный с неравномерностью сетки
      bSmagorinsky_Lilly : Boolean; // активирует модель Смагоринского-Лиллу.
      bsurface_roughness : Boolean; // активирует учёт шероховатости стенки.
      bSwirlamendment : Boolean; // поправка для течений с кривизной линий тока.
      rRimult : Real; // домножающий коэффициент подправляющий число Ричардсона для течений с кривизной линий тока.
      // избирательная модель Смагоринского.
      // турбулентная вязкость добавляется только в те области
      // где угол между вихрем и осреднённым вихрем  больше 15 градусов.
      bSelectiveSmagorinsky : Boolean;
      rSelectiveAngle : Real; // пороговое значение угла отсева.
      itypefiltr : Integer; // тип фильтра который используется для осреднения.
  end;

  // система уравнений в глобальной расчётной области
  TmyEGD = record
     itemper : Integer; // 0 - не считать температуру,
     // 1 - рассчитать температуру методом контрольного объема,
     // 2 - рассчитать температуру методом конечных элементов,
     // 3 - рассчитать температуру графовым методом решения.
     iStaticStructural : Integer; // 0 - не считать Static Structural, 1 - Считать Static Structural.
     imaxflD : Integer; // максимальное число не пересекающихся по жидкости жидких зон.
     myflmod : array of TmyFLUIDmodel; // система уравнений в каждой жидкой зоне.
  end;

  TmyVariable = record
     svar : String;  // имя переменной
     sval : String;  // значение переменной
  end;

  // Термоциклирование 23.07.2016.
  TTimeStepLaw = record
    id_law : Integer; // 0 - Linear, 1 - Square Wave, 2 - Square Wave Apparat, 3 - Double Linear.
    Factor_a_for_Linear : Real; // default 0.4
    tau : Real; // длительность импульса для Square Wave.
    iQ : Real; // Скважность для Square Wave.
    // Импульсный режим для аппарата.
    //                                  T
    //                         tau_pause , T - n X (2xtau1+tau2+tau_pause)
    //         _____  Power
    //    ____|     |____  m1*Power            _____|
    //  _|               |______ 0 ___________|
    //    tau1  tau2 tau1
    tau1, tau2, tau_pause, T, off_multiplyer : Real;
    m1 : Real;
    n : Integer;
    // double linear hot cold time law
    //------| on
    //      |_____________ off
    //
    on_time_double_linear : Real;
  end;

  TLaplas = class(TForm)
    MainPanel: TPanel;
    // дерево элементов
    MainTreeView: TTreeView;
    // окно консольных сообщений для диалога с пользователем
    MainMemo: TMemo;
    // увеличивает изображение
    Bzoomp: TSpeedButton;
    // уменьшает изображение
    Bzoomm: TSpeedButton;
    // добавляет блок
    SPBAddBlock: TSpeedButton;
    // Добавляет источник тепла:
    DaddSource: TSpeedButton;
    // список картинок для интерфейса пользователя
    MainImageList: TImageList;
    // меню пользователя:
    MainMenu1: TMainMenu;
    // меню File для опрации с файлами:
    File1: TMenuItem;
    // записывает данные в текстовый файл
    write1: TMenuItem;
    // считывает данные из текстового файла
    read1: TMenuItem;
    CreateImagefile1: TMenuItem;
    // для диалога открытия файла
    OpenDialog1: TOpenDialog;
    SBwall: TSpeedButton;
    SpeedButtonDel: TSpeedButton;
    // операция копирования элементов
    SpeedButtonCopy: TSpeedButton;
    SpeedButtonUnion: TSpeedButton;
    Grid1: TMenuItem;
    Define1: TMenuItem;
    Models1: TMenuItem;
    // задаёт параметры расчётной сетки
    Mesh1: TMenuItem;
    // форма задания параметризации модели
    Variables1: TMenuItem;
    // глобальное меню солвера
    Solve1: TMenuItem;
    // настройки решающего устройства
    Settings1: TMenuItem;
    // записывает файл premeshin.txt и вызывает солвер
    RunSolution1: TMenuItem;
    guiClose1: TMenuItem;
    pnliso: TPanel;
    lblview: TLabel;
    cbbview: TComboBox;
    lblvalue: TLabel;
    edtvalue: TEdit;
    btnapply: TButton;
    Panelorient: TPanel;
    SpeedButtonplaneneg_Z: TSpeedButton;
    SpeedButtonisogeom: TSpeedButton;
    SpeedButtonplanepos_Y: TSpeedButton;
    SpeedButtonplaneneg_X: TSpeedButton;
    Labellength: TLabel;
    ComboBoxlength: TComboBox;
    btndxf: TButton; // экспорт в dxf
    Post1: TMenuItem;
    Convergenceplot1: TMenuItem;
    pnlPaint: TPanel;
    rgview: TRadioGroup;
    btnimage: TSpeedButton;
    guiClose2: TMenuItem;
    SpeedButton1: TSpeedButton;
    GroupBoxLight: TGroupBox;
    ButtonLightsApply: TButton;
    CheckBoxPointSources: TCheckBox;
    CheckBoxOnLitht: TCheckBox;
    CheckBoxdistance: TCheckBox;
    Editmr: TEdit;
    Lmr: TLabel;
    Editmatt: TEdit;
    Lmatt: TLabel;
    LabelLithtprop: TLabel;
    Label3: TLabel;
    EditLamb0: TEdit;
    Labeldifuse: TLabel;
    EditLdifuse: TEdit;
    Labelspecularlitht: TLabel;
    EditSpecularL: TEdit;
    Label4: TLabel;
    Editangle: TEdit;
    Labelexp: TLabel;
    Editexponent: TEdit;
    Label5: TLabel;
    EditX: TEdit;
    EditY: TEdit;
    LabelY: TLabel;
    Label6: TLabel;
    Label7: TLabel;
    btnMaterial: TButton;
    grpmaterial_litht_prop: TGroupBox;
    lblamb: TLabel;
    lbl1: TLabel;
    lbl2: TLabel;
    lbldiff: TLabel;
    chksmooter: TCheckBox;
    chkGlobalAmbient: TCheckBox;
    edtamb: TEdit;
    edtambmat: TEdit;
    edtdiffmat: TEdit;
    chkSpecular: TCheckBox;
    edtSpec: TEdit;
    chkemis: TCheckBox;
    edtEmis: TEdit;
    chkblick: TCheckBox;
    edtblick: TEdit;
    btnreturnlight0: TButton;
    btnApplayMat: TButton;
    grplitht1: TGroupBox;
    btnLight1: TButton;
    chkOnLitht1: TCheckBox;
    chkDiskretSource1: TCheckBox;
    lbl3: TLabel;
    lbl4: TLabel;
    edtX1: TEdit;
    lbl5: TLabel;
    edtY1: TEdit;
    lbl6: TLabel;
    lbl7: TLabel;
    edtangle1: TEdit;
    lbl8: TLabel;
    edtexponent1: TEdit;
    chkdistance1: TCheckBox;
    lblmr1: TLabel;
    edtmr1: TEdit;
    lblmatt1: TLabel;
    edtmatt1: TEdit;
    lbl9: TLabel;
    lbl10: TLabel;
    edtLAmb1: TEdit;
    lblLdiffuse1: TLabel;
    edtdifuse1: TEdit;
    lblSpecular1: TLabel;
    edtSpecularLight1: TEdit;
    btnApplayLight1: TButton;
    btnreturnLight1: TButton;
    BitBtnScale_to_fit: TBitBtn;
    LoadSolution1: TMenuItem;
    HistoryPlot1: TMenuItem;
    Loadreport1: TMenuItem;
    BitBtn2: TBitBtn;
    BitBtnVisibleTecplot360: TBitBtn;
    ScrollBar1: TScrollBar;
    SpeedButtonplanepos_Z: TSpeedButton;
    SpeedButtonplaneneg_Y: TSpeedButton;
    SpeedButtonplanepos_X: TSpeedButton;
    btnrotate: TSpeedButton;
    Orient1: TMenuItem;
    Homeposition1: TMenuItem;
    Isometricview1: TMenuItem;
    OrientpositiveX1: TMenuItem;
    OrientnegativeX1: TMenuItem;
    OrientpositiveY1: TMenuItem;
    OrientnegativeY1: TMenuItem;
    Orientpositivez1: TMenuItem;
    OrientnegativeZ1: TMenuItem;
    Scaletofit1: TMenuItem;
    Initialization1: TMenuItem;
    ComboBoxVisibleVariable: TComboBox;
    Panel_shkala: TPanel;
    Image1: TImage;
    LabelTitle: TLabel;
    LabelShcala1: TLabel;
    LabelShcala2: TLabel;
    LabelShcala3: TLabel;
    LabelShcala4: TLabel;
    LabelShcala5: TLabel;
    LabelShcala6: TLabel;
    LabelShcala7: TLabel;
    LabelShcala8: TLabel;
    LabelShcala9: TLabel;
    XYPlot1: TMenuItem;
    CheckBoxSystemCoordinat: TCheckBox;
    GroupBoxMoveObject: TGroupBox;
    ButtonMoveObjectClose: TButton;
    ButtonApply: TButton;
    CheckBoxMoveallObject: TCheckBox;
    ComboBoxdirectionalmove: TComboBox;
    Label1: TLabel;
    EditstepMoveDirectional: TEdit;
    LabelstepMoveDirectional: TLabel;
    import1: TMenuItem;
    CheckBoxrotation: TCheckBox;
    GroupBoxVisualizationManagment: TGroupBox;
    ComboBoxdirectional: TComboBox;
    Label2: TLabel;
    Label8: TLabel;
    Label9: TLabel;
    Editminimum: TEdit;
    Editmaximum: TEdit;
    ButtonApplyVisualizationManagment: TButton;
    Labelunits1: TLabel;
    Labelunits2: TLabel;
    LoadSolutionID: TSpeedButton;
    BitBtnMove: TBitBtn;
    SpeedButtonVisualizationMabagement: TSpeedButton;
    Check1: TMenuItem;
    Setting1: TMenuItem;
    ComboBoxplaneViewSelect: TComboBox;
    Scale1: TMenuItem;
    Labeldopusk: TLabel;
    Editdopusk: TEdit;
    Editdopusk2: TEdit;
    ComboBoxlineWidth: TComboBox;
    RedoSourceforPattern: TBitBtn;
    OpenDialog2: TOpenDialog;
    SaveDialog1: TSaveDialog;
    ViewFactorCalculator: TMenuItem;
    Debug1: TMenuItem;
    Parameters1: TMenuItem;
    Runoptimization1: TMenuItem;
    XYPlot2: TMenuItem;
    BitBtn1: TBitBtn;
    // Вызывается при создании формы
    procedure FormCreate(Sender: TObject);
    // увеличение иображения
    procedure BzoompClick(Sender: TObject);
    // уменьшение изображения
    procedure BzoommClick(Sender: TObject);
    // по нажатию на кнопку добавляется блок
    procedure SPBAddBlockClick(Sender: TObject);
    // добавляет источник тепла
    procedure DaddSourceClick(Sender: TObject);
    // выравнивание картинки по плоскости XOY
    procedure SpeedButtonplaneneg_ZClick(Sender: TObject);
    // закрывает приложение
    procedure CreateImagefile1Click(Sender: TObject);
    // записывает информацию в текстовый файл
    procedure write1Click(Sender: TObject);
    // считывает информацию из текстового файла
    procedure read1Click(Sender: TObject);
    // устанавливает изометрию для изображения
    procedure SpeedButtonisogeomClick(Sender: TObject);
    // колёсико движется вниз уменьшение изображения
    procedure FormMouseWheelDown(Sender: TObject; Shift: TShiftState;
      MousePos: TPoint; var Handled: Boolean);
    // колёсико движется вверх увеличение изображения
    procedure FormMouseWheelUp(Sender: TObject; Shift: TShiftState;
      MousePos: TPoint; var Handled: Boolean);
      // изменение размеров формы
    procedure FormResize(Sender: TObject);
    // создаёт новую стенку
    procedure SBwallClick(Sender: TObject);
    // выполнен двойной щелчёк мышью по элементу на дереве
    procedure MainTreeViewDblClick(Sender: TObject);
    // удаление объекта
    procedure SpeedButtonDelClick(Sender: TObject);
    // создаёт копии элементов
    procedure SpeedButtonCopyClick(Sender: TObject);
    // показывает плоскоость XZ
    procedure SpeedButtonplanepos_YClick(Sender: TObject);
    // показывает плоскость YZ
    procedure SpeedButtonplaneneg_XClick(Sender: TObject);
    // создаёт объединение
    procedure SpeedButtonUnionClick(Sender: TObject);
    // задаёт параметры расчётной сетки
    procedure Mesh1Click(Sender: TObject);
    // задаёт силу тяжести
   // procedure Gravity1Click(Sender: TObject);
    // задаёт или редактирует переменные проекта
    procedure Variables1Click(Sender: TObject);
    // запичывает файл premeshin.txt
    procedure RunSolution1Click(Sender: TObject);
    // Удалил PowerTable1 11.08.2019
    // procedure PowerTable1Click(Sender: TObject);
    procedure MainTreeViewClick(Sender: TObject);
    procedure guiPrintClick(Sender: TObject);
    procedure MainTreeViewMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure btnrotateClick(Sender: TObject);
    procedure cbbviewChange(Sender: TObject);
    procedure btnapplyClick(Sender: TObject);
    // Экспортирование данных в программу SYMMIC.
   // procedure ExportSYMMIC1Click(Sender: TObject);
    procedure btndxfClick(Sender: TObject);  // экспорт в программу dxf
    procedure Convergenceplot1Click(Sender: TObject);
    // Закрытие формы.
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure pnlPaintMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure pnlPaintMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure pnlPaintMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure rgviewClick(Sender: TObject);
    procedure Settings1Click(Sender: TObject);
    procedure btnimageClick(Sender: TObject);
    procedure guiClose2Click(Sender: TObject);
    procedure SpeedButton1Click(Sender: TObject);
    procedure CheckBoxOnLithtClick(Sender: TObject);
    procedure ButtonLightsApplyClick(Sender: TObject);
    procedure btnMaterialClick(Sender: TObject);
    procedure btnreturnlight0Click(Sender: TObject);
    procedure btnApplayMatClick(Sender: TObject);
    procedure btnLight1Click(Sender: TObject);
    procedure btnreturnLight1Click(Sender: TObject);
    procedure btnApplayLight1Click(Sender: TObject);
    procedure BitBtnScale_to_fitClick(Sender: TObject);
    procedure LoadSolution1Click(Sender: TObject);
    procedure HistoryPlot1Click(Sender: TObject);
    procedure Loadreport1Click(Sender: TObject);
    procedure BitBtn2Click(Sender: TObject);
    procedure BitBtnVisibleTecplot360Click(Sender: TObject);
    procedure ScrollBar1Scroll(Sender: TObject; ScrollCode: TScrollCode;
      var ScrollPos: Integer);
    procedure SpeedButtonplanepos_ZClick(Sender: TObject);
    procedure SpeedButtonplaneneg_YClick(Sender: TObject);
    procedure SpeedButtonplanepos_XClick(Sender: TObject);
    procedure Isometricview1Click(Sender: TObject);
    procedure OrientpositiveX1Click(Sender: TObject);
    procedure OrientnegativeX1Click(Sender: TObject);
    procedure OrientpositiveY1Click(Sender: TObject);
    procedure OrientnegativeY1Click(Sender: TObject);
    procedure Orientpositivez1Click(Sender: TObject);
    procedure OrientnegativeZ1Click(Sender: TObject);
    procedure Homeposition1Click(Sender: TObject);
    procedure Scaletofit1Click(Sender: TObject);
    procedure Initialization1Click(Sender: TObject);
    procedure ComboBoxVisibleVariableChange(Sender: TObject);
    procedure XYPlot1Click(Sender: TObject);
    procedure ButtonMoveObjectCloseClick(Sender: TObject);
    procedure ButtonApplyClick(Sender: TObject);
    procedure BitBtnMoveClick(Sender: TObject);
    procedure import1Click(Sender: TObject);
    procedure CheckBoxrotationClick(Sender: TObject);
    procedure ButtonApplyVisualizationManagmentClick(Sender: TObject);
    procedure SpeedButtonVisualizationMabagementClick(Sender: TObject);
    procedure LoadSolutionIDClick(Sender: TObject);
    // Печатает простейшую статистику о модели
    procedure Check1Click(Sender: TObject);
    // задаёт набор уравнений для решения
    procedure Setting1Click(Sender: TObject);
    procedure Scale1Click(Sender: TObject);
    procedure RedoSourceforPatternClick(Sender: TObject);
    procedure ViewFactorCalculatorClick(Sender: TObject);
    procedure Parameters1Click(Sender: TObject);
    procedure Runoptimization1Click(Sender: TObject);
    procedure XYPlot2Click(Sender: TObject);
    procedure BitBtn1Click(Sender: TObject);


  private
    { Private declarations }

    // Считываем картинку из Техплот.
    npic, epic, nvalpic, icurrentpic : Integer;
    xminpic, xmaxpic, yminpic, ymaxpic, zminpic, zmaxpic : Real;
    risopic : Real;
    xpic, ypic, zpic : array of Real;
    ipa_count : array of Integer;
    bvisible_granq : array of array of Boolean;
    temppicpotent : array of array of Real;
    temppicname : array of String;
    minimumpic, maximumpic : array of Real;
    elmpic : array of telmpic;
    bvisiblepic, bvisiblepicdubl : Boolean;

    procedure SetupGL; // процедура инициализации.
    procedure Render; // процедура прорисовки.

    function GetSource(Index : integer) : TPlane;
    procedure SetSource(Index : integer; Value : TPlane);
    function GetWall(Index : integer) : TPlane;
    procedure SetWall(Index : integer; Value : TPlane);

  public
    { Public declarations }
    ecology_btn : Boolean;
    bon_rotate_polygon : Boolean;
    bonly_mesh_gen_call : Boolean; // Отдельный вызов сеточного генератора только.
    isleep_render : Integer;
    perspectiveangle_counter : Real;
    button_right_push : Boolean;
    Hscale : Real;

    priority_id : Integer; // приоритет.
    // Коэффициент теплоотдачи при решении СЛАУ
    // на основе краевой задачи с условиями 3-его рода.
    // Данное условие использует значение переменной operatingtemperature.
    filmcoefficient : Real;
    // emissivity global не существует теперь все значения задаются индивидуально на
    // сторонах каждого блока.
    // 0 - adiabatic, 1 -  Ньютон-Рихман.
    adiabatic_vs_heat_transfer_coeff : Integer;
    brun : Boolean; // запущено ли вычисление.
    icb, ics, icw : Integer; // Постоянно увеличивающиеся счётчики для формирования имён элементов.
    lb, itek : Integer; // всего кубиков и текущий обрабатываемый кубик
    body : array of TBody; // список тел
    ls : Integer; // всего источников тепла
    source : array of TPlane; // список источников тепла
    lw : Integer; // всего стенок
    wall : array of TPlane; // список стенок
    drawing : Boolean;
    Alf,Bet,Gam,R1,perspectiveangle,Gam0 : Real;  // углы поворота для визуализации
    cosAlf, cosBet, sinAlf, sinBet : Real;// Заранее вычисленные значения.
    m : Real; // масштабный коэффициент для визуализации
    mlength : Real; // для масштабирования реальных длин
    libsolid : array of TLibMatSolid;
    lmatsol : Integer;
    libfluid : array of TLibMatFluid;
    lmatfluid : Integer;
    workmat : array of TMYMat; // список рабочих материалов
    lmatmax : Integer; // количество рабочих материалов
    inum : Integer;   // число копий
    spdx, spdy, spdz : String; // параметризованное значение перемещения при копировании.
    bcontinuecopy : Boolean; // нужно ли осуществлять операцию копирования.
    Oxc, Oyc, Ozc : Real; // смещение начала системы координат в точку
    lu : Integer; // количество объединений
    myassembles : array of TMyAssembles; // список объединений
    ixo, iyo : Integer; // сдвигание картинки мышью
    inx, iny, inz : Integer; // количество узлов сетки по каждому из направлений
    etalon_max_size_ratio : Real; // подробность расчётной сетки.
    etalon_max_size_ratio2 : Real; // default 30 Второй критерий качества рапсчётной сетки.
    gx, gy, gz : Real; // сила тяжести
    operatingtemperature : Real; // опорная температура
    egddata : TmyEGD; // информация об уравнениях которые придётся решать.
    ivar : Integer; // количество переменных
    parametric : array of TmyVariable;
    iltdp : Integer; // integer length temperature depend power (количество уникальных таблично заданных зависимостей)
    listtablename : array of string; // список имен файлов (по одному файлу на каждую таблицу).
    breadfinish : Boolean; // считывание файла закончено
    blockgraphics : array of  GBody; // объекты подлежащие визуализации.
    vg : array of VisibleGran; // грани подлежащие визуализации.
    // Для моделирования освещения на основе OpenGL :
    glamb0, remis, rspec, matdiff, matamb : GLfloat; // параметры материала.
    matt, mr : GLfloat; // зависимость от расстояния для LIGHT0
    dopusk_gl1, dopusk_gl2 : GLfloat; // допуск для прорисовки Z буффером.
    lithtangle, lithtexponent, mldx, mldy : GLfloat; // LIGHT0
    lamb, lspec, ldiff : GLfloat; // параметры нулевой лампы.
    rblick : Integer;
    // Вторая лампа.
    lithtangle1, lithtexponent1, mldx1, mldy1 : GLfloat; // LIGHT1
    matt1, mr1 : GLfloat; // зависимость от расстояния для LIGHT1
    lamb1, lspec1, ldiff1 : GLfloat; // параметры нулевой лампы.
    glSTL : TTimeStepLaw; // законы изменения шагов по времени.
    // признаки существования особых граничных условий на стенках кабинета.
    cab_bound_condition : Cabinet_out_boundary_condition;
    inumber_package_load : Integer;
    bperenapravlenie_na_import : Boolean;
    bVisualization_Management_now : Boolean;
    bREALESEversion : Boolean;
    bOkTrials : Boolean;
    boptimetric : Boolean;
    id_0_index, id_1_index : Integer;

    // Каркасная модель не рисуется.
    procedure off_visible_karkas();
    // Каркасная модель рисуется.
    procedure on_visible_karkas();

    property sourcepublic[Index : integer] :  TPlane read GetSource write SetSource;
    property wallpublic[Index : integer] :  TPlane read GetWall write SetWall;

    function return_Perspective_angle(var rangle_counter : Real) : Real;
    procedure ColorToGL(c7 : TColor;var dcol7 : TColor; var R7, G7, B7 : GLFloat);
    procedure IdleHandler(Sender: TObject; var Done: Boolean);
    procedure ReadyPaint; // подготавливает данные к визуализации.
    procedure ReadyPaint1; // подготавливает данные к визуализации.
    procedure ReadyPaint2; // подготавливает данные к визуализации.
    // инициализация формы редактирования блока
    procedure initializeaddblockform;
    // инициализация формы редактирования источника тепла
    procedure InitializeAddSourceForm;
    // считывает параметры материала
    procedure myreadmaterial(var workmat : TMYMat; s : string);
    // считывает параметры для блока
    procedure myreadbody(var body : TBody; s : string);
    // считывает параметры для источника тепла
    procedure myreadsource(var source :  TPlane; s : string);
    // читает координаты плоского элемента
    procedure myreadplane(var plane : TPlane; s : string);
    // инициализация формы редактированния стенки
    procedure Initializeaddwallform;
    // Отображение дерева элементов.
    procedure TreeLoad(Sender: TObject);
    // считывает параметры твёрдой стенки
    procedure myReadWall(var wall : TPlane; s : string);
    // считывает информацию о жидкой зоне
    procedure myreadfluidzone(var myflmod : TmyFLUIDmodel; s : string);
    // проверка уникальности имени объекта
    function isduplicatenameobj(chidobj : Char; scandidate : string; iobjid : Integer): Boolean;
    // процедура корректировки имени объекта
    procedure correctobjname(chidobj : Char;var scandidate : string; iobjid : Integer);
    // преобразование оконных координат в сценовые.
    function  GetOGLPos( x : Integer;  y : Integer): Pointxy;
    // Если кабинет имеет тип Hollow то его геометрические размеры естественым образом
    // корректируются, чтобы соответствовать текущему размеру модели.
    procedure CorrectHollowCabinet;
    //   возвращает объем блока.
    function volume(b : Tbody) : Real;
    // Управление показом графики в плоскости.
    function if_visible_now(riso_loc : Real; start_loc : Real; end_loc : Real) : Boolean;
    procedure WriteStartSolutionNEW(Sender: TObject);
    procedure WriteStartSolutionOLD(Sender: TObject);

    procedure SerialExecute1;
    procedure SerialExecute2;
    procedure SerialExecute3;
  end;

  // Для теплопередачи в твёрдом теле.
  // Опишем класс TMyThread :
  TMyThread1 = class (TThread)
  private
     { Private declarations }
  protected
     procedure Execute; override;
  end;

  // Для гидродинамики.
  // Опишем класс TMyThread :
  TMyThread2 = class (TThread)
  private
     { Private declarations }
  protected
     procedure Execute; override;
  end;

  // Для гидродинамики совместно с теплопередачей.
  // Опишем класс TMyThread :
  TMyThread3 = class (TThread)
  private
     { Private declarations }
  protected
     procedure Execute; override;
  end;


const
NearClipping = 1; //ближняя плоскость отсечения
farClipping = 200000000; // 200000000; дальняя плоскость отсечения 100000

var
  Laplas: TLaplas;
  dc : HDC;  // контекст устройства.
  HRC: HGLRC;  // конекст рендеринга.
  // Введем переменную класса TMyThread
  MyThread1 : TMyThread1;
  MyThread2 : TMyThread2;
  MyThread3 : TMyThread3;


implementation
uses
     Printers, Math, CabinetUnit, addBlockUnit, AddSourceUnit, AddWallUnit, UnitCopy,
  UnitFormUnion, MeshUnit,  UnitEQGD, UnitVariables,
  UnitPowerList, jpeg, Unitaddinunion, UnitExportSYMMIC, Unitresidualplot,
  UnitParallelSetting, UnitTransientMenu, Unitresidual2, Unitwallinitposition,
  Unitamgmanager, UnitInitialization, UnitXYPlot, UnitRenameVariable, UnitScale,
  UnitAMGCLManager, Unitamg1r5Parameters, UnitresidualPlotSpallartAllmares,
  UnitResidualSATemp2, UnitResidualMenterSST, UnitResidualSSTTemperature,
  UnitResidualStandartKEpsilon, UnitResidualStandartK_Epsilon_TEMP,
  Unitpiecewiseconst, UnitPatternDelete, UnitTextNameSourcePattern,
  UnitTimedependpowerLaw, UnitViewFactors, Unit_debug,
  UnitUserDefinedSolidMaterial, UnitPlaneSelect, UnitResidual_Langtry_Menter,
  UnitResidual_Langtry_Menter_Temp, UnitOptimetric;
{$R *.dfm}


// Нужно создать процедуру Execute, уже описанную в классе TMyThread
procedure TMyThread1.Execute;
var
  // StartupInfo : TStartupInfo;
   //ProcessInfo : TProcessInformation;
   f, f2, f3 : TStringList;
   ShellInfo : TShellExecuteInfo;
   ExitCode : DWORD;
   QuoteParams : Boolean;
   i : Integer;
   starttime, endtime, deltatime : TTime;
      bodyname, sourcename, wallname : array of string;
      is_hollow : array of Boolean;
   lbclone, lsclone, lwclone : Integer;
   s7 : String;

begin
    // Serial
        // CreateProcess(nil,'test_pattern/solver/solid_static/AliceFlow_v0_07.exe',nil,nil,false,Create_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
        //     nil,nil,StartupInfo,ProcessInfo);

          // Надо сделать копию имён block, source и wall перед запуском.
        lbclone:=Laplas.lb;
        lsclone:=Laplas.ls;
        lwclone:=Laplas.lw;
        SetLength(bodyname,lbclone);
        SetLength(is_hollow,lbclone);
         for i:=0 to lbclone-1 do
         begin
           bodyname[i]:=Laplas.body[i].name;
           if (Laplas.body[i].itype=2) then
           begin
              // HOLLOW
              is_hollow[i]:=true;
           end
            else
           begin
              is_hollow[i]:=false;
           end;
         end;
         SetLength(sourcename,lsclone);
         for i:=0 to lsclone-1 do
         begin
            sourcename[i]:=Laplas.source[i].name;
         end;
         SetLength(wallname,lwclone);
          for i:=0 to lwclone-1 do
         begin
           wallname[i]:=Laplas.wall[i].name;
         end;

         starttime:=Now();

         if (not(Laplas.bonly_mesh_gen_call)) then
         begin
            if (FormUnsteady.RadioGroup1.ItemIndex=1) then
            begin
               // Нестационарное моделирование и мы формируем
               // наиполнейший отчёт о температурах всех объектов
               // из которых состоит расчётная модель.

               f2:=TStringList.Create();
               s7:='time ';
               for i:=0 to lbclone - 1 do
               begin
                  s7:=s7 + ' ' + bodyname[i] + '_tC ' + bodyname[i] + '_power';
               end;
               for i:=0 to lsclone - 1 do
               begin
                  s7:=s7 + ' ' + sourcename[i] + '_tC ' + sourcename[i] + '_power';
               end;
               for i:=0 to lwclone - 1 do
               begin
                  s7:=s7 + ' ' + wallname[i] + '_tC ' + wallname[i] + '_power';
               end;
               f2.Add(s7);
               f2.SaveToFile('report_temperature_unsteady.txt');
               f2.Clear;
               f2.Free;
            end;
        end
        else
        begin
           DeleteFile('report_temperature_unsteady.txt');
        end;


        ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        if (FormSetting.rgParallel.ItemIndex=0) then
        begin
        //if (FormUnsteady.RadioGroup1.ItemIndex=0) then
        //begin
           // модифицировано 23.07.2016.
           // Steady Calculation and  Unsteady Calculation
           //ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_30.exe"');
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x64\AliceFlow_v0_48.exe"');
        //end
        //else
        //begin
           // Unsteady Calculation
          // ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_26Unsteady.exe"');
        //end;
        end;
        if (FormSetting.rgParallel.ItemIndex=1) then
        begin
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x86\AliceFlow_v0_48.exe"');
        end;
        if (FormSetting.rgParallel.ItemIndex=2) then
        begin
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x64_float\AliceFlow_v0_48.exe"');
        end;
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;

        // удаляем ненужные файлы.
      DeleteFile('ALICEFLOW0_06_temp_part1.txt');
      DeleteFile('ALICEFLOW0_06_temp_part3.txt');



      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FileExists('report_temperature.txt')) then
         begin
            WinExec('notepad.exe report_temperature.txt',sw_ShowNormal);
         end;
         (*
         if (lbclone<300) then
         begin
            // Если будет больше 300 блоков то загружаться репорт
            // будет очень долго.
            if (FileExists('report_temperature.txt')) then
            begin
               f3:=TStringList.Create();
               f:=TStringList.Create();
               f.LoadFromFile('report_temperature.txt');
               //Laplas.MainMemo.Lines.Add(f.Strings[0]);
               f3.Add(f.Strings[0]);
               for i:=0 to lbclone-1 do
               begin
                  //Laplas.MainMemo.Lines.Add(f.Strings[i+1]);
                  f3.Add(f.Strings[i+1]);
               end;
               for i:=0 to lsclone-1 do
               begin
                  // Laplas.MainMemo.Lines.Add(f.Strings[i+lbclone+1]);
                  f3.Add(f.Strings[i+lbclone+1]);
               end;
               for i:=0 to lwclone-1 do
               begin
                  // Laplas.MainMemo.Lines.Add(f.Strings[i+lbclone+lsclone+1]);
                  f3.Add(f.Strings[i+lbclone+lsclone+1]);
               end;
               //DeleteFile('solver/solid_static/report_temperature.txt');
               // ускоренная загрузка репорта, чтобы не ждать.
               Laplas.MainMemo.Lines.AddStrings(f3);
               f.Clear;
               f.Free;
               f3.Clear;
               f3.Free;
             end
              else
             begin
                ShowMessage('file report_temperature.txt not found ');
                Laplas.MainMemo.Lines.Add('file report_temperature.txt not found ');
             end;
         end
          else
         begin
            Laplas.MainMemo.Lines.Add('report temperature do not load. lb>=300.');
            Laplas.MainMemo.Lines.Add('synopsis: very big file...');
         end;
         *)
      end;
      // Освобождение оперативной памяти.
      SetLength(wallname,0);
      SetLength(sourcename,0);
      SetLength(bodyname,0);
      SetLength(is_hollow,0);

      // В случае нестационарного моделирования записаны переходные характеристики.
      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FormUnsteady.RadioGroup1.ItemIndex=1) then
          begin
             if (FormUnsteady.ComboBoxTimeStep.ItemIndex=0) then
             begin
                // Linear Time Step Law. // была снята переходная характеристика.
                Laplas.MainMemo.Lines.Add('Evdokimova.txt report writing succsefull.');
                Laplas.MainMemo.Lines.Add('heating_curves.txt report writing succsefull.');
             end;
         end;
      end;
      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FileExists('report.txt')) then
         begin
            f:=TStringList.Create();
            f.LoadFromFile('report.txt');
            Laplas.MainMemo.Lines.Add(f.Strings[0]);
            DeleteFile('report.txt');
            f.Clear;
            f.Free;
         end;
      end;

       if (Laplas.bonly_mesh_gen_call) then
      begin
       // Время работы сеточного генератора.
         Laplas.MainMemo.Lines.Add('The meshing generation is completed.');
         endtime:=Now();
         deltatime:=endtime-starttime;
         Laplas.MainMemo.Lines.Add('Time meshing generation equals '+TimeToStr(deltatime));

      end
      else
      begin
       // Для оптимизационных задач продублируем время счёта.
         Laplas.MainMemo.Lines.Add('The calculation is completed.');
         endtime:=Now();
         deltatime:=endtime-starttime;
         Laplas.MainMemo.Lines.Add('Time calculation equals '+TimeToStr(deltatime));
      end;

      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FormUnsteady.RadioGroup1.ItemIndex=1) then
         begin
            // Запуск визуализации графика зависимости максимальной температуры в расчётной области
            // от времени.
            if (FileExists('GraphicsKras.exe')) then
            begin
               WinExec('GraphicsKras.exe',SW_SHOWNORMAL);
            end;
        end;
      end;


      if (Laplas.bVisualization_Management_now=true) then
      begin
          // вызов программы tecplot360
            // WinExec('C:/Program Files (x86)/Tecplot/Tec360 2008/bin/tec360.exe ALICEFlow0_07_Visualisation_Magement.PLT',SW_SHOWNORMAL);
            if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
            begin
               WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe ALICEFlow0_07_Visualisation_Magement.PLT'),SW_SHOWNORMAL);
            end
             else
            begin
               if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
               begin
                  WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe ALICEFlow0_07_Visualisation_Magement.PLT',SW_SHOWNORMAL);
               end
                else
               begin
                  if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
                  begin
                     WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe ALICEFlow0_07_Visualisation_Magement.PLT',SW_SHOWNORMAL);
                  end
                   else
                  begin
                     if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
                     begin
                        WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe ALICEFlow0_07_Visualisation_Magement.PLT',SW_SHOWNORMAL);
                     end
                      else
                     begin
                        if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                        begin
                           WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe ALICEFlow0_07_Visualisation_Magement.PLT',SW_SHOWNORMAL);
                        end
                         else
                        begin
                           Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 or 2017 unfound.');
                        end;
                     end;
                  end;
               end;
            end;
      end
      else
      begin
         if (Laplas.egddata.itemper=2) then
         begin
            // Был запущен метод конечных элементов.
            if (not(FormUnsteady.CheckBoxdonttec360.Checked))  then
            begin
               // вызов программы tecplot360
               // WinExec('C:/Program Files (x86)/Tecplot/Tec360 2008/bin/tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
               if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
               begin
                  WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe ALICEFLOW0_08_temp.PLT'),SW_SHOWNORMAL);
               end
                else
               begin
                  if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
                  begin
                     WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
                  end
                   else
                  begin
                     if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
                     begin
                        WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
                     end
                      else
                     begin
                        if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
                        begin
                           WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
                        end
                         else
                        begin
                           if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                           begin
                              WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
                           end
                            else
                           begin
                              Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 or 2017 unfound.');
                           end;
                        end;
                     end;
                  end;
               end;
            end;
         end
          else
         begin

            if (not(FormUnsteady.CheckBoxdonttec360.Checked))  then
            begin
               // вызов программы tecplot360
               // WinExec('C:/Program Files (x86)/Tecplot/Tec360 2008/bin/tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
               if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
               begin
                  WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT'),SW_SHOWNORMAL);
               end
                else
               begin
                  if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
                  begin
                     WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                  end
                   else
                  begin
                     if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
                     begin
                        WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                     end
                      else
                     begin
                        if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
                        begin
                           WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                        end
                         else
                        begin
                           if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                           begin
                              WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                           end
                            else
                           begin
                              Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 unfound.');
                           end;
                        end;
                     end;
                  end;
               end;
            end;
         end;
      end;

      // Стационарная постановка задачи.
      if (FormUnsteady.RadioGroup1.ItemIndex=0) then
      begin

         // Запускаем показ одномерного графика в техплот.
         // вызов программы tecplot360
         // WinExec('C:/Program Files (x86)/Tecplot/Tec360 2008/bin/tec360.exe xyplotT1.PLT',SW_SHOWNORMAL);
         if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
         begin
            WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe xyplotT1.PLT'),SW_SHOWNORMAL);
         end
          else
         begin
            if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
            begin
               WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe xyplotT1.PLT',SW_SHOWNORMAL);
            end
             else
            begin
               if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
               begin
                  WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe xyplotT1.PLT',SW_SHOWNORMAL);
               end
                else
               begin
                  if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
                  begin
                     WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe xyplotT1.PLT',SW_SHOWNORMAL);
                  end
                   else
                  begin
                     if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                     begin
                        WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe xyplotT1.PLT',SW_SHOWNORMAL);
                     end
                      else
                     begin
                        Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 unfound.');
                     end;
                  end;
               end;
            end;
         end;
      end;
      Laplas.bVisualization_Management_now:=false;

   Laplas.brun:=false;

    Laplas.bonly_mesh_gen_call:=false;
end;

 // Нужно создать процедуру Execute, уже описанную в классе TMyThread
procedure TMyThread2.Execute;
var
  // StartupInfo : TStartupInfo;
   //ProcessInfo : TProcessInformation;
   f, f3 : TStringList;
   ShellInfo : TShellExecuteInfo;
   ExitCode : DWORD;
   QuoteParams : Boolean;
   i : Integer;
   starttime, endtime, deltatime : TTime;
   bodyname, sourcename, wallname : array of string;
   is_hollow : array of boolean;
   lbclone, lsclone, lwclone : Integer;
   s,subx,sub : String; // текущая рабочая строка
   fmin, fmax : Real;

begin

        lbclone:=Laplas.lb;
        lsclone:=Laplas.ls;
        lwclone:=Laplas.lw;
         SetLength(bodyname,lbclone);
         SetLength(is_hollow,lbclone);
         for i:=0 to lbclone-1 do
         begin
           bodyname[i]:=Laplas.body[i].name;
           if (Laplas.body[i].itype=2) then
           begin
             // HOLLOW
             is_hollow[i]:=true;
           end
           else
           begin
              is_hollow[i]:=false;
           end;
         end;
         SetLength(sourcename,lsclone);
         for i:=0 to lsclone-1 do
         begin
            sourcename[i]:=Laplas.source[i].name;
         end;
         SetLength(wallname,lwclone);
          for i:=0 to lwclone-1 do
         begin
           wallname[i]:=Laplas.wall[i].name;
         end;

        starttime:=Now();



         // Запускает приложение и ждёт окончания его работы.
      //CreateProcess(nil,'test_pattern/solver/fluid_static/AliceFlow_v0_07.exe',nil,nil,false,Create_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
        //     nil,nil,StartupInfo,ProcessInfo);


        ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        if (FormSetting.rgParallel.ItemIndex=0) then
        begin
           // однопоточная версия.
           //ShellInfo.lpFile:=PChar('"test_pattern\solver\fluid_static\AliceFlow_v0_26.exe"');
           // 29.01.2017
           //ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_30.exe"');
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x64\AliceFlow_v0_48.exe"');
        end;
         if (FormSetting.rgParallel.ItemIndex=1) then
        begin
           // параллельные вычисления.
           // Устарело 29.01.2017
           //ShellInfo.lpFile:=PChar('"test_pattern\solver\fluid_static\AliceFlow_v0_07P.exe"');
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x86\AliceFlow_v0_48.exe"');
        end;
         if (FormSetting.rgParallel.ItemIndex=2) then
        begin
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x64_float\AliceFlow_v0_48.exe"');
        end;
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;

      //WaitforSingleObject(ProcessInfo.hProcess,INFINITE);

      // удаляем ненужные файлы.
      DeleteFile('ALICEFLOW0_06_temp_part1.txt');
      DeleteFile('ALICEFLOW0_06_temp_part3.txt');




      endtime:=Now();
      deltatime:=endtime-starttime;
      if (Laplas.bonly_mesh_gen_call=false) then
      begin
          Laplas.MainMemo.Lines.Add('The calculation is completed.');
          Laplas.MainMemo.Lines.Add('Time calculation equals.'+TimeToStr(deltatime));
      end
      else
      begin
          Laplas.MainMemo.Lines.Add('The mesh generation is completed.');
          Laplas.MainMemo.Lines.Add('Time mesh generations is equals.'+TimeToStr(deltatime));
      end;

      if (not(FormUnsteady.CheckBoxdonttec360.Checked))  then
       begin
      // вызов программы tecplot360
      //WinExec('C:/Program Files (x86)/Tecplot/Tec360 2008/bin/tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
      if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
              begin
                 WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT'),SW_SHOWNORMAL);
              end
         else
        begin
        if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
        begin
           WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
        end
         else
        begin
           if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
           begin
              WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
           end
            else
           begin
              if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
              begin
                 WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
              end
               else
              begin
                 if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                 begin
                    WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                 end
                  else
                 begin
                    Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 unfound.');
                 end;
              end;
           end;
        end;
       end;
        end;

       if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FileExists('statistic_convergence.txt')) then
         begin
            f:=TStringList.Create();
            f.LoadFromFile('statistic_convergence.txt');

            if (FormatSettings.DecimalSeparator=',') then
            begin
               // заменить все точки в файле на запятые.
               for i:=0 to f.Count-1 do
               begin
                  s:=f.Strings[i];
                  f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
               end;
            end;

             if (Laplas.egddata.myflmod[0].iturbmodel=6) then
            begin
               // Модель Ламинарно турбулнтного перехода Ментора Лантгрии (RANS) [2009].
               // первые две строки нужно пропустить.
               FormResidual_Langtry_Menter.Chart1.SeriesList[0].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[1].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[2].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[3].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[4].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[5].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[6].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[7].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=Max(1.0e-12,StrToFloat(sub));
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidual_Langtry_Menter.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=Max(1.0e-12,StrToFloat(sub));
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidual_Langtry_Menter.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=Max(1.0e-12,StrToFloat(sub));
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidual_Langtry_Menter.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=Max(1.0e-12,StrToFloat(sub));
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidual_Langtry_Menter.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=Max(1.0e-12,StrToFloat(sub));
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Langtry_Menter.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                               s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=Max(1.0e-12,StrToFloat(sub));
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Langtry_Menter.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                               s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                               sub:=Trim(Copy(s,1,Pos(' ',s)));
                               if (length(sub)>0) then
                               begin
                                  if (StrToFloat(sub)<fmin) then
                                  begin
                                     fmin:=Max(1.0e-12,StrToFloat(sub));
                                  end;
                                  if (StrToFloat(sub)>fmax) then
                                  begin
                                     fmax:=StrToFloat(sub);
                                  end;
                                  FormResidual_Langtry_Menter.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);


                                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                                  sub:=s;
                                  if (length(sub)>0) then
                                  begin
                                     if (StrToFloat(sub)<fmin) then
                                     begin
                                        fmin:=Max(1.0e-12,StrToFloat(sub));
                                     end;
                                     if (StrToFloat(sub)>fmax) then
                                     begin
                                        fmax:=StrToFloat(sub);
                                     end;
                                     FormResidual_Langtry_Menter.Chart1.SeriesList[7].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                                  end
                                   else
                                  begin
                                     // TODO
                                     // обрыв данных после первых трёх значений.
                                  end;
                               end;
                               end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   //FormResidual_Langtry_Menter.Chart1.LeftAxis.Minimum:=fmin;
                   //FormResidual_Langtry_Menter.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else
            if (Laplas.egddata.myflmod[0].iturbmodel=5) then
            begin
               // Standart K-Epsilon model.
               // первые две строки нужно пропустить.
               FormResidualStandartKEpsilon.Chart1.SeriesList[0].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[1].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[2].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[3].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[4].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualStandartKEpsilon.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualStandartKEpsilon.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualStandartKEpsilon.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualStandartKEpsilon.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualStandartKEpsilon.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualStandartKEpsilon.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                               end
                                else
                               begin
                                  // TODO
                                  // обрыв данных после первых трёх значений.
                               end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualStandartKEpsilon.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualStandartKEpsilon.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else if (Laplas.egddata.myflmod[0].iturbmodel=4) then
            begin
               // K-Omega SST.
               // первые две строки нужно пропустить.
               FormResidualSST.Chart1.SeriesList[0].Clear;
               FormResidualSST.Chart1.SeriesList[1].Clear;
               FormResidualSST.Chart1.SeriesList[2].Clear;
               FormResidualSST.Chart1.SeriesList[3].Clear;
               FormResidualSST.Chart1.SeriesList[4].Clear;
               FormResidualSST.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSST.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSST.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSST.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSST.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSST.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualSST.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                               end
                                else
                               begin
                                  // TODO
                                  // обрыв данных после первых трёх значений.
                               end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSST.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSST.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else if (Laplas.egddata.myflmod[0].iturbmodel=3) then
            begin
               // Спаларт Аллмарес.
               // первые две строки нужно пропустить.
               FormResidualSpallart_Allmares.Chart1.SeriesList[0].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[1].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[2].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[3].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[4].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSpallart_Allmares.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSpallart_Allmares.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSpallart_Allmares.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSpallart_Allmares.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=s;
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSpallart_Allmares.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSpallart_Allmares.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSpallart_Allmares.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else
            begin

            // первые две строки нужно пропустить.
            Formresidual.cht1.SeriesList[0].Clear;
            Formresidual.cht1.SeriesList[1].Clear;
            Formresidual.cht1.SeriesList[2].Clear;
            Formresidual.cht1.SeriesList[3].Clear;
            for i:=2 to f.Count-1 do
            begin
               fmin:=20.0;
               fmax:=120.0;
               s:=Trim(f.Strings[i]);
               subx:=Trim(Copy(s,1,Pos(' ',s)));
               s:=Trim(Copy(s,Pos(' ',s),Length(s)));
               sub:=Trim(Copy(s,1,Pos(' ',s)));
               if (StrToFloat(sub)<fmin) then
               begin
                  fmin:=StrToFloat(sub);
               end;
               if (StrToFloat(sub)>fmax) then
               begin
                  fmax:=StrToFloat(sub);
               end;
               Formresidual.cht1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
               s:=Trim(Copy(s,Pos(' ',s),Length(s)));
               sub:=Trim(Copy(s,1,Pos(' ',s)));
               if (length(sub)>0) then
               begin
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  Formresidual.cht1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     Formresidual.cht1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=s;
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        Formresidual.cht1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                     end
                     else
                     begin
                        // TODO
                        // обрыв данных после первых трёх значений.
                     end;

                end
                else
                begin
                   // TODO
                   // обрыв данных после двух первых значений.
                end;
            end
            else
            begin
               // TODO
               // обрыв данных.
            end;
            Formresidual.cht1.LeftAxis.Minimum:=fmin;
            Formresidual.cht1.LeftAxis.Maximum:=fmax;
         end;
            end;
         f.Clear;
         f.Free;

          if (Laplas.egddata.myflmod[0].iturbmodel=6) then
         begin
            // модель ламинарно турбулентного перехода Ментора Лангтрии.
            FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=true;
            FormResidual_Langtry_Menter.Show;
         end
         else
         if (Laplas.egddata.myflmod[0].iturbmodel=5) then
         begin
            // Standart K-Epsilon model.
            FormResidualStandartKEpsilon.brun_visibleKEpsilon:=true;
            FormResidualStandartKEpsilon.Show;
         end
         else
         if (Laplas.egddata.myflmod[0].iturbmodel=4) then
         begin
            // SST Ментер 1993.
            FormResidualSST.brun_visibleSST:=true;
            FormResidualSST.Show;
         end
         else
         if (Laplas.egddata.myflmod[0].iturbmodel=3) then
         begin
            // Спаларт Аллмарес 1992.
            FormResidualSpallart_Allmares.brun_visibleSA:=true;
            FormResidualSpallart_Allmares.Show;
         end
         else
         begin
            // Ламинарный
            Formresidual.brun_visible:=true;
            Formresidual.Show;
         end;
     end
     else
     begin
        Laplas.MainMemo.Lines.Add('file statistic_convergence.txt  unfound.');
     end;
      end;

      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FileExists('report_temperature.txt')) then
         begin
            WinExec('notepad.exe report_temperature.txt',sw_ShowNormal);
         end;
         (*
         if (lbclone<300) then
         begin
            // Если будет больше 300 блоков то загружаться репорт
            // будет очень долго.
            if (FileExists('report_temperature.txt')) then
            begin
               f3:=TStringList.Create();
               f:=TStringList.Create();
               f.LoadFromFile('report_temperature.txt');
               //Laplas.MainMemo.Lines.Add(f.Strings[0]);
               f3.Add(f.Strings[0]);
               for i:=0 to lbclone-1 do
               begin
                  //Laplas.MainMemo.Lines.Add(f.Strings[i+1]);
                  f3.Add(f.Strings[i+1]);
               end;
               for i:=0 to lsclone-1 do
               begin
                 //Laplas.MainMemo.Lines.Add(f.Strings[i+lbclone+1]);
                 f3.Add(f.Strings[i+lbclone+1]);
               end;
               for i:=0 to lwclone-1 do
               begin
                  //Laplas.MainMemo.Lines.Add(f.Strings[i+lbclone+lsclone+1]);
                  f3.Add(f.Strings[i+lbclone+lsclone+1]);
               end;
               //DeleteFile('solver/solid_static/report_temperature.txt');
               // Ускоренная загрузка репорта в программу интерфейс.
               Laplas.MainMemo.Lines.AddStrings(f3);
               f3.Clear;
               f3.Free;
               f.Clear;
               f.Free;
             end
              else
             begin
                Laplas.MainMemo.Lines.Add('report_temperature.txt not found.');
             end;
         end
          else
         begin
             Laplas.MainMemo.Lines.Add('report temperature do not load. lb>=300.');
            Laplas.MainMemo.Lines.Add('synopsis: very big file...');
         end;
         *)
      end;

     // Освобождение оперативной памяти.
      SetLength(wallname,0);
      SetLength(sourcename,0);
      SetLength(bodyname,0);
      SetLength(is_hollow,0);

     Laplas.brun:=false;

     Laplas.bonly_mesh_gen_call:=false;

     Laplas.bVisualization_Management_now:=false;
end;

// Нужно создать процедуру Execute, уже описанную в классе TMyThread
procedure TMyThread3.Execute;
var
  // StartupInfo : TStartupInfo;
   //ProcessInfo : TProcessInformation;
   f, f3 : TStringList;
   ShellInfo : TShellExecuteInfo;
   ExitCode : DWORD;
   QuoteParams : Boolean;
   i : Integer;
   starttime, endtime, deltatime : TTime;
   bodyname, sourcename, wallname : array of string;
   is_hollow : array of boolean;
   lbclone, lsclone, lwclone : Integer;

   s,subx,sub : String; // текущая рабочая строка
   fmin, fmax : Real;
begin



        // Надо сделать копию имён block, source и wall перед запуском.
        lbclone:=Laplas.lb;
        lsclone:=Laplas.ls;
        lwclone:=Laplas.lw;
         SetLength(bodyname,lbclone);
         SetLength(is_hollow,lbclone);
         for i:=0 to lbclone-1 do
         begin
           bodyname[i]:=Laplas.body[i].name;
           if (Laplas.body[i].itype=2) then
           begin
              // HOLLOW
              is_hollow[i]:=true;
           end
           else
           begin
              is_hollow[i]:=false;
           end;
         end;
         SetLength(sourcename,lsclone);
         for i:=0 to lsclone-1 do
         begin
            sourcename[i]:=Laplas.source[i].name;
         end;
         SetLength(wallname,lwclone);
          for i:=0 to lwclone-1 do
         begin
           wallname[i]:=Laplas.wall[i].name;
         end;

        starttime:=Now();




        ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        if (FormSetting.rgParallel.ItemIndex=0) then
        begin
           //ShellInfo.lpFile:=PChar('"test_pattern\solver\conjugate_heat_transfer_static\AliceFlow_v0_26.exe"');
           // 29.01.2017
           //ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_30.exe"');
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x64\AliceFlow_v0_48.exe"');
        end;
        if (FormSetting.rgParallel.ItemIndex=1) then
        begin
            ShellInfo.lpFile:=PChar('"test_pattern\solver\x86\AliceFlow_v0_48.exe"');
        end;
         if (FormSetting.rgParallel.ItemIndex=2) then
        begin
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x64_float\AliceFlow_v0_48.exe"');
        end;
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;


         // удаляем ненужные файлы.
      DeleteFile('ALICEFLOW0_06_temp_part1.txt');
      DeleteFile('ALICEFLOW0_06_temp_part3.txt');


       if (FileExists('report_temperature.txt')) then
      begin
         WinExec('notepad.exe report_temperature.txt',sw_ShowNormal);
      end;

      endtime:=Now();
      deltatime:=endtime-starttime;
      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         Laplas.MainMemo.Lines.Add('The calculation is completed.');
         Laplas.MainMemo.Lines.Add('Time calculation equals '+TimeToStr(deltatime));
      end
        else
      begin
         Laplas.MainMemo.Lines.Add('The mesh generation is completed.');
         Laplas.MainMemo.Lines.Add('Time mesh generation equals '+TimeToStr(deltatime));
      end;

      if (not(FormUnsteady.CheckBoxdonttec360.Checked))  then
      begin
         // вызов программы tecplot360
         // WinExec('C:/Program Files (x86)/Tecplot/Tec360 2008/bin/tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
         if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
              begin
                 WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT'),SW_SHOWNORMAL);
              end
         else
        begin
     if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
        begin
           WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
        end
         else
        begin
           if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
           begin
              WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
           end
            else
           begin
              if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
              begin
                WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
              end
               else
              begin
                 if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                 begin
                    WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                 end
                  else
                 begin
                    Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 unfound.');
                 end;
              end;
           end;
        end;
     end;
      end;

      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (Laplas.egddata.itemper>0) then
         begin

            if (FileExists('statistic_convergence.txt')) then
            begin
               f:=TStringList.Create();
               f.LoadFromFile('statistic_convergence.txt');

               if (FormatSettings.DecimalSeparator=',') then
               begin
                  // заменить все точки в файле на запятые.
                  for i:=0 to f.Count-1 do
                  begin
                     s:=f.Strings[i];
                     f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
                  end;
               end;

               if ((Laplas.egddata.myflmod[0].iflowregime=1)and
             (Laplas.egddata.myflmod[0].iturbmodel=6)) then
            begin
               // Standart K-Epsilon model на основек двухслойной модели.
               // первые две строки нужно пропустить.
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[0].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[1].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[2].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[3].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[4].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[5].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[6].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[7].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[8].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                            s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);


                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[7].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              if (Pos(s,' ')>0) then
                              begin
                                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                              end
                              else
                              begin
                                 sub:=Trim(Copy(s,1,length(s)));
                              end;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[8].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                              end
                               else
                              begin
                                 // TODO
                                 // обрыв данных после первых трёх значений.
                              end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                        end;
                        end;
                        end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidual_Lagtry_Menter_Temp.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidual_Lagtry_Menter_Temp.Chart1.LeftAxis.Maximum:=fmax;
                end;


                f.Free;
                Formresidual2.brun_visible2:=false;
                FormResidualSATemp.brun_visibleSA2:=false;
                FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=true;
                FormResidual_Lagtry_Menter_Temp.Show;
            end
            else
            if ((Laplas.egddata.myflmod[0].iflowregime=1)and
             (Laplas.egddata.myflmod[0].iturbmodel=5)) then
            begin
               // Standart K-Epsilon model на основек двухслойной модели.
               // первые две строки нужно пропустить.
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[0].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[1].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[2].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[3].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[4].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[5].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[6].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                            s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              if (Pos(s,' ')>0) then
                              begin
                                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                              end
                              else
                              begin
                                 sub:=Trim(Copy(s,1,length(s)));
                              end;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                              end
                               else
                              begin
                                 // TODO
                                 // обрыв данных после первых трёх значений.
                              end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                        end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualStandart_k_epsilon_Temp.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualStandart_k_epsilon_Temp.Chart1.LeftAxis.Maximum:=fmax;
                end;


                f.Free;
                Formresidual2.brun_visible2:=false;
                FormResidualSATemp.brun_visibleSA2:=false;
                FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=true;
                FormResidualStandart_k_epsilon_Temp.Show;
            end
            else
            if ((Laplas.egddata.myflmod[0].iflowregime=1)and
             (Laplas.egddata.myflmod[0].iturbmodel=4)) then
            begin
               // K-Omega SST.
               // первые две строки нужно пропустить.
               FormResidualSSTTemp.Chart1.SeriesList[0].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[1].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[2].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[3].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[4].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[5].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[6].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSSTTemp.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSSTTemp.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSSTTemp.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSSTTemp.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                            s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidualSSTTemp.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSSTTemp.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              if (Pos(s,' ')>0) then
                              begin
                                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                              end
                              else
                              begin
                                 sub:=Trim(Copy(s,1,length(s)));
                              end;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualSSTTemp.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                              end
                               else
                              begin
                                 // TODO
                                 // обрыв данных после первых трёх значений.
                              end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                        end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSSTTemp.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSSTTemp.Chart1.LeftAxis.Maximum:=fmax;
                end;


                f.Free;
                Formresidual2.brun_visible2:=false;
                FormResidualSATemp.brun_visibleSA2:=false;
                FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                FormResidualSSTTemp.brun_visibleSSTTemp:=true;
                FormResidualSSTTemp.Show;
            end
            else
            if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                (Laplas.egddata.myflmod[0].iturbmodel=3)) then
            begin
               // Спаларт Аллмарес с температурой.
               // первые две строки нужно пропустить.
               FormResidualSATemp.Chart1.SeriesList[0].Clear;
               FormResidualSATemp.Chart1.SeriesList[1].Clear;
               FormResidualSATemp.Chart1.SeriesList[2].Clear;
               FormResidualSATemp.Chart1.SeriesList[3].Clear;
               FormResidualSATemp.Chart1.SeriesList[4].Clear;
               FormResidualSATemp.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSATemp.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSATemp.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSATemp.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSATemp.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSATemp.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualSATemp.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                              end
                               else
                              begin
                                 // TODO
                                 // обрыв данных после первых трёх значений.
                              end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSATemp.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSATemp.Chart1.LeftAxis.Maximum:=fmax;
                end;
                 f.Free;
                 FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                 FormResidualSATemp.brun_visibleSA2:=true;
                 FormResidualSATemp.Show;
            end
            else
            begin
              // первые две строки нужно пропустить.
              Formresidual2.cht1.SeriesList[0].Clear;
              Formresidual2.cht1.SeriesList[1].Clear;
              Formresidual2.cht1.SeriesList[2].Clear;
              Formresidual2.cht1.SeriesList[3].Clear;
              Formresidual2.cht1.SeriesList[4].Clear;
              for i:=2 to f.Count-1 do
              begin
                 fmin:=20.0;
                 fmax:=1.2;
                 s:=Trim(f.Strings[i]);
                 subx:=Trim(Copy(s,1,Pos(' ',s)));
                 s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                 if (StrToFloat(sub)<fmin) then
                 begin
                    fmin:=StrToFloat(sub);
                 end;
                 Formresidual2.cht1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                 s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                 if (StrToFloat(sub)<fmin) then
                 begin
                    fmin:=StrToFloat(sub);
                 end;
                 Formresidual2.cht1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                 s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                 if (StrToFloat(sub)<fmin) then
                 begin
                    fmin:=StrToFloat(sub);
                 end;
                 Formresidual2.cht1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                 s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                 sub:=s;
                 if (StrToFloat(sub)<fmin) then
                 begin
                    fmin:=StrToFloat(sub);
                 end;
                 Formresidual2.cht1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                 s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                 sub:=s;
                 if (StrToFloat(sub)<fmin) then
                 begin
                    fmin:=StrToFloat(sub);
                 end;
                 Formresidual2.cht1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clBlack);


               Formresidual2.cht1.LeftAxis.Minimum:=fmin;
               Formresidual2.cht1.LeftAxis.Maximum:=fmax;
            end;
            f.Clear;
            f.Free;
            FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
            Formresidual2.brun_visible2:=true;
            Formresidual2.Show;
            end;
          end
           else
          begin
            Laplas.MainMemo.Lines.Add('file statistic_convergence.txt  unfound.');
          end;


     end
     else
     begin


      if (FileExists('statistic_convergence.txt')) then
      begin
         f:=TStringList.Create();
         f.LoadFromFile('statistic_convergence.txt');

         if (FormatSettings.DecimalSeparator=',') then
          begin
             // заменить все точки в файле на запятые.
             for i:=0 to f.Count-1 do
             begin
                s:=f.Strings[i];
                f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
             end;
          end;

           if (Laplas.egddata.myflmod[0].iturbmodel=6) then
            begin
               // модель ламинарно турбулентного перехода Ментора-Лангтрии (RANS) [2009].
               // первые две строки нужно пропустить.
               FormResidual_Langtry_Menter.Chart1.SeriesList[0].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[1].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[2].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[3].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[4].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[5].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[6].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[7].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidual_Langtry_Menter.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidual_Langtry_Menter.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidual_Langtry_Menter.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidual_Langtry_Menter.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Langtry_Menter.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Langtry_Menter.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                               s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Langtry_Menter.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);


                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidual_Langtry_Menter.Chart1.SeriesList[7].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                               end
                                else
                               begin
                                  // TODO
                                  // обрыв данных после первых трёх значений.
                               end;
                           end;
                           end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   //FormResidual_Langtry_Menter.Chart1.LeftAxis.Minimum:=fmin;
                   //FormResidual_Langtry_Menter.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else
          if (Laplas.egddata.myflmod[0].iturbmodel=5) then
            begin
               // Standart K-Epsilon model.
               // первые две строки нужно пропустить.
               FormResidualStandartKEpsilon.Chart1.SeriesList[0].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[1].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[2].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[3].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[4].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualStandartKEpsilon.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualStandartKEpsilon.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualStandartKEpsilon.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualStandartKEpsilon.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualStandartKEpsilon.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualStandartKEpsilon.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                               end
                                else
                               begin
                                  // TODO
                                  // обрыв данных после первых трёх значений.
                               end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualStandartKEpsilon.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualStandartKEpsilon.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else
          if (Laplas.egddata.myflmod[0].iturbmodel=4) then
            begin
               // K-Omega SST Menter [1993].
               // первые две строки нужно пропустить.
               FormResidualSST.Chart1.SeriesList[0].Clear;
               FormResidualSST.Chart1.SeriesList[1].Clear;
               FormResidualSST.Chart1.SeriesList[2].Clear;
               FormResidualSST.Chart1.SeriesList[3].Clear;
               FormResidualSST.Chart1.SeriesList[4].Clear;
               FormResidualSST.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSST.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSST.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSST.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSST.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSST.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualSST.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                               end
                                else
                               begin
                                  // TODO
                                  // обрыв данных после первых трёх значений.
                               end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSST.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSST.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else
          if (Laplas.egddata.myflmod[0].iturbmodel=3) then
            begin
               // Спаларт Аллмарес.
               // первые две строки нужно пропустить.
               FormResidualSpallart_Allmares.Chart1.SeriesList[0].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[1].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[2].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[3].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[4].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSpallart_Allmares.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSpallart_Allmares.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSpallart_Allmares.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSpallart_Allmares.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=s;
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSpallart_Allmares.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSpallart_Allmares.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSpallart_Allmares.Chart1.LeftAxis.Maximum:=fmax;
                end;

                f.Free;
                FormResidualSpallart_Allmares.brun_visibleSA:=true;
                FormResidualSpallart_Allmares.Show;
            end
             else
            begin
               // первые две строки нужно пропустить.
               Formresidual.cht1.SeriesList[0].Clear;
               Formresidual.cht1.SeriesList[1].Clear;
               Formresidual.cht1.SeriesList[2].Clear;
               Formresidual.cht1.SeriesList[3].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=1.2;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  Formresidual.cht1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  Formresidual.cht1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  Formresidual.cht1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=s;
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  Formresidual.cht1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                  Formresidual.cht1.LeftAxis.Minimum:=fmin;
                  Formresidual.cht1.LeftAxis.Maximum:=fmax;
               end;
               f.Clear;
               f.Free;
               Formresidual.brun_visible:=true;
               Formresidual.Show;
         end;
      end
      else
      begin
        Laplas.MainMemo.Lines.Add('file statistic_convergence.txt  unfound.');
      end;

      end;
     end;

       if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FileExists('report_temperature.txt')) then
         begin
            WinExec('notepad.exe report_temperature.txt',sw_ShowNormal);
         end;
         (*
         if (lbclone<300) then
         begin
            // Если будет больше 300 блоков то загружаться репорт
            // будет очень долго.
            if (FileExists('report_temperature.txt')) then
            begin
               f3:=TStringList.Create();
               f:=TStringList.Create();
               f.LoadFromFile('report_temperature.txt');
               //Laplas.MainMemo.Lines.Add(f.Strings[0]);
               f3.Add(f.Strings[0]);
               for i:=0 to lbclone-1 do
               begin
                  //Laplas.MainMemo.Lines.Add(f.Strings[i+1]);
                  f3.Add(f.Strings[i+1]);
               end;
               for i:=0 to lsclone-1 do
               begin
                  //Laplas.MainMemo.Lines.Add(f.Strings[i+lbclone+1]);
                  f3.Add(f.Strings[i+lbclone+1]);
               end;
               for i:=0 to lwclone-1 do
               begin
                  //Laplas.MainMemo.Lines.Add(f.Strings[i+lbclone+lsclone+1]);
                  f3.Add(f.Strings[i+lbclone+lsclone+1]);
               end;
               //DeleteFile('solver/solid_static/report_temperature.txt');
               // Ускоренная загрузка больших репортов в программу.
               Laplas.MainMemo.Lines.AddStrings(f3);
               f3.Clear;
               f3.Free;
               f.Clear;
               f.Free;
            end
             else
            begin
               Laplas.MainMemo.Lines.Add('report_temperature.txt not found.');
            end;
         end
          else
         begin
             Laplas.MainMemo.Lines.Add('report temperature do not load. lb>=300.');
            Laplas.MainMemo.Lines.Add('synopsis: very big file...');
         end;
         *)
      end;

      // Освобождение оперативной памяти.
      SetLength(wallname,0);
      SetLength(sourcename,0);
      SetLength(bodyname,0);
      SetLength(is_hollow,0);

      Laplas.brun:=false;
      Laplas.bonly_mesh_gen_call:=false;

      Laplas.bVisualization_Management_now:=false;
end;



// Нужно создать процедуру Execute, уже описанную в классе TMyThread
procedure TLaplas.SerialExecute1;
var
  // StartupInfo : TStartupInfo;
   //ProcessInfo : TProcessInformation;
   f, f2, f3 : TStringList;
   ShellInfo : TShellExecuteInfo;
   ExitCode : DWORD;
   QuoteParams : Boolean;
   i : Integer;
   starttime, endtime, deltatime : TTime;
      bodyname, sourcename, wallname : array of string;
      is_hollow : array of Boolean;
   lbclone, lsclone, lwclone : Integer;
   s7 : String;

begin
    // Serial
        // CreateProcess(nil,'test_pattern/solver/solid_static/AliceFlow_v0_07.exe',nil,nil,false,Create_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
        //     nil,nil,StartupInfo,ProcessInfo);

          // Надо сделать копию имён block, source и wall перед запуском.
        lbclone:=Laplas.lb;
        lsclone:=Laplas.ls;
        lwclone:=Laplas.lw;
        SetLength(bodyname,lbclone);
        SetLength(is_hollow,lbclone);
         for i:=0 to lbclone-1 do
         begin
           bodyname[i]:=Laplas.body[i].name;
           if (Laplas.body[i].itype=2) then
           begin
              // HOLLOW
              is_hollow[i]:=true;
           end
            else
           begin
              is_hollow[i]:=false;
           end;
         end;
         SetLength(sourcename,lsclone);
         for i:=0 to lsclone-1 do
         begin
            sourcename[i]:=Laplas.source[i].name;
         end;
         SetLength(wallname,lwclone);
          for i:=0 to lwclone-1 do
         begin
           wallname[i]:=Laplas.wall[i].name;
         end;

         starttime:=Now();

         if (not(Laplas.bonly_mesh_gen_call)) then
         begin
            if (FormUnsteady.RadioGroup1.ItemIndex=1) then
            begin
               // Нестационарное моделирование и мы формируем
               // наиполнейший отчёт о температурах всех объектов
               // из которых состоит расчётная модель.

               f2:=TStringList.Create();
               s7:='time ';
               for i:=0 to lbclone - 1 do
               begin
                  s7:=s7 + ' ' + bodyname[i] + '_tC ' + bodyname[i] + '_power';
               end;
               for i:=0 to lsclone - 1 do
               begin
                  s7:=s7 + ' ' + sourcename[i] + '_tC ' + sourcename[i] + '_power';
               end;
               for i:=0 to lwclone - 1 do
               begin
                  s7:=s7 + ' ' + wallname[i] + '_tC ' + wallname[i] + '_power';
               end;
               f2.Add(s7);
               f2.SaveToFile('report_temperature_unsteady.txt');
               f2.Clear;
               f2.Free;
            end;
        end
        else
        begin
           DeleteFile('report_temperature_unsteady.txt');
        end;


        ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        if (FormSetting.rgParallel.ItemIndex=0) then
        begin
        //if (FormUnsteady.RadioGroup1.ItemIndex=0) then
        //begin
           // модифицировано 23.07.2016.
           // Steady Calculation and  Unsteady Calculation
           //ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_30.exe"');
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x64\AliceFlow_v0_48.exe"');
        //end
        //else
        //begin
           // Unsteady Calculation
          // ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_26Unsteady.exe"');
        //end;
        end;
        if (FormSetting.rgParallel.ItemIndex=1) then
        begin
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x86\AliceFlow_v0_48.exe"');
        end;
        if (FormSetting.rgParallel.ItemIndex=2) then
        begin
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x64_float\AliceFlow_v0_48.exe"');
        end;
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;

        // удаляем ненужные файлы.
      DeleteFile('ALICEFLOW0_06_temp_part1.txt');
      DeleteFile('ALICEFLOW0_06_temp_part3.txt');



      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FileExists('report_temperature.txt')) then
         begin
            WinExec('notepad.exe report_temperature.txt',sw_ShowNormal);
         end;
         (*
         if (lbclone<300) then
         begin
            // Если будет больше 300 блоков то загружаться репорт
            // будет очень долго.
            if (FileExists('report_temperature.txt')) then
            begin
               f3:=TStringList.Create();
               f:=TStringList.Create();
               f.LoadFromFile('report_temperature.txt');
               //Laplas.MainMemo.Lines.Add(f.Strings[0]);
               f3.Add(f.Strings[0]);
               for i:=0 to lbclone-1 do
               begin
                  //Laplas.MainMemo.Lines.Add(f.Strings[i+1]);
                  f3.Add(f.Strings[i+1]);
               end;
               for i:=0 to lsclone-1 do
               begin
                  // Laplas.MainMemo.Lines.Add(f.Strings[i+lbclone+1]);
                  f3.Add(f.Strings[i+lbclone+1]);
               end;
               for i:=0 to lwclone-1 do
               begin
                  // Laplas.MainMemo.Lines.Add(f.Strings[i+lbclone+lsclone+1]);
                  f3.Add(f.Strings[i+lbclone+lsclone+1]);
               end;
               //DeleteFile('solver/solid_static/report_temperature.txt');
               // ускоренная загрузка репорта, чтобы не ждать.
               Laplas.MainMemo.Lines.AddStrings(f3);
               f.Clear;
               f.Free;
               f3.Clear;
               f3.Free;
             end
              else
             begin
                ShowMessage('file report_temperature.txt not found ');
                Laplas.MainMemo.Lines.Add('file report_temperature.txt not found ');
             end;
         end
          else
         begin
            Laplas.MainMemo.Lines.Add('report temperature do not load. lb>=300.');
            Laplas.MainMemo.Lines.Add('synopsis: very big file...');
         end;
         *)
      end;
      // Освобождение оперативной памяти.
      SetLength(wallname,0);
      SetLength(sourcename,0);
      SetLength(bodyname,0);
      SetLength(is_hollow,0);

      // В случае нестационарного моделирования записаны переходные характеристики.
      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FormUnsteady.RadioGroup1.ItemIndex=1) then
          begin
             if (FormUnsteady.ComboBoxTimeStep.ItemIndex=0) then
             begin
                // Linear Time Step Law. // была снята переходная характеристика.
                Laplas.MainMemo.Lines.Add('Evdokimova.txt report writing succsefull.');
                Laplas.MainMemo.Lines.Add('heating_curves.txt report writing succsefull.');
             end;
         end;
      end;
      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FileExists('report.txt')) then
         begin
            f:=TStringList.Create();
            f.LoadFromFile('report.txt');
            Laplas.MainMemo.Lines.Add(f.Strings[0]);
            DeleteFile('report.txt');
            f.Clear;
            f.Free;
         end;
      end;

       if (Laplas.bonly_mesh_gen_call) then
      begin
       // Время работы сеточного генератора.
         Laplas.MainMemo.Lines.Add('The meshing generation is completed.');
         endtime:=Now();
         deltatime:=endtime-starttime;
         Laplas.MainMemo.Lines.Add('Time meshing generation equals '+TimeToStr(deltatime));

      end
      else
      begin
       // Для оптимизационных задач продублируем время счёта.
         Laplas.MainMemo.Lines.Add('The calculation is completed.');
         endtime:=Now();
         deltatime:=endtime-starttime;
         Laplas.MainMemo.Lines.Add('Time calculation equals '+TimeToStr(deltatime));
      end;

      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FormUnsteady.RadioGroup1.ItemIndex=1) then
         begin
            // Запуск визуализации графика зависимости максимальной температуры в расчётной области
            // от времени.
            if (FileExists('GraphicsKras.exe')) then
            begin
               WinExec('GraphicsKras.exe',SW_SHOWNORMAL);
            end;
        end;
      end;


      if (Laplas.bVisualization_Management_now=true) then
      begin
          // вызов программы tecplot360
            // WinExec('C:/Program Files (x86)/Tecplot/Tec360 2008/bin/tec360.exe ALICEFlow0_07_Visualisation_Magement.PLT',SW_SHOWNORMAL);
            if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
            begin
               WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe ALICEFlow0_07_Visualisation_Magement.PLT'),SW_SHOWNORMAL);
            end
             else
            begin
               if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
               begin
                  WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe ALICEFlow0_07_Visualisation_Magement.PLT',SW_SHOWNORMAL);
               end
                else
               begin
                  if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
                  begin
                     WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe ALICEFlow0_07_Visualisation_Magement.PLT',SW_SHOWNORMAL);
                  end
                   else
                  begin
                     if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
                     begin
                        WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe ALICEFlow0_07_Visualisation_Magement.PLT',SW_SHOWNORMAL);
                     end
                      else
                     begin
                        if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                        begin
                           WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe ALICEFlow0_07_Visualisation_Magement.PLT',SW_SHOWNORMAL);
                        end
                         else
                        begin
                           Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 or 2017 unfound.');
                        end;
                     end;
                  end;
               end;
            end;
      end
      else
      begin
         if (Laplas.egddata.itemper=2) then
         begin
            // Был запущен метод конечных элементов.
            if (not(FormUnsteady.CheckBoxdonttec360.Checked))  then
            begin
               // вызов программы tecplot360
               // WinExec('C:/Program Files (x86)/Tecplot/Tec360 2008/bin/tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
               if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
               begin
                  WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe ALICEFLOW0_08_temp.PLT'),SW_SHOWNORMAL);
               end
                else
               begin
                  if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
                  begin
                     WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
                  end
                   else
                  begin
                     if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
                     begin
                        WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
                     end
                      else
                     begin
                        if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
                        begin
                           WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
                        end
                         else
                        begin
                           if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                           begin
                              WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
                           end
                            else
                           begin
                              Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 or 2017 unfound.');
                           end;
                        end;
                     end;
                  end;
               end;
            end;
         end
          else
         begin

            if (not(FormUnsteady.CheckBoxdonttec360.Checked))  then
            begin
               // вызов программы tecplot360
               // WinExec('C:/Program Files (x86)/Tecplot/Tec360 2008/bin/tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
               if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
               begin
                  WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT'),SW_SHOWNORMAL);
               end
                else
               begin
                  if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
                  begin
                     WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                  end
                   else
                  begin
                     if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
                     begin
                        WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                     end
                      else
                     begin
                        if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
                        begin
                           WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                        end
                         else
                        begin
                           if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                           begin
                              WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                           end
                            else
                           begin
                              Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 unfound.');
                           end;
                        end;
                     end;
                  end;
               end;
            end;
         end;
      end;

      Laplas.bVisualization_Management_now:=false;

   Laplas.brun:=false;

    Laplas.bonly_mesh_gen_call:=false;
end;

 // Нужно создать процедуру Execute, уже описанную в классе TMyThread
procedure TLaplas.SerialExecute2;
var
  // StartupInfo : TStartupInfo;
   //ProcessInfo : TProcessInformation;
   f, f3 : TStringList;
   ShellInfo : TShellExecuteInfo;
   ExitCode : DWORD;
   QuoteParams : Boolean;
   i : Integer;
   starttime, endtime, deltatime : TTime;
   bodyname, sourcename, wallname : array of string;
   is_hollow : array of boolean;
   lbclone, lsclone, lwclone : Integer;
   s,subx,sub : String; // текущая рабочая строка
   fmin, fmax : Real;

begin

        lbclone:=Laplas.lb;
        lsclone:=Laplas.ls;
        lwclone:=Laplas.lw;
         SetLength(bodyname,lbclone);
         SetLength(is_hollow,lbclone);
         for i:=0 to lbclone-1 do
         begin
           bodyname[i]:=Laplas.body[i].name;
           if (Laplas.body[i].itype=2) then
           begin
             // HOLLOW
             is_hollow[i]:=true;
           end
           else
           begin
              is_hollow[i]:=false;
           end;
         end;
         SetLength(sourcename,lsclone);
         for i:=0 to lsclone-1 do
         begin
            sourcename[i]:=Laplas.source[i].name;
         end;
         SetLength(wallname,lwclone);
          for i:=0 to lwclone-1 do
         begin
           wallname[i]:=Laplas.wall[i].name;
         end;

        starttime:=Now();



         // Запускает приложение и ждёт окончания его работы.
      //CreateProcess(nil,'test_pattern/solver/fluid_static/AliceFlow_v0_07.exe',nil,nil,false,Create_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
        //     nil,nil,StartupInfo,ProcessInfo);


        ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        if (FormSetting.rgParallel.ItemIndex=0) then
        begin
           // однопоточная версия.
           //ShellInfo.lpFile:=PChar('"test_pattern\solver\fluid_static\AliceFlow_v0_26.exe"');
           // 29.01.2017
           //ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_30.exe"');
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x64\AliceFlow_v0_48.exe"');
        end;
         if (FormSetting.rgParallel.ItemIndex=1) then
        begin
           // параллельные вычисления.
           // Устарело 29.01.2017
           //ShellInfo.lpFile:=PChar('"test_pattern\solver\fluid_static\AliceFlow_v0_07P.exe"');
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x86\AliceFlow_v0_48.exe"');
        end;
         if (FormSetting.rgParallel.ItemIndex=2) then
        begin
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x64_float\AliceFlow_v0_48.exe"');
        end;
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;

      //WaitforSingleObject(ProcessInfo.hProcess,INFINITE);

      // удаляем ненужные файлы.
      DeleteFile('ALICEFLOW0_06_temp_part1.txt');
      DeleteFile('ALICEFLOW0_06_temp_part3.txt');




      endtime:=Now();
      deltatime:=endtime-starttime;
      if (Laplas.bonly_mesh_gen_call=false) then
      begin
          Laplas.MainMemo.Lines.Add('The calculation is completed.');
          Laplas.MainMemo.Lines.Add('Time calculation equals.'+TimeToStr(deltatime));
      end
      else
      begin
          Laplas.MainMemo.Lines.Add('The mesh generation is completed.');
          Laplas.MainMemo.Lines.Add('Time mesh generations is equals.'+TimeToStr(deltatime));
      end;

      if (not(FormUnsteady.CheckBoxdonttec360.Checked))  then
       begin
      // вызов программы tecplot360
      //WinExec('C:/Program Files (x86)/Tecplot/Tec360 2008/bin/tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
      if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
              begin
                 WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT'),SW_SHOWNORMAL);
              end
         else
        begin
        if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
        begin
           WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
        end
         else
        begin
           if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
           begin
              WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
           end
            else
           begin
              if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
              begin
                 WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
              end
               else
              begin
                 if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                 begin
                    WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                 end
                  else
                 begin
                    Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 unfound.');
                 end;
              end;
           end;
        end;
       end;
        end;

       if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FileExists('statistic_convergence.txt')) then
         begin
            f:=TStringList.Create();
            f.LoadFromFile('statistic_convergence.txt');

            if (FormatSettings.DecimalSeparator=',') then
            begin
               // заменить все точки в файле на запятые.
               for i:=0 to f.Count-1 do
               begin
                  s:=f.Strings[i];
                  f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
               end;
            end;

             if (Laplas.egddata.myflmod[0].iturbmodel=6) then
            begin
               // Модель Ламинарно турбулнтного перехода Ментора Лантгрии (RANS) [2009].
               // первые две строки нужно пропустить.
               FormResidual_Langtry_Menter.Chart1.SeriesList[0].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[1].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[2].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[3].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[4].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[5].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[6].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[7].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=Max(1.0e-12,StrToFloat(sub));
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidual_Langtry_Menter.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=Max(1.0e-12,StrToFloat(sub));
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidual_Langtry_Menter.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=Max(1.0e-12,StrToFloat(sub));
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidual_Langtry_Menter.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=Max(1.0e-12,StrToFloat(sub));
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidual_Langtry_Menter.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=Max(1.0e-12,StrToFloat(sub));
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Langtry_Menter.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                               s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=Max(1.0e-12,StrToFloat(sub));
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Langtry_Menter.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                               s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                               sub:=Trim(Copy(s,1,Pos(' ',s)));
                               if (length(sub)>0) then
                               begin
                                  if (StrToFloat(sub)<fmin) then
                                  begin
                                     fmin:=Max(1.0e-12,StrToFloat(sub));
                                  end;
                                  if (StrToFloat(sub)>fmax) then
                                  begin
                                     fmax:=StrToFloat(sub);
                                  end;
                                  FormResidual_Langtry_Menter.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);


                                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                                  sub:=s;
                                  if (length(sub)>0) then
                                  begin
                                     if (StrToFloat(sub)<fmin) then
                                     begin
                                        fmin:=Max(1.0e-12,StrToFloat(sub));
                                     end;
                                     if (StrToFloat(sub)>fmax) then
                                     begin
                                        fmax:=StrToFloat(sub);
                                     end;
                                     FormResidual_Langtry_Menter.Chart1.SeriesList[7].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                                  end
                                   else
                                  begin
                                     // TODO
                                     // обрыв данных после первых трёх значений.
                                  end;
                               end;
                               end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   //FormResidual_Langtry_Menter.Chart1.LeftAxis.Minimum:=fmin;
                   //FormResidual_Langtry_Menter.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else
            if (Laplas.egddata.myflmod[0].iturbmodel=5) then
            begin
               // Standart K-Epsilon model.
               // первые две строки нужно пропустить.
               FormResidualStandartKEpsilon.Chart1.SeriesList[0].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[1].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[2].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[3].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[4].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualStandartKEpsilon.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualStandartKEpsilon.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualStandartKEpsilon.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualStandartKEpsilon.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualStandartKEpsilon.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualStandartKEpsilon.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                               end
                                else
                               begin
                                  // TODO
                                  // обрыв данных после первых трёх значений.
                               end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualStandartKEpsilon.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualStandartKEpsilon.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else if (Laplas.egddata.myflmod[0].iturbmodel=4) then
            begin
               // K-Omega SST.
               // первые две строки нужно пропустить.
               FormResidualSST.Chart1.SeriesList[0].Clear;
               FormResidualSST.Chart1.SeriesList[1].Clear;
               FormResidualSST.Chart1.SeriesList[2].Clear;
               FormResidualSST.Chart1.SeriesList[3].Clear;
               FormResidualSST.Chart1.SeriesList[4].Clear;
               FormResidualSST.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSST.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSST.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSST.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSST.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSST.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualSST.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                               end
                                else
                               begin
                                  // TODO
                                  // обрыв данных после первых трёх значений.
                               end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSST.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSST.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else if (Laplas.egddata.myflmod[0].iturbmodel=3) then
            begin
               // Спаларт Аллмарес.
               // первые две строки нужно пропустить.
               FormResidualSpallart_Allmares.Chart1.SeriesList[0].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[1].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[2].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[3].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[4].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSpallart_Allmares.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSpallart_Allmares.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSpallart_Allmares.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSpallart_Allmares.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=s;
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSpallart_Allmares.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSpallart_Allmares.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSpallart_Allmares.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else
            begin

            // первые две строки нужно пропустить.
            Formresidual.cht1.SeriesList[0].Clear;
            Formresidual.cht1.SeriesList[1].Clear;
            Formresidual.cht1.SeriesList[2].Clear;
            Formresidual.cht1.SeriesList[3].Clear;
            for i:=2 to f.Count-1 do
            begin
               fmin:=20.0;
               fmax:=120.0;
               s:=Trim(f.Strings[i]);
               subx:=Trim(Copy(s,1,Pos(' ',s)));
               s:=Trim(Copy(s,Pos(' ',s),Length(s)));
               sub:=Trim(Copy(s,1,Pos(' ',s)));
               if (StrToFloat(sub)<fmin) then
               begin
                  fmin:=StrToFloat(sub);
               end;
               if (StrToFloat(sub)>fmax) then
               begin
                  fmax:=StrToFloat(sub);
               end;
               Formresidual.cht1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
               s:=Trim(Copy(s,Pos(' ',s),Length(s)));
               sub:=Trim(Copy(s,1,Pos(' ',s)));
               if (length(sub)>0) then
               begin
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  Formresidual.cht1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     Formresidual.cht1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=s;
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        Formresidual.cht1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                     end
                     else
                     begin
                        // TODO
                        // обрыв данных после первых трёх значений.
                     end;

                end
                else
                begin
                   // TODO
                   // обрыв данных после двух первых значений.
                end;
            end
            else
            begin
               // TODO
               // обрыв данных.
            end;
            Formresidual.cht1.LeftAxis.Minimum:=fmin;
            Formresidual.cht1.LeftAxis.Maximum:=fmax;
         end;
            end;
         f.Clear;
         f.Free;

          if (Laplas.egddata.myflmod[0].iturbmodel=6) then
         begin
            // модель ламинарно турбулентного перехода Ментора Лангтрии.
            FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=true;
            FormResidual_Langtry_Menter.Show;
         end
         else
         if (Laplas.egddata.myflmod[0].iturbmodel=5) then
         begin
            // Standart K-Epsilon model.
            FormResidualStandartKEpsilon.brun_visibleKEpsilon:=true;
            FormResidualStandartKEpsilon.Show;
         end
         else
         if (Laplas.egddata.myflmod[0].iturbmodel=4) then
         begin
            // SST Ментер 1993.
            FormResidualSST.brun_visibleSST:=true;
            FormResidualSST.Show;
         end
         else
         if (Laplas.egddata.myflmod[0].iturbmodel=3) then
         begin
            // Спаларт Аллмарес 1992.
            FormResidualSpallart_Allmares.brun_visibleSA:=true;
            FormResidualSpallart_Allmares.Show;
         end
         else
         begin
            // Ламинарный
            Formresidual.brun_visible:=true;
            Formresidual.Show;
         end;
     end
     else
     begin
        Laplas.MainMemo.Lines.Add('file statistic_convergence.txt  unfound.');
     end;
      end;

      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FileExists('report_temperature.txt')) then
         begin
            WinExec('notepad.exe report_temperature.txt',sw_ShowNormal);
         end;
         (*
         if (lbclone<300) then
         begin
            // Если будет больше 300 блоков то загружаться репорт
            // будет очень долго.
            if (FileExists('report_temperature.txt')) then
            begin
               f3:=TStringList.Create();
               f:=TStringList.Create();
               f.LoadFromFile('report_temperature.txt');
               //Laplas.MainMemo.Lines.Add(f.Strings[0]);
               f3.Add(f.Strings[0]);
               for i:=0 to lbclone-1 do
               begin
                  //Laplas.MainMemo.Lines.Add(f.Strings[i+1]);
                  f3.Add(f.Strings[i+1]);
               end;
               for i:=0 to lsclone-1 do
               begin
                 //Laplas.MainMemo.Lines.Add(f.Strings[i+lbclone+1]);
                 f3.Add(f.Strings[i+lbclone+1]);
               end;
               for i:=0 to lwclone-1 do
               begin
                  //Laplas.MainMemo.Lines.Add(f.Strings[i+lbclone+lsclone+1]);
                  f3.Add(f.Strings[i+lbclone+lsclone+1]);
               end;
               //DeleteFile('solver/solid_static/report_temperature.txt');
               // Ускоренная загрузка репорта в программу интерфейс.
               Laplas.MainMemo.Lines.AddStrings(f3);
               f3.Clear;
               f3.Free;
               f.Clear;
               f.Free;
             end
              else
             begin
                Laplas.MainMemo.Lines.Add('report_temperature.txt not found.');
             end;
         end
          else
         begin
             Laplas.MainMemo.Lines.Add('report temperature do not load. lb>=300.');
            Laplas.MainMemo.Lines.Add('synopsis: very big file...');
         end;
         *)
      end;

     // Освобождение оперативной памяти.
      SetLength(wallname,0);
      SetLength(sourcename,0);
      SetLength(bodyname,0);
      SetLength(is_hollow,0);

     Laplas.brun:=false;

     Laplas.bonly_mesh_gen_call:=false;

     Laplas.bVisualization_Management_now:=false;
end;

// Нужно создать процедуру Execute, уже описанную в классе TMyThread
procedure TLaplas.SerialExecute3;
var
  // StartupInfo : TStartupInfo;
   //ProcessInfo : TProcessInformation;
   f, f3 : TStringList;
   ShellInfo : TShellExecuteInfo;
   ExitCode : DWORD;
   QuoteParams : Boolean;
   i : Integer;
   starttime, endtime, deltatime : TTime;
   bodyname, sourcename, wallname : array of string;
   is_hollow : array of boolean;
   lbclone, lsclone, lwclone : Integer;

   s,subx,sub : String; // текущая рабочая строка
   fmin, fmax : Real;
begin



        // Надо сделать копию имён block, source и wall перед запуском.
        lbclone:=Laplas.lb;
        lsclone:=Laplas.ls;
        lwclone:=Laplas.lw;
         SetLength(bodyname,lbclone);
         SetLength(is_hollow,lbclone);
         for i:=0 to lbclone-1 do
         begin
           bodyname[i]:=Laplas.body[i].name;
           if (Laplas.body[i].itype=2) then
           begin
              // HOLLOW
              is_hollow[i]:=true;
           end
           else
           begin
              is_hollow[i]:=false;
           end;
         end;
         SetLength(sourcename,lsclone);
         for i:=0 to lsclone-1 do
         begin
            sourcename[i]:=Laplas.source[i].name;
         end;
         SetLength(wallname,lwclone);
          for i:=0 to lwclone-1 do
         begin
           wallname[i]:=Laplas.wall[i].name;
         end;

        starttime:=Now();




        ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        if (FormSetting.rgParallel.ItemIndex=0) then
        begin
           //ShellInfo.lpFile:=PChar('"test_pattern\solver\conjugate_heat_transfer_static\AliceFlow_v0_26.exe"');
           // 29.01.2017
           //ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_30.exe"');
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x64\AliceFlow_v0_48.exe"');
        end;
        if (FormSetting.rgParallel.ItemIndex=1) then
        begin
            ShellInfo.lpFile:=PChar('"test_pattern\solver\x86\AliceFlow_v0_48.exe"');
        end;
         if (FormSetting.rgParallel.ItemIndex=2) then
        begin
           ShellInfo.lpFile:=PChar('"test_pattern\solver\x64_float\AliceFlow_v0_48.exe"');
        end;
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;


         // удаляем ненужные файлы.
      DeleteFile('ALICEFLOW0_06_temp_part1.txt');
      DeleteFile('ALICEFLOW0_06_temp_part3.txt');


       if (FileExists('report_temperature.txt')) then
      begin
         WinExec('notepad.exe report_temperature.txt',sw_ShowNormal);
      end;

      endtime:=Now();
      deltatime:=endtime-starttime;
      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         Laplas.MainMemo.Lines.Add('The calculation is completed.');
         Laplas.MainMemo.Lines.Add('Time calculation equals '+TimeToStr(deltatime));
      end
        else
      begin
         Laplas.MainMemo.Lines.Add('The mesh generation is completed.');
         Laplas.MainMemo.Lines.Add('Time mesh generation equals '+TimeToStr(deltatime));
      end;

      if (not(FormUnsteady.CheckBoxdonttec360.Checked))  then
      begin
         // вызов программы tecplot360
         // WinExec('C:/Program Files (x86)/Tecplot/Tec360 2008/bin/tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
         if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
              begin
                 WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT'),SW_SHOWNORMAL);
              end
         else
        begin
     if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
        begin
           WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
        end
         else
        begin
           if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
           begin
              WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
           end
            else
           begin
              if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
              begin
                WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
              end
               else
              begin
                 if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                 begin
                    WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                 end
                  else
                 begin
                    Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 unfound.');
                 end;
              end;
           end;
        end;
     end;
      end;

      if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (Laplas.egddata.itemper>0) then
         begin

            if (FileExists('statistic_convergence.txt')) then
            begin
               f:=TStringList.Create();
               f.LoadFromFile('statistic_convergence.txt');

               if (FormatSettings.DecimalSeparator=',') then
               begin
                  // заменить все точки в файле на запятые.
                  for i:=0 to f.Count-1 do
                  begin
                     s:=f.Strings[i];
                     f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
                  end;
               end;

               if ((Laplas.egddata.myflmod[0].iflowregime=1)and
             (Laplas.egddata.myflmod[0].iturbmodel=6)) then
            begin
               // Standart K-Epsilon model на основек двухслойной модели.
               // первые две строки нужно пропустить.
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[0].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[1].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[2].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[3].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[4].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[5].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[6].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[7].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[8].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                            s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);


                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[7].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              if (Pos(s,' ')>0) then
                              begin
                                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                              end
                              else
                              begin
                                 sub:=Trim(Copy(s,1,length(s)));
                              end;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[8].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                              end
                               else
                              begin
                                 // TODO
                                 // обрыв данных после первых трёх значений.
                              end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                        end;
                        end;
                        end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidual_Lagtry_Menter_Temp.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidual_Lagtry_Menter_Temp.Chart1.LeftAxis.Maximum:=fmax;
                end;


                f.Free;
                Formresidual2.brun_visible2:=false;
                FormResidualSATemp.brun_visibleSA2:=false;
                FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=true;
                FormResidual_Lagtry_Menter_Temp.Show;
            end
            else
            if ((Laplas.egddata.myflmod[0].iflowregime=1)and
             (Laplas.egddata.myflmod[0].iturbmodel=5)) then
            begin
               // Standart K-Epsilon model на основек двухслойной модели.
               // первые две строки нужно пропустить.
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[0].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[1].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[2].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[3].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[4].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[5].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[6].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                            s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              if (Pos(s,' ')>0) then
                              begin
                                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                              end
                              else
                              begin
                                 sub:=Trim(Copy(s,1,length(s)));
                              end;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                              end
                               else
                              begin
                                 // TODO
                                 // обрыв данных после первых трёх значений.
                              end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                        end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualStandart_k_epsilon_Temp.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualStandart_k_epsilon_Temp.Chart1.LeftAxis.Maximum:=fmax;
                end;


                f.Free;
                Formresidual2.brun_visible2:=false;
                FormResidualSATemp.brun_visibleSA2:=false;
                FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=true;
                FormResidualStandart_k_epsilon_Temp.Show;
            end
            else
            if ((Laplas.egddata.myflmod[0].iflowregime=1)and
             (Laplas.egddata.myflmod[0].iturbmodel=4)) then
            begin
               // K-Omega SST.
               // первые две строки нужно пропустить.
               FormResidualSSTTemp.Chart1.SeriesList[0].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[1].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[2].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[3].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[4].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[5].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[6].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSSTTemp.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSSTTemp.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSSTTemp.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSSTTemp.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                            s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidualSSTTemp.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSSTTemp.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              if (Pos(s,' ')>0) then
                              begin
                                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                              end
                              else
                              begin
                                 sub:=Trim(Copy(s,1,length(s)));
                              end;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualSSTTemp.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                              end
                               else
                              begin
                                 // TODO
                                 // обрыв данных после первых трёх значений.
                              end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                        end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSSTTemp.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSSTTemp.Chart1.LeftAxis.Maximum:=fmax;
                end;


                f.Free;
                Formresidual2.brun_visible2:=false;
                FormResidualSATemp.brun_visibleSA2:=false;
                FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                FormResidualSSTTemp.brun_visibleSSTTemp:=true;
                FormResidualSSTTemp.Show;
            end
            else
            if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                (Laplas.egddata.myflmod[0].iturbmodel=3)) then
            begin
               // Спаларт Аллмарес с температурой.
               // первые две строки нужно пропустить.
               FormResidualSATemp.Chart1.SeriesList[0].Clear;
               FormResidualSATemp.Chart1.SeriesList[1].Clear;
               FormResidualSATemp.Chart1.SeriesList[2].Clear;
               FormResidualSATemp.Chart1.SeriesList[3].Clear;
               FormResidualSATemp.Chart1.SeriesList[4].Clear;
               FormResidualSATemp.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSATemp.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSATemp.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSATemp.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSATemp.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSATemp.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualSATemp.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                              end
                               else
                              begin
                                 // TODO
                                 // обрыв данных после первых трёх значений.
                              end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSATemp.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSATemp.Chart1.LeftAxis.Maximum:=fmax;
                end;
                 f.Free;
                 FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                 FormResidualSATemp.brun_visibleSA2:=true;
                 FormResidualSATemp.Show;
            end
            else
            begin
              // первые две строки нужно пропустить.
              Formresidual2.cht1.SeriesList[0].Clear;
              Formresidual2.cht1.SeriesList[1].Clear;
              Formresidual2.cht1.SeriesList[2].Clear;
              Formresidual2.cht1.SeriesList[3].Clear;
              Formresidual2.cht1.SeriesList[4].Clear;
              for i:=2 to f.Count-1 do
              begin
                 fmin:=20.0;
                 fmax:=1.2;
                 s:=Trim(f.Strings[i]);
                 subx:=Trim(Copy(s,1,Pos(' ',s)));
                 s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                 if (StrToFloat(sub)<fmin) then
                 begin
                    fmin:=StrToFloat(sub);
                 end;
                 Formresidual2.cht1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                 s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                 if (StrToFloat(sub)<fmin) then
                 begin
                    fmin:=StrToFloat(sub);
                 end;
                 Formresidual2.cht1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                 s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                 if (StrToFloat(sub)<fmin) then
                 begin
                    fmin:=StrToFloat(sub);
                 end;
                 Formresidual2.cht1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                 s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                 sub:=s;
                 if (StrToFloat(sub)<fmin) then
                 begin
                    fmin:=StrToFloat(sub);
                 end;
                 Formresidual2.cht1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                 s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                 sub:=s;
                 if (StrToFloat(sub)<fmin) then
                 begin
                    fmin:=StrToFloat(sub);
                 end;
                 Formresidual2.cht1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clBlack);


               Formresidual2.cht1.LeftAxis.Minimum:=fmin;
               Formresidual2.cht1.LeftAxis.Maximum:=fmax;
            end;
            f.Clear;
            f.Free;
            FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
            Formresidual2.brun_visible2:=true;
            Formresidual2.Show;
            end;
          end
           else
          begin
            Laplas.MainMemo.Lines.Add('file statistic_convergence.txt  unfound.');
          end;


     end
     else
     begin


      if (FileExists('statistic_convergence.txt')) then
      begin
         f:=TStringList.Create();
         f.LoadFromFile('statistic_convergence.txt');

         if (FormatSettings.DecimalSeparator=',') then
          begin
             // заменить все точки в файле на запятые.
             for i:=0 to f.Count-1 do
             begin
                s:=f.Strings[i];
                f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
             end;
          end;

           if (Laplas.egddata.myflmod[0].iturbmodel=6) then
            begin
               // модель ламинарно турбулентного перехода Ментора-Лангтрии (RANS) [2009].
               // первые две строки нужно пропустить.
               FormResidual_Langtry_Menter.Chart1.SeriesList[0].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[1].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[2].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[3].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[4].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[5].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[6].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[7].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidual_Langtry_Menter.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidual_Langtry_Menter.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidual_Langtry_Menter.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidual_Langtry_Menter.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Langtry_Menter.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Langtry_Menter.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                               s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Langtry_Menter.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);


                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidual_Langtry_Menter.Chart1.SeriesList[7].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                               end
                                else
                               begin
                                  // TODO
                                  // обрыв данных после первых трёх значений.
                               end;
                           end;
                           end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   //FormResidual_Langtry_Menter.Chart1.LeftAxis.Minimum:=fmin;
                   //FormResidual_Langtry_Menter.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else
          if (Laplas.egddata.myflmod[0].iturbmodel=5) then
            begin
               // Standart K-Epsilon model.
               // первые две строки нужно пропустить.
               FormResidualStandartKEpsilon.Chart1.SeriesList[0].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[1].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[2].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[3].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[4].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualStandartKEpsilon.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualStandartKEpsilon.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualStandartKEpsilon.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualStandartKEpsilon.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualStandartKEpsilon.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualStandartKEpsilon.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                               end
                                else
                               begin
                                  // TODO
                                  // обрыв данных после первых трёх значений.
                               end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualStandartKEpsilon.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualStandartKEpsilon.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else
          if (Laplas.egddata.myflmod[0].iturbmodel=4) then
            begin
               // K-Omega SST Menter [1993].
               // первые две строки нужно пропустить.
               FormResidualSST.Chart1.SeriesList[0].Clear;
               FormResidualSST.Chart1.SeriesList[1].Clear;
               FormResidualSST.Chart1.SeriesList[2].Clear;
               FormResidualSST.Chart1.SeriesList[3].Clear;
               FormResidualSST.Chart1.SeriesList[4].Clear;
               FormResidualSST.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSST.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSST.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSST.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSST.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSST.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualSST.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                               end
                                else
                               begin
                                  // TODO
                                  // обрыв данных после первых трёх значений.
                               end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSST.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSST.Chart1.LeftAxis.Maximum:=fmax;
                end;
            end
            else
          if (Laplas.egddata.myflmod[0].iturbmodel=3) then
            begin
               // Спаларт Аллмарес.
               // первые две строки нужно пропустить.
               FormResidualSpallart_Allmares.Chart1.SeriesList[0].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[1].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[2].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[3].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[4].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSpallart_Allmares.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSpallart_Allmares.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSpallart_Allmares.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSpallart_Allmares.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=s;
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSpallart_Allmares.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSpallart_Allmares.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSpallart_Allmares.Chart1.LeftAxis.Maximum:=fmax;
                end;

                f.Free;
                FormResidualSpallart_Allmares.brun_visibleSA:=true;
                FormResidualSpallart_Allmares.Show;
            end
             else
            begin
               // первые две строки нужно пропустить.
               Formresidual.cht1.SeriesList[0].Clear;
               Formresidual.cht1.SeriesList[1].Clear;
               Formresidual.cht1.SeriesList[2].Clear;
               Formresidual.cht1.SeriesList[3].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=1.2;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  Formresidual.cht1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  Formresidual.cht1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  Formresidual.cht1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=s;
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  Formresidual.cht1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                  Formresidual.cht1.LeftAxis.Minimum:=fmin;
                  Formresidual.cht1.LeftAxis.Maximum:=fmax;
               end;
               f.Clear;
               f.Free;
               Formresidual.brun_visible:=true;
               Formresidual.Show;
         end;
      end
      else
      begin
        Laplas.MainMemo.Lines.Add('file statistic_convergence.txt  unfound.');
      end;

      end;
     end;

       if (Laplas.bonly_mesh_gen_call=false) then
      begin
         if (FileExists('report_temperature.txt')) then
         begin
            WinExec('notepad.exe report_temperature.txt',sw_ShowNormal);
         end;
         (*
         if (lbclone<300) then
         begin
            // Если будет больше 300 блоков то загружаться репорт
            // будет очень долго.
            if (FileExists('report_temperature.txt')) then
            begin
               f3:=TStringList.Create();
               f:=TStringList.Create();
               f.LoadFromFile('report_temperature.txt');
               //Laplas.MainMemo.Lines.Add(f.Strings[0]);
               f3.Add(f.Strings[0]);
               for i:=0 to lbclone-1 do
               begin
                  //Laplas.MainMemo.Lines.Add(f.Strings[i+1]);
                  f3.Add(f.Strings[i+1]);
               end;
               for i:=0 to lsclone-1 do
               begin
                  //Laplas.MainMemo.Lines.Add(f.Strings[i+lbclone+1]);
                  f3.Add(f.Strings[i+lbclone+1]);
               end;
               for i:=0 to lwclone-1 do
               begin
                  //Laplas.MainMemo.Lines.Add(f.Strings[i+lbclone+lsclone+1]);
                  f3.Add(f.Strings[i+lbclone+lsclone+1]);
               end;
               //DeleteFile('solver/solid_static/report_temperature.txt');
               // Ускоренная загрузка больших репортов в программу.
               Laplas.MainMemo.Lines.AddStrings(f3);
               f3.Clear;
               f3.Free;
               f.Clear;
               f.Free;
            end
             else
            begin
               Laplas.MainMemo.Lines.Add('report_temperature.txt not found.');
            end;
         end
          else
         begin
             Laplas.MainMemo.Lines.Add('report temperature do not load. lb>=300.');
            Laplas.MainMemo.Lines.Add('synopsis: very big file...');
         end;
         *)
      end;

      // Освобождение оперативной памяти.
      SetLength(wallname,0);
      SetLength(sourcename,0);
      SetLength(bodyname,0);
      SetLength(is_hollow,0);

      Laplas.brun:=false;
      Laplas.bonly_mesh_gen_call:=false;

      Laplas.bVisualization_Management_now:=false;
end;




function TLaplas.GetSource(Index : integer) : TPlane;
begin
  Result:=source[Index];
end;


// Вычисляет объем блока.
 function TLaplas.volume(b : Tbody) : Real;
 var
   x1min, x1max : Real;
   x2min, x2max : Real;
   i_1 : Integer;
 begin
     if (b.igeometry_type=0) then
     begin
         // Prism
         Result:=abs(b.xE-b.xS)*abs(b.yE-b.yS)*abs(b.zE-b.zS);
     end;
     if (b.igeometry_type=1) then
     begin
        // Cylinder
        if (abs(b.angle_end-b.angle_start)<0.5) then
        begin
           b.angle_end:=360.0;
        end;
        Result:=(abs(b.angle_end-b.angle_start)/360.0)*b.Hcyl*3.141*(b.R_out_cyl*b.R_out_cyl-b.R_in_cyl*b.R_in_cyl);
     end;
     (*
     if (b.igeometry_type=2) then
     begin
        // Polygon
        x1min:=1.0e30;
        x2min:=1.0e30;
        x1max=-1.0e30;
        x2max:=-1.0e30;
        for i_1 := 0 to b.nsizei do
        begin
           if (b.iPlane_obj2=1) then
            begin
                // XY

           //if ( then
            end;
        end;



                         // работает только для треугольника
                         // и только для всюду одинаковых высот.
                         if (body[i_4].nsizei<3) then
                         begin
                            ShowMessage('Polygon error: nsizei<3');
                         end;
                         if (body[i_4].nsizei=3) then
                         begin
                            case body[i_4].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      massa:=massa+rdensity*(abs(body[i_4].hi[0]))*((body[i_4].xi[1]-body[i_4].xi[0])*(body[i_4].yi[2]-body[i_4].yi[0])-(body[i_4].yi[1]-body[i_4].yi[0])*(body[i_4].xi[2]-body[i_4].xi[0]));
                                   end;
                               2: begin
                                     // XZ
                                      massa:=massa+rdensity*(abs(body[i_4].hi[0]))*((body[i_4].xi[1]-body[i_4].xi[0])*(body[i_4].zi[2]-body[i_4].zi[0])-(body[i_4].zi[1]-body[i_4].zi[0])*(body[i_4].xi[2]-body[i_4].xi[0]));
                                  end;
                               3 : begin
                                      // YZ
                                       massa:=massa+rdensity*(abs(body[i_4].hi[0]))*((body[i_4].yi[1]-body[i_4].yi[0])*(body[i_4].zi[2]-body[i_4].zi[0])-(body[i_4].zi[1]-body[i_4].zi[0])*(body[i_4].yi[2]-body[i_4].yi[0]));
                                   end;
                            end;
                         end;
                         if (body[i_4].nsizei>3) then
                         begin
                            //   Только выпуклый полигон, его площадь аппроксимирована
                            // суммой площадей составляющих его треугольников.
                            // Центр масс.
                            xavg:=0.0;
                            yavg:=0.0;
                            zavg:=0.0;
                            for j := 0 to body[i_4].nsizei-1 do
                            begin
                               xavg:=xavg+body[i_4].xi[j];
                               yavg:=yavg+body[i_4].yi[j];
                               zavg:=zavg+body[i_4].zi[j];
                            end;
                            xavg:=xavg/body[i_4].nsizei;
                            yavg:=yavg/body[i_4].nsizei;
                            zavg:=zavg/body[i_4].nsizei;

                            for j := 0 to body[i_4].nsizei-2 do
                            begin
                            case body[i_4].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      massa:=massa+rdensity*(abs(body[i_4].hi[0]))*((body[i_4].xi[j]-xavg)*(body[i_4].yi[j+1]-yavg)-(body[i_4].yi[j]-yavg)*(body[i_4].xi[j+1]-xavg));
                                   end;
                               2: begin
                                     // XZ
                                      massa:=massa+rdensity*(abs(body[i_4].hi[0]))*((body[i_4].xi[j]-xavg)*(body[i_4].zi[j+1]-zavg)-(body[i_4].zi[j]-zavg)*(body[i_4].xi[j+1]-xavg));
                                  end;
                               3 : begin
                                      // YZ
                                       massa:=massa+rdensity*(abs(body[i_4].hi[0]))*((body[i_4].yi[j]-yavg)*(body[i_4].zi[j+1]-zavg)-(body[i_4].zi[j]-zavg)*(body[i_4].yi[j+1]-yavg));
                                   end;
                            end;
                            end;
                         end;
                      end;
                      *)
 end;

procedure TLaplas.SetSource(Index : integer; Value : TPlane);
begin
   source[Index]:=Value;
end;

function TLaplas.GetWall(Index : integer) : TPlane;
begin
  Result:=wall[Index];
end;

procedure TLaplas.SetWall(Index : integer; Value : TPlane);
begin
   wall[Index]:=Value;
end;



// преобразование оконных координат в сценовые.
// Z - буфер должен быть обязательным образом включён.
function  TLaplas.GetOGLPos( x : Integer;  y : Integer):Pointxy;
var
   viewport : TVector4i;
   modelview, projection : TGLMatrixd4;
   posx, posy, posz : GLdouble; // возвращает мировые x,y,z координаты.
   rY : glInt;   // позиция y координаты.
   rZ : glFloat;
   ret : Pointxy;
begin

   posx:=0.0;
   posy:=0.0;
   posz:=0.0;

   glGetDoubleV( GL_MODELVIEW_MATRIX, @modelview );
   glGetDoubleV( GL_PROJECTION_MATRIX, @projection );
   glGetIntegerv( GL_VIEWPORT, @viewport );



   rY:=viewport[3]-y-1;

   glReadPixels( x, rY, 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, @rZ );
   gluUnProject( x, rY, rZ, modelview, projection, viewport, @posx, @posy, @posz);


   ret.x:=posx;
   ret.y:=posy;
   ret.z:=posz;
   Result:=ret;
end;

procedure TLaplas.ColorToGL(c7 : TColor;var dcol7 : TColor; var R7, G7, B7 : GLFloat);
begin
   dcol7:=c7;
   R7:=( c7 mod $100) / 255.0;
   G7:=(( c7 div $100) mod $100) / 255.0;
   B7:=( c7 div $10000) / 255.0;
end;

//  Какую полевую величину визуализируем.
procedure TLaplas.ComboBoxVisibleVariableChange(Sender: TObject);
var
  i : Integer;
begin
   icurrentpic:=ComboBoxVisibleVariable.ItemIndex;
   if (icurrentpic=nvalpic+1) then
   begin
      // Отключение показа считанного файла с данными.
      bvisiblepic:=false;
      icurrentpic:=0;
      Panel_shkala.Visible:=false;
   end
   else
   begin
      if (bvisiblepicdubl=true) then
      begin
         // Только если файл с геометрией был ранее считан
         // и соответствующие структуры данных уже заполнены.
         bvisiblepic:=true;

         if (icurrentpic>0) then
         begin
            LabelTitle.Caption:=temppicname[icurrentpic];
            for i := 1 to 9 do
              begin
                 case i of
                    1 : begin
                       LabelShcala9.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     2 : begin
                       LabelShcala8.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     3 : begin
                       LabelShcala7.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     4 : begin
                       LabelShcala6.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     5 : begin
                       LabelShcala5.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     6 : begin
                       LabelShcala4.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     7 : begin
                       LabelShcala3.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     8 : begin
                       LabelShcala2.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     9 : begin
                       LabelShcala1.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                 end;
              end;


            Panel_shkala.Visible:=true;
         end
          else
         begin
            Panel_shkala.Visible:=false;
         end;
      end;
   end;
   // OpenGL part.
   if (not(bvisiblepic)) then
    begin
       glPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
       // показать передние и задние стороны полигона линиями
    end
    else
    begin
       if ((icurrentpic=0)or(ComboBoxVisibleVariable.ItemIndex=nvalpic+1)) then
       begin
         // Расчётная сетка или геометрия.
         glPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
         // показать передние и задние стороны полигона линиями
       end
        else
       begin
          glPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
       end;
    end;
end;

procedure TLaplas.SetupGL;
begin
   //glClearColor(0.0,0.0,0.0,0.0); //цвет фона
   //glClearColor (0.5, 0.5, 0.75, 1.0); //Цвет фона
   glClearColor (1.0, 1.0, 1.0, 1.0); //Цвет фона белый
end;

procedure TLaplas.IdleHandler(Sender: TObject; var Done: Boolean);
begin
   if (ecology_btn) then
   begin
      Render;
      Sleep(isleep_render);  //5
      Done:=False;
   end;
end;


// Задаёт начальную скорость в расчётной области.
procedure TLaplas.Initialization1Click(Sender: TObject);
var
   s : String;
begin
    if (FormatSettings.DecimalSeparator=',') then
    begin
        // заменить все точки в FormSpeedInitialization на запятые.
        s:=FormSpeedInitialization.EditVx.Text;
        FormSpeedInitialization.EditVx.Text:=StringReplace(s,'.',',',[rfReplaceAll]);

        s:=FormSpeedInitialization.EditVy.Text;
        FormSpeedInitialization.EditVy.Text:=StringReplace(s,'.',',',[rfReplaceAll]);

        s:=FormSpeedInitialization.EditVz.Text;
        FormSpeedInitialization.EditVz.Text:=StringReplace(s,'.',',',[rfReplaceAll]);

    end;
     if (FormatSettings.DecimalSeparator='.') then
    begin
        // заменить все точки в FormSpeedInitialization на запятые.
        s:=FormSpeedInitialization.EditVx.Text;
        FormSpeedInitialization.EditVx.Text:=StringReplace(s,',','.',[rfReplaceAll]);

        s:=FormSpeedInitialization.EditVy.Text;
        FormSpeedInitialization.EditVy.Text:=StringReplace(s,',','.',[rfReplaceAll]);

        s:=FormSpeedInitialization.EditVz.Text;
        FormSpeedInitialization.EditVz.Text:=StringReplace(s,',','.',[rfReplaceAll]);

    end;
    FormSpeedInitialization.ShowModal;
end;

procedure TLaplas.ReadyPaint; // подготавливает данные к визуализации.
begin
   //ReadyPaint1;
    // Более поздняя версия в которой улучшены
    // характеристики быстродействия.
    if (rgview.ItemIndex=1) then
    begin
       // Применяем подготовку только в том случае
       // если прорисовка использует Z-буффер.
      ReadyPaint2;
    end;
end;


function TLaplas.return_Perspective_angle(var rangle_counter : Real) : Real;
begin
     if (rangle_counter>8000.0) then
    begin
        rangle_counter:=8000.0;
    end;
      if (rangle_counter<-8000.0) then
    begin
        rangle_counter:=-8000.0;
    end;
    // arctan(0.08*8000)=1.5692338280665;

    //result:=90.0+90.0*arctan(0.08*rangle_counter)/1.57079632675;
     result:=90.0+90.0*arctan(0.08*rangle_counter)/1.5692339;
     // отличие лишь в 7 знаке после запятой - гарантия отсутствия значения 0 и 180 градусов.
end;

procedure TLaplas.ReadyPaint1; // подготавливает данные к визуализации.
var
   x1, y1, z1 : array of Real;
   i,j,k,isel,ib : Integer;
   xc, yc, zc, epsilon_tol : Real;
   bonlyfluid, bisox, bisoy, bisoz, biso, bfound : Boolean;
   isovalgx, isovalgy, isovalgz : Real;
   // -1 нет блока. >=0 номер блока. -2 - объединение первого уровня.
   mask : array of array of array of Integer; // маска для последующего объединения.
   bid : array of array of array of Integer; // номер исходного блока.
   bmask : array of array of array of Boolean;
   bg : array of GBody;
   vgloc : array of VisibleGran;
   vl : array of Visible_Line; // избирает только те отрезки которые нужно прорисовывать.
   lvl, j1 : Integer;
    epsx, epsy, epsz : Real;
   sbuf : String;
   rbuf : Real;



procedure Pushx(r : Real);
var
   ilen : Integer;
   bfound : Boolean;
begin
   bfound:=False;
   for ilen:=0 to Length(x1)-1 do
   begin
      if (Abs(x1[ilen]-r)<1e-15 ) then
      begin
         bfound:=True;
         Break;
      end;
   end;
   if (not(bfound)) then
   begin
      SetLength(x1, Length(x1)+1);
      x1[Length(x1)-1]:=r;
   end;
end;

procedure Pushy(r : Real);
var
   ilen : Integer;
   bfound : Boolean;
begin
   bfound:=False;
   for ilen:=0 to Length(y1)-1 do
   begin
      if (Abs(y1[ilen]-r)<1e-15 ) then
      begin
         bfound:=True;
         Break;
      end;
   end;
   if (not(bfound)) then
   begin
      SetLength(y1, Length(y1)+1);
      y1[Length(y1)-1]:=r;
   end;
end;

procedure Pushz(r : Real);
var
   ilen : Integer;
   bfound : Boolean;
begin
   bfound:=False;
   for ilen:=0 to Length(z1)-1 do
   begin
      if (Abs(z1[ilen]-r)<1e-15 ) then
      begin
         bfound:=True;
         Break;
      end;
   end;
   if (not(bfound)) then
   begin
      SetLength(z1, Length(z1)+1);
      z1[Length(z1)-1]:=r;
   end;
end;

// Пузырьковая сортировка по x.
procedure BubbleSortx;
var
   i2, j2 : Integer;
   xchange : Real;
begin


   for i2:=1 to Length(x1)-1 do
   begin
	   for j2:=Length(x1)-1 downto i2 do
     begin
     		if (x1[j2-1] > x1[j2]) then
        begin
			     // swap
			     xchange:=x1[j2-1];
			     x1[j2-1]:=x1[j2];
			     x1[j2]:=xchange;
		    end;
	   end;
   end;
end; // BubbleSortx

// Пузырьковая сортировка по y.
procedure BubbleSorty;
var
   i2, j2 : Integer;
   ychange : Real;
begin


   for i2:=1 to Length(y1)-1 do
   begin
	   for j2:=Length(y1)-1 downto i2 do
     begin
     		if (y1[j2-1] > y1[j2]) then
        begin
			     // swap
			     ychange:=y1[j2-1];
			     y1[j2-1]:=y1[j2];
			     y1[j2]:=ychange;
		    end;
	   end;
   end;
end; // BubbleSorty

// Пузырьковая сортировка по z.
procedure BubbleSortz;
var
   i2, j2 : Integer;
   zchange : Real;
begin
   for i2:=1 to Length(z1)-1 do
   begin
	   for j2:=Length(z1)-1 downto i2 do
     begin
     		if (z1[j2-1] > z1[j2]) then
        begin
			     // swap
			     zchange:=z1[j2-1];
			     z1[j2-1]:=z1[j2];
			     z1[j2]:=zchange;
		    end;
	   end;
   end;
end; // BubbleSortz

begin
   // Подготовительный этап к визуализации графики на основе OpenGL.
   // Производим анализ области и автоматом делаём вырезы, т.к. любая композиция
   // прямоугольных параллелепипедов после операций объеинения и вырезания снова становится
   // композицией прямоугольных параллелепипедов.

   // ShowMessage('Ready Paint'); // debug.

   // Если xS > xE то это приводит к ошибке визуализации,
   // аналогично должно быть yS, yE, zS, zE.
   // Организуем переупорядочивание.
   for isel := 0 to lb-1 do
   begin
      if (body[isel].xS>body[isel].xE) then
      begin
         sbuf:=body[isel].sxS;
         body[isel].sxS:=body[isel].sxE;
         body[isel].sxE:=sbuf;
         rbuf:=body[isel].xS;
         body[isel].xS:=body[isel].xE;
         body[isel].xE:=rbuf;
      end;
      if (body[isel].yS>body[isel].yE) then
      begin
         sbuf:=body[isel].syS;
         body[isel].syS:=body[isel].syE;
         body[isel].syE:=sbuf;
         rbuf:=body[isel].yS;
         body[isel].yS:=body[isel].yE;
         body[isel].yE:=rbuf;
      end;
      if (body[isel].zS>body[isel].zE) then
      begin
         sbuf:=body[isel].szS;
         body[isel].szS:=body[isel].szE;
         body[isel].szE:=sbuf;
         rbuf:=body[isel].zS;
         body[isel].zS:=body[isel].zE;
         body[isel].zE:=rbuf;
      end;
   end;


   SetLength(x1,2);
   SetLength(y1,2);
   SetLength(z1,2);

   x1[0]:=body[1].xS;
   x1[1]:=body[1].xE;
   for isel:=2 to lb-1 do
   begin
      Pushx(body[isel].xS);
      Pushx(body[isel].xE);
   end;
   // сортировка по возрастанию.
   BubbleSortx;

   epsx:=1e30;
   for i:=1 to length(x1)-1 do
   begin
      if (epsx>abs(x1[i]-x1[i-1])) then
      begin
         epsx:=abs(x1[i]-x1[i-1]);
      end;
   end;
   epsx:=epsx*0.5;



   y1[0]:=body[1].yS;
   y1[1]:=body[1].yE;
   for isel:=2 to lb-1 do
   begin
      Pushy(body[isel].yS);
      Pushy(body[isel].yE);
   end;
   // сортировка по возрастанию.
   BubbleSorty;

   epsy:=1e30;
   for i:=1 to length(y1)-1 do
   begin
      if (epsy>abs(y1[i]-y1[i-1])) then
      begin
         epsy:=abs(y1[i]-y1[i-1]);
      end;
   end;
   epsy:=epsy*0.5;

   z1[0]:=body[1].zS;
   z1[1]:=body[1].zE;
   for isel:=2 to lb-1 do
   begin
      Pushz(body[isel].zS);
      Pushz(body[isel].zE);
   end;
   // сортировка по возрастанию.
   BubbleSortz;

    epsz:=1e30;
   for i:=1 to length(z1)-1 do
   begin
      if (epsz>abs(z1[i]-z1[i-1])) then
      begin
         epsz:=abs(z1[i]-z1[i-1]);
      end;
   end;
   epsz:=epsz*0.5;


   biso:=False;
   bisox:=False;
   bisoy:=False;
   bisoz:=False;
   // Теперь сделаем учёт рассекающей плоскости :
   case cbbview.ItemIndex of
   1 : // XY
       begin
          isovalgz:=StrToFloat(edtvalue.Text);
          Pushz(isovalgz);
          BubbleSortz;
          bisoz:=True;
       end;
   2 : // XZ
       begin
          isovalgy:=StrToFloat(edtvalue.Text);
          Pushy(isovalgy);
          BubbleSorty;
          bisoy:=True;
       end;
   3 : // YZ
       begin
          isovalgx:=StrToFloat(edtvalue.Text);
          Pushx(isovalgx);
          BubbleSortx;
          bisox:=True;
       end;
   end;
   biso:=bisox or bisoy or bisoz;

   SetLength(mask,Length(x1),Length(y1),Length(z1));
   SetLength(bid,Length(x1),Length(y1),Length(z1));
   for i:=0 to Length(x1)-1 do
   begin
      for j:=0 to Length(y1)-1 do
      begin
         for k:=0 to Length(z1)-1 do
         begin
            mask[i][j][k]:=-1;
            bid[i][j][k]:=-1;

         end;
      end;
   end;

   SetLength(blockgraphics,0);
   bonlyfluid:=True;
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            xc:=0.5*(x1[i]+x1[i+1]);
            yc:=0.5*(y1[j]+y1[j+1]);
            zc:=0.5*(z1[k]+z1[k+1]);

            if ((not(biso)) or (bisox and (xc<isovalgx)) or (bisoy and (yc<isovalgy)) or (bisoz and (zc<isovalgz))) then
            begin

               ib:=0; // номер блока к которому принадлежит.
               for isel:=1 to lb-1 do
               begin
                  if ((xc>body[isel].xS) and (xc<body[isel].xE) and (yc>body[isel].yS) and (yc<body[isel].yE)  and (zc>body[isel].zS) and (zc<body[isel].zE)) then
                  begin
                     ib:=isel;
                  end;
               end;
               // только Solid.
               if ((ib<>0) and (body[ib].itype=1)and (body[ib].bvisible)) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].xS:=x1[i];
                  blockgraphics[Length(blockgraphics)-1].xE:=x1[i+1];
                  blockgraphics[Length(blockgraphics)-1].yS:=y1[j];
                  blockgraphics[Length(blockgraphics)-1].yE:=y1[j+1];
                  blockgraphics[Length(blockgraphics)-1].zS:=z1[k];
                  blockgraphics[Length(blockgraphics)-1].zE:=z1[k+1];
                  // наследуем цвет и прозрачность.
                  blockgraphics[Length(blockgraphics)-1].redcolor:=body[ib].redcolor;
                  blockgraphics[Length(blockgraphics)-1].greencolor:=body[ib].greencolor;
                  blockgraphics[Length(blockgraphics)-1].bluecolor:=body[ib].bluecolor;
                  blockgraphics[Length(blockgraphics)-1].transparency:=body[ib].transparency;
                  blockgraphics[Length(blockgraphics)-1].dcol:=body[ib].dcol;
                  bonlyfluid:=false;
                  mask[i][j][k]:=Length(blockgraphics)-1;
                  bid[i][j][k]:=ib;
               end;
            end;
         end;
      end;
   end;

   // Если нет ни одного SOLID блока к показу то мы визуализируем только
   // Fluid блоки.
   if (bonlyfluid) then
   begin
      for i:=0 to Length(x1)-2 do
      begin
         for j:=0 to Length(y1)-2 do
         begin
            for k:=0 to Length(z1)-2 do
            begin
               xc:=0.5*(x1[i]+x1[i+1]);
               yc:=0.5*(y1[j]+y1[j+1]);
               zc:=0.5*(z1[k]+z1[k+1]);

               if ((not(biso)) or (bisox and (xc<isovalgx)) or (bisoy and (yc<isovalgy)) or (bisoz and (zc<isovalgz))) then
               begin

                  ib:=0; // номер блока к которому принадлежит.
                  for isel:=1 to lb-1 do
                  begin
                     if ((xc>body[isel].xS) and (xc<body[isel].xE) and (yc>body[isel].yS) and (yc<body[isel].yE)  and (zc>body[isel].zS) and (zc<body[isel].zE)) then
                     begin
                        ib:=isel;
                     end;
                  end;
                  // только Solid.
                  if ((ib<>0) and (body[ib].itype=3) and (body[ib].bvisible)) then
                  begin
                     SetLength(blockgraphics,Length(blockgraphics)+1);
                     blockgraphics[Length(blockgraphics)-1].xS:=x1[i];
                     blockgraphics[Length(blockgraphics)-1].xE:=x1[i+1];
                     blockgraphics[Length(blockgraphics)-1].yS:=y1[j];
                     blockgraphics[Length(blockgraphics)-1].yE:=y1[j+1];
                     blockgraphics[Length(blockgraphics)-1].zS:=z1[k];
                     blockgraphics[Length(blockgraphics)-1].zE:=z1[k+1];
                     // наследуем цвет и прозрачность.
                     blockgraphics[Length(blockgraphics)-1].redcolor:=body[ib].redcolor;
                     blockgraphics[Length(blockgraphics)-1].greencolor:=body[ib].greencolor;
                     blockgraphics[Length(blockgraphics)-1].bluecolor:=body[ib].bluecolor;
                     blockgraphics[Length(blockgraphics)-1].transparency:=body[ib].transparency;
                     blockgraphics[Length(blockgraphics)-1].dcol:=body[ib].dcol;
                     mask[i][j][k]:=Length(blockgraphics)-1;
                     bid[i][j][k]:=ib;
                  end;
               end;
            end;
         end;
      end;
   end;


    // подготовка списка линий которые нужно перерисовывать.

    //eps:=1.0e-12;


    lvl:=0;

    for i:=1 to lb-1 do
    begin

       // найти в x1 позицию xS.
       for j1:=0 to length(x1)-1 do
       begin
          if (abs(x1[j1]-body[i].xS)<epsx) then
          begin
              for j:=j1 to length(x1)-2 do
             begin
                // j - это позиция xS.
                if (abs(x1[j+1]-body[i].xE)<epsx) then
                begin
                   // конец найден
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='X';
                   vl[lvl-1].yS:=body[i].yS;
                   vl[lvl-1].yE:=body[i].yS;
                   vl[lvl-1].zS:=body[i].zS;
                   vl[lvl-1].zE:=body[i].zS;
                   vl[lvl-1].xS:=x1[j];
                   vl[lvl-1].xE:=body[i].xE;
                   break;
                end
                 else
                begin
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='X';
                   vl[lvl-1].yS:=body[i].yS;
                   vl[lvl-1].yE:=body[i].yS;
                   vl[lvl-1].zS:=body[i].zS;
                   vl[lvl-1].zE:=body[i].zS;
                   vl[lvl-1].xS:=x1[j];
                   vl[lvl-1].xE:=x1[j+1];
                end;
             end;
             break;
          end;
       end;


       // найти в x1 позицию xS.
       for j1:=0 to length(x1)-1 do
       begin
          if (abs(x1[j1]-body[i].xS)<epsx) then
          begin
             for j:=j1 to length(x1)-2 do
             begin
                // j - это позиция xS.
                if (abs(x1[j+1]-body[i].xE)<epsx) then
                begin
                   // конец найден
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='X';
                   vl[lvl-1].yS:=body[i].yS;
                   vl[lvl-1].yE:=body[i].yS;
                   vl[lvl-1].zS:=body[i].zE;
                   vl[lvl-1].zE:=body[i].zE;
                   vl[lvl-1].xS:=x1[j];
                   vl[lvl-1].xE:=body[i].xE;
                   break;
                end
                 else
                begin
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='X';
                   vl[lvl-1].yS:=body[i].yS;
                   vl[lvl-1].yE:=body[i].yS;
                   vl[lvl-1].zS:=body[i].zE;
                   vl[lvl-1].zE:=body[i].zE;
                   vl[lvl-1].xS:=x1[j];
                   vl[lvl-1].xE:=x1[j+1];
                end;
             end;
             break;
          end;
       end;



       // найти в x1 позицию xS.
       for j1:=0 to length(x1)-1 do
       begin
          if (abs(x1[j1]-body[i].xS)<epsx) then
          begin
             for j:=j1 to length(x1)-2 do
             begin
                // j - это позиция xS.
                if (abs(x1[j+1]-body[i].xE)<epsx) then
                begin
                   // конец найден
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='X';
                   vl[lvl-1].yS:=body[i].yE;
                   vl[lvl-1].yE:=body[i].yE;
                   vl[lvl-1].zS:=body[i].zE;
                   vl[lvl-1].zE:=body[i].zE;
                   vl[lvl-1].xS:=x1[j];
                   vl[lvl-1].xE:=body[i].xE;
                   break;
                end
                 else
                begin
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='X';
                   vl[lvl-1].yS:=body[i].yE;
                   vl[lvl-1].yE:=body[i].yE;
                   vl[lvl-1].zS:=body[i].zE;
                   vl[lvl-1].zE:=body[i].zE;
                   vl[lvl-1].xS:=x1[j];
                   vl[lvl-1].xE:=x1[j+1];
                end;
             end;
             break;
          end;
       end;


       // найти в x1 позицию xS.
       for j1:=0 to length(x1)-1 do
       begin
          if (abs(x1[j1]-body[i].xS)<epsx) then
          begin
             for j:=j1 to length(x1)-2 do
             begin
             // j - это позиция xS.
             if (abs(x1[j+1]-body[i].xE)<epsx) then
             begin
                // конец найден
                 inc(lvl);
                 SetLength(vl,lvl);
                 vl[lvl-1].normal:='X';
                 vl[lvl-1].yS:=body[i].yE;
                 vl[lvl-1].yE:=body[i].yE;
                 vl[lvl-1].zS:=body[i].zS;
                 vl[lvl-1].zE:=body[i].zS;
                 vl[lvl-1].xS:=x1[j];
                 vl[lvl-1].xE:=body[i].xE;
                 break;
             end
             else
             begin
                inc(lvl);
                 SetLength(vl,lvl);
                 vl[lvl-1].normal:='X';
                 vl[lvl-1].yS:=body[i].yE;
                 vl[lvl-1].yE:=body[i].yE;
                 vl[lvl-1].zS:=body[i].zS;
                 vl[lvl-1].zE:=body[i].zS;
                 vl[lvl-1].xS:=x1[j];
                vl[lvl-1].xE:=x1[j+1];
             end;
             end;
             break;
          end;
       end;


       // найти в y1 позицию yS.
       for j1:=0 to length(y1)-1 do
       begin
          if (abs(y1[j1]-body[i].yS)<epsy) then
          begin
             for j:=j1 to length(y1)-2 do
             begin
                // j - это позиция yS.
                if (abs(y1[j+1]-body[i].yE)<epsy) then
                begin
                   // конец найден
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='Y';
                   vl[lvl-1].xS:=body[i].xS;
                   vl[lvl-1].xE:=body[i].xS;
                   vl[lvl-1].zS:=body[i].zS;
                   vl[lvl-1].zE:=body[i].zS;
                   vl[lvl-1].yS:=y1[j];
                   vl[lvl-1].yE:=body[i].yE;
                   break;
                end
                 else
                begin
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='Y';
                   vl[lvl-1].xS:=body[i].xS;
                   vl[lvl-1].xE:=body[i].xS;
                   vl[lvl-1].zS:=body[i].zS;
                   vl[lvl-1].zE:=body[i].zS;
                   vl[lvl-1].yS:=y1[j];
                   vl[lvl-1].yE:=y1[j+1];
                end;
             end;
             break;
          end;
       end;


       // найти в y1 позицию yS.
       for j1:=0 to length(y1)-1 do
       begin
          if (abs(y1[j1]-body[i].yS)<epsy) then
          begin
             for j:=j1 to length(y1)-2 do
             begin
                // j - это позиция yS.
                if (abs(y1[j+1]-body[i].yE)<epsy) then
                begin
                   // конец найден
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Y';
                    vl[lvl-1].xS:=body[i].xS;
                    vl[lvl-1].xE:=body[i].xS;
                    vl[lvl-1].zS:=body[i].zE;
                    vl[lvl-1].zE:=body[i].zE;
                    vl[lvl-1].yS:=y1[j];
                    vl[lvl-1].yE:=body[i].yE;
                    break;
                end
                 else
                begin
                   inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Y';
                    vl[lvl-1].xS:=body[i].xS;
                    vl[lvl-1].xE:=body[i].xS;
                    vl[lvl-1].zS:=body[i].zE;
                    vl[lvl-1].zE:=body[i].zE;
                    vl[lvl-1].yS:=y1[j];
                   vl[lvl-1].yE:=y1[j+1];
                end;
             end;
             break;
          end;
       end;



       // найти в y1 позицию yS.
       for j1:=0 to length(y1)-1 do
       begin
          if (abs(y1[j1]-body[i].yS)<epsy) then
          begin
             for j:=j1 to length(y1)-2 do
             begin
                // j - это позиция yS.
                if (abs(y1[j+1]-body[i].yE)<epsy) then
                begin
                   // конец найден
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='Y';
                   vl[lvl-1].xS:=body[i].xE;
                   vl[lvl-1].xE:=body[i].xE;
                   vl[lvl-1].zS:=body[i].zE;
                   vl[lvl-1].zE:=body[i].zE;
                   vl[lvl-1].yS:=y1[j];
                   vl[lvl-1].yE:=body[i].yE;
                   break;
                end
                 else
                begin
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='Y';
                   vl[lvl-1].xS:=body[i].xE;
                   vl[lvl-1].xE:=body[i].xE;
                   vl[lvl-1].zS:=body[i].zE;
                   vl[lvl-1].zE:=body[i].zE;
                   vl[lvl-1].yS:=y1[j];
                   vl[lvl-1].yE:=y1[j+1];
                end;
             end;
             break;
          end;
       end;


       // найти в y1 позицию yS.
       for j1:=0 to length(y1)-1 do
       begin
          if (abs(y1[j1]-body[i].yS)<epsy) then
          begin
             for j:=j1 to length(y1)-2 do
             begin
                // j - это позиция yS.
                if (abs(y1[j+1]-body[i].yE)<epsy) then
                begin
                   // конец найден
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Y';
                    vl[lvl-1].xS:=body[i].xE;
                    vl[lvl-1].xE:=body[i].xE;
                    vl[lvl-1].zS:=body[i].zS;
                    vl[lvl-1].zE:=body[i].zS;
                    vl[lvl-1].yS:=y1[j];
                    vl[lvl-1].yE:=body[i].yE;
                    break;
                end
                 else
                begin
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Y';
                    vl[lvl-1].xS:=body[i].xE;
                    vl[lvl-1].xE:=body[i].xE;
                    vl[lvl-1].zS:=body[i].zS;
                    vl[lvl-1].zE:=body[i].zS;
                    vl[lvl-1].yS:=y1[j];
                   vl[lvl-1].yE:=y1[j+1];
                end;
             end;
             break;
          end;
       end;


       // найти в z1 позицию zS.
       for j1:=0 to length(z1)-1 do
       begin
          if (abs(z1[j1]-body[i].zS)<epsz) then
          begin
             for j:=j1 to length(z1)-2 do
             begin
                // j - это позиция zS.
                if (abs(z1[j+1]-body[i].zE)<epsz) then
                begin
                   // конец найден
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Z';
                    vl[lvl-1].xS:=body[i].xS;
                    vl[lvl-1].xE:=body[i].xS;
                    vl[lvl-1].yS:=body[i].yS;
                    vl[lvl-1].yE:=body[i].yS;
                    vl[lvl-1].zS:=z1[j];
                    vl[lvl-1].zE:=body[i].zE;
                    break;
                end
                 else
                begin
                   inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Z';
                    vl[lvl-1].xS:=body[i].xS;
                    vl[lvl-1].xE:=body[i].xS;
                    vl[lvl-1].yS:=body[i].yS;
                    vl[lvl-1].yE:=body[i].yS;
                    vl[lvl-1].zS:=z1[j];
                   vl[lvl-1].zE:=z1[j+1];
                end;
             end;
             break;
          end;
       end;


       // найти в z1 позицию zS.
       for j1:=0 to length(z1)-1 do
       begin
          if (abs(z1[j1]-body[i].zS)<epsz) then
          begin
             for j:=j1 to length(z1)-2 do
             begin
                // j - это позиция zS.
                if (abs(z1[j+1]-body[i].zE)<epsz) then
                begin
                   // конец найден
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Z';
                    vl[lvl-1].xS:=body[i].xS;
                    vl[lvl-1].xE:=body[i].xS;
                    vl[lvl-1].yS:=body[i].yE;
                    vl[lvl-1].yE:=body[i].yE;
                    vl[lvl-1].zS:=z1[j];
                    vl[lvl-1].zE:=body[i].zE;
                    break;
                end
                 else
                begin
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Z';
                    vl[lvl-1].xS:=body[i].xS;
                    vl[lvl-1].xE:=body[i].xS;
                    vl[lvl-1].yS:=body[i].yE;
                    vl[lvl-1].yE:=body[i].yE;
                    vl[lvl-1].zS:=z1[j];
                   vl[lvl-1].zE:=z1[j+1];
                end;
             end;
             break;
          end;
       end;


       // найти в z1 позицию zS.
       for j1:=0 to length(z1)-1 do
       begin
          if (abs(z1[j1]-body[i].zS)<epsz) then
          begin
             for j:=j1 to length(z1)-2 do
             begin
                // j - это позиция zS.
                if (abs(z1[j+1]-body[i].zE)<epsz) then
                begin
                   // конец найден
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='Z';
                   vl[lvl-1].xS:=body[i].xE;
                   vl[lvl-1].xE:=body[i].xE;
                   vl[lvl-1].yS:=body[i].yS;
                   vl[lvl-1].yE:=body[i].yS;
                   vl[lvl-1].zS:=z1[j];
                   vl[lvl-1].zE:=body[i].zE;
                   break;
                end
                 else
                begin
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='Z';
                   vl[lvl-1].xS:=body[i].xE;
                   vl[lvl-1].xE:=body[i].xE;
                   vl[lvl-1].yS:=body[i].yS;
                   vl[lvl-1].yE:=body[i].yS;
                   vl[lvl-1].zS:=z1[j];
                   vl[lvl-1].zE:=z1[j+1];
                end;
             end;
             break;
          end;
       end;



       // найти в z1 позицию zS.
       for j1:=0 to length(z1)-1 do
       begin
          if (abs(z1[j1]-body[i].zS)<epsz) then
          begin
             for j:=j1 to length(z1)-2 do
             begin
                // j - это позиция zS.
                if (abs(z1[j+1]-body[i].zE)<epsz) then
                begin
                   // конец найден
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Z';
                    vl[lvl-1].xS:=body[i].xE;
                    vl[lvl-1].xE:=body[i].xE;
                    vl[lvl-1].yS:=body[i].yE;
                    vl[lvl-1].yE:=body[i].yE;
                    vl[lvl-1].zS:=z1[j];
                    vl[lvl-1].zE:=body[i].zE;
                    break;
                end
                 else
                begin
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Z';
                    vl[lvl-1].xS:=body[i].xE;
                    vl[lvl-1].xE:=body[i].xE;
                    vl[lvl-1].yS:=body[i].yE;
                    vl[lvl-1].yE:=body[i].yE;
                    vl[lvl-1].zS:=z1[j];
                   vl[lvl-1].zE:=z1[j+1];
                end;
             end;
             break;
          end;
       end;


       inc(lvl);
    end;
    dec(lvl); // длина vl.

   // ShowMessage(IntToStr(lvl)); //160
    (*
    for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           ShowMessage(FloatToStr(vl[j].yS)+' '+FloatToStr(vl[j].yE));
        end;
     end;
     *)
     (*
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           ShowMessage(FloatToStr(vl[j].xS)+' '+FloatToStr(vl[j].xE));
        end;
     end;
     *)

     // изначально все линии не прорисовываем.
   for i:=0 to Length(blockgraphics)-1 do
   begin
      // TOP
      blockgraphics[i].zE_xE2xS:=False;
      blockgraphics[i].zE_yE2yS:=False;
      blockgraphics[i].zE_xS2xE:=False;
      blockgraphics[i].zE_yS2yE:=False;
      // BOTTOM
      blockgraphics[i].zS_yE2yS:=False;
      blockgraphics[i].zS_xE2xS:=False;
      blockgraphics[i].zS_yS2yE:=False;
      blockgraphics[i].zS_xS2xE:=False;
      // индикация прорисовки линий на WEST грани.
      blockgraphics[i].xS_zE2zS:=False;
      blockgraphics[i].xS_yE2yS:=False;
      blockgraphics[i].xS_zS2zE:=False;
      blockgraphics[i].xS_yS2yE:=False;
      // индикация прорисовки линий на EAST грани.
      blockgraphics[i].xE_zE2zS:=False;
      blockgraphics[i].xE_yE2yS:=False;
      blockgraphics[i].xE_zS2zE:=False;
      blockgraphics[i].xE_yS2yE:=False;
      // North
      blockgraphics[i].yE_zS2zE:=False;
      blockgraphics[i].yE_xS2xE:=False;
      blockgraphics[i].yE_zE2zS:=False;
      blockgraphics[i].yE_xE2xS:=False;
      // Soush
      blockgraphics[i].yS_xS2xE:=False;
      blockgraphics[i].yS_zS2zE:=False;
      blockgraphics[i].yS_xE2xS:=False;
      blockgraphics[i].yS_zE2zS:=False;
   end;

   //eps:=1.0e-12;



   for i:=0 to Length(blockgraphics)-1 do
   begin
     // TOP
     // blockgraphics[i].zE_xE2xS;
     // X
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx) and (abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              //ShowMessage(IntToStr(lvl));
              if ((abs(vl[j].yS-blockgraphics[i].yE)<epsy) and (abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].zE_xE2xS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].zE_yE2yS;
      // Y
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy) and (abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx) and (abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].zE_yE2yS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].zE_xS2xE;
      // X
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].zE_xS2xE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].zE_yS2yE;
      // Y
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx)and(abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].zE_yS2yE:=true;
              end;
           end;
        end;
     end;
      // BOTTOM
      //blockgraphics[i].zS_yE2yS;
       // Y
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].zS_yE2yS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].zS_xE2xS;
      // X
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].zS_xE2xS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].zS_yS2yE;
      // Y
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].zS_yS2yE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].zS_xS2xE;
      // X
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yE)<epsy)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].zS_xS2xE:=true;
              end;
           end;
        end;
     end;
      // индикация прорисовки линий на WEST грани.
      //blockgraphics[i].xS_zE2zS;
      // Z
        for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].yS-blockgraphics[i].yE)<epsy)) then
              begin
                 blockgraphics[i].xS_zE2zS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].xS_yE2yS;
     // Y
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].xS_yE2yS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].xS_zS2zE:=False;
      // Z
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].yS-blockgraphics[i].yS)<epsy)) then
              begin
                 blockgraphics[i].xS_zS2zE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].xS_yS2yE;
      // Y
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy) and (abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx) and (abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].xS_yS2yE:=true;
              end;
           end;
        end;
     end;
      // индикация прорисовки линий на EAST грани.
      //blockgraphics[i].xE_zE2zS;
      // Z
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx)and(abs(vl[j].yS-blockgraphics[i].yE)<epsy)) then
              begin
                 blockgraphics[i].xE_zE2zS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].xE_yE2yS;
       // Y
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy) and (abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx) and (abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].xE_yE2yS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].xE_zS2zE;
      // Z
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx)and(abs(vl[j].yS-blockgraphics[i].yS)<epsy)) then
              begin
                 blockgraphics[i].xE_zS2zE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].xE_yS2yE;
      // Y
      for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy) and (abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx) and (abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].xE_yS2yE:=true;
              end;
           end;
        end;
     end;
      // North
      //blockgraphics[i].yE_zS2zE;
      // Z
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].yS-blockgraphics[i].yE)<epsy)) then
              begin
                 blockgraphics[i].yE_zS2zE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].yE_xS2xE;
      // X
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yE)<epsy)and(abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].yE_xS2xE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].yE_zE2zS;
      // Z
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx)and(abs(vl[j].yS-blockgraphics[i].yE)<epsy)) then
              begin
                 blockgraphics[i].yE_zE2zS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].yE_xE2xS;
      // X
        for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yE)<epsy)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].yE_xE2xS:=true;
              end;
           end;
        end;
     end;
      // Soush
      //blockgraphics[i].yS_xS2xE;
      // X
      for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].yS_xS2xE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].yS_zS2zE;
      // Z
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx)and(abs(vl[j].yS-blockgraphics[i].yS)<epsy)) then
              begin
                 blockgraphics[i].yS_zS2zE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].yS_xE2xS;
      // X
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].yS_xE2xS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].yS_zE2zS;
      // Z
      for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].yS-blockgraphics[i].yS)<epsy)) then
              begin
                 blockgraphics[i].yS_zE2zS:=true;
              end;
           end;
        end;
     end;
   end;


   // Я отказался от  идеи объединения, так как она плохо формализуема в пользу идеи
   // в которой я не прорисовываю грань если она встречается дважды. Для идеи не
   // проррисовывать грань если она встречается дважды важно не выполнять никаких объединений.
   // Это существенным образом ускоряет рендеринг.
   SetLength(vg,0);

   SetLength(vgloc,6);// 6 граней куба
   for i:=0 to Length(blockgraphics)-1 do
   begin
     vgloc[0].xc:=0.5*(blockgraphics[i].xS+blockgraphics[i].xE);
     vgloc[0].yc:=0.5*(blockgraphics[i].yS+blockgraphics[i].yE);
     vgloc[0].zc:=blockgraphics[i].zE;
     vgloc[0].start_on:=False; // z End
     vgloc[0].redcolor:=blockgraphics[i].redcolor;
     vgloc[0].greencolor:=blockgraphics[i].greencolor;
     vgloc[0].bluecolor:=blockgraphics[i].bluecolor;
     vgloc[0].transparency:=blockgraphics[i].transparency;
     vgloc[0].iPlane:=1; // XY
     vgloc[0].xS:=blockgraphics[i].xS;
     vgloc[0].xE:=blockgraphics[i].xE;
     vgloc[0].yS:=blockgraphics[i].yS;
     vgloc[0].yE:=blockgraphics[i].yE;
     vgloc[0].zS:=blockgraphics[i].zS;
     vgloc[0].zE:=blockgraphics[i].zE;
     // 10 marth 2015 для каркасной модели с удалением невидимых линий.
     // zE
     vgloc[0].zE_xE2xS:=blockgraphics[i].zE_xE2xS;
     vgloc[0].zE_yE2yS:=blockgraphics[i].zE_yE2yS;
     vgloc[0].zE_xS2xE:=blockgraphics[i].zE_xS2xE;
     vgloc[0].zE_yS2yE:=blockgraphics[i].zE_yS2yE;
     // zS
     vgloc[0].zS_yE2yS:=blockgraphics[i].zS_yE2yS;
     vgloc[0].zS_xE2xS:=blockgraphics[i].zS_xE2xS;
     vgloc[0].zS_yS2yE:=blockgraphics[i].zS_yS2yE;
     vgloc[0].zS_xS2xE:=blockgraphics[i].zS_xS2xE;
     // xS
     vgloc[0].xS_zE2zS:=blockgraphics[i].xS_zE2zS;
     vgloc[0].xS_yE2yS:=blockgraphics[i].xS_yE2yS;
     vgloc[0].xS_zS2zE:=blockgraphics[i].xS_zS2zE;
     vgloc[0].xS_yS2yE:=blockgraphics[i].xS_yS2yE;
     // xE
     vgloc[0].xE_zE2zS:=blockgraphics[i].xE_zE2zS;
     vgloc[0].xE_yE2yS:=blockgraphics[i].xE_yE2yS;
     vgloc[0].xE_zS2zE:=blockgraphics[i].xE_zS2zE;
     vgloc[0].xE_yS2yE:=blockgraphics[i].xE_yS2yE;
     // yE
     vgloc[0].yE_zS2zE:=blockgraphics[i].yE_zS2zE;
     vgloc[0].yE_xS2xE:=blockgraphics[i].yE_xS2xE;
     vgloc[0].yE_zE2zS:=blockgraphics[i].yE_zE2zS;
     vgloc[0].yE_xE2xS:=blockgraphics[i].yE_xE2xS;
     // yS
     vgloc[0].yS_xS2xE:=blockgraphics[i].yS_xS2xE;
     vgloc[0].yS_zS2zE:=blockgraphics[i].yS_zS2zE;
     vgloc[0].yS_xE2xS:=blockgraphics[i].yS_xE2xS;
     vgloc[0].yS_zE2zS:=blockgraphics[i].yS_zE2zS;


     vgloc[1].xc:=0.5*(blockgraphics[i].xS+blockgraphics[i].xE);
     vgloc[1].yc:=0.5*(blockgraphics[i].yS+blockgraphics[i].yE);
     vgloc[1].zc:=blockgraphics[i].zS;
     vgloc[1].start_on:=True; // z Start
     vgloc[1].redcolor:=blockgraphics[i].redcolor;
     vgloc[1].greencolor:=blockgraphics[i].greencolor;
     vgloc[1].bluecolor:=blockgraphics[i].bluecolor;
     vgloc[1].transparency:=blockgraphics[i].transparency;
     vgloc[1].iPlane:=1; // XY
     vgloc[1].xS:=blockgraphics[i].xS;
     vgloc[1].xE:=blockgraphics[i].xE;
     vgloc[1].yS:=blockgraphics[i].yS;
     vgloc[1].yE:=blockgraphics[i].yE;
     vgloc[1].zS:=blockgraphics[i].zS;
     vgloc[1].zE:=blockgraphics[i].zE;
     // 10 marth 2015 для каркасной модели с удалением невидимых линий.
     // zE
     vgloc[1].zE_xE2xS:=blockgraphics[i].zE_xE2xS;
     vgloc[1].zE_yE2yS:=blockgraphics[i].zE_yE2yS;
     vgloc[1].zE_xS2xE:=blockgraphics[i].zE_xS2xE;
     vgloc[1].zE_yS2yE:=blockgraphics[i].zE_yS2yE;
     // zS
     vgloc[1].zS_yE2yS:=blockgraphics[i].zS_yE2yS;
     vgloc[1].zS_xE2xS:=blockgraphics[i].zS_xE2xS;
     vgloc[1].zS_yS2yE:=blockgraphics[i].zS_yS2yE;
     vgloc[1].zS_xS2xE:=blockgraphics[i].zS_xS2xE;
     // xS
     vgloc[1].xS_zE2zS:=blockgraphics[i].xS_zE2zS;
     vgloc[1].xS_yE2yS:=blockgraphics[i].xS_yE2yS;
     vgloc[1].xS_zS2zE:=blockgraphics[i].xS_zS2zE;
     vgloc[1].xS_yS2yE:=blockgraphics[i].xS_yS2yE;
     // xE
     vgloc[1].xE_zE2zS:=blockgraphics[i].xE_zE2zS;
     vgloc[1].xE_yE2yS:=blockgraphics[i].xE_yE2yS;
     vgloc[1].xE_zS2zE:=blockgraphics[i].xE_zS2zE;
     vgloc[1].xE_yS2yE:=blockgraphics[i].xE_yS2yE;
     // yE
     vgloc[1].yE_zS2zE:=blockgraphics[i].yE_zS2zE;
     vgloc[1].yE_xS2xE:=blockgraphics[i].yE_xS2xE;
     vgloc[1].yE_zE2zS:=blockgraphics[i].yE_zE2zS;
     vgloc[1].yE_xE2xS:=blockgraphics[i].yE_xE2xS;
     // yS
     vgloc[1].yS_xS2xE:=blockgraphics[i].yS_xS2xE;
     vgloc[1].yS_zS2zE:=blockgraphics[i].yS_zS2zE;
     vgloc[1].yS_xE2xS:=blockgraphics[i].yS_xE2xS;
     vgloc[1].yS_zE2zS:=blockgraphics[i].yS_zE2zS;



     vgloc[2].xc:=blockgraphics[i].xS;
     vgloc[2].yc:=0.5*(blockgraphics[i].yS+blockgraphics[i].yE);
     vgloc[2].zc:=0.5*(blockgraphics[i].zS+blockgraphics[i].zE);
     vgloc[2].start_on:=True; // x Start
     vgloc[2].redcolor:=blockgraphics[i].redcolor;
     vgloc[2].greencolor:=blockgraphics[i].greencolor;
     vgloc[2].bluecolor:=blockgraphics[i].bluecolor;
     vgloc[2].transparency:=blockgraphics[i].transparency;
     vgloc[2].iPlane:=3; // YZ
     vgloc[2].xS:=blockgraphics[i].xS;
     vgloc[2].xE:=blockgraphics[i].xE;
     vgloc[2].yS:=blockgraphics[i].yS;
     vgloc[2].yE:=blockgraphics[i].yE;
     vgloc[2].zS:=blockgraphics[i].zS;
     vgloc[2].zE:=blockgraphics[i].zE;
     // 10 marth 2015 для каркасной модели с удалением невидимых линий.
     // zE
     vgloc[2].zE_xE2xS:=blockgraphics[i].zE_xE2xS;
     vgloc[2].zE_yE2yS:=blockgraphics[i].zE_yE2yS;
     vgloc[2].zE_xS2xE:=blockgraphics[i].zE_xS2xE;
     vgloc[2].zE_yS2yE:=blockgraphics[i].zE_yS2yE;
     // zS
     vgloc[2].zS_yE2yS:=blockgraphics[i].zS_yE2yS;
     vgloc[2].zS_xE2xS:=blockgraphics[i].zS_xE2xS;
     vgloc[2].zS_yS2yE:=blockgraphics[i].zS_yS2yE;
     vgloc[2].zS_xS2xE:=blockgraphics[i].zS_xS2xE;
     // xS
     vgloc[2].xS_zE2zS:=blockgraphics[i].xS_zE2zS;
     vgloc[2].xS_yE2yS:=blockgraphics[i].xS_yE2yS;
     vgloc[2].xS_zS2zE:=blockgraphics[i].xS_zS2zE;
     vgloc[2].xS_yS2yE:=blockgraphics[i].xS_yS2yE;
     // xE
     vgloc[2].xE_zE2zS:=blockgraphics[i].xE_zE2zS;
     vgloc[2].xE_yE2yS:=blockgraphics[i].xE_yE2yS;
     vgloc[2].xE_zS2zE:=blockgraphics[i].xE_zS2zE;
     vgloc[2].xE_yS2yE:=blockgraphics[i].xE_yS2yE;
     // yE
     vgloc[2].yE_zS2zE:=blockgraphics[i].yE_zS2zE;
     vgloc[2].yE_xS2xE:=blockgraphics[i].yE_xS2xE;
     vgloc[2].yE_zE2zS:=blockgraphics[i].yE_zE2zS;
     vgloc[2].yE_xE2xS:=blockgraphics[i].yE_xE2xS;
     // yS
     vgloc[2].yS_xS2xE:=blockgraphics[i].yS_xS2xE;
     vgloc[2].yS_zS2zE:=blockgraphics[i].yS_zS2zE;
     vgloc[2].yS_xE2xS:=blockgraphics[i].yS_xE2xS;
     vgloc[2].yS_zE2zS:=blockgraphics[i].yS_zE2zS;


     vgloc[3].xc:=blockgraphics[i].xE;
     vgloc[3].yc:=0.5*(blockgraphics[i].yS+blockgraphics[i].yE);
     vgloc[3].zc:=0.5*(blockgraphics[i].zS+blockgraphics[i].zE);
     vgloc[3].start_on:=False; // x End
     vgloc[3].redcolor:=blockgraphics[i].redcolor;
     vgloc[3].greencolor:=blockgraphics[i].greencolor;
     vgloc[3].bluecolor:=blockgraphics[i].bluecolor;
     vgloc[3].transparency:=blockgraphics[i].transparency;
     vgloc[3].iPlane:=3; // YZ
     vgloc[3].xS:=blockgraphics[i].xS;
     vgloc[3].xE:=blockgraphics[i].xE;
     vgloc[3].yS:=blockgraphics[i].yS;
     vgloc[3].yE:=blockgraphics[i].yE;
     vgloc[3].zS:=blockgraphics[i].zS;
     vgloc[3].zE:=blockgraphics[i].zE;
     // 10 marth 2015 для каркасной модели с удалением невидимых линий.
     // zE
     vgloc[3].zE_xE2xS:=blockgraphics[i].zE_xE2xS;
     vgloc[3].zE_yE2yS:=blockgraphics[i].zE_yE2yS;
     vgloc[3].zE_xS2xE:=blockgraphics[i].zE_xS2xE;
     vgloc[3].zE_yS2yE:=blockgraphics[i].zE_yS2yE;
     // zS
     vgloc[3].zS_yE2yS:=blockgraphics[i].zS_yE2yS;
     vgloc[3].zS_xE2xS:=blockgraphics[i].zS_xE2xS;
     vgloc[3].zS_yS2yE:=blockgraphics[i].zS_yS2yE;
     vgloc[3].zS_xS2xE:=blockgraphics[i].zS_xS2xE;
     // xS
     vgloc[3].xS_zE2zS:=blockgraphics[i].xS_zE2zS;
     vgloc[3].xS_yE2yS:=blockgraphics[i].xS_yE2yS;
     vgloc[3].xS_zS2zE:=blockgraphics[i].xS_zS2zE;
     vgloc[3].xS_yS2yE:=blockgraphics[i].xS_yS2yE;
     // xE
     vgloc[3].xE_zE2zS:=blockgraphics[i].xE_zE2zS;
     vgloc[3].xE_yE2yS:=blockgraphics[i].xE_yE2yS;
     vgloc[3].xE_zS2zE:=blockgraphics[i].xE_zS2zE;
     vgloc[3].xE_yS2yE:=blockgraphics[i].xE_yS2yE;
     // yE
     vgloc[3].yE_zS2zE:=blockgraphics[i].yE_zS2zE;
     vgloc[3].yE_xS2xE:=blockgraphics[i].yE_xS2xE;
     vgloc[3].yE_zE2zS:=blockgraphics[i].yE_zE2zS;
     vgloc[3].yE_xE2xS:=blockgraphics[i].yE_xE2xS;
     // yS
     vgloc[3].yS_xS2xE:=blockgraphics[i].yS_xS2xE;
     vgloc[3].yS_zS2zE:=blockgraphics[i].yS_zS2zE;
     vgloc[3].yS_xE2xS:=blockgraphics[i].yS_xE2xS;
     vgloc[3].yS_zE2zS:=blockgraphics[i].yS_zE2zS;


     vgloc[4].xc:=0.5*(blockgraphics[i].xS+blockgraphics[i].xE);
     vgloc[4].yc:=blockgraphics[i].yS;
     vgloc[4].zc:=0.5*(blockgraphics[i].zS+blockgraphics[i].zE);
     vgloc[4].start_on:=True; // y Start
     vgloc[4].redcolor:=blockgraphics[i].redcolor;
     vgloc[4].greencolor:=blockgraphics[i].greencolor;
     vgloc[4].bluecolor:=blockgraphics[i].bluecolor;
     vgloc[4].transparency:=blockgraphics[i].transparency;
     vgloc[4].iPlane:=2; // XZ
     vgloc[4].xS:=blockgraphics[i].xS;
     vgloc[4].xE:=blockgraphics[i].xE;
     vgloc[4].yS:=blockgraphics[i].yS;
     vgloc[4].yE:=blockgraphics[i].yE;
     vgloc[4].zS:=blockgraphics[i].zS;
     vgloc[4].zE:=blockgraphics[i].zE;
     // 10 marth 2015 для каркасной модели с удалением невидимых линий.
     // zE
     vgloc[4].zE_xE2xS:=blockgraphics[i].zE_xE2xS;
     vgloc[4].zE_yE2yS:=blockgraphics[i].zE_yE2yS;
     vgloc[4].zE_xS2xE:=blockgraphics[i].zE_xS2xE;
     vgloc[4].zE_yS2yE:=blockgraphics[i].zE_yS2yE;
     // zS
     vgloc[4].zS_yE2yS:=blockgraphics[i].zS_yE2yS;
     vgloc[4].zS_xE2xS:=blockgraphics[i].zS_xE2xS;
     vgloc[4].zS_yS2yE:=blockgraphics[i].zS_yS2yE;
     vgloc[4].zS_xS2xE:=blockgraphics[i].zS_xS2xE;
     // xS
     vgloc[4].xS_zE2zS:=blockgraphics[i].xS_zE2zS;
     vgloc[4].xS_yE2yS:=blockgraphics[i].xS_yE2yS;
     vgloc[4].xS_zS2zE:=blockgraphics[i].xS_zS2zE;
     vgloc[4].xS_yS2yE:=blockgraphics[i].xS_yS2yE;
     // xE
     vgloc[4].xE_zE2zS:=blockgraphics[i].xE_zE2zS;
     vgloc[4].xE_yE2yS:=blockgraphics[i].xE_yE2yS;
     vgloc[4].xE_zS2zE:=blockgraphics[i].xE_zS2zE;
     vgloc[4].xE_yS2yE:=blockgraphics[i].xE_yS2yE;
     // yE
     vgloc[4].yE_zS2zE:=blockgraphics[i].yE_zS2zE;
     vgloc[4].yE_xS2xE:=blockgraphics[i].yE_xS2xE;
     vgloc[4].yE_zE2zS:=blockgraphics[i].yE_zE2zS;
     vgloc[4].yE_xE2xS:=blockgraphics[i].yE_xE2xS;
     // yS
     vgloc[4].yS_xS2xE:=blockgraphics[i].yS_xS2xE;
     vgloc[4].yS_zS2zE:=blockgraphics[i].yS_zS2zE;
     vgloc[4].yS_xE2xS:=blockgraphics[i].yS_xE2xS;
     vgloc[4].yS_zE2zS:=blockgraphics[i].yS_zE2zS;


     vgloc[5].xc:=0.5*(blockgraphics[i].xS+blockgraphics[i].xE);
     vgloc[5].yc:=blockgraphics[i].yE;
     vgloc[5].zc:=0.5*(blockgraphics[i].zS+blockgraphics[i].zE);
     vgloc[5].start_on:=False; // y End
     vgloc[5].redcolor:=blockgraphics[i].redcolor;
     vgloc[5].greencolor:=blockgraphics[i].greencolor;
     vgloc[5].bluecolor:=blockgraphics[i].bluecolor;
     vgloc[5].transparency:=blockgraphics[i].transparency;
     vgloc[5].iPlane:=2; // XZ
     vgloc[5].xS:=blockgraphics[i].xS;
     vgloc[5].xE:=blockgraphics[i].xE;
     vgloc[5].yS:=blockgraphics[i].yS;
     vgloc[5].yE:=blockgraphics[i].yE;
     vgloc[5].zS:=blockgraphics[i].zS;
     vgloc[5].zE:=blockgraphics[i].zE;
     // 10 marth 2015 для каркасной модели с удалением невидимых линий.
     // zE
     vgloc[5].zE_xE2xS:=blockgraphics[i].zE_xE2xS;
     vgloc[5].zE_yE2yS:=blockgraphics[i].zE_yE2yS;
     vgloc[5].zE_xS2xE:=blockgraphics[i].zE_xS2xE;
     vgloc[5].zE_yS2yE:=blockgraphics[i].zE_yS2yE;
     // zS
     vgloc[5].zS_yE2yS:=blockgraphics[i].zS_yE2yS;
     vgloc[5].zS_xE2xS:=blockgraphics[i].zS_xE2xS;
     vgloc[5].zS_yS2yE:=blockgraphics[i].zS_yS2yE;
     vgloc[5].zS_xS2xE:=blockgraphics[i].zS_xS2xE;
     // xS
     vgloc[5].xS_zE2zS:=blockgraphics[i].xS_zE2zS;
     vgloc[5].xS_yE2yS:=blockgraphics[i].xS_yE2yS;
     vgloc[5].xS_zS2zE:=blockgraphics[i].xS_zS2zE;
     vgloc[5].xS_yS2yE:=blockgraphics[i].xS_yS2yE;
     // xE
     vgloc[5].xE_zE2zS:=blockgraphics[i].xE_zE2zS;
     vgloc[5].xE_yE2yS:=blockgraphics[i].xE_yE2yS;
     vgloc[5].xE_zS2zE:=blockgraphics[i].xE_zS2zE;
     vgloc[5].xE_yS2yE:=blockgraphics[i].xE_yS2yE;
     // yE
     vgloc[5].yE_zS2zE:=blockgraphics[i].yE_zS2zE;
     vgloc[5].yE_xS2xE:=blockgraphics[i].yE_xS2xE;
     vgloc[5].yE_zE2zS:=blockgraphics[i].yE_zE2zS;
     vgloc[5].yE_xE2xS:=blockgraphics[i].yE_xE2xS;
     // yS
     vgloc[5].yS_xS2xE:=blockgraphics[i].yS_xS2xE;
     vgloc[5].yS_zS2zE:=blockgraphics[i].yS_zS2zE;
     vgloc[5].yS_xE2xS:=blockgraphics[i].yS_xE2xS;
     vgloc[5].yS_zE2zS:=blockgraphics[i].yS_zE2zS;


     k:=Length(vg)-1;
     epsilon_tol:=1.0e-12;
     bfound:=False;
     // построение списка уникальных граней.
     for j:=0 to k do
     begin

         if ((abs(vg[j].xc-vgloc[0].xc)<epsx)and(abs(vg[j].yc-vgloc[0].yc)<epsy)and(abs(vg[j].zc-vgloc[0].zc)<epsz)) then
         begin
            bfound:=True;
         end;
     end;
     if (not(bfound)) then
     begin
        SetLength(vg,Length(vg)+1);
        Inc(k);
        vg[Length(vg)-1]:=vgloc[0];
        vg[Length(vg)-1].flagvisit:=false;
     end;
     bfound:=False;
     for j:=0 to k do
     begin
         if ((abs(vg[j].xc-vgloc[1].xc)<epsx)and(abs(vg[j].yc-vgloc[1].yc)<epsy)and(abs(vg[j].zc-vgloc[1].zc)<epsz)) then
         begin
            bfound:=True;
            vg[j].flagvisit:=True;
         end;
     end;
     if (not(bfound)) then
     begin
        SetLength(vg,Length(vg)+1);
        Inc(k);
        vg[Length(vg)-1]:=vgloc[1];
        vg[Length(vg)-1].flagvisit:=false;
     end;
     bfound:=False;
     for j:=0 to k do
     begin
         if ((abs(vg[j].xc-vgloc[2].xc)<epsx)and(abs(vg[j].yc-vgloc[2].yc)<epsy)and(abs(vg[j].zc-vgloc[2].zc)<epsz)) then
         begin
             bfound:=True;
             vg[j].flagvisit:=True;
         end;
     end;
     if (not(bfound)) then
     begin
        SetLength(vg,Length(vg)+1);
        Inc(k);
        vg[Length(vg)-1]:=vgloc[2];
        vg[Length(vg)-1].flagvisit:=false;
     end;
     bfound:=False;
     for j:=0 to k do
     begin
          if ((abs(vg[j].xc-vgloc[3].xc)<epsx)and(abs(vg[j].yc-vgloc[3].yc)<epsy)and(abs(vg[j].zc-vgloc[3].zc)<epsz)) then
         begin
             bfound:=True;
            vg[j].flagvisit:=True;
         end;
     end;
     if (not(bfound)) then
     begin
        SetLength(vg,Length(vg)+1);
        Inc(k);
        vg[Length(vg)-1]:=vgloc[3];
        vg[Length(vg)-1].flagvisit:=false;
     end;
     bfound:=False;
     for j:=0 to k do
     begin
          if ((abs(vg[j].xc-vgloc[4].xc)<epsx)and(abs(vg[j].yc-vgloc[4].yc)<epsy)and(abs(vg[j].zc-vgloc[4].zc)<epsz)) then
         begin
            bfound:=True;
            vg[j].flagvisit:=True;
         end;
     end;
     if (not(bfound)) then
     begin
        SetLength(vg,Length(vg)+1);
        Inc(k);
        vg[Length(vg)-1]:=vgloc[4];
        vg[Length(vg)-1].flagvisit:=false;
     end;
     bfound:=False;
     for j:=0 to k do
     begin
          if ((abs(vg[j].xc-vgloc[5].xc)<epsx)and(abs(vg[j].yc-vgloc[5].yc)<epsy)and(abs(vg[j].zc-vgloc[5].zc)<epsz)) then
         begin
             bfound:=True;
            vg[j].flagvisit:=True;
         end;
     end;
     if (not(bfound)) then
     begin
        SetLength(vg,Length(vg)+1);
        Inc(k);
        vg[Length(vg)-1]:=vgloc[5];
        vg[Length(vg)-1].flagvisit:=false;
     end;
   end;
    SetLength(vgloc,Length(vg));
    k:=0;
    for i:=0 to Length(vg)-1 do
    begin
      if (vg[i].flagvisit=False) then
      begin
         vgloc[k]:=vg[i];
         inc(k);
      end;
    end;
    SetLength(vg,k);
    for i:=0 to k-1 do
    begin
       vg[i]:=vgloc[i];
    end;
    SetLength(vgloc,0);


   (*
   // Объединение.
   SetLength(bmask,Length(x1),Length(y1),Length(z1));
   for i:=0 to Length(x1)-1 do
   begin
      for j:=0 to Length(y1)-1 do
      begin
         for k:=0 to Length(z1)-1 do
         begin
            bmask[i][j][k]:=false;
         end;
      end;
   end;
   for i:=0 to Length(x1)-1 do
   begin
      for j:=0 to Length(y1)-1 do
      begin
         for k:=0 to Length(z1)-1 do
         begin
            if (mask[i][j][k]>=0) then
            begin
               bmask[i][j][k]:=true;
            end;
         end;
      end;
   end;

   SetLength(bg,Length(blockgraphics));
   for i:=0 to Length(blockgraphics)-1 do
   begin
      bg[i]:=blockgraphics[i];
   end;
   SetLength(blockgraphics,0);

   // объединение восьмёрок.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i+1][j][k] and bmask[i][j+1][k] and  bmask[i][j][k+1] and bmask[i+1][j+1][k] and bmask[i][j+1][k+1] and bmask[i+1][j][k+1] and  bmask[i+1][j+1][k+1] ) then
            begin
               if ((bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i][j][k+1]) and (bid[i][j][k]=bid[i+1][j+1][k]) and (bid[i][j][k]=bid[i][j+1][k+1])and (bid[i][j][k]=bid[i+1][j][k+1])and (bid[i][j][k]=bid[i+1][j+1][k+1])) then
               begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+1][j+1][k+1]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+1][j+1][k+1]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+1][j+1][k+1]].zE;
               bmask[i][j][k]:=False;
               bmask[i+1][j][k]:=False;
               bmask[i][j+1][k]:=False;
               bmask[i][j][k+1]:=False;
               bmask[i+1][j+1][k]:=False;
               bmask[i+1][j][k+1]:=False;
               bmask[i+1][j+1][k+1]:=False;
               bmask[i][j+1][k+1]:=False;
              end;
            end;
         end;
      end;
   end;

    // объединение шестёрок k.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j][k+1] and bmask[i][j+1][k] and  bmask[i][j+1][k+1] and  bmask[i][j+1][k+2] and  bmask[i][j][k+2]) then
            begin
               if ((bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i][j][k+1]) and (bid[i][j][k]=bid[i][j+1][k+1]) and (bid[i][j][k]=bid[i][j][k+2]) and (bid[i][j][k]=bid[i][j+1][k+2])) then
               begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j+1][k+2]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j+1][k+2]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j+1][k+2]].zE;
               bmask[i][j][k]:=False;
               bmask[i][j][k+1]:=False;
               bmask[i][j+1][k]:=False;
               bmask[i][j+1][k+1]:=False;
               bmask[i][j][k+2]:=False;
               bmask[i][j+1][k+2]:=False;
              end;
            end;
         end;
      end;
   end;

   // объединение шестёрок j.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i+1][j][k] and bmask[i][j+1][k] and  bmask[i+1][j+1][k] and bmask[i][j+2][k] and  bmask[i+1][j+2][k]) then
            begin
               if ((bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i+1][j+1][k])  and (bid[i][j][k]=bid[i][j+2][k]) and (bid[i][j][k]=bid[i+1][j+2][k])) then
               begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+1][j+2][k]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+1][j+2][k]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+1][j+2][k]].zE;
               bmask[i][j][k]:=False;
               bmask[i+1][j][k]:=False;
               bmask[i][j+1][k]:=False;
               bmask[i+1][j+1][k]:=False;
               bmask[i][j+2][k]:=False;
               bmask[i+1][j+2][k]:=False;
              end;
            end;
         end;
      end;
   end;


   // объединение шестёрок i.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i+1][j][k] and bmask[i][j+1][k] and  bmask[i+1][j+1][k] and  bmask[i+2][j][k] and  bmask[i+2][j+1][k]) then
            begin
               if ((bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i+1][j+1][k]) and (bid[i][j][k]=bid[i+2][j][k]) and (bid[i][j][k]=bid[i+2][j+1][k])) then
               begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
               blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
               blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
               blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
               blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+2][j+1][k]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+2][j+1][k]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+2][j+1][k]].zE;
               bmask[i][j][k]:=False;
               bmask[i+1][j][k]:=False;
               bmask[i][j+1][k]:=False;
               bmask[i+1][j+1][k]:=False;
                bmask[i+2][j][k]:=False;
                bmask[i+2][j+1][k]:=False;
              end;
            end;
         end;
      end;
   end;

   // объединение четвёрок.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i+1][j][k] and bmask[i][j+1][k] and  bmask[i+1][j+1][k]) then
            begin
               if ((bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i+1][j+1][k]) ) then
               begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+1][j+1][k]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+1][j+1][k]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+1][j+1][k]].zE;
               bmask[i][j][k]:=False;
               bmask[i+1][j][k]:=False;
               bmask[i][j+1][k]:=False;
               bmask[i+1][j+1][k]:=False;
              end;
            end;
         end;
      end;
   end;




   // объединение четвёрок.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j][k+1] and bmask[i][j+1][k] and  bmask[i][j+1][k+1]) then
            begin
               if ((bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i][j][k+1]) and (bid[i][j][k]=bid[i][j+1][k+1]) ) then
               begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j+1][k+1]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j+1][k+1]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j+1][k+1]].zE;
               bmask[i][j][k]:=False;
               bmask[i][j][k+1]:=False;
               bmask[i][j+1][k]:=False;
               bmask[i][j+1][k+1]:=False;
              end;
            end;
         end;
      end;
   end;

   // объединение четвёрок.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j][k+1] and bmask[i+1][j][k] and  bmask[i+1][j][k+1]) then
            begin
               if ((bid[i][j][k]=bid[i][j][k+1]) and (bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i+1][j][k+1]) ) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+1][j][k+1]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+1][j][k+1]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+1][j][k+1]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i][j][k+1]:=False;
                  bmask[i+1][j][k]:=False;
                  bmask[i+1][j][k+1]:=False;
              end;
            end;
         end;
      end;
   end;


   // объединение четвёрок i-long 4.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i+1][j][k] and bmask[i+2][j][k] and  bmask[i+3][j][k]) then
            begin
               if ((bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i+2][j][k]) and (bid[i][j][k]=bid[i+3][j][k]) ) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+3][j][k]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+3][j][k]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+3][j][k]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i+1][j][k]:=False;
                  bmask[i+2][j][k]:=False;
                  bmask[i+3][j][k]:=False;
              end;
            end;
         end;
      end;
   end;

   // объединение троек i-long 3.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i+1][j][k] and bmask[i+2][j][k]) then
            begin
               if ((bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i+2][j][k]) ) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+2][j][k]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+2][j][k]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+2][j][k]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i+1][j][k]:=False;
                  bmask[i+2][j][k]:=False;
              end;
            end;
         end;
      end;
   end;

    // объединение четвёрок j-long 4.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j+1][k] and bmask[i][j+2][k] and  bmask[i][j+3][k]) then
            begin
               if ((bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i][j+2][k]) and (bid[i][j][k]=bid[i][j+3][k])) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j+3][k]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j+3][k]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j+3][k]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i][j+1][k]:=False;
                  bmask[i][j+2][k]:=False;
                  bmask[i][j+3][k]:=False;
              end;
            end;
         end;
      end;
   end;

    // объединение четвёрок k-long 4.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j][k+1] and bmask[i][j][k+2] and  bmask[i][j][k+3]) then
            begin
               if ((bid[i][j][k]=bid[i][j][k+1]) and (bid[i][j][k]=bid[i][j][k+2]) and (bid[i][j][k]=bid[i][j][k+3])) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j][k+3]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j][k+3]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j][k+3]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i][j][k+1]:=False;
                  bmask[i][j][k+2]:=False;
                  bmask[i][j][k+3]:=False;
              end;
            end;
         end;
      end;
   end;

   // объединение троек j-long 3.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j+1][k] and bmask[i][j+2][k]) then
            begin
               if ((bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i][j+2][k]) ) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j+2][k]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j+2][k]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j+2][k]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i][j+2][k]:=False;
                  bmask[i][j+2][k]:=False;
              end;
            end;
         end;
      end;
   end;

   // объединение троек k-long 3.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j][k+1] and bmask[i][j][k+2]) then
            begin
               if ((bid[i][j][k]=bid[i][j][k+1]) and (bid[i][j][k]=bid[i][j][k+2]) ) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                  blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                  blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                  blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                  blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j][k+2]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j][k+2]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j][k+2]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i][j][k+1]:=False;
                  bmask[i][j][k+2]:=False;
              end;
            end;
         end;
      end;
   end;

   // Оставшиеся необъединёнными элементы.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k]) then
            begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j][k]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j][k]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j][k]].zE;
                blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               bmask[i][j][k]:=False;
            end;
         end;
      end;
   end;

   SetLength(mask,0,0,0);
   SetLength(bmask,0,0,0);
   SetLength(bg,0);
   *)

end;  // ReadyPaint1

// подготавливает данные к визуализации.
procedure TLaplas.ReadyPaint2;
var
   x1, y1, z1 : array of Real;
   i,j,k,isel,ib, i87 : Integer;
   xc, yc, zc, epsilon_tol : Real;
   bonlyfluid, bisox, bisoy, bisoz, biso, bfound : Boolean;
   isovalgx, isovalgy, isovalgz : Real;
   // -1 нет блока. >=0 номер блока. -2 - объединение первого уровня.
   mask : array of array of array of Integer; // маска для последующего объединения.
   // номер исходного блока.
   bid : array of array of array of Integer;
   bmask : array of array of array of Boolean;
   bg : array of GBody;
   vgloc : array of VisibleGran;
   vl : array of Visible_Line; // избирает только те отрезки которые нужно прорисовывать.
   lvl, j1 : Integer;
    epsx, epsy, epsz : Real;
   sbuf : String;
   rbuf : Real;
   binit : Boolean;


procedure Pushx(r : Real);
var
   ilen : Integer;
   bfound : Boolean;
begin
   bfound:=False;
   for ilen:=0 to Length(x1)-1 do
   begin
      if (Abs(x1[ilen]-r)<1e-15 ) then
      begin
         bfound:=True;
         Break;
      end;
   end;
   if (not(bfound)) then
   begin
      SetLength(x1, Length(x1)+1);
      x1[Length(x1)-1]:=r;
   end;
end;

procedure Pushy(r : Real);
var
   ilen : Integer;
   bfound : Boolean;
begin
   bfound:=False;
   for ilen:=0 to Length(y1)-1 do
   begin
      if (Abs(y1[ilen]-r)<1e-15 ) then
      begin
         bfound:=True;
         Break;
      end;
   end;
   if (not(bfound)) then
   begin
      SetLength(y1, Length(y1)+1);
      y1[Length(y1)-1]:=r;
   end;
end;

procedure Pushz(r : Real);
var
   ilen : Integer;
   bfound : Boolean;
begin
   bfound:=False;
   for ilen:=0 to Length(z1)-1 do
   begin
      if (Abs(z1[ilen]-r)<1e-15 ) then
      begin
         bfound:=True;
         Break;
      end;
   end;
   if (not(bfound)) then
   begin
      SetLength(z1, Length(z1)+1);
      z1[Length(z1)-1]:=r;
   end;
end;

// Пузырьковая сортировка по x.
procedure BubbleSortx;
var
   i2, j2 : Integer;
   xchange : Real;
begin


   for i2:=1 to Length(x1)-1 do
   begin
	   for j2:=Length(x1)-1 downto i2 do
     begin
     		if (x1[j2-1] > x1[j2]) then
        begin
			     // swap
			     xchange:=x1[j2-1];
			     x1[j2-1]:=x1[j2];
			     x1[j2]:=xchange;
		    end;
	   end;
   end;
end; // BubbleSortx

// Пузырьковая сортировка по y.
procedure BubbleSorty;
var
   i2, j2 : Integer;
   ychange : Real;
begin


   for i2:=1 to Length(y1)-1 do
   begin
	   for j2:=Length(y1)-1 downto i2 do
     begin
     		if (y1[j2-1] > y1[j2]) then
        begin
			     // swap
			     ychange:=y1[j2-1];
			     y1[j2-1]:=y1[j2];
			     y1[j2]:=ychange;
		    end;
	   end;
   end;
end; // BubbleSorty

// Пузырьковая сортировка по z.
procedure BubbleSortz;
var
   i2, j2 : Integer;
   zchange : Real;
begin
   for i2:=1 to Length(z1)-1 do
   begin
	   for j2:=Length(z1)-1 downto i2 do
     begin
     		if (z1[j2-1] > z1[j2]) then
        begin
			     // swap
			     zchange:=z1[j2-1];
			     z1[j2-1]:=z1[j2];
			     z1[j2]:=zchange;
		    end;
	   end;
   end;
end; // BubbleSortz

begin


   // Подготовительный этап к визуализации графики на основе OpenGL.
   // Производим анализ области и автоматом делаём вырезы, т.к. любая композиция
   // прямоугольных параллелепипедов после операций объеинения и вырезания снова становится
   // композицией прямоугольных параллелепипедов.

   // ShowMessage('Ready Paint'); // debug.

   // Если xS > xE то это приводит к ошибке визуализации,
   // аналогично должно быть yS, yE, zS, zE.
   // Организуем переупорядочивание.
   for isel := 0 to lb-1 do
   begin
      if (body[isel].xS>body[isel].xE) then
      begin
         sbuf:=body[isel].sxS;
         body[isel].sxS:=body[isel].sxE;
         body[isel].sxE:=sbuf;
         rbuf:=body[isel].xS;
         body[isel].xS:=body[isel].xE;
         body[isel].xE:=rbuf;
      end;
      if (body[isel].yS>body[isel].yE) then
      begin
         sbuf:=body[isel].syS;
         body[isel].syS:=body[isel].syE;
         body[isel].syE:=sbuf;
         rbuf:=body[isel].yS;
         body[isel].yS:=body[isel].yE;
         body[isel].yE:=rbuf;
      end;
      if (body[isel].zS>body[isel].zE) then
      begin
         sbuf:=body[isel].szS;
         body[isel].szS:=body[isel].szE;
         body[isel].szE:=sbuf;
         rbuf:=body[isel].zS;
         body[isel].zS:=body[isel].zE;
         body[isel].zE:=rbuf;
      end;
   end;


   SetLength(x1,2);
   SetLength(y1,2);
   SetLength(z1,2);

   x1[0]:=body[1].xS;
   x1[1]:=body[1].xE;
   for isel:=2 to lb-1 do
   begin
      Pushx(body[isel].xS);
      Pushx(body[isel].xE);
   end;
   // сортировка по возрастанию.
   BubbleSortx;

   epsx:=1e30;
   for i:=1 to length(x1)-1 do
   begin
      if (epsx>abs(x1[i]-x1[i-1])) then
      begin
         epsx:=abs(x1[i]-x1[i-1]);
      end;
   end;
   epsx:=epsx*0.5*0.1;



   y1[0]:=body[1].yS;
   y1[1]:=body[1].yE;
   for isel:=2 to lb-1 do
   begin
      Pushy(body[isel].yS);
      Pushy(body[isel].yE);
   end;
   // сортировка по возрастанию.
   BubbleSorty;

   epsy:=1e30;
   for i:=1 to length(y1)-1 do
   begin
      if (epsy>abs(y1[i]-y1[i-1])) then
      begin
         epsy:=abs(y1[i]-y1[i-1]);
      end;
   end;
   epsy:=epsy*0.5*0.1;

   z1[0]:=body[1].zS;
   z1[1]:=body[1].zE;
   for isel:=2 to lb-1 do
   begin
      Pushz(body[isel].zS);
      Pushz(body[isel].zE);
   end;
   // сортировка по возрастанию.
   BubbleSortz;

    epsz:=1e30;
   for i:=1 to length(z1)-1 do
   begin
      if (epsz>abs(z1[i]-z1[i-1])) then
      begin
         epsz:=abs(z1[i]-z1[i-1]);
      end;
   end;
   epsz:=epsz*0.5*0.1;

   (*
   //debug ok
   MainMemo.Lines.Add('z1='+FloatToStr(z1[0])+' '+
   FloatToStr(z1[1])+' '+
   FloatToStr(z1[2])+' '+
   FloatToStr(z1[3])+' ');
    MainMemo.Lines.Add('y1='+FloatToStr(y1[0])+' '+
   FloatToStr(y1[1])+' '+
   FloatToStr(y1[2])+' '+
   FloatToStr(y1[3])+' ');
     *)
   biso:=False;
   bisox:=False;
   bisoy:=False;
   bisoz:=False;
   // Теперь сделаем учёт рассекающей плоскости :
   case cbbview.ItemIndex of
   1 : // XY
       begin
          isovalgz:=StrToFloat(edtvalue.Text);
          Pushz(isovalgz);
          BubbleSortz;
          bisoz:=True;
       end;
   2 : // XZ
       begin
          isovalgy:=StrToFloat(edtvalue.Text);
          Pushy(isovalgy);
          BubbleSorty;
          bisoy:=True;
       end;
   3 : // YZ
       begin
          isovalgx:=StrToFloat(edtvalue.Text);
          Pushx(isovalgx);
          BubbleSortx;
          bisox:=True;
       end;
   end;
   biso:=bisox or bisoy or bisoz;

   // инициализация
   SetLength(mask,Length(x1)-1,Length(y1)-1,Length(z1)-1);
   SetLength(bid,Length(x1)-1,Length(y1)-1,Length(z1)-1);
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            mask[i][j][k]:=-2;
            bid[i][j][k]:=-1;// номер исходного блока.
         end;
      end;
   end;

   for isel:=1 to lb-1 do
   begin
      body[isel].ixS:=0;
      body[isel].ixE:=Length(x1)-1;
      for i:=0 to Length(x1)-1 do
      begin
         if (abs(x1[i]-body[isel].xS)<epsx) then
         begin
            body[isel].ixS:=i;
            break;
         end;
      end;
      for i:=0 to Length(x1)-1 do
      begin
         if (abs(x1[i]-body[isel].xE)<epsx) then
         begin
            body[isel].ixE:=i;
            break;
         end;
      end;
      body[isel].iyS:=0;
      body[isel].iyE:=Length(y1)-1;
      for i:=0 to Length(y1)-1 do
      begin
         if (abs(y1[i]-body[isel].yS)<epsy) then
         begin
            body[isel].iyS:=i;
            break;
         end;
      end;
      for i:=0 to Length(y1)-1 do
      begin
         if (abs(y1[i]-body[isel].yE)<epsy) then
         begin
            body[isel].iyE:=i;
            break;
         end;
      end;
       body[isel].izS:=0;
      body[isel].izE:=Length(z1)-1;
      for i:=0 to Length(z1)-1 do
      begin
         if (abs(z1[i]-body[isel].zS)<epsz) then
         begin
            body[isel].izS:=i;
            break;
         end;
      end;
      for i:=0 to Length(z1)-1 do
      begin
         if (abs(z1[i]-body[isel].zE)<epsz) then
         begin
            body[isel].izE:=i;
            break;
         end;
      end;
   end;

   (*
   // debug
    for isel:=lb-1 downto 1 do
   begin
   MainMemo.Lines.Add(IntToStr(body[isel].ixS)+' '+
   IntToStr(body[isel].ixE)+' '+
   IntToStr(body[isel].iyS)+' '+
   IntToStr(body[isel].iyE)+' '+
   IntToStr(body[isel].izS)+' '+
   IntToStr(body[isel].izE)+' ');
   end;
   *)

   for isel:=lb-1 downto 1 do
   begin
       for i:=body[isel].ixS to (body[isel].ixE-1) do
       begin
          for j:=body[isel].iyS to (body[isel].iyE-1) do
          begin
             for k:=body[isel].izS to (body[isel].izE-1) do
             begin
                if (mask[i][j][k]=-2) then
                begin
                    mask[i][j][k]:=-1;
                    bid[i][j][k]:=isel;
                end;
             end;
          end;
      end;
   end;


    for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
           if( mask[i][j][k]=-2) then
           begin
              // ShowMessage('Error! cell not visited.');
               mask[i][j][k]:=-1;
               bid[i][j][k]:=-1;
            end;
         end;
      end;
   end;

   SetLength(blockgraphics,0);
   bonlyfluid:=True;
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            // Принадлежит ли ячейка SOLID телу,
            // составляющему расчётную модель.


            xc:=0.5*(x1[i]+x1[i+1]);
            yc:=0.5*(y1[j]+y1[j+1]);
            zc:=0.5*(z1[k]+z1[k+1]);

            if ((not(biso)) or
            (bisox and (xc<isovalgx))
            or (bisoy and (yc<isovalgy))
            or (bisoz and (zc<isovalgz)))
            then
            begin
               ib:=bid[i][j][k];
               // только Solid.
               if ((ib>0)(* and
                (body[ib].itype=1)and // SOLID
                (body[ib].bvisible)*)) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].xS:=x1[i];
                  blockgraphics[Length(blockgraphics)-1].xE:=x1[i+1];
                  blockgraphics[Length(blockgraphics)-1].yS:=y1[j];
                  blockgraphics[Length(blockgraphics)-1].yE:=y1[j+1];
                  blockgraphics[Length(blockgraphics)-1].zS:=z1[k];
                  blockgraphics[Length(blockgraphics)-1].zE:=z1[k+1];
                  // наследуем цвет и прозрачность.
                  blockgraphics[Length(blockgraphics)-1].redcolor:=body[ib].redcolor;
                  blockgraphics[Length(blockgraphics)-1].greencolor:=body[ib].greencolor;
                  blockgraphics[Length(blockgraphics)-1].bluecolor:=body[ib].bluecolor;
                  blockgraphics[Length(blockgraphics)-1].transparency:=body[ib].transparency;
                  blockgraphics[Length(blockgraphics)-1].dcol:=body[ib].dcol;
                  blockgraphics[Length(blockgraphics)-1].igeometry_type:=body[ib].itype;
                  // debug
                  //MainMemo.Lines.Add(IntToStr(ib)+' '+IntToStr(body[ib].itype));
                  bonlyfluid:=false;
                  mask[i][j][k]:=Length(blockgraphics)-1;
                  bid[i][j][k]:=ib;
               end;
            end;
         end;
      end;
   end;

   // Совершенно аналогично для Fluid блоков.
   // Если нет ни одного SOLID блока к показу то мы визуализируем только
   // Fluid блоки.
   (*
   if (bonlyfluid) then
   begin
      for i:=0 to Length(x1)-2 do
      begin
         for j:=0 to Length(y1)-2 do
         begin
            for k:=0 to Length(z1)-2 do
            begin
               xc:=0.5*(x1[i]+x1[i+1]);
               yc:=0.5*(y1[j]+y1[j+1]);
               zc:=0.5*(z1[k]+z1[k+1]);

               if ((not(biso)) or
                (bisox and (xc<isovalgx))
                or (bisoy and (yc<isovalgy))
                or (bisoz and (zc<isovalgz)))
               then
               begin
                  ib:=bid[i][j][k];
                  // только FLUID.
                  if ((ib<>0) and
                   (body[ib].itype=3) // FLUID
                   and (body[ib].bvisible)) then
                  begin
                     SetLength(blockgraphics,Length(blockgraphics)+1);
                     blockgraphics[Length(blockgraphics)-1].xS:=x1[i];
                     blockgraphics[Length(blockgraphics)-1].xE:=x1[i+1];
                     blockgraphics[Length(blockgraphics)-1].yS:=y1[j];
                     blockgraphics[Length(blockgraphics)-1].yE:=y1[j+1];
                     blockgraphics[Length(blockgraphics)-1].zS:=z1[k];
                     blockgraphics[Length(blockgraphics)-1].zE:=z1[k+1];
                     // наследуем цвет и прозрачность.
                     blockgraphics[Length(blockgraphics)-1].redcolor:=body[ib].redcolor;
                     blockgraphics[Length(blockgraphics)-1].greencolor:=body[ib].greencolor;
                     blockgraphics[Length(blockgraphics)-1].bluecolor:=body[ib].bluecolor;
                     blockgraphics[Length(blockgraphics)-1].transparency:=body[ib].transparency;
                     blockgraphics[Length(blockgraphics)-1].dcol:=body[ib].dcol;
                     mask[i][j][k]:=Length(blockgraphics)-1;
                     bid[i][j][k]:=ib;
                  end;
               end;
            end;
         end;
      end;
   end;
     *)

    // подготовка списка линий
    // которые нужно перерисовывать.

    //eps:=1.0e-12;


    lvl:=0;
    (*
    for i:=1 to lb-1 do
    begin

       // найти в x1 позицию xS.
       for j1:=0 to length(x1)-1 do
       begin
          if (abs(x1[j1]-body[i].xS)<epsx) then
          begin
             //xS найдена в x1
              for j:=j1 to length(x1)-2 do
             begin
                // j - это позиция xS.
                if (abs(x1[j+1]-body[i].xE)<epsx) then
                begin
                // xE найдена в x1.

                   // конец найден
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='X';
                   vl[lvl-1].yS:=body[i].yS;
                   vl[lvl-1].yE:=body[i].yS;
                   vl[lvl-1].zS:=body[i].zS;
                   vl[lvl-1].zE:=body[i].zS;
                   vl[lvl-1].xS:=x1[j];
                   vl[lvl-1].xE:=body[i].xE;
                   break;
                end
                 else
                begin

                   // 24,11,2019
                   // не найден и ладно.
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='X';
                   vl[lvl-1].yS:=body[i].yS;
                   vl[lvl-1].yE:=body[i].yS;
                   vl[lvl-1].zS:=body[i].zS;
                   vl[lvl-1].zE:=body[i].zS;
                   vl[lvl-1].xS:=x1[j];
                   vl[lvl-1].xE:=x1[j+1];

                end;
             end;
             break;
          end;
       end;

       (*
       // найти в x1 позицию xS.
       for j1:=0 to length(x1)-1 do
       begin
          if (abs(x1[j1]-body[i].xS)<epsx) then
          begin
             for j:=j1 to length(x1)-2 do
             begin
                // j - это позиция xS.
                if (abs(x1[j+1]-body[i].xE)<epsx) then
                begin
                   // конец найден
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='X';
                   vl[lvl-1].yS:=body[i].yS;
                   vl[lvl-1].yE:=body[i].yS;
                   vl[lvl-1].zS:=body[i].zE;
                   vl[lvl-1].zE:=body[i].zE;
                   vl[lvl-1].xS:=x1[j1];
                   vl[lvl-1].xE:=body[i].xE;
                   break;
                end
                 else
                begin
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='X';
                   vl[lvl-1].yS:=body[i].yS;
                   vl[lvl-1].yE:=body[i].yS;
                   vl[lvl-1].zS:=body[i].zE;
                   vl[lvl-1].zE:=body[i].zE;
                   vl[lvl-1].xS:=x1[j1];
                   vl[lvl-1].xE:=x1[j+1];
                end;
             end;
             break;
          end;
       end;



       // найти в x1 позицию xS.
       for j1:=0 to length(x1)-1 do
       begin
          if (abs(x1[j1]-body[i].xS)<epsx) then
          begin
             for j:=j1 to length(x1)-2 do
             begin
                // j - это позиция xS.
                if (abs(x1[j+1]-body[i].xE)<epsx) then
                begin
                   // конец найден
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='X';
                   vl[lvl-1].yS:=body[i].yE;
                   vl[lvl-1].yE:=body[i].yE;
                   vl[lvl-1].zS:=body[i].zE;
                   vl[lvl-1].zE:=body[i].zE;
                   vl[lvl-1].xS:=x1[j1];
                   vl[lvl-1].xE:=body[i].xE;
                   break;
                end
                 else
                begin
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='X';
                   vl[lvl-1].yS:=body[i].yE;
                   vl[lvl-1].yE:=body[i].yE;
                   vl[lvl-1].zS:=body[i].zE;
                   vl[lvl-1].zE:=body[i].zE;
                   vl[lvl-1].xS:=x1[j1];
                   vl[lvl-1].xE:=x1[j+1];
                end;
             end;
             break;
          end;
       end;


       // найти в x1 позицию xS.
       for j1:=0 to length(x1)-1 do
       begin
          if (abs(x1[j1]-body[i].xS)<epsx) then
          begin
             for j:=j1 to length(x1)-2 do
             begin
             // j - это позиция xS.
             if (abs(x1[j+1]-body[i].xE)<epsx) then
             begin
                // конец найден
                 inc(lvl);
                 SetLength(vl,lvl);
                 vl[lvl-1].normal:='X';
                 vl[lvl-1].yS:=body[i].yE;
                 vl[lvl-1].yE:=body[i].yE;
                 vl[lvl-1].zS:=body[i].zS;
                 vl[lvl-1].zE:=body[i].zS;
                 vl[lvl-1].xS:=x1[j1];
                 vl[lvl-1].xE:=body[i].xE;
                 break;
             end
             else
             begin
                inc(lvl);
                 SetLength(vl,lvl);
                 vl[lvl-1].normal:='X';
                 vl[lvl-1].yS:=body[i].yE;
                 vl[lvl-1].yE:=body[i].yE;
                 vl[lvl-1].zS:=body[i].zS;
                 vl[lvl-1].zE:=body[i].zS;
                 vl[lvl-1].xS:=x1[j1];
                vl[lvl-1].xE:=x1[j+1];
             end;
             end;
             break;
          end;
       end;
       *)
        (*
       // найти в y1 позицию yS.
       for j1:=0 to length(y1)-1 do
       begin
          if (abs(y1[j1]-body[i].yS)<epsy) then
          begin
             for j:=j1 to length(y1)-2 do
             begin
                // j - это позиция yS.
                if (abs(y1[j+1]-body[i].yE)<epsy) then
                begin
                   // конец найден
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='Y';
                   vl[lvl-1].xS:=body[i].xS;
                   vl[lvl-1].xE:=body[i].xS;
                   vl[lvl-1].zS:=body[i].zS;
                   vl[lvl-1].zE:=body[i].zS;
                   vl[lvl-1].yS:=y1[j];
                   vl[lvl-1].yE:=body[i].yE;
                   break;
                end
                 else
                begin

                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='Y';
                   vl[lvl-1].xS:=body[i].xS;
                   vl[lvl-1].xE:=body[i].xS;
                   vl[lvl-1].zS:=body[i].zS;
                   vl[lvl-1].zE:=body[i].zS;
                   vl[lvl-1].yS:=y1[j];
                   vl[lvl-1].yE:=y1[j+1];

                end;
             end;
             break;
          end;
       end;

       (*
       // найти в y1 позицию yS.
       for j1:=0 to length(y1)-1 do
       begin
          if (abs(y1[j1]-body[i].yS)<epsy) then
          begin
             for j:=j1 to length(y1)-2 do
             begin
                // j - это позиция yS.
                if (abs(y1[j+1]-body[i].yE)<epsy) then
                begin
                   // конец найден
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Y';
                    vl[lvl-1].xS:=body[i].xS;
                    vl[lvl-1].xE:=body[i].xS;
                    vl[lvl-1].zS:=body[i].zE;
                    vl[lvl-1].zE:=body[i].zE;
                    vl[lvl-1].yS:=y1[j];
                    vl[lvl-1].yE:=body[i].yE;
                    break;
                end
                 else
                begin
                   inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Y';
                    vl[lvl-1].xS:=body[i].xS;
                    vl[lvl-1].xE:=body[i].xS;
                    vl[lvl-1].zS:=body[i].zE;
                    vl[lvl-1].zE:=body[i].zE;
                    vl[lvl-1].yS:=y1[j];
                   vl[lvl-1].yE:=y1[j+1];
                end;
             end;
             break;
          end;
       end;



       // найти в y1 позицию yS.
       for j1:=0 to length(y1)-1 do
       begin
          if (abs(y1[j1]-body[i].yS)<epsy) then
          begin
             for j:=j1 to length(y1)-2 do
             begin
                // j - это позиция yS.
                if (abs(y1[j+1]-body[i].yE)<epsy) then
                begin
                   // конец найден
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='Y';
                   vl[lvl-1].xS:=body[i].xE;
                   vl[lvl-1].xE:=body[i].xE;
                   vl[lvl-1].zS:=body[i].zE;
                   vl[lvl-1].zE:=body[i].zE;
                   vl[lvl-1].yS:=y1[j];
                   vl[lvl-1].yE:=body[i].yE;
                   break;
                end
                 else
                begin
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='Y';
                   vl[lvl-1].xS:=body[i].xE;
                   vl[lvl-1].xE:=body[i].xE;
                   vl[lvl-1].zS:=body[i].zE;
                   vl[lvl-1].zE:=body[i].zE;
                   vl[lvl-1].yS:=y1[j];
                   vl[lvl-1].yE:=y1[j+1];
                end;
             end;
             break;
          end;
       end;


       // найти в y1 позицию yS.
       for j1:=0 to length(y1)-1 do
       begin
          if (abs(y1[j1]-body[i].yS)<epsy) then
          begin
             for j:=j1 to length(y1)-2 do
             begin
                // j - это позиция yS.
                if (abs(y1[j+1]-body[i].yE)<epsy) then
                begin
                   // конец найден
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Y';
                    vl[lvl-1].xS:=body[i].xE;
                    vl[lvl-1].xE:=body[i].xE;
                    vl[lvl-1].zS:=body[i].zS;
                    vl[lvl-1].zE:=body[i].zS;
                    vl[lvl-1].yS:=y1[j];
                    vl[lvl-1].yE:=body[i].yE;
                    break;
                end
                 else
                begin
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Y';
                    vl[lvl-1].xS:=body[i].xE;
                    vl[lvl-1].xE:=body[i].xE;
                    vl[lvl-1].zS:=body[i].zS;
                    vl[lvl-1].zE:=body[i].zS;
                    vl[lvl-1].yS:=y1[j];
                   vl[lvl-1].yE:=y1[j+1];
                end;
             end;
             break;
          end;
       end;
        *)
        (*
       // найти в z1 позицию zS.
       for j1:=0 to length(z1)-1 do
       begin
          if (abs(z1[j1]-body[i].zS)<epsz) then
          begin
             for j:=j1 to length(z1)-2 do
             begin
                // j - это позиция zS.
                if (abs(z1[j+1]-body[i].zE)<epsz) then
                begin
                   // конец найден
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Z';
                    vl[lvl-1].xS:=body[i].xS;
                    vl[lvl-1].xE:=body[i].xS;
                    vl[lvl-1].yS:=body[i].yS;
                    vl[lvl-1].yE:=body[i].yS;
                    vl[lvl-1].zS:=z1[j];
                    vl[lvl-1].zE:=body[i].zE;
                    break;
                end
                 else
                begin

                   inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Z';
                    vl[lvl-1].xS:=body[i].xS;
                    vl[lvl-1].xE:=body[i].xS;
                    vl[lvl-1].yS:=body[i].yS;
                    vl[lvl-1].yE:=body[i].yS;
                    vl[lvl-1].zS:=z1[j];
                   vl[lvl-1].zE:=z1[j+1];

                end;
             end;
             break;
          end;
       end;

       (*
       // найти в z1 позицию zS.
       for j1:=0 to length(z1)-1 do
       begin
          if (abs(z1[j1]-body[i].zS)<epsz) then
          begin
             for j:=j1 to length(z1)-2 do
             begin
                // j - это позиция zS.
                if (abs(z1[j+1]-body[i].zE)<epsz) then
                begin
                   // конец найден
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Z';
                    vl[lvl-1].xS:=body[i].xS;
                    vl[lvl-1].xE:=body[i].xS;
                    vl[lvl-1].yS:=body[i].yE;
                    vl[lvl-1].yE:=body[i].yE;
                    vl[lvl-1].zS:=z1[j];
                    vl[lvl-1].zE:=body[i].zE;
                    break;
                end
                 else
                begin
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Z';
                    vl[lvl-1].xS:=body[i].xS;
                    vl[lvl-1].xE:=body[i].xS;
                    vl[lvl-1].yS:=body[i].yE;
                    vl[lvl-1].yE:=body[i].yE;
                    vl[lvl-1].zS:=z1[j];
                   vl[lvl-1].zE:=z1[j+1];
                end;
             end;
             break;
          end;
       end;


       // найти в z1 позицию zS.
       for j1:=0 to length(z1)-1 do
       begin
          if (abs(z1[j1]-body[i].zS)<epsz) then
          begin
             for j:=j1 to length(z1)-2 do
             begin
                // j - это позиция zS.
                if (abs(z1[j+1]-body[i].zE)<epsz) then
                begin
                   // конец найден
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='Z';
                   vl[lvl-1].xS:=body[i].xE;
                   vl[lvl-1].xE:=body[i].xE;
                   vl[lvl-1].yS:=body[i].yS;
                   vl[lvl-1].yE:=body[i].yS;
                   vl[lvl-1].zS:=z1[j];
                   vl[lvl-1].zE:=body[i].zE;
                   break;
                end
                 else
                begin
                   inc(lvl);
                   SetLength(vl,lvl);
                   vl[lvl-1].normal:='Z';
                   vl[lvl-1].xS:=body[i].xE;
                   vl[lvl-1].xE:=body[i].xE;
                   vl[lvl-1].yS:=body[i].yS;
                   vl[lvl-1].yE:=body[i].yS;
                   vl[lvl-1].zS:=z1[j];
                   vl[lvl-1].zE:=z1[j+1];
                end;
             end;
             break;
          end;
       end;



       // найти в z1 позицию zS.
       for j1:=0 to length(z1)-1 do
       begin
          if (abs(z1[j1]-body[i].zS)<epsz) then
          begin
             for j:=j1 to length(z1)-2 do
             begin
                // j - это позиция zS.
                if (abs(z1[j+1]-body[i].zE)<epsz) then
                begin
                   // конец найден
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Z';
                    vl[lvl-1].xS:=body[i].xE;
                    vl[lvl-1].xE:=body[i].xE;
                    vl[lvl-1].yS:=body[i].yE;
                    vl[lvl-1].yE:=body[i].yE;
                    vl[lvl-1].zS:=z1[j];
                    vl[lvl-1].zE:=body[i].zE;
                    break;
                end
                 else
                begin
                    inc(lvl);
                    SetLength(vl,lvl);
                    vl[lvl-1].normal:='Z';
                    vl[lvl-1].xS:=body[i].xE;
                    vl[lvl-1].xE:=body[i].xE;
                    vl[lvl-1].yS:=body[i].yE;
                    vl[lvl-1].yE:=body[i].yE;
                    vl[lvl-1].zS:=z1[j];
                   vl[lvl-1].zE:=z1[j+1];
                end;
             end;
             break;
          end;
       end;
       *)
        (*
       inc(lvl);
    end;
    dec(lvl); // длина vl.
    *)
   // ShowMessage(IntToStr(lvl)); //160
    (*
    for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           ShowMessage(FloatToStr(vl[j].yS)+' '+FloatToStr(vl[j].yE));
        end;
     end;
     *)
     (*
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           ShowMessage(FloatToStr(vl[j].xS)+' '+FloatToStr(vl[j].xE));
        end;
     end;
     *)
     (*
     binit:=true;

     // изначально все линии не прорисовываем.
   for i:=0 to Length(blockgraphics)-1 do
   begin
      // TOP
      blockgraphics[i].zE_xE2xS:=binit;
      blockgraphics[i].zE_yE2yS:=binit;
      blockgraphics[i].zE_xS2xE:=binit;
      blockgraphics[i].zE_yS2yE:=binit;
      // BOTTOM
      blockgraphics[i].zS_yE2yS:=binit;
      blockgraphics[i].zS_xE2xS:=binit;
      blockgraphics[i].zS_yS2yE:=binit;
      blockgraphics[i].zS_xS2xE:=binit;
      // индикация прорисовки линий на WEST грани.
      blockgraphics[i].xS_zE2zS:=binit;
      blockgraphics[i].xS_yE2yS:=binit;
      blockgraphics[i].xS_zS2zE:=binit;
      blockgraphics[i].xS_yS2yE:=binit;
      // индикация прорисовки линий на EAST грани.
      blockgraphics[i].xE_zE2zS:=binit;
      blockgraphics[i].xE_yE2yS:=binit;
      blockgraphics[i].xE_zS2zE:=binit;
      blockgraphics[i].xE_yS2yE:=binit;
      // North
      blockgraphics[i].yE_zS2zE:=binit;
      blockgraphics[i].yE_xS2xE:=binit;
      blockgraphics[i].yE_zE2zS:=binit;
      blockgraphics[i].yE_xE2xS:=binit;
      // Soush
      blockgraphics[i].yS_xS2xE:=binit;
      blockgraphics[i].yS_zS2zE:=binit;
      blockgraphics[i].yS_xE2xS:=binit;
      blockgraphics[i].yS_zE2zS:=binit;
   end;
    *)
   //eps:=1.0e-12;
   (*
   if (not(binit)) then
   begin

   for i:=0 to Length(blockgraphics)-1 do
   begin
     // TOP
     // blockgraphics[i].zE_xE2xS;
     // X
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
          if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)
          and (abs(vl[j].xE-blockgraphics[i].xE)<epsx)
          then
           begin
              //ShowMessage(IntToStr(lvl));
              if ((abs(vl[j].yS-blockgraphics[i].yE)<epsy)
               and (abs(vl[j].zS-blockgraphics[i].zE)<epsz))
                then
              begin
                 blockgraphics[i].zE_xE2xS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].zE_yE2yS;
      // Y
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy) and (abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx) and (abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].zE_yE2yS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].zE_xS2xE;
      // X
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].zE_xS2xE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].zE_yS2yE;
      // Y
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx)and(abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].zE_yS2yE:=true;
              end;
           end;
        end;
     end;
      // BOTTOM
      //blockgraphics[i].zS_yE2yS;
       // Y
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].zS_yE2yS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].zS_xE2xS;
      // X
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].zS_xE2xS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].zS_yS2yE;
      // Y
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].zS_yS2yE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].zS_xS2xE;
      // X
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yE)<epsy)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].zS_xS2xE:=true;
              end;
           end;
        end;
     end;
      // индикация прорисовки линий на WEST грани.
      //blockgraphics[i].xS_zE2zS;
      // Z
        for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].yS-blockgraphics[i].yE)<epsy)) then
              begin
                 blockgraphics[i].xS_zE2zS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].xS_yE2yS;
     // Y
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].xS_yE2yS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].xS_zS2zE:=False;
      // Z
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].yS-blockgraphics[i].yS)<epsy)) then
              begin
                 blockgraphics[i].xS_zS2zE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].xS_yS2yE;
      // Y
     for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy) and (abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx) and (abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].xS_yS2yE:=true;
              end;
           end;
        end;
     end;
      // индикация прорисовки линий на EAST грани.
      //blockgraphics[i].xE_zE2zS;
      // Z
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx)and(abs(vl[j].yS-blockgraphics[i].yE)<epsy)) then
              begin
                 blockgraphics[i].xE_zE2zS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].xE_yE2yS;
       // Y
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy) and (abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx) and (abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].xE_yE2yS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].xE_zS2zE;
      // Z
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx)and(abs(vl[j].yS-blockgraphics[i].yS)<epsy)) then
              begin
                 blockgraphics[i].xE_zS2zE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].xE_yS2yE;
      // Y
      for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Y') then
        begin
           if (abs(vl[j].yS-blockgraphics[i].yS)<epsy) and (abs(vl[j].yE-blockgraphics[i].yE)<epsy) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx) and (abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].xE_yS2yE:=true;
              end;
           end;
        end;
     end;
      // North
      //blockgraphics[i].yE_zS2zE;
      // Z
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].yS-blockgraphics[i].yE)<epsy)) then
              begin
                 blockgraphics[i].yE_zS2zE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].yE_xS2xE;
      // X
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yE)<epsy)and(abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].yE_xS2xE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].yE_zE2zS;
      // Z
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx)and(abs(vl[j].yS-blockgraphics[i].yE)<epsy)) then
              begin
                 blockgraphics[i].yE_zE2zS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].yE_xE2xS;
      // X
        for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yE)<epsy)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].yE_xE2xS:=true;
              end;
           end;
        end;
     end;
      // Soush
      //blockgraphics[i].yS_xS2xE;
      // X
      for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].zS-blockgraphics[i].zS)<epsz)) then
              begin
                 blockgraphics[i].yS_xS2xE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].yS_zS2zE;
      // Z
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xE)<epsx)and(abs(vl[j].yS-blockgraphics[i].yS)<epsy)) then
              begin
                 blockgraphics[i].yS_zS2zE:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].yS_xE2xS;
      // X
       for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='X') then
        begin
           if (abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].xE-blockgraphics[i].xE)<epsx) then
           begin
              if ((abs(vl[j].yS-blockgraphics[i].yS)<epsy)and(abs(vl[j].zS-blockgraphics[i].zE)<epsz)) then
              begin
                 blockgraphics[i].yS_xE2xS:=true;
              end;
           end;
        end;
     end;
      //blockgraphics[i].yS_zE2zS;
      // Z
      for j:=0 to length(vl)-1 do
     begin
        if (vl[j].normal='Z') then
        begin
           if (abs(vl[j].zS-blockgraphics[i].zS)<epsz)and(abs(vl[j].zE-blockgraphics[i].zE)<epsz) then
           begin
              if ((abs(vl[j].xS-blockgraphics[i].xS)<epsx)and(abs(vl[j].yS-blockgraphics[i].yS)<epsy)) then
              begin
                 blockgraphics[i].yS_zE2zS:=true;
              end;
           end;
        end;
     end;
   end;
 end;
   *)
   // Я отказался от  идеи объединения, так как она плохо формализуема в пользу идеи
   // в которой я не прорисовываю грань если она встречается дважды. Для идеи не
   // проррисовывать грань если она встречается дважды важно не выполнять никаких объединений.
   // Это существенным образом ускоряет рендеринг.
   (*
   SetLength(vg,0);

   SetLength(vgloc,6);// 6 граней куба
   for i:=0 to Length(blockgraphics)-1 do
   begin
     // if (blockgraphics[i].igeometry_type<>2) then
      begin

         vgloc[0].xc:=0.5*(blockgraphics[i].xS+blockgraphics[i].xE);
         vgloc[0].yc:=0.5*(blockgraphics[i].yS+blockgraphics[i].yE);
         vgloc[0].zc:=blockgraphics[i].zE;
         vgloc[0].start_on:=False; // z End
         vgloc[0].redcolor:=blockgraphics[i].redcolor;
         vgloc[0].greencolor:=blockgraphics[i].greencolor;
         vgloc[0].bluecolor:=blockgraphics[i].bluecolor;
         vgloc[0].transparency:=blockgraphics[i].transparency;
         vgloc[0].iPlane:=1; // XY
         vgloc[0].xS:=blockgraphics[i].xS;
         vgloc[0].xE:=blockgraphics[i].xE;
         vgloc[0].yS:=blockgraphics[i].yS;
         vgloc[0].yE:=blockgraphics[i].yE;
         vgloc[0].zS:=blockgraphics[i].zS;
         vgloc[0].zE:=blockgraphics[i].zE;
         // 10 marth 2015 для каркасной модели с удалением невидимых линий.
         // zE
         vgloc[0].zE_xE2xS:=blockgraphics[i].zE_xE2xS;
         vgloc[0].zE_yE2yS:=blockgraphics[i].zE_yE2yS;
         vgloc[0].zE_xS2xE:=blockgraphics[i].zE_xS2xE;
         vgloc[0].zE_yS2yE:=blockgraphics[i].zE_yS2yE;
         // zS
         vgloc[0].zS_yE2yS:=blockgraphics[i].zS_yE2yS;
         vgloc[0].zS_xE2xS:=blockgraphics[i].zS_xE2xS;
         vgloc[0].zS_yS2yE:=blockgraphics[i].zS_yS2yE;
         vgloc[0].zS_xS2xE:=blockgraphics[i].zS_xS2xE;
         // xS
         vgloc[0].xS_zE2zS:=blockgraphics[i].xS_zE2zS;
         vgloc[0].xS_yE2yS:=blockgraphics[i].xS_yE2yS;
         vgloc[0].xS_zS2zE:=blockgraphics[i].xS_zS2zE;
         vgloc[0].xS_yS2yE:=blockgraphics[i].xS_yS2yE;
         // xE
         vgloc[0].xE_zE2zS:=blockgraphics[i].xE_zE2zS;
         vgloc[0].xE_yE2yS:=blockgraphics[i].xE_yE2yS;
         vgloc[0].xE_zS2zE:=blockgraphics[i].xE_zS2zE;
         vgloc[0].xE_yS2yE:=blockgraphics[i].xE_yS2yE;
         // yE
         vgloc[0].yE_zS2zE:=blockgraphics[i].yE_zS2zE;
         vgloc[0].yE_xS2xE:=blockgraphics[i].yE_xS2xE;
         vgloc[0].yE_zE2zS:=blockgraphics[i].yE_zE2zS;
         vgloc[0].yE_xE2xS:=blockgraphics[i].yE_xE2xS;
         // yS
         vgloc[0].yS_xS2xE:=blockgraphics[i].yS_xS2xE;
         vgloc[0].yS_zS2zE:=blockgraphics[i].yS_zS2zE;
         vgloc[0].yS_xE2xS:=blockgraphics[i].yS_xE2xS;
         vgloc[0].yS_zE2zS:=blockgraphics[i].yS_zE2zS;


         vgloc[1].xc:=0.5*(blockgraphics[i].xS+blockgraphics[i].xE);
         vgloc[1].yc:=0.5*(blockgraphics[i].yS+blockgraphics[i].yE);
         vgloc[1].zc:=blockgraphics[i].zS;
         vgloc[1].start_on:=True; // z Start
         vgloc[1].redcolor:=blockgraphics[i].redcolor;
         vgloc[1].greencolor:=blockgraphics[i].greencolor;
         vgloc[1].bluecolor:=blockgraphics[i].bluecolor;
         vgloc[1].transparency:=blockgraphics[i].transparency;
         vgloc[1].iPlane:=1; // XY
         vgloc[1].xS:=blockgraphics[i].xS;
         vgloc[1].xE:=blockgraphics[i].xE;
         vgloc[1].yS:=blockgraphics[i].yS;
         vgloc[1].yE:=blockgraphics[i].yE;
         vgloc[1].zS:=blockgraphics[i].zS;
         vgloc[1].zE:=blockgraphics[i].zE;
         // 10 marth 2015 для каркасной модели с удалением невидимых линий.
         // zE
         vgloc[1].zE_xE2xS:=blockgraphics[i].zE_xE2xS;
         vgloc[1].zE_yE2yS:=blockgraphics[i].zE_yE2yS;
         vgloc[1].zE_xS2xE:=blockgraphics[i].zE_xS2xE;
         vgloc[1].zE_yS2yE:=blockgraphics[i].zE_yS2yE;
         // zS
         vgloc[1].zS_yE2yS:=blockgraphics[i].zS_yE2yS;
         vgloc[1].zS_xE2xS:=blockgraphics[i].zS_xE2xS;
         vgloc[1].zS_yS2yE:=blockgraphics[i].zS_yS2yE;
         vgloc[1].zS_xS2xE:=blockgraphics[i].zS_xS2xE;
         // xS
         vgloc[1].xS_zE2zS:=blockgraphics[i].xS_zE2zS;
         vgloc[1].xS_yE2yS:=blockgraphics[i].xS_yE2yS;
         vgloc[1].xS_zS2zE:=blockgraphics[i].xS_zS2zE;
         vgloc[1].xS_yS2yE:=blockgraphics[i].xS_yS2yE;
         // xE
         vgloc[1].xE_zE2zS:=blockgraphics[i].xE_zE2zS;
         vgloc[1].xE_yE2yS:=blockgraphics[i].xE_yE2yS;
         vgloc[1].xE_zS2zE:=blockgraphics[i].xE_zS2zE;
         vgloc[1].xE_yS2yE:=blockgraphics[i].xE_yS2yE;
         // yE
         vgloc[1].yE_zS2zE:=blockgraphics[i].yE_zS2zE;
         vgloc[1].yE_xS2xE:=blockgraphics[i].yE_xS2xE;
         vgloc[1].yE_zE2zS:=blockgraphics[i].yE_zE2zS;
         vgloc[1].yE_xE2xS:=blockgraphics[i].yE_xE2xS;
         // yS
         vgloc[1].yS_xS2xE:=blockgraphics[i].yS_xS2xE;
         vgloc[1].yS_zS2zE:=blockgraphics[i].yS_zS2zE;
         vgloc[1].yS_xE2xS:=blockgraphics[i].yS_xE2xS;
         vgloc[1].yS_zE2zS:=blockgraphics[i].yS_zE2zS;



         vgloc[2].xc:=blockgraphics[i].xS;
         vgloc[2].yc:=0.5*(blockgraphics[i].yS+blockgraphics[i].yE);
         vgloc[2].zc:=0.5*(blockgraphics[i].zS+blockgraphics[i].zE);
         vgloc[2].start_on:=True; // x Start
         vgloc[2].redcolor:=blockgraphics[i].redcolor;
         vgloc[2].greencolor:=blockgraphics[i].greencolor;
         vgloc[2].bluecolor:=blockgraphics[i].bluecolor;
         vgloc[2].transparency:=blockgraphics[i].transparency;
         vgloc[2].iPlane:=3; // YZ
         vgloc[2].xS:=blockgraphics[i].xS;
         vgloc[2].xE:=blockgraphics[i].xE;
         vgloc[2].yS:=blockgraphics[i].yS;
         vgloc[2].yE:=blockgraphics[i].yE;
         vgloc[2].zS:=blockgraphics[i].zS;
         vgloc[2].zE:=blockgraphics[i].zE;
         // 10 marth 2015 для каркасной модели с удалением невидимых линий.
         // zE
         vgloc[2].zE_xE2xS:=blockgraphics[i].zE_xE2xS;
         vgloc[2].zE_yE2yS:=blockgraphics[i].zE_yE2yS;
         vgloc[2].zE_xS2xE:=blockgraphics[i].zE_xS2xE;
         vgloc[2].zE_yS2yE:=blockgraphics[i].zE_yS2yE;
         // zS
         vgloc[2].zS_yE2yS:=blockgraphics[i].zS_yE2yS;
         vgloc[2].zS_xE2xS:=blockgraphics[i].zS_xE2xS;
         vgloc[2].zS_yS2yE:=blockgraphics[i].zS_yS2yE;
         vgloc[2].zS_xS2xE:=blockgraphics[i].zS_xS2xE;
         // xS
         vgloc[2].xS_zE2zS:=blockgraphics[i].xS_zE2zS;
         vgloc[2].xS_yE2yS:=blockgraphics[i].xS_yE2yS;
         vgloc[2].xS_zS2zE:=blockgraphics[i].xS_zS2zE;
         vgloc[2].xS_yS2yE:=blockgraphics[i].xS_yS2yE;
         // xE
         vgloc[2].xE_zE2zS:=blockgraphics[i].xE_zE2zS;
         vgloc[2].xE_yE2yS:=blockgraphics[i].xE_yE2yS;
         vgloc[2].xE_zS2zE:=blockgraphics[i].xE_zS2zE;
         vgloc[2].xE_yS2yE:=blockgraphics[i].xE_yS2yE;
         // yE
         vgloc[2].yE_zS2zE:=blockgraphics[i].yE_zS2zE;
         vgloc[2].yE_xS2xE:=blockgraphics[i].yE_xS2xE;
         vgloc[2].yE_zE2zS:=blockgraphics[i].yE_zE2zS;
         vgloc[2].yE_xE2xS:=blockgraphics[i].yE_xE2xS;
         // yS
         vgloc[2].yS_xS2xE:=blockgraphics[i].yS_xS2xE;
         vgloc[2].yS_zS2zE:=blockgraphics[i].yS_zS2zE;
         vgloc[2].yS_xE2xS:=blockgraphics[i].yS_xE2xS;
         vgloc[2].yS_zE2zS:=blockgraphics[i].yS_zE2zS;


         vgloc[3].xc:=blockgraphics[i].xE;
         vgloc[3].yc:=0.5*(blockgraphics[i].yS+blockgraphics[i].yE);
         vgloc[3].zc:=0.5*(blockgraphics[i].zS+blockgraphics[i].zE);
         vgloc[3].start_on:=False; // x End
         vgloc[3].redcolor:=blockgraphics[i].redcolor;
         vgloc[3].greencolor:=blockgraphics[i].greencolor;
         vgloc[3].bluecolor:=blockgraphics[i].bluecolor;
         vgloc[3].transparency:=blockgraphics[i].transparency;
         vgloc[3].iPlane:=3; // YZ
         vgloc[3].xS:=blockgraphics[i].xS;
         vgloc[3].xE:=blockgraphics[i].xE;
         vgloc[3].yS:=blockgraphics[i].yS;
         vgloc[3].yE:=blockgraphics[i].yE;
         vgloc[3].zS:=blockgraphics[i].zS;
         vgloc[3].zE:=blockgraphics[i].zE;
         // 10 marth 2015 для каркасной модели с удалением невидимых линий.
         // zE
         vgloc[3].zE_xE2xS:=blockgraphics[i].zE_xE2xS;
         vgloc[3].zE_yE2yS:=blockgraphics[i].zE_yE2yS;
         vgloc[3].zE_xS2xE:=blockgraphics[i].zE_xS2xE;
         vgloc[3].zE_yS2yE:=blockgraphics[i].zE_yS2yE;
         // zS
         vgloc[3].zS_yE2yS:=blockgraphics[i].zS_yE2yS;
         vgloc[3].zS_xE2xS:=blockgraphics[i].zS_xE2xS;
         vgloc[3].zS_yS2yE:=blockgraphics[i].zS_yS2yE;
         vgloc[3].zS_xS2xE:=blockgraphics[i].zS_xS2xE;
         // xS
         vgloc[3].xS_zE2zS:=blockgraphics[i].xS_zE2zS;
         vgloc[3].xS_yE2yS:=blockgraphics[i].xS_yE2yS;
         vgloc[3].xS_zS2zE:=blockgraphics[i].xS_zS2zE;
         vgloc[3].xS_yS2yE:=blockgraphics[i].xS_yS2yE;
         // xE
         vgloc[3].xE_zE2zS:=blockgraphics[i].xE_zE2zS;
         vgloc[3].xE_yE2yS:=blockgraphics[i].xE_yE2yS;
         vgloc[3].xE_zS2zE:=blockgraphics[i].xE_zS2zE;
         vgloc[3].xE_yS2yE:=blockgraphics[i].xE_yS2yE;
         // yE
         vgloc[3].yE_zS2zE:=blockgraphics[i].yE_zS2zE;
         vgloc[3].yE_xS2xE:=blockgraphics[i].yE_xS2xE;
         vgloc[3].yE_zE2zS:=blockgraphics[i].yE_zE2zS;
         vgloc[3].yE_xE2xS:=blockgraphics[i].yE_xE2xS;
         // yS
         vgloc[3].yS_xS2xE:=blockgraphics[i].yS_xS2xE;
         vgloc[3].yS_zS2zE:=blockgraphics[i].yS_zS2zE;
         vgloc[3].yS_xE2xS:=blockgraphics[i].yS_xE2xS;
         vgloc[3].yS_zE2zS:=blockgraphics[i].yS_zE2zS;


         vgloc[4].xc:=0.5*(blockgraphics[i].xS+blockgraphics[i].xE);
         vgloc[4].yc:=blockgraphics[i].yS;
         vgloc[4].zc:=0.5*(blockgraphics[i].zS+blockgraphics[i].zE);
         vgloc[4].start_on:=True; // y Start
         vgloc[4].redcolor:=blockgraphics[i].redcolor;
         vgloc[4].greencolor:=blockgraphics[i].greencolor;
         vgloc[4].bluecolor:=blockgraphics[i].bluecolor;
         vgloc[4].transparency:=blockgraphics[i].transparency;
         vgloc[4].iPlane:=2; // XZ
         vgloc[4].xS:=blockgraphics[i].xS;
         vgloc[4].xE:=blockgraphics[i].xE;
         vgloc[4].yS:=blockgraphics[i].yS;
         vgloc[4].yE:=blockgraphics[i].yE;
         vgloc[4].zS:=blockgraphics[i].zS;
         vgloc[4].zE:=blockgraphics[i].zE;
         // 10 marth 2015 для каркасной модели с удалением невидимых линий.
         // zE
         vgloc[4].zE_xE2xS:=blockgraphics[i].zE_xE2xS;
         vgloc[4].zE_yE2yS:=blockgraphics[i].zE_yE2yS;
         vgloc[4].zE_xS2xE:=blockgraphics[i].zE_xS2xE;
         vgloc[4].zE_yS2yE:=blockgraphics[i].zE_yS2yE;
         // zS
         vgloc[4].zS_yE2yS:=blockgraphics[i].zS_yE2yS;
         vgloc[4].zS_xE2xS:=blockgraphics[i].zS_xE2xS;
         vgloc[4].zS_yS2yE:=blockgraphics[i].zS_yS2yE;
         vgloc[4].zS_xS2xE:=blockgraphics[i].zS_xS2xE;
         // xS
         vgloc[4].xS_zE2zS:=blockgraphics[i].xS_zE2zS;
         vgloc[4].xS_yE2yS:=blockgraphics[i].xS_yE2yS;
         vgloc[4].xS_zS2zE:=blockgraphics[i].xS_zS2zE;
         vgloc[4].xS_yS2yE:=blockgraphics[i].xS_yS2yE;
         // xE
         vgloc[4].xE_zE2zS:=blockgraphics[i].xE_zE2zS;
         vgloc[4].xE_yE2yS:=blockgraphics[i].xE_yE2yS;
         vgloc[4].xE_zS2zE:=blockgraphics[i].xE_zS2zE;
         vgloc[4].xE_yS2yE:=blockgraphics[i].xE_yS2yE;
         // yE
         vgloc[4].yE_zS2zE:=blockgraphics[i].yE_zS2zE;
         vgloc[4].yE_xS2xE:=blockgraphics[i].yE_xS2xE;
         vgloc[4].yE_zE2zS:=blockgraphics[i].yE_zE2zS;
         vgloc[4].yE_xE2xS:=blockgraphics[i].yE_xE2xS;
         // yS
         vgloc[4].yS_xS2xE:=blockgraphics[i].yS_xS2xE;
         vgloc[4].yS_zS2zE:=blockgraphics[i].yS_zS2zE;
         vgloc[4].yS_xE2xS:=blockgraphics[i].yS_xE2xS;
         vgloc[4].yS_zE2zS:=blockgraphics[i].yS_zE2zS;


         vgloc[5].xc:=0.5*(blockgraphics[i].xS+blockgraphics[i].xE);
         vgloc[5].yc:=blockgraphics[i].yE;
         vgloc[5].zc:=0.5*(blockgraphics[i].zS+blockgraphics[i].zE);
         vgloc[5].start_on:=False; // y End
         vgloc[5].redcolor:=blockgraphics[i].redcolor;
         vgloc[5].greencolor:=blockgraphics[i].greencolor;
         vgloc[5].bluecolor:=blockgraphics[i].bluecolor;
         vgloc[5].transparency:=blockgraphics[i].transparency;
         vgloc[5].iPlane:=2; // XZ
         vgloc[5].xS:=blockgraphics[i].xS;
         vgloc[5].xE:=blockgraphics[i].xE;
         vgloc[5].yS:=blockgraphics[i].yS;
         vgloc[5].yE:=blockgraphics[i].yE;
         vgloc[5].zS:=blockgraphics[i].zS;
         vgloc[5].zE:=blockgraphics[i].zE;
         // 10 marth 2015 для каркасной модели с удалением невидимых линий.
         // zE
         vgloc[5].zE_xE2xS:=blockgraphics[i].zE_xE2xS;
         vgloc[5].zE_yE2yS:=blockgraphics[i].zE_yE2yS;
         vgloc[5].zE_xS2xE:=blockgraphics[i].zE_xS2xE;
         vgloc[5].zE_yS2yE:=blockgraphics[i].zE_yS2yE;
         // zS
         vgloc[5].zS_yE2yS:=blockgraphics[i].zS_yE2yS;
         vgloc[5].zS_xE2xS:=blockgraphics[i].zS_xE2xS;
         vgloc[5].zS_yS2yE:=blockgraphics[i].zS_yS2yE;
         vgloc[5].zS_xS2xE:=blockgraphics[i].zS_xS2xE;
         // xS
         vgloc[5].xS_zE2zS:=blockgraphics[i].xS_zE2zS;
         vgloc[5].xS_yE2yS:=blockgraphics[i].xS_yE2yS;
         vgloc[5].xS_zS2zE:=blockgraphics[i].xS_zS2zE;
         vgloc[5].xS_yS2yE:=blockgraphics[i].xS_yS2yE;
         // xE
         vgloc[5].xE_zE2zS:=blockgraphics[i].xE_zE2zS;
         vgloc[5].xE_yE2yS:=blockgraphics[i].xE_yE2yS;
         vgloc[5].xE_zS2zE:=blockgraphics[i].xE_zS2zE;
         vgloc[5].xE_yS2yE:=blockgraphics[i].xE_yS2yE;
         // yE
         vgloc[5].yE_zS2zE:=blockgraphics[i].yE_zS2zE;
         vgloc[5].yE_xS2xE:=blockgraphics[i].yE_xS2xE;
         vgloc[5].yE_zE2zS:=blockgraphics[i].yE_zE2zS;
         vgloc[5].yE_xE2xS:=blockgraphics[i].yE_xE2xS;
         // yS
         vgloc[5].yS_xS2xE:=blockgraphics[i].yS_xS2xE;
         vgloc[5].yS_zS2zE:=blockgraphics[i].yS_zS2zE;
         vgloc[5].yS_xE2xS:=blockgraphics[i].yS_xE2xS;
         vgloc[5].yS_zE2zS:=blockgraphics[i].yS_zE2zS;


         k:=Length(vg)-1;
         epsilon_tol:=1.0e-12;
         for i87 := 0 to 5 do
         begin
            bfound:=False;
            // построение списка уникальных граней.
            for j:=0 to k do
            begin
               if ((abs(vg[j].xc-vgloc[i87].xc)<epsx)and
               (abs(vg[j].yc-vgloc[i87].yc)<epsy)and
               (abs(vg[j].zc-vgloc[i87].zc)<epsz)) then
               begin
                  bfound:=True;
               end;
            end;
            if (not(bfound)) then
            begin
               SetLength(vg,Length(vg)+1);
               Inc(k);
               vg[Length(vg)-1]:=vgloc[i87];
               vg[Length(vg)-1].flagvisit:=false;
            end;
         end;

      end;
   end;

      // Запись в vg только уникальных граней которые
      // встречались не более одного раза.
      SetLength(vgloc,Length(vg));
      k:=0;
      for i87:=0 to Length(vg)-1 do
      begin
         if (vg[i87].flagvisit=False) then
         begin
            vgloc[k]:=vg[i87];
            inc(k);
         end;
      end;
      SetLength(vg,k);
      for i87:=0 to k-1 do
      begin
         vg[i87]:=vgloc[i87];
      end;
      SetLength(vgloc,0);
    *)

   (*
   // Объединение.
   SetLength(bmask,Length(x1),Length(y1),Length(z1));
   for i:=0 to Length(x1)-1 do
   begin
      for j:=0 to Length(y1)-1 do
      begin
         for k:=0 to Length(z1)-1 do
         begin
            bmask[i][j][k]:=false;
         end;
      end;
   end;
   for i:=0 to Length(x1)-1 do
   begin
      for j:=0 to Length(y1)-1 do
      begin
         for k:=0 to Length(z1)-1 do
         begin
            if (mask[i][j][k]>=0) then
            begin
               bmask[i][j][k]:=true;
            end;
         end;
      end;
   end;

   SetLength(bg,Length(blockgraphics));
   for i:=0 to Length(blockgraphics)-1 do
   begin
      bg[i]:=blockgraphics[i];
   end;
   SetLength(blockgraphics,0);

   // объединение восьмёрок.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i+1][j][k] and bmask[i][j+1][k] and  bmask[i][j][k+1] and bmask[i+1][j+1][k] and bmask[i][j+1][k+1] and bmask[i+1][j][k+1] and  bmask[i+1][j+1][k+1] ) then
            begin
               if ((bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i][j][k+1]) and (bid[i][j][k]=bid[i+1][j+1][k]) and (bid[i][j][k]=bid[i][j+1][k+1])and (bid[i][j][k]=bid[i+1][j][k+1])and (bid[i][j][k]=bid[i+1][j+1][k+1])) then
               begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+1][j+1][k+1]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+1][j+1][k+1]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+1][j+1][k+1]].zE;
               bmask[i][j][k]:=False;
               bmask[i+1][j][k]:=False;
               bmask[i][j+1][k]:=False;
               bmask[i][j][k+1]:=False;
               bmask[i+1][j+1][k]:=False;
               bmask[i+1][j][k+1]:=False;
               bmask[i+1][j+1][k+1]:=False;
               bmask[i][j+1][k+1]:=False;
              end;
            end;
         end;
      end;
   end;

    // объединение шестёрок k.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j][k+1] and bmask[i][j+1][k] and  bmask[i][j+1][k+1] and  bmask[i][j+1][k+2] and  bmask[i][j][k+2]) then
            begin
               if ((bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i][j][k+1]) and (bid[i][j][k]=bid[i][j+1][k+1]) and (bid[i][j][k]=bid[i][j][k+2]) and (bid[i][j][k]=bid[i][j+1][k+2])) then
               begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j+1][k+2]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j+1][k+2]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j+1][k+2]].zE;
               bmask[i][j][k]:=False;
               bmask[i][j][k+1]:=False;
               bmask[i][j+1][k]:=False;
               bmask[i][j+1][k+1]:=False;
               bmask[i][j][k+2]:=False;
               bmask[i][j+1][k+2]:=False;
              end;
            end;
         end;
      end;
   end;

   // объединение шестёрок j.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i+1][j][k] and bmask[i][j+1][k] and  bmask[i+1][j+1][k] and bmask[i][j+2][k] and  bmask[i+1][j+2][k]) then
            begin
               if ((bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i+1][j+1][k])  and (bid[i][j][k]=bid[i][j+2][k]) and (bid[i][j][k]=bid[i+1][j+2][k])) then
               begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+1][j+2][k]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+1][j+2][k]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+1][j+2][k]].zE;
               bmask[i][j][k]:=False;
               bmask[i+1][j][k]:=False;
               bmask[i][j+1][k]:=False;
               bmask[i+1][j+1][k]:=False;
               bmask[i][j+2][k]:=False;
               bmask[i+1][j+2][k]:=False;
              end;
            end;
         end;
      end;
   end;


   // объединение шестёрок i.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i+1][j][k] and bmask[i][j+1][k] and  bmask[i+1][j+1][k] and  bmask[i+2][j][k] and  bmask[i+2][j+1][k]) then
            begin
               if ((bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i+1][j+1][k]) and (bid[i][j][k]=bid[i+2][j][k]) and (bid[i][j][k]=bid[i+2][j+1][k])) then
               begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
               blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
               blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
               blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
               blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+2][j+1][k]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+2][j+1][k]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+2][j+1][k]].zE;
               bmask[i][j][k]:=False;
               bmask[i+1][j][k]:=False;
               bmask[i][j+1][k]:=False;
               bmask[i+1][j+1][k]:=False;
                bmask[i+2][j][k]:=False;
                bmask[i+2][j+1][k]:=False;
              end;
            end;
         end;
      end;
   end;

   // объединение четвёрок.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i+1][j][k] and bmask[i][j+1][k] and  bmask[i+1][j+1][k]) then
            begin
               if ((bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i+1][j+1][k]) ) then
               begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+1][j+1][k]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+1][j+1][k]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+1][j+1][k]].zE;
               bmask[i][j][k]:=False;
               bmask[i+1][j][k]:=False;
               bmask[i][j+1][k]:=False;
               bmask[i+1][j+1][k]:=False;
              end;
            end;
         end;
      end;
   end;




   // объединение четвёрок.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j][k+1] and bmask[i][j+1][k] and  bmask[i][j+1][k+1]) then
            begin
               if ((bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i][j][k+1]) and (bid[i][j][k]=bid[i][j+1][k+1]) ) then
               begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j+1][k+1]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j+1][k+1]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j+1][k+1]].zE;
               bmask[i][j][k]:=False;
               bmask[i][j][k+1]:=False;
               bmask[i][j+1][k]:=False;
               bmask[i][j+1][k+1]:=False;
              end;
            end;
         end;
      end;
   end;

   // объединение четвёрок.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j][k+1] and bmask[i+1][j][k] and  bmask[i+1][j][k+1]) then
            begin
               if ((bid[i][j][k]=bid[i][j][k+1]) and (bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i+1][j][k+1]) ) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+1][j][k+1]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+1][j][k+1]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+1][j][k+1]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i][j][k+1]:=False;
                  bmask[i+1][j][k]:=False;
                  bmask[i+1][j][k+1]:=False;
              end;
            end;
         end;
      end;
   end;


   // объединение четвёрок i-long 4.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i+1][j][k] and bmask[i+2][j][k] and  bmask[i+3][j][k]) then
            begin
               if ((bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i+2][j][k]) and (bid[i][j][k]=bid[i+3][j][k]) ) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+3][j][k]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+3][j][k]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+3][j][k]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i+1][j][k]:=False;
                  bmask[i+2][j][k]:=False;
                  bmask[i+3][j][k]:=False;
              end;
            end;
         end;
      end;
   end;

   // объединение троек i-long 3.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i+1][j][k] and bmask[i+2][j][k]) then
            begin
               if ((bid[i][j][k]=bid[i+1][j][k]) and (bid[i][j][k]=bid[i+2][j][k]) ) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i+2][j][k]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i+2][j][k]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i+2][j][k]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i+1][j][k]:=False;
                  bmask[i+2][j][k]:=False;
              end;
            end;
         end;
      end;
   end;

    // объединение четвёрок j-long 4.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j+1][k] and bmask[i][j+2][k] and  bmask[i][j+3][k]) then
            begin
               if ((bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i][j+2][k]) and (bid[i][j][k]=bid[i][j+3][k])) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j+3][k]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j+3][k]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j+3][k]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i][j+1][k]:=False;
                  bmask[i][j+2][k]:=False;
                  bmask[i][j+3][k]:=False;
              end;
            end;
         end;
      end;
   end;

    // объединение четвёрок k-long 4.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j][k+1] and bmask[i][j][k+2] and  bmask[i][j][k+3]) then
            begin
               if ((bid[i][j][k]=bid[i][j][k+1]) and (bid[i][j][k]=bid[i][j][k+2]) and (bid[i][j][k]=bid[i][j][k+3])) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j][k+3]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j][k+3]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j][k+3]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i][j][k+1]:=False;
                  bmask[i][j][k+2]:=False;
                  bmask[i][j][k+3]:=False;
              end;
            end;
         end;
      end;
   end;

   // объединение троек j-long 3.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j+1][k] and bmask[i][j+2][k]) then
            begin
               if ((bid[i][j][k]=bid[i][j+1][k]) and (bid[i][j][k]=bid[i][j+2][k]) ) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j+2][k]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j+2][k]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j+2][k]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i][j+2][k]:=False;
                  bmask[i][j+2][k]:=False;
              end;
            end;
         end;
      end;
   end;

   // объединение троек k-long 3.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k] and  bmask[i][j][k+1] and bmask[i][j][k+2]) then
            begin
               if ((bid[i][j][k]=bid[i][j][k+1]) and (bid[i][j][k]=bid[i][j][k+2]) ) then
               begin
                  SetLength(blockgraphics,Length(blockgraphics)+1);
                  blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                  blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                  blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                  blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                  blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
                  blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
                  blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
                  blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
                  blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j][k+2]].xE;
                  blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j][k+2]].yE;
                  blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j][k+2]].zE;
                  bmask[i][j][k]:=False;
                  bmask[i][j][k+1]:=False;
                  bmask[i][j][k+2]:=False;
              end;
            end;
         end;
      end;
   end;

   // Оставшиеся необъединёнными элементы.
   for i:=0 to Length(x1)-2 do
   begin
      for j:=0 to Length(y1)-2 do
      begin
         for k:=0 to Length(z1)-2 do
         begin
            if (bmask[i][j][k]) then
            begin
               SetLength(blockgraphics,Length(blockgraphics)+1);
               blockgraphics[Length(blockgraphics)-1].xS:=bg[mask[i][j][k]].xS;
               blockgraphics[Length(blockgraphics)-1].yS:=bg[mask[i][j][k]].yS;
               blockgraphics[Length(blockgraphics)-1].zS:=bg[mask[i][j][k]].zS;
               blockgraphics[Length(blockgraphics)-1].xE:=bg[mask[i][j][k]].xE;
               blockgraphics[Length(blockgraphics)-1].yE:=bg[mask[i][j][k]].yE;
               blockgraphics[Length(blockgraphics)-1].zE:=bg[mask[i][j][k]].zE;
                blockgraphics[Length(blockgraphics)-1].redcolor:=bg[mask[i][j][k]].redcolor;
                blockgraphics[Length(blockgraphics)-1].greencolor:=bg[mask[i][j][k]].greencolor;
                blockgraphics[Length(blockgraphics)-1].bluecolor:=bg[mask[i][j][k]].bluecolor;
                blockgraphics[Length(blockgraphics)-1].transparency:=bg[mask[i][j][k]].transparency;
                blockgraphics[Length(blockgraphics)-1].dcol:=bg[mask[i][j][k]].dcol;
               bmask[i][j][k]:=False;
            end;
         end;
      end;
   end;
    *)
   SetLength(mask,0,0,0);
   SetLength(bmask,0,0,0);
   SetLength(bg,0);


end;   // ReadyPaint2

// Задаёт закон изменения тепловой мощности в блоках имена
// которых соответствуют образцу.
procedure TLaplas.RedoSourceforPatternClick(Sender: TObject);
var
    i_1, i_1_first : Integer;
    bfirst : Boolean;
    i_count_patces : Integer; // Количество модифицированных источников тепла.
begin
   FormTextNameSourcePattern.ShowModal;

   i_count_patces:=0;

    // Текстовый шаблон.
      if (length(FormTextNameSourcePattern.EditSourcepatternname.Text)>0) then
      begin

            bfirst:=true;

            for i_1 := 1 to (lb-1) do
            begin
               if (Pos(Trim(FormTextNameSourcePattern.EditSourcepatternname.Text),body[i_1].name)>0) then
               begin
                  inc(i_count_patces);

                  itek:=i_1;
                  if (bfirst) then
                  begin
                     bfirst:=false;
                     i_1_first:=i_1;
                     // 2 - это полигон. Мы не можем задаваать мощность тепловыделения
                     // внутри полигона.
                     if (body[Laplas.itek].igeometry_type<>2) then
                     begin
                        if (body[itek].n_power=1) then
                         begin
                            // Constant (not temperature depend)
                            FormTransientPowerSetting.EditPower.Visible:=true;
                            FormTransientPowerSetting.Label1.Visible:=true;
                            FormTransientPowerSetting.Buttonpiecewisepower.Visible:=false;
                            //FormTransientPowerSetting.EditPower.Text:=FloatToStr(Laplas.body[Laplas.itek].arr_power[0]);
                            FormTransientPowerSetting.EditPower.Text:=Trim(Laplas.body[Laplas.itek].arr_s_power[0]);
                            FormTransientPowerSetting.ComboBoxTemperaturedependpower.ItemIndex:=0;
                            FormTransientPowerSetting.ComboBoxTemperaturedependpowerChange(Sender);
                         end
                          else
                         begin
                            // Temperature depend.
                            FormTransientPowerSetting.EditPower.Visible:=false;
                            FormTransientPowerSetting.Label1.Visible:=false;
                            FormTransientPowerSetting.Buttonpiecewisepower.Visible:=true;
                            FormTransientPowerSetting.ComboBoxTemperaturedependpower.ItemIndex:=1;
                            FormTransientPowerSetting.ComboBoxTemperaturedependpowerChange(Sender);
                         end;
                     end;
                     // Зависимость мощности тепловыделения от времени.
                     // 0 - не зависит от времени и выделяется постоянно,
                     // 1 - squre wave зависимость от времени,
                     // 2 - square wave 2 зависимость от времени,
                     // 3 - hot cold режим для Евдокимовой Н.Л.
                     FormTransientPowerSetting.RadioGroupTimeDependPowerLow.ItemIndex:=body[itek].ipower_time_depend;
                     // Запрет на тепловую мощность зависящую от температуры
                     // при массовом изменении закона тепловой мощности.
                     FormTransientPowerSetting.bBlock_piecewice_power:=true;
                     FormTransientPowerSetting.ShowModal;
                  end
                  else
                  begin
                     // Просто задаём параметры тепловой мощности текущему блоку.

                      // Зависимость мощности тепловыделения от времени.
                      // 0 - не зависит от времени и выделяется постоянно,
                      // 1 - squre wave зависимость от времени,
                      // 2 - square wave 2 зависимость от времени,
                      // 3 - hot cold режим для Евдокимовой Н.Л.
                      // 4 - piecewise const.
                     body[itek].ipower_time_depend:=FormTransientPowerSetting.RadioGroupTimeDependPowerLow.ItemIndex;
                     body[itek].n_power:= body[i_1_first].n_power;
                     // Только постоянное значение тепловой мощности.
                     SetLength(body[itek].temp_power, body[itek].n_power);
                     SetLength(body[itek].arr_power, body[itek].n_power);
                     SetLength(body[itek].arr_s_power, body[itek].n_power);
                     body[itek].arr_s_power[0]:=body[i_1_first].arr_s_power[0];
                     body[itek].arr_power[0]:=body[i_1_first].arr_power[0];
                  end;
               end;
            end;

            MainMemo.Lines.Add('Pathing heat source name string search pattern='+Trim(FormTextNameSourcePattern.EditSourcepatternname.Text)+'. count patching sources='+IntToStr(i_count_patces)+'. Done...');
            Application.MessageBox(PWideChar(IntToStr(i_count_patces)+'Pathing heat sources Done...'),'Define group heat source', MB_OK);

      end;
      // запрет на мощность зависящую от температуры снят.
      FormTransientPowerSetting.bBlock_piecewice_power:=false;
end;





// вызывается при создании формы
procedure TLaplas.FormCreate(Sender: TObject);
var
   NewNode : TTreeNode;
   ipfd :integer;
   pfd:TPixelFormatDescriptor;
   xa,xb,xc : Real;  // для метода дихтомии.

begin

  ecology_btn:=true;
  boptimetric:=false;
  id_0_index:=0;
  id_1_index:=0;

   perspectiveangle_counter:=0.0;

   // Готовим для пользователя очень
   // стабильную версию если true
   // отключая всё лишнее неработоспособное.
   // Раскоментировать в случае
   //  development версии :=false.
   bREALESEversion:=true; // realese
   // пакеты пока не загружались.
   // эту величину нужно хранить в файле с моделью.
   inumber_package_load:=0;
   bperenapravlenie_na_import:=false;
   bVisualization_Management_now:=false;

   bvisiblepic:=false; // картинка не визуализируется.
   bvisiblepicdubl:=false;
   risopic:=0.0;

   isleep_render:=100; // Пауза при рендере.
   Hscale:=125.0;
    //perspectiveangle:=45.0;
    //perspectiveangle:=90.0+90.0*arctan(0.08*perspectiveangle_counter)/1.5705;
   // perspectiveangle:=return_Perspective_angle(perspectiveangle_counter);
  // perspectiveangle_counter:=0.0;



    perspectiveangle:=2.0*180.0*(arctan((0.25)/(Hscale)))/1.57079632679;
   xa:=-7990;
   xb:=7990;
   xc:=0;
   while (abs(perspectiveangle-return_Perspective_angle(xc))>0.01) do
   begin
     if ((perspectiveangle-return_Perspective_angle(xa))*(perspectiveangle-return_Perspective_angle(xc))<0) then
     begin
       xb:=xc;
       xc:=0.5*(xa+xb);
     end
     else
     begin
         xa:=xc;
         xc:=0.5*(xa+xb);
     end;
   end;
    perspectiveangle_counter:=xc;

   button_right_push:=false;


   bonly_mesh_gen_call:=false; // Сеточный генератор не вызывается отдельно.
   // Признак особых граничных условий на стенках кабинета.
   cab_bound_condition.bminX:=false;
   cab_bound_condition.bmaxX:=false;
   cab_bound_condition.bminY:=false;
   cab_bound_condition.bmaxY:=false;
   cab_bound_condition.bminZ:=false;
   cab_bound_condition.bmaxZ:=false;

   // Законы изменения шага по времени и мощности тепловыделения.
   glSTL.id_law:=0; // 0 - Linear, 1 - Square Wave, 2 - Square Wave Apparat, 3 - Double Linear time step.
   glSTL.Factor_a_for_Linear:=0.4;  // Factor_a для Linear закона изменения шага по времени.
   glSTL.tau:=0.1; // Длительность импульса.
   glSTL.iQ:=5.0; // Скважность
   glSTL.tau1:=180.0; // 3 мин подготовка аппаратуры.
   glSTL.tau2:=240.0; // 4 мин съёмка.
   glSTL.tau_pause:=5040.0; // один виток вокруг земли 94 мин минус время 2xtau1+tau2.
   glSTL.off_multiplyer:=0.0;
   glSTL.T:=86400.0; // сутки
   glSTL.m1:=0.3333; // подготовка к режиму съёмки имеет тепловыделение в трое меньшее.
   glSTL.n:=6; // 6 витков в сутках.
   glSTL.on_time_double_linear:=0.3; // EndTime=1.0; On_time=0.3;


   priority_id:=5; // приоритет первого блока.

   brun:=false; // вычисление ещё не запущено.
   DoubleBuffered:=True;
   //SetLength(zbuffer,MainPaintBox.Width+1,MainPaintBox.Height+1); // выделяем память под Z - буффер.

   SetLength(blockgraphics,0);
   // Уникальные постоянно увеличивающиеся счётчики для формирования имён объектов.
   icb:=0;
   ics:=0;
   icw:=0;
   breadfinish:=false;
   mlength:=1.0; // метры
   drawing:=false;

   // добавляет кубик
   lb:=1;
   SetLength(body,lb);
   body[0].igeometry_type:=0; // Prism
   body[0].priority:=-5; // наинизший приоритет.
   body[0].xS:=-0.5;  body[0].xE:=0.5;  // отображение параметризованной пользователем
   body[0].yS:=-0.5;  body[0].yE:=0.5;  // геометрии
   body[0].zS:=-0.5;  body[0].zE:=0.5;  // в реальные числа
   if (FormatSettings.DecimalSeparator='.') then
   begin
      body[0].sxS:='-0.5';  body[0].sxE:='0.5';  // параметризованная
      body[0].syS:='-0.5';  body[0].syE:='0.5';  // пользователем
      body[0].szS:='-0.5';  body[0].szE:='0.5';  // геометрия
   end;
   if (FormatSettings.DecimalSeparator=',') then
   begin
      body[0].sxS:='-0,5';  body[0].sxE:='0,5';  // параметризованная
      body[0].syS:='-0,5';  body[0].syE:='0,5';  // пользователем
      body[0].szS:='-0,5';  body[0].szE:='0,5';  // геометрия
   end;
   body[0].xC:=0.0;
   body[0].yC:=0.0;
   body[0].zC:=-0.5;
   body[0].Hcyl:=1.0;
   body[0].R_out_cyl:=0.5;
   body[0].R_in_cyl:=0.0;
   body[0].iPlane:=1; // 1- XY
   // 23_02_2017
   body[0].R_out_cyl2:=-1.0;
   body[0].R_in_cyl2:=-1.0;
   body[0].angle_start:=0.0;
   body[0].angle_end:=0.0;
   // Кабинет всегда имеет форму Призмы
   // для него это преобразование не имеет смысла.
   body[0].bCylinder2Prism:=true;
   if (FormatSettings.DecimalSeparator='.') then
   begin
        body[0].sxC:='0.0';
        body[0].syC:='0.0';
        body[0].szC:='-0.5';
        body[0].sHcyl:='1.0';
        body[0].sR_out_cyl:='0.5';
        body[0].sR_in_cyl:='0.0';
        // sector
        body[0].sR_out_cyl2:='-1.0';
        body[0].sR_in_cyl2:='-1.0';
        body[0].sangle_start:='0.0';
        body[0].sangle_end:='0.0';
   end;
   if (FormatSettings.DecimalSeparator=',') then
   begin
      body[0].sxC:='0,0';
      body[0].syC:='0,0';
      body[0].szC:='-0,5';
      body[0].sHcyl:='1,0';
      body[0].sR_out_cyl:='0,5';
      body[0].sR_in_cyl:='0,0';
      // sector
      body[0].sR_out_cyl2:='-1,0';
      body[0].sR_in_cyl2:='-1,0';
      body[0].sangle_start:='0,0';
      body[0].sangle_end:='0,0';
   end;
   // Polygon
   body[0].nsizei:=3;
   SetLength(body[0].xi,body[0].nsizei);
   SetLength(body[0].yi,body[0].nsizei);
   SetLength(body[0].zi,body[0].nsizei);
   SetLength(body[0].hi,body[0].nsizei);
   body[0].iPlane_obj2:=3; // 3- YZ
   body[0].hi[0]:=0.2;
   body[0].xi[0]:=-0.1;
   body[0].yi[0]:=-0.141421;
   body[0].zi[0]:=-0.141421;
   body[0].hi[1]:=0.2;
   body[0].xi[1]:=-0.1;
   body[0].yi[1]:=0.141421;
   body[0].zi[1]:=-0.141421;
   body[0].hi[2]:=0.2;
   body[0].xi[2]:=-0.1;
   body[0].yi[2]:=-0.141421;
   body[0].zi[2]:=0.141421;

   // Серый цвет и полная непрозрачность.
   body[0].redcolor:=0.502;
   body[0].greencolor:=0.502;
   body[0].bluecolor:=0.502;
   body[0].transparency:=1.0;
   body[0].dcol:=8421504;
   body[0].BodyLineWidth:=1;

   // рёбра
   // Вращательное движение в 3D имеет три степени свободы.
   Alf:=-1.29; Bet:=1.26; Gam:=0.0;// углы поворота
   cosAlf:=cos(Alf);
   cosBet:=cos(Bet);
   sinAlf:=sin(Alf);
   sinBet:=sin(Bet);
   Gam0:=0;

   // Параметры модели освещения в OpenGL.
   // параметры материала :
   remis:=0.0; rspec:=0.0; rblick:=60;
   matdiff:=0.8; matamb:=0.2;
   dopusk_gl1:=0.01; // глобальный допуск для алгоритма z-буффера.
   dopusk_gl2:=0.01; // глобальный допуск для алгоритма z-буффера.
   // LIGHT0
   matt:=1.0; mr:=1.0;   glamb0:=0.0;
   mldx:=-0.5;
   mldy:=0.0;
   lamb:=0.0; lspec:=1.0; ldiff:=1.0;
   lithtangle:=180.0; lithtexponent:=0.0;
   // LIGHT1
   // Вторая лампа.
   lithtangle1:=180.0; lithtexponent1:=0.0;
   mldx1:=-0.3; mldy1:=0.0; // LIGHT1
   matt1:=1.0; mr1:=1.0; // зависимость от расстояния для LIGHT1
   lamb1:=0.0; lspec1:=0.0; ldiff1:=0.0; // параметры первой лампы.
   // Конец списка параметров модели освещения в OpenGL.

   body[0].name:='cabinet';
   body[0].CylinderFixed:=false; // Кабинет не может быть цилиндром.
   body[0].imatid:=0; // номер рабочего материала
   lmatmax:=2; // только два рабочих материала air и AlDuralumin
   SetLength(workmat,lmatmax); // выделяем память под рабочие материалы
   workmat[0].rho:=1.1614; // плотность воздуха
   //workmat[0].cp:=1005; // удельная теплоёмкость воздуха
   workmat[0].n_cp:=1;
   SetLength(workmat[0].temp_cp, workmat[0].n_cp);
   SetLength(workmat[0].arr_cp, workmat[0].n_cp);
   workmat[0].temp_cp[0]:=20.0;
   workmat[0].arr_cp[0]:=1005;  // теплоёмкость воздуха
   // workmat[0].lambda:=0.0261; // теплопроводность воздуха
   workmat[0].n_lam:=1;
   SetLength(workmat[0].temp_lam, workmat[0].n_lam);
   SetLength(workmat[0].arr_lam, workmat[0].n_lam);
   workmat[0].temp_lam[0]:=20.0;
   workmat[0].arr_lam[0]:=0.0261;  // теплопроводность воздуха
   // air   Thermal-Stress
   //workmat[0].Poisson_ratio:=0.49;
   workmat[0].n_Poisson_ratio:=1;
   SetLength(workmat[0].temp_Poisson_ratio, workmat[0].n_Poisson_ratio);
   SetLength(workmat[0].arr_Poisson_ratio, workmat[0].n_Poisson_ratio);
   workmat[0].temp_Poisson_ratio[0]:=20.0;
   workmat[0].arr_Poisson_ratio[0]:=0.49;
   //workmat[0].Young_Module:=1.42e-4;//GPa  // 60000Pa SolidWork.
   workmat[0].n_Young_Module:=1;
   SetLength(workmat[0].temp_Young_Module, workmat[0].n_Young_Module);
   SetLength(workmat[0].arr_Young_Module, workmat[0].n_Young_Module);
   workmat[0].temp_Young_Module[0]:=20.0;
   workmat[0].arr_Young_Module[0]:=1.42e-4;//GPa  // 60000Pa SolidWork.
   //workmat[0].Linear_expansion_coefficient:=3.331e+3;//*1e-6
   workmat[0].n_Linear_expansion_coefficient:=1;
   SetLength(workmat[0].temp_Linear_expansion_coefficient, workmat[0].n_Linear_expansion_coefficient);
   SetLength(workmat[0].arr_Linear_expansion_coefficient, workmat[0].n_Linear_expansion_coefficient);
   workmat[0].temp_Linear_expansion_coefficient[0]:=20.0;
   workmat[0].arr_Linear_expansion_coefficient[0]:=3.331e+3;//*1e-6
   // Ортотропность теплопроводности.
   workmat[0].mult_lam_x:=1.0;
   workmat[0].mult_lam_y:=1.0;
   workmat[0].mult_lam_z:=1.0;
   workmat[0].mult_Linear_expansion_coefficient_x:=1.0;
   workmat[0].mult_Linear_expansion_coefficient_y:=1.0;
   workmat[0].mult_Linear_expansion_coefficient_z:=1.0;
   workmat[0].mult_Young_Module_x:=1.0;
   workmat[0].mult_Young_Module_y:=1.0;
   workmat[0].mult_Young_Module_z:=1.0;
   workmat[0].mult_Poisson_ratio_xy:=1.0;
   workmat[0].mult_Poisson_ratio_xz:=1.0;
   workmat[0].mult_Poisson_ratio_yz:=1.0;
   workmat[0].mult_Poisson_ratio_yx:=1.0;
   workmat[0].mult_Poisson_ratio_zx:=1.0;
   workmat[0].mult_Poisson_ratio_zy:=1.0;
   // Модуль сдвига.
   workmat[0].bShearModuleActive:=false;
   workmat[0].ShearModuleGxy:=workmat[0].arr_Young_Module[0]/(2.0*(1.0+workmat[0].arr_Poisson_ratio[0]));
   workmat[0].ShearModuleGyz:=workmat[0].arr_Young_Module[0]/(2.0*(1.0+workmat[0].arr_Poisson_ratio[0]));
   workmat[0].ShearModuleGxz:=workmat[0].arr_Young_Module[0]/(2.0*(1.0+workmat[0].arr_Poisson_ratio[0]));



   workmat[0].mu:=1.7894e-5; // коэффициент динамической вязкости
   workmat[0].ilawmu:=0; // const value
   // ограничители динамической вязкости.
   workmat[0].mumin:=workmat[0].mu;
   workmat[0].mumax:=workmat[0].mu;
   workmat[0].Amu:=1.0; // константы модельных зависимостей
   workmat[0].Bmu:=1.0;
   workmat[0].Cmu:=1.0;
   workmat[0].degreennmu:=1.0; // показатель степени
   workmat[0].beta_t:=0.003331; // коэффициент линейного температурного расширения
   //body[0].power:=0.0; // мощность тепловыделения блока
   //body[0].spower:='0.0'; // параметризованная пользователем мощность тепловыделения
   body[0].n_power:=1;
   SetLength(body[0].arr_power,body[0].n_power);
   SetLength(body[0].temp_power,body[0].n_power);
   SetLength(body[0].arr_s_power,body[0].n_power);
   body[0].temp_power[0]:=20.0;
   body[0].arr_power[0]:=0.0; // мощность тепловыделения блока
   body[0].arr_s_power[0]:='0.0'; // параметризованная пользователем мощность тепловыделения
   body[0].ipower_time_depend:=0; // тепловыделение не зависит от времени.
   // emissivity
   if (FormatSettings.DecimalSeparator=',') then
   begin
      body[0].semissW:='0,001';
      body[0].semissE:='0,001';
      body[0].semissS:='0,001';
      body[0].semissN:='0,001';
      body[0].semissB:='0,001';
      body[0].semissT:='0,001';
   end;
   if (FormatSettings.DecimalSeparator='.') then
   begin
      body[0].semissW:='0.001';
      body[0].semissE:='0.001';
      body[0].semissS:='0.001';
      body[0].semissN:='0.001';
      body[0].semissB:='0.001';
      body[0].semissT:='0.001';
   end;


   body[0].emissW:=0.001;
   body[0].emissE:=0.001;
   body[0].emissS:=0.001;
   body[0].emissN:=0.001;
   body[0].emissB:=0.001;
   body[0].emissT:=0.001;
   // По умолчанию теплообмен излучением внутри блока не учитывается.
   body[0].binternalRadiation:=0;
   body[0].itype:=3; // FLUID
   workmat[0].namemat:='air';
   //workmat[0].bBoussinesq:=0; // приближение Обербека-Буссинеска выключено
   // 25 07 2015
   // новые соображения о настройках по умолчанию приводят к заключению
   // что приближение Обербека Буссинеска должно быть включено по умолчанию.
   workmat[0].bBoussinesq:=1;


   cbbview.ItemIndex:=0; // all
   edtvalue.Visible:=False; // не предлагаем изо сечения.
   ComboBoxplaneViewSelect.Visible:=false;
   lblvalue.Visible:=False;

   NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,body[0].name);
   NewNode.ImageIndex:=0;
   ls:=0; // количество источников тепла
   lw:=0; // количество твёрдых стенок
   m:=100; // масштабный коэффициент для визуализации
   lu:=0; // количество union-ов
   SetLength(myassembles,0);
   body[0].iunion:=0;
   body[0].bvisible:=true;
   workmat[0].blibmat:=0; // это материал определённый пользователем
   workmat[0].ilibident:=0; // это материал определённый пользователем



   workmat[1].rho:=2800; // плотность дюр-аллюминия
   //workmat[1].cp:=921; // удельная теплоёмкость дюр-аллюминия
   workmat[1].n_cp:=1;
   SetLength(workmat[1].temp_cp, workmat[1].n_cp);
   SetLength(workmat[1].arr_cp, workmat[1].n_cp);
   workmat[1].temp_cp[0]:=20.0;
   workmat[1].arr_cp[0]:=921.0;  // теплоёмкость дюр-аллюминия
   //workmat[1].lambda:=164; // теплопроводность дюр-аллюминия
   workmat[1].n_lam:=1;
   SetLength(workmat[1].temp_lam, workmat[1].n_lam);
   SetLength(workmat[1].arr_lam, workmat[1].n_lam);
   workmat[1].temp_lam[0]:=20.0;
   workmat[1].arr_lam[0]:=164.0;  // теплопроводность дюр-аллюминия
   // Ортотропность теплопроводности.
   workmat[1].mult_lam_x:=1.0;
   workmat[1].mult_lam_y:=1.0;
   workmat[1].mult_lam_z:=1.0;


    // aluminium
   //workmat[1].Poisson_ratio:=0.334;
    workmat[1].n_Poisson_ratio:=1;
   SetLength(workmat[1].temp_Poisson_ratio, workmat[1].n_Poisson_ratio);
   SetLength(workmat[1].arr_Poisson_ratio, workmat[1].n_Poisson_ratio);
   workmat[1].temp_Poisson_ratio[0]:=20.0;
   workmat[1].arr_Poisson_ratio[0]:=0.334;
   //workmat[1].Young_Module:=69.0;//GPa
   workmat[1].n_Young_Module:=1;
   SetLength(workmat[1].temp_Young_Module, workmat[1].n_Young_Module);
   SetLength(workmat[1].arr_Young_Module, workmat[1].n_Young_Module);
   workmat[1].temp_Young_Module[0]:=20.0;
   workmat[1].arr_Young_Module[0]:=69.0;//GPa
   //workmat[1].Linear_expansion_coefficient:=23.0;//*1e-6
   workmat[1].n_Linear_expansion_coefficient:=1;
   SetLength(workmat[1].temp_Linear_expansion_coefficient, workmat[1].n_Linear_expansion_coefficient);
   SetLength(workmat[1].arr_Linear_expansion_coefficient, workmat[1].n_Linear_expansion_coefficient);
   workmat[1].temp_Linear_expansion_coefficient[0]:=20.0;
   workmat[1].arr_Linear_expansion_coefficient[0]:=23.0;//*1e-6

   workmat[1].mult_Linear_expansion_coefficient_x:=1.0;
   workmat[1].mult_Linear_expansion_coefficient_y:=1.0;
   workmat[1].mult_Linear_expansion_coefficient_z:=1.0;
   workmat[1].mult_Young_Module_x:=1.0;
   workmat[1].mult_Young_Module_y:=1.0;
   workmat[1].mult_Young_Module_z:=1.0;
   workmat[1].mult_Poisson_ratio_xy:=1.0;
   workmat[1].mult_Poisson_ratio_xz:=1.0;
   workmat[1].mult_Poisson_ratio_yz:=1.0;
   workmat[1].mult_Poisson_ratio_yx:=1.0;
   workmat[1].mult_Poisson_ratio_zx:=1.0;
   workmat[1].mult_Poisson_ratio_zy:=1.0;
   // Модуль сдвига.
   workmat[1].bShearModuleActive:=false;
   workmat[1].ShearModuleGxy:=workmat[1].arr_Young_Module[0]/(2.0*(1.0+workmat[1].arr_Poisson_ratio[0]));
   workmat[1].ShearModuleGyz:=workmat[1].arr_Young_Module[0]/(2.0*(1.0+workmat[1].arr_Poisson_ratio[0]));
   workmat[1].ShearModuleGxz:=workmat[1].arr_Young_Module[0]/(2.0*(1.0+workmat[1].arr_Poisson_ratio[0]));

   // следующие 8 значений не используются
   workmat[1].mu:=1.7894e-5; // воздух
   workmat[1].ilawmu:=0; // const value
   // ограничители динамической вязкости.
   workmat[1].mumin:=workmat[1].mu;
   workmat[1].mumax:=workmat[1].mu;
   workmat[1].Amu:=1.0; // константы модельных зависимостей
   workmat[1].Bmu:=1.0;
   workmat[1].Cmu:=1.0;
   workmat[1].degreennmu:=1.0; // показатель степени
   workmat[1].beta_t:=0.003331; // воздух
   workmat[1].bBoussinesq:=0; // приближение Обербека-Буссинеска выключено.
   workmat[1].namemat:='Al-Duralumin';
   workmat[1].blibmat:=0; // материал определяемый пользователем.
   workmat[1].ilibident:=100; // в библиотеке материалов не значится.

   // центры двух систем координат совпадают
   Oxc:=0.0;
   Oyc:=0.0;
   Ozc:=0.0;

   // библиотека твёрдых материалов
   lmatsol:=42;
   SetLength(libsolid,lmatsol);
   // YoungModule GPa, linear expansion coefficient *1.0E-6.
   libsolid[0].name:='Al-Duralumin'; libsolid[0].Poisson_ratio:=0.345; libsolid[0].Young_Module:=70.5; libsolid[0].Linear_expansion_coefficient:=22.5; libsolid[0].lam:=164; libsolid[0].cp:=921; libsolid[0].rho:=2800;  libsolid[0].mult_lam_x:=1.0; libsolid[0].mult_lam_y:=1.0; libsolid[0].mult_lam_z:=1.0;
   libsolid[1].name:='GaN'; libsolid[1].Poisson_ratio:=0.352; libsolid[1].Young_Module:=181.0; libsolid[1].Linear_expansion_coefficient:=4.0; libsolid[1].lam:=130; libsolid[1].cp:=700; libsolid[1].rho:=6150;  libsolid[1].mult_lam_x:=1.0; libsolid[1].mult_lam_y:=1.0; libsolid[1].mult_lam_z:=1.0;
   libsolid[2].name:='SiC-4H'; libsolid[2].Poisson_ratio:=0.14; libsolid[2].Young_Module:=410.0; libsolid[2].Linear_expansion_coefficient:=4.0; libsolid[2].lam:=370; libsolid[2].cp:=690; libsolid[2].rho:=3210; libsolid[2].mult_lam_x:=1.0; libsolid[2].mult_lam_y:=1.0; libsolid[2].mult_lam_z:=1.0;
   libsolid[3].name:='SOLDER_Au80Sn20'; libsolid[3].Poisson_ratio:=0.4; libsolid[3].Young_Module:=68.0; libsolid[3].Linear_expansion_coefficient:=16.0; libsolid[3].lam:=57; libsolid[3].cp:=143; libsolid[3].rho:=14510;  libsolid[3].mult_lam_x:=1.0; libsolid[3].mult_lam_y:=1.0; libsolid[3].mult_lam_z:=1.0;// TDIM Master
   libsolid[4].name:='Cu'; libsolid[4].Poisson_ratio:=0.34; libsolid[4].Young_Module:=114.0; libsolid[4].Linear_expansion_coefficient:=16.5; libsolid[4].lam:=390; libsolid[4].cp:=390; libsolid[4].rho:=8930; libsolid[4].mult_lam_x:=1.0; libsolid[4].mult_lam_y:=1.0; libsolid[4].mult_lam_z:=1.0;
   libsolid[5].name:='MD-40'; libsolid[5].Poisson_ratio:=0.32; libsolid[5].Young_Module:=195.0; libsolid[5].Linear_expansion_coefficient:=8.65; libsolid[5].lam:=210; libsolid[5].cp:=318; libsolid[5].rho:=8900; libsolid[5].mult_lam_x:=1.0; libsolid[5].mult_lam_y:=1.0; libsolid[5].mult_lam_z:=1.0;// MoCu 60%Mo 40%Cu
   libsolid[6].name:='GaAs'; libsolid[6].Poisson_ratio:=0.31; libsolid[6].Young_Module:=85.0; libsolid[6].Linear_expansion_coefficient:=5.39; libsolid[6].lam:=47; libsolid[6].cp:=330; libsolid[6].rho:=5300;  libsolid[6].mult_lam_x:=1.0; libsolid[6].mult_lam_y:=1.0; libsolid[6].mult_lam_z:=1.0;
   libsolid[7].name:='Au'; libsolid[7].Poisson_ratio:=0.42; libsolid[7].Young_Module:=83.0; libsolid[7].Linear_expansion_coefficient:=14.2; libsolid[7].lam:=293; libsolid[7].cp:=126; libsolid[7].rho:=19300;  libsolid[7].mult_lam_x:=1.0; libsolid[7].mult_lam_y:=1.0; libsolid[7].mult_lam_z:=1.0;
   // Термически выращенный из газовой фазы.
   libsolid[8].name:='SiO2'; libsolid[8].Poisson_ratio:=0.17; libsolid[8].Young_Module:=70.0; libsolid[8].Linear_expansion_coefficient:=12.3; libsolid[8].lam:=1.27; libsolid[8].cp:=741; libsolid[8].rho:=2100; libsolid[8].mult_lam_x:=1.0; libsolid[8].mult_lam_y:=1.0; libsolid[8].mult_lam_z:=1.0;
   libsolid[9].name:='Si'; libsolid[9].Poisson_ratio:=0.17; libsolid[9].Young_Module:=150.0; libsolid[9].Linear_expansion_coefficient:=2.0; libsolid[9].lam:=148.0; libsolid[9].cp:=711; libsolid[9].rho:=2330; libsolid[9].mult_lam_x:=1.0; libsolid[9].mult_lam_y:=1.0; libsolid[9].mult_lam_z:=1.0;// кремний.
   // ковар (используется в качестве держателя при испытаниях. Сплав: Co 17% Ni 29% Fe остальное).
   libsolid[10].name:='kovar'; libsolid[10].Poisson_ratio:=317.0; libsolid[10].Young_Module:=20.0; libsolid[10].Linear_expansion_coefficient:=5.1; libsolid[10].lam:=19; libsolid[10].cp:=669; libsolid[10].rho:=8350; libsolid[10].mult_lam_x:=1.0; libsolid[10].mult_lam_y:=1.0; libsolid[10].mult_lam_z:=1.0;// ковар.
   // поликор alumina
   libsolid[11].name:='Alumina'; libsolid[11].Poisson_ratio:=0.22; libsolid[11].Young_Module:=340.0; libsolid[11].Linear_expansion_coefficient:=7.8; libsolid[11].lam:=25.0; libsolid[11].cp:=750.0; libsolid[11].rho:=3760.0; libsolid[11].mult_lam_x:=1.0; libsolid[11].mult_lam_y:=1.0; libsolid[11].mult_lam_z:=1.0;
   // Латунь ЛС-59-1-Л (Brass)
   libsolid[12].name:='Brass'; libsolid[12].Poisson_ratio:=0.331; libsolid[12].Young_Module:=120.0; libsolid[12].Linear_expansion_coefficient:=19.0; libsolid[12].lam:=108.784; libsolid[12].cp:=377.0; libsolid[12].rho:=8500.0; libsolid[12].mult_lam_x:=1.0; libsolid[12].mult_lam_y:=1.0; libsolid[12].mult_lam_z:=1.0;
   // полиимид (polyimide PI)
   libsolid[13].name:='Polyimide'; libsolid[13].Poisson_ratio:=0.34; libsolid[13].Young_Module:=2.5; libsolid[13].Linear_expansion_coefficient:=45.0; libsolid[13].lam:=0.22; libsolid[13].cp:=1040.0; libsolid[13].rho:=1340.0; libsolid[13].mult_lam_x:=1.0; libsolid[13].mult_lam_y:=1.0; libsolid[13].mult_lam_z:=1.0;
   // Сапфир (Sapphire Al2O3)
   libsolid[14].name:='Sapphire'; libsolid[14].Poisson_ratio:=0.309; libsolid[14].Young_Module:=462.6; libsolid[14].Linear_expansion_coefficient:=4.5; libsolid[14].lam:=25.1; libsolid[14].cp:=718.0; libsolid[14].rho:=4000.0; libsolid[14].mult_lam_x:=1.0; libsolid[14].mult_lam_y:=1.0; libsolid[14].mult_lam_z:=1.0;
   // Клей ЭЧЭС (glue_ECHES)
   libsolid[15].name:='Glue_ECHES'; libsolid[15].Poisson_ratio:=0.334; libsolid[15].Young_Module:=7.0e-3; libsolid[15].Linear_expansion_coefficient:=66.0; libsolid[15].lam:=4.0; libsolid[15].cp:=100.0; libsolid[15].rho:=1000.0; libsolid[15].mult_lam_x:=1.0; libsolid[15].mult_lam_y:=1.0; libsolid[15].mult_lam_z:=1.0;
   // Оксидно-берилиевая керамика (BeO)
   libsolid[16].name:='BeO'; libsolid[16].Poisson_ratio:=0.26; libsolid[16].Young_Module:=350.0; libsolid[16].Linear_expansion_coefficient:=8.0; libsolid[16].lam:=251.0; libsolid[16].cp:=1260.0; libsolid[16].rho:=2850.0; libsolid[16].mult_lam_x:=1.0; libsolid[16].mult_lam_y:=1.0; libsolid[16].mult_lam_z:=1.0;
   // Серебро Argentum (Ag)  Silver
   libsolid[17].name:='Ag'; libsolid[17].Poisson_ratio:=0.37; libsolid[17].Young_Module:=83.0; libsolid[17].Linear_expansion_coefficient:=18.9; libsolid[17].lam:=429.0; libsolid[17].cp:=234.0; libsolid[17].rho:=10500.0;  libsolid[17].mult_lam_x:=1.0; libsolid[17].mult_lam_y:=1.0; libsolid[17].mult_lam_z:=1.0;
   // Алмаз Diamond (C)
   libsolid[18].name:='Diamond'; libsolid[18].Poisson_ratio:=0.2; libsolid[18].Young_Module:=1220.0; libsolid[18].Linear_expansion_coefficient:=1.2; libsolid[18].lam:=1000.0; libsolid[18].cp:=520.0; libsolid[18].rho:=3500.0; libsolid[18].mult_lam_x:=1.0; libsolid[18].mult_lam_y:=1.0; libsolid[18].mult_lam_z:=1.0;
   // Si3N4
   // теплопроводность SiN равна 33 по данным фирмы CREE.
   libsolid[19].name:='Si3N4'; libsolid[19].Poisson_ratio:=0.334; libsolid[19].Young_Module:=69.0; libsolid[19].Linear_expansion_coefficient:=22.5; libsolid[19].lam:=33; libsolid[19].cp:=663.0; libsolid[19].rho:=3192.0; libsolid[19].mult_lam_x:=1.0; libsolid[19].mult_lam_y:=1.0; libsolid[19].mult_lam_z:=1.0;
   // KPT8 Кремний органическая паста теплопроводная.
   libsolid[20].name:='KPT8'; libsolid[20].Poisson_ratio:=0.334; libsolid[20].Young_Module:=69.0; libsolid[20].Linear_expansion_coefficient:=22.5; libsolid[20].lam:=0.7; libsolid[20].cp:=1000.0; libsolid[20].rho:=2800.0; libsolid[20].mult_lam_x:=1.0; libsolid[20].mult_lam_y:=1.0; libsolid[20].mult_lam_z:=1.0;
   // Пенополиуретан polyurethane foam
   libsolid[21].name:='Polyurethane_foam'; libsolid[21].Poisson_ratio:=0.334; libsolid[21].Young_Module:=69.0; libsolid[21].Linear_expansion_coefficient:=22.5; libsolid[21].lam:=0.029; libsolid[21].cp:=1.47; libsolid[21].rho:=40.0; libsolid[21].mult_lam_x:=1.0; libsolid[21].mult_lam_y:=1.0; libsolid[21].mult_lam_z:=1.0;
   // Припои из TDIM Master
   // Solder PbSn2Ag2.5
   libsolid[22].name:='SOLDER_PbSn2Ag2.5'; libsolid[22].Poisson_ratio:=0.334; libsolid[22].Young_Module:=69.0; libsolid[22].Linear_expansion_coefficient:=22.5; libsolid[22].lam:=53; libsolid[22].cp:=134; libsolid[22].rho:=11170; libsolid[22].mult_lam_x:=1.0; libsolid[22].mult_lam_y:=1.0; libsolid[22].mult_lam_z:=1.0;
   // Solder SnAg25Sb10
   libsolid[23].name:='SOLDER_SnAg25Sb10'; libsolid[23].Poisson_ratio:=0.334; libsolid[23].Young_Module:=69.0; libsolid[23].Linear_expansion_coefficient:=22.5; libsolid[23].lam:=55; libsolid[23].cp:=210; libsolid[23].rho:=7800;  libsolid[23].mult_lam_x:=1.0; libsolid[23].mult_lam_y:=1.0; libsolid[23].mult_lam_z:=1.0;
   // Solder SnPb36Ag2
   libsolid[24].name:='SOLDER_SnPb36Ag2'; libsolid[24].Poisson_ratio:=0.334; libsolid[24].Young_Module:=69.0; libsolid[24].Linear_expansion_coefficient:=22.5; libsolid[24].lam:=59; libsolid[24].cp:=210; libsolid[24].rho:=9500; libsolid[24].mult_lam_x:=1.0; libsolid[24].mult_lam_y:=1.0; libsolid[24].mult_lam_z:=1.0;
   // Различные клеи из TDIM Master
   // Glue Ablebond 3230 (клей паста)
   libsolid[25].name:='GLUE_Ablebond_3230'; libsolid[25].Poisson_ratio:=0.334; libsolid[25].Young_Module:=69.0; libsolid[25].Linear_expansion_coefficient:=22.5; libsolid[25].lam:=0.6; libsolid[25].cp:=500; libsolid[25].rho:=3600; libsolid[25].mult_lam_x:=1.0; libsolid[25].mult_lam_y:=1.0; libsolid[25].mult_lam_z:=1.0;
   // Glue Ablebond 8290 (клей паста)
   libsolid[26].name:='GLUE_Ablebond_8290'; libsolid[26].Poisson_ratio:=0.334; libsolid[26].Young_Module:=69.0; libsolid[26].Linear_expansion_coefficient:=22.5; libsolid[26].lam:=1.6; libsolid[26].cp:=480; libsolid[26].rho:=3800;  libsolid[26].mult_lam_x:=1.0; libsolid[26].mult_lam_y:=1.0; libsolid[26].mult_lam_z:=1.0;
   // Glue CRM 1033B
   libsolid[27].name:='GLUE_CRM_1033B'; libsolid[27].Poisson_ratio:=0.334; libsolid[27].Young_Module:=69.0; libsolid[27].Linear_expansion_coefficient:=22.5; libsolid[27].lam:=1.5; libsolid[27].cp:=500; libsolid[27].rho:=3500;  libsolid[27].mult_lam_x:=1.0; libsolid[27].mult_lam_y:=1.0; libsolid[27].mult_lam_z:=1.0;
   libsolid[28].name:='SOLDER_Au88Ge12'; libsolid[28].Poisson_ratio:=0.4; libsolid[28].Young_Module:=72.74; libsolid[28].Linear_expansion_coefficient:=13.0; libsolid[28].lam:=44; libsolid[28].cp:=152.8; libsolid[28].rho:=14670; libsolid[28].mult_lam_x:=1.0; libsolid[28].mult_lam_y:=1.0; libsolid[28].mult_lam_z:=1.0;
   // канифоль.
   libsolid[29].name:='kanifoul'; libsolid[29].Poisson_ratio:=0.334; libsolid[29].Young_Module:=69.0; libsolid[29].Linear_expansion_coefficient:=22.5; libsolid[29].lam:=0.164; libsolid[29].cp:=1340; libsolid[29].rho:=1080; libsolid[29].mult_lam_x:=1.0; libsolid[29].mult_lam_y:=1.0; libsolid[29].mult_lam_z:=1.0;
   // теплопроводности с сайта фирмы CREE.
   // CuMoCu (package) lambda 300. AuSn (die attach) 57, SiN (passivation) 33,
   // AlGaN 19, SiC 430, Cu (fixture) 370, Au 317.
   // Polystyrene - полистирол (используется при изготовлении одноразовой посуды, тар для иогуртов,
   // упаковки, детских игрушек, в строительстве для теплоизоляционных плит, облицовочной потолочной плитки.
   libsolid[30].name:='Polystyrene_rigid_R12'; libsolid[30].Poisson_ratio:=0.334; libsolid[30].Young_Module:=69.0; libsolid[30].Linear_expansion_coefficient:=22.5; libsolid[30].lam:=0.04; libsolid[30].cp:=1300; libsolid[30].rho:=56; libsolid[30].mult_lam_x:=1.0; libsolid[30].mult_lam_y:=1.0; libsolid[30].mult_lam_z:=1.0;
   libsolid[31].name:='FR4';libsolid[31].Poisson_ratio:=0.13; libsolid[31].Young_Module:=22.5; libsolid[31].Linear_expansion_coefficient:=14.0; libsolid[31].lam:=0.35; libsolid[31].cp:=1300; libsolid[31].rho:=1250; libsolid[31].mult_lam_x:=1.0; libsolid[31].mult_lam_y:=1.0; libsolid[31].mult_lam_z:=1.0;
   libsolid[32].name:='Polystyrene_Typical'; libsolid[32].Poisson_ratio:=0.334; libsolid[32].Young_Module:=69.0; libsolid[32].Linear_expansion_coefficient:=22.5; libsolid[32].lam:=0.08; libsolid[32].cp:=1300; libsolid[32].rho:=1165; libsolid[32].mult_lam_x:=1.0; libsolid[32].mult_lam_y:=1.0; libsolid[32].mult_lam_z:=1.0;
   libsolid[33].name:='air_solid'; libsolid[33].Poisson_ratio:=0.49; libsolid[33].Young_Module:=1.42e-4; libsolid[33].Linear_expansion_coefficient:=3.331e+3; libsolid[33].lam:=0.0261; libsolid[33].cp:=1005; libsolid[33].rho:=1.1614; libsolid[33].mult_lam_x:=1.0; libsolid[33].mult_lam_y:=1.0; libsolid[33].mult_lam_z:=1.0;
   libsolid[34].name:='indium'; libsolid[34].Poisson_ratio:=0.455; libsolid[34].Young_Module:=11.5; libsolid[34].Linear_expansion_coefficient:=28.5; libsolid[34].lam:=81.8; libsolid[34].cp:=238; libsolid[34].rho:=7310; libsolid[34].mult_lam_x:=1.0; libsolid[34].mult_lam_y:=1.0; libsolid[34].mult_lam_z:=1.0;
   libsolid[35].name:='VK_87_Ceramics'; libsolid[35].Poisson_ratio:=0.22; libsolid[35].Young_Module:=310.0; libsolid[35].Linear_expansion_coefficient:=3.5; libsolid[35].lam:=16.5; libsolid[35].cp:=887; libsolid[35].rho:=3900; libsolid[35].mult_lam_x:=1.0; libsolid[35].mult_lam_y:=1.0; libsolid[35].mult_lam_z:=1.0;
   libsolid[36].name:='AlN'; libsolid[36].Poisson_ratio:=0.24; libsolid[36].Young_Module:=330.0; libsolid[36].Linear_expansion_coefficient:=4.5; libsolid[36].lam:=319.0; libsolid[36].cp:=600; libsolid[36].rho:=3255; libsolid[36].mult_lam_x:=1.0; libsolid[36].mult_lam_y:=1.0; libsolid[36].mult_lam_z:=1.0;
   libsolid[37].name:='vacuum'; libsolid[37].Poisson_ratio:=0.49; libsolid[37].Young_Module:=1.42e-4; libsolid[37].Linear_expansion_coefficient:=3.331e+3; libsolid[37].lam:=0.0001; libsolid[37].cp:=1.0; libsolid[37].rho:=0.0001; libsolid[37].mult_lam_x:=1.0; libsolid[37].mult_lam_y:=1.0; libsolid[37].mult_lam_z:=1.0;
   // Внимание ! модуль Юнга и коэффициент линейного теплового расширения для rogers ортотропны.
   // Ссылка на параметры материалов для различных роджерсов.
   //        http://materials.ellwest.com/rogers/high_guide.pdf
   libsolid[38].name:='rogers5870'; libsolid[38].Poisson_ratio:=0.3685; libsolid[38].Young_Module:=0.185; libsolid[38].Linear_expansion_coefficient:=28.0; libsolid[38].lam:=0.22; libsolid[38].cp:=960.0; libsolid[38].rho:=2200.0; libsolid[38].mult_lam_x:=1.0; libsolid[38].mult_lam_y:=1.0; libsolid[38].mult_lam_z:=1.0;
   libsolid[39].name:='rogers6002'; libsolid[39].Poisson_ratio:=0.3685; libsolid[39].Young_Module:=0.360; libsolid[39].Linear_expansion_coefficient:=16.0; libsolid[39].lam:=0.68; libsolid[39].cp:=930.0; libsolid[39].rho:=2100.0; libsolid[39].mult_lam_x:=1.0; libsolid[39].mult_lam_y:=1.0; libsolid[39].mult_lam_z:=1.0;
   libsolid[40].name:='rogers5880'; libsolid[40].Poisson_ratio:=0.3685; libsolid[40].Young_Module:=0.136; libsolid[40].Linear_expansion_coefficient:=48.0; libsolid[40].lam:=0.2; libsolid[40].cp:=960.0; libsolid[40].rho:=2200.0; libsolid[40].mult_lam_x:=1.0; libsolid[40].mult_lam_y:=1.0; libsolid[40].mult_lam_z:=1.0;
   libsolid[41].name:='rohacellhf51D'; libsolid[41].Poisson_ratio:=0.334; libsolid[41].Young_Module:=69.0; libsolid[41].Linear_expansion_coefficient:=22.5; libsolid[41].lam:=0.0567; libsolid[41].cp:=2399.04; libsolid[41].rho:=52.0; libsolid[41].mult_lam_x:=1.0; libsolid[41].mult_lam_y:=1.0; libsolid[41].mult_lam_z:=1.0;



   // библиотека жидких материалов
   lmatfluid:=8;
   SetLength(libfluid,lmatfluid);
   libfluid[0].name:='Dry_Air'; libfluid[0].rho:=1.1614; libfluid[0].cp:=1005; libfluid[0].lam:=0.0261; libfluid[0].mu:=1.7894e-5; libfluid[0].beta_t:=3.665e-3; libfluid[0].mult_lam_x:=1.0;  libfluid[0].mult_lam_y:=1.0; libfluid[0].mult_lam_z:=1.0; // сухой воздух
   libfluid[1].name:='Hydrogen_H2'; libfluid[1].rho:=0.09; libfluid[1].cp:=14.26e3; libfluid[1].lam:=0.1861; libfluid[1].mu:=9.0e-6; libfluid[1].beta_t:=3.664e-3; libfluid[1].mult_lam_x:=1.0;  libfluid[1].mult_lam_y:=1.0; libfluid[1].mult_lam_z:=1.0; // водород
   libfluid[2].name:='Helium_He'; libfluid[2].rho:=0.18; libfluid[2].cp:=5.29e3; libfluid[2].lam:=0.152; libfluid[2].mu:=20.0e-6; libfluid[2].beta_t:=3.66e-3;  libfluid[2].mult_lam_x:=1.0;  libfluid[2].mult_lam_y:=1.0; libfluid[2].mult_lam_z:=1.0;// гелий
   libfluid[3].name:='Argon_Ar'; libfluid[3].rho:=1.78; libfluid[3].cp:=0.52e3; libfluid[3].lam:=0.0177; libfluid[3].mu:=22.9e-6; libfluid[3].beta_t:=3.676e-3;  libfluid[3].mult_lam_x:=1.0;  libfluid[3].mult_lam_y:=1.0; libfluid[3].mult_lam_z:=1.0; // аргон
   libfluid[4].name:='Carbon_dioxide'; libfluid[4].rho:=1.98; libfluid[4].cp:=1.0e3; libfluid[4].lam:=0.0186; libfluid[4].mu:=15.0e-6; libfluid[4].beta_t:=3.726e-3; libfluid[4].mult_lam_x:=1.0;  libfluid[4].mult_lam_y:=1.0; libfluid[4].mult_lam_z:=1.0; // углекислый газ, двуокись углерода, диоксид углерода
   libfluid[5].name:='Water280K'; libfluid[5].rho:=1000.0; libfluid[5].cp:=4198; libfluid[5].lam:=0.582; libfluid[5].mu:=0.001422; libfluid[5].beta_t:=4.6e-5;  libfluid[5].mult_lam_x:=1.0;  libfluid[5].mult_lam_y:=1.0; libfluid[5].mult_lam_z:=1.0;// вода при температуре 280К
   libfluid[6].name:='Water320K'; libfluid[6].rho:=989; libfluid[6].cp:=4177; libfluid[6].lam:=0.6367; libfluid[6].mu:=0.000577; libfluid[6].beta_t:=0.000435;  libfluid[6].mult_lam_x:=1.0;  libfluid[6].mult_lam_y:=1.0; libfluid[6].mult_lam_z:=1.0; // вода при температуре 320К
   libfluid[7].name:='Water360K'; libfluid[7].rho:=967; libfluid[7].cp:=4206; libfluid[7].lam:=0.6743; libfluid[7].mu:=0.000324; libfluid[7].beta_t:=0.0006979;  libfluid[7].mult_lam_x:=1.0;  libfluid[7].mult_lam_y:=1.0; libfluid[7].mult_lam_z:=1.0; // вода при температуре 360К



   // Инициализация параметров
   // сеточного генератора.
   inx:=23;
   iny:=23;
   inz:=23;
   //etalon_max_size_ratio:=2.0; // отвечает за подробность расчётной сетки. Это значение должно быть всегда больше 1.0.
   //etalon_max_size_ratio2:=30.0; // Отвечает за качество расчётной сетки дефолтное значение 30.
   etalon_max_size_ratio:=10.0; // отвечает за подробность расчётной сетки. Это значение должно быть всегда больше 1.0.
   etalon_max_size_ratio2:=3000000.0; // Отвечает за качество расчётной сетки дефолтное значение 30.

   // Сила тяжести.
   gx:=0.0;
   gy:=0.0;
   gz:=0.0;
   operatingtemperature:=20; // опорная температура град. С.
   // По умолчанию на всех границах стоит однородное условие Неймана,
   // что физически обозначает адиабатическую стенку.
   adiabatic_vs_heat_transfer_coeff:=0;
   filmcoefficient:=0.0;

   // Информация об уравнениях которые придётся решать:
   egddata.itemper:=1; // решаем уравнение теплопроводности МКО
   egddata.iStaticStructural:=0; // Не решаем Static Structural.
   egddata.imaxflD:=1; // одна жидкая зона
   SetLength(egddata.myflmod,egddata.imaxflD); // одна жидкая зона
   // координаты опорной точки
   // Эта точка всегда находится внутри данной жидкости.
   egddata.myflmod[0].xc:=0.0;
   egddata.myflmod[0].yc:=0.0;
   egddata.myflmod[0].zc:=0.0;
   egddata.myflmod[0].iflow:=1; // считаем течение в данной жидкой зоне.
   // устанавливаем режим течения: 0 - ламинарный, 1 - турбулентный
   egddata.myflmod[0].iflowregime:=0; // режим течения ламинарный
   // модель турбулентности турбулентного режима
   // 0 - алгебраическая RANS модель Zero Equation Model (RANS)
   // 1 - модель Смагоринского (LES). (в неё как опция включена динамическая модель Германо 1991.)
   // 2 - RNG (LES).
   // 3 - Spalart Allmares (RANS) [1992]
   // 4 - K-Omega SST Menter (RANS) [1993]
   // 5 - Standart K-Epsilon (RANS) [2001]
   // 6 - модель ламинарно турбулентного перехода Ментора Лантгрии (RANS) [2009].
   egddata.myflmod[0].iturbmodel:=0; // ZEM
   // модель Смагоринского
   egddata.myflmod[0].SmagConst:=0.151; // при Ck==1.8   (Ck соответствующая константа Колмогорова).
   egddata.myflmod[0].iDynamicStressGermano:=0; // модель Германо не используется
   egddata.myflmod[0].iLimitersCs:=0; // ограничения на константу Смагоринского не используются.
   egddata.myflmod[0].minCs:=-1.0e20; // данное значение не является ограничением.
   egddata.myflmod[0].maxCs:=1.0e23; // данное значение не является ограничением.
   egddata.myflmod[0].itypeFiltrGermano:=2; // фильтр Симпсона.
   egddata.myflmod[0].bSmagorinsky_Lilly:=true; // модель Смагоринского-Лиллу.
   egddata.myflmod[0].bfdelta:=true; // учёт неравномерности сетки
   egddata.myflmod[0].bsurface_roughness:=false; // не учитывать шероховатость стенки.
   egddata.myflmod[0].ipowerroughness:=2; // показатель степени в модели.
   egddata.myflmod[0].roughness:=10.0; // micron (шероховатость стенки в мкм).
   egddata.myflmod[0].bSwirlamendment:=true; // поправка для течений с кривизной линий тока.
   egddata.myflmod[0].rRimult:=1.0; // на эту величину будет домножаться турбулентное число Ричардсона.
   // Лучше выключить селективную модель Смагоринского так как она требует тонкого подбора отсекающего угла.
   egddata.myflmod[0].bSelectiveSmagorinsky:=false; // добавляем избирательности в модель Смагоринского.
   egddata.myflmod[0].rSelectiveAngle:=15.0; // значение угла равное 15 градусов подобрано из DNS моделирования.
   egddata.myflmod[0].itypefiltr:=2; // фильтр Симпсона.

   

   ivar:=2; // нету переменных.
   SetLength(parametric,2); // нет переменных
    if (FormatSettings.DecimalSeparator=',') then
   begin
      parametric[0].svar:='$emiss';
      parametric[0].sval:='0,8';
      parametric[1].svar:='$alpha';
      parametric[1].sval:='0,3';
   end;
    if (FormatSettings.DecimalSeparator='.') then
   begin
      parametric[0].svar:='$emiss';
      parametric[0].sval:='0.8';
      parametric[1].svar:='$alpha';
      parametric[1].sval:='0.3';
   end;



   iltdp:=0; // пока нет ни одной таблицы.
   SetLength(listtablename,0); // пустой список имён файлов

   R1:=0.5*Hscale*sqrt(Sqr(body[0].xE-body[0].xS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].zE-body[0].zS));



   dc:=GetDC(pnlPaint.Handle);
   if not InitOpenGL then //если OpenGL не доступна, то приложение закрываем
      Application.Terminate;
   hrc := CreateRenderingContext(dc,[opDoubleBuffered],32,24,0,0,0,0); //здесь создаем контекст рендеринга, //необходимыми параметрами, в предыдущем уроке мы их изучали
   ActivateRenderingContext(dc,hrc); //теперь активируем и связываем контекст рендеринга и контекст //устройства
   SetupGL; // включение необходимого состояния OpenGL.
   Application.OnIdle:=IdleHandler;

   glEnable(GL_DEPTH_TEST); //включить тест глубины : включаем проверку разрешения фигур (впереди стоящая закрывает фигуру за ней)
   glDepthFunc(GL_LEQUAL); //тип проверки

   MainMemo.Lines.Add('Current date and time:'+ DateTimeToStr(Now));
   MainMemo.Lines.Add('This is 64 bit version.');
   MainMemo.Lines.Add('Done loading.');
   breadfinish:=true;
   bon_rotate_polygon:=true;

   if (bREALESEversion) then
   begin
      // МАНИФЕСТ СТАБИЛЬНОСТИ
      // ДЛЯ ПОЛЬЗОВАТЕЛЯ 04.08.2019

      // Мы полностью отключаем все
      // недоработанные функциональные
      // возможности из интерфейса программы.

      // Мы не используем больше
      // плоских бесконечно тонких
      // источников тепла.
      // Используйте мощность
      // тепловыделения внутри блоков.
      DaddSource.Visible:=false;

      // Мы не визуализируем больше
      // результат вычисления у
      // себя в программе т.к.
      // сторонние визуализаторы
      // tecplot360.exe и paraview.exe
      // значительно лучше.
      // В моём визуализаторе к тому-же
      // наблюдается проблема с правильностью
      // использования OpenGL.
      LoadSolutionID.Visible:=false;
      // Также собственный визуализатор
      // неудовлетворительно работает
      // (не работает) поэтому геометрия
      // прорисовывается каркасно линиями
      // без удаления невидимых линий.
      // Это значительно меньше ресурсов
      // требует от компьютера.
      // Прорисовка только линиями.
      rgview.Visible:=true;
      SpeedButton1.Visible:=false;
       // Среди моделей турбулентности оставляем только
      // Zero Equation Turbulence Model.
      //EGDForm.ComboBoxturbulentmodel.Items.Clear;
      //EGDForm.ComboBoxturbulentmodel.Items.Add('Zero Equation Model (RANS)');
      //EGDForm.ComboBoxturbulentmodel.ItemIndex:=0;
      // Полностью отключаем механику из интерфейса
      // т.к. она так и не заработала на мсмент
      // 4 августа 2019 года.
      //EGDForm.CheckBoxStaticStructural.Visible:=true;
      //EGDForm.CheckBoxStaticStructural.Checked:=false;
      // Не задаём свойства механических материалов.
      //FormUserDefinedSolidMat.GroupBoxThermalStress.Visible:=true;
      //FormUserDefinedSolidMat.PanelSOLID.Width:=287;
      //FormUserDefinedSolidMat.Width:=290;
      // Убираем управление фиксацией боковых стенок цилиндра.
      //AddBlockForm.CheckBoxFixedCylinder.Visible:=true;
      // Убираем задание механических граничных условий на стенке.
      //AddWallForm.GroupBoxThermalStress.Visible:=true;

      //bon_rotate_polygon:=false; // закоментировать если используется вращение полигона
   end;

end;


// событие OnPaint
(*
procedure TLaplas.MainPaintBoxPaint(Sender: TObject);
const
    ax = 100;
    epsilon = 1e-20;  // для определения вещественного нуля
var
    L, i,j : Integer;
    xs1,ys1,xe1,ye1, xcenter, ycenter : Integer;
    zcenter : Real;
    p,q : TVertex; // прорисовка осей координат
    xc, yc : Integer; // центральная точка на холсте
    s : string; // имя редактируемого элемента
    ch : Char;  // характеризующий префикс элемента
    bcontinue, bsel : Boolean; // нужно ли продолжать поиск
    // причины. событие просивовки вызывается в любой момент, оно не должно изменять itek.
    // Описание возможного бага если не ввести данную переменную itekpaint и работать с itek.
    // Выделен кабинет создаём блок вызывается событие paint в дереве выделен кабинет он и становится itek,
    // тем самым правильный itek утерян так как мы ещё не добавили в дерево block1 сразу при подготовке.
    // Вобщем здесь надо работать с локальным itekpaint.
    itekpaint : Integer; // выделенный элемент для прорисовки не означает что он выбран для редактирования.
    riso : Real;
    c : Real;
    code : Integer;
    // двойная буферизация.
    bpic : TBitmap;
    SRect, DRect : TRect;
    bzbuf : Boolean;

begin

   bzbuf:=chkzbuffer.Checked; // удаление невидимых линий.

   bpic:=TBitmap.Create();
   bpic.Width:=MainPaintBox.Width;
   bpic.Height:=MainPaintBox.Height;
   SRect:=Rect(0,0,bpic.Width,bpic.Height);
   DRect:=Rect(0,0,bpic.Width,bpic.Height);

   if (bzbuf) then
   begin
      // инициализация z buffer`a.
      for i:=0 to MainPaintBox.Width do
      begin
         for j:=0 to MainPaintBox.Height do
         begin
            zbuffer[i,j]:=-1.0e20;
         end;
      end;
   end;

   xc:= MainPaintBox.Width div 2;
   yc:= MainPaintBox.Height div 2;

   // вызывается при создании формы
   with bpic.Canvas(*MainPaintBox.Canvas*)(* do
   begin


        Brush.Color:=clWhite;

        Rectangle(0,0,Width, Height);

        // оси координат
        Pen.Color:=clGray;
        Pen.Style:=psDot;

        q.x:=ax; q.y:=0; q.z:=0;
        axis(q,p); // вращение
        MoveTo(120,yc-120); LineTo(round(120+p.x),round(yc-120+p.y));
        TextOut(round(120+p.x),round(yc-120+p.y),'X');
        q.x:=0; q.y:=ax; q.z:=0;
        axis(q,p);
        MoveTo(120,yc-120); LineTo(round(120 + p.x),round(yc-120 + p.y));
        TextOut(round(120+p.x),round(yc-120+p.y),'Y');
        q.x:=0; q.y:=0; q.z:=ax;
        axis(q,p);
        MoveTo(120,yc-120); LineTo(round(120 + p.x),round(yc-120 + p.y));
        TextOut(round(120+p.x),round(yc-120+p.y),'Z');

        // Прорисовка источников тепла:
        Pen.Color:=clGreen; // источники нарисуются зелёным
        Pen.Style:=psSolid;
        RotateSource; // вращение
        for j:=0 to (ls-1) do
        begin // проход по всем источникам тепла
           with source[j] do
           begin
              if (source[j].bvisible) then
              begin
                 for i:=0 to 3 do
                 begin // проход по всем рёбрам
                    xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                    ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                    xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                    ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                    if (bzbuf) then
                    begin
                       Brezenhem(xs1, ys1, xe1, ye1);
                    end
                     else
                    begin
                       MoveTo(xs1,ys1);
                       LineTo(xe1,ye1);
                    end;
                 end;
              end;
           end;
        end;

        // Прорисовка блоков:
        Pen.Color:=clBlue;
        Rotate; // вращение

        with (body[0]) do
        begin
           if (body[0].bvisible) then
           begin
              L:=Length(Edges);
              for i:=0 to (L-1) do
              begin
                xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                if (bzbuf) then
                 begin
                    //Brezenhem(xs1, ys1, xe1, ye1);
                 end
                  else
                 begin
                    MoveTo(xs1,ys1);
                    LineTo(xe1,ye1);
                 end;
              end;
           end;
        end;
        Pen.Color:=clBlack;
        for j:=1 to lb-1 do
        begin
           with (body[j]) do
           begin
              if (bvisible) then
              begin
                 case cbbview.ItemIndex of
                  0 : // all
                   begin
                      L:=Length(Edges);

                      if (bzbuf) then
                      begin
                        if (itype<>2) then
                        begin
                         // Только не hollow block.

                         // сначала закрашиваем видимую грань.
                         xcenter:=Round(0.25*(round(xc+m*Vertext[0].x)+round(xc+m*Vertext[1].x)+round(xc+m*Vertext[4].x)+round(xc+m*Vertext[5].x)));
                         ycenter:=Round(0.25*(round(yc+m*Vertext[0].y)+round(yc+m*Vertext[1].y)+round(yc+m*Vertext[4].y)+round(yc+m*Vertext[5].y)));
                         zcenter:=0.25*(Vertext[0].z+Vertext[1].z+Vertext[4].z+Vertext[5].z);
                         DrawTriangle(round(xc+m*Vertext[0].x) ,round(xc+m*Vertext[1].x) , xcenter , round(yc+m*Vertext[0].y) , round(yc+m*Vertext[1].y) , ycenter , Vertext[0].z , Vertext[1].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[1].x) ,round(xc+m*Vertext[5].x) , xcenter , round(yc+m*Vertext[1].y) , round(yc+m*Vertext[5].y) , ycenter , Vertext[1].z , Vertext[5].z , zcenter  );
                         DrawTriangle(round(xc+m*Vertext[5].x) ,round(xc+m*Vertext[4].x) , xcenter , round(yc+m*Vertext[5].y) , round(yc+m*Vertext[4].y) , ycenter , Vertext[5].z , Vertext[4].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[0].x) ,round(xc+m*Vertext[4].x) , xcenter , round(yc+m*Vertext[0].y) , round(yc+m*Vertext[4].y) , ycenter , Vertext[0].z , Vertext[4].z , zcenter  );
                         xcenter:=Round(0.25*(round(xc+m*Vertext[1].x)+round(xc+m*Vertext[3].x)+round(xc+m*Vertext[5].x)+round(xc+m*Vertext[7].x)));
                         ycenter:=Round(0.25*(round(yc+m*Vertext[1].y)+round(yc+m*Vertext[3].y)+round(yc+m*Vertext[5].y)+round(yc+m*Vertext[7].y)));
                         zcenter:=0.25*(Vertext[1].z+Vertext[3].z+Vertext[5].z+Vertext[7].z);
                         DrawTriangle(round(xc+m*Vertext[1].x) ,round(xc+m*Vertext[3].x) , xcenter , round(yc+m*Vertext[1].y) , round(yc+m*Vertext[3].y) , ycenter , Vertext[1].z , Vertext[3].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[1].x) ,round(xc+m*Vertext[5].x) , xcenter , round(yc+m*Vertext[1].y) , round(yc+m*Vertext[5].y) , ycenter , Vertext[1].z , Vertext[5].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[5].x) ,round(xc+m*Vertext[7].x) , xcenter , round(yc+m*Vertext[5].y) , round(yc+m*Vertext[7].y) , ycenter , Vertext[5].z , Vertext[7].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[3].x) ,round(xc+m*Vertext[7].x) , xcenter , round(yc+m*Vertext[3].y) , round(yc+m*Vertext[7].y) , ycenter , Vertext[3].z , Vertext[7].z , zcenter );
                         xcenter:=Round(0.25*(round(xc+m*Vertext[4].x)+round(xc+m*Vertext[5].x)+round(xc+m*Vertext[7].x)+round(xc+m*Vertext[6].x)));
                         ycenter:=Round(0.25*(round(yc+m*Vertext[4].y)+round(yc+m*Vertext[5].y)+round(yc+m*Vertext[7].y)+round(yc+m*Vertext[6].y)));
                         zcenter:=0.25*(Vertext[4].z+Vertext[5].z+Vertext[7].z+Vertext[6].z);
                         DrawTriangle(round(xc+m*Vertext[4].x) ,round(xc+m*Vertext[5].x) , xcenter , round(yc+m*Vertext[4].y) , round(yc+m*Vertext[5].y) , ycenter , Vertext[4].z , Vertext[5].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[5].x) ,round(xc+m*Vertext[7].x) , xcenter , round(yc+m*Vertext[5].y) , round(yc+m*Vertext[7].y) , ycenter , Vertext[5].z , Vertext[7].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[6].x) ,round(xc+m*Vertext[7].x) , xcenter , round(yc+m*Vertext[6].y) , round(yc+m*Vertext[7].y) , ycenter , Vertext[6].z , Vertext[7].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[4].x) ,round(xc+m*Vertext[6].x) , xcenter , round(yc+m*Vertext[4].y) , round(yc+m*Vertext[6].y) , ycenter , Vertext[4].z , Vertext[6].z , zcenter);
                         xcenter:=Round(0.25*(round(xc+m*Vertext[0].x)+round(xc+m*Vertext[2].x)+round(xc+m*Vertext[6].x)+round(xc+m*Vertext[4].x)));
                         ycenter:=Round(0.25*(round(yc+m*Vertext[0].y)+round(yc+m*Vertext[2].y)+round(yc+m*Vertext[6].y)+round(yc+m*Vertext[4].y)));
                          zcenter:=0.25*(Vertext[0].z+Vertext[2].z+Vertext[6].z+Vertext[4].z);
                         DrawTriangle(round(xc+m*Vertext[0].x) ,round(xc+m*Vertext[2].x) , xcenter , round(yc+m*Vertext[0].y) , round(yc+m*Vertext[2].y) , ycenter , Vertext[0].z , Vertext[2].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[0].x) ,round(xc+m*Vertext[4].x) , xcenter , round(yc+m*Vertext[0].y) , round(yc+m*Vertext[4].y) , ycenter , Vertext[0].z , Vertext[4].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[4].x) ,round(xc+m*Vertext[6].x) , xcenter , round(yc+m*Vertext[4].y) , round(yc+m*Vertext[6].y) , ycenter , Vertext[4].z , Vertext[6].z , zcenter);
                         DrawTriangle(round(xc+m*Vertext[2].x) ,round(xc+m*Vertext[6].x) , xcenter , round(yc+m*Vertext[2].y) , round(yc+m*Vertext[6].y) , ycenter , Vertext[2].z , Vertext[6].z , zcenter );
                         xcenter:=Round(0.25*(round(xc+m*Vertext[2].x)+round(xc+m*Vertext[3].x)+round(xc+m*Vertext[7].x)+round(xc+m*Vertext[6].x)));
                         ycenter:=Round(0.25*(round(yc+m*Vertext[2].y)+round(yc+m*Vertext[3].y)+round(yc+m*Vertext[7].y)+round(yc+m*Vertext[6].y)));
                          zcenter:=0.25*(Vertext[2].z+Vertext[3].z+Vertext[7].z+Vertext[6].z);
                         DrawTriangle(round(xc+m*Vertext[2].x) ,round(xc+m*Vertext[3].x) , xcenter , round(yc+m*Vertext[2].y) , round(yc+m*Vertext[3].y) , ycenter , Vertext[2].z , Vertext[3].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[3].x) ,round(xc+m*Vertext[7].x) , xcenter , round(yc+m*Vertext[3].y) , round(yc+m*Vertext[7].y) , ycenter , Vertext[3].z , Vertext[7].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[6].x) ,round(xc+m*Vertext[7].x) , xcenter , round(yc+m*Vertext[6].y) , round(yc+m*Vertext[7].y) , ycenter , Vertext[6].z , Vertext[7].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[2].x) ,round(xc+m*Vertext[6].x) , xcenter , round(yc+m*Vertext[2].y) , round(yc+m*Vertext[6].y) , ycenter , Vertext[2].z , Vertext[6].z , zcenter );
                         xcenter:=Round(0.25*(round(xc+m*Vertext[0].x)+round(xc+m*Vertext[1].x)+round(xc+m*Vertext[3].x)+round(xc+m*Vertext[2].x)));
                         ycenter:=Round(0.25*(round(yc+m*Vertext[0].y)+round(yc+m*Vertext[1].y)+round(yc+m*Vertext[3].y)+round(yc+m*Vertext[2].y)));
                          zcenter:=0.25*(Vertext[0].z+Vertext[1].z+Vertext[3].z+Vertext[2].z);
                         DrawTriangle(round(xc+m*Vertext[0].x) ,round(xc+m*Vertext[1].x) , xcenter , round(yc+m*Vertext[0].y) , round(yc+m*Vertext[1].y) , ycenter , Vertext[0].z , Vertext[1].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[1].x) ,round(xc+m*Vertext[3].x) , xcenter , round(yc+m*Vertext[1].y) , round(yc+m*Vertext[3].y) , ycenter , Vertext[1].z , Vertext[3].z , zcenter );
                         DrawTriangle(round(xc+m*Vertext[2].x) ,round(xc+m*Vertext[3].x) , xcenter , round(yc+m*Vertext[2].y) , round(yc+m*Vertext[3].y) , ycenter , Vertext[2].z , Vertext[3].z , zcenter);
                         DrawTriangle(round(xc+m*Vertext[0].x) ,round(xc+m*Vertext[2].x) , xcenter , round(yc+m*Vertext[0].y) , round(yc+m*Vertext[2].y) , ycenter , Vertext[0].z , Vertext[2].z , zcenter );
                         // затем прорисовываем оребрение.
                         //Brezenhem(xs1, ys1, xe1, ye1);
                         end;
                      end
                       else
                      begin

                         for i:=0 to (L-1) do
                         begin
                            xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                            ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                            xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                            ye1:=round(yc+m*Vertext[Edges[i].p2].y);

                            //Brezenhem(xs1, ys1, xe1, ye1);

                            MoveTo(xs1,ys1);
                            LineTo(xe1,ye1);
                         end;
                      end;
                   end;
              1 : // XY
                   begin
                      sforval:='';
                    sforval:=StringReplace(edtvalue.Text,',','.',[rfReplaceAll]);
                    val(sforval,c,code);
                     //val(edtvalue.Text,c,code);
                     if (code=0) then
                     begin
                        riso:=StrToFloat(edtvalue.Text);
                        if ((riso>=zS)and(riso<=zE)) then
                        begin
                          L:=Length(Edges);
                          for i:=0 to (L-1) do
                          begin
                             xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                             ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                             MoveTo(xs1,ys1);
                             xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                             ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                             LineTo(xe1,ye1);
                          end;
                       end;
                    end
                     else
                    begin
                       ShowMessage('Error! Incorrect iso value...');
                       edtvalue.Text:='0.0';
                    end;
                 end;
              2 : // XZ
                 begin
                     sforval:='';
                    sforval:=StringReplace(edtvalue.Text,',','.',[rfReplaceAll]);
                    val(sforval,c,code);
                    //val(edtvalue.Text,c,code);
                    if (code=0) then
                    begin
                       riso:=StrToFloat(edtvalue.Text);
                       if ((riso>=yS)and(riso<=yE)) then
                       begin
                          L:=Length(Edges);
                          for i:=0 to (L-1) do
                          begin
                             xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                             ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                             MoveTo(xs1,ys1);
                             xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                             ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                             LineTo(xe1,ye1);
                          end;
                       end;
                    end
                     else
                    begin
                       ShowMessage('Error! Incorrect iso value...');
                       edtvalue.Text:='0.0';
                    end;
                 end;
              3 : // YZ
                 begin
                      sforval:='';
                    sforval:=StringReplace(edtvalue.Text,',','.',[rfReplaceAll]);
                    val(sforval,c,code);
                    //val(edtvalue.Text,c,code);
                    if (code=0) then
                    begin
                       riso:=StrToFloat(edtvalue.Text);
                       if ((riso>=xS)and(riso<=xE)) then
                       begin
                          L:=Length(Edges);
                          for i:=0 to (L-1) do
                          begin
                             xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                             ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                             MoveTo(xs1,ys1);
                             xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                             ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                             LineTo(xe1,ye1);
                          end;
                       end;
                    end
                     else
                    begin
                       ShowMessage('Error! Incorrect iso value...');
                       edtvalue.Text:='0.0';
                    end;
                 end;
              end;
           end;
        end;
     end;

     // При использовании алгоритма удаления невидимых линий
     // кабинет прорисовываем в последнююю очередь.
     // Прорисовка блоков:
        Pen.Color:=clBlue;
        Rotate; // вращение

        with (body[0]) do
        begin
           if (body[0].bvisible) then
           begin
              L:=Length(Edges);
              for i:=0 to (L-1) do
              begin
                xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                if (bzbuf) then
                 begin
                    Brezenhem(xs1, ys1, xe1, ye1);
                 end
                  else
                 begin
                    //MoveTo(xs1,ys1);
                    //LineTo(xe1,ye1);
                 end;
              end;
           end;
        end;

     // прорисовка стенок
     Pen.Color:=clGray; // стенки нарисуются серым
     RotateWall; // вращение
     for j:=0 to (lw-1) do
     begin // проход по всем твёрдым стенкам
        with wall[j] do
        begin
           if (wall[j].bvisible) then
           begin

              if (bsymmetry or bpressure) then Pen.Color:=clYellow;
              if ((abs(Vx)>epsilon) or (abs(Vy)>epsilon) or (abs(Vz)>epsilon)) then
                    Pen.Color:=clFuchsia; // Сиреневый
              for i:=0 to 3 do
              begin // проход по всем рёбрам
                 xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                 ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                 xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                 ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                 if (bzbuf) then
                 begin
                    Brezenhem(xs1, ys1, xe1, ye1);
                 end
                 else
                 begin
                    MoveTo(xs1,ys1);
                    LineTo(xe1,ye1);
                 end;
              end;
           end;

        end;
     end;

   bsel:=false;
   for i:=0 to MainTreeView.Items.Count-1 do
   begin
      if (MainTreeView.Items.Item[i].Selected) then
      begin
         bsel:=true;  // по крайней мере один элемент в дереве выделен
      end;
   end;

   if ( breadfinish and bsel) then
   begin
      // Мы прорисовываем геометрию в любое время кроме времени
      // в течение которого осуществляется построение модели

      // Выделение цветом выделенного в дереве элемента
      s:=MainTreeView.Selected.Text;
      if (length(s)<>0) then
      begin
         // символ ch может принимать значения : c, b, s, w, u, e-exit
         ch:='e';
         bcontinue:=true;
         // по всем блокам
         for i:=0 to (lb-1) do
         begin
            if (bcontinue and (length(body[i].name) = length(s)) and (Pos(body[i].name,s)=1)) then
            begin
               // найден блок :
               bcontinue:=false;
               itekpaint:=i;
               if (i=0) then
               begin
                  ch:='c';
               end
                else
               begin
                  ch:='b';
               end;
            end;
         end;
         if (ch='e') then
         begin
            // по всем источникам
            for i:=0 to (ls-1) do
            begin
               if (bcontinue and (length(source[i].name) = length(s)) and (Pos(source[i].name,s)=1)) then
               begin
                  // найден источник
                  bcontinue:=false;
                  ch:='s';
                  itekpaint:=i;
               end;
            end;
         end;
         if (ch='e') then
         begin
            // по всем твёрдым стенкам
            for i:=0 to (lw-1) do
            begin
               if (bcontinue and (length(wall[i].name) = length(s)) and (Pos(wall[i].name,s)=1)) then
               begin
                  // найдена твёрдая стенка.
                  bcontinue:=false;
                  itekpaint:=i;
                  ch:='w';
               end;
            end;
        end;
        if (ch='e') then
        begin
           // по всем объединениям
           for i:=0 to (lu-1) do
           begin
              if (bcontinue and (length(myassembles[i].name) = length(s)) and (Pos(myassembles[i].name,s)=1)) then
              begin
                 bcontinue:=false;
                 ch:='u'; // двойной щелчек по объединению
                 itekpaint:=myassembles[i].identifire; // идентификатор объединения
                 // внимание : обязательно должна быть справедлива связь itek=identifire=i+1;
                 // т.е. номер объединения в списке должен быть на единицу меньше его идентификатора.
              end;
           end;
        end;

        Pen.Color:=clRed; // выделенный элемент покажем красным.
        Pen.Width:=2; // в трое более толстое перо
        case ch of
         'b' : begin
                  with (body[itekpaint]) do
                  begin
                     L:=Length(Edges);
                     for i:=0 to (L-1) do
                     begin
                        xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                        ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                        MoveTo(xs1,ys1);
                        xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                        ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                        LineTo(xe1,ye1);
                     end;
                  end;
               end;
         's' : begin
                  with source[itekpaint] do
                  begin
                     for i:=0 to 3 do
                     begin // проход по всем рёбрам
                        xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                        ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                        MoveTo(xs1,ys1);
                        xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                        ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                        LineTo(xe1,ye1);
                     end;
                  end;
               end;
         'w' : begin
                  with wall[itekpaint] do
                  begin
                     for i:=0 to 3 do
                     begin // проход по всем рёбрам
                        xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                        ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                        MoveTo(xs1,ys1);
                        xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                        ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                        LineTo(xe1,ye1);
                     end;
                  end;
               end;
        end;
      end;

   end;

   Pen.Width:=1; // стандартная ширина пера
   Pen.Color:=clBlack; // возвращение чёрного цвета

   end;
   // Копируем только после прорисовки.
   MainPaintBox.Canvas.CopyRect(DRect,bpic.Canvas,SRect);
end;
*)



 (*
// движение мыши
procedure TLaplas.MainPaintBoxMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   //a,b : Real;
   iAlf, iBet : Integer; // углы в градусах
   idx, idy : Integer;
begin
   if drawing then
   begin
      (*
      // углы меняются от -90 до +90 градусов
      a:=X - Width div 2;
      b:=Y - Height div 2;
      Alf:=ArcTan2(b,a);
      iAlf:=Round((Alf/3.141)*180);
      if ((iAlf>90) or (iAlf<-90)) then iAlf:=iAlf mod 90;
      Alf:=(iAlf/180)*3.141;
      Bet:=Sqrt(Sqr(a/30)+Sqr(b/30));
      iBet:=Round((Bet/3.141)*180);
      if ((iBet>90) or (iBet<-90)) then iBet:=iBet mod 90;
      Bet:=(iBet/180)*3.141;
      MainPaintBoxPaint(Sender);
      *)(*

      idx:=X-ixo;
      idy:=Y-iyo;
      if (idx>0) then Alf:=Alf+3.141/180; // добавляем один градус
      if (idx<0) then Alf:=Alf-3.141/180; // вычитаем один градус
      iAlf:=Round((Alf/3.141)*180);
      //if ((iAlf>90) or (iAlf<-90)) then iAlf:=iAlf mod 90;  // разрывы при вращении.
      // конструкция приведённая ниже должна обеспечивать непрерывное
      // плавное вращение во всём спектре.
      if (iAlf>180) then
      begin
        iAlf:=-180+(iAlf-180);
      end
      else
      if (iAlf<-180) then
      begin
        iAlf:=180+(iAlf+180);
      end;
      Alf:=(iAlf/180)*3.141;

      if (idy>0) then Bet:=Bet+3.141/180; // добавляем один градус
      if (idy<0) then Bet:=Bet-3.141/180; // вычитаем один градус
      iBet:=Round((Bet/3.141)*180);
      //if ((iBet>90) or (iBet<-90)) then iBet:=iBet mod 90; // разрывы при вращении.
      // конструкция приведённая ниже должна обеспечивать непрерывное
      // плавное вращение во всём спектре.
      if (iBet>180) then
      begin
        iBet:=-180+(iBet-180);
      end
      else
      if (iBet<-180) then
      begin
        iBet:=180+(iBet+180);
      end;
      Bet:=(iBet/180)*3.141;

      ixo:=X; iyo:=Y;
      MainPaintBoxPaint(Sender);

   end;
end;
*)
 (*
// левая кнопка мыши нажата
procedure TLaplas.MainPaintBoxMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   bzbufloc:=chkzbuffer.Checked;
   chkzbuffer.Checked:=False;
   if (Button = mbLeft) then
   begin
      drawing:=true;
      // запоминаем начальную позицию мыши
      ixo:=X;
      iyo:=Y;
   end
    else
   begin
       if (Button = mbRight) then
       begin
          // Нажата правая кнопка мыши
          // запоминаем начальную позицию мыши
          ixo:=X;
          iyo:=Y;
       end;
   end;
end;
*)
 (*
// если мы зажимаем правую кнопку мыши и перемещаем курсор при зажатой правой кнопке,
// а потом отпускаем правую кнопку то картинка перемещается в ту сторону в которую была перетащена мышь.
procedure TLaplas.MainPaintBoxMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
const
     epsilon = 0.01;
var
    dxz, dyz, dzz : Real;
    dxold, dyold, dzold : Real;

begin
   if (Button = mbLeft) then
   begin
      drawing:=false;
   end
    else
   begin
      if (Button = mbRight) then
      begin
         dxold:=-(X-ixo)/m;
         dyold:=-(Y-iyo)/m;
         dzold:=0.0;

         // домножаем на обратную матрицу поворота, найденную аналитически в maple.
         dxz:=dxold*cos(Alf)+dyold*sin(Alf)*cos(Bet)+dzold*sin(Alf)*sin(Bet);
         dyz:=-dxold*sin(Alf)+dyold*cos(Alf)*cos(Bet)+dzold*cos(Alf)*sin(Bet);
         dzz:=-dyold*sin(Bet)+dzold*cos(Bet);

         Oxc:=Oxc+dxz;
         Oyc:=Oyc+dyz;
         Ozc:=Ozc+dzz;
         MainPaintBoxPaint(Sender);
      end;
   end;
    chkzbuffer.Checked:=bzbufloc;
end;
*)

// Увеличение изображения в окошке
procedure TLaplas.BzoompClick(Sender: TObject);
begin
   // колёсико движется вверх
   {
    if (m>11) then
    begin
        m:=m+10; // ZOOM
    end
    else
    begin
       if (m>0.11) then
       begin
          m:=m+0.1;
       end
       else
       begin
          if (m>0.011) then
          begin
             m:=m+0.01; // ZOOM
          end
           else
          begin
             m:=m+0.001;
          end;
       end;
    end;
    }
    (*
    if (perspectiveangle>-178.0) then
   begin
       if (perspectiveangle>-170.0) then
       begin
          perspectiveangle:=perspectiveangle-1.0;
       end
       else
       begin
          perspectiveangle:=perspectiveangle-0.1;
       end;
   end;
      *)
      // 3 февраля 2017
    perspectiveangle_counter:=perspectiveangle_counter-30.0; //1.0
   if (perspectiveangle_counter>8000.0) then
    begin
        perspectiveangle_counter:=8000.0;
    end;
      if (perspectiveangle_counter<-8000.0) then
    begin
        perspectiveangle_counter:=-8000.0;
    end;

   //perspectiveangle:=90.0+90.0*arctan(0.08*perspectiveangle_counter)/1.5705;
   perspectiveangle:=return_Perspective_angle(perspectiveangle_counter);

  // MainPaintBoxPaint(Sender);
end;

// Уменьшение изображения в окошке
procedure TLaplas.BzoommClick(Sender: TObject);
begin
{
   if (m>11) then
    begin
        m:=m-10; // ZOOM
    end
    else
    begin
       if (m>0.11) then
       begin
          m:=m-0.1;
       end
        else
       begin
          if (m>0.011) then
          begin
             m:=m-0.01;
          end
           else
          begin
             m:=m-0.001;
          end;
       end;
    end;
    }
  // MainPaintBoxPaint(Sender);
  (*
   if (perspectiveangle<178.0) then
   begin
      if (perspectiveangle<170.0) then
       begin
          perspectiveangle:=perspectiveangle+1.0;
       end
       else
       begin
          perspectiveangle:=perspectiveangle+0.1;
       end;
   end;
   *)
   // 3 февраля 2017
    perspectiveangle_counter:=perspectiveangle_counter+30.0; // 1.0
      if (perspectiveangle_counter>8000.0) then
    begin
        perspectiveangle_counter:=8000.0;
    end;
      if (perspectiveangle_counter<-8000.0) then
    begin
        perspectiveangle_counter:=-8000.0;
    end;

   //perspectiveangle:=90.0+90.0*arctan(0.08*perspectiveangle_counter)/1.5705;
   perspectiveangle:=return_Perspective_angle(perspectiveangle_counter);

end;

// инициализация формы редактирования блока
procedure TLaplas.initializeaddblockform;
const
    epsilon = 1e-20;  // для определения вещественного нуля
var
    i : Integer;
begin
   with body[itek] do
   begin
      AddBlockForm.ComboBoxLineWidth.ItemIndex:=BodyLineWidth-1; // толщина линии 1-6.

      // показываем приоритет блока на форме.
      AddBlockForm.EditPriority.Text:=IntToStr(priority);
      AddBlockForm.ComboBoxgeometryType.ItemIndex:=igeometry_type;
      AddBlockForm.CheckBoxVisible.Checked:=bvisible;

      AddBlockForm.CheckBoxFixedCylinder.Checked:=Laplas.body[Laplas.itek].CylinderFixed;
      if (Laplas.body[Laplas.itek].igeometry_type=1) then
      begin
         // Cylinder.
         AddBlockForm.CheckBoxFixedCylinder.Visible:=true;
      end
       else
      begin
          AddBlockForm.CheckBoxFixedCylinder.Visible:=false;
      end;


      //AddBlockForm.labelpowerinfo.Caption:=FloatToStr(Laplas.body[Laplas.itek].arr_power[0])+' W';
      AddBlockForm.labelpowerinfo.Caption:=Trim(Laplas.body[Laplas.itek].arr_s_power[0]+' W');

      // Делать ли преобразование Цилиндра в Призму.
      AddBlockForm.CheckBoxCylinder2Prism.Checked:=bCylinder2Prism;
      AddBlockForm.CheckBoxFixedCylinder.Checked:=CylinderFixed;
      if (igeometry_type=1) then
      begin
          AddBlockForm.CheckBoxFixedCylinder.Visible:=true;
      end
      else
      begin
          AddBlockForm.CheckBoxFixedCylinder.Visible:=false;
      end;

      if (igeometry_type=0) then
      begin
         AddBlockForm.GBPolygonGeom.Visible:=false;
         AddBlockForm.GBsizeBlock.Visible:=true;
         // Prism
         AddBlockForm.LxS.Caption:='xS';
         AddBlockForm.LyS.Caption:='yS';
         AddBlockForm.LzS.Caption:='zS';
         AddBlockForm.LxE.Caption:='xE';
         AddBlockForm.LyE.Caption:='yE';
         AddBlockForm.LzE.Caption:='zE';
         AddBlockForm.LabelPlane.Visible:=false;
         AddBlockForm.ComboBoxPlane.Visible:=false;
         // координаты блока
         AddBlockForm.ExS.Text:=sxS;
         AddBlockForm.EyS.Text:=syS;
         AddBlockForm.EzS.Text:=szS;
         AddBlockForm.ExE.Text:=sxE;
         AddBlockForm.EyE.Text:=syE;
         AddBlockForm.EzE.Text:=szE;
      end;
      if (igeometry_type=1) then
      begin
         AddBlockForm.GBPolygonGeom.Visible:=false;
         AddBlockForm.GBsizeBlock.Visible:=true;
         // Cylinder
         AddBlockForm.LxS.Caption:='xC';
         AddBlockForm.LyS.Caption:='yC';
         AddBlockForm.LzS.Caption:='zC';
         AddBlockForm.LxE.Caption:='Height';
         AddBlockForm.LyE.Caption:='Radius';
         AddBlockForm.LzE.Caption:='Int radius';
         AddBlockForm.LabelPlane.Visible:=true;
         AddBlockForm.ComboBoxPlane.Visible:=true;
         AddBlockForm.ComboBoxPlane.ItemIndex:=iPlane-1; // 1 - XY

         // координаты блока
         AddBlockForm.ExS.Text:=sxC;
         AddBlockForm.EyS.Text:=syC;
         AddBlockForm.EzS.Text:=szC;
         AddBlockForm.ExE.Text:=sHcyl;
         AddBlockForm.EyE.Text:=sR_out_cyl;
         AddBlockForm.EzE.Text:=sR_in_cyl;
      end;
      if (igeometry_type=2) then
      begin
         AddBlockForm.LabelPlane.Visible:=true;
         AddBlockForm.ComboBoxPlane.Visible:=true;
         AddBlockForm.ComboBoxPlane.ItemIndex:=Laplas.body[Laplas.itek].iPlane_obj2-1;

         AddBlockForm.GBPolygonGeom.Visible:=true;
         AddBlockForm.GBsizeBlock.Visible:=false;

         AddBlockForm.ListBoxvert.Items.Clear;
         for i := 1 to Laplas.body[Laplas.itek].nsizei do
         begin
            AddBlockForm.ListBoxvert.Items.Add('vert '+IntToStr(i));
         end;
         AddBlockForm.ListBoxvert.ItemIndex:=0;
         if (AddBlockForm.ListBoxvert.ItemIndex<Laplas.body[Laplas.itek].nsizei) then
         begin
            AddBlockForm.EditHeight.Text:=FloatToStr(Laplas.body[Laplas.itek].hi[AddBlockForm.ListBoxvert.ItemIndex]);
            AddBlockForm.Editx.Text:=FloatToStr(Laplas.body[Laplas.itek].xi[AddBlockForm.ListBoxvert.ItemIndex]);
            AddBlockForm.Edity.Text:=FloatToStr(Laplas.body[Laplas.itek].yi[AddBlockForm.ListBoxvert.ItemIndex]);
            AddBlockForm.Editz.Text:=FloatToStr(Laplas.body[Laplas.itek].zi[AddBlockForm.ListBoxvert.ItemIndex]);
         end;

         AddBlockForm.Labelx.Caption:='x1';
         AddBlockForm.Labely.Caption:='y1';
         AddBlockForm.Labelz.Caption:='z1';

      end;

      if (igeometry_type=2) then
      begin
        // Polygon
        if (ComboBoxlength.ItemIndex=1) then
        begin
           AddBlockForm.Labeldim1.Caption:='mm';
           AddBlockForm.Labeldimx.Caption:='mm';
           AddBlockForm.Labeldimy.Caption:='mm';
           AddBlockForm.Labeldimz.Caption:='mm';
        end;
        if (ComboBoxlength.ItemIndex=0) then
        begin
           AddBlockForm.Labeldim1.Caption:='m';
           AddBlockForm.Labeldimx.Caption:='m';
           AddBlockForm.Labeldimy.Caption:='m';
           AddBlockForm.Labeldimz.Caption:='m';
        end;
        if (ComboBoxlength.ItemIndex=2) then
        begin
           AddBlockForm.Labeldim1.Caption:='um';
           AddBlockForm.Labeldimx.Caption:='um';
           AddBlockForm.Labeldimy.Caption:='um';
           AddBlockForm.Labeldimz.Caption:='um';
        end;
      end;

       if ((igeometry_type=0)or(igeometry_type=1)) then
       begin
          if (ComboBoxlength.ItemIndex=1) then
           begin
             AddBlockForm.Label1.Caption:='mm';
             AddBlockForm.Label2.Caption:='mm';
             AddBlockForm.Label3.Caption:='mm';
             AddBlockForm.Label4.Caption:='mm';
             AddBlockForm.Label5.Caption:='mm';
             AddBlockForm.Label6.Caption:='mm';
           end;
           if (ComboBoxlength.ItemIndex=0) then
           begin
              AddBlockForm.Label1.Caption:='m';
              AddBlockForm.Label2.Caption:='m';
              AddBlockForm.Label3.Caption:='m';
              AddBlockForm.Label4.Caption:='m';
              AddBlockForm.Label5.Caption:='m';
              AddBlockForm.Label6.Caption:='m';
          end;
          if (ComboBoxlength.ItemIndex=2) then
          begin
             AddBlockForm.Label1.Caption:='um';
             AddBlockForm.Label2.Caption:='um';
             AddBlockForm.Label3.Caption:='um';
             AddBlockForm.Label4.Caption:='um';
             AddBlockForm.Label5.Caption:='um';
             AddBlockForm.Label6.Caption:='um';
          end;
      end;

      AddBlockForm.scrlbrtrans1.Position:=AddBlockForm.scrlbrtrans1.Min + round((1.0-transparency)*(AddBlockForm.scrlbrtrans1.Max-AddBlockForm.scrlbrtrans1.Min));
      AddBlockForm.lbltransparencyvalue.Caption:=FloatToStr(1.0*(AddBlockForm.scrlbrtrans1.Position-AddBlockForm.scrlbrtrans1.Min)/(AddBlockForm.scrlbrtrans1.Max-AddBlockForm.scrlbrtrans1.Min));
      AddBlockForm.dlgColorcube.Color:=dcol;

      AddBlockForm.Ename.Text:=name;
      AddBlockForm.RadioGroupType.ItemIndex:=itype-1;
      AddBlockForm.CBselectAction.ItemIndex:=0; // Edit Current Material
      if (Laplas.workmat[imatid].blibmat=0) then
      begin
         AddBlockForm.RGSelect.ItemIndex:=1; // материал определяемый пользователем
      end
       else AddBlockForm.RGSelect.ItemIndex:=0; // библиотечный материал
      case itype of
        1 : begin
               // SOLID
               AddBlockForm.GroupBoxPropBl.Visible:=true; // Форма со свойствами видна
               AddBlockForm.LMN.Caption:=workmat[imatid].namemat;
            end;
        2 : begin
              // HOLLOW
               AddBlockForm.GroupBoxPropBl.Visible:=false; // форма со свойствами невидна
            end;
        3 : begin
               // FLUID
               AddBlockForm.GroupBoxPropBl.Visible:=true; // Форма со свойствами видна
               AddBlockForm.LMN.Caption:=workmat[imatid].namemat;
            end;
      end;

   end;
end;  // initializeaddblockform

// инициализация формы редактирования источника тепла
procedure TLaplas.Initializeaddsourceform;
const
    epsilon = 1e-20; // для определения вещественного нуля
var
  i : Integer; // счётчик.
begin
   with source[itek] do
   begin
      AddSourceForm.Epower.Text:=spower; // мощность параметризованная пользователем

      case itempdep of
         0 : begin
                // константа
                AddSourceForm.Ptempdefloc.Visible:=false;
                AddSourceForm.Label1.Caption:='power';
                AddSourceForm.LW.Caption:='W';
                AddSourceForm.RGpowertype.ItemIndex:=0; // const
             end;
         1 : begin
                // задана таблично.
                AddSourceForm.Ptempdefloc.Visible:=true;
                AddSourceForm.Label1.Caption:='mult power';
                AddSourceForm.LW.Caption:='';
                AddSourceForm.CBtableid.Clear;
                for i:=0 to iltdp-1 do
                begin
                     AddSourceForm.CBtableid.Items.Add(IntToStr(i));
                end;
                AddSourceForm.CBtableid.ItemIndex:=id_table;
                AddSourceForm.EOperoffsetdrain.Text:=soperatingoffsetdrain;
                AddSourceForm.RGpowertype.ItemIndex:=1; // temperature depend
             end;
      end;

      AddSourceForm.RadioGroupPlane.ItemIndex:=iPlane-1;
      AddSourceForm.Ename.Text:=name;

      // координаты источника тепла :
      AddSourceForm.ExS.Text:=sxS;
      AddSourceForm.EyS.Text:=syS;
      AddSourceForm.EzS.Text:=szS;
      AddSourceForm.ExE.Text:=sxE;
      AddSourceForm.EyE.Text:=syE;
      AddSourceForm.EzE.Text:=szE;
   end;
end;

// инициализация формы редактированния стенки
procedure TLaplas.Initializeaddwallform;
 const
    epsilon = 1e-20; // для определения вещественного нуля
begin
   with wall[itek] do
   begin
      AddWallForm.RadioGroupBonConTemp.ItemIndex:=family-1;
      AddWallForm.ComboBoxDeformationBoundaryConditon.ItemIndex:=ithermal_stress_boundary_condition;
      if (ithermal_stress_boundary_condition<8) then
      begin
          AddWallForm.EditForce.Visible:=false;
          AddWallForm.LabelForce.Visible:=false;
      end
       else
      begin
          AddWallForm.EditForce.Visible:=true;
          AddWallForm.LabelForce.Visible:=true;
          if (ithermal_stress_boundary_condition=8) then
          begin
             AddWallForm.EditForce.Text:=FloatToStr(xForce);
          end;
          if (ithermal_stress_boundary_condition=9) then
          begin
             AddWallForm.EditForce.Text:=FloatToStr(yForce);
          end;
          if (ithermal_stress_boundary_condition=10) then
          begin
             AddWallForm.EditForce.Text:=FloatToStr(zForce);
          end;
      end;
      if (family=1) then
      begin
         // условие Дирихле
         AddWallForm.PaneltemperatureBC.Visible:=true;
         AddWallForm.Etemp.Text:=FloatToStr(Tamb);
         AddWallForm.EditViewFactor.Visible:=false;
         AddWallForm.Label13.Visible:=false;
      end
       else if (family=4) then
      begin
         // Стефан-Больцман
         AddWallForm.PaneltemperatureBC.Visible:=true;
         AddWallForm.Etemp.Text:=FloatToStr(Tamb);
         AddWallForm.EditViewFactor.Text:=FloatToStr(ViewFactor);
         AddWallForm.Panelemissivity.Visible:=true;
         //AddWallForm.Editemissivity.Text:=FloatToStr(emissivity);
         AddWallForm.Editemissivity.Text:=semissivity;
         AddWallForm.Label12.Caption:='emissivity';
         AddWallForm.EditViewFactor.Visible:=true;
         AddWallForm.Label13.Visible:=true;
      end
       else if (family=3) then
      begin
         // Ньютон-Рихман.
         AddWallForm.PaneltemperatureBC.Visible:=true;
         AddWallForm.Etemp.Text:=FloatToStr(Tamb);
         AddWallForm.Panelemissivity.Visible:=true;
         //AddWallForm.Editemissivity.Text:=FloatToStr(heat_transfer_coefficient);
         AddWallForm.Editemissivity.Text:=sheat_transfer_coefficient;
         AddWallForm.Label12.Caption:='heat transfer coeff';
         AddWallForm.EditViewFactor.Visible:=false;
         AddWallForm.Label13.Visible:=false;
      end
       else
      begin
         // однородное условие Неймана
         AddWallForm.PaneltemperatureBC.Visible:=false;
         AddWallForm.EditViewFactor.Visible:=false;
         AddWallForm.Label13.Visible:=false;
      end;
      AddWallForm.RadioGroupPlane.ItemIndex:=iPlane-1;
      AddWallForm.Ename.Text:=Trim(name);

      // координаты твёрдой стенки.
      AddWallForm.ExS.Text:=sxS;
      AddWallForm.EyS.Text:=syS;
      AddWallForm.EzS.Text:=szS;
      AddWallForm.ExE.Text:=sxE;
      AddWallForm.EyE.Text:=syE;
      AddWallForm.EzE.Text:=szE;

      if (ComboBoxlength.ItemIndex=1) then
      begin
         AddWallForm.Label6.Caption:='mm';
         AddWallForm.Label7.Caption:='mm';
         AddWallForm.Label8.Caption:='mm';
         AddWallForm.Label9.Caption:='mm';
         AddWallForm.Label10.Caption:='mm';
         AddWallForm.Label11.Caption:='mm';
      end;
      if (ComboBoxlength.ItemIndex=0) then
      begin
         AddWallForm.Label6.Caption:='m';
         AddWallForm.Label7.Caption:='m';
         AddWallForm.Label8.Caption:='m';
         AddWallForm.Label9.Caption:='m';
         AddWallForm.Label10.Caption:='m';
         AddWallForm.Label11.Caption:='m';
      end;
      if (ComboBoxlength.ItemIndex=2) then
      begin
         AddWallForm.Label6.Caption:='um';
         AddWallForm.Label7.Caption:='um';
         AddWallForm.Label8.Caption:='um';
         AddWallForm.Label9.Caption:='um';
         AddWallForm.Label10.Caption:='um';
         AddWallForm.Label11.Caption:='um';
      end;

      if (cabinet_depend>0) then
      begin
         // Геометрические размеры стенки определены
         // кабинетом и автоматическим образом перестраиваются при
         // изменении размеров кабинета.
         AddWallForm.GroupBoxSize.Visible:=false;
         AddWallForm.RadioGroupPlane.Visible:=false;
      end
      else
      begin
         AddWallForm.GroupBoxSize.Visible:=true;
         AddWallForm.RadioGroupPlane.Visible:=true;
      end;

      if (bpressure) then
      begin
         // задано давление
         AddWallForm.GroupBoxpressure.Visible:=true;
         AddWallForm.GroupBoxvelcomp.Visible:=false;
         AddWallForm.RadioGroupflowtype.ItemIndex:=1;
      end;
      if ((bsymmetry)or(bopening)) then
      begin
         // граница симметрии
         AddWallForm.GroupBoxpressure.Visible:=false;
         AddWallForm.GroupBoxvelcomp.Visible:=false;
         if (bsymmetry) then
         begin
            AddWallForm.RadioGroupflowtype.ItemIndex:=2;
         end;
         if (bopening) then
         begin
            AddWallForm.RadioGroupflowtype.ItemIndex:=3;
         end;
      end;
      if (not(bpressure) and not(bsymmetry) and not(bopening)) then
      begin
         // задана нормальная компонента скорости
         AddWallForm.GroupBoxpressure.Visible:=false;
         AddWallForm.GroupBoxvelcomp.Visible:=true;
         AddWallForm.RadioGroupflowtype.ItemIndex:=0;
      end;
      AddWallForm.EditVx.Text:=FloatToStr(Vx);
      AddWallForm.EditVy.Text:=FloatToStr(Vy);
      AddWallForm.EditVz.Text:=FloatToStr(Vz);
      AddWallForm.Editpress.Text:=FloatToStr(P);

   end;
end;


// добавляет блок
procedure TLaplas.SPBAddBlockClick(Sender: TObject);
var
   hx,hy,hz : real;
   NewNode : TTreeNode;
   sname : String;
   i : Integer;
   bfound, bOk : Boolean;
   isort : Integer;
   //jsort : Integer; // текущий номер блока или источника при записи
   // body_change : TBody; // для сортировки блоков.

procedure FixHeap(root : Integer; m : TBody; bound : Integer; iadd : Integer);
var
   vacant, largerChild : Integer;
   lCadd, lCadd1 : Integer;
begin
   vacant:=root;
   while (2*vacant<=bound) do
   begin
      largerChild:=2*vacant;
      lCadd:=largerChild+iadd;
      lCadd1:=lCadd+1;
      if ((largerChild<bound)and(body[lCadd1].priority>body[lCadd].priority)) then
      begin
         inc(largerChild);
      end;
      lCadd:=largerChild+iadd;
      if (m.priority>body[lCadd].priority) then
      begin
        break;
      end
      else
      begin
         body[vacant+iadd]:=body[lCadd];
         vacant:=largerChild;
      end;
   end;
   body[vacant+iadd]:=m;
end;

// Пирамидальная сортировка.
procedure HeapSort(first,last : Integer);
var
   body_buf : TBody;
   i9 : Integer;
begin
   for i9 := ((last-first+1) div 2) downto 1 do
   begin
      FixHeap(i9,body[i9+first-1],last-first+1,first-1);
   end;
   for i9 := last-first+1 downto 2 do
     begin
       body_buf:=body[first];
       FixHeap(1,body[i9+first-1],i9-1,first-1);
       body[i9+first-1]:=body_buf;
     end;
end;

begin
   inc(lb); itek:=lb-1;
   SetLength(body,lb); // выделение памяти под дополнительный блок
   hx:=abs(body[0].xE-body[0].xS)/5.0;
   hy:=abs(body[0].yE-body[0].yS)/5.0;
   hz:=abs(body[0].zE-body[0].zS)/5.0;
   body[itek].priority:=priority_id;
   priority_id:=priority_id+5;
   body[itek].igeometry_type:=0; // 0 - Prism
   body[itek].xS:=body[0].xS+2*hx;  body[itek].xE:=body[0].xE-2*hx;  // числовые значения
   body[itek].yS:=body[0].yS+2*hy;  body[itek].yE:=body[0].yE-2*hy;  // координат
   body[itek].zS:=body[0].zS+2*hz;  body[itek].zE:=body[0].zE-2*hz;
   body[itek].sxS:=FormatFloat('0.000',body[0].xS+2*hx);  body[itek].sxE:=FormatFloat('0.000',body[0].xE-2*hx);  // параметризованные
   body[itek].syS:=FormatFloat('0.000',body[0].yS+2*hy);  body[itek].syE:=FormatFloat('0.000',body[0].yE-2*hy);  // значения
   body[itek].szS:=FormatFloat('0.000',body[0].zS+2*hz);  body[itek].szE:=FormatFloat('0.000',body[0].zE-2*hz);  // координат
   body[itek].iPlane:=1; // 1 - XY
   body[itek].xC:=0.5*(body[0].xS+body[0].xE);
   body[itek].yC:=0.5*(body[0].yS+body[0].yE);
   body[itek].zC:=body[0].zS+2*hz;
   body[itek].Hcyl:=abs(body[0].zE-body[0].zS)-4*hz;
   body[itek].R_out_cyl:=0.5*(0.5*(abs(body[0].xE-body[0].xS)-4*hx)+0.5*(abs(body[0].yE-body[0].yS)-4*hy));
   body[itek].R_in_cyl:=0.0;
   body[itek].sxC:=FormatFloat('0.000',body[itek].xC);
   body[itek].syC:=FormatFloat('0.000',body[itek].yC);
   body[itek].szC:=FormatFloat('0.000',body[itek].zC);
   body[itek].sHcyl:=FormatFloat('0.000',body[itek].Hcyl);
   body[itek].sR_out_cyl:=FormatFloat('0.000',body[itek].R_out_cyl);
   body[itek].sR_in_cyl:=FormatFloat('0.000',body[itek].R_in_cyl);
   // По умолчанию мы разрешаем преобразовывать цилиндр в призму если этого
   // хочет пользователь.
   body[itek].bCylinder2Prism:=true;
   // 23_02_2017
   body[itek].R_out_cyl2:=-1.0;
   body[itek].R_in_cyl2:=-1.0;
   body[itek].angle_start:=0.0;
   body[itek].angle_end:=0.0;
   body[itek].sR_out_cyl2:=FormatFloat('0.000',body[itek].R_out_cyl2);
   body[itek].sR_in_cyl2:=FormatFloat('0.000',body[itek].R_in_cyl2);
   body[itek].sangle_start:=FormatFloat('0.000',body[itek].angle_start);
   body[itek].sangle_end:=FormatFloat('0.000',body[itek].angle_end);
   // 12_08_2017 Polygon
   body[itek].nsizei:=3;
   SetLength(body[itek].xi,body[itek].nsizei);
   SetLength(body[itek].yi,body[itek].nsizei);
   SetLength(body[itek].zi,body[itek].nsizei);
   SetLength(body[itek].hi,body[itek].nsizei);
   body[itek].iPlane_obj2:=3; // 3- YZ
   body[itek].hi[0]:=0.2*abs(body[0].xE-body[0].xS);
   body[itek].xi[0]:=0.5*(body[0].xS+body[0].xE)-0.1*abs(body[0].xE-body[0].xS);
   body[itek].yi[0]:=0.5*(body[0].yS+body[0].yE)-0.141421*abs(body[0].yE-body[0].yS);
   body[itek].zi[0]:=0.5*(body[0].zS+body[0].zE)-0.141421*abs(body[0].zE-body[0].zS);
   body[itek].hi[1]:=0.2*abs(body[0].xE-body[0].xS);
   body[itek].xi[1]:=0.5*(body[0].xS+body[0].xE)-0.1*abs(body[0].xE-body[0].xS);
   body[itek].yi[1]:=0.5*(body[0].yS+body[0].yE)+0.141421*abs(body[0].yE-body[0].yS);
   body[itek].zi[1]:=0.5*(body[0].zS+body[0].zE)-0.141421*abs(body[0].zE-body[0].zS);
   body[itek].hi[2]:=0.2*abs(body[0].xE-body[0].xS);
   body[itek].xi[2]:=0.5*(body[0].xS+body[0].xE)-0.1*abs(body[0].xE-body[0].xS);
   body[itek].yi[2]:=0.5*(body[0].yS+body[0].yE)-0.141421*abs(body[0].yE-body[0].yS);
   body[itek].zi[2]:=0.5*(body[0].zS+body[0].zE)+0.141421*abs(body[0].zE-body[0].zS);


   body[itek].itype:=1; // SOLID
   inc(icb);
   body[itek].name:='block'+IntToStr(icb);
   body[itek].CylinderFixed:=false; // боковые стенки фиксируются ?
   body[itek].imatid:=1; // Дюраль Аллюминий.
   //body[itek].power:=0.0; // нет тепловыделения
   //body[itek].spower:='0.0'; // нет тепловыделения
   body[itek].n_power:=1;
   SetLength(body[itek].arr_power,body[itek].n_power);
   SetLength(body[itek].temp_power,body[itek].n_power);
   SetLength(body[itek].arr_s_power,body[itek].n_power);
   body[itek].temp_power[0]:=20.0;
   body[itek].arr_power[0]:=0.0; //  нет тепловыделения
   body[itek].arr_s_power[0]:='0.0'; // нет тепловыделения

   body[itek].ipower_time_depend:=0; // тепловыделение не зависит от времени.
   // emissivity individual sides.
   body[itek].semissW:='$emiss';
   body[itek].semissE:='$emiss';
   body[itek].semissS:='$emiss';
   body[itek].semissN:='$emiss';
   body[itek].semissB:='$emiss';
   body[itek].semissT:='$emiss';
   bOk:=true;
   body[itek].emissW:=FormVariables.my_real_convert(body[itek].semissW,bOk);
   body[itek].emissE:=FormVariables.my_real_convert(body[itek].semissE,bOk);
   body[itek].emissS:=FormVariables.my_real_convert(body[itek].semissS,bOk);
   body[itek].emissN:=FormVariables.my_real_convert(body[itek].semissN,bOk);
   body[itek].emissB:=FormVariables.my_real_convert(body[itek].semissB,bOk);
   body[itek].emissT:=FormVariables.my_real_convert(body[itek].semissT,bOk);
   // Не учитывать теплообмен излучением внутри вновь созданного блока.
   body[itek].binternalRadiation:=0;
   body[itek].iunion:=0;
   body[itek].bvisible:=true;
   body[itek].redcolor:=0.0; //0.502;
   body[itek].greencolor:=0.0;//0.502;
   body[itek].bluecolor:=0.0;//0.502;
   body[itek].transparency:=1.0;  // абсолютно непрозрачный.
   body[itek].dcol:=8421504;
   body[itek].BodyLineWidth:=1;

   if (MainTreeView.Selected=nil) then
   begin
      MainTreeView.Select(MainTreeView.Items[0]);
   end
    else
   begin
       sname:=MainTreeView.Selected.Text; // имя выделенного элемента.
       bfound:=false;
       for i:=0 to lb-2 do
       begin
          if ((length(body[i].name)=length(sname)) and (Pos(body[i].name,sname)=1)) then
          begin
             bfound:=true;
             body[itek].iunion:=body[i].iunion;
             break;
          end;
       end;
       if (not(bfound)) then
       begin
          for i:=0 to ls-1 do
          begin
             if ((length(source[i].name)=length(sname)) and (Pos(source[i].name,sname)=1)) then
             begin
                bfound:=true;
                body[itek].iunion:=source[i].iunion;
                break;
             end;
          end;
       end;
       if (not(bfound)) then
       begin
          for i:=0 to lw-1 do
          begin
             if ((length(wall[i].name)=length(sname)) and (Pos(wall[i].name,sname)=1)) then
             begin
                bfound:=true;
                body[itek].iunion:=wall[i].iunion;
                break;
             end;
          end;
       end;
       // Если bfound=false то выделен асемблес а значит iunion по умолчанию 0.
   end;

   NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,body[itek].name);
   NewNode.ImageIndex:=1;  // номер картинки
   NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен
   ReadyPaint;
   initializeaddblockform;
   AddBlockForm.ShowModal;
   MainTreeView.Items[MainTreeView.Items.Count-1].Text:=body[itek].name;

   // Сортировка блоков по приоритетам:
   // Сортировка блоков по возрастанию значения их priority.
   // 2 мая 2016.
   (*
    for isort:=2 to lb-1 do
   begin
	   for jsort:=lb-1 downto isort do
     begin
     		if (body[jsort-1].priority > body[jsort].priority) then
        begin
			     // swap
			     body_change:=body[jsort-1];
			     body[jsort-1]:=body[jsort];
			     body[jsort]:= body_change;
		    end;
	   end;
   end;
   *)
   HeapSort(1,lb-1);


   // Теперь блоки отсортированы по возратанию их приоритетов.
   // Переформировываем имена в дереве в соответстви с новым упорядочиванием.
   isort:=1;
   for i := 1 to MainTreeView.Items.Count-1 do
   begin
       if (MainTreeView.Items[i].ImageIndex=1) then
       begin
          MainTreeView.Items[i].Text:=body[isort].name;
          inc(isort);
       end;
   end;

   // подготовку обязательно после переформирования блоков т.к. могут появиться
   // новые hollow области а может и наоборот hollow область стала solid областью.
   CorrectHollowCabinet;
   ReadyPaint;
end;


// по нажатию на кнопку добавляется источник тепла
procedure TLaplas.DaddSourceClick(Sender: TObject);
var
   hx,hy : real;
   NewNode : TTreeNode;
   sname : String;
   i : Integer;
   bfound : Boolean;
begin
   inc(ls); itek:=ls-1;
   SetLength(source,ls); // выделение памяти под дополнительный источник
   hx:=abs(body[0].xE-body[0].xS)/5.0;
   hy:=abs(body[0].yE-body[0].yS)/5.0;
   source[itek].iPlane:=1;//XY
   source[itek].xS:=body[0].xS+2*hx;  source[itek].xE:=body[0].xE-2*hx; // числовые
   source[itek].yS:=body[0].yS+2*hy;  source[itek].yE:=body[0].yE-2*hy; // значения
   source[itek].zS:=0.5*(body[0].zS+body[0].zE); source[itek].zE:=0.5*(body[0].zS+body[0].zE);  // координат
   source[itek].sxS:=FloatToStr(body[0].xS+2*hx);  source[itek].sxE:=FloatToStr(body[0].xE-2*hx);  // параметризованные
   source[itek].syS:=FloatToStr(body[0].yS+2*hy);  source[itek].syE:=FloatToStr(body[0].yE-2*hy);  // значения
   source[itek].szS:=FloatToStr(0.5*(body[0].zS+body[0].zE)); source[itek].szE:=FloatToStr(0.5*(body[0].zS+body[0].zE)); // координат
   inc(ics);
   source[itek].name:='source'+IntToStr(ics); // задаёт уникальное имя объекта
   source[itek].itempdep:=0; // мощность константа
   source[itek].id_table:=0;
   source[itek].operatingoffsetdrain:=28.0; // Vg  напряжение на сьтоке в вольтах.
   source[itek].soperatingoffsetdrain:='28.0'; // Vg text
   source[itek].Power:=0.0; // тепло не выделяется
   source[itek].spower:='0.0'; // тепло не выделяется
   // в гидродинамическом плане это твёрдая стенка
   source[itek].Vx:=0.0;
   source[itek].Vy:=0.0;
   source[itek].Vz:=0.0;
   source[itek].P:=0.0;
   source[itek].bpressure:=false;
   source[itek].bsymmetry:=false;
   source[itek].bopening:=false;
   source[itek].iunion:=0;
   source[itek].bvisible:=true;
   source[itek].cabinet_depend:=0; // пользовательские размеры.

   if (MainTreeView.Selected=nil) then
   begin
      MainTreeView.Select(MainTreeView.Items[0]);
   end
    else
   begin
       sname:=MainTreeView.Selected.Text; // имя выделенного элемента.
       bfound:=false;
       for i:=0 to lb-1 do
       begin
          if ((length(body[i].name)=length(sname)) and (Pos(body[i].name,sname)=1)) then
          begin
             bfound:=true;
             source[itek].iunion:=body[i].iunion;
             break;
          end;
       end;
       if (not(bfound)) then
       begin
          for i:=0 to ls-2 do
          begin
             if ((length(source[i].name)=length(sname)) and (Pos(source[i].name,sname)=1)) then
             begin
                bfound:=true;
                source[itek].iunion:=source[i].iunion;
                break;
             end;
          end;
       end;
       if (not(bfound)) then
       begin
          for i:=0 to lw-1 do
          begin
             if ((length(wall[i].name)=length(sname)) and (Pos(wall[i].name,sname)=1)) then
             begin
                bfound:=true;
                source[itek].iunion:=wall[i].iunion;
                break;
             end;
          end;
       end;
       // Если bfound=false то выделен асемблес а значит iunion по умолчанию 0.
   end;

   NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,source[itek].name);
   NewNode.ImageIndex:=2; // загружает картинку источника тепла
   NewNode.SelectedIndex:=2; // номер картинки когда элемент выделен
   ReadyPaint;
   Initializeaddsourceform; // инициализирует форму перед запуском
   AddSourceForm.ShowModal;
   MainTreeView.Items[MainTreeView.Items.Count-1].Text:=source[itek].name;
   CorrectHollowCabinet;
   ReadyPaint;
end;


// устанавливаем плоскость XY neg_Z
procedure TLaplas.SpeedButtonplaneneg_ZClick(Sender: TObject);
begin
   // Ось Ox направо, ось Oy строго вверх.
   //Alf:=-1.57;
   //Bet:=1.57;
   // 22 апреля 2015
   // Alf - вращение вокруг оси Oz.
   // Bet - вращение вокруг вектора лежащего в плоскости XOY и направленного под 45 градусов к оси абсцисс.
   // Ориентация XOY.
   Alf:=0.0;  //X
   Bet:=0.0;  // Y
   Gam:=0.0;  // Z
   cosAlf:=cos(Alf);
   cosBet:=cos(Bet);
   sinAlf:=sin(Alf);
   sinBet:=sin(Bet);
end;

// сохраняет bmp картинку в файл.
procedure TLaplas.CreateImagefile1Click(Sender: TObject);
var
  filename : string; // имя записываемого файла
  //Bitmap: TBitmap;
  //Source: TRect;
  //Dest: TRect;
  //i : Integer;
  //r : Real;
  dwloc : HWND;
  dcloc : HDC;
  bmp : TBitmap;
  ileft, itop : Integer;

begin
   // записывает файл картинки с геометрией задачи

   filename:='';
   if not InputQuery('Input name file', 'Please, enter name writing file',filename)
   then exit;

   Render; // обязательная перерисовка

   // Данный код устарел.
   // Он был пригоден для реализации графики без использования OpenGL.
   // Поэтому 27 февраля 2015 он будет заменён на код учитывающий то,
   // что графика реализована на OpenGL.

   (*
   Bitmap := TBitmap.Create;
  try
    Bitmap.Width := pnlPaint.Width;
    Bitmap.Height:= pnlPaint.Height;
    Dest := Rect(0, 0, Bitmap.Width, Bitmap.Height);
    Source := Rect(MainPanel.Left+pnlPaint.Left, pnlPaint.Top, MainPanel.Left+pnlPaint.Left+pnlPaint.Width, pnlPaint.Top+pnlPaint.Height);

    Bitmap.Canvas.CopyRect(Dest, Canvas, Source);
    Bitmap.SaveToFile(filename+'.bmp');
  finally
    Bitmap.Free;
  end;
  *)

    Sleep(500);
   // Делает скриншот всей экранной формы.
   bmp:=TBitmap.Create;
   bmp.Width:=Laplas.Width;
   bmp.Height:=Laplas.Height;
   dwloc:=GetDesktopWindow;
   dcloc:=GetDC(dwloc);
   ileft:=Laplas.Left;
   itop:=Laplas.Top;
   BitBlt(bmp.Canvas.Handle,0,0,bmp.Width,bmp.Height,dcloc,ileft,itop,SRCCOPY);
   ReleaseDC(dwloc,dcloc);
   bmp.SaveToFile(filename+'.bmp');

   // SwapBuffer делать не надо тут.


end;

// записывает геометрию в текстовый файл.
procedure TLaplas.write1Click(Sender: TObject);


procedure FixHeap(root : Integer; m : TBody; bound : Integer; iadd : Integer);
var
   vacant, largerChild : Integer;
   lCadd, lCadd1 : Integer;
begin
   vacant:=root;
   while (2*vacant<=bound) do
   begin
      largerChild:=2*vacant;
      lCadd:=largerChild+iadd;
      lCadd1:=lCadd+1;
      if ((largerChild<bound)and(body[lCadd1].priority>body[lCadd].priority)) then
      begin
         inc(largerChild);
      end;
      lCadd:=largerChild+iadd;
      if (m.priority>body[lCadd].priority) then
      begin
        break;
      end
      else
      begin
         body[vacant+iadd]:=body[lCadd];
         vacant:=largerChild;
      end;
   end;
   body[vacant+iadd]:=m;
end;

// Пирамидальная сортировка.
procedure HeapSort(first,last : Integer);
var
   body_buf : TBody;
   i9 : Integer;
begin
   for i9 := ((last-first+1) div 2) downto 1 do
   begin
      FixHeap(i9,body[i9+first-1],last-first+1,first-1);
   end;
   for i9 := last-first+1 downto 2 do
     begin
       body_buf:=body[first];
       FixHeap(1,body[i9+first-1],i9-1,first-1);
       body[i9+first-1]:=body_buf;
     end;
end;

procedure OldWriteFile();
var
   filename : string; // имя записываемого файла
   f : TStringList; // переменная типа объект TStringList
   s : String; // текущая рабочая строка
   i, i_4, j, i_2, i_3 : Integer;
   bOk : Boolean;
   // isort, jsort : Integer; // текущий номер блока или источника при записи
   //body_change : TBody; // для сортировки блоков.
begin
    // записывает файл с геометрией задачи
   filename:='';
   if not InputQuery('Input name file', 'Please, enter name writing file',filename)
   then exit;

   f:=TStringList.Create();

   s:='m='+FloatToStr(m);
   s:=s+' :'+FloatToStr(gx)+' :'+FloatToStr(gy)+' :'+FloatToStr(gz)+' :';
   s:=s+IntToStr(inx)+' :'+IntToStr(iny)+' :'+IntToStr(inz)+' :';
   s:=s+FloatToStr(operatingtemperature)+' :'+FloatToStr(etalon_max_size_ratio)+' :';
   s:=s+FloatToStr(etalon_max_size_ratio2)+' :';
   // Snap to grid
   s:=s+IntToStr(MeshForm.ComboBoxSnapTo.ItemIndex)+' :';
   s:=s+IntToStr(FormSetting.ComboBoxSolverSetting.ItemIndex)+' :'+FloatToStr(filmcoefficient)+' :';
   s:=s+IntToStr(adiabatic_vs_heat_transfer_coeff)+' :';
   s:=s+IntToStr(glSTL.id_law)+' :'+FloatToStr(glSTL.Factor_a_for_Linear)+' :';
   s:=s+FloatToStr(glSTL.tau)+' :'+FloatToStr(glSTL.iQ)+' :';
   s:=s+FloatToStr(glSTL.m1)+' :'+FloatToStr(glSTL.tau1)+' :';
   s:=s+FloatToStr(glSTL.tau2)+' :'+FloatToStr(glSTL.tau_pause)+' :';
   s:=s+FloatToStr(glSTL.off_multiplyer)+' :';
   s:=s+IntToStr(glSTL.n)+' :'+FloatToStr(glSTL.T)+' :';
   s:=s+FloatToStr(glSTL.on_time_double_linear)+' :';
   f.Add(s); // масштабирующий коэффициент
   // единицы длины:
   s:='length=';
   s:=s+IntToStr(ComboBoxlength.ItemIndex); // запоминаем выбранные единицы длины
   f.Add(s); // единицы длины

   // Список таблиц в которых прописана зависимость
   // рассеиваемой мощности  от максимальной температуры и смещения стока.
   s:='ltdp=';
   s:=s+IntToStr(iltdp); // количество различных таблиц
   f.Add(s);
   for i:=0 to iltdp-1 do
   begin
      f.Add(listtablename[i]); // имя файла с таблицей
   end;

   // параметры объединений :
   s:='lu='+IntToStr(lu);
   f.Add(s);
   for i:=0 to lu-1 do
   begin
       // имя объединения, идентификатор объединения.
       s:=myassembles[i].name+' :'+IntToStr(myassembles[i].identifire)+' :';
       s:=s+IntToStr(myassembles[i].iunionparent)+' :';
       if (myassembles[i].bmesh_assembles_separately) then
       begin
          s:=s+'1 :';  // блочно структурированная сетка
       end
        else
       begin
          s:=s+'0 :'; // не бочно структурированная сетка
       end;
       s:=s+myassembles[i].sxmin+' :';
       s:=s+myassembles[i].sxmax+' :';
       s:=s+myassembles[i].symin+' :';
       s:=s+myassembles[i].symax+' :';
       s:=s+myassembles[i].szmin+' :';
       s:=s+myassembles[i].szmax+' :';
       s:=s+IntToStr(myassembles[i].inxloc)+' :';
       s:=s+IntToStr(myassembles[i].inyloc)+' :';
       s:=s+IntToStr(myassembles[i].inzloc)+' :';
       f.Add(s);
   end;

   // количество рабочих переменных :
   s:='ivarmax='+IntToStr(ivar);
   f.Add(s);
   for i:=0 to (ivar-1) do
   begin
      // каждая переменная записывается в отдельной строке.
      s:=parametric[i].svar+' :'+parametric[i].sval+' :';
      f.Add(s);
   end;

   // количество рабочих материалов: (solid and fluid).
   s:='lmatmax='+IntToStr(lmatmax);
   f.Add(s);
   for i:=0 to (lmatmax-1) do
   begin
      s:=workmat[i].namemat+' :'; // имя материала
      // плотность, теплоёмкость и теплопроводность.
      s:=s+FloatToStr(workmat[i].rho)+ ' :'; // плотность
      //s:=s+FloatToStr(workmat[i].cp)+ ' :'; // теплоёмкость
      s:=s+IntToStr(workmat[i].n_cp)+ ' :';
      for i_4 := 0 to (workmat[i].n_cp-1) do
      begin
         s:=s+FloatToStr(workmat[i].temp_cp[i_4])+ ' :'+FloatToStr(workmat[i].arr_cp[i_4])+ ' :';
      end;
      //s:=s+FloatToStr(workmat[i].lambda)+ ' :'; // теплопроводность
      s:=s+IntToStr(workmat[i].n_lam)+ ' :';
      for i_4 := 0 to (workmat[i].n_lam-1) do
      begin
         s:=s+FloatToStr(workmat[i].temp_lam[i_4])+ ' :'+FloatToStr(workmat[i].arr_lam[i_4])+ ' :';
      end;
      // Ортотропность теплопроводности.
      s:=s+FloatToStr(workmat[i].mult_lam_x)+ ' :';
      s:=s+FloatToStr(workmat[i].mult_lam_y)+ ' :';
      s:=s+FloatToStr(workmat[i].mult_lam_z)+ ' :';

      // Thermal-Stress
      // Коэффициент линейного теплового расширения.
      s:=s+FloatToStr(workmat[i].mult_Linear_expansion_coefficient_x)+ ' :';
      s:=s+FloatToStr(workmat[i].mult_Linear_expansion_coefficient_y)+ ' :';
      s:=s+FloatToStr(workmat[i].mult_Linear_expansion_coefficient_z)+ ' :';
      // Модуль Юнга.
      s:=s+FloatToStr(workmat[i].mult_Young_Module_x)+ ' :';
      s:=s+FloatToStr(workmat[i].mult_Young_Module_y)+ ' :';
      s:=s+FloatToStr(workmat[i].mult_Young_Module_z)+ ' :';
       // Ортотропность коэффициента Пуассона.
      s:=s+FloatToStr(workmat[i].mult_Poisson_ratio_xy)+ ' :';
      s:=s+FloatToStr(workmat[i].mult_Poisson_ratio_xz)+ ' :';
      s:=s+FloatToStr(workmat[i].mult_Poisson_ratio_yz)+ ' :';
      s:=s+FloatToStr(workmat[i].mult_Poisson_ratio_yx)+ ' :';
      s:=s+FloatToStr(workmat[i].mult_Poisson_ratio_zx)+ ' :';
      s:=s+FloatToStr(workmat[i].mult_Poisson_ratio_zy)+ ' :';
      // Модуль сдвига
      if (workmat[i].bShearModuleActive) then
      begin
         s:=s+'1 :';  // Модуль сдвига задаётся пользователем.
      end
      else
      begin
         s:=s+'0 :';  // Модуль сдвига не задаётся пользователем.
      end;
      s:=s+FloatToStr(workmat[i].ShearModuleGxy)+ ' :';
      s:=s+FloatToStr(workmat[i].ShearModuleGyz)+ ' :';
      s:=s+FloatToStr(workmat[i].ShearModuleGxz)+ ' :';


      s:=s+IntToStr(workmat[i].n_Poisson_ratio)+ ' :';
      for i_4 := 0 to (workmat[i].n_Poisson_ratio-1) do
      begin
         s:=s+FloatToStr(workmat[i].temp_Poisson_ratio[i_4])+ ' :'+FloatToStr(workmat[i].arr_Poisson_ratio[i_4])+ ' :';
      end;
      s:=s+IntToStr(workmat[i].n_Young_Module)+ ' :';
      for i_4 := 0 to (workmat[i].n_Young_Module-1) do
      begin
         s:=s+FloatToStr(workmat[i].temp_Young_Module[i_4])+ ' :'+FloatToStr(workmat[i].arr_Young_Module[i_4])+ ' :';
      end;
      s:=s+IntToStr(workmat[i].n_Linear_expansion_coefficient)+ ' :';
      for i_4 := 0 to (workmat[i].n_Linear_expansion_coefficient-1) do
      begin
         s:=s+FloatToStr(workmat[i].temp_Linear_expansion_coefficient[i_4])+ ' :'+FloatToStr(workmat[i].arr_Linear_expansion_coefficient[i_4])+ ' :';
      end;
      // etc.
      s:=s+FloatToStr(workmat[i].mu)+ ' :'; // динамическая вязкость
      s:=s+FloatToStr(workmat[i].beta_t)+ ' :'; // коэффициент линейного температурного расширения
      s:=s+IntToStr(workmat[i].blibmat)+' :'; // является ли материал библиотечным ?
      s:=s+IntToStr(workmat[i].ilibident)+' :'; // идентификатор библиотечного материаала
      s:=s+IntToStr(workmat[i].bBoussinesq)+' :'; // использовать приближение Обербека-Буссинеска или нет.
      s:=s+IntToStr(workmat[i].ilawmu)+' :';  // номер закона для динамической вязкости
      s:=s+FloatToStr(workmat[i].mumin)+' :'; // ограничители
      s:=s+FloatToStr(workmat[i].mumax)+' :'; // динамической вязкости.
      s:=s+FloatToStr(workmat[i].Amu)+' :';   // параметры
      s:=s+FloatToStr(workmat[i].Bmu)+' :';   // модельных
      s:=s+FloatToStr(workmat[i].Cmu)+' :';   // зависимостей
      s:=s+FloatToStr(workmat[i].degreennmu)+' :'; // показатель степени
      f.Add(s);
   end;


   // запись размеров кабинета
   s:='cabinet=';
   with (body[0]) do
   begin
      s:=s+IntToStr(igeometry_type)+' :'; // 0 - Prism, 1 - Cylinder, 2 - Polygon.
      // Prism
      s:=s+sxS+' :';  // записываются
      s:=s+syS+' :';  // параметризованные
      s:=s+szS+' :';  // пользователем значения
      s:=s+sxE+' :';
      s:=s+syE+' :';
      s:=s+szE+' :';
      // Cylinder
      s:=s+IntToStr(iPlane)+' :'; // 1 - XY, 2 - XZ, 3 - YZ.
      s:=s+sxC+' :';  // записываются
      s:=s+syC+' :';  // параметризованные
      s:=s+szC+' :';  // пользователем значения
      s:=s+sHcyl+' :';
      s:=s+sR_out_cyl+' :';
      s:=s+sR_in_cyl+' :';
      // 18 января 2018.
      if (bCylinder2Prism) then
      begin
         // Разрешаем преобразовывать цилиндр в Призму.
         s:=s+'1 :';
      end
      else
      begin
         // Не разрешаем преобразовывать цилиндр в призму.
         s:=s+'0 :';
      end;
      // sector, conoid
      s:=s+sR_out_cyl2+' :';
      s:=s+sR_in_cyl2+' :';
      s:=s+sangle_start+' :';
      s:=s+sangle_end+' :';
      // Polygon
      s:=s+IntToStr(iPlane_obj2)+' :'; // 1 - XY, 2 - XZ, 3 - YZ.
      s:=s+IntToStr(nsizei)+' :';
      for i := 0 to nsizei-1 do
      begin
         s:=s+FloatToStr(hi[i])+' :';
         s:=s+FloatToStr(xi[i])+' :';
         s:=s+FloatToStr(yi[i])+' :';
         s:=s+FloatToStr(zi[i])+' :';
      end;

      // emissivity:
      bOk:=true;

      if (abs(FormVariables.my_real_convert(semissW,bOk))<1.0e-12) then
      begin
          // во избежании деления на ноль.
          body[0].emissW:=0.001;
          if (FormatSettings.DecimalSeparator=',') then
          begin
             body[0].semissW:='0,001';
          end;
          if (FormatSettings.DecimalSeparator='.') then
          begin
             body[0].semissW:='0.001';
         end;

      end;
      //s:=s+FloatToStr(emissW)+' :';
      s:=s+semissW+' :';
      if (abs(FormVariables.my_real_convert(semissE,bOk))<1.0e-12) then
      begin
          // во избежании деления на ноль.
          body[0].emissE:=0.001;
           if (FormatSettings.DecimalSeparator=',') then
          begin
             body[0].semissE:='0,001';
          end;
            if (FormatSettings.DecimalSeparator='.') then
          begin
              body[0].semissE:='0.001';
          end;

      end;
      //s:=s+FloatToStr(emissE)+' :';
      s:=s+semissE+' :';
      if (abs(FormVariables.my_real_convert(semissS,bOk))<1.0e-12) then
      begin
          // во избежании деления на ноль.
          body[0].emissS:=0.001;
           if (FormatSettings.DecimalSeparator=',') then
          begin
          body[0].semissS:='0,001';
          end;
            if (FormatSettings.DecimalSeparator='.') then
          begin
             body[0].semissS:='0.001';
          end;
      end;
      //s:=s+FloatToStr(emissS)+' :';
      s:=s+semissS+' :';
      if (abs(FormVariables.my_real_convert(semissN,bOk))<1.0e-12) then
      begin
          // во избежании деления на ноль.
          body[0].emissN:=0.001;
          if (FormatSettings.DecimalSeparator=',') then
          begin
             body[0].semissN:='0,001';
          end;
          if (FormatSettings.DecimalSeparator='.') then
          begin
             body[0].semissN:='0.001';
          end;

      end;
      //s:=s+FloatToStr(emissN)+' :';
      s:=s+semissN+' :';
      if (abs(FormVariables.my_real_convert(semissB,bOk))<1.0e-12) then
      begin
          // во избежании деления на ноль.
          body[0].emissB:=0.001;
             if (FormatSettings.DecimalSeparator=',') then
          begin
             body[0].semissB:='0,001';
          end;
             if (FormatSettings.DecimalSeparator='.') then
          begin
             body[0].semissB:='0.001';
          end;

      end;
      //s:=s+FloatToStr(emissB)+' :';
      s:=s+semissB+' :';
      if (abs(FormVariables.my_real_convert(semissT,bOk))<1.0e-12) then
      begin
          // во избежании деления на ноль.
          body[0].emissT:=0.001;
             if (FormatSettings.DecimalSeparator='.') then
          begin
             body[0].semissT:='0,001';
          end;
             if (FormatSettings.DecimalSeparator='.') then
          begin
             body[0].semissT:='0.001';
          end;

      end;
      //s:=s+FloatToStr(emissT)+' :';
      s:=s+semissT+' :';
      // Считать ли излучение внутри блока ?
      s:=s+IntToStr(binternalRadiation)+' :';
      s:=s+IntToStr(imatid)+' :'; // идентификатор рабочего материала.

      // Фиксация боковой стенки цилиндра при расчёте прочности.
      if (body[0].CylinderFixed=true) then
      begin
         s:=s+'1 :';
      end
       else
      begin
         s:=s+'0 :';
      end;

      //s:=s+spower+ ' :'; // параметризованная пользователем мощность тепловыделения блока
      // Кусочно - линейная мощность тепловыделения.
      s:=s+IntToStr(n_power)+ ' :';
      for i_4 := 0 to (n_power-1) do
      begin
         s:=s+FloatToStr(temp_power[i_4])+ ' :'+arr_s_power[i_4]+ ' :';
      end;
      s:=s+IntToStr(ipower_time_depend)+' :'; // зависимость мощности тепловыделения в блоке от времени.
      s:=s+IntToStr(itype)+ ' :'; // тип блока : SOLID, HOLLOW, FLUID.
      s:=s+IntToStr(iunion)+ ' :'; // номер объединения
      // Информация о цвете и прозрачности.
      s:=s+FloatToStr(redcolor)+ ' :';
      s:=s+FloatToStr(greencolor)+ ' :';
      s:=s+FloatToStr(bluecolor)+ ' :';
      s:=s+FloatToStr(transparency)+ ' :';
      s:=s+IntToStr(dcol)+ ' :';
   end;
   f.Add(s);
   // количество блоков:
   s:='lb='+IntToStr(lb)+' :'+IntToStr(icb)+' :';
   f.Add(s);

   // Сортировка блоков по возрастанию значения их priority.
   // 2 мая 2016.
   (*
    for isort:=2 to lb-1 do
   begin
	   for jsort:=lb-1 downto isort do
     begin
     		if (body[jsort-1].priority > body[jsort].priority) then
        begin
			     // swap
			     body_change:=body[jsort-1];
			     body[jsort-1]:=body[jsort];
			     body[jsort]:= body_change;
		    end;
	   end;
   end;
   *)
   // Теперь блоки отсортированы по возратанию их приоритетов.
   HeapSort(1,lb-1);


   // цикл по всем блокам :
   for i:=1 to (lb-1) do
   begin
      with (body[i]) do
      begin
         s:=name+'=';
         s:=s+IntToStr(igeometry_type)+' :'; // 0 - Prism, 1 - Cylinder.
         // Prism
         s:=s+sxS+' :';  // записываются
         s:=s+syS+' :';  // параметризованные
         s:=s+szS+' :';  // пользователем значения
         s:=s+sxE+' :';
         s:=s+syE+' :';
         s:=s+szE+' :';
         // Cylinder
         s:=s+IntToStr(iPlane)+' :'; // 1 - XY, 2 - XZ, 3 - YZ.
         s:=s+sxC+' :';  // записываются
         s:=s+syC+' :';  // параметризованные
         s:=s+szC+' :';  // пользователем значения
         s:=s+sHcyl+' :';
         s:=s+sR_out_cyl+' :';
         s:=s+sR_in_cyl+' :';
         // 18 января 2018.
         if (bCylinder2Prism) then
         begin
            // Разрешаем преобразовывать цилиндр в Призму.
            s:=s+'1 :';
         end
          else
         begin
            // Не разрешаем преобразовывать цилиндр в призму.
            s:=s+'0 :';
         end;
         // sector, conoid
         s:=s+sR_out_cyl2+' :';
         s:=s+sR_in_cyl2+' :';
         s:=s+sangle_start+' :';
         s:=s+sangle_end+' :';
         // Polygon
         s:=s+IntToStr(iPlane_obj2)+' :'; // 1 - XY, 2 - XZ, 3 - YZ.
         s:=s+IntToStr(nsizei)+' :';
         for j := 0 to nsizei-1 do
         begin
            s:=s+FloatToStr(hi[j])+' :';
            s:=s+FloatToStr(xi[j])+' :';
            s:=s+FloatToStr(yi[j])+' :';
            s:=s+FloatToStr(zi[j])+' :';
         end;

         // emissivity:
         bOk:=true;
         if (abs(FormVariables.my_real_convert(semissW,bOk))<1.0e-12) then
         begin
             // во избежании деления на ноль.
             body[i].emissW:=0.001;
             if (FormatSettings.DecimalSeparator=',') then
          begin
             body[i].semissW:='0,001';
          end;
          if (FormatSettings.DecimalSeparator='.') then
          begin
             body[i].semissW:='0.001';
         end;
         end;
         //s:=s+FloatToStr(emissW)+' :';
         s:=s+semissW+' :';
         if (abs(FormVariables.my_real_convert(semissE,bOk))<1.0e-12) then
         begin
            // во избежании деления на ноль.
            body[i].emissE:=0.001;
            if (FormatSettings.DecimalSeparator=',') then
          begin
             body[i].semissE:='0,001';
          end;
          if (FormatSettings.DecimalSeparator='.') then
          begin
             body[i].semissE:='0.001';
         end;
         end;
         //s:=s+FloatToStr(emissE)+' :';
         s:=s+semissE+' :';
         if (abs(FormVariables.my_real_convert(semissS,bOk))<1.0e-12) then
         begin
             // во избежании деления на ноль.
             body[i].emissS:=0.001;
              if (FormatSettings.DecimalSeparator=',') then
          begin
             body[i].semissS:='0,001';
          end;
          if (FormatSettings.DecimalSeparator='.') then
          begin
             body[i].semissS:='0.001';
         end;
         end;
         //s:=s+FloatToStr(emissS)+' :';
         s:=s+semissS+' :';
         if (abs(FormVariables.my_real_convert(semissN,bOk))<1.0e-12) then
         begin
            // во избежании деления на ноль.
            body[i].emissN:=0.001;
             if (FormatSettings.DecimalSeparator=',') then
          begin
             body[i].semissN:='0,001';
          end;
          if (FormatSettings.DecimalSeparator='.') then
          begin
             body[i].semissN:='0.001';
         end;
         end;
        // s:=s+FloatToStr(emissN)+' :';
         s:=s+semissN+' :';
         if (abs(FormVariables.my_real_convert(semissB,bOk))<1.0e-12) then
         begin
            // во избежании деления на ноль.
            body[i].emissB:=0.001;
            if (FormatSettings.DecimalSeparator=',') then
            begin
               body[i].semissB:='0,001';
            end;
            if (FormatSettings.DecimalSeparator='.') then
            begin
               body[i].semissB:='0.001';
            end;
         end;
         //s:=s+FloatToStr(emissB)+' :';
         s:=s+semissB+' :';
         if (abs(FormVariables.my_real_convert(semissT,bOk))<1.0e-12) then
         begin
            // во избежании деления на ноль.
            body[i].emissT:=0.001;
             if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissT:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissT:='0.001';
             end;
         end;
         //s:=s+FloatToStr(emissT)+' :';
         s:=s+semissT+' :';
         // Считать ли излучение внутри блока ?
         s:=s+IntToStr(binternalRadiation)+' :';
         s:=s+IntToStr(imatid)+' :'; // идентификатор рабочего материала.

         // Фиксация боковой стенки цилиндра при расчёте прочности.
         if (body[i].CylinderFixed=true) then
         begin
            s:=s+'1 :';
         end
           else
         begin
            s:=s+'0 :';
         end;

         //s:=s+spower+ ' :'; // параметризованная пользователем мощность тепловыделения блока
         s:=s+IntToStr(n_power)+ ' :';
         for i_4 := 0 to (n_power-1) do
         begin
            s:=s+FloatToStr(temp_power[i_4])+ ' :'+arr_s_power[i_4]+ ' :';
         end;
         s:=s+IntToStr(ipower_time_depend)+' :'; // зависимость мощности тепловыделения в блоке от времени.
         s:=s+IntToStr(itype)+ ' :'; // тип блока : SOLID, HOLLOW, FLUID.
         s:=s+IntToStr(iunion)+ ' :'; // номер объединения
         // Информация о цвете и прозрачности.
         s:=s+FloatToStr(redcolor)+ ' :';
         s:=s+FloatToStr(greencolor)+ ' :';
         s:=s+FloatToStr(bluecolor)+ ' :';
         s:=s+FloatToStr(transparency)+ ' :';
         s:=s+IntToStr(dcol)+ ' :';
      end;
      f.Add(s);
   end;
   // количество источников тепла:
   s:='ls='+IntToStr(ls)+' :'+IntToStr(ics)+' :';
   f.Add(s);
   // цикл по всем источникам тепла:
   for i:=0 to (ls-1) do
   begin
      with (source[i]) do
      begin
         s:=name+'=';
         // мощность тепловыделения, плоскость и координаты:
         s:=s+spower+' :';  // параметризованная пользователем мощность
         s:=s+IntToStr(itempdep)+' :';
         s:=s+IntToStr(id_table)+' :'; // идентификатор таблицы задания мощностей
         s:=s+soperatingoffsetdrain+' :'; // смещение стока.

         s:=s+IntToStr(iPlane)+' :'; // плоскость в которой лежит источник тепла
         s:=s+sxS+' :';  // записываются
         s:=s+syS+' :';  // параметризованные
         s:=s+szS+' :';  // пользователем значения
         s:=s+sxE+' :';
         s:=s+syE+' :';
         s:=s+szE+' :';
         s:=s+IntToStr(iunion)+ ' :'; // номер объединения
      end;
      f.Add(s);
   end;
   // количество твёрдых стенок
   // твёрдая стенка может быть только границей кабинета.
   s:='lw='+IntToStr(lw)+' :'+IntToStr(icw)+' :';
   f.Add(s);
   // цикл по всем твёрдым стенкам:
   for i:=0 to (lw-1) do
   begin
      with (wall[i]) do
      begin
         s:=name+'='; // имя
         // тип краевого условия, температура и тепловой поток,
         //  плоскость и координаты:
         s:=s+IntToStr(family)+' :'; // тип краевого условия
         s:=s+FloatToStr(Tamb)+' :'; // температура на идеальном теплооотводе
         bOk:=true;
         if (family=3) then
         begin
            //s:=s+FloatToStr(heat_transfer_coefficient)+' :'; // коэффициент теплоотдачи.
            s:=s+FloatToStr(FormVariables.my_real_convert(sheat_transfer_coefficient,bOk))+' :';
         end
         else
         begin
            //s:=s+FloatToStr(emissivity)+' :';// излучательная способность.
            s:=s+FloatToStr(FormVariables.my_real_convert(semissivity,bOk))+' :';
         end;
         s:=s+FloatToStr(ViewFactor)+' :';// Для фактора видимости.
         s:=s+FloatToStr(HF)+' :'; // для граничного условия 2 или 3 рода.
         if (bsymmetry) then s:=s+'1 :' else s:=s+'0 :';
         if (bpressure) then s:=s+'1 :' else s:=s+'0 :';
         if (bopening) then s:=s+'1 :' else s:=s+'0 :';

         s:=s+FloatToStr(Vx)+' :';
         s:=s+FloatToStr(Vy)+' :';
         s:=s+FloatToStr(Vz)+' :';
         s:=s+FloatToStr(P)+' :';
         s:=s+IntToStr(ithermal_stress_boundary_condition)+ ' :'; // Thermal-Stress.
         s:=s+FloatToStr(xForce)+' :';   // Приложенная сила в Ньютонах.
         s:=s+FloatToStr(yForce)+' :';
         s:=s+FloatToStr(zForce)+' :';


         s:=s+IntToStr(iPlane)+' :'; // плоскость в которой лежит источник тепла
         s:=s+sxS+' :';  // записываются
         s:=s+syS+' :';  // параметризованные
         s:=s+szS+' :';  // пользователем
         s:=s+sxE+' :';  // значения
         s:=s+syE+' :';
         s:=s+szE+' :';
         s:=s+IntToStr(iunion)+ ' :'; // номер объединения
         s:=s+IntToStr(cabinet_depend)+ ' :';// cabinet depend признак.
      end;
      f.Add(s);
   end;

   // Запись информации о решаемых уравнениях.
   // Теплопередча, Деформации, Гидродинамика.
   s:=IntToStr(egddata.itemper)+' :'+IntToStr(egddata.iStaticStructural)+' :'+IntToStr(egddata.imaxflD)+' :';
   f.Add(s);
   for i:=0 to egddata.imaxflD-1 do
   begin
      s:=FloatToStr(egddata.myflmod[i].xc)+' :'+FloatToStr(egddata.myflmod[i].yc)+' :';
      s:=s+FloatToStr(egddata.myflmod[i].zc)+' :';
      s:=s+IntToStr(egddata.myflmod[i].iflow)+' :';
      s:=s+IntToStr(egddata.myflmod[i].iflowregime)+' :';
      s:=s+IntToStr(egddata.myflmod[i].iturbmodel)+' :';
      // параметры модели Смагоринского
      s:=s+FloatToStr(egddata.myflmod[i].SmagConst)+' :';
      s:=s+IntToStr(egddata.myflmod[i].iDynamicStressGermano)+' :';
      s:=s+IntToStr(egddata.myflmod[i].iLimitersCs)+' :';
      s:=s+FloatToStr(egddata.myflmod[i].minCs)+' :';
      s:=s+FloatToStr(egddata.myflmod[i].maxCs)+' :';
      s:=s+IntToStr(egddata.myflmod[i].itypeFiltrGermano)+' :';
      s:=s+FloatToStr(egddata.myflmod[i].roughness)+' :';
      s:=s+FloatToStr(egddata.myflmod[i].rRimult)+' :';
      s:=s+FloatToStr(egddata.myflmod[i].rSelectiveAngle)+' :';
      s:=s+IntToStr(egddata.myflmod[i].ipowerroughness)+' :';
      s:=s+IntToStr(egddata.myflmod[i].itypefiltr)+' :';
      // учёт неравномерности сетки.
      if (egddata.myflmod[i].bfdelta) then
      begin
         s:=s+'1 :';
      end
      else
      begin
         s:=s+'0 :';
      end;
      // модель Смагоринского-Лиллу.
      if (egddata.myflmod[i].bSmagorinsky_Lilly) then
      begin
         s:=s+'1 :';
      end
      else
      begin
         s:=s+'0 :';
      end;
      // учёт шероховатости стенки.
      if (egddata.myflmod[i].bsurface_roughness) then
      begin
         s:=s+'1 :';
      end
      else
      begin
         s:=s+'0 :';
      end;
      // течения с кривизной линий тока
      if (egddata.myflmod[i].bSwirlamendment) then
      begin
         s:=s+'1 :';
      end
      else
      begin
         s:=s+'0 :';
      end;
      // модель Selective Smagorinsky
      if (egddata.myflmod[i].bSelectiveSmagorinsky) then
      begin
         s:=s+'1 :';
      end
      else
      begin
         s:=s+'0 :';
      end;
      f.Add(s);
   end;

    // Сохраняем параметры освещения.

    s:=FloatToStr(remis)+' :'+FloatToStr(rspec)+' :'+FloatToStr(matdiff)+' :';
    f.Add(s);
    s:=FloatToStr(matamb)+' :'+FloatToStr(matt)+' :'+FloatToStr(mr)+' :';
    f.Add(s);
    s:=FloatToStr(glamb0)+' :'+FloatToStr(mldx)+' :'+FloatToStr(mldy)+' :';
    f.Add(s);
    s:=FloatToStr(lamb)+' :'+FloatToStr(lspec)+' :'+FloatToStr(ldiff)+' :';
    f.Add(s);
    s:=FloatToStr(lithtangle)+' :'+FloatToStr(lithtexponent)+' :'+FloatToStr(lithtangle1)+' :';
    f.Add(s);
    s:=FloatToStr(lithtexponent1)+' :'+FloatToStr(mldx1)+' :'+FloatToStr(mldy1)+' :';
    f.Add(s);
    s:=FloatToStr(matt1)+' :'+FloatToStr(mr1)+' :'+FloatToStr(lamb1)+' :';
    f.Add(s);
    s:=FloatToStr(lspec1)+' :'+FloatToStr(ldiff1)+' :'+IntToStr(rblick)+' :';
    f.Add(s);

    // Сохраняем булевы индикаторы связанные с освещением.
    if (chkOnLitht1.Checked=True) then
    begin
       s:='1 :';
    end
     else
    begin
       s:='0 :';
    end;

    if (chkDiskretSource1.Checked=True) then
    begin
       s:=s+'1 :';
    end
     else
    begin
       s:=s+'0 :';
    end;

    if (chkdistance1.Checked=True) then
    begin
       s:=s+'1 :';
    end
     else
    begin
       s:=s+'0 :';
    end;

    if (CheckBoxdistance.Checked=True) then
    begin
       s:=s+'1 :';
    end
     else
    begin
       s:=s+'0 :';
    end;

     if (CheckBoxOnLitht.Checked=True) then
    begin
       s:=s+'1 :';
    end
     else
    begin
       s:=s+'0 :';
    end;

     if (CheckBoxPointSources.Checked=True) then
    begin
       s:=s+'1 :';
    end
     else
    begin
       s:=s+'0 :';
    end;

    if (chkblick.Checked=True) then
    begin
       s:=s+'1 :';
    end
     else
    begin
       s:=s+'0 :';
    end;

     if (chkemis.Checked=True) then
    begin
       s:=s+'1 :';
    end
     else
    begin
       s:=s+'0 :';
    end;

     if (chkGlobalAmbient.Checked=True) then
    begin
       s:=s+'1 :';
    end
     else
    begin
       s:=s+'0 :';
    end;

     if (chksmooter.Checked=True) then
    begin
       s:=s+'1 :';
    end
     else
    begin
       s:=s+'0 :';
    end;

     if (chkSpecular.Checked=True) then
    begin
       s:=s+'1 :';
    end
     else
    begin
       s:=s+'0 :';
    end;
    f.Add(s);

    // additional setting 24.07.2020
    s:=FormSpeedInitialization.EditVx.Text+' :';
    f.Add(s);
    s:=FormSpeedInitialization.EditVy.Text+' :';
    f.Add(s);
    s:=FormSpeedInitialization.EditVz.Text+' :';
    f.Add(s);
    s:=IntToStr(FormSetting.ComboBoxStaticStructuralSolverSetting.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(MeshForm.ComboBoxmeshgen.ItemIndex)+' :';
    f.Add(s);
    if (MeshForm.CheckBoxALICE.Checked) then
    begin
       // Adaptive Local Refinement Mesh
       s:='1 :';
    end
    else
    begin
       // Structural Mesh
       s:='0 :';
    end;
    f.Add(s);
    s:=IntToStr(MeshForm.ComboBoxALICEType.ItemIndex)+' :';
    f.Add(s);

    if (FormXYPlot.bfirst_zapusk_XYPlot) then
    begin

       // При считывании тепловой модели инициализируем XYPlot.
       if (ls>0) then
       begin
          // Инициализируем геометрическим центром первого источника тепла при его наличии.
          FormXYPlot.EditXo.Text:=FloatToStr(0.5*(source[0].xS+source[0].xE));
          FormXYPlot.EditYo.Text:=FloatToStr(0.5*(source[0].yS+source[0].yE));
          FormXYPlot.EditZo.Text:=FloatToStr(0.5*(source[0].zS+source[0].zE));

          if (ls>1) then
          begin
             if (abs(source[0].xS-source[1].xS)>1.0e-23) then
             begin
                FormXYPlot.ComboBoxdirectional.ItemIndex:=0; // X - directional
             end;
             if (abs(source[0].yS-source[1].yS)>1.0e-23) then
             begin
                FormXYPlot.ComboBoxdirectional.ItemIndex:=1; // Y - directional
             end;
             if (abs(source[0].zS-source[1].zS)>1.0e-23) then
             begin
                FormXYPlot.ComboBoxdirectional.ItemIndex:=2; // Z - directional
             end;
          end;
       end
        else
       begin
          // Инициализируем геометрическим центром кабинета.
          FormXYPlot.EditXo.Text:=FloatToStr(0.5*(body[0].xS+body[0].xE));
          FormXYPlot.EditYo.Text:=FloatToStr(0.5*(body[0].yS+body[0].yE));
          FormXYPlot.EditZo.Text:=FloatToStr(0.5*(body[0].zS+body[0].zE));
          i_3:=-1;
          for i_2 := 0 to lb-1 do
          begin
             if (body[i_2].n_power>0) then
             begin
                if ((i_3>-1)and(abs(body[i_2].arr_power[0])>0.0)) then
                begin
                   if (abs(body[i_3].xS-body[i_2].xS)>1.0e-23) then
                   begin
                      FormXYPlot.ComboBoxdirectional.ItemIndex:=0; // X - directional
                   end;
                   if (abs(body[i_3].yS-body[i_2].yS)>1.0e-23) then
                   begin
                      FormXYPlot.ComboBoxdirectional.ItemIndex:=1; // Y - directional
                   end;
                   if (abs(body[i_3].zS-body[i_2].zS)>1.0e-23) then
                   begin
                      FormXYPlot.ComboBoxdirectional.ItemIndex:=2; // Z - directional
                   end;
                   break;
                end;
                if ((i_3=-1)and(abs(body[i_2].arr_power[0])>0.0)) then
                begin
                   i_3:=i_2;
                   FormXYPlot.EditXo.Text:=FloatToStr(0.5*(body[i_2].xS+body[i_2].xE));
                   FormXYPlot.EditYo.Text:=FloatToStr(0.5*(body[i_2].yS+body[i_2].yE));
                   FormXYPlot.EditZo.Text:=FloatToStr(0.5*(body[i_2].zS+body[i_2].zE));
                end;
             end;
          end;
       end;

       FormXYPlot.bfirst_zapusk_XYPlot:=false;

    end;


    s:=FormXYPlot.EditXo.Text+' :';
    f.Add(s);
    s:=FormXYPlot.EditYo.Text+' :';
    f.Add(s);
    s:=FormXYPlot.EditZo.Text+' :';
    f.Add(s);
    s:=IntToStr(FormXYPlot.ComboBoxdirectional.ItemIndex)+' :';
    f.Add(s);

    // Save AMGCL settings 25.07.2020
    s:=IntToStr(FormAMGCLParameters.RadioGroupAMGCLsmoother1.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(FormAMGCLParameters.RadioGroupAMGCLCoarseningType.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(FormAMGCLParameters.ComboBoxIterator.ItemIndex)+' :';
    f.Add(s);

    // Save amg1r5 settings 27.07.2020
    s:=IntToStr(FormSetting.ComboBoxNumberProcessors.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Formamg1r5Parameters.ComboBoxStabilization.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Formamg1r5Parameters.ComboBoxNumber_of_smootherssteps.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Formamg1r5Parameters.ComboBoxTypeSmoother.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Formamg1r5Parameters.ComboBoxTypePostSmoother.ItemIndex)+' :';
    f.Add(s);
    s:=Trim(Formamg1r5Parameters.Editstrongthreshold.Text)+' :';
    f.Add(s);
    s:=Trim(Formamg1r5Parameters.EditF2F.Text)+' :';
    f.Add(s);
    if (Formamg1r5Parameters.CheckBox_amg1r6.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
    s:=IntToStr(FormSetting.ComboBoxPressureVelocityCoupling.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(FormSetting.ComboBoxFlowSchemePrefix.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(FormSetting.ComboBoxFlowScheme.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(FormSetting.ComboBoxSchemeTemperature.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(FormSetting.ComboBox_lfil.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(FormSetting.ComboBox_m_restart_for_gmres.ItemIndex)+' :';
    f.Add(s);

    // Сохранение настроек Румба v.0.14 решателя.
    // 28.07.2020.
    s:=IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevels.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevelsSpeed.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevelsPressure.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevelsStress.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxnFinnest.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxnFinnestSpeed.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxnFinnestPressure.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxnFinnestStress.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxnumberpresmothers.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxnumberpresmothersSpeed.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxnumberpresmothersPressure.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxnumberpresmoothersStress.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxnumberpostsweeps.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxnumberpostsweepsSpeed.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxnumberpostsweepsPressure.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxnumberpostsweepsStress.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxmemorysize.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxmemorysizeSpeed.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxmemorysizePressure.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxmemorysizeStress.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxinterpolation.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxinterpolationSpeed.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxinterpolationPressure.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxinterpollationStress.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxSort.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxsmoothertypeTemperature.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxsmoothertypeSpeed.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxsmoothertypePressure.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxsmoothertypeStress.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxcoarseningTemp.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxcoarseningSpeed.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxcoarseningPressure.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxcoarseningStress.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxStabilizationTemp.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxStabilizationSpeed.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxStabilizationPressure.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxStabilizationStress.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Temperature.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Speed.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Pressure.ItemIndex)+' :';
    f.Add(s);
    s:=IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Stress.ItemIndex)+' :';
    f.Add(s);

     // 30.07.2020
    s:=Trim(Form_amg_manager.Editthreshold.Text)+' :';
    f.Add(s);
    s:=Trim(Form_amg_manager.EditthresholdSpeed.Text)+' :';
    f.Add(s);
    s:=Trim(Form_amg_manager.EditthresholdPressure.Text)+' :';
    f.Add(s);
    s:=Trim(Form_amg_manager.EditthresholdStress.Text)+' :';
    f.Add(s);
    s:=Trim(Form_amg_manager.Edit_truncation_T.Text)+' :';
    f.Add(s);
    s:=Trim(Form_amg_manager.Edit_truncation_Speed.Text)+' :';
    f.Add(s);
    s:=Trim(Form_amg_manager.Edit_truncation_Pressure.Text)+' :';
    f.Add(s);
    s:=Trim(Form_amg_manager.Edittruncation_Stress.Text)+' :';
    f.Add(s);
    s:=Trim(Form_amg_manager.EditmagicT.Text)+' :';
    f.Add(s);
    s:=Trim(Form_amg_manager.EditmagicSpeed.Text)+' :';
    f.Add(s);
    s:=Trim(Form_amg_manager.EditmagicPressure.Text)+' :';
    f.Add(s);
    s:=Trim(Form_amg_manager.EditmagicStress.Text)+' :';
    f.Add(s);
     if (Form_amg_manager.CheckBoxDiagonalDominant.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxtruncationT.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxtruncationSpeed.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxtruncationPressure.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxtruncationStress.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxStrongTranspose.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxprintlogTemperature.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
     if (Form_amg_manager.CheckBoxprintlogSpeed.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxprintlogPressure.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxprintlogStress.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
     if (Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxStressMatrixPortrait.Checked=true) then
    begin
       s:='1 :';
    end
    else
    begin
       s:='0 :';
    end;
    f.Add(s);



    if (Pos('.txt',filename)>0) then
    begin
       filename:=StringReplace(filename,'.txt','',[rfReplaceAll, rfIgnoreCase]);
    end;
    f.SaveToFile(filename+'.txt'); // сохранение результата
    f.Free;
    MainMemo.Lines.Add('File '+filename+'.txt  successfully written.');
end;

procedure NewWriteFile();
var
   filename : string; // имя записываемого файла
   f : TStringList; // переменная типа объект TStringList
   s : String; // текущая рабочая строка
   i, i_4, j, i_2, i_3 : Integer;
   bOk : Boolean;
   // isort, jsort : Integer; // текущий номер блока или источника при записи
   //body_change : TBody; // для сортировки блоков.
begin
    // записывает файл с геометрией задачи
   //filename:='';
   //if not InputQuery('Input name file', 'Please, enter name writing file',filename)
   //then exit;

   f:=TStringList.Create();

   // 01.08.2020 В файл пишется метка для того чтобы понять что это не
   // просто текстовый файл, а именно файл с моделью для программы AliceMesh.v.0.45.
   s:='open_label=1082020 :';
   f.Add(s);
   // Если метка во входном файле отсутствует значит файл не будет открываться.

   s:='mashtab='+FloatToStr(m);
   s:=s+' :'+'gravity_x='+FloatToStr(gx)+' :'+'gravity_y='+FloatToStr(gy)+' :'+'gravity_z='+FloatToStr(gz)+' :';
   s:=s+'inx='+IntToStr(inx)+' :'+'iny='+IntToStr(iny)+' :'+'inz='+IntToStr(inz)+' :';
   s:=s+'operating_temperature='+FloatToStr(operatingtemperature)+' :'+'etalon_max_size_ratio='+FloatToStr(etalon_max_size_ratio)+' :';
   s:=s+'etalon_max_size_ratio2='+FloatToStr(etalon_max_size_ratio2)+' :';
    // Snap to grid
   s:=s+'snap_to_grid='+IntToStr(MeshForm.ComboBoxSnapTo.ItemIndex)+' :';
   s:=s+'solver_setting='+IntToStr(FormSetting.ComboBoxSolverSetting.ItemIndex)+' :'+'film_coefficient='+FloatToStr(filmcoefficient)+' :';
   s:=s+'adiabatic_vs_heat_transfer_coeff='+IntToStr(adiabatic_vs_heat_transfer_coeff)+' :';
   s:=s+'time_step_id_law='+IntToStr(glSTL.id_law)+' :'+'time_step_factor_a_for_linear='+FloatToStr(glSTL.Factor_a_for_Linear)+' :';
   s:=s+'tau='+FloatToStr(glSTL.tau)+' :'+'iQ_duty_cycle='+FloatToStr(glSTL.iQ)+' :';
   s:=s+'m1='+FloatToStr(glSTL.m1)+' :'+'tau1='+FloatToStr(glSTL.tau1)+' :';
   s:=s+'tau2='+FloatToStr(glSTL.tau2)+' :'+'tau_pause='+FloatToStr(glSTL.tau_pause)+' :';
   s:=s+'off_multiplyer='+FloatToStr(glSTL.off_multiplyer)+' :';
   s:=s+'number_vitkov='+IntToStr(glSTL.n)+' :'+'Time_period='+FloatToStr(glSTL.T)+' :';
   s:=s+'on_time_double_linear='+FloatToStr(glSTL.on_time_double_linear)+' :';
   f.Add(s);
   // масштабирующий коэффициент
   // единицы длины:
   s:='length=';
   s:=s+IntToStr(ComboBoxlength.ItemIndex); // запоминаем выбранные единицы длины
   f.Add(s); // единицы длины

   // Список таблиц в которых прописана зависимость
   // рассеиваемой мощности  от максимальной температуры и смещения стока.
   s:='ltdp=';
   s:=s+IntToStr(iltdp); // количество различных таблиц
   f.Add(s);
   for i:=0 to iltdp-1 do
   begin
      f.Add('power_table_number'+IntToStr(i)+'='+listtablename[i]); // имя файла с таблицей
   end;

   // параметры объединений :
   s:='lu='+IntToStr(lu);
   f.Add(s);
   for i:=0 to lu-1 do
   begin
       // имя объединения, идентификатор объединения.
       s:='ass'+IntToStr(i)+'name='+myassembles[i].name+' :'+'ass'+IntToStr(i)+'identifire='+IntToStr(myassembles[i].identifire)+' :';
       s:=s+'ass'+IntToStr(i)+'iunionparent='+IntToStr(myassembles[i].iunionparent)+' :';
       if (myassembles[i].bmesh_assembles_separately) then
       begin
          s:=s+'ass'+IntToStr(i)+'type_mesh='+'1 :';  // блочно структурированная сетка
       end
        else
       begin
          s:=s+'ass'+IntToStr(i)+'type_mesh='+'0 :'; // не блочно структурированная сетка
       end;
       s:=s+'ass'+IntToStr(i)+'sxmin='+myassembles[i].sxmin+' :';
       s:=s+'ass'+IntToStr(i)+'sxmax='+myassembles[i].sxmax+' :';
       s:=s+'ass'+IntToStr(i)+'symin='+myassembles[i].symin+' :';
       s:=s+'ass'+IntToStr(i)+'symax='+myassembles[i].symax+' :';
       s:=s+'ass'+IntToStr(i)+'szmin='+myassembles[i].szmin+' :';
       s:=s+'ass'+IntToStr(i)+'szmax='+myassembles[i].szmax+' :';
       s:=s+'ass'+IntToStr(i)+'inxloc='+IntToStr(myassembles[i].inxloc)+' :';
       s:=s+'ass'+IntToStr(i)+'inyloc='+IntToStr(myassembles[i].inyloc)+' :';
       s:=s+'ass'+IntToStr(i)+'inzloc='+IntToStr(myassembles[i].inzloc)+' :';
       f.Add(s);
   end;

   // количество рабочих переменных :
   s:='ivarmax='+IntToStr(ivar);
   f.Add(s);
   for i:=0 to (ivar-1) do
   begin
      // каждая переменная записывается в отдельной строке.
      s:='var'+IntToStr(i)+'name='+parametric[i].svar+' :'+'var'+IntToStr(i)+'value='+parametric[i].sval+' :';
      f.Add(s);
   end;

   // количество рабочих материалов: (solid and fluid).
   s:='lmatmax='+IntToStr(lmatmax);
   f.Add(s);
   for i:=0 to (lmatmax-1) do
   begin
      s:='matherial'+IntToStr(i)+'name='+workmat[i].namemat+' :'; // имя материала
      // плотность, теплоёмкость и теплопроводность.
      s:=s+'matherial'+IntToStr(i)+'density='+FloatToStr(workmat[i].rho)+ ' :'; // плотность
      //s:=s+FloatToStr(workmat[i].cp)+ ' :'; // теплоёмкость
      s:=s+'matherial'+IntToStr(i)+'nCp='+IntToStr(workmat[i].n_cp)+ ' :';
      for i_4 := 0 to (workmat[i].n_cp-1) do
      begin
         s:=s+'matherial'+IntToStr(i)+'Temp_Cp'+IntToStr(i_4)+'='+FloatToStr(workmat[i].temp_cp[i_4])+ ' :'+'matherial'+IntToStr(i)+'Arr_Cp_val'+IntToStr(i_4)+'='+FloatToStr(workmat[i].arr_cp[i_4])+ ' :';
      end;
      //s:=s+FloatToStr(workmat[i].lambda)+ ' :'; // теплопроводность
      s:=s+'matherial'+IntToStr(i)+'n_lambda='+IntToStr(workmat[i].n_lam)+ ' :';
      for i_4 := 0 to (workmat[i].n_lam-1) do
      begin
         s:=s+'matherial'+IntToStr(i)+'Temp_Lam'+IntToStr(i_4)+'='+FloatToStr(workmat[i].temp_lam[i_4])+ ' :'+'matherial'+IntToStr(i)+'Arr_Lam_val'+IntToStr(i_4)+'='+FloatToStr(workmat[i].arr_lam[i_4])+ ' :';
      end;
      // Ортотропность теплопроводности.
      s:=s+'matherial'+IntToStr(i)+'mult_lam_x='+FloatToStr(workmat[i].mult_lam_x)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'mult_lam_y='+FloatToStr(workmat[i].mult_lam_y)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'mult_lam_z='+FloatToStr(workmat[i].mult_lam_z)+ ' :';
      // Thermal-Stress
      s:=s+'matherial'+IntToStr(i)+'mult_Linear_expansion_coefficient_x='+FloatToStr(workmat[i].mult_Linear_expansion_coefficient_x)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'mult_Linear_expansion_coefficient_y='+FloatToStr(workmat[i].mult_Linear_expansion_coefficient_y)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'mult_Linear_expansion_coefficient_z='+FloatToStr(workmat[i].mult_Linear_expansion_coefficient_z)+ ' :';
       // Ортотропность Модуля Юнга.
      s:=s+'matherial'+IntToStr(i)+'mult_Young_Module_x='+FloatToStr(workmat[i].mult_Young_Module_x)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'mult_Young_Module_y='+FloatToStr(workmat[i].mult_Young_Module_y)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'mult_Young_Module_z='+FloatToStr(workmat[i].mult_Young_Module_z)+ ' :';
      // Ортотропность коэффициента Пуассона.
      s:=s+'matherial'+IntToStr(i)+'mult_Poisson_ratio_xy='+FloatToStr(workmat[i].mult_Poisson_ratio_xy)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'mult_Poisson_ratio_xz='+FloatToStr(workmat[i].mult_Poisson_ratio_xz)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'mult_Poisson_ratio_yz='+FloatToStr(workmat[i].mult_Poisson_ratio_yz)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'mult_Poisson_ratio_yx='+FloatToStr(workmat[i].mult_Poisson_ratio_yx)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'mult_Poisson_ratio_zx='+FloatToStr(workmat[i].mult_Poisson_ratio_zx)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'mult_Poisson_ratio_zy='+FloatToStr(workmat[i].mult_Poisson_ratio_zy)+ ' :';
      // Модуль сдвига
      if (workmat[i].bShearModuleActive) then
      begin
         s:=s+'matherial'+IntToStr(i)+'bShearModuleActive=1 :';  // Модуль сдвига задаётся пользователем.
      end
      else
      begin
         s:=s+'matherial'+IntToStr(i)+'bShearModuleActive=0 :';  // Модуль сдвига не задаётся пользователем.
      end;
      s:=s+'matherial'+IntToStr(i)+'ShearModuleGxy='+FloatToStr(workmat[i].ShearModuleGxy)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'ShearModuleGyz='+FloatToStr(workmat[i].ShearModuleGyz)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'ShearModuleGxz='+FloatToStr(workmat[i].ShearModuleGxz)+ ' :';


      //s:=s+'matherial'+IntToStr(i)+'Poisson_ratio='+FloatToStr(workmat[i].Poisson_ratio)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'n_Poisson_ratio='+IntToStr(workmat[i].n_Poisson_ratio)+ ' :';
      for i_4 := 0 to (workmat[i].n_Poisson_ratio-1) do
      begin
         s:=s+'matherial'+IntToStr(i)+'temp_Poisson_ratio'+IntToStr(i_4)+'='+FloatToStr(workmat[i].temp_Poisson_ratio[i_4])+ ' :'+'matherial'+IntToStr(i)+'arr_Poisson_ratio'+IntToStr(i_4)+'='+FloatToStr(workmat[i].arr_Poisson_ratio[i_4])+ ' :';
      end;
      //s:=s+'matherial'+IntToStr(i)+'Young_Module='+FloatToStr(workmat[i].Young_Module)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'n_Young_Module='+IntToStr(workmat[i].n_Young_Module)+ ' :';
      for i_4 := 0 to (workmat[i].n_Young_Module-1) do
      begin
         s:=s+'matherial'+IntToStr(i)+'temp_Young_Module'+IntToStr(i_4)+'='+FloatToStr(workmat[i].temp_Young_Module[i_4])+ ' :'+'matherial'+IntToStr(i)+'arr_Young_Module'+IntToStr(i_4)+'='+FloatToStr(workmat[i].arr_Young_Module[i_4])+ ' :';
      end;
      //s:=s+'matherial'+IntToStr(i)+'Linear_expansion_coefficient='+FloatToStr(workmat[i].Linear_expansion_coefficient)+ ' :';
      s:=s+'matherial'+IntToStr(i)+'n_Linear_expansion_coefficient='+IntToStr(workmat[i].n_Linear_expansion_coefficient)+ ' :';
      for i_4 := 0 to (workmat[i].n_Linear_expansion_coefficient-1) do
      begin
         s:=s+'matherial'+IntToStr(i)+'temp_Linear_expansion_coefficient'+IntToStr(i_4)+'='+FloatToStr(workmat[i].temp_Linear_expansion_coefficient[i_4])+ ' :'+'matherial'+IntToStr(i)+'arr_Linear_expansion_coefficient_val'+IntToStr(i_4)+'='+FloatToStr(workmat[i].arr_Linear_expansion_coefficient[i_4])+ ' :';
      end;
      // etc.
      s:=s+'matherial'+IntToStr(i)+'mu='+FloatToStr(workmat[i].mu)+ ' :'; // динамическая вязкость
      s:=s+'matherial'+IntToStr(i)+'beta_t='+FloatToStr(workmat[i].beta_t)+ ' :'; // коэффициент линейного температурного расширения
      s:=s+'matherial'+IntToStr(i)+'blibmat='+IntToStr(workmat[i].blibmat)+' :'; // является ли материал библиотечным ?
      s:=s+'matherial'+IntToStr(i)+'ilibident='+IntToStr(workmat[i].ilibident)+' :'; // идентификатор библиотечного материаала
      s:=s+'matherial'+IntToStr(i)+'bBoussinesq='+IntToStr(workmat[i].bBoussinesq)+' :'; // использовать приближение Обербека-Буссинеска или нет.
      s:=s+'matherial'+IntToStr(i)+'ilawmu='+IntToStr(workmat[i].ilawmu)+' :';  // номер закона для динамической вязкости
      s:=s+'matherial'+IntToStr(i)+'mumin='+FloatToStr(workmat[i].mumin)+' :'; // ограничители
      s:=s+'matherial'+IntToStr(i)+'mumax='+FloatToStr(workmat[i].mumax)+' :'; // динамической вязкости.
      s:=s+'matherial'+IntToStr(i)+'Amu='+FloatToStr(workmat[i].Amu)+' :';   // параметры
      s:=s+'matherial'+IntToStr(i)+'Bmu='+FloatToStr(workmat[i].Bmu)+' :';   // модельных
      s:=s+'matherial'+IntToStr(i)+'Cmu='+FloatToStr(workmat[i].Cmu)+' :';   // зависимостей
      s:=s+'matherial'+IntToStr(i)+'degreennmu='+FloatToStr(workmat[i].degreennmu)+' :'; // показатель степени
      f.Add(s);
   end;


   // запись размеров кабинета
   s:='cabinet=';
   with (body[0]) do
   begin
      s:=s+'body'+'0'+'igeometry_type='+IntToStr(igeometry_type)+' :'; // 0 - Prism, 1 - Cylinder, 2 - Polygon.
      // Prism
      s:=s+'body'+'0'+'sxS='+sxS+' :';  // записываются
      s:=s+'body'+'0'+'syS='+syS+' :';  // параметризованные
      s:=s+'body'+'0'+'szS='+szS+' :';  // пользователем значения
      s:=s+'body'+'0'+'sxE='+sxE+' :';
      s:=s+'body'+'0'+'syE='+syE+' :';
      s:=s+'body'+'0'+'szE='+szE+' :';
      // Cylinder
      s:=s+'body'+'0'+'iPlane='+IntToStr(iPlane)+' :'; // 1 - XY, 2 - XZ, 3 - YZ.
      s:=s+'body'+'0'+'sxC='+sxC+' :';  // записываются
      s:=s+'body'+'0'+'syC='+syC+' :';  // параметризованные
      s:=s+'body'+'0'+'szC='+szC+' :';  // пользователем значения
      s:=s+'body'+'0'+'sHcyl='+sHcyl+' :';
      s:=s+'body'+'0'+'sR_out_cyl='+sR_out_cyl+' :';
      s:=s+'body'+'0'+'sR_in_cyl='+sR_in_cyl+' :';
       // 18 января 2018.
      if (bCylinder2Prism) then
      begin
         // Разрешаем преобразовывать Цилиндр в Призму.
         s:=s+'body'+'0'+'bCylinder2Prism='+'1 :';
      end
      else
      begin
         // Не разрешаем преобразовывать Цилиндр в Призму.
         s:=s+'body'+'0'+'bCylinder2Prism='+'0 :';
      end;
      // sector, conoid
      s:=s+'body'+'0'+'sR_out_cyl2='+sR_out_cyl2+' :';
      s:=s+'body'+'0'+'sR_in_cyl2='+sR_in_cyl2+' :';
      s:=s+'body'+'0'+'sangle_start='+sangle_start+' :';
      s:=s+'body'+'0'+'sangle_end='+sangle_end+' :';
      // Polygon
      s:=s+'body'+'0'+'iPlane_obj2='+IntToStr(iPlane_obj2)+' :'; // 1 - XY, 2 - XZ, 3 - YZ.
      s:=s+'body'+'0'+'nsizei='+IntToStr(nsizei)+' :';
      for i := 0 to nsizei-1 do
      begin
         s:=s+'body'+'0'+'hi'+IntToStr(i)+'='+FloatToStr(hi[i])+' :';
         s:=s+'body'+'0'+'xi'+IntToStr(i)+'='+FloatToStr(xi[i])+' :';
         s:=s+'body'+'0'+'yi'+IntToStr(i)+'='+FloatToStr(yi[i])+' :';
         s:=s+'body'+'0'+'zi'+IntToStr(i)+'='+FloatToStr(zi[i])+' :';
      end;

      // emissivity:
      bOk:=true;

      if (abs(FormVariables.my_real_convert(semissW,bOk))<1.0e-12) then
      begin
          // во избежании деления на ноль.
          body[0].emissW:=0.001;
          if (FormatSettings.DecimalSeparator=',') then
          begin
             body[0].semissW:='0,001';
          end;
          if (FormatSettings.DecimalSeparator='.') then
          begin
             body[0].semissW:='0.001';
         end;

      end;
      //s:=s+FloatToStr(emissW)+' :';
      s:=s+'body'+'0'+'semissW='+semissW+' :';
      if (abs(FormVariables.my_real_convert(semissE,bOk))<1.0e-12) then
      begin
          // во избежании деления на ноль.
          body[0].emissE:=0.001;
           if (FormatSettings.DecimalSeparator=',') then
          begin
             body[0].semissE:='0,001';
          end;
            if (FormatSettings.DecimalSeparator='.') then
          begin
              body[0].semissE:='0.001';
          end;

      end;
      //s:=s+FloatToStr(emissE)+' :';
      s:=s+'body'+'0'+'semissE='+semissE+' :';
      if (abs(FormVariables.my_real_convert(semissS,bOk))<1.0e-12) then
      begin
          // во избежании деления на ноль.
          body[0].emissS:=0.001;
           if (FormatSettings.DecimalSeparator=',') then
          begin
          body[0].semissS:='0,001';
          end;
            if (FormatSettings.DecimalSeparator='.') then
          begin
             body[0].semissS:='0.001';
          end;
      end;
      //s:=s+FloatToStr(emissS)+' :';
      s:=s+'body'+'0'+'semissS='+semissS+' :';
      if (abs(FormVariables.my_real_convert(semissN,bOk))<1.0e-12) then
      begin
          // во избежании деления на ноль.
          body[0].emissN:=0.001;
          if (FormatSettings.DecimalSeparator=',') then
          begin
             body[0].semissN:='0,001';
          end;
          if (FormatSettings.DecimalSeparator='.') then
          begin
             body[0].semissN:='0.001';
          end;

      end;
      //s:=s+FloatToStr(emissN)+' :';
      s:=s+'body'+'0'+'semissN='+semissN+' :';
      if (abs(FormVariables.my_real_convert(semissB,bOk))<1.0e-12) then
      begin
          // во избежании деления на ноль.
          body[0].emissB:=0.001;
             if (FormatSettings.DecimalSeparator=',') then
          begin
             body[0].semissB:='0,001';
          end;
             if (FormatSettings.DecimalSeparator='.') then
          begin
             body[0].semissB:='0.001';
          end;

      end;
      //s:=s+FloatToStr(emissB)+' :';
      s:=s+'body'+'0'+'semissB='+semissB+' :';
      if (abs(FormVariables.my_real_convert(semissT,bOk))<1.0e-12) then
      begin
          // во избежании деления на ноль.
          body[0].emissT:=0.001;
             if (FormatSettings.DecimalSeparator='.') then
          begin
             body[0].semissT:='0,001';
          end;
             if (FormatSettings.DecimalSeparator='.') then
          begin
             body[0].semissT:='0.001';
          end;

      end;
      //s:=s+FloatToStr(body[0].emissT)+' :';
      s:=s+'body'+'0'+'semissT='+body[0].semissT+' :';
      // Считать ли излучение внутри блока ?
      s:=s+'body'+'0'+'binternalRadiation='+IntToStr(body[0].binternalRadiation)+' :';
      s:=s+'body'+'0'+'imatid='+IntToStr(body[0].imatid)+' :'; // идентификатор рабочего материала.

      // Фиксация боковой стенки цилиндра при расчёте прочности.
      if (body[0].CylinderFixed=true) then
      begin
         s:=s+'body'+'0'+'CylinderFixed='+'1 :';
      end
       else
      begin
         s:=s+'body'+'0'+'CylinderFixed='+'0 :';
      end;
      //s:=s+spower+ ' :'; // параметризованная пользователем мощность тепловыделения блока
      // Кусочно - линейная мощность тепловыделения.
      s:=s+'body'+'0'+'n_power='+IntToStr(body[0].n_power)+ ' :';
      for i_4 := 0 to (body[0].n_power-1) do
      begin
         s:=s+'body'+'0'+'Temp_Power'+IntToStr(i_4)+'='+FloatToStr(body[0].temp_power[i_4])+ ' :'+'body'+'0'+'Arr_Power'+IntToStr(i_4)+'='+body[0].arr_s_power[i_4]+ ' :';
      end;
      // зависимость мощности тепловыделения в блоке от времени.
      s:=s+'body'+'0'+'ipower_time_depend='+IntToStr(body[0].ipower_time_depend)+' :';
      s:=s+'body'+'0'+'itype='+IntToStr(body[0].itype)+ ' :'; // тип блока : SOLID, HOLLOW, FLUID.
      s:=s+'body'+'0'+'iunion='+IntToStr(body[0].iunion)+ ' :'; // номер объединения
      // Информация о цвете и прозрачности.
      s:=s+'body'+'0'+'redcolor='+FloatToStr(body[0].redcolor)+ ' :';
      s:=s+'body'+'0'+'greencolor='+FloatToStr(body[0].greencolor)+ ' :';
      s:=s+'body'+'0'+'bluecolor='+FloatToStr(body[0].bluecolor)+ ' :';
      s:=s+'body'+'0'+'transparency='+FloatToStr(body[0].transparency)+ ' :';
      s:=s+'body'+'0'+'dcol='+IntToStr(body[0].dcol)+ ' :';
      s:=s+'body'+'0'+'lineWidth='+IntToStr(body[0].BodyLineWidth)+' :';
   end;
   f.Add(s);
   // количество блоков:
   s:='lb='+IntToStr(lb)+' :'+'icb='+IntToStr(icb)+' :';
   f.Add(s);

   // Сортировка блоков по возрастанию значения их priority.
   // 2 мая 2016.
   (*
    for isort:=2 to lb-1 do
   begin
	   for jsort:=lb-1 downto isort do
     begin
     		if (body[jsort-1].priority > body[jsort].priority) then
        begin
			     // swap
			     body_change:=body[jsort-1];
			     body[jsort-1]:=body[jsort];
			     body[jsort]:= body_change;
		    end;
	   end;
   end;
   *)
   // Теперь блоки отсортированы по возратанию их приоритетов.
   HeapSort(1,lb-1);


   // цикл по всем блокам :
   for i:=1 to (lb-1) do
   begin
      with (body[i]) do
      begin
         s:='body'+IntToStr(i)+'name='+name+' :';
         s:=s+'body'+IntToStr(i)+'igeometry_type='+IntToStr(igeometry_type)+' :'; // 0 - Prism, 1 - Cylinder.
         // Prism
         s:=s+'body'+IntToStr(i)+'sxS='+sxS+' :';  // записываются
         s:=s+'body'+IntToStr(i)+'syS='+syS+' :';  // параметризованные
         s:=s+'body'+IntToStr(i)+'szS='+szS+' :';  // пользователем значения
         s:=s+'body'+IntToStr(i)+'sxE='+sxE+' :';
         s:=s+'body'+IntToStr(i)+'syE='+syE+' :';
         s:=s+'body'+IntToStr(i)+'szE='+szE+' :';
         // Cylinder
         s:=s+'body'+IntToStr(i)+'iPlane='+IntToStr(iPlane)+' :'; // 1 - XY, 2 - XZ, 3 - YZ.
         s:=s+'body'+IntToStr(i)+'sxC='+sxC+' :';  // записываются
         s:=s+'body'+IntToStr(i)+'syC='+syC+' :';  // параметризованные
         s:=s+'body'+IntToStr(i)+'szC='+szC+' :';  // пользователем значения
         s:=s+'body'+IntToStr(i)+'sHcyl='+sHcyl+' :';
         s:=s+'body'+IntToStr(i)+'sR_out_cyl='+sR_out_cyl+' :';
         s:=s+'body'+IntToStr(i)+'sR_in_cyl='+sR_in_cyl+' :';
         // 18 января 2018.
         if (bCylinder2Prism) then
         begin
            // Разрешаем преобразовывать Цилиндр в Призму.
            s:=s+'body'+IntToStr(i)+'bCylinder2Prism='+'1 :';
         end
          else
         begin
            // Не разрешаем преобразовывать Цилиндр в Призму.
            s:=s+'body'+IntToStr(i)+'bCylinder2Prism='+'0 :';
         end;
         // sector, conoid
         s:=s+'body'+IntToStr(i)+'sR_out_cyl2='+sR_out_cyl2+' :';
         s:=s+'body'+IntToStr(i)+'sR_in_cyl2='+sR_in_cyl2+' :';
         s:=s+'body'+IntToStr(i)+'sangle_start='+sangle_start+' :';
         s:=s+'body'+IntToStr(i)+'sangle_end='+sangle_end+' :';
         // Polygon
         s:=s+'body'+IntToStr(i)+'iPlane_obj2='+IntToStr(iPlane_obj2)+' :'; // 1 - XY, 2 - XZ, 3 - YZ.
         s:=s+'body'+IntToStr(i)+'nsizei='+IntToStr(nsizei)+' :';
         for j := 0 to nsizei-1 do
         begin
            s:=s+'body'+IntToStr(i)+'hi'+IntToStr(j)+'='+FloatToStr(hi[j])+' :';
            s:=s+'body'+IntToStr(i)+'xi'+IntToStr(j)+'='+FloatToStr(xi[j])+' :';
            s:=s+'body'+IntToStr(i)+'yi'+IntToStr(j)+'='+FloatToStr(yi[j])+' :';
            s:=s+'body'+IntToStr(i)+'zi'+IntToStr(j)+'='+FloatToStr(zi[j])+' :';
         end;

         // emissivity:
         bOk:=true;
         if (abs(FormVariables.my_real_convert(semissW,bOk))<1.0e-12) then
         begin
             // во избежании деления на ноль.
             body[i].emissW:=0.001;
             if (FormatSettings.DecimalSeparator=',') then
          begin
             body[i].semissW:='0,001';
          end;
          if (FormatSettings.DecimalSeparator='.') then
          begin
             body[i].semissW:='0.001';
         end;
         end;
         //s:=s+FloatToStr(emissW)+' :';
         s:=s+'body'+IntToStr(i)+'semissW='+semissW+' :';
         if (abs(FormVariables.my_real_convert(semissE,bOk))<1.0e-12) then
         begin
            // во избежании деления на ноль.
            body[i].emissE:=0.001;
            if (FormatSettings.DecimalSeparator=',') then
          begin
             body[i].semissE:='0,001';
          end;
          if (FormatSettings.DecimalSeparator='.') then
          begin
             body[i].semissE:='0.001';
         end;
         end;
         //s:=s+FloatToStr(emissE)+' :';
         s:=s+'body'+IntToStr(i)+'semissE='+semissE+' :';
         if (abs(FormVariables.my_real_convert(semissS,bOk))<1.0e-12) then
         begin
             // во избежании деления на ноль.
             body[i].emissS:=0.001;
              if (FormatSettings.DecimalSeparator=',') then
          begin
             body[i].semissS:='0,001';
          end;
          if (FormatSettings.DecimalSeparator='.') then
          begin
             body[i].semissS:='0.001';
         end;
         end;
         //s:=s+FloatToStr(emissS)+' :';
         s:=s+'body'+IntToStr(i)+'semissS='+semissS+' :';
         if (abs(FormVariables.my_real_convert(semissN,bOk))<1.0e-12) then
         begin
            // во избежании деления на ноль.
            body[i].emissN:=0.001;
             if (FormatSettings.DecimalSeparator=',') then
          begin
             body[i].semissN:='0,001';
          end;
          if (FormatSettings.DecimalSeparator='.') then
          begin
             body[i].semissN:='0.001';
         end;
         end;
        // s:=s+FloatToStr(emissN)+' :';
         s:=s+'body'+IntToStr(i)+'semissN='+semissN+' :';
         if (abs(FormVariables.my_real_convert(semissB,bOk))<1.0e-12) then
         begin
            // во избежании деления на ноль.
            body[i].emissB:=0.001;
            if (FormatSettings.DecimalSeparator=',') then
            begin
               body[i].semissB:='0,001';
            end;
            if (FormatSettings.DecimalSeparator='.') then
            begin
               body[i].semissB:='0.001';
            end;
         end;
         //s:=s+FloatToStr(emissB)+' :';
         s:=s+'body'+IntToStr(i)+'semissB='+semissB+' :';
         if (abs(FormVariables.my_real_convert(semissT,bOk))<1.0e-12) then
         begin
            // во избежании деления на ноль.
            body[i].emissT:=0.001;
             if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissT:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissT:='0.001';
             end;
         end;
         //s:=s+FloatToStr(emissT)+' :';
         s:=s+'body'+IntToStr(i)+'semissT='+body[i].semissT+' :';
         // Считать ли излучение внутри блока ?
         s:=s+'body'+IntToStr(i)+'binternalRadiation='+IntToStr(body[i].binternalRadiation)+' :';
         s:=s+'body'+IntToStr(i)+'imatid='+IntToStr(body[i].imatid)+' :'; // идентификатор рабочего материала.

         // Фиксация боковой стенки цилиндра при расчёте прочности.
         if (body[i].CylinderFixed=true) then
         begin
            s:=s+'body'+IntToStr(i)+'CylinderFixed='+'1 :';
         end
           else
         begin
            s:=s+'body'+IntToStr(i)+'CylinderFixed='+'0 :';
         end;

         //s:=s+spower+ ' :'; // параметризованная пользователем мощность тепловыделения блока
         s:=s+'body'+IntToStr(i)+'n_power='+IntToStr(body[i].n_power)+ ' :';
         for i_4 := 0 to (body[i].n_power-1) do
         begin
            s:=s+'body'+IntToStr(i)+'Temp_power'+IntToStr(i_4)+'='+FloatToStr(body[i].temp_power[i_4])+ ' :'+'body'+IntToStr(i)+'Arr_power'+IntToStr(i_4)+'='+body[i].arr_s_power[i_4]+ ' :';
         end;
         // зависимость мощности тепловыделения в блоке от времени.
         s:=s+'body'+IntToStr(i)+'ipower_time_depend='+IntToStr(body[i].ipower_time_depend)+' :';
         s:=s+'body'+IntToStr(i)+'itype='+IntToStr(body[i].itype)+ ' :'; // тип блока : SOLID, HOLLOW, FLUID.
         s:=s+'body'+IntToStr(i)+'iunion='+IntToStr(body[i].iunion)+ ' :'; // номер объединения
         // Информация о цвете и прозрачности.
         s:=s+'body'+IntToStr(i)+'redcolor='+FloatToStr(body[i].redcolor)+ ' :';
         s:=s+'body'+IntToStr(i)+'greencolor='+FloatToStr(body[i].greencolor)+ ' :';
         s:=s+'body'+IntToStr(i)+'bluecolor='+FloatToStr(body[i].bluecolor)+ ' :';
         s:=s+'body'+IntToStr(i)+'transparency='+FloatToStr(body[i].transparency)+ ' :';
         s:=s+'body'+IntToStr(i)+'dcol='+IntToStr(body[i].dcol)+ ' :';
         s:=s+'body'+IntToStr(i)+'lineWidth='+IntToStr(body[i].BodyLineWidth)+' :';
      end;
      f.Add(s);
   end;
   // количество источников тепла:
   s:='ls='+IntToStr(ls)+' :'+'ics='+IntToStr(ics)+' :';
   f.Add(s);
   // цикл по всем источникам тепла:
   for i:=0 to (ls-1) do
   begin
      with (source[i]) do
      begin
         s:='source'+IntToStr(i)+'name='+name+' :';
         // мощность тепловыделения, плоскость и координаты:
         s:=s+'source'+IntToStr(i)+'spower='+spower+' :';  // параметризованная пользователем мощность
         s:=s+'source'+IntToStr(i)+'itempdep='+IntToStr(itempdep)+' :';
         s:=s+'source'+IntToStr(i)+'id_table='+IntToStr(id_table)+' :'; // идентификатор таблицы задания мощностей
         s:=s+'source'+IntToStr(i)+'soperatingoffsetdrain='+soperatingoffsetdrain+' :'; // смещение стока.

         s:=s+'source'+IntToStr(i)+'iPlane='+IntToStr(iPlane)+' :'; // плоскость в которой лежит источник тепла
         s:=s+'source'+IntToStr(i)+'sxS='+sxS+' :';  // записываются
         s:=s+'source'+IntToStr(i)+'syS='+syS+' :';  // параметризованные
         s:=s+'source'+IntToStr(i)+'szS='+szS+' :';  // пользователем значения
         s:=s+'source'+IntToStr(i)+'sxE='+sxE+' :';
         s:=s+'source'+IntToStr(i)+'syE='+syE+' :';
         s:=s+'source'+IntToStr(i)+'szE='+szE+' :';
         s:=s+'source'+IntToStr(i)+'iunion='+IntToStr(iunion)+ ' :'; // номер объединения
      end;
      f.Add(s);
   end;
   // количество твёрдых стенок
   // твёрдая стенка может быть только границей кабинета.
   s:='lw='+IntToStr(lw)+' :'+'icw='+IntToStr(icw)+' :';
   f.Add(s);
   // цикл по всем твёрдым стенкам:
   for i:=0 to (lw-1) do
   begin
      with (wall[i]) do
      begin
         s:='wall'+IntToStr(i)+'name='+name+' :'; // имя
         // тип краевого условия, температура и тепловой поток,
         //  плоскость и координаты:
         s:=s+'wall'+IntToStr(i)+'family='+IntToStr(family)+' :'; // тип краевого условия
         s:=s+'wall'+IntToStr(i)+'Tamb='+FloatToStr(Tamb)+' :'; // температура на идеальном теплооотводе
         bOk:=true;
         if (family=3) then
         begin
            //s:=s+FloatToStr(heat_transfer_coefficient)+' :'; // коэффициент теплоотдачи.
            s:=s+'wall'+IntToStr(i)+'sheat_transfer_coefficient='+FloatToStr(FormVariables.my_real_convert(sheat_transfer_coefficient,bOk))+' :';
         end
         else
         begin
            //s:=s+FloatToStr(emissivity)+' :';// излучательная способность.
            s:=s+'wall'+IntToStr(i)+'semissivity='+FloatToStr(FormVariables.my_real_convert(semissivity,bOk))+' :';
         end;
         s:=s+'wall'+IntToStr(i)+'ViewFactor='+FloatToStr(ViewFactor)+' :'; // Фактор видимости.
         s:=s+'wall'+IntToStr(i)+'HF='+FloatToStr(HF)+' :'; // для граничного условия 2 или 3 рода.
         if (bsymmetry) then s:=s+'wall'+IntToStr(i)+'bsymmetry='+'1 :' else s:=s+'wall'+IntToStr(i)+'bsymmetry='+'0 :';
         if (bpressure) then s:=s+'wall'+IntToStr(i)+'bpressure='+'1 :' else s:=s+'wall'+IntToStr(i)+'bpressure='+'0 :';
         if (bopening) then s:=s+'wall'+IntToStr(i)+'bopening='+'1 :' else s:=s+'wall'+IntToStr(i)+'bopening='+'0 :';

         s:=s+'wall'+IntToStr(i)+'Vx='+FloatToStr(Vx)+' :';
         s:=s+'wall'+IntToStr(i)+'Vy='+FloatToStr(Vy)+' :';
         s:=s+'wall'+IntToStr(i)+'Vz='+FloatToStr(Vz)+' :';
         s:=s+'wall'+IntToStr(i)+'Pressure='+FloatToStr(P)+' :';
         s:=s+'wall'+IntToStr(i)+'ithermal_stress_boundary_condition='+IntToStr(ithermal_stress_boundary_condition)+ ' :'; // Thermal-Stress.
         s:=s+'wall'+IntToStr(i)+'xForce='+FloatToStr(xForce)+' :';   // Приложенная сила в Ньютонах.
         s:=s+'wall'+IntToStr(i)+'yForce='+FloatToStr(yForce)+' :';
         s:=s+'wall'+IntToStr(i)+'zForce='+FloatToStr(zForce)+' :';


         s:=s+'wall'+IntToStr(i)+'iPlane='+IntToStr(iPlane)+' :'; // плоскость в которой лежит источник тепла
         s:=s+'wall'+IntToStr(i)+'sxS='+sxS+' :';  // записываются
         s:=s+'wall'+IntToStr(i)+'syS='+syS+' :';  // параметризованные
         s:=s+'wall'+IntToStr(i)+'szS='+szS+' :';  // пользователем
         s:=s+'wall'+IntToStr(i)+'sxE='+sxE+' :';  // значения
         s:=s+'wall'+IntToStr(i)+'syE='+syE+' :';
         s:=s+'wall'+IntToStr(i)+'szE='+szE+' :';
         s:=s+'wall'+IntToStr(i)+'iunion='+IntToStr(iunion)+ ' :'; // номер объединения
         s:=s+'wall'+IntToStr(i)+'cabinet_depend='+IntToStr(cabinet_depend)+ ' :';// cabinet depend признак.
      end;
      f.Add(s);
   end;

   // Запись информации о решаемых уравнениях.
   // Теплопередча, Деформации, Гидродинамика.
   s:='solver_itemper='+IntToStr(egddata.itemper)+' :'+'solver_StaticStructural='+IntToStr(egddata.iStaticStructural)+' :'+'solver_imaxflD='+IntToStr(egddata.imaxflD)+' :';
   f.Add(s);
   for i:=0 to egddata.imaxflD-1 do
   begin
      s:='myflmod'+IntToStr(i)+'xc='+FloatToStr(egddata.myflmod[i].xc)+' :'+'myflmod'+IntToStr(i)+'yc='+FloatToStr(egddata.myflmod[i].yc)+' :';
      s:=s+'myflmod'+IntToStr(i)+'zc='+FloatToStr(egddata.myflmod[i].zc)+' :';
      s:=s+'myflmod'+IntToStr(i)+'iflow='+IntToStr(egddata.myflmod[i].iflow)+' :';
      s:=s+'myflmod'+IntToStr(i)+'iflowregime='+IntToStr(egddata.myflmod[i].iflowregime)+' :';
      s:=s+'myflmod'+IntToStr(i)+'iturbmodel='+IntToStr(egddata.myflmod[i].iturbmodel)+' :';
      // параметры модели Смагоринского
      s:=s+'myflmod'+IntToStr(i)+'SmagConst='+FloatToStr(egddata.myflmod[i].SmagConst)+' :';
      s:=s+'myflmod'+IntToStr(i)+'iDynamicStressGermano='+IntToStr(egddata.myflmod[i].iDynamicStressGermano)+' :';
      s:=s+'myflmod'+IntToStr(i)+'iLimitersCs='+IntToStr(egddata.myflmod[i].iLimitersCs)+' :';
      s:=s+'myflmod'+IntToStr(i)+'minCs='+FloatToStr(egddata.myflmod[i].minCs)+' :';
      s:=s+'myflmod'+IntToStr(i)+'maxCs='+FloatToStr(egddata.myflmod[i].maxCs)+' :';
      s:=s+'myflmod'+IntToStr(i)+'itypeFiltrGermano='+IntToStr(egddata.myflmod[i].itypeFiltrGermano)+' :';
      s:=s+'myflmod'+IntToStr(i)+'roughness='+FloatToStr(egddata.myflmod[i].roughness)+' :';
      s:=s+'myflmod'+IntToStr(i)+'rRimult='+FloatToStr(egddata.myflmod[i].rRimult)+' :';
      s:=s+'myflmod'+IntToStr(i)+'rSelectiveAngle='+FloatToStr(egddata.myflmod[i].rSelectiveAngle)+' :';
      s:=s+'myflmod'+IntToStr(i)+'ipowerroughness='+IntToStr(egddata.myflmod[i].ipowerroughness)+' :';
      s:=s+'myflmod'+IntToStr(i)+'itypefiltr='+IntToStr(egddata.myflmod[i].itypefiltr)+' :';
      // учёт неравномерности сетки.
      if (egddata.myflmod[i].bfdelta) then
      begin
         s:=s+'myflmod'+IntToStr(i)+'bfdelta='+'1 :';
      end
      else
      begin
         s:=s+'myflmod'+IntToStr(i)+'bfdelta='+'0 :';
      end;
      // модель Смагоринского-Лиллу.
      if (egddata.myflmod[i].bSmagorinsky_Lilly) then
      begin
         s:=s+'myflmod'+IntToStr(i)+'bSmagorinsky_Lilly='+'1 :';
      end
      else
      begin
         s:=s+'myflmod'+IntToStr(i)+'bSmagorinsky_Lilly='+'0 :';
      end;
      // учёт шероховатости стенки.
      if (egddata.myflmod[i].bsurface_roughness) then
      begin
         s:=s+'myflmod'+IntToStr(i)+'bsurface_roughness='+'1 :';
      end
      else
      begin
         s:=s+'myflmod'+IntToStr(i)+'bsurface_roughness='+'0 :';
      end;
      // течения с кривизной линий тока
      if (egddata.myflmod[i].bSwirlamendment) then
      begin
         s:=s+'myflmod'+IntToStr(i)+'bSwirlamendment='+'1 :';
      end
      else
      begin
         s:=s+'myflmod'+IntToStr(i)+'bSwirlamendment='+'0 :';
      end;
      // модель Selective Smagorinsky
      if (egddata.myflmod[i].bSelectiveSmagorinsky) then
      begin
         s:=s+'myflmod'+IntToStr(i)+'bSelectiveSmagorinsky='+'1 :';
      end
      else
      begin
         s:=s+'myflmod'+IntToStr(i)+'bSelectiveSmagorinsky='+'0 :';
      end;
      f.Add(s);
   end;

    // Сохраняем параметры освещения.

    s:='light_remis='+FloatToStr(remis)+' :'+'light_rspec='+FloatToStr(rspec)+' :'+'light_matdiff='+FloatToStr(matdiff)+' :';
    f.Add(s);
    s:='light_matamb='+FloatToStr(matamb)+' :'+'light_matt='+FloatToStr(matt)+' :'+'light_mr='+FloatToStr(mr)+' :';
    f.Add(s);
    s:='light_glamb0='+FloatToStr(glamb0)+' :'+'light_mldx='+FloatToStr(mldx)+' :'+'light_mldy='+FloatToStr(mldy)+' :';
    f.Add(s);
    s:='light_lamb='+FloatToStr(lamb)+' :'+'light_lspec='+FloatToStr(lspec)+' :'+'light_ldiff='+FloatToStr(ldiff)+' :';
    f.Add(s);
    s:='light_lithtangle='+FloatToStr(lithtangle)+' :'+'light_lithtexponent='+FloatToStr(lithtexponent)+' :'+'light_lithtangle1='+FloatToStr(lithtangle1)+' :';
    f.Add(s);
    s:='light_lithtexponent1='+FloatToStr(lithtexponent1)+' :'+'light_mldx1='+FloatToStr(mldx1)+' :'+'light_mldy1='+FloatToStr(mldy1)+' :';
    f.Add(s);
    s:='light_matt1='+FloatToStr(matt1)+' :'+'light_mr1='+FloatToStr(mr1)+' :'+'light_lamb1='+FloatToStr(lamb1)+' :';
    f.Add(s);
    s:='light_lspec1='+FloatToStr(lspec1)+' :'+'light_ldiff1='+FloatToStr(ldiff1)+' :'+'light_rblick='+IntToStr(rblick)+' :';
    f.Add(s);

    // Сохраняем булевы индикаторы связанные с освещением.
    if (chkOnLitht1.Checked=True) then
    begin
       s:='light_OnLitht1='+'1 :';
    end
     else
    begin
       s:='light_OnLitht1='+'0 :';
    end;

    if (chkDiskretSource1.Checked=True) then
    begin
       s:=s+'light_DiskretSource1='+'1 :';
    end
     else
    begin
       s:=s+'light_DiskretSource1='+'0 :';
    end;

    if (chkdistance1.Checked=True) then
    begin
       s:=s+'light_distance1='+'1 :';
    end
     else
    begin
       s:=s+'light_distance1='+'0 :';
    end;

    if (CheckBoxdistance.Checked=True) then
    begin
       s:=s+'light_distance='+'1 :';
    end
     else
    begin
       s:=s+'light_distance='+'0 :';
    end;

     if (CheckBoxOnLitht.Checked=True) then
    begin
       s:=s+'light_OnLitht='+'1 :';
    end
     else
    begin
       s:=s+'light_OnLitht='+'0 :';
    end;

     if (CheckBoxPointSources.Checked=True) then
    begin
       s:=s+'light_PointSources='+'1 :';
    end
     else
    begin
       s:=s+'light_PointSources='+'0 :';
    end;

    if (chkblick.Checked=True) then
    begin
       s:=s+'light_chkblick='+'1 :';
    end
     else
    begin
       s:=s+'light_chkblick='+'0 :';
    end;

     if (chkemis.Checked=True) then
    begin
       s:=s+'light_chkemis='+'1 :';
    end
     else
    begin
       s:=s+'light_chkemis='+'0 :';
    end;

     if (chkGlobalAmbient.Checked=True) then
    begin
       s:=s+'light_chkGlobalAmbient='+'1 :';
    end
     else
    begin
       s:=s+'light_chkGlobalAmbient='+'0 :';
    end;

     if (chksmooter.Checked=True) then
    begin
       s:=s+'light_chksmooter='+'1 :';
    end
     else
    begin
       s:=s+'light_chksmooter='+'0 :';
    end;

     if (chkSpecular.Checked=True) then
    begin
       s:=s+'light_chkSpecular='+'1 :';
    end
     else
    begin
       s:=s+'light_chkSpecular='+'0 :';
    end;
    f.Add(s);

    if (FormatSettings.DecimalSeparator=',') then
    begin
        // заменить все точки в FormSpeedInitialization на запятые.
        s:=FormSpeedInitialization.EditVx.Text;
        FormSpeedInitialization.EditVx.Text:=StringReplace(s,'.',',',[rfReplaceAll]);

        s:=FormSpeedInitialization.EditVy.Text;
        FormSpeedInitialization.EditVy.Text:=StringReplace(s,'.',',',[rfReplaceAll]);

        s:=FormSpeedInitialization.EditVz.Text;
        FormSpeedInitialization.EditVz.Text:=StringReplace(s,'.',',',[rfReplaceAll]);

    end;
    if (FormatSettings.DecimalSeparator='.') then
    begin
        // заменить все точки в FormSpeedInitialization на запятые.
        s:=FormSpeedInitialization.EditVx.Text;
        FormSpeedInitialization.EditVx.Text:=StringReplace(s,',','.',[rfReplaceAll]);

        s:=FormSpeedInitialization.EditVy.Text;
        FormSpeedInitialization.EditVy.Text:=StringReplace(s,',','.',[rfReplaceAll]);

        s:=FormSpeedInitialization.EditVz.Text;
        FormSpeedInitialization.EditVz.Text:=StringReplace(s,',','.',[rfReplaceAll]);

    end;

    // additional setting 24.07.2020
    s:='VxInitialization_Speed='+FormSpeedInitialization.EditVx.Text+' :';
    f.Add(s);
    s:='VyInitialization_Speed='+FormSpeedInitialization.EditVy.Text+' :';
    f.Add(s);
    s:='VzInitialization_Speed='+FormSpeedInitialization.EditVz.Text+' :';
    f.Add(s);
    s:='StaticStructuralSolverSetting='+IntToStr(FormSetting.ComboBoxStaticStructuralSolverSetting.ItemIndex)+' :';
    f.Add(s);
    s:='MeshGenAlgo_id='+IntToStr(MeshForm.ComboBoxmeshgen.ItemIndex)+' :';
    f.Add(s);
    if (MeshForm.CheckBoxALICE.Checked) then
    begin
       // Adaptive Local Refinement Mesh
       s:='AdaptiveLocalRefinementMesh_Checker='+'1 :';
    end
    else
    begin
       // Structural Mesh
       s:='AdaptiveLocalRefinementMesh_Checker='+'0 :';
    end;
    f.Add(s);

    s:='ALICE_Mesh_Type='+IntToStr(MeshForm.ComboBoxALICEType.ItemIndex)+' :';
    f.Add(s);

    if (FormXYPlot.bfirst_zapusk_XYPlot) then
    begin

       // При считывании тепловой модели инициализируем XYPlot.
       if (ls>0) then
       begin
          // Инициализируем геометрическим центром первого источника тепла при его наличии.
          FormXYPlot.EditXo.Text:=FloatToStr(0.5*(source[0].xS+source[0].xE));
          FormXYPlot.EditYo.Text:=FloatToStr(0.5*(source[0].yS+source[0].yE));
          FormXYPlot.EditZo.Text:=FloatToStr(0.5*(source[0].zS+source[0].zE));

          if (ls>1) then
          begin
             if (abs(source[0].xS-source[1].xS)>1.0e-23) then
             begin
                FormXYPlot.ComboBoxdirectional.ItemIndex:=0; // X - directional
             end;
             if (abs(source[0].yS-source[1].yS)>1.0e-23) then
             begin
                FormXYPlot.ComboBoxdirectional.ItemIndex:=1; // Y - directional
             end;
             if (abs(source[0].zS-source[1].zS)>1.0e-23) then
             begin
                FormXYPlot.ComboBoxdirectional.ItemIndex:=2; // Z - directional
             end;
          end;
       end
        else
       begin
          // Инициализируем геометрическим центром кабинета.
          FormXYPlot.EditXo.Text:=FloatToStr(0.5*(body[0].xS+body[0].xE));
          FormXYPlot.EditYo.Text:=FloatToStr(0.5*(body[0].yS+body[0].yE));
          FormXYPlot.EditZo.Text:=FloatToStr(0.5*(body[0].zS+body[0].zE));
          i_3:=-1;
          for i_2 := 0 to lb-1 do
          begin
             if (body[i_2].n_power>0) then
             begin
                if ((i_3>-1)and(abs(body[i_2].arr_power[0])>0.0)) then
                begin
                   if (abs(body[i_3].xS-body[i_2].xS)>1.0e-23) then
                   begin
                      FormXYPlot.ComboBoxdirectional.ItemIndex:=0; // X - directional
                   end;
                   if (abs(body[i_3].yS-body[i_2].yS)>1.0e-23) then
                   begin
                      FormXYPlot.ComboBoxdirectional.ItemIndex:=1; // Y - directional
                   end;
                   if (abs(body[i_3].zS-body[i_2].zS)>1.0e-23) then
                   begin
                      FormXYPlot.ComboBoxdirectional.ItemIndex:=2; // Z - directional
                   end;
                   break;
                end;
                if ((i_3=-1)and(abs(body[i_2].arr_power[0])>0.0)) then
                begin
                   i_3:=i_2;
                   FormXYPlot.EditXo.Text:=FloatToStr(0.5*(body[i_2].xS+body[i_2].xE));
                   FormXYPlot.EditYo.Text:=FloatToStr(0.5*(body[i_2].yS+body[i_2].yE));
                   FormXYPlot.EditZo.Text:=FloatToStr(0.5*(body[i_2].zS+body[i_2].zE));
                end;
             end;
          end;
       end;

       FormXYPlot.bfirst_zapusk_XYPlot:=false;

    end;

    s:='XYPlotXo='+FormXYPlot.EditXo.Text+' :';
    f.Add(s);
    s:='XYPlotYo='+FormXYPlot.EditYo.Text+' :';
    f.Add(s);
    s:='XYPlotZo='+FormXYPlot.EditZo.Text+' :';
    f.Add(s);
    s:='line_directional='+IntToStr(FormXYPlot.ComboBoxdirectional.ItemIndex)+' :';
    f.Add(s);

    // Save AMGCL settings 25.07.2020
    s:='AMGCL_ddemidov_smoother='+IntToStr(FormAMGCLParameters.RadioGroupAMGCLsmoother1.ItemIndex)+' :';
    f.Add(s);
    s:='AMGCL_ddemidov_AMG_Coarseng='+IntToStr(FormAMGCLParameters.RadioGroupAMGCLCoarseningType.ItemIndex)+' :';
    f.Add(s);
    s:='AMGCL_ddemidov_Krjlov_iterator='+IntToStr(FormAMGCLParameters.ComboBoxIterator.ItemIndex)+' :';
    f.Add(s);

    // Save amg1r5 settings 27.07.2020
    s:='inumber_processors='+IntToStr(FormSetting.ComboBoxNumberProcessors.ItemIndex)+' :';
    f.Add(s);
    s:='amg1r5_Stailization='+IntToStr(Formamg1r5Parameters.ComboBoxStabilization.ItemIndex)+' :';
    f.Add(s);
    s:='amg1r5_number_presmoothers='+IntToStr(Formamg1r5Parameters.ComboBoxNumber_of_smootherssteps.ItemIndex)+' :';
    f.Add(s);
    s:='amg1r5_number_postsmoothers='+IntToStr(Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex)+' :';
    f.Add(s);
    s:='amg1r5_type_algorithm_presmoother='+IntToStr(Formamg1r5Parameters.ComboBoxTypeSmoother.ItemIndex)+' :';
    f.Add(s);
    s:='amg1r5_type_algorithm_postsmoother='+IntToStr(Formamg1r5Parameters.ComboBoxTypePostSmoother.ItemIndex)+' :';
    f.Add(s);
    s:='amg1r5_Strong_threshold='+Trim(Formamg1r5Parameters.Editstrongthreshold.Text)+' :';
    f.Add(s);
    s:='amg1r5_F_to_F='+Trim(Formamg1r5Parameters.EditF2F.Text)+' :';
    f.Add(s);
    if (Formamg1r5Parameters.CheckBox_amg1r6.Checked=true) then
    begin
       s:='amg1r5_amg1r6_version_aggregator='+'1 :';
    end
    else
    begin
       s:='amg1r5_amg1r6_version_aggregator='+'0 :';
    end;
    f.Add(s);

    s:='PressureVelocityCoupling='+IntToStr(FormSetting.ComboBoxPressureVelocityCoupling.ItemIndex)+' :';
    f.Add(s);
    s:='FlowConvectionSchemePrefix_id='+IntToStr(FormSetting.ComboBoxFlowSchemePrefix.ItemIndex)+' :';
    f.Add(s);
    s:='FlowConvectionScheme_id='+IntToStr(FormSetting.ComboBoxFlowScheme.ItemIndex)+' :';
    f.Add(s);
    s:='TemperatureConvectionScheme_id='+IntToStr(FormSetting.ComboBoxSchemeTemperature.ItemIndex)+' :';
    f.Add(s);
    s:='ILUK_lfil_number='+IntToStr(FormSetting.ComboBox_lfil.ItemIndex)+' :';
    f.Add(s);
    s:='FGMRes_mrestart_number='+IntToStr(FormSetting.ComboBox_m_restart_for_gmres.ItemIndex)+' :';
    f.Add(s);

    // Сохранение настроек Румба v.0.14 решателя.
    // 28.07.2020.
    s:='Maximum_reduced_levels_Temperature='+IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevels.ItemIndex)+' :';
    f.Add(s);
    s:='Maximum_reduced_levels_Speed='+IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevelsSpeed.ItemIndex)+' :';
    f.Add(s);
    s:='Maximum_reduced_levels_Pressure='+IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevelsPressure.ItemIndex)+' :';
    f.Add(s);
    s:='Maximum_reduced_levels_Stress='+IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevelsStress.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_nFinnest='+IntToStr(Form_amg_manager.ComboBoxnFinnest.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_nFinnestSpeed='+IntToStr(Form_amg_manager.ComboBoxnFinnestSpeed.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_nFinnestPressure='+IntToStr(Form_amg_manager.ComboBoxnFinnestPressure.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_nFinnestStress='+IntToStr(Form_amg_manager.ComboBoxnFinnestStress.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_number_presmoothers='+IntToStr(Form_amg_manager.ComboBoxnumberpresmothers.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_number_presmoothersSpeed='+IntToStr(Form_amg_manager.ComboBoxnumberpresmothersSpeed.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_number_presmoothersPressure='+IntToStr(Form_amg_manager.ComboBoxnumberpresmothersPressure.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_number_presmoothersStress='+IntToStr(Form_amg_manager.ComboBoxnumberpresmoothersStress.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_number_postsmoothers='+IntToStr(Form_amg_manager.ComboBoxnumberpostsweeps.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_number_postsmoothersSpeed='+IntToStr(Form_amg_manager.ComboBoxnumberpostsweepsSpeed.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_number_postsmoothersPressure='+IntToStr(Form_amg_manager.ComboBoxnumberpostsweepsPressure.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_number_postsmoothersStress='+IntToStr(Form_amg_manager.ComboBoxnumberpostsweepsStress.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_memory_size='+IntToStr(Form_amg_manager.ComboBoxmemorysize.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_memory_sizeSpeed='+IntToStr(Form_amg_manager.ComboBoxmemorysizeSpeed.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_memory_sizePressure='+IntToStr(Form_amg_manager.ComboBoxmemorysizePressure.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_memory_sizeStress='+IntToStr(Form_amg_manager.ComboBoxmemorysizeStress.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_interpolation_id='+IntToStr(Form_amg_manager.ComboBoxinterpolation.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_interpolation_id_Speed='+IntToStr(Form_amg_manager.ComboBoxinterpolationSpeed.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_interpolation_id_Pressure='+IntToStr(Form_amg_manager.ComboBoxinterpolationPressure.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_interpolation_id_Stress='+IntToStr(Form_amg_manager.ComboBoxinterpollationStress.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_sort_algo='+IntToStr(Form_amg_manager.ComboBoxSort.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_Relaxation_Temperature='+IntToStr(Form_amg_manager.ComboBoxsmoothertypeTemperature.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_Relaxation_Speed='+IntToStr(Form_amg_manager.ComboBoxsmoothertypeSpeed.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_Relaxation_Pressure='+IntToStr(Form_amg_manager.ComboBoxsmoothertypePressure.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_Relaxation_Stress='+IntToStr(Form_amg_manager.ComboBoxsmoothertypeStress.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_amg_splitting_coarsening='+IntToStr(Form_amg_manager.ComboBoxcoarseningTemp.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_amg_splitting_coarseningSpeed='+IntToStr(Form_amg_manager.ComboBoxcoarseningSpeed.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_amg_splitting_coarseningPressure='+IntToStr(Form_amg_manager.ComboBoxcoarseningPressure.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_amg_splitting_coarseningStress='+IntToStr(Form_amg_manager.ComboBoxcoarseningStress.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_Stabilization='+IntToStr(Form_amg_manager.ComboBoxStabilizationTemp.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_StabilizationSpeed='+IntToStr(Form_amg_manager.ComboBoxStabilizationSpeed.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_StabilizationPressure='+IntToStr(Form_amg_manager.ComboBoxStabilizationPressure.ItemIndex)+' :';
    f.Add(s);
    s:='Rumba_StabilizationStress='+IntToStr(Form_amg_manager.ComboBoxStabilizationStress.ItemIndex)+' :';
    f.Add(s);
    s:='C_F_decomposition_algorithms_and_data_structure='+IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Temperature.ItemIndex)+' :';
    f.Add(s);
    s:='C_F_decomposition_algorithms_and_data_structureSpeed='+IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Speed.ItemIndex)+' :';
    f.Add(s);
    s:='C_F_decomposition_algorithms_and_data_structurePressure='+IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Pressure.ItemIndex)+' :';
    f.Add(s);
    s:='C_F_decomposition_algorithms_and_data_structureStress='+IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Stress.ItemIndex)+' :';
    f.Add(s);

    // 30.07.2020
    s:='Rumba_threshold_Temperature='+Trim(Form_amg_manager.Editthreshold.Text)+' :';
    f.Add(s);
    s:='Rumba_threshold_Speed='+Trim(Form_amg_manager.EditthresholdSpeed.Text)+' :';
    f.Add(s);
    s:='Rumba_threshold_Pressure='+Trim(Form_amg_manager.EditthresholdPressure.Text)+' :';
    f.Add(s);
    s:='Rumba_threshold_Stress='+Trim(Form_amg_manager.EditthresholdStress.Text)+' :';
    f.Add(s);
    s:='Rumba_truncation_interpolation_Temp='+Trim(Form_amg_manager.Edit_truncation_T.Text)+' :';
    f.Add(s);
    s:='Rumba_truncation_interpolation_Speed='+Trim(Form_amg_manager.Edit_truncation_Speed.Text)+' :';
    f.Add(s);
    s:='Rumba_truncation_interpolation_Pressure='+Trim(Form_amg_manager.Edit_truncation_Pressure.Text)+' :';
    f.Add(s);
    s:='Rumba_truncation_interpolation_Stress='+Trim(Form_amg_manager.Edittruncation_Stress.Text)+' :';
    f.Add(s);
    s:='Rumba_F2F_Temperature='+Trim(Form_amg_manager.EditmagicT.Text)+' :';
    f.Add(s);
    s:='Rumba_F2F_Speed='+Trim(Form_amg_manager.EditmagicSpeed.Text)+' :';
    f.Add(s);
    s:='Rumba_F2F_Pressure='+Trim(Form_amg_manager.EditmagicPressure.Text)+' :';
    f.Add(s);
    s:='Rumba_F2F_Stress='+Trim(Form_amg_manager.EditmagicStress.Text)+' :';
    f.Add(s);

    if (Form_amg_manager.CheckBoxDiagonalDominant.Checked=true) then
    begin
       s:='Rumba_Diagonal_dominant='+'1 :';
    end
    else
    begin
       s:='Rumba_Diagonal_dominant='+'0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxtruncationT.Checked=true) then
    begin
       s:='Rumba_truncationT='+'1 :';
    end
    else
    begin
       s:='Rumba_truncationT='+'0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxtruncationSpeed.Checked=true) then
    begin
       s:='Rumba_truncationSpeed='+'1 :';
    end
    else
    begin
       s:='Rumba_truncationSpeed='+'0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxtruncationPressure.Checked=true) then
    begin
       s:='Rumba_truncationPressure='+'1 :';
    end
    else
    begin
       s:='Rumba_truncationPressure='+'0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxtruncationStress.Checked=true) then
    begin
       s:='Rumba_truncationStress='+'1 :';
    end
    else
    begin
       s:='Rumba_truncationStress='+'0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxStrongTranspose.Checked=true) then
    begin
       s:='Rumba_StrongTranspose='+'1 :';
    end
    else
    begin
       s:='Rumba_StrongTranspose='+'0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxprintlogTemperature.Checked=true) then
    begin
       s:='Rumba_PrintLogTemperature='+'1 :';
    end
    else
    begin
       s:='Rumba_PrintLogTemperature='+'0 :';
    end;
    f.Add(s);
     if (Form_amg_manager.CheckBoxprintlogSpeed.Checked=true) then
    begin
       s:='Rumba_PrintLogSpeed='+'1 :';
    end
    else
    begin
       s:='Rumba_PrintLogSpeed='+'0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxprintlogPressure.Checked=true) then
    begin
       s:='Rumba_PrintLogPressure='+'1 :';
    end
    else
    begin
       s:='Rumba_PrintLogPressure='+'0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxprintlogStress.Checked=true) then
    begin
       s:='Rumba_PrintLogStress='+'1 :';
    end
    else
    begin
       s:='Rumba_PrintLogStress='+'0 :';
    end;
    f.Add(s);
     if (Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked=true) then
    begin
       s:='Rumba_TemperatureMatrixPortrait='+'1 :';
    end
    else
    begin
       s:='Rumba_TemperatureMatrixPortrait='+'0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked=true) then
    begin
       s:='Rumba_SpeedMatrixPortrait='+'1 :';
    end
    else
    begin
       s:='Rumba_SpeedMatrixPortrait='+'0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked=true) then
    begin
       s:='Rumba_PressureMatrixPortrait='+'1 :';
    end
    else
    begin
       s:='Rumba_PressureMatrixPortrait='+'0 :';
    end;
    f.Add(s);
    if (Form_amg_manager.CheckBoxStressMatrixPortrait.Checked=true) then
    begin
       s:='Rumba_StressMatrixPortrait='+'1 :';
    end
    else
    begin
       s:='Rumba_StressMatrixPortrait='+'0 :';
    end;
    f.Add(s);


    //if (Pos('.txt',filename)>0) then
    //begin
      // filename:=StringReplace(filename,'.txt','',[rfReplaceAll, rfIgnoreCase]);
    //end;
    // f.SaveToFile(filename+'.txt'); // сохранение результата

    if SaveDialog1.Execute then
    begin
       filename:=SaveDialog1.FileName;
       if (Pos('.txt',filename)>0) then
       begin
          filename:=StringReplace(filename,'.txt','',[rfReplaceAll, rfIgnoreCase]);
       end;

       f.SaveToFile(filename+'.txt'); // сохранение результата
       MainMemo.Lines.Add('File '+filename+'.txt successfully written.');
    end;

    f.Free;
    //MainMemo.Lines.Add('File '+filename+'.txt  successfully written.');
end; // NewWriteFile();

begin
   //OldWriteFile();
   // Данный формат записи модели  в текстовый  файл будет поддерживать
   // и все предыдущие модели, создаваемые на протяжении ряда лет,
   // обеспечивая при этом возможность дальнейшего развития программы.
   NewWriteFile();  // 14.10.2017
end;

// 3 января 2017, 30.05.2021.
// Вызов для построения графика по одной из пространственных координат.
procedure TLaplas.XYPlot1Click(Sender: TObject);
begin
      // вызов программы tecplot360
         // WinExec('C:/Program Files (x86)/Tecplot/Tec360 2008/bin/tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
     if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
     begin
        WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe xyplotT1.PLT'),SW_SHOWNORMAL);
     end
     else
     begin
     if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
        begin
           WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe xyplotT1.PLT',SW_SHOWNORMAL);
        end
         else
        begin
           if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
           begin
              WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe xyplotT1.PLT',SW_SHOWNORMAL);
           end
            else
           begin
              if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
              begin
                WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe xyplotT1.PLT',SW_SHOWNORMAL);
              end
               else
              begin
                 if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                 begin
                    WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe xyplotT1.PLT',SW_SHOWNORMAL);
                 end
                  else
                 begin
                    Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 unfound.');
                 end;
              end;
           end;
        end;
     end;
end;

procedure TLaplas.XYPlot2Click(Sender: TObject);
begin
   // Устанавливаем единицы измерения.
   case ComboBoxlength.ItemIndex of
     0 : begin
            // m
            FormXYPlot.LabelXdim.Caption:='m';
            FormXYPlot.LabelYdim.Caption:='m';
            FormXYPlot.LabelZdim.Caption:='m';
         end;
     1 : begin
            // mm
            FormXYPlot.LabelXdim.Caption:='mm';
            FormXYPlot.LabelYdim.Caption:='mm';
            FormXYPlot.LabelZdim.Caption:='mm';
         end;
     2 : begin
            // um
            FormXYPlot.LabelXdim.Caption:='um';
            FormXYPlot.LabelYdim.Caption:='um';
            FormXYPlot.LabelZdim.Caption:='um';
         end;
   end;
   if (FormXYPlot.bfirst_zapusk_XYPlot) then
   begin
      if (ls>0) then
      begin
         // Инициализируем геометрическим центром первого источника тепла при его наличии.
         FormXYPlot.EditXo.Text:=FloatToStr(0.5*(source[0].xS+source[0].xE));
         FormXYPlot.EditYo.Text:=FloatToStr(0.5*(source[0].yS+source[0].yE));
         FormXYPlot.EditZo.Text:=FloatToStr(0.5*(source[0].zS+source[0].zE));
         if (ls>1) then
         begin
            if (abs(source[0].xS-source[1].xS)>1.0e-23) then
            begin
               FormXYPlot.ComboBoxdirectional.ItemIndex:=0; // X - directional
            end;
            if (abs(source[0].yS-source[1].yS)>1.0e-23) then
            begin
               FormXYPlot.ComboBoxdirectional.ItemIndex:=1; // Y - directional
            end;
            if (abs(source[0].zS-source[1].zS)>1.0e-23) then
            begin
               FormXYPlot.ComboBoxdirectional.ItemIndex:=2; // Z - directional
            end;
         end;
      end
       else
      begin
         // Инициализируем геометрическим центром кабинета.
         FormXYPlot.EditXo.Text:=FloatToStr(0.5*(body[0].xS+body[0].xE));
         FormXYPlot.EditYo.Text:=FloatToStr(0.5*(body[0].yS+body[0].yE));
         FormXYPlot.EditZo.Text:=FloatToStr(0.5*(body[0].zS+body[0].zE));
      end;
      // Снимаем флаг первого запуска. Запуск больше уже не первый и инициализация не требуется.
      FormXYPlot.bfirst_zapusk_XYPlot:=false;
   end;
   FormXYPlot.ShowModal;
end;

// считывает информацию о жидкой зоне
procedure TLaplas.myreadfluidzone(var myflmod : TmyFLUIDmodel; s : string);
var
    sub : string;
    itest : Integer;
begin
   // xc
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.xc:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // yc
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.yc:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // zc
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.zc:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // iflow
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.iflow:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // iflowregime
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.iflowregime:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // iturbmodel
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.iturbmodel:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // постоянная Смагоринского.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.SmagConst:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // включать ли модель Германо 1991 года.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.iDynamicStressGermano:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // учитывать ли заданные пользователем ограничения на постоянную Смагоринского.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.iLimitersCs:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // ограничение на постоянную Смагоринского снизу.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.minCs:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // ограничение на постоянную Смагоринского сверху.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.maxCs:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // тип фильтра который используется в модели Германо.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.itypeFiltrGermano:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // roughness
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.roughness:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // множитель корректирующий турбулентное число Ричардсона
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.rRimult:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // пороговое значение угла в модели Selective Smagorinsky
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.rSelectiveAngle:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // показатель степени в модели учёта шероховатости стенки
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.ipowerroughness:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // тип фильтра
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.itypefiltr:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // учитывать ли поправку на неравномерность сетки.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   itest:=StrToInt(sub);
   if (itest=1) then
   begin
       myflmod.bfdelta:=true;
   end
   else
   begin
      myflmod.bfdelta:=false;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // учитывать ли модель Смагоринского-Лиллу
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   itest:=StrToInt(sub);
   if (itest=1) then
   begin
       myflmod.bSmagorinsky_Lilly:=true;
   end
   else
   begin
      myflmod.bSmagorinsky_Lilly:=false;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // учитывать ли шероховатость на стенке
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   itest:=StrToInt(sub);
   if (itest=1) then
   begin
      myflmod.bsurface_roughness:=true;
   end
   else
   begin
      myflmod.bsurface_roughness:=false;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // учитывать ли поправку для течений с кривизной линий тока
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   itest:=StrToInt(sub);
   if (itest=1) then
   begin
      myflmod.bSwirlamendment:=true;
   end
   else
   begin
      myflmod.bSwirlamendment:=false;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // учитывать ли избирательность в модели Смагоринского.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   itest:=StrToInt(sub);
   if (itest=1) then
   begin
      myflmod.bSelectiveSmagorinsky:=true;
   end
   else
   begin
      myflmod.bSelectiveSmagorinsky:=false;
   end;
end;

// считывает параметры материала
procedure TLaplas.myreadmaterial(var workmat : TMYMat; s : string);
var
   sub : string;
   i : Integer;
begin
   // имя материала из которого состоит блок
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.namemat:=sub;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // плотность
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.rho:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // теплоёмкость
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   //workmat.cp:=StrToFloat(sub);
   //workmat.n_cp:=1;
   workmat.n_cp:=StrToInt(sub);

   SetLength(workmat.temp_cp, workmat.n_cp);
   SetLength(workmat.arr_cp, workmat.n_cp);
   for i := 0 to workmat.n_cp-1 do
   begin
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      workmat.temp_cp[i]:= StrToFloat(sub);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      workmat.arr_cp[i]:= StrToFloat(sub);
   end;

   //workmat.temp_cp[0]:=20.0;
   //workmat.arr_cp[0]:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // теплопроводность
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   //workmat.lambda:=StrToFloat(sub);
   //workmat.n_lam:=1;
   workmat.n_lam:=StrToInt(sub);
   SetLength(workmat.temp_lam, workmat.n_lam);
   SetLength(workmat.arr_lam, workmat.n_lam);
   for i := 0 to workmat.n_lam-1 do
   begin
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      workmat.temp_lam[i]:= StrToFloat(sub);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      workmat.arr_lam[i]:= StrToFloat(sub);
   end;
   //workmat.temp_lam[0]:=20.0;
   //workmat.arr_lam[0]:=StrToFloat(sub);

   // Ортотропность теплопроводности :
   s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_thermal_conductivity_x
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_lam_x:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_thermal_conductivity_y
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_lam_y:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_thermal_conductivity_z
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_lam_z:=StrToFloat(sub);
   // Thermal-Stress
    // Ортотропность коэффициента линейного теплового расширения :
   s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_Linear_expansion_coefficient_x
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_Linear_expansion_coefficient_x:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_Linear_expansion_coefficient_y
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_Linear_expansion_coefficient_y:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_Linear_expansion_coefficient_z
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_Linear_expansion_coefficient_z:=StrToFloat(sub);
    // Ортотропность модуля Юнга (Упругости) :
   s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_Young_Module_x
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_Young_Module_x:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_Young_Module_y
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_Young_Module_y:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_Young_Module_z
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_Young_Module_z:=StrToFloat(sub);
   // Ортотропность коэффициента Пуассона :
   s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_Poisson_ratio_xy
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_Poisson_ratio_xy:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_Poisson_ratio_xz
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_Poisson_ratio_xz:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_Poisson_ratio_yz
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_Poisson_ratio_yz:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_Poisson_ratio_yx
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_Poisson_ratio_yx:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_Poisson_ratio_zx
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_Poisson_ratio_zx:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // multiplyer_Poisson_ratio_zy
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mult_Poisson_ratio_zy:=StrToFloat(sub);

   // Модуль сдвига :
   s:=Copy(s,Pos(':',s)+1,length(s));
   // bShearModuleActive
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      workmat.bShearModuleActive:=true;
   end
   else
   begin
      workmat.bShearModuleActive:=false;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // ShearModuleGxy  GPa
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.ShearModuleGxy:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // ShearModuleGyz   GPa
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.ShearModuleGyz:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // ShearModuleGxz   GPa
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.ShearModuleGxz:=StrToFloat(sub);
   (*
   s:=Copy(s,Pos(':',s)+1,length(s));
   // Poisson Ratio
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.Poisson_ratio:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // Young Module
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.Young_Module:=StrToFloat(sub);
    s:=Copy(s,Pos(':',s)+1,length(s));
   // linear_expansion koefficient
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   //workmat.Linear_expansion_coefficient:=StrToFloat(sub);
    //workmat.n_Linear_expansion_coefficient:=1;
   workmat.n_Linear_expansion_coefficient:=StrToInt(sub);

   SetLength(workmat.temp_Linear_expansion_coefficient, workmat.n_Linear_expansion_coefficient);
   SetLength(workmat.arr_Linear_expansion_coefficient, workmat.n_Linear_expansion_coefficient);
   for i := 0 to workmat.n_Linear_expansion_coefficient-1 do
   begin
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      workmat.temp_Linear_expansion_coefficient[i]:= StrToFloat(sub);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      workmat.arr_Linear_expansion_coefficient[i]:= StrToFloat(sub);
   end;
   *)
    // thermal stress stub
    //workmat.Poisson_ratio:=0.154;
    workmat.n_Poisson_ratio:=1;
    SetLength(workmat.temp_Poisson_ratio, workmat.n_Poisson_ratio);
    SetLength(workmat.arr_Poisson_ratio, workmat.n_Poisson_ratio);
    workmat.temp_Poisson_ratio[0]:= 20.0;
    workmat.arr_Poisson_ratio[0]:=0.154;
    //workmat.Young_Module:=217.5;
    workmat.n_Young_Module:=1;
    SetLength(workmat.temp_Young_Module, workmat.n_Young_Module);
    SetLength(workmat.arr_Young_Module, workmat.n_Young_Module);
    workmat.temp_Young_Module[0]:= 20.0;
    workmat.arr_Young_Module[0]:=217.5;
    //workmat.Linear_expansion_coefficient:=1.0;
    workmat.n_Linear_expansion_coefficient:=1;
    SetLength(workmat.temp_Linear_expansion_coefficient, workmat.n_Linear_expansion_coefficient);
    SetLength(workmat.arr_Linear_expansion_coefficient, workmat.n_Linear_expansion_coefficient);
    workmat.temp_Linear_expansion_coefficient[0]:= 20.0;
    workmat.arr_Linear_expansion_coefficient[0]:=1.0;


   s:=Copy(s,Pos(':',s)+1,length(s));
   // динамическая вязкость
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mu:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // коэффициент линейного температурного расширения
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.beta_t:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // материал пользователя или из библиотеки.
   workmat.blibmat:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // идентификатор библиотечного материала.
   workmat.ilibident:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // Приближение Обербека-Буссинеска
   workmat.bBoussinesq:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // закон изменения динамической вязкости.
   workmat.ilawmu:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // минимальное значение динамической вязкости.
   workmat.mumin:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // максимальное значение динамической вязкости.
   workmat.mumax:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // константа модели для вязкости.
   workmat.Amu:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // константа модели для вязкости.
   workmat.Bmu:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // константа модели для вязкости.
   workmat.Cmu:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // показатель степени для неньютоновских жидкостей
   workmat.degreennmu:=StrToFloat(sub);
end;

// считывает параметры для блока
procedure TLaplas.myreadbody(var body : TBody; s : string);
var
   sub : string;
   bOk : Boolean;
   i, j : Integer;

begin
   bOk:=true; // инициализация
   body.name:=Copy(s,1,Pos('=',s)-1);

   s:=Copy(s,Pos('=',s)+1,length(s));
   // igeometry_type
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.igeometry_type:=StrToInt(Trim(sub)); // Prism

   s:=Copy(s,Pos(':',s)+1,length(s));
   // xS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.sxS:=sub;
   if (bOk) then body.xS:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // yS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.syS:=sub;
   if (bOk) then body.yS:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // zS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.szS:=sub;
   if (bOk) then body.zS:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // xE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.sxE:=sub;
   if (bOk) then body.xE:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // yE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.syE:=sub;
   if (bOk) then body.yE:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // zE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.szE:=sub;
   if (bOk) then body.zE:=FormVariables.my_real_convert(sub,bOk);

    (*
   body.iPlane:=1; // XY
   body.xC:=0.5*(abs(body.xE+body.xS));
   body.yC:=0.5*(abs(body.yE+body.yS));
   body.zC:=body.zS;
   body.Hcyl:=abs(body.zE-body.zS);
   body.R_out_cyl:=0.5*(0.5*(abs(body.xE-body.xS))+0.5*(abs(body.yE-body.yS)));
   body.R_in_cyl:=0.0;

   body.sxC:=FormatFloat('0.000',body.xC);
   body.syC:=FormatFloat('0.000',body.yC);
   body.szC:=FormatFloat('0.000',body.zC);
   body.sHcyl:=FormatFloat('0.000',body.Hcyl);
   body.sR_out_cyl:=FormatFloat('0.000',body.R_out_cyl);
   body.sR_in_cyl:=FormatFloat('0.000',body.R_in_cyl);
    *)

    s:=Copy(s,Pos(':',s)+1,length(s));
   // iPlane
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.iPlane:=StrToInt(Trim(sub));


   s:=Copy(s,Pos(':',s)+1,length(s));
   // xC
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.sxC:=sub;
   if (bOk) then body.xC:=FormVariables.my_real_convert(sub,bOk);

   s:=Copy(s,Pos(':',s)+1,length(s));
   // yC
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.syC:=sub;
   if (bOk) then body.yC:=FormVariables.my_real_convert(sub,bOk);

   s:=Copy(s,Pos(':',s)+1,length(s));
   // zC
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.szC:=sub;
   if (bOk) then body.zC:=FormVariables.my_real_convert(sub,bOk);

    s:=Copy(s,Pos(':',s)+1,length(s));
   // Hcyl
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.sHcyl:=sub;
   if (bOk) then body.Hcyl:=FormVariables.my_real_convert(sub,bOk);

   s:=Copy(s,Pos(':',s)+1,length(s));
   // R_out_cyl
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.sR_out_cyl:=sub;
   if (bOk) then body.R_out_cyl:=FormVariables.my_real_convert(sub,bOk);

   s:=Copy(s,Pos(':',s)+1,length(s));
   // R_in_cyl
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.sR_in_cyl:=sub;
   if (bOk) then body.R_in_cyl:=FormVariables.my_real_convert(sub,bOk);

   s:=Copy(s,Pos(':',s)+1,length(s));
   // bCylinder2Prism
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      body.bCylinder2Prism:=true;
   end
     else
   begin
      body.bCylinder2Prism:=false;
   end;

   // sector, conoid

   (*
   // 23_02_2017
   body.R_out_cyl2:=-1.0;
   body.R_in_cyl2:=-1.0;
   body.angle_start:=0.0;
   body.angle_end:=0.0;
   body.sR_out_cyl2:=FormatFloat('0.000',body.R_out_cyl2);
   body.sR_in_cyl2:=FormatFloat('0.000',body.R_in_cyl2);
   body.sangle_start:=FormatFloat('0.000',body.angle_start);
   body.sangle_end:=FormatFloat('0.000',body.angle_end);
   *)


   s:=Copy(s,Pos(':',s)+1,length(s));
   // R_out_cyl2
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.sR_out_cyl2:=sub;
   if (bOk) then body.R_out_cyl2:=FormVariables.my_real_convert(sub,bOk);

    s:=Copy(s,Pos(':',s)+1,length(s));
   // R_in_cyl2
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.sR_in_cyl2:=sub;
   if (bOk) then body.R_in_cyl2:=FormVariables.my_real_convert(sub,bOk);

    s:=Copy(s,Pos(':',s)+1,length(s));
   // angle_start
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.sangle_start:=sub;
   if (bOk) then body.angle_start:=FormVariables.my_real_convert(sub,bOk);

    s:=Copy(s,Pos(':',s)+1,length(s));
   // angle_end
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.sangle_end:=sub;
   if (bOk) then body.angle_end:=FormVariables.my_real_convert(sub,bOk);

   // Polygon

   (*
   s:=Copy(s,Pos(':',s)+1,length(s));
   // iPlane
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.iPlane_obj2:=StrToInt(Trim(sub));
   //body.iPlane_obj2:=3;

   s:=Copy(s,Pos(':',s)+1,length(s));
   // nsizei
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.nsizei:=StrToInt(Trim(sub));
   //body.nsizei:=3;

   SetLength(body.hi,body.nsizei);
   SetLength(body.xi,body.nsizei);
   SetLength(body.yi,body.nsizei);
   SetLength(body.zi,body.nsizei);


   for j := 0 to body.nsizei-1 do
   begin
       s:=Copy(s,Pos(':',s)+1,length(s));
       // hi
       sub:=Trim(Copy(s,1,Pos(':',s)-1));
       if (bOk) then body.hi[j]:=FormVariables.my_real_convert(sub,bOk);

       s:=Copy(s,Pos(':',s)+1,length(s));
       // xi
       sub:=Trim(Copy(s,1,Pos(':',s)-1));
       if (bOk) then body.xi[j]:=FormVariables.my_real_convert(sub,bOk);

       s:=Copy(s,Pos(':',s)+1,length(s));
       // yi
       sub:=Trim(Copy(s,1,Pos(':',s)-1));
       if (bOk) then body.yi[j]:=FormVariables.my_real_convert(sub,bOk);

       s:=Copy(s,Pos(':',s)+1,length(s));
       // zi
       sub:=Trim(Copy(s,1,Pos(':',s)-1));
       if (bOk) then body.zi[j]:=FormVariables.my_real_convert(sub,bOk);
   end;
    *)

     body.iPlane_obj2:=3;
     body.nsizei:=3;
     SetLength(body.hi,body.nsizei);
   SetLength(body.xi,body.nsizei);
   SetLength(body.yi,body.nsizei);
   SetLength(body.zi,body.nsizei);
   body.hi[0]:=0.2*abs(body.xE-body.xS);
   body.xi[0]:=0.5*(body.xS+body.xE)-0.1*abs(body.xE-body.xS);
   body.yi[0]:=0.5*(body.yS+body.yE)-0.141421*abs(body.yE-body.yS);
   body.zi[0]:=0.5*(body.zS+body.zE)-0.141421*abs(body.zE-body.zS);
   body.hi[1]:=0.2*abs(body.xE-body.xS);
   body.xi[1]:=0.5*(body.xS+body.xE)-0.1*abs(body.xE-body.xS);
   body.yi[1]:=0.5*(body.yS+body.yE)+0.141421*abs(body.yE-body.yS);
   body.zi[1]:=0.5*(body.zS+body.zE)-0.141421*abs(body.zE-body.zS);
   body.hi[2]:=0.2*abs(body.xE-body.xS);
   body.xi[2]:=0.5*(body.xS+body.xE)-0.1*abs(body.xE-body.xS);
   body.yi[2]:=0.5*(body.yS+body.yE)-0.141421*abs(body.yE-body.yS);
   body.zi[2]:=0.5*(body.zS+body.zE)+0.141421*abs(body.zE-body.zS);


   // emissivity :
   s:=Copy(s,Pos(':',s)+1,length(s));
   // emissW
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (bOk) then
   begin
      body.emissW:=FormVariables.my_real_convert(sub,bOk);
      body.semissW:=Trim(sub);
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // emissE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (bOk) then
   begin
      body.emissE:=FormVariables.my_real_convert(sub,bOk);
      body.semissE:=Trim(sub);
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // emissS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (bOk) then
   begin
      body.emissS:=FormVariables.my_real_convert(sub,bOk);
      body.semissS:=Trim(sub);
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // emissN
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (bOk) then
   begin
      body.emissN:=FormVariables.my_real_convert(sub,bOk);
      body.semissN:=Trim(sub);
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // emissB
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (bOk) then
   begin
      body.emissB:=FormVariables.my_real_convert(sub,bOk);
      body.semissB:=Trim(sub);
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // emissT
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (bOk) then
   begin
      body.emissT:=FormVariables.my_real_convert(sub,bOk);
      body.semissT:=Trim(sub);
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // binternalRadiation
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.binternalRadiation:=StrToInt(sub);


   s:=Copy(s,Pos(':',s)+1,length(s));
   // imatid
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.imatid:=StrToInt(sub);


   // Фиксация боковой стенки цилиндра для задач Механики.
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(Trim(sub))=1) then
   begin
      body.CylinderFixed:=true;
   end
     else
   begin
       body.CylinderFixed:=false;
   end;

   s:=Copy(s,Pos(':',s)+1,length(s));
   // мощность тепловыделения на блок
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // TODO 19_11_2016
   //body.n_power:=1;
   //SetLength(body.temp_power ,body.n_power);
   //SetLength(body.arr_power ,body.n_power);
   //SetLength(body.arr_s_power ,body.n_power);
   //body.arr_s_power[0]:=sub;
   //if (bOk) then body.arr_power[0]:=FormVariables.my_real_convert(sub,bOk);
   //body.temp_power[0]:=20.0;

   body.n_power:=StrToInt(sub);

   SetLength(body.temp_power ,body.n_power);
   SetLength(body.arr_power ,body.n_power);
   SetLength(body.arr_s_power ,body.n_power);
   for i := 0 to body.n_power-1 do
   begin
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      body.temp_power[i]:= StrToFloat(sub);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      body.arr_s_power[i]:= sub;
      if (bOk) then body.arr_power[i]:=FormVariables.my_real_convert(sub,bOk);
   end;

   s:=Copy(s,Pos(':',s)+1,length(s));
   // зависимость или независимость мощности тепловыделения в блоке от времени.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.ipower_time_depend:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // тип блока
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.itype:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // идентификатор объединения
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.iunion:=StrToInt(sub);
   // Информация о цвете и прозрачности.
   s:=Trim(Copy(s,Pos(':',s)+1,length(s)));
   if (Length(s)=0) then
   begin
      // ранняя версия : данных о цвете и прозрачности ещё нет.
      // Серый цвет и полная непрозрачность.
      body.redcolor:=0.502;
      body.greencolor:=0.502;
      body.bluecolor:=0.502;
      body.transparency:=1.0;
      body.dcol:=8421504;
   end
   else
   begin
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      body.redcolor:=StrToFloat(sub);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      body.greencolor:=StrToFloat(sub);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      body.bluecolor:=StrToFloat(sub);
      s:=Copy(s,Pos(':',s)+1,length(s));
       sub:=Trim(Copy(s,1,Pos(':',s)-1));
      body.transparency:=StrToFloat(sub);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      body.dcol:=StrToInt(sub);
   end;

end;

// читает координаты плоского элемента
procedure TLaplas.myreadplane(var plane : TPlane; s : string);
var
   sub : string;
   bOk : Boolean;
begin
   bOk:=true; // признак корректности ввода.
   // iPlane
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.iPlane:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // xS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.sxS:=sub;
   if (bOk) then plane.xS:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // yS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.syS:=sub;
   if (bOk) then plane.yS:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // zS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.szS:=sub;
   if (bOk) then plane.zS:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // xE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.sxE:=sub;
   if (bOk) then plane.xE:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // yE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.syE:=sub;
   if (bOk) then plane.yE:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // zE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.szE:=sub;
   if (bOk) then plane.zE:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // идентификатор объединения
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.iunion:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // определяются ли размеры стенки размерами кабинета.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (length(sub)>0) then
   begin
      plane.cabinet_depend:=StrToInt(sub);
      // модель предполагается априорно корректной,
      // проверки на некорректность не производится.
      case (StrToInt(sub)) of
         1 : begin
                // minX
                cab_bound_condition.bminX:=true;
             end;
         2 : begin
                 // maxX
                cab_bound_condition.bmaxX:=true;
             end;
         3 : begin
                // minY
                cab_bound_condition.bminY:=true;
             end;
         4 : begin
                // maxY
                cab_bound_condition.bmaxY:=true;
             end;
         5 : begin
                // minZ
                cab_bound_condition.bminZ:=true;
             end;
         6 : begin
                // maxZ
                cab_bound_condition.bmaxZ:=true;
             end;
      end;
   end
   else
    begin
      // пользовательские размеры.
      plane.cabinet_depend:=0;
   end;
end;

// считывает параметры для источника тепла
procedure TLaplas.myreadsource(var source :  TPlane; s : string);
var
   sub : string;
   bOk : Boolean;

begin
   source.name:=Copy(s,1,Pos('=',s)-1);
   s:=Copy(s,Pos('=',s)+1,length(s));
   // Power
   bOk:=true;
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   source.spower:=sub;
   if (bOk) then source.Power:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   source.itempdep:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   source.id_table:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   source.soperatingoffsetdrain:=sub;
   bOk:=true;
   if (bOk) then source.operatingoffsetdrain:=FormVariables.my_real_convert(sub,bOk);

   s:=Copy(s,Pos(':',s)+1,length(s));
   myreadplane(source,s);
   // устанавливаем твёрдую стенку в гидродинамическом плане
   source.Vx:=0.0;
   source.Vy:=0.0;
   source.Vz:=0.0;
   source.P:=0.0;
   source.bpressure:=false;
   source.bsymmetry:=false;
   source.bopening:=false;
end; // myreadsource

// считывает параметры твёрдой стенки
procedure TLaplas.myReadWall(var wall : TPlane; s : string);
var
    sub : string;
    ikey : Integer;
    bOk : Boolean;
begin
   wall.name:=Copy(s,1,Pos('=',s)-1);
   s:=Copy(s,Pos('=',s)+1,length(s));
   // family
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.family:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // Tamb
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.Tamb:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
    // emissivity
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   bOk:=true;
   if (wall.family=3) then
   begin
     wall.emissivity:=0.0;
      if (FormatSettings.DecimalSeparator=',') then
      begin
          wall.semissivity:='0,0';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
         wall.semissivity:='0.0';
      end;
     wall.sheat_transfer_coefficient:=Trim(sub);
     wall.heat_transfer_coefficient:=FormVariables.my_real_convert(wall.sheat_transfer_coefficient,bOk)
   end
   else
   begin
      if (FormatSettings.DecimalSeparator=',') then
      begin
         wall.sheat_transfer_coefficient:='0,0';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
         wall.sheat_transfer_coefficient:='0.0';
      end;
      wall.semissivity:=Trim(sub);
      wall.emissivity:=FormVariables.my_real_convert(wall.semissivity,bOk);
      wall.heat_transfer_coefficient:=0.0;
   end;

   s:=Copy(s,Pos(':',s)+1,length(s));
   // ViewFactor
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.ViewFactor:=StrToFloat(sub);

   s:=Copy(s,Pos(':',s)+1,length(s));
   // Heat Flux
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.HF:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // bsymmetry
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   ikey:=StrToInt(sub);
   if (ikey=1) then wall.bsymmetry:=true else wall.bsymmetry:=false;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // bpressure
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   ikey:=StrToInt(sub);
   if (ikey=1) then wall.bpressure:=true else wall.bpressure:=false;
   s:=Copy(s,Pos(':',s)+1,length(s));
    // bopening
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   ikey:=StrToInt(sub);
   if (ikey=1) then wall.bopening:=true else wall.bopening:=false;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // Vx
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.Vx:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // Vy
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.Vy:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // Vz
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.Vz:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // P
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.P:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));

   (*
   // Thermal - Stress    boundary condition.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.ithermal_stress_boundary_condition:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // xForce
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.xForce:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // yForce
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.yForce:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // zForce
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.zForce:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   *)

   wall.ithermal_stress_boundary_condition:=0;
   wall.xForce:=0.0;
   wall.yForce:=0.0;
   wall.zForce:=0.0;


   // остальные параметры по умолчанию:
   wall.spower:='0.0';
   wall.Power:=0.0;
   myreadplane(wall,s);
end;



// вид в плоскости YZ  neg_X
procedure TLaplas.OrientnegativeX1Click(Sender: TObject);
begin
   SpeedButtonplaneneg_XClick(Sender);
end;

// вид в плоскости XZ  neg_Y
procedure TLaplas.OrientnegativeY1Click(Sender: TObject);
begin
   SpeedButtonplaneneg_YClick(Sender);
end;

// устанавливаем плоскость XY neg_Z
procedure TLaplas.OrientnegativeZ1Click(Sender: TObject);
begin
   SpeedButtonplaneneg_ZClick(Sender);
end;

// вид в плоскости YZ  pos_X
procedure TLaplas.OrientpositiveX1Click(Sender: TObject);
begin
   SpeedButtonplanepos_XClick(Sender);
end;

// вид в плоскости XZ  pos_Y
procedure TLaplas.OrientpositiveY1Click(Sender: TObject);
begin
   SpeedButtonplanepos_YClick(Sender);
end;

// устанавливаем плоскость XY pos_Z
procedure TLaplas.Orientpositivez1Click(Sender: TObject);
begin
   SpeedButtonplanepos_ZClick(Sender);
end;

// Вызывает настройки отладочной панели, параметры которой передаются в
// солвер и отвечают за настройку работы солвера без перекомпиляции.
procedure TLaplas.Parameters1Click(Sender: TObject);
begin
   Form_debug_panel.ShowModal;
end;

// считываем входной файл :
procedure TLaplas.read1Click(Sender: TObject);
var
    iq : Integer;
    bsbros : Boolean;

procedure My_read_model_old();
var
   f : TStringList; // переменная типа объект TStringList
   i,j, i_2, i_3, imlength : Integer; // счётчик
   s,sub : string; // анализируемая строка из файла
   NewNode, Nodeloc, Noddy : TTreeNode; // узел дерева элементов
   flagunion : array of Boolean; //  было ли создано объединение
   SearchTarget : String;
   Searching : Boolean;
   imeshassemblesseparately : Integer;
   bOk : Boolean;
   Qunion_number : array of Integer; // номера unionov
   im1, im2 : Integer;
   bXY_empty : Boolean;
begin
   bsbros:=false;

    breadfinish:=false;
   f:=TStringList.Create();
   // читает файл с геометрией и создаёт тепловую модель
   // считывает файл с компьютерной программой
   OpenDialog1.Filter := 'Текстовые файлы|*.txt';
   if OpenDialog1.Execute and FileExists(OpenDialog1.FileName) then
   begin
       // Результат успешный - пользователь выбрал файл.
       // Загружаем файл .
       f.LoadFromFile(OpenDialog1.FileName);

       Laplas.Caption:=OpenDialog1.FileName;

       if (FormatSettings.DecimalSeparator='.') then
       begin
          // заменить все запятые в файле на точки.
          for i:=0 to f.Count-1 do
          begin
             s:=f.Strings[i];
             f.Strings[i]:=StringReplace(s,',','.',[rfReplaceAll]);
          end;
       end;

        if (FormatSettings.DecimalSeparator=',') then
       begin
          // заменить все точки в файле на запятые.
          for i:=0 to f.Count-1 do
          begin
             s:=f.Strings[i];
             f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
          end;
       end;

   i:=0; // маркер на начало файла
   // начинаем считывание файла
   s:=f.Strings[i]; inc(i);
   sub:=Copy(s,1,Pos(':',s)-1);
   m:=StrToFloat(Copy(sub,Pos('m=',sub)+2,length(sub)));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   gx:=StrToFloat(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   gy:=StrToFloat(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   gz:=StrToFloat(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   inx:=StrToInt(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   iny:=StrToInt(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   inz:=StrToInt(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   operatingtemperature:=StrToFloat(Trim(sub)); //  считывание Operating Temperature
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   etalon_max_size_ratio:=StrToFloat(Trim(sub)); //  считывание фактора подробности сетки
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   etalon_max_size_ratio2:=StrToFloat(Trim(sub)); //  считывание фактора подробности сетки
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   j:=StrToInt(Trim(sub));
   // Snap to grid
   // 0.	none
	 // 1.	Snap to grid
	 // 2.	Snap to grid ALICE
	 // 3.	Snap to grid ++
   if ((j=0)or(j=1)or(j=2)or(j=3)) then
   begin
     MeshForm.ComboBoxSnapTo.ItemIndex:=j;
   end
   else
   begin
      MeshForm.ComboBoxSnapTo.ItemIndex:=0;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   // Также поддерживается cl_agl_amg_v0_14 с января 2016 года.
   if (StrToInt(Trim(sub))>11) then
   begin
     sub:='1';
   end;
   FormSetting.ComboBoxSolverSetting.ItemIndex:=StrToInt(Trim(sub));  // BicgStab+ILU2 vs amg1r5.
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   filmcoefficient:=StrToFloat(Trim(sub)); //  считывание  коэффициента теплоотдачи.
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   adiabatic_vs_heat_transfer_coeff:=StrToInt(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   glSTL.id_law:=StrToInt(Trim(sub)); // 0 - Linear, 1 - Square Wave.
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   glSTL.Factor_a_for_Linear:=StrToFloat(Trim(sub));  // Factor (a) for Linear Law time step.
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   glSTL.tau:=StrToFloat(Trim(sub)); // tau for Square Wave.
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   glSTL.iQ:=StrToFloat(Trim(sub)); // Скважность Q for Square Wave.
   // Параметры импульсного режима АППАРАТ.
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   glSTL.m1:=StrToFloat(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   glSTL.tau1:=StrToFloat(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   glSTL.tau2:=StrToFloat(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   glSTL.tau_pause:=StrToFloat(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   glSTL.off_multiplyer:=StrToFloat(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   glSTL.n:=StrToInt(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   glSTL.T:=StrToFloat(Trim(sub));
   (*
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   glSTL.on_time_double_linear:=StrToFloat(Trim(sub));
   *)
   glSTL.on_time_double_linear:=0.3;// 0.3 s.

   s:=f.Strings[i]; inc(i);
   imlength:=StrToInt(Copy(s,Pos('length=',s)+7,length(s)));
   ComboBoxlength.ItemIndex:=imlength; // выставляем считанные единицы длины
   case imlength of
    0 : begin
           // m
           mlength:=1.0;
        end;
    1 : begin
           // mm
           mlength:=1e-3;
        end;
    2 : begin
           // micron
           mlength:=1e-6;
        end;
   end;

   // считывание информации о таблично заданной мощности.
   s:=f.Strings[i]; inc(i);
   iltdp:=StrToInt(Copy(s,Pos('ltdp=',s)+5,length(s)));
   SetLength(listtablename,iltdp);
   for j:=0 to iltdp-1 do
   begin
      s:=f.Strings[i]; inc(i);
      listtablename[j]:=s; // имя файла с таблицей.
   end;


   // считывание информации об объединениях :
   s:=f.Strings[i]; inc(i);
   lu:=StrToInt(Trim(Copy(s,Pos('lu=',s)+3,length(s))));
   SetLength(myassembles,lu);
   bOk:=true;
   for j:=0 to lu-1 do
   begin
      s:=f.Strings[i]; inc(i);
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].name:=Trim(sub);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].identifire:=StrToInt(Trim(sub));
      myassembles[j].bVisible:=True; // при считывании по умолчанию все элементы полностью видимы.
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].iunionparent:=StrToInt(Trim(sub));
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      imeshassemblesseparately:=StrToInt(Trim(sub));
      if (imeshassemblesseparately=0) then
      begin
         myassembles[j].bmesh_assembles_separately:=false;
      end
       else
      begin
         myassembles[j].bmesh_assembles_separately:=true;
      end;
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].sxmin:=Trim(sub);
      if (bOk) then myassembles[j].xmin:=FormVariables.my_real_convert(Trim(sub),bOk);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].sxmax:=Trim(sub);
      if (bOk) then myassembles[j].xmax:=FormVariables.my_real_convert(Trim(sub),bOk);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].symin:=Trim(sub);
      if (bOk) then myassembles[j].ymin:=FormVariables.my_real_convert(Trim(sub),bOk);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].symax:=Trim(sub);
      if (bOk) then myassembles[j].ymax:=FormVariables.my_real_convert(Trim(sub),bOk);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].szmin:=Trim(sub);
      if (bOk) then myassembles[j].zmin:=FormVariables.my_real_convert(Trim(sub),bOk);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].szmax:=Trim(sub);
      if (bOk) then myassembles[j].zmax:=FormVariables.my_real_convert(Trim(sub),bOk);
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].inxloc:=StrToInt(Trim(sub));
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].inyloc:=StrToInt(Trim(sub));
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].inzloc:=StrToInt(Trim(sub));
   end;

   s:=f.Strings[i]; inc(i);
   ivar:=StrToInt(Trim(Copy(s,Pos('ivarmax=',s)+8,length(s))));
   SetLength(parametric,ivar); // выделение памяти под переменные
   for j:=0 to ivar-1 do
   begin
      // считываем переменные из входного файла :
      s:=f.Strings[i]; inc(i);
      sub:=Copy(s,1,Pos(':',s)-1);
      parametric[j].svar:=Trim(sub);  // имя переменной
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      parametric[j].sval:=Trim(sub); // значение переменной
   end;

   s:=f.Strings[i];
   lmatmax:=StrToInt(Copy(s,Pos('lmatmax=',s)+8,length(s)));
   SetLength(workmat,lmatmax); // выделение оперативной памяти
   // Считываем материалы:
   for j:=0 to (lmatmax-1) do
   begin
      inc(i); s:=f.Strings[i];
      myreadmaterial(workmat[j],s);
   end;
   priority_id:=5;
   inc(i); s:=f.Strings[i]; // cabinet
   SetLength(body,1); // выделение оперативной памяти
   myreadbody(body[0],s); // считывание из текстового файл
   body[0].priority:=-5; // наинизший приоритет.
   Oxc:=0.5*(body[0].xS+body[0].xE);
   Oyc:=0.5*(body[0].yS+body[0].yE);
   Ozc:=0.5*(body[0].zS+body[0].zE);
   R1:=0.5*Hscale*sqrt(Sqr(body[0].xE-body[0].xS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].zE-body[0].zS));
   body[0].bvisible:=true;
   // количество блоков:
   inc(i);
   s:=f.Strings[i];
   //lb:=StrToInt(Copy(s,Pos('lb=',s)+3,length(s)));
   s:=Copy(s,Pos('lb=',s)+3,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   lb:=StrToInt(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   icb:=StrToInt(Trim(sub));
   SetLength(body,lb); // выделение оперативной памяти
   // считываем остальные блоки:
   for j:=1 to (lb-1) do
   begin
      inc(i); s:=f.Strings[i];
      myreadbody(body[j],s);
      body[j].bvisible:=true;
      body[j].priority:=priority_id;
      priority_id:=priority_id+5;
   end;
   ReadyPaint;

   // сообщение на консоль:
   MainMemo.Lines.Add('Reading a text file...');
   for j:=0 to (lb-1) do
   begin
      MainMemo.Lines.Add(body[j].name+' ... ready');
   end;
   // количество источников тепла:
   inc(i); s:=f.Strings[i];
   //ls:=StrToInt(Copy(s,Pos('ls=',s)+3,length(s)));
   s:=Copy(s,Pos('ls=',s)+3,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   ls:=StrToInt(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   ics:=StrToInt(Trim(sub));
   SetLength(source,ls); // выделение оперативной памяти под источники тепла
   // цикл по всем источникам тепла:
   for j:=0 to (ls-1) do
   begin
      inc(i); s:=f.Strings[i]; // считывание очередной строки
      myreadsource(source[j],s);
      source[j].bvisible:=true;
   end;
   for j:=0 to (ls-1) do
   begin
      MainMemo.Lines.Add(source[j].name+' ... ready');
   end;
   // количество стенок:
   inc(i); s:=f.Strings[i];
   //lw:=StrToInt(Copy(s,Pos('lw=',s)+3,length(s)));
   s:=Copy(s,Pos('lw=',s)+3,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   lw:=StrToInt(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   icw:=StrToInt(Trim(sub));
   SetLength(wall,lw); // выделение оперативной памяти под источники тепла
   // цикл по всем источникам тепла:
   for j:=0 to (lw-1) do
   begin
      inc(i); s:=f.Strings[i]; // считывание очередной строки
      myreadwall(wall[j],s);
      wall[j].bvisible:=true; // видимость стенки
   end;
   for j:=0 to (lw-1) do
   begin
      MainMemo.Lines.Add(wall[j].name+' ... ready');
   end;

   // Считывание информации о решаемом наборе уравнений.
   inc(i); s:=f.Strings[i]; // считывание очередной строки
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   egddata.itemper:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   //sub:=Trim(Copy(s,1,Pos(':',s)-1));
   //egddata.iStaticStructural:=StrToInt(sub);
   //s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=0) then
   begin
      // Гидродинамичекская подобласть отсутствует и мы её не рассчитываем.
      // 9.01.2017 Многие константы взяты наобум, надо уточнить дефолтные значения.
       egddata.imaxflD:=1;
      // Обязательное выделение памяти под количество уникальных жидких зон.
      SetLength(egddata.myflmod,egddata.imaxflD);
      egddata.myflmod[0].xc:=Oxc;
      egddata.myflmod[0].yc:=Oyc;
      egddata.myflmod[0].zc:=Ozc;
      egddata.myflmod[0].iflow:=0;
      egddata.myflmod[0].iflowregime:=0;
      egddata.myflmod[0].iturbmodel:=0;
      egddata.myflmod[0].SmagConst:=0.0;
      egddata.myflmod[0].iDynamicStressGermano:=0;
      egddata.myflmod[0].iLimitersCs:=0;
      egddata.myflmod[0].minCs:=-1.0e30;
      egddata.myflmod[0].maxCs:=+1.0e30;
      egddata.myflmod[0].itypeFiltrGermano:=0;
      egddata.myflmod[0].roughness:=0.0;
      egddata.myflmod[0].rRimult:=1.0;
      egddata.myflmod[0].rSelectiveAngle:=15.0;
      egddata.myflmod[0].ipowerroughness:=0;
      egddata.myflmod[0].itypefiltr:=0;
      egddata.myflmod[0].bfdelta:=true;
      egddata.myflmod[0].bSmagorinsky_Lilly:=false;
      egddata.myflmod[0].bsurface_roughness:=false;
      egddata.myflmod[0].bSwirlamendment:=true;
      egddata.myflmod[0].bSelectiveSmagorinsky:=false;
   end
   else
   begin
      egddata.imaxflD:=StrToInt(sub);
      // Обязательное выделение памяти под количество уникальных жидких зон.
      SetLength(egddata.myflmod,egddata.imaxflD);
      for j:=0 to egddata.imaxflD-1 do
      begin
         inc(i); s:=f.Strings[i]; // считывание очередной строки
         // считывание информации о текущей FLUID зоне.
         myreadfluidzone(egddata.myflmod[j], s);
      end;
   end;

   // Считывание параметров освещения.
   inc(i);
   s:=f.Strings[i];
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   remis:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   rspec:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   matdiff:=StrToFloat(sub);

   inc(i);
   s:=f.Strings[i];
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   matamb:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   matt:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   mr:=StrToFloat(sub);

   inc(i);
   s:=f.Strings[i];
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   glamb0:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   mldx:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   mldy:=StrToFloat(sub);

   inc(i);
   s:=f.Strings[i];
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   lamb:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   lspec:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   ldiff:=StrToFloat(sub);

   inc(i);
   s:=f.Strings[i];
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   lithtangle:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   lithtexponent:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   lithtangle1:=StrToFloat(sub);

   inc(i);
   s:=f.Strings[i];
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   lithtexponent1:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   mldx1:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   mldy1:=StrToFloat(sub);

   inc(i);
   s:=f.Strings[i];
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   matt1:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   mr1:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   lamb1:=StrToFloat(sub);

   inc(i);
   s:=f.Strings[i];
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   lspec1:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   ldiff1:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   rblick:=StrToInt(sub);

   inc(i);
   s:=f.Strings[i];
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      chkOnLitht1.Checked:=True;
   end
   else
   begin
      chkOnLitht1.Checked:=False;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      chkDiskretSource1.Checked:=True;
   end
   else
   begin
      chkDiskretSource1.Checked:=False;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      chkdistance1.Checked:=True;
   end
   else
   begin
      chkdistance1.Checked:=False;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      CheckBoxdistance.Checked:=True;
   end
   else
   begin
      CheckBoxdistance.Checked:=False;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      CheckBoxOnLitht.Checked:=True;
   end
   else
   begin
      CheckBoxOnLitht.Checked:=False;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));

   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      CheckBoxPointSources.Checked:=True;
   end
   else
   begin
      CheckBoxPointSources.Checked:=False;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      chkblick.Checked:=True;
   end
   else
   begin
      chkblick.Checked:=False;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));

   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      chkemis.Checked:=True;
   end
   else
   begin
      chkemis.Checked:=False;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));

   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      chkGlobalAmbient.Checked:=True;
   end
   else
   begin
      chkGlobalAmbient.Checked:=False;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));

   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      chksmooter.Checked:=True;
   end
   else
   begin
      chksmooter.Checked:=False;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));

   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   if (StrToInt(sub)=1) then
   begin
      chkSpecular.Checked:=True;
   end
   else
   begin
      chkSpecular.Checked:=False;
   end;

   // i+3 строк присутствуют, значит файл нового образца и в нем сохраняются
   // скорости для инициализации.
   if (i+3< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      FormSpeedInitialization.EditVx.Text:=Trim(sub);

      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      FormSpeedInitialization.EditVy.Text:=Trim(sub);

      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      FormSpeedInitialization.EditVz.Text:=Trim(sub);
   end
   else
   begin
      FormSpeedInitialization.EditVx.Text:='0.0';
      FormSpeedInitialization.EditVy.Text:='0.0';
      FormSpeedInitialization.EditVz.Text:='0.0';
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! StaticStructuralSolverSetting is empty.');
         FormSetting.ComboBoxStaticStructuralSolverSetting.ItemIndex:=0; // BiCGStab+ILU(lfil).
      end
        else
      begin
         if ((StrToInt(Trim(sub))>4)or(StrToInt(Trim(sub))<0)) then
         begin
            FormSetting.ComboBoxStaticStructuralSolverSetting.ItemIndex:=0; // BiCGStab+ILU(lfil).
         end
          else
         begin
            FormSetting.ComboBoxStaticStructuralSolverSetting.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      FormSetting.ComboBoxStaticStructuralSolverSetting.ItemIndex:=0; // BiCGStab+ILU(lfil).
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! MeshGenAlgo_id is empty.');
         MeshForm.ComboBoxmeshgen.ItemIndex:=2; // CoarseMesh
      end
        else
      begin
         if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
         begin
            MeshForm.ComboBoxmeshgen.ItemIndex:=2; // CoarseMesh
         end
          else
         begin
            MeshForm.ComboBoxmeshgen.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      MeshForm.ComboBoxmeshgen.ItemIndex:=2; // CoarseMesh
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! AdaptiveLocalRefinementMesh_Checker is empty.');
         MeshForm.CheckBoxALICE.Checked:=false; // Структурированная сетка.
      end
       else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
            MeshForm.CheckBoxALICE.Checked:=false; // Структурированная сетка.
         end
          else
         begin
            case StrToInt(Trim(sub)) of
               0 :
               begin
                  MeshForm.CheckBoxALICE.Checked:=false; // Структурированная сетка.
               end;
               1 :
               begin
                  MeshForm.CheckBoxALICE.Checked:=true; // Адаптивная Локально Измельчённая Сетка.
               end;
            end;
         end;
      end;
   end
    else
   begin
      MeshForm.CheckBoxALICE.Checked:=false; // Структурированная сетка.
   end;



   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! ALICE_Mesh_Type is empty.');
         MeshForm.ComboBoxALICEType.ItemIndex:=0; // AliceMesh Coarse
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
            MeshForm.ComboBoxALICEType.ItemIndex:=0; // AliceMesh Coarse
         end
          else
         begin
            MeshForm.ComboBoxALICEType.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      MeshForm.ComboBoxALICEType.ItemIndex:=0; // AliceMesh Coarse
   end;


   bXY_empty:=false;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! XYPlotXo is empty.');
         bXY_empty:=true;
      end
        else
      begin
         FormXYPlot.EditXo.Text:=Trim(sub);
      end;
   end
   else
   begin
      bXY_empty:=true;
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! XYPlotYo is empty.');
         bXY_empty:=true;
      end
        else
      begin
         FormXYPlot.EditYo.Text:=Trim(sub);
      end;
   end
   else
   begin
      bXY_empty:=true;
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! XYPlotZo is empty.');
         bXY_empty:=true;
      end
        else
      begin
         FormXYPlot.EditZo.Text:=Trim(sub);
      end;
   end
   else
   begin
      bXY_empty:=true;
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! line_directional is empty.');
         bXY_empty:=true;
      end
        else
      begin
         if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
         begin
            bXY_empty:=true;
         end
          else
         begin
            FormXYPlot.ComboBoxdirectional.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      bXY_empty:=true;
   end;

    if (bXY_empty) then
    begin
        // При считывании тепловой модели инициализируем XYPlot.
        if (ls>0) then
        begin
           // Инициализируем геометрическим центром первого источника тепла при его наличии.
           FormXYPlot.EditXo.Text:=FloatToStr(0.5*(source[0].xS+source[0].xE));
           FormXYPlot.EditYo.Text:=FloatToStr(0.5*(source[0].yS+source[0].yE));
           FormXYPlot.EditZo.Text:=FloatToStr(0.5*(source[0].zS+source[0].zE));

           if (ls>1) then
           begin
              if (abs(source[0].xS-source[1].xS)>1.0e-23) then
              begin
                 FormXYPlot.ComboBoxdirectional.ItemIndex:=0; // X - directional
              end;
              if (abs(source[0].yS-source[1].yS)>1.0e-23) then
              begin
                 FormXYPlot.ComboBoxdirectional.ItemIndex:=1; // Y - directional
              end;
              if (abs(source[0].zS-source[1].zS)>1.0e-23) then
              begin
                 FormXYPlot.ComboBoxdirectional.ItemIndex:=2; // Z - directional
              end;
           end;
        end
         else
        begin
           // Инициализируем геометрическим центром кабинета.
           FormXYPlot.EditXo.Text:=FloatToStr(0.5*(body[0].xS+body[0].xE));
           FormXYPlot.EditYo.Text:=FloatToStr(0.5*(body[0].yS+body[0].yE));
           FormXYPlot.EditZo.Text:=FloatToStr(0.5*(body[0].zS+body[0].zE));
           i_3:=-1;
           for i_2 := 0 to lb-1 do
           begin
              if (body[i_2].n_power>0) then
              begin
                 if ((i_3>-1)and(abs(body[i_2].arr_power[0])>0.0)) then
                 begin
                    if (abs(body[i_3].xS-body[i_2].xS)>1.0e-23) then
                    begin
                       FormXYPlot.ComboBoxdirectional.ItemIndex:=0; // X - directional
                    end;
                    if (abs(body[i_3].yS-body[i_2].yS)>1.0e-23) then
                    begin
                       FormXYPlot.ComboBoxdirectional.ItemIndex:=1; // Y - directional
                    end;
                    if (abs(body[i_3].zS-body[i_2].zS)>1.0e-23) then
                    begin
                       FormXYPlot.ComboBoxdirectional.ItemIndex:=2; // Z - directional
                    end;
                    break;
                 end;
                 if ((i_3=-1)and(abs(body[i_2].arr_power[0])>0.0)) then
                 begin
                    i_3:=i_2;
                    FormXYPlot.EditXo.Text:=FloatToStr(0.5*(body[i_2].xS+body[i_2].xE));
                    FormXYPlot.EditYo.Text:=FloatToStr(0.5*(body[i_2].yS+body[i_2].yE));
                    FormXYPlot.EditZo.Text:=FloatToStr(0.5*(body[i_2].zS+body[i_2].zE));
                 end;
              end;
           end;
        end;
    end;


    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! AMGCL_ddemidov_smoother is empty.');
         FormAMGCLParameters.RadioGroupAMGCLsmoother1.ItemIndex:=0; // spai0
      end
        else
      begin
         if ((StrToInt(Trim(sub))>11)or(StrToInt(Trim(sub))<0)) then
         begin
            FormAMGCLParameters.RadioGroupAMGCLsmoother1.ItemIndex:=0; // spai0
         end
          else
         begin
            FormAMGCLParameters.RadioGroupAMGCLsmoother1.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      FormAMGCLParameters.RadioGroupAMGCLsmoother1.ItemIndex:=0; // spai0
   end;


     if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! AMGCL_ddemidov_AMG_Coarseng is empty.');
         FormAMGCLParameters.RadioGroupAMGCLCoarseningType.ItemIndex:=1; // samg
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
            FormAMGCLParameters.RadioGroupAMGCLCoarseningType.ItemIndex:=1; // samg
         end
          else
         begin
            FormAMGCLParameters.RadioGroupAMGCLCoarseningType.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      FormAMGCLParameters.RadioGroupAMGCLCoarseningType.ItemIndex:=1; // samg
   end;


    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! AMGCL_ddemidov_Krjlov_iterator is empty.');
         FormAMGCLParameters.ComboBoxIterator.ItemIndex:=0; // bicgstab
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
            FormAMGCLParameters.ComboBoxIterator.ItemIndex:=0; // bicgstab
         end
          else
         begin
            FormAMGCLParameters.ComboBoxIterator.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      FormAMGCLParameters.ComboBoxIterator.ItemIndex:=0; // bicgstab
   end;


   // Read amg1r5 settings 27.07.2020

     if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! inumber_processors is empty.');
         FormSetting.ComboBoxNumberProcessors.ItemIndex:=0; // one thread
      end
        else
      begin
         if ((StrToInt(Trim(sub))>31)or(StrToInt(Trim(sub))<0)) then
         begin
            FormSetting.ComboBoxNumberProcessors.ItemIndex:=0; // one thread
         end
          else
         begin
            FormSetting.ComboBoxNumberProcessors.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      FormSetting.ComboBoxNumberProcessors.ItemIndex:=0; // one thread
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! amg1r5_Stailization is empty.');
         Formamg1r5Parameters.ComboBoxStabilization.ItemIndex:=2; // FGMRes
      end
        else
      begin
         if ((StrToInt(Trim(sub))>3)or(StrToInt(Trim(sub))<0)) then
         begin
            Formamg1r5Parameters.ComboBoxStabilization.ItemIndex:=2; // FGMRes
         end
          else
         begin
            Formamg1r5Parameters.ComboBoxStabilization.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Formamg1r5Parameters.ComboBoxStabilization.ItemIndex:=2; // FGMRes
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! amg1r5_number_presmoothers is empty.');
         Formamg1r5Parameters.ComboBoxNumber_of_smootherssteps.ItemIndex:=0; // одна итерация
      end
        else
      begin
         if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
         begin
            Formamg1r5Parameters.ComboBoxNumber_of_smootherssteps.ItemIndex:=0; // одна итерация
         end
          else
         begin
            Formamg1r5Parameters.ComboBoxNumber_of_smootherssteps.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Formamg1r5Parameters.ComboBoxNumber_of_smootherssteps.ItemIndex:=0; // одна итерация
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! amg1r5_number_postsmoothers is empty.');
         Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex:=0; // одна итерация
      end
        else
      begin
         if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
         begin
            Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex:=0; // одна итерация
         end
          else
         begin
            Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex:=0; // одна итерация
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! amg1r5_type_algorithm_presmoother is empty.');
         Formamg1r5Parameters.ComboBoxTypeSmoother.ItemIndex:=0; // С/F relaxation
      end
        else
      begin
         if ((StrToInt(Trim(sub))>3)or(StrToInt(Trim(sub))<0)) then
         begin
            Formamg1r5Parameters.ComboBoxTypeSmoother.ItemIndex:=0; // С/F relaxation
         end
          else
         begin
            Formamg1r5Parameters.ComboBoxTypeSmoother.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Formamg1r5Parameters.ComboBoxTypeSmoother.ItemIndex:=0; // С/F relaxation
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! amg1r5_type_algorithm_postsmoother is empty.');
         Formamg1r5Parameters.ComboBoxTypePostSmoother.ItemIndex:=0; // С/F relaxation
      end
        else
      begin
         if ((StrToInt(Trim(sub))>3)or(StrToInt(Trim(sub))<0)) then
         begin
            Formamg1r5Parameters.ComboBoxTypePostSmoother.ItemIndex:=0; // С/F relaxation
         end
          else
         begin
            Formamg1r5Parameters.ComboBoxTypePostSmoother.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Formamg1r5Parameters.ComboBoxTypePostSmoother.ItemIndex:=0; // С/F relaxation
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! amg1r5_Strong_threshold is empty.');
         Formamg1r5Parameters.Editstrongthreshold.Text:='0.25'; // Strong Threshold
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.002)) then
         begin
            Formamg1r5Parameters.Editstrongthreshold.Text:='0.25'; // Strong Threshold
         end
          else
         begin
             Formamg1r5Parameters.Editstrongthreshold.Text:=(Trim(sub));
         end;
      end;
   end
   else
   begin
      Formamg1r5Parameters.Editstrongthreshold.Text:='0.25'; // Strong Threshold
   end;


    s:='amg1r5_F_to_F='+Trim(Formamg1r5Parameters.EditF2F.Text)+' :';

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! amg1r5_F_to_F is empty.');
         Formamg1r5Parameters.EditF2F.Text:='0.35'; // F_2_F
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.002)) then
         begin
            Formamg1r5Parameters.EditF2F.Text:='0.35'; // F_2_F
         end
          else
         begin
             Formamg1r5Parameters.EditF2F.Text:=(Trim(sub));
         end;
      end;
   end
   else
   begin
      Formamg1r5Parameters.EditF2F.Text:='0.35'; // F_2_F
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! amg1r5_amg1r6_version_aggregator is empty.');
         Formamg1r5Parameters.CheckBox_amg1r6.Checked:=false;  // amg1r5 version aggregator
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Formamg1r5Parameters.CheckBox_amg1r6.Checked:=false;  // amg1r5 version aggregator
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // amg1r5 version
              begin
                 Formamg1r5Parameters.CheckBox_amg1r6.Checked:=false;  // amg1r5 version aggregator
              end;
              1 : // amg1r6 version
              begin
                 Formamg1r5Parameters.CheckBox_amg1r6.Checked:=true;  // amg1r6 version aggregator
              end;
            end;
         end;
      end;
   end
   else
   begin
      Formamg1r5Parameters.CheckBox_amg1r6.Checked:=false;  // amg1r5 version aggregator
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! PressureVelocityCoupling is empty.');
         FormSetting.ComboBoxPressureVelocityCoupling.ItemIndex:=0; // SIMPLE 1972 Б.Сполдинг и С.Патанкар.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
            FormSetting.ComboBoxPressureVelocityCoupling.ItemIndex:=0; // SIMPLE 1972 Б.Сполдинг и С.Патанкар.
         end
          else
         begin
            FormSetting.ComboBoxPressureVelocityCoupling.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      FormSetting.ComboBoxPressureVelocityCoupling.ItemIndex:=0; // SIMPLE 1972 Б.Сполдинг и С.Патанкар.
   end;


    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! FlowConvectionSchemePrefix_id is empty.');
         FormSetting.ComboBoxFlowSchemePrefix.ItemIndex:=1; // Upwind.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            FormSetting.ComboBoxFlowSchemePrefix.ItemIndex:=1; // Upwind.
         end
          else
         begin
            FormSetting.ComboBoxFlowSchemePrefix.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      FormSetting.ComboBoxFlowSchemePrefix.ItemIndex:=1; // Upwind.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! FlowConvectionScheme_id is empty.');
         FormSetting.ComboBoxFlowScheme.ItemIndex:=0; // Upwind.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>15)or(StrToInt(Trim(sub))<0)) then
         begin
            FormSetting.ComboBoxFlowScheme.ItemIndex:=0; // Upwind.
         end
          else
         begin
            FormSetting.ComboBoxFlowScheme.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      FormSetting.ComboBoxFlowScheme.ItemIndex:=0; // Upwind.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! TemperatureConvectionScheme_id is empty.');
         FormSetting.ComboBoxSchemeTemperature.ItemIndex:=0; // Upwind.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>15)or(StrToInt(Trim(sub))<0)) then
         begin
            FormSetting.ComboBoxSchemeTemperature.ItemIndex:=0; // Upwind.
         end
          else
         begin
            FormSetting.ComboBoxSchemeTemperature.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      FormSetting.ComboBoxSchemeTemperature.ItemIndex:=0; // Upwind.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! ILUK_lfil_number is empty.');
         FormSetting.ComboBox_lfil.ItemIndex:=2; // lfil=2.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>7)or(StrToInt(Trim(sub))<0)) then
         begin
            FormSetting.ComboBox_lfil.ItemIndex:=2; // lfil=2.
         end
          else
         begin
            FormSetting.ComboBox_lfil.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      FormSetting.ComboBox_lfil.ItemIndex:=2; // lfil=2.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! FGMRes_mrestart_number is empty.');
         FormSetting.ComboBox_m_restart_for_gmres.ItemIndex:=1; // FGMRes(Mrestart=20).
      end
        else
      begin
         if ((StrToInt(Trim(sub))>9)or(StrToInt(Trim(sub))<0)) then
         begin
            FormSetting.ComboBox_m_restart_for_gmres.ItemIndex:=1; // FGMRes(Mrestart=20).
         end
          else
         begin
            FormSetting.ComboBox_m_restart_for_gmres.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      FormSetting.ComboBox_m_restart_for_gmres.ItemIndex:=1; // FGMRes(Mrestart=20).
   end;

    // Прочтение настроек Румба v.0.14 решателя.
    // 30.07.2020.

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Maximum_reduced_levels_Temperature is empty.');
         Form_amg_manager.ComboBoxmaximumreducedlevels.ItemIndex:=0; // отсутствуют отсекаемые уровни сетки.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>20)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxmaximumreducedlevels.ItemIndex:=0; // отсутствуют отсекаемые уровни сетки.
         end
          else
         begin
            Form_amg_manager.ComboBoxmaximumreducedlevels.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxmaximumreducedlevels.ItemIndex:=0; // отсутствуют отсекаемые уровни сетки.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Maximum_reduced_levels_Speed is empty.');
         Form_amg_manager.ComboBoxmaximumreducedlevelsSpeed.ItemIndex:=0; // отсутствуют отсекаемые уровни сетки.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>20)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxmaximumreducedlevelsSpeed.ItemIndex:=0; // отсутствуют отсекаемые уровни сетки.
         end
          else
         begin
            Form_amg_manager.ComboBoxmaximumreducedlevelsSpeed.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxmaximumreducedlevelsSpeed.ItemIndex:=0; // отсутствуют отсекаемые уровни сетки.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Maximum_reduced_levels_Pressure is empty.');
         Form_amg_manager.ComboBoxmaximumreducedlevelsPressure.ItemIndex:=0; // отсутствуют отсекаемые уровни сетки.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>20)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxmaximumreducedlevelsPressure.ItemIndex:=0; // отсутствуют отсекаемые уровни сетки.
         end
          else
         begin
            Form_amg_manager.ComboBoxmaximumreducedlevelsPressure.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxmaximumreducedlevelsPressure.ItemIndex:=0; // отсутствуют отсекаемые уровни сетки.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Maximum_reduced_levels_Stress is empty.');
         Form_amg_manager.ComboBoxmaximumreducedlevelsStress.ItemIndex:=0; // отсутствуют отсекаемые уровни сетки.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>20)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxmaximumreducedlevelsStress.ItemIndex:=0; // отсутствуют отсекаемые уровни сетки.
         end
          else
         begin
            Form_amg_manager.ComboBoxmaximumreducedlevelsStress.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxmaximumreducedlevelsStress.ItemIndex:=0; // отсутствуют отсекаемые уровни сетки.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_nFinnest is empty.');
         Form_amg_manager.ComboBoxnFinnest.ItemIndex:=1; // две итерации на самой подробной сетке.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxnFinnest.ItemIndex:=1; // две итерации на самой подробной сетке.
         end
          else
         begin
            Form_amg_manager.ComboBoxnFinnest.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxnFinnest.ItemIndex:=1; // две итерации на самой подробной сетке.
   end;


    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_nFinnestSpeed is empty.');
         Form_amg_manager.ComboBoxnFinnestSpeed.ItemIndex:=1; // две итерации на самой подробной сетке.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxnFinnestSpeed.ItemIndex:=1; // две итерации на самой подробной сетке.
         end
          else
         begin
            Form_amg_manager.ComboBoxnFinnestSpeed.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxnFinnestSpeed.ItemIndex:=1; // две итерации на самой подробной сетке.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_nFinnestPressure is empty.');
         Form_amg_manager.ComboBoxnFinnestPressure.ItemIndex:=1; // две итерации на самой подробной сетке.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxnFinnestPressure.ItemIndex:=1; // две итерации на самой подробной сетке.
         end
          else
         begin
            Form_amg_manager.ComboBoxnFinnestPressure.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxnFinnestPressure.ItemIndex:=1; // две итерации на самой подробной сетке.
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_nFinnestStress is empty.');
         Form_amg_manager.ComboBoxnFinnestStress.ItemIndex:=1; // две итерации на самой подробной сетке.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxnFinnestStress.ItemIndex:=1; // две итерации на самой подробной сетке.
         end
          else
         begin
            Form_amg_manager.ComboBoxnFinnestStress.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxnFinnestStress.ItemIndex:=1; // две итерации на самой подробной сетке.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_number_presmoothers is empty.');
         Form_amg_manager.ComboBoxnumberpresmothers.ItemIndex:=1; // одно предсглаживание.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxnumberpresmothers.ItemIndex:=1; // одно предсглаживание.
         end
          else
         begin
            Form_amg_manager.ComboBoxnumberpresmothers.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxnumberpresmothers.ItemIndex:=1; // одно предсглаживание.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_number_presmoothersSpeed is empty.');
         Form_amg_manager.ComboBoxnumberpresmothersSpeed.ItemIndex:=1; // одно предсглаживание.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxnumberpresmothersSpeed.ItemIndex:=1; // одно предсглаживание.
         end
          else
         begin
            Form_amg_manager.ComboBoxnumberpresmothersSpeed.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxnumberpresmothersSpeed.ItemIndex:=1; // одно предсглаживание.
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_number_presmoothersPressure is empty.');
         Form_amg_manager.ComboBoxnumberpresmothersPressure.ItemIndex:=1; // одно предсглаживание.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxnumberpresmothersPressure.ItemIndex:=1; // одно предсглаживание.
         end
          else
         begin
            Form_amg_manager.ComboBoxnumberpresmothersPressure.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxnumberpresmothersPressure.ItemIndex:=1; // одно предсглаживание.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_number_presmoothersStress is empty.');
         Form_amg_manager.ComboBoxnumberpresmoothersStress.ItemIndex:=1; // одно предсглаживание.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxnumberpresmoothersStress.ItemIndex:=1; // одно предсглаживание.
         end
          else
         begin
            Form_amg_manager.ComboBoxnumberpresmoothersStress.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxnumberpresmoothersStress.ItemIndex:=1; // одно предсглаживание.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_number_postsmoothers is empty.');
         Form_amg_manager.ComboBoxnumberpostsweeps.ItemIndex:=2; // два постсглаживания.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxnumberpostsweeps.ItemIndex:=2; // два постсглаживания.
         end
          else
         begin
            Form_amg_manager.ComboBoxnumberpostsweeps.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxnumberpostsweeps.ItemIndex:=2; // два постсглаживания.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_number_postsmoothersSpeed is empty.');
         Form_amg_manager.ComboBoxnumberpostsweepsSpeed.ItemIndex:=2; // два постсглаживания.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxnumberpostsweepsSpeed.ItemIndex:=2; // два постсглаживания.
         end
          else
         begin
            Form_amg_manager.ComboBoxnumberpostsweepsSpeed.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxnumberpostsweepsSpeed.ItemIndex:=2; // два постсглаживания.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_number_postsmoothersPressure is empty.');
         Form_amg_manager.ComboBoxnumberpostsweepsPressure.ItemIndex:=2; // два постсглаживания.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxnumberpostsweepsPressure.ItemIndex:=2; // два постсглаживания.
         end
          else
         begin
            Form_amg_manager.ComboBoxnumberpostsweepsPressure.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxnumberpostsweepsPressure.ItemIndex:=2; // два постсглаживания.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_number_postsmoothersStress is empty.');
         Form_amg_manager.ComboBoxnumberpostsweepsStress.ItemIndex:=2; // два постсглаживания.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxnumberpostsweepsStress.ItemIndex:=2; // два постсглаживания.
         end
          else
         begin
            Form_amg_manager.ComboBoxnumberpostsweepsStress.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxnumberpostsweepsStress.ItemIndex:=2; // два постсглаживания.
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_memory_size is empty.');
         Form_amg_manager.ComboBoxmemorysize.ItemIndex:=5; // девять размеров исходной матрицы.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>96)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxmemorysize.ItemIndex:=5; // девять размеров исходной матрицы.
         end
          else
         begin
            Form_amg_manager.ComboBoxmemorysize.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxmemorysize.ItemIndex:=5; // девять размеров исходной матрицы.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_memory_sizeSpeed is empty.');
         Form_amg_manager.ComboBoxmemorysizeSpeed.ItemIndex:=5; // девять размеров исходной матрицы.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>96)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxmemorysizeSpeed.ItemIndex:=5; // девять размеров исходной матрицы.
         end
          else
         begin
            Form_amg_manager.ComboBoxmemorysizeSpeed.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxmemorysizeSpeed.ItemIndex:=5; // девять размеров исходной матрицы.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_memory_sizePressure is empty.');
         Form_amg_manager.ComboBoxmemorysizePressure.ItemIndex:=5; // девять размеров исходной матрицы.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>96)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxmemorysizePressure.ItemIndex:=5; // девять размеров исходной матрицы.
         end
          else
         begin
            Form_amg_manager.ComboBoxmemorysizePressure.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxmemorysizePressure.ItemIndex:=5; // девять размеров исходной матрицы.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_memory_sizeStress is empty.');
         Form_amg_manager.ComboBoxmemorysizeStress.ItemIndex:=5; // девять размеров исходной матрицы.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>96)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxmemorysizeStress.ItemIndex:=5; // девять размеров исходной матрицы.
         end
          else
         begin
            Form_amg_manager.ComboBoxmemorysizeStress.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxmemorysizeStress.ItemIndex:=5; // девять размеров исходной матрицы.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_interpolation_id is empty.');
         Form_amg_manager.ComboBoxinterpolation.ItemIndex:=3; // четвёртая версия интерполяции.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxinterpolation.ItemIndex:=3; // четвёртая версия интерполяции.
         end
          else
         begin
            Form_amg_manager.ComboBoxinterpolation.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxinterpolation.ItemIndex:=3; // четвёртая версия интерполяции.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_interpolation_id_Speed is empty.');
         Form_amg_manager.ComboBoxinterpolationSpeed.ItemIndex:=3; // четвёртая версия интерполяции.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxinterpolationSpeed.ItemIndex:=3; // четвёртая версия интерполяции.
         end
          else
         begin
            Form_amg_manager.ComboBoxinterpolationSpeed.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxinterpolationSpeed.ItemIndex:=3; // четвёртая версия интерполяции.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_interpolation_id_Pressure is empty.');
         Form_amg_manager.ComboBoxinterpolationPressure.ItemIndex:=3; // четвёртая версия интерполяции.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxinterpolationPressure.ItemIndex:=3; // четвёртая версия интерполяции.
         end
          else
         begin
            Form_amg_manager.ComboBoxinterpolationPressure.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxinterpolationPressure.ItemIndex:=3; // четвёртая версия интерполяции.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_interpolation_id_Stress is empty.');
         Form_amg_manager.ComboBoxinterpollationStress.ItemIndex:=3; // четвёртая версия интерполяции.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxinterpollationStress.ItemIndex:=3; // четвёртая версия интерполяции.
         end
          else
         begin
            Form_amg_manager.ComboBoxinterpollationStress.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxinterpollationStress.ItemIndex:=3; // четвёртая версия интерполяции.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_sort_algo is empty.');
         Form_amg_manager.ComboBoxSort.ItemIndex:=0; // Counting Sort.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>4)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxSort.ItemIndex:=0; // Counting Sort.
         end
          else
         begin
            Form_amg_manager.ComboBoxSort.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxSort.ItemIndex:=0; // Counting Sort.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_Relaxation_Temperature is empty.');
         Form_amg_manager.ComboBoxsmoothertypeTemperature.ItemIndex:=0; // Gauss-Seidel.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>7)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxsmoothertypeTemperature.ItemIndex:=0; // Gauss-Seidel.
         end
          else
         begin
            Form_amg_manager.ComboBoxsmoothertypeTemperature.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxsmoothertypeTemperature.ItemIndex:=0; // Gauss-Seidel.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_Relaxation_Speed is empty.');
         Form_amg_manager.ComboBoxsmoothertypeSpeed.ItemIndex:=0; // Gauss-Seidel.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>7)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxsmoothertypeSpeed.ItemIndex:=0; // Gauss-Seidel.
         end
          else
         begin
            Form_amg_manager.ComboBoxsmoothertypeSpeed.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxsmoothertypeSpeed.ItemIndex:=0; // Gauss-Seidel.
   end;


    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_Relaxation_Pressure is empty.');
         Form_amg_manager.ComboBoxsmoothertypePressure.ItemIndex:=0; // Gauss-Seidel.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>7)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxsmoothertypePressure.ItemIndex:=0; // Gauss-Seidel.
         end
          else
         begin
            Form_amg_manager.ComboBoxsmoothertypePressure.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxsmoothertypePressure.ItemIndex:=0; // Gauss-Seidel.
   end;


    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_Relaxation_Stress is empty.');
         Form_amg_manager.ComboBoxsmoothertypeStress.ItemIndex:=0; // Gauss-Seidel.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>7)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxsmoothertypeStress.ItemIndex:=0; // Gauss-Seidel.
         end
          else
         begin
            Form_amg_manager.ComboBoxsmoothertypeStress.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxsmoothertypeStress.ItemIndex:=0; // Gauss-Seidel.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_amg_splitting_coarsening is empty.');
         Form_amg_manager.ComboBoxcoarseningTemp.ItemIndex:=2; // classical ST all connectioon.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>9)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxcoarseningTemp.ItemIndex:=2; // classical ST all connectioon.
         end
          else
         begin
            Form_amg_manager.ComboBoxcoarseningTemp.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxcoarseningTemp.ItemIndex:=2; // classical ST all connectioon.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_amg_splitting_coarseningSpeed is empty.');
         Form_amg_manager.ComboBoxcoarseningSpeed.ItemIndex:=2; // classical ST all connectioon.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>9)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxcoarseningSpeed.ItemIndex:=2; // classical ST all connectioon.
         end
          else
         begin
            Form_amg_manager.ComboBoxcoarseningSpeed.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxcoarseningSpeed.ItemIndex:=2; // classical ST all connectioon.
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_amg_splitting_coarseningPressure is empty.');
         Form_amg_manager.ComboBoxcoarseningPressure.ItemIndex:=2; // classical ST all connectioon.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>9)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxcoarseningPressure.ItemIndex:=2; // classical ST all connectioon.
         end
          else
         begin
            Form_amg_manager.ComboBoxcoarseningPressure.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxcoarseningPressure.ItemIndex:=2; // classical ST all connectioon.
   end;


    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_amg_splitting_coarseningStress is empty.');
         Form_amg_manager.ComboBoxcoarseningStress.ItemIndex:=2; // classical ST all connectioon.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>9)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxcoarseningStress.ItemIndex:=2; // classical ST all connectioon.
         end
          else
         begin
            Form_amg_manager.ComboBoxcoarseningStress.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxcoarseningStress.ItemIndex:=2; // classical ST all connectioon.
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_Stabilization is empty.');
         Form_amg_manager.ComboBoxStabilizationTemp.ItemIndex:=0; // none.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>3)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxStabilizationTemp.ItemIndex:=0; // none.
         end
          else
         begin
            Form_amg_manager.ComboBoxStabilizationTemp.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxStabilizationTemp.ItemIndex:=0; // none.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_StabilizationSpeed is empty.');
         Form_amg_manager.ComboBoxStabilizationSpeed.ItemIndex:=0; // none.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxStabilizationSpeed.ItemIndex:=0; // none.
         end
          else
         begin
            Form_amg_manager.ComboBoxStabilizationSpeed.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxStabilizationSpeed.ItemIndex:=0; // none.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_StabilizationPressure is empty.');
         Form_amg_manager.ComboBoxStabilizationPressure.ItemIndex:=0; // none.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxStabilizationPressure.ItemIndex:=0; // none.
         end
          else
         begin
            Form_amg_manager.ComboBoxStabilizationPressure.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxStabilizationPressure.ItemIndex:=0; // none.
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_StabilizationStress is empty.');
         Form_amg_manager.ComboBoxStabilizationStress.ItemIndex:=0; // none.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxStabilizationStress.ItemIndex:=0; // none.
         end
          else
         begin
            Form_amg_manager.ComboBoxStabilizationStress.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxStabilizationStress.ItemIndex:=0; // none.
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! C_F_decomposition_algorithms_and_data_structure is empty.');
         Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Temperature.ItemIndex:=2; // BinaryHeap.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Temperature.ItemIndex:=2; // BinaryHeap.
         end
          else
         begin
            Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Temperature.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Temperature.ItemIndex:=2; // BinaryHeap.
   end;


    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! C_F_decomposition_algorithms_and_data_structureSpeed is empty.');
         Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Speed.ItemIndex:=2; // BinaryHeap.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Speed.ItemIndex:=2; // BinaryHeap.
         end
          else
         begin
            Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Speed.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Speed.ItemIndex:=2; // BinaryHeap.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! C_F_decomposition_algorithms_and_data_structurePressure is empty.');
         Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Pressure.ItemIndex:=2; // BinaryHeap.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Pressure.ItemIndex:=2; // BinaryHeap.
         end
          else
         begin
            Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Pressure.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Pressure.ItemIndex:=2; // BinaryHeap.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! C_F_decomposition_algorithms_and_data_structureStress is empty.');
         Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Stress.ItemIndex:=2; // BinaryHeap.
      end
        else
      begin
         if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
         begin
            Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Stress.ItemIndex:=2; // BinaryHeap.
         end
          else
         begin
            Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Stress.ItemIndex:=StrToInt(Trim(sub));
         end;
      end;
   end
   else
   begin
      Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Stress.ItemIndex:=2; // BinaryHeap.
   end;

   // 30.07.2020

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_threshold_Temperature is empty.');
         Form_amg_manager.Editthreshold.Text:='0.24'; // standart threshold.
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
         begin
            Form_amg_manager.Editthreshold.Text:='0.24'; // standart threshold.
         end
          else
         begin
            Form_amg_manager.Editthreshold.Text:=Trim(sub);
         end;
      end;
   end
   else
   begin
      Form_amg_manager.Editthreshold.Text:='0.24'; // standart threshold.
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_threshold_Speed is empty.');
         Form_amg_manager.EditthresholdSpeed.Text:='0.24'; // standart threshold.
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
         begin
            Form_amg_manager.EditthresholdSpeed.Text:='0.24'; // standart threshold.
         end
          else
         begin
            Form_amg_manager.EditthresholdSpeed.Text:=Trim(sub);
         end;
      end;
   end
   else
   begin
      Form_amg_manager.EditthresholdSpeed.Text:='0.24'; // standart threshold.
   end;


    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_threshold_Pressure is empty.');
         Form_amg_manager.EditthresholdPressure.Text:='0.24'; // standart threshold.
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
         begin
            Form_amg_manager.EditthresholdPressure.Text:='0.24'; // standart threshold.
         end
          else
         begin
            Form_amg_manager.EditthresholdPressure.Text:=Trim(sub);
         end;
      end;
   end
   else
   begin
      Form_amg_manager.EditthresholdPressure.Text:='0.24'; // standart threshold.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_threshold_Stress is empty.');
         Form_amg_manager.EditthresholdStress.Text:='0.24'; // standart threshold.
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
         begin
            Form_amg_manager.EditthresholdStress.Text:='0.24'; // standart threshold.
         end
          else
         begin
            Form_amg_manager.EditthresholdStress.Text:=Trim(sub);
         end;
      end;
   end
   else
   begin
      Form_amg_manager.EditthresholdStress.Text:='0.24'; // standart threshold.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_truncation_interpolation_Temp is empty.');
         Form_amg_manager.Edit_truncation_T.Text:='0.2'; // standart hruncation.
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
         begin
            Form_amg_manager.Edit_truncation_T.Text:='0.2'; // standart truncation.
         end
          else
         begin
            Form_amg_manager.Edit_truncation_T.Text:=Trim(sub);
         end;
      end;
   end
   else
   begin
      Form_amg_manager.Edit_truncation_T.Text:='0.2'; // standart truncation.
   end;


    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_truncation_interpolation_Speed is empty.');
         Form_amg_manager.Edit_truncation_Speed.Text:='0.2'; // standart hruncation.
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
         begin
            Form_amg_manager.Edit_truncation_Speed.Text:='0.2'; // standart truncation.
         end
          else
         begin
            Form_amg_manager.Edit_truncation_Speed.Text:=Trim(sub);
         end;
      end;
   end
   else
   begin
      Form_amg_manager.Edit_truncation_Speed.Text:='0.2'; // standart truncation.
   end;


   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_truncation_interpolation_Pressure is empty.');
         Form_amg_manager.Edit_truncation_Pressure.Text:='0.2'; // standart hruncation.
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
         begin
            Form_amg_manager.Edit_truncation_Pressure.Text:='0.2'; // standart truncation.
         end
          else
         begin
            Form_amg_manager.Edit_truncation_Pressure.Text:=Trim(sub);
         end;
      end;
   end
   else
   begin
      Form_amg_manager.Edit_truncation_Pressure.Text:='0.2'; // standart truncation.
   end;


    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_truncation_interpolation_Stress is empty.');
         Form_amg_manager.Edittruncation_Stress.Text:='0.2'; // standart hruncation.
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
         begin
            Form_amg_manager.Edittruncation_Stress.Text:='0.2'; // standart truncation.
         end
          else
         begin
            Form_amg_manager.Edittruncation_Stress.Text:=Trim(sub);
         end;
      end;
   end
   else
   begin
      Form_amg_manager.Edittruncation_Stress.Text:='0.2'; // standart truncation.
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_F2F_Temperature is empty.');
         Form_amg_manager.EditmagicT.Text:='0.4'; // standart F2F.
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
         begin
            Form_amg_manager.EditmagicT.Text:='0.4'; // standart F2F.
         end
          else
         begin
            Form_amg_manager.EditmagicT.Text:=Trim(sub);
         end;
      end;
   end
   else
   begin
      Form_amg_manager.EditmagicT.Text:='0.4'; // standart F2F.
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_F2F_Speed is empty.');
         Form_amg_manager.EditmagicSpeed.Text:='0.4'; // standart F2F.
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
         begin
            Form_amg_manager.EditmagicSpeed.Text:='0.4'; // standart F2F.
         end
          else
         begin
            Form_amg_manager.EditmagicSpeed.Text:=Trim(sub);
         end;
      end;
   end
   else
   begin
      Form_amg_manager.EditmagicSpeed.Text:='0.4'; // standart F2F.
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_F2F_Pressure is empty.');
         Form_amg_manager.EditmagicPressure.Text:='0.4'; // standart F2F.
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
         begin
            Form_amg_manager.EditmagicPressure.Text:='0.4'; // standart F2F.
         end
          else
         begin
            Form_amg_manager.EditmagicPressure.Text:=Trim(sub);
         end;
      end;
   end
   else
   begin
      Form_amg_manager.EditmagicPressure.Text:='0.4'; // standart F2F.
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_F2F_Stress is empty.');
         Form_amg_manager.EditmagicStress.Text:='0.4'; // standart F2F.
      end
        else
      begin
         if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
         begin
            Form_amg_manager.EditmagicStress.Text:='0.4'; // standart F2F.
         end
          else
         begin
            Form_amg_manager.EditmagicStress.Text:=Trim(sub);
         end;
      end;
   end
   else
   begin
      Form_amg_manager.EditmagicStress.Text:='0.4'; // standart F2F.
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_Diagonal_dominant is empty.');
         Form_amg_manager.CheckBoxDiagonalDominant.Checked:=true;  // диагональное преобладание
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxDiagonalDominant.Checked:=true;  // диагональное преобладание
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // диагональное преобладание
              begin
                 Form_amg_manager.CheckBoxDiagonalDominant.Checked:=false;  // диагональное преобладание
              end;
              1 : // диагональное преобладание
              begin
                 Form_amg_manager.CheckBoxDiagonalDominant.Checked:=true;  // диагональное преобладание
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxDiagonalDominant.Checked:=true;  // диагональное преобладание
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_truncationT is empty.');
         Form_amg_manager.CheckBoxtruncationT.Checked:=true;  // truncation interpolation
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxtruncationT.Checked:=true;  // truncation interpolation
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // truncation interpolation
              begin
                 Form_amg_manager.CheckBoxtruncationT.Checked:=false;  // truncation interpolation
              end;
              1 : // truncation interpolation
              begin
                 Form_amg_manager.CheckBoxtruncationT.Checked:=true;  // truncation interpolation
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxtruncationT.Checked:=true;  // truncation interpolation
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_truncationSpeed is empty.');
         Form_amg_manager.CheckBoxtruncationSpeed.Checked:=true;  // truncation interpolation
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxtruncationSpeed.Checked:=true;  // truncation interpolation
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // truncation interpolation
              begin
                 Form_amg_manager.CheckBoxtruncationSpeed.Checked:=false;  // truncation interpolation
              end;
              1 : // truncation interpolation
              begin
                 Form_amg_manager.CheckBoxtruncationSpeed.Checked:=true;  // truncation interpolation
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxtruncationSpeed.Checked:=true;  // truncation interpolation
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_truncationPressure is empty.');
         Form_amg_manager.CheckBoxtruncationPressure.Checked:=true;  // truncation interpolation
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxtruncationPressure.Checked:=true;  // truncation interpolation
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // truncation interpolation
              begin
                 Form_amg_manager.CheckBoxtruncationPressure.Checked:=false;  // truncation interpolation
              end;
              1 : // truncation interpolation
              begin
                 Form_amg_manager.CheckBoxtruncationPressure.Checked:=true;  // truncation interpolation
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxtruncationPressure.Checked:=true;  // truncation interpolation
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_truncationStress is empty.');
         Form_amg_manager.CheckBoxtruncationStress.Checked:=true;  // truncation interpolation
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxtruncationStress.Checked:=true;  // truncation interpolation
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // truncation interpolation
              begin
                 Form_amg_manager.CheckBoxtruncationStress.Checked:=false;  // truncation interpolation
              end;
              1 : // truncation interpolation
              begin
                 Form_amg_manager.CheckBoxtruncationStress.Checked:=true;  // truncation interpolation
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxtruncationStress.Checked:=true;  // truncation interpolation
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_StrongTranspose is empty.');
         Form_amg_manager.CheckBoxStrongTranspose.Checked:=true;  // StrongTranspose
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxStrongTranspose.Checked:=true;  // StrongTranspose
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // StrongTranspose
              begin
                 Form_amg_manager.CheckBoxStrongTranspose.Checked:=false;  // StrongTranspose
              end;
              1 : // StrongTranspose
              begin
                 Form_amg_manager.CheckBoxStrongTranspose.Checked:=true;  // StrongTranspose
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxStrongTranspose.Checked:=true;  // StrongTranspose
   end;


    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_PrintLogTemperature is empty.');
         Form_amg_manager.CheckBoxprintlogTemperature.Checked:=true;  // print amg log
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxprintlogTemperature.Checked:=true;  // print amg log
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // print amg log
              begin
                 Form_amg_manager.CheckBoxprintlogTemperature.Checked:=false;  // print amg log
              end;
              1 : // print amg log
              begin
                 Form_amg_manager.CheckBoxprintlogTemperature.Checked:=true;  // print amg log
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxprintlogTemperature.Checked:=true;  // print amg log
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_PrintLogSpeed is empty.');
         Form_amg_manager.CheckBoxprintlogSpeed.Checked:=true;  // print amg log
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxprintlogSpeed.Checked:=true;  // print amg log
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // print amg log
              begin
                 Form_amg_manager.CheckBoxprintlogSpeed.Checked:=false;  // print amg log
              end;
              1 : // print amg log
              begin
                 Form_amg_manager.CheckBoxprintlogSpeed.Checked:=true;  // print amg log
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxprintlogSpeed.Checked:=true;  // print amg log
   end;

   if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_PrintLogPressure is empty.');
         Form_amg_manager.CheckBoxprintlogPressure.Checked:=true;  // print amg log
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxprintlogPressure.Checked:=true;  // print amg log
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // print amg log
              begin
                 Form_amg_manager.CheckBoxprintlogPressure.Checked:=false;  // print amg log
              end;
              1 : // print amg log
              begin
                 Form_amg_manager.CheckBoxprintlogPressure.Checked:=true;  // print amg log
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxprintlogPressure.Checked:=true;  // print amg log
   end;

     if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_PrintLogStress is empty.');
         Form_amg_manager.CheckBoxprintlogStress.Checked:=true;  // print amg log
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxprintlogStress.Checked:=true;  // print amg log
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // print amg log
              begin
                 Form_amg_manager.CheckBoxprintlogStress.Checked:=false;  // print amg log
              end;
              1 : // print amg log
              begin
                 Form_amg_manager.CheckBoxprintlogStress.Checked:=true;  // print amg log
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxprintlogStress.Checked:=true;  // print amg log
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_TemperatureMatrixPortrait is empty.');
         Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked:=false;  // печать портрета матрицы
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked:=false;  // печать портрета матрицы
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // print amg log
              begin
                 Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked:=false;  // печать портрета матрицы
              end;
              1 : // print amg log
              begin
                 Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked:=true;  // печать портрета матрицы
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked:=false;  // печать портрета матрицы
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_SpeedMatrixPortrait is empty.');
         Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked:=false;  // печать портрета матрицы
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked:=false;  // печать портрета матрицы
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // print amg log
              begin
                 Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked:=false;  // печать портрета матрицы
              end;
              1 : // print amg log
              begin
                 Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked:=true;  // печать портрета матрицы
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked:=false;  // печать портрета матрицы
   end;

    if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_PressureMatrixPortrait is empty.');
         Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked:=false;  // печать портрета матрицы
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked:=false;  // печать портрета матрицы
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // print amg log
              begin
                 Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked:=false;  // печать портрета матрицы
              end;
              1 : // print amg log
              begin
                 Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked:=true;  // печать портрета матрицы
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked:=false;  // печать портрета матрицы
   end;

      if (i+1< f.Count) then
   begin
      inc(i);
      s:=f.Strings[i];
      sub:=Trim(Copy(s,1,Pos(':',s)-1));
      if (length(sub)=0) then
      begin
         //ShowMessage('error! Rumba_StressMatrixPortrait is empty.');
         Form_amg_manager.CheckBoxStressMatrixPortrait.Checked:=false;  // печать портрета матрицы
      end
        else
      begin
         if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
         begin
           Form_amg_manager.CheckBoxStressMatrixPortrait.Checked:=false;  // печать портрета матрицы
         end
          else
         begin
            case StrToInt(Trim(sub)) of
              0 : // print amg log
              begin
                 Form_amg_manager.CheckBoxStressMatrixPortrait.Checked:=false;  // печать портрета матрицы
              end;
              1 : // print amg log
              begin
                 Form_amg_manager.CheckBoxStressMatrixPortrait.Checked:=true;  // печать портрета матрицы
              end;
            end;
         end;
      end;
   end
   else
   begin
      Form_amg_manager.CheckBoxStressMatrixPortrait.Checked:=false;  // печать портрета матрицы
   end;



    // отображение дерева элементов:
    TreeLoad(Sender);

    MainMemo.Lines.Add('Done');
    f.Free;
    // прорисовка геометрии
   end;  // иначе чтение файла не удалось, например пользователь отказался от открытитя файла.

   breadfinish:=true;

end;


// ищет в текстовом файле f подстроку ':'+s_name_analizing+'=' для последующего
// извлечения числа в строку sret однозначно ассоциированного этим текстовым маркером
// s_name_analizing. 13 ноября 2017.
function My_Get_String_for_to_val(s_name_analizing : String; var f : TStringList): String;
var
  sret : String;
  i,ipos : Integer;
  bfound : Boolean;
  smemo : String;
begin

   smemo:=Trim(s_name_analizing);

   bfound:=false;
   sret:='';
   //  s_name_analizing  - имя переменной которую надо найти в файле.


   // f - файл в котором осуществляется поиск.
   for i := iq to f.Count-1 do
   begin
      // Сразу ищем в каждой обрабатываемой строке
      // вхождения по обоим шаблонам (первому и сразу второму) одновременно.


      s_name_analizing:=':'+Trim(smemo)+'=';
      ipos:=pos(s_name_analizing,f.Strings[i]);
      if (ipos>0) then
      begin
         // данные найдены.
         iq:=i;

         ipos:=ipos+length(s_name_analizing);
         sret:=copy(f.Strings[i],ipos,length(f.Strings[i])-ipos+1);
         //ShowMessage(sret);
         if (pos(':',sret)=0) then
         begin
             // Этим числовым значением заканчивается строка.
            sret:=copy(sret,1,length(sret));
           // Application.MessageBox(PWideChar(smemo+'='+sret),'incomming');
         end
         else
         begin
             sret:=copy(sret,1,pos(':',sret)-1);
             //Application.MessageBox(PWideChar(smemo+'='+sret),'incomming');
         end;
         // Мы удаляем из анализируемого файла те строки которые уже встретились.
         // Это ускорит загрузку очень больших моделей. 1.12.2018
        // StringReplace(f.Strings[i],':'+smemo+'='+sret,'',[rfReplaceAll]);
         bfound:=true;
         // Прерывание сканирования файла на поиск, т.к. уже найдено.
         break;
      end;

      if (not(bfound)) then
      begin
      //  s_name_analizing  - имя переменной которую надо найти в файле.
       s_name_analizing:=Trim(smemo)+'=';
        ipos:=pos(s_name_analizing,f.Strings[i]);
          if (ipos>0) then
          begin
             // данные найдены.
             iq:=i;

             ipos:=ipos+length(s_name_analizing);
             sret:=copy(f.Strings[i],ipos,length(f.Strings[i])-ipos+1);
             //Application.MessageBox(PWideChar(sret),'debug');
             if (pos(':',sret)=0) then
             begin
                // Этим числовым значением заканчивается строка.
                sret:=copy(sret,1,length(sret));
               //Application.MessageBox(PWideChar(smemo+'='+sret),'incomming');
             end
              else
             begin
                sret:=copy(sret,1,pos(':',sret)-1);
                //Application.MessageBox(PWideChar(smemo+'='+sret),'incomming');
             end;
             // Мы удаляем из анализируемого файла те строки которые уже встретились.
             // Это ускорит загрузку очень больших моделей. 1.12.2018
            // StringReplace(f.Strings[i],smemo+'='+sret,'',[rfReplaceAll]);
             bfound:=true;
             // Прерывание сканирования файла на поиск, т.к. уже найдено.
             break;
          end;
        end;

   end;

   if (not(bfound)) then
   begin
   // f - файл в котором осуществляется поиск.
   for i := 0 to f.Count-1 do
   begin

      ipos:=pos(s_name_analizing,f.Strings[i]);
      if (ipos>0) then
      begin
         // данные найдены.
         iq:=i;

         ipos:=ipos+length(s_name_analizing);
         sret:=copy(f.Strings[i],ipos,length(f.Strings[i])-ipos+1);
         //ShowMessage(sret);
         if (pos(':',sret)=0) then
         begin
             // Этим числовым значением заканчивается строка.
            sret:=copy(sret,1,length(sret));
           // Application.MessageBox(PWideChar(smemo+'='+sret),'incomming');
         end
         else
         begin
             sret:=copy(sret,1,pos(':',sret)-1);
             //Application.MessageBox(PWideChar(smemo+'='+sret),'incomming');
         end;
         // Мы удаляем из анализируемого файла те строки которые уже встретились.
         // Это ускорит загрузку очень больших моделей. 1.12.2018
        // StringReplace(f.Strings[i],':'+smemo+'='+sret,'',[rfReplaceAll]);
         bfound:=true;
         // Прерывание сканирования файла на поиск, т.к. уже найдено.
         break;
      end;
   end;
   end;

   if (not(bfound)) then
   begin
       //  s_name_analizing  - имя переменной которую надо найти в файле.
       s_name_analizing:=Trim(smemo)+'=';

       // f - файл в котором осуществляется поиск.
       for i := 0 to f.Count-1 do
       begin
          ipos:=pos(s_name_analizing,f.Strings[i]);
          if (ipos>0) then
          begin
             // данные найдены.
             iq:=i;

             ipos:=ipos+length(s_name_analizing);
             sret:=copy(f.Strings[i],ipos,length(f.Strings[i])-ipos+1);
             //Application.MessageBox(PWideChar(sret),'debug');
             if (pos(':',sret)=0) then
             begin
                // Этим числовым значением заканчивается строка.
                sret:=copy(sret,1,length(sret));
               //Application.MessageBox(PWideChar(smemo+'='+sret),'incomming');
             end
              else
             begin
                sret:=copy(sret,1,pos(':',sret)-1);
                //Application.MessageBox(PWideChar(smemo+'='+sret),'incomming');
             end;
             // Мы удаляем из анализируемого файла те строки которые уже встретились.
             // Это ускорит загрузку очень больших моделей. 1.12.2018
            // StringReplace(f.Strings[i],smemo+'='+sret,'',[rfReplaceAll]);
             bfound:=true;
             // Прерывание сканирования файла на поиск, т.к. уже найдено.
             break;
          end;
       end;
   end;

   sret:=Trim(sret);

   Result:=sret;
end;


// После тестирования, нужно полностью очистить код read_new
// от закоментированного кода.
procedure My_read_model_new(bAdd_packaje : Boolean);
var
   f: TStringList; // переменная типа объект TStringList
   //f2 : TStringList;
   i,j, imlength, idob, iscan_ass, i_2, i_3 : Integer; // счётчик
   s,sub : string; // анализируемая строка из файла
   NewNode, Nodeloc, Noddy : TTreeNode; // узел дерева элементов
   flagunion : array of Boolean; //  было ли создано объединение
   bdobavlen : array of Boolean; // какие блоки уже были добавлены в дерево.
   SearchTarget : String;
   Searching, not_ignoring : Boolean;
   imeshassemblesseparately : Integer;
   bOk : Boolean;
   Qunion_number : array of Integer; // номера unionov
   im1, im2 : Integer;
   i_1, iunion_old, lb_old, icb_old, imatherial_old : Integer;
   priority_id_old, ls_old, lw_old, ics_old, icw_old : Integer;
   ivar_package, j_var : Integer;
   bfound_variable : Boolean;
   snew, sold, subloc : String;
   bXY_empty : Boolean;
   bPostShearStressxy, bPostShearStressyz, bPostShearStressxz : Boolean;


begin

   bsbros:=false;
   iq:=0;// начинаем поиск с самого начала файла.
   breadfinish:=false;
   f:=TStringList.Create();
   //f2:=TStringList.Create();
   // читает файл с геометрией и создаёт тепловую модель
   // считывает файл с компьютерной программой
   OpenDialog1.Filter := 'Текстовые файлы|*.txt';
   if OpenDialog1.Execute and FileExists(OpenDialog1.FileName) then
   begin
       // Результат успешный - пользователь выбрал файл.
       // Загружаем файл .
       f.LoadFromFile(OpenDialog1.FileName);

       (*
       for i := 0 to f2.Count-1 do
       begin
         s:=f2.Strings[i];
         sub:='';
         idob:=1;
         for j := 1 to length(s) do
         begin
            //sub[idob]:=s[j];
            //inc(idob);
            if (s[j]=':') then
            begin
                sub:=copy(s,idob,j-idob+1);
                f.Add(sub);
                //ShowMessage(sub);
                sub:='';
                idob:=j+1;
            end
            else if (j=length(s)) then
            begin
                sub:=copy(s,idob,j-idob+1);
                f.Add(sub);
                //ShowMessage(sub);
                sub:='';
                idob:=j+1;
            end;
         end;
       end;
       f2.Clear;
       f2.Free;
       *)
       Laplas.Caption:=OpenDialog1.FileName;

       if (FormatSettings.DecimalSeparator='.') then
       begin
          // заменить все запятые в файле на точки.
          for i:=0 to f.Count-1 do
          begin
             s:=f.Strings[i];
             f.Strings[i]:=StringReplace(s,',','.',[rfReplaceAll]);
          end;
       end;

        if (FormatSettings.DecimalSeparator=',') then
       begin
          // заменить все точки в файле на запятые.
          for i:=0 to f.Count-1 do
          begin
             s:=f.Strings[i];
             f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
          end;
       end;


       sub:=My_Get_String_for_to_val('open_label',f);
       if ((length(sub)>0)and(StrToInt(sub)=1082020)) then
       begin

       if (bAdd_packaje) then
       begin
          inc(inumber_package_load);
       end;

       if (not(bAdd_packaje)) then
       begin
          //i:=0; // маркер на начало файла
          // начинаем считывание файла
          //s:=f.Strings[i]; inc(i);
          //sub:=Copy(s,1,Pos(':',s)-1);
          sub:=My_Get_String_for_to_val('mashtab',f);
          if (length(sub)=0) then
          begin
             // default
             m:=0.001;
          end
           else
          begin
             m:=StrToFloat(sub);
          end;
          //m:=StrToFloat(Copy(sub,Pos('m=',sub)+2,length(sub)));
        end;

         if (not(bAdd_packaje)) then
       begin
          //s:=Copy(s,Pos(':',s)+1,length(s));
          //sub:=Copy(s,1,Pos(':',s)-1);
          //gx:=StrToFloat(Trim(sub));
          sub:=My_Get_String_for_to_val('gravity_x',f);
          if (length(sub)=0) then
          begin
            // default
            gx:=0.0;
          end
           else
          begin
             gx:=StrToFloat(sub);
          end;

          sub:=My_Get_String_for_to_val('gravity_y',f);
          if (length(sub)=0) then
          begin
             // default
             gy:=0.0;
          end
           else
          begin
             gy:=StrToFloat(sub);
          end;

          sub:=My_Get_String_for_to_val('gravity_z',f);
          if (length(sub)=0) then
          begin
            // default
            gz:=0.0;
          end
           else
          begin
             gz:=StrToFloat(sub);
          end;

          //s:=Copy(s,Pos(':',s)+1,length(s));
          //sub:=Copy(s,1,Pos(':',s)-1);
          //gy:=StrToFloat(Trim(sub));
          //s:=Copy(s,Pos(':',s)+1,length(s));
          //sub:=Copy(s,1,Pos(':',s)-1);
          //gz:=StrToFloat(Trim(sub));
          //s:=Copy(s,Pos(':',s)+1,length(s));
   end;

     if (not(bAdd_packaje)) then
     begin
        sub:=My_Get_String_for_to_val('inx',f);
        if (length(sub)=0) then
        begin
           // default
           inx:=23;
        end
         else
        begin
           inx:=StrToInt(sub);
        end;

        sub:=My_Get_String_for_to_val('iny',f);
        if (length(sub)=0) then
        begin
           // default
           iny:=23;
        end
         else
        begin
           iny:=StrToInt(sub);
        end;

        sub:=My_Get_String_for_to_val('inz',f);
        if (length(sub)=0) then
        begin
           // default
           inz:=23;
        end
         else
        begin
           inz:=StrToInt(sub);
        end;

        //sub:=Copy(s,1,Pos(':',s)-1);
        //inx:=StrToInt(Trim(sub));
        //s:=Copy(s,Pos(':',s)+1,length(s));
        //sub:=Copy(s,1,Pos(':',s)-1);
        //iny:=StrToInt(Trim(sub));
        //s:=Copy(s,Pos(':',s)+1,length(s));
        //sub:=Copy(s,1,Pos(':',s)-1);
        //inz:=StrToInt(Trim(sub));
        //s:=Copy(s,Pos(':',s)+1,length(s));

   end;

   if (not(bAdd_packaje)) then
   begin

      sub:=My_Get_String_for_to_val('operating_temperature',f);
      if (length(sub)=0) then
      begin
          // default
          operatingtemperature:=20.0;
      end
        else
      begin
          operatingtemperature:=StrToFloat(sub);
      end;

      sub:=My_Get_String_for_to_val('etalon_max_size_ratio',f);
      if (length(sub)=0) then
      begin
         // default
         etalon_max_size_ratio:=2.0;
      end
        else
      begin
          etalon_max_size_ratio:=StrToFloat(sub);
      end;

      sub:=My_Get_String_for_to_val('etalon_max_size_ratio2',f);
      if (length(sub)=0) then
      begin
         // default
         etalon_max_size_ratio2:=700000.0;
      end
        else
      begin
         etalon_max_size_ratio2:=StrToFloat(sub);
      end;

      //sub:=Copy(s,1,Pos(':',s)-1);
      //operatingtemperature:=StrToFloat(Trim(sub)); //  считывание Operating Temperature
      //s:=Copy(s,Pos(':',s)+1,length(s));
      //sub:=Copy(s,1,Pos(':',s)-1);
      //etalon_max_size_ratio:=StrToFloat(Trim(sub)); //  считывание фактора подробности сетки
      //s:=Copy(s,Pos(':',s)+1,length(s));
      //sub:=Copy(s,1,Pos(':',s)-1);
      //etalon_max_size_ratio2:=StrToFloat(Trim(sub)); //  считывание фактора подробности сетки
      //s:=Copy(s,Pos(':',s)+1,length(s));
   end;


   if (not(bAdd_packaje)) then
   begin
   sub:=My_Get_String_for_to_val('snap_to_grid',f);
   if (length(sub)=0) then
   begin
      // default
      j:=0; // no usage
   end
   else
   begin
      j:=StrToInt(sub);
   end;
   end;

   if (not(bAdd_packaje)) then
   begin
   //sub:=Copy(s,1,Pos(':',s)-1);
   //j:=StrToInt(Trim(sub));
   // Snap to grid
   // 0.	none
	 // 1.	Snap to grid
	 // 2.	Snap to grid ALICE
	 // 3.	Snap to grid ++
   if ((j=0)or(j=1)or(j=2)or(j=3)) then
   begin
     MeshForm.ComboBoxSnapTo.ItemIndex:=j;
   end
   else
   begin
      MeshForm.ComboBoxSnapTo.ItemIndex:=0;
   end;

   sub:=My_Get_String_for_to_val('solver_setting',f);
   if (length(sub)=0) then
   begin
      // default
      FormSetting.ComboBoxSolverSetting.ItemIndex:=0; // BiCGStab+ilu2
   end
   else
   begin
      if (StrToInt(Trim(sub))>11) then
      begin
         sub:='1';
      end;
      FormSetting.ComboBoxSolverSetting.ItemIndex:=StrToInt(sub);
   end;
   end;

   //s:=Copy(s,Pos(':',s)+1,length(s));
   //sub:=Copy(s,1,Pos(':',s)-1);
   // Также поддерживается cl_agl_amg_v0_14 с января 2016 года.
   //FormSetting.ComboBoxSolverSetting.ItemIndex:=StrToInt(Trim(sub));  // BicgStab+ILU2 vs amg1r5.
   //s:=Copy(s,Pos(':',s)+1,length(s));
    if (not(bAdd_packaje)) then
    begin

       sub:=My_Get_String_for_to_val('film_coefficient',f);
       if (length(sub)=0) then
       begin
          // default
          filmcoefficient:=0.0;
       end
        else
       begin
          filmcoefficient:=StrToFloat(sub);
       end;


       //sub:=Copy(s,1,Pos(':',s)-1);
       //filmcoefficient:=StrToFloat(Trim(sub)); //  считывание  коэффициента теплоотдачи.
       //s:=Copy(s,Pos(':',s)+1,length(s));
       //sub:=Copy(s,1,Pos(':',s)-1);

       sub:=My_Get_String_for_to_val('adiabatic_vs_heat_transfer_coeff',f);
       if (length(sub)=0) then
       begin
          // default
          adiabatic_vs_heat_transfer_coeff:=0;
       end
        else
       begin
          adiabatic_vs_heat_transfer_coeff:=StrToInt(sub);
       end;

       //adiabatic_vs_heat_transfer_coeff:=StrToInt(Trim(sub));
       //s:=Copy(s,Pos(':',s)+1,length(s));
       //sub:=Copy(s,1,Pos(':',s)-1);

    end;

     if (not(bAdd_packaje)) then
     begin
        sub:=My_Get_String_for_to_val('time_step_id_law',f);
        if (length(sub)=0) then
        begin
           // default
           glSTL.id_law:=0;  // 0 - Linear, 1 - Square Wave.
        end
         else
        begin
           glSTL.id_law:=StrToInt(sub);
        end;


        //glSTL.id_law:=StrToInt(Trim(sub)); // 0 - Linear, 1 - Square Wave.
        //s:=Copy(s,Pos(':',s)+1,length(s));
        //sub:=Copy(s,1,Pos(':',s)-1);

        sub:=My_Get_String_for_to_val('time_step_factor_a_for_linear',f);
        if (length(sub)=0) then
        begin
           // default
           glSTL.Factor_a_for_Linear:=0.4; // Factor (a) for Linear Law time step.
        end
         else
        begin
           glSTL.Factor_a_for_Linear:=StrToFloat(sub);
        end;
     end;
     //glSTL.Factor_a_for_Linear:=StrToFloat(Trim(sub));  // Factor (a) for Linear Law time step.
     //s:=Copy(s,Pos(':',s)+1,length(s));
     //sub:=Copy(s,1,Pos(':',s)-1);

    if (not(bAdd_packaje)) then
    begin
       sub:=My_Get_String_for_to_val('tau',f);
       if (length(sub)=0) then
       begin
          // default
          glSTL.tau:=1.0e-4; // pulse width.
       end
        else
       begin
          glSTL.tau:=StrToFloat(sub);
       end;

       sub:=My_Get_String_for_to_val('iQ_duty_cycle',f);
       if (length(sub)=0) then
       begin
          // default
          glSTL.iQ:=4.0;  // duty cycle.
       end
        else
       begin
          glSTL.iQ:=StrToFloat(sub);
       end;

       //glSTL.tau:=StrToFloat(Trim(sub)); // tau for Square Wave.
       //s:=Copy(s,Pos(':',s)+1,length(s));
       //sub:=Copy(s,1,Pos(':',s)-1);
       //glSTL.iQ:=StrToFloat(Trim(sub)); // Скважность Q for Square Wave.
       sub:=My_Get_String_for_to_val('m1',f);
       if (length(sub)=0) then
       begin
          // default
          glSTL.m1:=0.3333;
       end
        else
       begin
          glSTL.m1:=StrToFloat(sub);
       end;

       sub:=My_Get_String_for_to_val('tau1',f);
       if (length(sub)=0) then
       begin
          // default
          glSTL.tau1:=180.0;
       end
        else
       begin
          glSTL.tau1:=StrToFloat(sub);
       end;

       sub:=My_Get_String_for_to_val('tau2',f);
       if (length(sub)=0) then
       begin
          // default
          glSTL.tau2:=240.0;
       end
        else
       begin
          glSTL.tau2:=StrToFloat(sub);
       end;

       // Параметры импульсного режима АППАРАТ.
       //s:=Copy(s,Pos(':',s)+1,length(s));
       //sub:=Copy(s,1,Pos(':',s)-1);
       //glSTL.m1:=StrToFloat(Trim(sub));
       //s:=Copy(s,Pos(':',s)+1,length(s));
       //sub:=Copy(s,1,Pos(':',s)-1);
       //glSTL.tau1:=StrToFloat(Trim(sub));
       //s:=Copy(s,Pos(':',s)+1,length(s));
       //sub:=Copy(s,1,Pos(':',s)-1);
       //glSTL.tau2:=StrToFloat(Trim(sub));
       //s:=Copy(s,Pos(':',s)+1,length(s));

   sub:=My_Get_String_for_to_val('tau_pause',f);
   if (length(sub)=0) then
   begin
      // default
      glSTL.tau_pause:=5040.0;
   end
    else
   begin
      glSTL.tau_pause:=StrToFloat(sub);
   end;

   //sub:=Copy(s,1,Pos(':',s)-1);
   //glSTL.tau_pause:=StrToFloat(Trim(sub));
   //s:=Copy(s,Pos(':',s)+1,length(s));

   sub:=My_Get_String_for_to_val('off_multiplyer',f);
   if (length(sub)=0) then
   begin
      // default
      glSTL.off_multiplyer:=0.0;
   end
    else
   begin
      glSTL.off_multiplyer:=StrToFloat(sub);
   end;



   sub:=My_Get_String_for_to_val('number_vitkov',f);
   if (length(sub)=0) then
   begin
      // default
      glSTL.n:=6;
   end
    else
   begin
      glSTL.n:=StrToInt(sub);
   end;

   //sub:=Copy(s,1,Pos(':',s)-1);
   //glSTL.n:=StrToInt(Trim(sub));
   //s:=Copy(s,Pos(':',s)+1,length(s));
   //sub:=Copy(s,1,Pos(':',s)-1);

   sub:=My_Get_String_for_to_val('Time_period',f);
   if (length(sub)=0) then
   begin
      // default
      glSTL.T:=86400.0;
   end
    else
   begin
      glSTL.T:=StrToFloat(sub);
   end;

   //glSTL.T:=StrToFloat(Trim(sub));

   sub:=My_Get_String_for_to_val('on_time_double_linear',f);
   if (length(sub)=0) then
   begin
      // default
      glSTL.on_time_double_linear:=0.3;
   end
    else
   begin
      glSTL.on_time_double_linear:=StrToFloat(sub);
   end;

   end;


    if (not(bAdd_packaje)) then
   begin
   sub:=My_Get_String_for_to_val('length',f);
   if (length(sub)=0) then
   begin
      // default
      imlength:=1;    //mm
   end
    else
   begin
      imlength:=StrToInt(sub);
   end;

   //s:=f.Strings[i]; inc(i);
   //imlength:=StrToInt(Copy(s,Pos('length=',s)+7,length(s)));
   ComboBoxlength.ItemIndex:=imlength; // выставляем считанные единицы длины
   case imlength of
    0 : begin
           // m
           mlength:=1.0;
        end;
    1 : begin
           // mm
           mlength:=1e-3;
        end;
    2 : begin
           // micron
           mlength:=1e-6;
        end;
   end;
   end;
   // считывание информации о таблично заданной мощности.
  // s:=f.Strings[i]; inc(i);




   if (not(bAdd_packaje)) then
   begin
      sub:=My_Get_String_for_to_val('ltdp',f);
      if (length(sub)=0) then
      begin
         // default
         iltdp:=0;
      end
       else
      begin
         iltdp:=StrToInt(sub);
      end;

      //iltdp:=StrToInt(Copy(s,Pos('ltdp=',s)+5,length(s)));
      SetLength(listtablename,iltdp);
      for j:=0 to iltdp-1 do
      begin
         //power_table_number
         sub:=My_Get_String_for_to_val('power_table_number'+IntToStr(j),f);
         if (length(sub)>0) then
         begin
            listtablename[j]:=Trim(sub); // имя файла с таблицей.
         end
          else
         begin
            ShowMessage('error! variable power_table_number is empty.');
            listtablename[j]:='noname'+IntToStr(j);
         end;
      end;

   end;

   // считывание информации об объединениях :
   //s:=f.Strings[i]; inc(i);

     if ((bAdd_packaje)) then
     begin
        iunion_old:=lu;
     end
      else
     begin
        iunion_old:=0;
     end;

     sub:=My_Get_String_for_to_val('lu',f);
     if (length(sub)=0) then
     begin
        // default
        lu:=0;
     end
      else
     begin
        lu:=StrToInt(sub);
     end;

     lu:=lu+ iunion_old;

   //lu:=StrToInt(Trim(Copy(s,Pos('lu=',s)+3,length(s))));

   SetLength(myassembles,lu);
   bOk:=true;

   // Добавляем новые юнионы в конец списка, к их именам приписываем 'imp'  + inumber_package_load
   // Чтобы избежать конфликта имён.
   // идентификатор нового юниона увеличен на число старых юнионов.


   for j:=iunion_old to lu-1 do
   begin

      if ((bAdd_packaje)) then
      begin
         myassembles[j].name:=Trim(My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'name',f))+'imp'+IntToStr(inumber_package_load);
      end
       else
      begin
        myassembles[j].name:=Trim(My_Get_String_for_to_val('ass'+IntToStr(j)+'name',f));
      end;
      //s:=f.Strings[i]; inc(i);
      //sub:=Copy(s,1,Pos(':',s)-1);
      //myassembles[j].name:=Trim(sub);

       sub:=My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'identifire',f);
       if (length(sub)=0) then
       begin
          // default
          myassembles[j].identifire:=0;
       end
        else
       begin
          myassembles[j].identifire:=iunion_old+StrToInt(sub);
       end;

      //s:=Copy(s,Pos(':',s)+1,length(s));
      //sub:=Copy(s,1,Pos(':',s)-1);
      //myassembles[j].identifire:=StrToInt(Trim(sub));
      myassembles[j].bVisible:=True; // при считывании по умолчанию все элементы полностью видимы.
       // s:=Copy(s,Pos(':',s)+1,length(s));
       //sub:=Copy(s,1,Pos(':',s)-1);
       sub:=My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'iunionparent',f);
       if (length(sub)=0) then
       begin
          // default
          myassembles[j].iunionparent:=-1;
       end
        else
       begin
          if (StrToInt(sub)=0) then
          begin
             myassembles[j].iunionparent:=-1;
          end
          else
          begin
             //myassembles[j].iunionparent:=iunion_old+StrToInt(sub);
             //MainMemo.Lines.Add('iunionparent='+IntToStr(myassembles[j].iunionparent));
             // У нас не может быть многоуровневой вложенности ассемблесов.
             // 07.09.2019
             myassembles[j].iunionparent:=-1;
          end;
       end;

      //myassembles[j].iunionparent:=StrToInt(Trim(sub));
      //s:=Copy(s,Pos(':',s)+1,length(s));
      //sub:=Copy(s,1,Pos(':',s)-1);
       sub:=My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'type_mesh',f);
       if (length(sub)=0) then
       begin
          // default
         imeshassemblesseparately:=0;
       end
        else
       begin
          imeshassemblesseparately:=StrToInt(sub);
       end;

      //imeshassemblesseparately:=StrToInt(Trim(sub));
      if (imeshassemblesseparately=0) then
      begin
         myassembles[j].bmesh_assembles_separately:=false;
      end
       else
      begin
         myassembles[j].bmesh_assembles_separately:=true;
      end;

       //s:=Copy(s,Pos(':',s)+1,length(s));
       //sub:=Copy(s,1,Pos(':',s)-1);
       sub:=My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'sxmin',f);
       if (length(sub)=0) then
       begin
          // default
         myassembles[j].sxmin:='-0.5';
       end
        else
       begin
          myassembles[j].sxmin:=Trim(sub);
       end;

      //myassembles[j].sxmin:=Trim(sub);
      if (bOk) then myassembles[j].xmin:=FormVariables.my_real_convert(Trim(sub),bOk);
      //s:=Copy(s,Pos(':',s)+1,length(s));
      //sub:=Copy(s,1,Pos(':',s)-1);

       sub:=My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'sxmax',f);
       if (length(sub)=0) then
       begin
          // default
         myassembles[j].sxmax:='0.5';
       end
        else
       begin
          myassembles[j].sxmax:=Trim(sub);
       end;

      // myassembles[j].sxmax:=Trim(sub);
      if (bOk) then myassembles[j].xmax:=FormVariables.my_real_convert(Trim(sub),bOk);

      //s:=Copy(s,Pos(':',s)+1,length(s));
      //sub:=Copy(s,1,Pos(':',s)-1);

       sub:=My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'symin',f);
       if (length(sub)=0) then
       begin
          // default
         myassembles[j].symin:='-0.5';
       end
        else
       begin
          myassembles[j].symin:=Trim(sub);
       end;

      //myassembles[j].symin:=Trim(sub);
      if (bOk) then myassembles[j].ymin:=FormVariables.my_real_convert(Trim(sub),bOk);

      //s:=Copy(s,Pos(':',s)+1,length(s));
      //sub:=Copy(s,1,Pos(':',s)-1);

       sub:=My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'symax',f);
       if (length(sub)=0) then
       begin
          // default
         myassembles[j].symax:='0.5';
       end
        else
       begin
          myassembles[j].symax:=Trim(sub);
       end;


      //myassembles[j].symax:=Trim(sub);
      if (bOk) then myassembles[j].ymax:=FormVariables.my_real_convert(Trim(sub),bOk);

      //s:=Copy(s,Pos(':',s)+1,length(s));
      //sub:=Copy(s,1,Pos(':',s)-1);

       sub:=My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'szmin',f);
       if (length(sub)=0) then
       begin
          // default
         myassembles[j].szmin:='-0.5';
       end
        else
       begin
          myassembles[j].szmin:=Trim(sub);
       end;

      //myassembles[j].szmin:=Trim(sub);
      if (bOk) then myassembles[j].zmin:=FormVariables.my_real_convert(Trim(sub),bOk);
      //s:=Copy(s,Pos(':',s)+1,length(s));
      //sub:=Copy(s,1,Pos(':',s)-1);

       sub:=My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'szmax',f);
       if (length(sub)=0) then
       begin
          // default
         myassembles[j].szmax:='0.5';
       end
        else
       begin
          myassembles[j].szmax:=Trim(sub);
       end;

      //myassembles[j].szmax:=Trim(sub);
      if (bOk) then myassembles[j].zmax:=FormVariables.my_real_convert(Trim(sub),bOk);

      //s:=Copy(s,Pos(':',s)+1,length(s));
      //sub:=Copy(s,1,Pos(':',s)-1);

       sub:=My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'inxloc',f);
       if (length(sub)=0) then
       begin
          // default
          myassembles[j].inxloc:=23;
       end
        else
       begin
          myassembles[j].inxloc:=StrToInt(sub);
       end;

      //myassembles[j].inxloc:=StrToInt(Trim(sub));
      //s:=Copy(s,Pos(':',s)+1,length(s));
      //sub:=Copy(s,1,Pos(':',s)-1);

       sub:=My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'inyloc',f);
       if (length(sub)=0) then
       begin
          // default
          myassembles[j].inyloc:=23;
       end
        else
       begin
          myassembles[j].inyloc:=StrToInt(sub);
       end;

      //myassembles[j].inyloc:=StrToInt(Trim(sub));
      //s:=Copy(s,Pos(':',s)+1,length(s));
      //sub:=Copy(s,1,Pos(':',s)-1);

       sub:=My_Get_String_for_to_val('ass'+IntToStr(j-iunion_old)+'inzloc',f);
       if (length(sub)=0) then
       begin
          // default
          myassembles[j].inzloc:=23;
       end
        else
       begin
          myassembles[j].inzloc:=StrToInt(sub);
       end;

      //myassembles[j].inzloc:=StrToInt(Trim(sub));
   end;

   //s:=f.Strings[i]; inc(i);
   if (not(bAdd_packaje)) then
   begin
      // В пакете не должно быть переменных.

      sub:=My_Get_String_for_to_val('ivarmax',f);
      if (length(sub)=0) then
      begin
         // default
         ivar:=0;
      end
       else
      begin
         ivar:=StrToInt(sub);
      end;

      //ivar:=StrToInt(Trim(Copy(s,Pos('ivarmax=',s)+8,length(s))));
      SetLength(parametric,ivar); // выделение памяти под переменные
      for j:=0 to ivar-1 do
      begin
         // считываем переменные из входного файла :
         //s:=f.Strings[i]; inc(i);
         //sub:=Copy(s,1,Pos(':',s)-1);

         sub:=My_Get_String_for_to_val('var'+IntToStr(j)+'name',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! variable name is empty.');
            parametric[j].svar:='$noname'+IntToStr(j);
         end
           else
         begin
            parametric[j].svar:=Trim(sub);  // имя переменной
         end;

         //s:=Copy(s,Pos(':',s)+1,length(s));
         //sub:=Copy(s,1,Pos(':',s)-1);
         sub:=My_Get_String_for_to_val('var'+IntToStr(j)+'value',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! variable value is empty.');
            parametric[j].sval:='0.0'; // значение переменной
         end
           else
         begin
            parametric[j].sval:=Trim(sub); // значение переменной
         end;
      end;


   end
   else
   begin
     // Если переменные в пакете всеже есть.
      sub:=My_Get_String_for_to_val('ivarmax',f);
      if (length(sub)=0) then
      begin
         ivar_package:=0;
      end
       else
      begin
         ivar_package:=StrToInt(sub);
      end;

       for j:=0 to ivar_package-1 do
      begin
         // считываем переменные из входного файла :
         //s:=f.Strings[i]; inc(i);
         //sub:=Copy(s,1,Pos(':',s)-1);

         sub:=My_Get_String_for_to_val('var'+IntToStr(j)+'name',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! package variable name is empty.');
            //parametric[j].svar:='$noname'+IntToStr(j);
         end
           else
         begin
            if ((length(Trim(sub))=length('$emiss'))and(pos(Trim(sub),'$emiss')=1)) then
            begin
              // У нас совпадение переменных $emiss

              // Есть ли эта переменная в исходном проекте. Равны ли значения
              // переменной emiss в пакете и исходном проекте.
            end
            else
            begin
                if ((length(Trim(sub))=length('$alpha'))and(pos(Trim(sub),'$alpha')=1)) then
                begin
                    // У нас совпадение переменных $alpha

                    // Есть ли эта переменная в исходном проекте. Равны ли значения
                    // переменной emiss в пакете и исходном проекте.
                end
                else
                begin
                    // Надо проверить есть ли переменная с таким именем в исходном проекте.
                    bfound_variable:=false;
                    not_ignoring:=true;
                    for j_var := 0 to ivar-1 do
                      begin
                         if ((length(Trim(sub))=length(Trim(parametric[j_var].svar)))and(pos(Trim(sub),Trim(parametric[j_var].svar))=1))  then
                         begin
                            // Найдено полное совпадение.
                            bfound_variable:=true;

                             subloc:=My_Get_String_for_to_val('var'+IntToStr(j)+'value',f);
                             if (abs(StrToFloat(Trim(subloc))-StrToFloat(Trim(parametric[j_var].sval)))<1.0e-14) then
                             begin
                                not_ignoring:=false; // игнорируем. Такая переменная уже есть.
                                // При этом не выдается никаких предупреждающих сообщений. Тихое считывание файла.
                             end;
                         end;
                      end;

                      if (not_ignoring) then
                      begin

                         if (bfound_variable) then
                         begin
                            // Надо дать переменной новое имя и переименовать всё
                            // внутри пакета.
                            ShowMessage('WARNING! package variable name is found in the name project variable. Please rename conflict project variable.');

                            // Показать форму в которой надо выбрать что мы удаляем.
                            // Пы показываем все проектные переменные (текущие).
                            // Устанавливаем марке в списке на последнюю переменную из списка.
                            FormRenameVar.ComboBox1.Clear();
                            FormRenameVar.LabelConflictName.Caption:=Trim(sub);
                            for j_var := 0 to Laplas.ivar-1 do
                            begin
                               FormRenameVar.ComboBox1.Items.Add(Trim(Laplas.parametric[j_var].svar));
                            end;
                            FormRenameVar.ComboBox1.ItemIndex:=Laplas.ivar-1;
                            FormRenameVar.EditNewName.Text:='';
                            FormRenameVar.ShowModal;

                            // На данном этапе гарантируется что введенное новое имя переменной
                            // уникально и не совпадает с именами других проектных переменных.
                            if (FormRenameVar.bOk_rename) then
                            begin
                               snew:= Trim(FormRenameVar.EditNewName.Text);
                               // Нельзя выбирать конфликтную переменную из списка самому.
                               // Можно легко запутататься. Имя конфликтной переменной известно
                               // программно. Список с именами проектных переменных нужен только для того чтобы
                               // посмотреть какие переменные уже есть в проекте чтобы не задать совпадающее имя.
                               //sold:=Trim(FormRenameVar.ComboBox1.Items[FormRenameVar.ComboBox1.ItemIndex]);
                               sold:=Trim(sub);

                               FormVariables.all_obj_project_variable_rename(sold,snew);

                               FormVariables.StringGridVariables.Cells[1,1+FormRenameVar.ComboBox1.ItemIndex]:=Trim(snew);
                               Laplas.parametric[FormRenameVar.ComboBox1.ItemIndex].svar:=Trim(snew);

                               // обновление размеров объектов
                               FormVariables.my_update_size();
                               bfound_variable:=false;
                            end;
                            FormRenameVar.bOk_rename:=false;
                         end;

                         if (not(bfound_variable)) then
                         begin
                            // Переменная уникальна 19.08.2019
                            inc(ivar);
                            SetLength(parametric,ivar); // выделение памяти под переменные
                            parametric[ivar-1].svar:=Trim(sub);  // имя переменной
                            // Надо задать значение.
                            //s:=Copy(s,Pos(':',s)+1,length(s));
                            //sub:=Copy(s,1,Pos(':',s)-1);
                            sub:=My_Get_String_for_to_val('var'+IntToStr(j)+'value',f);
                            if (length(sub)=0) then
                            begin
                               ShowMessage('error! package variable value is empty.');
                               parametric[ivar-1].sval:='0.0'; // значение переменной
                            end
                             else
                            begin
                               parametric[ivar-1].sval:=Trim(sub); // значение переменной
                            end;
                         end; // Уникальная переменная.
                      end;

                end;
            end;
         end;
      end;

   end;





   if (not(bAdd_packaje)) then
   begin
      imatherial_old:=0;
   end
   else
   begin
      imatherial_old:=lmatmax;
   end;

   //s:=f.Strings[i];
   sub:=My_Get_String_for_to_val('lmatmax',f);
   if (length(sub)=0) then
   begin
      // default
      lmatmax:=0;
      ShowMessage('error! lmatmax value is empty.');
   end
    else
   begin
      lmatmax:=StrToInt(sub);
   end;

   lmatmax:=imatherial_old+lmatmax;
   //ShowMessage(IntToStr(lmatmax));

   //lmatmax:=StrToInt(Copy(s,Pos('lmatmax=',s)+8,length(s)));

   SetLength(workmat,lmatmax); // выделение оперативной памяти
   // Считываем материалы:
   for j:=imatherial_old to (lmatmax-1) do
   begin
      // inc(i); s:=f.Strings[i];
      //myreadmaterial(workmat[j],s);


      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'name',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial name is empty.');
         workmat[j].namemat:='noname_matherial'+IntToStr(j); // назваание материала по умолчанию
      end
        else
      begin
         workmat[j].namemat:=Trim(sub); // название материала
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'density',f);
      if (length(sub)=0) then
      begin
          ShowMessage('error! matherial density is empty.');
         workmat[j].rho:=1.225; // плотность по умолчанию (материал воздух).
      end
        else
      begin
         workmat[j].rho:=StrToFloat(Trim(sub)); // плотность материала
      end;

      // Удельная теплоёмкость при постоянном давлении.

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'nCp',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial nCp is empty.');
         workmat[j].n_cp:=1;
      end
        else
      begin
         workmat[j].n_cp:=StrToInt(Trim(sub)); // количество значений для таблично заданной теплоёмкости материала
      end;

      // Выделение оперативной памяти.
      SetLength(workmat[j].temp_cp, workmat[j].n_cp);
      SetLength(workmat[j].arr_cp, workmat[j].n_cp);

      // цикл по новой локальной переменной.
      for i_1:=0 to (workmat[j].n_cp-1) do
      begin
          sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'Temp_Cp'+IntToStr(i_1),f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! matherial Temp Cp is empty.');
             workmat[j].temp_cp[i_1]:=300.0+i_1; // Температуры при которых задана удельная теплоёмкость при постоянном давлении.
          end
           else
          begin
             workmat[j].temp_cp[i_1]:=StrToFloat(Trim(sub)); // температура при которой задана удельная теплоёмкость при постоянном давлении.
          end;

          sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'Arr_Cp_val'+IntToStr(i_1),f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! matherial Arr Cp value is empty.');
             workmat[j].arr_cp[i_1]:=1005.0; // удельная теплоёмкость по умолчанию.
          end
           else
          begin
             workmat[j].arr_cp[i_1]:=StrToFloat(Trim(sub)); // температура при которой задана удельная теплоёмкость при постоянном давлении.
          end;

      end;

      // Теплопроводность.

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'n_lambda',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial n_lambda is empty.');
         workmat[j].n_lam:=1;
      end
        else
      begin
         workmat[j].n_lam:=StrToInt(Trim(sub)); // количество значений для таблично заданной теплопроводности материала
      end;

       // Выделение оперативной памяти.
      SetLength(workmat[j].temp_lam, workmat[j].n_lam);
      SetLength(workmat[j].arr_lam, workmat[j].n_lam);

      // цикл по новой локальной переменной.
      for i_1:=0 to (workmat[j].n_lam-1) do
      begin
          sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'Temp_Lam'+IntToStr(i_1),f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! matherial Temp Lam is empty.');
             workmat[j].temp_lam[i_1]:=300.0+i_1; // Температуры при которых задана теплопроводность.
          end
           else
          begin
             workmat[j].temp_lam[i_1]:=StrToFloat(Trim(sub)); // температура при которой задана теплопроводность.
          end;

          sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'Arr_Lam_val'+IntToStr(i_1),f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! matherial Arr Lam val value is empty.');
             workmat[j].arr_lam[i_1]:=1.1614; // теплопроводность по умолчанию.
          end
           else
          begin
             workmat[j].arr_lam[i_1]:=StrToFloat(Trim(sub)); // температура при которой задана теплопроводность.
          end;

      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_lam_x',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial mult_lam_x is empty.');
         workmat[j].mult_lam_x:=1;
      end
        else
      begin
         workmat[j].mult_lam_x:=StrToFloat(Trim(sub)); // multiplyer x - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_lam_y',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial mult_lam_y is empty.');
         workmat[j].mult_lam_y:=1;
      end
        else
      begin
         workmat[j].mult_lam_y:=StrToFloat(Trim(sub)); // multiplyer y - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_lam_z',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial mult_lam_z is empty.');
         workmat[j].mult_lam_z:=1;
      end
        else
      begin
         workmat[j].mult_lam_z:=StrToFloat(Trim(sub)); // multiplyer z - axis
      end;

      // Thermal-Stress

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_Linear_expansion_coefficient_x',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial mult_Linear_expansion_coefficient_x is empty.');
         MainMemo.Lines.Add('error! matherial mult_Linear_expansion_coefficient_x is empty.');
         workmat[j].mult_Linear_expansion_coefficient_x:=1;
      end
        else
      begin
         workmat[j].mult_Linear_expansion_coefficient_x:=StrToFloat(Trim(sub)); // multiplyer x - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_Linear_expansion_coefficient_y',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial mult_Linear_expansion_coefficient_y is empty.');
         MainMemo.Lines.Add('error! matherial mult_Linear_expansion_coefficient_y is empty.');
         workmat[j].mult_Linear_expansion_coefficient_y:=1;
      end
        else
      begin
         workmat[j].mult_Linear_expansion_coefficient_y:=StrToFloat(Trim(sub)); // multiplyer y - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_Linear_expansion_coefficient_z',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial mult_Linear_expansion_coefficient_z is empty.');
         MainMemo.Lines.Add('error! matherial mult_Linear_expansion_coefficient_z is empty.');
         workmat[j].mult_Linear_expansion_coefficient_z:=1;
      end
        else
      begin
         workmat[j].mult_Linear_expansion_coefficient_z:=StrToFloat(Trim(sub)); // multiplyer z - axis
      end;

      // Модуль Юнга

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_Young_Module_x',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial mult_Young_Module_x is empty.');
         MainMemo.Lines.Add('error! matherial mult_Young_Module_x is empty.');
         workmat[j].mult_Young_Module_x:=1;
      end
        else
      begin
         workmat[j].mult_Young_Module_x:=StrToFloat(Trim(sub)); // multiplyer x - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_Young_Module_y',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial mult_Young_Module_y is empty.');
         MainMemo.Lines.Add('error! matherial mult_Young_Module_y is empty.');
         workmat[j].mult_Young_Module_y:=1;
      end
        else
      begin
         workmat[j].mult_Young_Module_y:=StrToFloat(Trim(sub)); // multiplyer y - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_Young_Module_z',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial mult_Young_Module_z is empty.');
         MainMemo.Lines.Add('error! matherial mult_Young_Module_z is empty.');
         workmat[j].mult_Young_Module_z:=1;
      end
        else
      begin
         workmat[j].mult_Young_Module_z:=StrToFloat(Trim(sub)); // multiplyer z - axis
      end;


      // multiplyer Коэффициента Пуассона.

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_Poisson_ratio_xy',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial mult_Poisson_ratio_xy is empty.');
         MainMemo.Lines.Add('error! matherial mult_Poisson_ratio_xy is empty.');
         workmat[j].mult_Poisson_ratio_xy:=1;
      end
        else
      begin
         workmat[j].mult_Poisson_ratio_xy:=StrToFloat(Trim(sub)); // multiplyer z - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_Poisson_ratio_xz',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial mult_Poisson_ratio_xz is empty.');
         MainMemo.Lines.Add('error! matherial mult_Poisson_ratio_xz is empty.');
         workmat[j].mult_Poisson_ratio_xz:=1;
      end
        else
      begin
         workmat[j].mult_Poisson_ratio_xz:=StrToFloat(Trim(sub)); // multiplyer y - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_Poisson_ratio_yz',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial mult_Poisson_ratio_yz is empty.');
         MainMemo.Lines.Add('error! matherial mult_Poisson_ratio_yz is empty.');
         workmat[j].mult_Poisson_ratio_yz:=1;
      end
        else
      begin
         workmat[j].mult_Poisson_ratio_yz:=StrToFloat(Trim(sub)); // multiplyer x - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_Poisson_ratio_yx',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial mult_Poisson_ratio_yx is empty.');
         MainMemo.Lines.Add('error! matherial mult_Poisson_ratio_yx is empty.');
         workmat[j].mult_Poisson_ratio_yx:=1;
      end
        else
      begin
         workmat[j].mult_Poisson_ratio_yx:=StrToFloat(Trim(sub)); // multiplyer z - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_Poisson_ratio_zx',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial mult_Poisson_ratio_zx is empty.');
         MainMemo.Lines.Add('error! matherial mult_Poisson_ratio_zx is empty.');
         workmat[j].mult_Poisson_ratio_zx:=1;
      end
        else
      begin
         workmat[j].mult_Poisson_ratio_zx:=StrToFloat(Trim(sub)); // multiplyer y - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mult_Poisson_ratio_zy',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial mult_Poisson_ratio_zy is empty.');
         MainMemo.Lines.Add('error! matherial mult_Poisson_ratio_zy is empty.');
         workmat[j].mult_Poisson_ratio_zy:=1;
      end
        else
      begin
         workmat[j].mult_Poisson_ratio_zy:=StrToFloat(Trim(sub)); // multiplyer x - axis
      end;

      // Модуль сдвига
      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'bShearModuleActive',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial bShearModuleActive is empty.');
         MainMemo.Lines.Add('error! matherial bShearModuleActive is empty.');
         workmat[j].bShearModuleActive:=false;
      end
        else
      begin
         if (StrToInt(Trim(sub))=1) then
         begin
            workmat[j].bShearModuleActive:=true;
         end
         else
         begin
            workmat[j].bShearModuleActive:=false;
         end;
      end;

      bPostShearStressxy:=false;
      bPostShearStressyz:=false;
      bPostShearStressxz:=false;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'ShearModuleGxy',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial ShearModuleGxy is empty.');
         MainMemo.Lines.Add('error! matherial ShearModuleGxy is empty.');
         bPostShearStressxy:=true;
      end
        else
      begin
         workmat[j].ShearModuleGxy:=StrToFloat(Trim(sub)); // multiplyer z - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'ShearModuleGyz',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial ShearModuleGyz is empty.');
         MainMemo.Lines.Add('error! matherial ShearModuleGyz is empty.');
         bPostShearStressyz:=true;
      end
        else
      begin
         workmat[j].ShearModuleGyz:=StrToFloat(Trim(sub)); // multiplyer y - axis
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'ShearModuleGxz',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial ShearModuleGxz is empty.');
         MainMemo.Lines.Add('error! matherial ShearModuleGxz is empty.');
         bPostShearStressxz:=true;
      end
        else
      begin
         workmat[j].ShearModuleGxz:=StrToFloat(Trim(sub)); // multiplyer x - axis
      end;


      // Коэффициент Пуассона

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'n_Poisson_ratio',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial n_Poisson_ratio is empty.');
         workmat[j].n_Poisson_ratio:=1;
         SetLength(workmat[j].temp_Poisson_ratio, workmat[j].n_Poisson_ratio);
         SetLength(workmat[j].arr_Poisson_ratio, workmat[j].n_Poisson_ratio);

         iq:=0;
         bsbros:=true;

         sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'Poisson_ratio',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! matherial Poisson_ratio is empty.');
            workmat[j].temp_Poisson_ratio[0]:=20.0;
            workmat[j].arr_Poisson_ratio[0]:=0.154; // AlSiC-8
         end
          else
         begin

            workmat[j].temp_Poisson_ratio[0]:=20.0;
            workmat[j].arr_Poisson_ratio[0]:=StrToFloat(Trim(sub)); // Poisson_ratio
         end;
      end
        else
      begin
         workmat[j].n_Poisson_ratio:=StrToInt(Trim(sub)); // количество значений для таблично заданного коэффициента Пуассона
      end;

      if (not(bsbros)) then
      begin
         // Выделение оперативной памяти.
         SetLength(workmat[j].temp_Poisson_ratio, workmat[j].n_Poisson_ratio);
         SetLength(workmat[j].arr_Poisson_ratio, workmat[j].n_Poisson_ratio);

      // цикл по новой локальной переменной.
      for i_1:=0 to (workmat[j].n_Poisson_ratio-1) do
      begin
          sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'temp_Poisson_ratio'+IntToStr(i_1),f);
          if (length(sub)=0) then
          begin
             if (j>0) then
             begin
                ShowMessage('error! matherial temp_Poisson_ratio is empty.');
                workmat[j].temp_Poisson_ratio[i_1]:=300.0+i_1; // Температуры при которых задан Poisson_ratio.
             end;
          end
           else
          begin
             workmat[j].temp_Poisson_ratio[i_1]:=StrToFloat(Trim(sub)); // температура при которой задан Poisson_ratio.
          end;

          sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'arr_Poisson_ratio'+IntToStr(i_1),f);
          if (length(sub)=0) then
          begin
             if (j>0) then
             begin
                ShowMessage('error! matherial arr_Poisson_ratio value is empty.');
                workmat[j].arr_Poisson_ratio[i_1]:=0.154; // Poisson_ratio по умолчанию.
             end;
          end
           else
          begin
             workmat[j].arr_Poisson_ratio[i_1]:=StrToFloat(Trim(sub)); // Poisson_ratio.
          end;

        end;
      end;


      bsbros:=false;

      // Модуль Юнга

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'n_Young_Module',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial n_Young_Module is empty.');
         workmat[j].n_Young_Module:=1;
         SetLength(workmat[j].temp_Young_Module, workmat[j].n_Young_Module);
         SetLength(workmat[j].arr_Young_Module, workmat[j].n_Young_Module);

         iq:=0;
         bsbros:=true;

         sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'Young_Module',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! matherial Young_Module is empty.');
            workmat[j].temp_Young_Module[0]:=20.0;
            workmat[j].arr_Young_Module[0]:=217.5; // GPa AlSiC-8
         end
          else
         begin

            workmat[j].temp_Young_Module[0]:=20.0;
            workmat[j].arr_Young_Module[0]:=StrToFloat(Trim(sub)); // Young_Module
         end;
      end
        else
      begin
         workmat[j].n_Young_Module:=StrToInt(Trim(sub)); // количество значений для таблично заданного модуля Юнга
      end;

      if (not(bsbros)) then
      begin
         // Выделение оперативной памяти.
         SetLength(workmat[j].temp_Young_Module, workmat[j].n_Young_Module);
         SetLength(workmat[j].arr_Young_Module, workmat[j].n_Young_Module);

      // цикл по новой локальной переменной.
      for i_1:=0 to (workmat[j].n_Young_Module-1) do
      begin
          sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'temp_Young_Module'+IntToStr(i_1),f);
          if (length(sub)=0) then
          begin
             if (j>0) then
             begin
                ShowMessage('error! matherial temp_Young_Module is empty.');
                workmat[j].temp_Young_Module[i_1]:=300.0+i_1; // Температуры при которых задан модуль Юнга.
             end;
          end
           else
          begin
             workmat[j].temp_Young_Module[i_1]:=StrToFloat(Trim(sub)); // температура при которой задан модуль Юнга.
          end;

          sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'arr_Young_Module'+IntToStr(i_1),f);
          if (length(sub)=0) then
          begin
             if (j>0) then
             begin
                ShowMessage('error! matherial arr_Young_Module value is empty.');
                workmat[j].arr_Young_Module[i_1]:=217.5; // модуль Юнга по умолчанию.
             end;
          end
           else
          begin
             workmat[j].arr_Young_Module[i_1]:=StrToFloat(Trim(sub)); // модуль Юнга.
          end;

        end;
      end;


      if (bPostShearStressxy) then
      begin
         workmat[j].ShearModuleGxy:=workmat[j].arr_Young_Module[0]/(2.0*(1.0+workmat[j].arr_Poisson_ratio[0]));
      end;

      if (bPostShearStressyz) then
      begin
         workmat[j].ShearModuleGyz:=workmat[j].arr_Young_Module[0]/(2.0*(1.0+workmat[j].arr_Poisson_ratio[0]));
      end;

      if (bPostShearStressxz) then
      begin
         workmat[j].ShearModuleGxz:=workmat[j].arr_Young_Module[0]/(2.0*(1.0+workmat[j].arr_Poisson_ratio[0]));
      end;


      bsbros:=false;

      // Коэффициент линейного теплового расширения.

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'n_Linear_expansion_coefficient',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! matherial n_Linear_expansion_coefficient is empty.');
         workmat[j].n_Linear_expansion_coefficient:=1;
         SetLength(workmat[j].temp_Linear_expansion_coefficient, workmat[j].n_Linear_expansion_coefficient);
         SetLength(workmat[j].arr_Linear_expansion_coefficient, workmat[j].n_Linear_expansion_coefficient);

         iq:=0;
         bsbros:=true;

         sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'Linear_expansion_coefficient',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! matherial Linear_expansion_coefficient is empty.');
            workmat[j].temp_Linear_expansion_coefficient[0]:=20.0;
            workmat[j].arr_Linear_expansion_coefficient[0]:=6.5; // *1E-6 AlSiC-8
         end
          else
         begin

            workmat[j].temp_Linear_expansion_coefficient[0]:=20.0;
            workmat[j].arr_Linear_expansion_coefficient[0]:=StrToFloat(Trim(sub)); // Linear_expansion_coefficient
         end;
      end
        else
      begin
         workmat[j].n_Linear_expansion_coefficient:=StrToInt(Trim(sub)); // количество значений для таблично заданного коэффициента линейного теплового расширения
      end;

      if (not(bsbros)) then
      begin
      // Выделение оперативной памяти.
      SetLength(workmat[j].temp_Linear_expansion_coefficient, workmat[j].n_Linear_expansion_coefficient);
      SetLength(workmat[j].arr_Linear_expansion_coefficient, workmat[j].n_Linear_expansion_coefficient);

      // цикл по новой локальной переменной.
      for i_1:=0 to (workmat[j].n_Linear_expansion_coefficient-1) do
      begin
          sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'temp_Linear_expansion_coefficient'+IntToStr(i_1),f);
          if (length(sub)=0) then
          begin
             if (j>0) then
             begin
                ShowMessage('error! matherial temp_Linear_expansion_coefficient is empty.');
                workmat[j].temp_Linear_expansion_coefficient[i_1]:=300.0+i_1; // Температуры при которых задан коэффициент линейного теплового расширения.
             end;
          end
           else
          begin
             workmat[j].temp_Linear_expansion_coefficient[i_1]:=StrToFloat(Trim(sub)); // температура при которой задан коэффициент линейного теплового расширения.
          end;

          sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'arr_Linear_expansion_coefficient_val'+IntToStr(i_1),f);
          if (length(sub)=0) then
          begin
             if (j>0) then
             begin
                ShowMessage('error! matherial arr_Linear_expansion_coefficient_val value is empty.');
                workmat[j].arr_Linear_expansion_coefficient[i_1]:=6.5; // коэффициент линейного теплового расширения по умолчанию.
             end;
          end
           else
          begin
             workmat[j].arr_Linear_expansion_coefficient[i_1]:=StrToFloat(Trim(sub)); // коэффициент линейного теплового расширения.
          end;

        end;
      end;


      bsbros:=false;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mu',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial dynamic viscosity is empty.');
         workmat[j].mu:=1.84e-5; // air
      end
        else
      begin
         workmat[j].mu:=StrToFloat(Trim(sub)); // dynamic viscosity
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'beta_t',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial fluid linear expansion coefficient is empty.');
         workmat[j].beta_t:=1.84e-5; // air
      end
        else
      begin
         workmat[j].beta_t:=StrToFloat(Trim(sub)); // fluid linear expansion coefficient
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'blibmat',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial blibmat is empty.');
         workmat[j].blibmat:=0; // по умолчанию не библиотечный материал
      end
        else
      begin
         workmat[j].blibmat:=StrToInt(Trim(sub)); //  библиотечный материал или нет.
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'ilibident',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial ilibident is empty.');
         workmat[j].ilibident:=100; // в библиотеке не значится
      end
        else
      begin
         workmat[j].ilibident:=StrToInt(Trim(sub)); //  номер библиотечного материала
      end;


      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'bBoussinesq',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial bBoussinesq is empty.');
         workmat[j].bBoussinesq:=1; // Приближение Буссинеска по умолчанию используется.
      end
        else
      begin
         workmat[j].bBoussinesq:=StrToInt(Trim(sub)); //  Использовать ли приближение Обербека-Буссинеска.
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'ilawmu',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial ilawmu is empty.');
         workmat[j].ilawmu:=0;
      end
        else
      begin
         workmat[j].ilawmu:=StrToInt(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mumin',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial mumin is empty.');
         workmat[j].mumin:=workmat[j].mu;
      end
        else
      begin
         workmat[j].mumin:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'mumax',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial mumax is empty.');
         workmat[j].mumax:=workmat[j].mu;
      end
        else
      begin
         workmat[j].mumax:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'Amu',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial Amu is empty.');
         workmat[j].Amu:=1.0;
      end
        else
      begin
         workmat[j].Amu:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'Bmu',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial Bmu is empty.');
         workmat[j].Bmu:=1.0;
      end
        else
      begin
         workmat[j].Bmu:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'Cmu',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial Cmu is empty.');
         workmat[j].Cmu:=1.0;
      end
        else
      begin
         workmat[j].Cmu:=StrToFloat(Trim(sub));
      end;


      sub:=My_Get_String_for_to_val('matherial'+IntToStr(j-imatherial_old)+'degreennmu',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! matherial degreennmu is empty.');
         workmat[j].degreennmu:=1.0;
      end
        else
      begin
         workmat[j].degreennmu:=StrToFloat(Trim(sub));
      end;

   end;
   priority_id:=5;
   j:=0;



   if (not(bAdd_packaje)) then
   begin



   //inc(i); s:=f.Strings[i]; // cabinet
   SetLength(body,1); // выделение оперативной памяти
   //myreadbody(body[0],s); // считывание из текстового файл

   body[j].name:='cabinet';

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'igeometry_type',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.igeometry_type is empty.');
      body[0].igeometry_type:=0; //Prism
   end
    else
   begin
      body[0].igeometry_type:=StrToInt(Trim(sub));
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'sxS',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.sxS is empty.');
      body[0].sxS:='-0.5'; //Prism
      body[0].xS:=-0.5;
   end
    else
   begin
      body[0].sxS:=Trim(sub);
      bOk:=true;
      body[0].xS:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

    sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'syS',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.syS is empty.');
      body[0].syS:='-0.5'; //Prism
      body[0].yS:=-0.5;
   end
    else
   begin
      body[0].syS:=Trim(sub);
         bOk:=true;
      body[0].yS:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

    sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'szS',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.szS is empty.');
      body[0].szS:='-0.5'; //Prism
      body[0].zS:=-0.5;
   end
    else
   begin
      body[0].szS:=Trim(sub);
        bOk:=true;
      body[0].zS:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'sxE',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.sxE is empty.');
      body[0].sxE:='0.5'; //Prism
      body[0].xE:=0.5;
   end
    else
   begin
      body[0].sxE:=Trim(sub);
       bOk:=true;
      body[0].xE:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'syE',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.syE is empty.');
      body[0].syE:='0.5'; //Prism
      body[0].yE:=0.5;
   end
    else
   begin
      body[0].syE:=Trim(sub);
       bOk:=true;
      body[0].yE:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'szE',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.szE is empty.');
      body[0].szE:='0.5'; //Prism
      body[0].zE:=0.5;
   end
    else
   begin
      body[0].szE:=Trim(sub);
      bOk:=true;
      body[0].zE:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'iPlane',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.iPlane is empty.');
      body[0].iPlane:=1; // XY
   end
    else
   begin
      body[0].iPlane:=StrToInt(Trim(sub));
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'sxC',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.sxC is empty.');
      body[0].sxC:='0.0'; // Cylinder
      body[0].xC:=0.0;
   end
    else
   begin
      body[0].sxC:=Trim(sub);
      bOk:=true;
      body[0].xC:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'syC',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.syC is empty.');
      body[0].syC:='0.0'; // Cylinder
      body[0].yC:=0.0;
   end
    else
   begin
      body[0].syC:=Trim(sub);
      bOk:=true;
      body[0].yC:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'szC',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.szC is empty.');
      body[0].szC:='0.0'; // Cylinder
      body[0].zC:=0.0;
   end
    else
   begin
      body[0].szC:=Trim(sub);
      bOk:=true;
      body[0].zC:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'sHcyl',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.sHcyl is empty.');
      body[0].sHcyl:='0.4'; // Cylinder
      body[0].Hcyl:=0.4;
   end
    else
   begin
      body[0].sHcyl:=Trim(sub);
       bOk:=true;
      body[0].Hcyl:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'sR_out_cyl',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.sR_out_cyl is empty.');
      body[0].sR_out_cyl:='0.3';
      //body[0].sR_out_cyl:=FloatToStr(0.3*0.5*(sqrt())); // Cylinder
     body[0].R_out_cyl:=0.3;
   end
    else
   begin
      body[0].sR_out_cyl:=Trim(sub);
      bOk:=true;
      body[0].R_out_cyl:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'sR_in_cyl',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.sR_in_cyl is empty.');
      body[0].sR_in_cyl:='0.0'; // Cylinder
      body[0].R_in_cyl:=0.0;
   end
    else
   begin
      body[0].sR_in_cyl:=Trim(sub);
      bOk:=true;
      body[0].R_in_cyl:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   // 18.01.2018
   // bCylinder2Prism
   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'bCylinder2Prism',f);
   if (length(sub)=0) then
   begin
      // Не печатаем предупреждающее сообщение т.к. параметр новый
      // и в большом количестве моделей он просто отсутствует.
      //ShowMessage('error! body0.bCylinder2Prism is empty.');
      body[0].bCylinder2Prism:=true; // Cylinder2Prism
   end
    else
   begin
      if (StrToInt(Trim(sub))=1) then
      begin
         body[0].bCylinder2Prism:=true;
      end
       else
      begin
         body[0].bCylinder2Prism:=false;
      end;
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'sR_out_cyl2',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.sR_out_cyl2 is empty.');
      body[0].sR_out_cyl2:='0.0'; // sector, conoid
      body[0].R_out_cyl2:=0.0;
   end
    else
   begin
      body[0].sR_out_cyl2:=Trim(sub);
      bOk:=true;
      body[0].R_out_cyl2:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'sR_in_cyl2',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.sR_in_cyl2 is empty.');
      body[0].sR_in_cyl2:='0.0'; // sector, conoid
      body[0].R_in_cyl2:=0.0;
   end
    else
   begin
      body[0].sR_in_cyl2:=Trim(sub);
       bOk:=true;
      body[0].R_in_cyl2:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'sangle_start',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.sangle_start is empty.');
      body[0].sangle_start:='0.0'; // sector, conoid
      body[0].angle_start:=0.0;
   end
    else
   begin
      body[0].sangle_start:=Trim(sub);
      bOk:=true;
      body[0].angle_start:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'sangle_end',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.sangle_end is empty.');
      body[0].sangle_end:='0.0'; // sector, conoid
      body[0].angle_end:=0.0;
   end
    else
   begin
      body[0].sangle_end:=Trim(sub);
      bOk:=true;
      body[0].angle_end:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   // POLYGON
   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'iPlane_obj2',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.iPlane_obj2 is empty.');
      body[0].iPlane_obj2:=1; // XY
   end
    else
   begin
      body[0].iPlane_obj2:=StrToInt(Trim(sub));
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'nsizei',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.nsizei is empty.');
      body[0].nsizei:=3;
   end
    else
   begin
      body[0].nsizei:=StrToInt(Trim(sub));
   end;

     SetLength(body[0].hi,body[0].nsizei);
   SetLength(body[0].xi,body[0].nsizei);
   SetLength(body[0].yi,body[0].nsizei);
   SetLength(body[0].zi,body[0].nsizei);

   for i_1 := 0 to body[0].nsizei-1 do
   begin
      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'hi'+IntToStr(i_1),f);
      if (length(sub)=0) then
      begin
          ShowMessage('error! body0.hi['+IntToStr(i_1)+'] is empty.');
          body[0].hi[i_1]:=0.2;
      end
       else
      begin
         //body[0].hi[i_1]:=StrToFloat(Trim(sub));
         bOk:=true;
         body[0].hi[i_1]:=FormVariables.my_real_convert(Trim(sub),bOk);
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'xi'+IntToStr(i_1),f);
      if (length(sub)=0) then
      begin
          ShowMessage('error! body0.xi['+IntToStr(i_1)+'] is empty.');
          body[0].xi[i_1]:=0.0;
      end
       else
      begin
         //body[0].xi[i_1]:=StrToFloat(Trim(sub));
         bOk:=true;
         body[0].xi[i_1]:=FormVariables.my_real_convert(Trim(sub),bOk);
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'yi'+IntToStr(i_1),f);
      if (length(sub)=0) then
      begin
          ShowMessage('error! body0.yi['+IntToStr(i_1)+'] is empty.');
          body[0].yi[i_1]:=0.0;
      end
       else
      begin
         //body[0].yi[i_1]:=StrToFloat(Trim(sub));
         bOk:=true;
         body[0].yi[i_1]:=FormVariables.my_real_convert(Trim(sub),bOk);
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'zi'+IntToStr(i_1),f);
      if (length(sub)=0) then
      begin
          ShowMessage('error! body0.zi['+IntToStr(i_1)+'] is empty.');
          body[0].zi[i_1]:=0.0;
      end
       else
      begin
         //body[0].zi[i_1]:=StrToFloat(Trim(sub));
         bOk:=true;
         body[0].zi[i_1]:=FormVariables.my_real_convert(Trim(sub),bOk);
      end;

   end;

   // emissivity:

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'semissW',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.semissW is empty.');
      (*
      if (FormatSettings.DecimalSeparator=',') then
      begin
          body[0].semissW:='0,001';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
          body[0].semissW:='0.001';
      end;
      *)
      body[0].semissW:='$emiss';
   end
    else
   begin
      body[0].semissW:=Trim(sub);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'semissE',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.semissE is empty.');
     (*
      if (FormatSettings.DecimalSeparator=',') then
      begin
          body[0].semissE:='0,001';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
          body[0].semissE:='0.001';
      end;
      *)
       body[0].semissE:='$emiss';
   end
    else
   begin
      body[0].semissE:=Trim(sub);
   end;

    sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'semissS',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.semissS is empty.');
      (*
      if (FormatSettings.DecimalSeparator=',') then
      begin
          body[0].semissS:='0,001';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
          body[0].semissS:='0.001';
      end;
      *)
      body[0].semissS:='$emiss';
   end
    else
   begin
      body[0].semissS:=Trim(sub);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'semissN',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.semissN is empty.');
      (*
      if (FormatSettings.DecimalSeparator=',') then
      begin
          body[0].semissN:='0,001';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
          body[0].semissN:='0.001';
      end;
      *)
      body[0].semissN:='$emiss';
   end
    else
   begin
      body[0].semissN:=Trim(sub);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'semissB',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.semissB is empty.');
      (*
      if (FormatSettings.DecimalSeparator=',') then
      begin
          body[0].semissB:='0,001';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
          body[0].semissB:='0.001';
      end;
      *)
      body[0].semissB:='$emiss';
   end
    else
   begin
      body[0].semissB:=Trim(sub);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'semissT',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.semissT is empty.');
      (*
      if (FormatSettings.DecimalSeparator=',') then
      begin
          body[0].semissT:='0,001';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
          body[0].semissT:='0.001';
      end;
      *)
      body[0].semissT:='$emiss';
   end
    else
   begin
      body[0].semissT:=Trim(sub);
   end;


    bOk:=true;
   body[0].emissW:=FormVariables.my_real_convert(body[0].semissW,bOk);
   body[0].emissE:=FormVariables.my_real_convert(body[0].semissE,bOk);
   body[0].emissS:=FormVariables.my_real_convert(body[0].semissS,bOk);
   body[0].emissN:=FormVariables.my_real_convert(body[0].semissN,bOk);
   body[0].emissB:=FormVariables.my_real_convert(body[0].semissB,bOk);
   body[0].emissT:=FormVariables.my_real_convert(body[0].semissT,bOk);


   // Считать ли излучение внутри блока
    sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'binternalRadiation',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.binternalRadiation is empty.');
      body[0].binternalRadiation:=0;
   end
    else
   begin
      body[0].binternalRadiation:=StrToInt(Trim(sub));
   end;

   // идентификатор рабочего материала.
   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'imatid',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.imatid is empty.');
      body[0].imatid:=1; // идентификатор материала.
   end
    else
   begin
      body[0].imatid:=StrToInt(Trim(sub));
   end;


   // Фиксация боковой стенки цилиндра при расчёте прочности.
   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'CylinderFixed',f);
    if (length(sub)=0) then
   begin
      body[0].CylinderFixed:=false;
   end
     else
   begin
      if (StrToInt(Trim(sub))=1) then
      begin
         body[0].CylinderFixed:=true;
      end
        else
      begin
         body[0].CylinderFixed:=false;
      end
   end;


   // Кусочно - линейная мощность тепловыделения.
   sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'n_power',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body0.n_power is empty.');
      body[0].n_power:=1; // Количество значений таблично-заданной мощности тепловыделения.
   end
    else
   begin
      body[0].n_power:=StrToInt(Trim(sub));
   end;

   SetLength(body[0].temp_power ,body[0].n_power);
   SetLength(body[0].arr_power ,body[0].n_power);
   SetLength(body[0].arr_s_power ,body[0].n_power);

   for i_1 := 0 to body[0].n_power-1 do
   begin
      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'Temp_Power'+IntToStr(i_1),f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body0.Temp_Power'+IntToStr(i_1)+' is empty.');
         body[0].temp_power[i_1]:=20.0;
      end
       else
      begin
         body[0].temp_power[i_1]:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'Arr_Power'+IntToStr(i_1),f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body0.Arr_Power'+IntToStr(i_1)+' is empty.');
         if (FormatSettings.DecimalSeparator=',') then
         begin
            body[0].arr_s_power[i_1]:='0,0';
         end;
         if (FormatSettings.DecimalSeparator='.') then
         begin
            body[0].arr_s_power[i_1]:='0.0';
         end;
      end
       else
      begin
         body[0].arr_s_power[i_1]:=Trim(sub);
      end;

      bOk:=true;
      body[0].arr_power[i_1]:=FormVariables.my_real_convert(Trim(body[0].arr_s_power[i_1]),bOk);

   end;



      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'ipower_time_depend',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body0.ipower_time_depend is empty.');
         body[0].ipower_time_depend:=0;  // стационарное значение.
      end
       else
      begin
         body[0].ipower_time_depend:=StrToInt(Trim(sub));
         if (not((body[0].ipower_time_depend>=0)and(body[0].ipower_time_depend<=4))) then
         begin
             ShowMessage('error! body0.ipower_time_depend is udefined.');
             body[0].ipower_time_depend:=0;  // стационарное значение.
         end;
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'itype',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body0.itype is empty.');
         body[0].itype:=0;  // тип блока : SOLID, HOLLOW, FLUID.
      end
       else
      begin
         body[0].itype:=StrToInt(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'iunion',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body0.iunion is empty.');
         body[0].iunion:=0;  // номер объединения
      end
       else
      begin
         body[0].iunion:=StrToInt(Trim(sub));
      end;

      // Информация о цвете и прозрачности.
      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'redcolor',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body0.redcolor is empty.');
         body[0].redcolor:=0.502;
      end
       else
      begin
         body[0].redcolor:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'greencolor',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body0.greencolor is empty.');
         body[0].greencolor:=0.502;
      end
       else
      begin
         body[0].greencolor:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'bluecolor',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body0.bluecolor is empty.');
         body[0].bluecolor:=0.502;
      end
       else
      begin
         body[0].bluecolor:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'transparency',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body0.transparency is empty.');
         body[0].transparency:=1.0;// непрозрачный, видимый.
      end
       else
      begin
         body[0].transparency:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'dcol',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body0.dcol is empty.');
         body[0].dcol:=8421504;
      end
       else
      begin
         body[0].dcol:=StrToInt(Trim(sub));
      end;

       sub:=My_Get_String_for_to_val('body'+IntToStr(j)+'lineWidth',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! body0.BodyLineWidth is empty.');
         body[0].BodyLineWidth:=1;// тонкая линия.
      end
       else
      begin
         body[0].BodyLineWidth:=StrToInt(Trim(sub));
      end;

       body[0].priority:=-5; // наинизший приоритет.
       Oxc:=0.5*(body[0].xS+body[0].xE);
       Oyc:=0.5*(body[0].yS+body[0].yE);
       Ozc:=0.5*(body[0].zS+body[0].zE);
       R1:=0.5*Hscale*sqrt(Sqr(body[0].xE-body[0].xS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].zE-body[0].zS));
       body[0].bvisible:=true;
       // количество блоков:

   end; // НЕ пакет считывался.



      if (not(bAdd_packaje)) then
      begin
         icb_old:=1;
         lb_old:=1;
          priority_id_old:=0;
      end
       else
      begin
         icb_old:=icb;
         lb_old:=lb;
         priority_id_old:=0;

         for j := 1 to lb-1 do
         begin
            if (body[j].priority > priority_id_old) then
            begin
               priority_id_old:= body[j].priority;
            end;
         end;
         priority_id_old:=priority_id_old+5;
      end;


      sub:=My_Get_String_for_to_val('lb',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! lb is empty.');
         lb:=1;
      end
       else
      begin
         lb:=StrToInt(Trim(sub));
         if (lb>250) then
         begin
           etalon_max_size_ratio:=10.0;
           etalon_max_size_ratio2:=3000000;
         end;
      end;



      sub:=My_Get_String_for_to_val('icb',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! icb is empty.');
         icb:=1;
      end
       else
      begin
         icb:=StrToInt(Trim(sub));
      end;

      icb:=icb + icb_old-1;
      lb:=lb + lb_old-1;
      dec(lb_old);
      dec(icb_old);



      SetLength(body,lb); // выделение оперативной памяти

      for j := 1+lb_old to (lb-1) do
      begin
          // name
          sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'name',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! body'+IntToStr(j)+'.name is empty.');
             body[j].name:='block'+IntToStr(j); //default name Prism
          end
           else
          begin
             if (not(bAdd_packaje)) then
             begin
                 body[j].name:=(Trim(sub));
             end
              else
             begin
                // пакет
                body[j].name:=(Trim(sub))+'imp'+IntToStr(inumber_package_load);
             end;
          end;


          sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'igeometry_type',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! body'+IntToStr(j)+'.igeometry_type is empty.');
             body[j].igeometry_type:=0; //Prism
          end
           else
          begin
             body[j].igeometry_type:=StrToInt(Trim(sub));
          end;

          sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'sxS',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! body'+IntToStr(j)+'.sxS is empty.');
             body[j].sxS:='-0.5'; //Prism
             body[j].xS:=-0.5;
          end
           else
          begin
             body[j].sxS:=Trim(sub);
             bOk:=true;
             body[j].xS:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;

          sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'syS',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! body'+IntToStr(j)+'.syS is empty.');
             body[j].syS:='-0.5'; //Prism
             body[j].yS:=-0.5;
          end
           else
         begin
            body[j].syS:=Trim(sub);
            bOk:=true;
            body[j].yS:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'szS',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.szS is empty.');
            body[j].szS:='-0.5'; //Prism
            body[j].zS:=-0.5;
         end
          else
         begin
            body[j].szS:=Trim(sub);
            bOk:=true;
            body[j].zS:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'sxE',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.sxE is empty.');
            body[j].sxE:='0.5'; //Prism
            body[j].xE:=0.5;
         end
          else
         begin
            body[j].sxE:=Trim(sub);
            bOk:=true;
            body[j].xE:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'syE',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.syE is empty.');
            body[j].syE:='0.5'; //Prism
            body[j].yE:=0.5;
         end
          else
         begin
            body[j].syE:=Trim(sub);
            bOk:=true;
            body[j].yE:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'szE',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.szE is empty.');
            body[j].szE:='0.5'; //Prism
            body[j].zE:=0.5;
         end
          else
         begin
            body[j].szE:=Trim(sub);
            bOk:=true;
            body[j].zE:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'iPlane',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.iPlane is empty.');
            body[j].iPlane:=1; // XY
         end
          else
         begin
            body[j].iPlane:=StrToInt(Trim(sub));
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'sxC',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.sxC is empty.');
            body[j].sxC:='0.0'; // Cylinder
            body[j].xC:=0.0;
         end
          else
         begin
            body[j].sxC:=Trim(sub);
            bOk:=true;
            body[j].xC:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'syC',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.syC is empty.');
            body[j].syC:='0.0'; // Cylinder
            body[j].yC:=0.0;
         end
          else
         begin
            body[j].syC:=Trim(sub);
            bOk:=true;
            body[j].yC:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'szC',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.szC is empty.');
            body[j].szC:='0.0'; // Cylinder
            body[j].zC:=0.0;
         end
          else
         begin
            body[j].szC:=Trim(sub);
            bOk:=true;
            body[j].zC:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'sHcyl',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.sHcyl is empty.');
            body[j].sHcyl:='0.4'; // Cylinder
            body[j].Hcyl:=0.4;
         end
          else
         begin
            body[j].sHcyl:=Trim(sub);
            bOk:=true;
            body[j].Hcyl:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'sR_out_cyl',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.sR_out_cyl is empty.');
            body[j].sR_out_cyl:='0.3';
            //body[j].sR_out_cyl:=FloatToStr(0.3*0.5*(sqrt())); // Cylinder
            body[j].R_out_cyl:=0.3;
         end
          else
         begin
            body[j].sR_out_cyl:=Trim(sub);
            bOk:=true;
            body[j].R_out_cyl:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'sR_in_cyl',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.sR_in_cyl is empty.');
            body[j].sR_in_cyl:='0.0'; // Cylinder
            body[j].R_in_cyl:=0.0;
         end
          else
         begin
            body[j].sR_in_cyl:=Trim(sub);
            bOk:=true;
            body[j].R_in_cyl:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         // 18.01.2018
         // bCylinder2Prism
         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'bCylinder2Prism',f);
         if (length(sub)=0) then
         begin
            // Не печатаем предупреждающее сообщение т.к. параметр новый
            // и в большом количестве моделей он просто отсутствует.
            //ShowMessage('error! body'+IntToStr(j)+'.bCylinder2Prism is empty.');
            body[j].bCylinder2Prism:=true; // Cylinder2Prism
         end
          else
         begin
            if (StrToInt(Trim(sub))=1) then
            begin
               body[j].bCylinder2Prism:=true;
            end
             else
            begin
               body[j].bCylinder2Prism:=false;
            end;
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'sR_out_cyl2',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.sR_out_cyl2 is empty.');
            body[j].sR_out_cyl2:='0.0'; // sector, conoid
            body[j].R_out_cyl2:=0.0;
         end
          else
         begin
            body[j].sR_out_cyl2:=Trim(sub);
            bOk:=true;
            body[j].R_out_cyl2:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'sR_in_cyl2',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.sR_in_cyl2 is empty.');
            body[j].sR_in_cyl2:='0.0'; // sector, conoid
            body[j].R_in_cyl2:=0.0;
         end
          else
         begin
            body[j].sR_in_cyl2:=Trim(sub);
            bOk:=true;
            body[j].R_in_cyl2:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'sangle_start',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.sangle_start is empty.');
            body[j].sangle_start:='0.0'; // sector, conoid
            body[j].angle_start:=0.0;
         end
          else
         begin
            body[j].sangle_start:=Trim(sub);
            bOk:=true;
            body[j].angle_start:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'sangle_end',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.sangle_end is empty.');
            body[j].sangle_end:='0.0'; // sector, conoid
            body[j].angle_end:=0.0;
         end
           else
         begin
            body[j].sangle_end:=Trim(sub);
            bOk:=true;
            body[j].angle_end:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         // POLYGON
         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'iPlane_obj2',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.iPlane_obj2 is empty.');
            body[j].iPlane_obj2:=1; // XY
         end
          else
         begin
            body[j].iPlane_obj2:=StrToInt(Trim(sub));
         end;

         sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'nsizei',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! body'+IntToStr(j)+'.nsizei is empty.');
            body[j].nsizei:=3;
         end
          else
         begin
            body[j].nsizei:=StrToInt(Trim(sub));
         end;


         SetLength(body[j].hi,body[j].nsizei);
         SetLength(body[j].xi,body[j].nsizei);
         SetLength(body[j].yi,body[j].nsizei);
         SetLength(body[j].zi,body[j].nsizei);

         for i_1 := 0 to body[j].nsizei-1 do
         begin
            sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'hi'+IntToStr(i_1),f);
            if (length(sub)=0) then
            begin
               ShowMessage('error! body'+IntToStr(j)+'.hi['+IntToStr(i_1)+'] is empty.');
               body[j].hi[i_1]:=0.2;
            end
             else
            begin
               //body[j].hi[i_1]:=StrToFloat(Trim(sub));
               bOk:=true;
               body[j].hi[i_1]:=FormVariables.my_real_convert(Trim(sub),bOk);
            end;

            sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'xi'+IntToStr(i_1),f);
            if (length(sub)=0) then
            begin
               ShowMessage('error! body'+IntToStr(j)+'.xi['+IntToStr(i_1)+'] is empty.');
               body[j].xi[i_1]:=0.0;
            end
             else
            begin
               //body[j].xi[i_1]:=StrToFloat(Trim(sub));
               bOk:=true;
               body[j].xi[i_1]:=FormVariables.my_real_convert(Trim(sub),bOk);
            end;

            sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'yi'+IntToStr(i_1),f);
            if (length(sub)=0) then
            begin
               ShowMessage('error! body'+IntToStr(j)+'.yi['+IntToStr(i_1)+'] is empty.');
               body[j].yi[i_1]:=0.0;
            end
              else
            begin
               //body[j].yi[i_1]:=StrToFloat(Trim(sub));
               bOk:=true;
               body[j].yi[i_1]:=FormVariables.my_real_convert(Trim(sub),bOk);
            end;

            sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'zi'+IntToStr(i_1),f);
            if (length(sub)=0) then
            begin
               ShowMessage('error! body'+IntToStr(j)+'.zi['+IntToStr(i_1)+'] is empty.');
               body[j].zi[i_1]:=0.0;
            end
              else
            begin
               //body[j].zi[i_1]:=StrToFloat(Trim(sub));
               bOk:=true;
               body[j].zi[i_1]:=FormVariables.my_real_convert(Trim(sub),bOk);
            end;

      end;

   // emissivity:

   sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'semissW',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body'+IntToStr(j)+'.semissW is empty.');
      (*
      if (FormatSettings.DecimalSeparator=',') then
      begin
          body[j].semissW:='0,001';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
          body[j].semissW:='0.001';
      end;
      *)
      body[j].semissW:='$emiss';
   end
    else
   begin
      body[j].semissW:=Trim(sub);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'semissE',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body'+IntToStr(j)+'.semissE is empty.');
     (*
      if (FormatSettings.DecimalSeparator=',') then
      begin
          body[j].semissE:='0,001';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
          body[j].semissE:='0.001';
      end;
      *)
       body[j].semissE:='$emiss';
   end
    else
   begin
      body[j].semissE:=Trim(sub);
   end;

    sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'semissS',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body'+IntToStr(j)+'.semissS is empty.');
      (*
      if (FormatSettings.DecimalSeparator=',') then
      begin
          body[j].semissS:='0,001';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
          body[j].semissS:='0.001';
      end;
      *)
      body[j].semissS:='$emiss';
   end
    else
   begin
      body[j].semissS:=Trim(sub);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'semissN',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body'+IntToStr(j)+'.semissN is empty.');
      (*
      if (FormatSettings.DecimalSeparator=',') then
      begin
          body[j].semissN:='0,001';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
          body[j].semissN:='0.001';
      end;
      *)
      body[j].semissN:='$emiss';
   end
    else
   begin
      body[j].semissN:=Trim(sub);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'semissB',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body'+IntToStr(j)+'.semissB is empty.');
      (*
      if (FormatSettings.DecimalSeparator=',') then
      begin
          body[j].semissB:='0,001';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
          body[j].semissB:='0.001';
      end;
      *)
      body[j].semissB:='$emiss';
   end
    else
   begin
      body[j].semissB:=Trim(sub);
   end;

   sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'semissT',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body'+IntToStr(j)+'.semissT is empty.');
      (*
      if (FormatSettings.DecimalSeparator=',') then
      begin
          body[j].semissT:='0,001';
      end;
      if (FormatSettings.DecimalSeparator='.') then
      begin
          body[j].semissT:='0.001';
      end;
      *)
      body[j].semissT:='$emiss';
   end
    else
   begin
      body[j].semissT:=Trim(sub);
   end;


   bOk:=true;
   body[j].emissW:=FormVariables.my_real_convert(body[j].semissW,bOk);
   body[j].emissE:=FormVariables.my_real_convert(body[j].semissE,bOk);
   body[j].emissS:=FormVariables.my_real_convert(body[j].semissS,bOk);
   body[j].emissN:=FormVariables.my_real_convert(body[j].semissN,bOk);
   body[j].emissB:=FormVariables.my_real_convert(body[j].semissB,bOk);
   body[j].emissT:=FormVariables.my_real_convert(body[j].semissT,bOk);


   // Считать ли излучение внутри блока
    sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'binternalRadiation',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body'+IntToStr(j)+'.binternalRadiation is empty.');
      body[j].binternalRadiation:=0;
   end
    else
   begin
      body[j].binternalRadiation:=StrToInt(Trim(sub));
   end;

   // идентификатор рабочего материала.
   sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'imatid',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body'+IntToStr(j)+'.imatid is empty.');
      body[j].imatid:=1; // идентификатор материала.
   end
    else
   begin
      if (not(bAdd_packaje)) then
      begin
          body[j].imatid:=StrToInt(Trim(sub));
      end
      else
      begin
         body[j].imatid:=imatherial_old+StrToInt(Trim(sub));
      end;
   end;

     // Фиксация боковой стенки цилиндра при расчёте прочности.
   sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'CylinderFixed',f);
    if (length(sub)=0) then
   begin
      body[j].CylinderFixed:=false;
   end
     else
   begin
      if (StrToInt(Trim(sub))=1) then
      begin
         body[j].CylinderFixed:=true;
      end
        else
      begin
         body[j].CylinderFixed:=false;
      end
   end;


   // Кусочно - линейная мощность тепловыделения.
   sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'n_power',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! body'+IntToStr(j)+'.n_power is empty.');
      body[j].n_power:=1; // Количество значений таблично-заданной мощности тепловыделения.
   end
    else
   begin
      body[j].n_power:=StrToInt(Trim(sub));
   end;

   SetLength(body[j].temp_power ,body[j].n_power);
   SetLength(body[j].arr_power ,body[j].n_power);
   SetLength(body[j].arr_s_power ,body[j].n_power);


   for i_1 := 0 to body[j].n_power-1 do
   begin
      sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'Temp_power'+IntToStr(i_1),f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body'+IntToStr(j)+'.Temp_power'+IntToStr(i_1)+' is empty.');
         body[j].temp_power[i_1]:=20.0;
      end
       else
      begin
         body[j].temp_power[i_1]:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'Arr_power'+IntToStr(i_1),f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body'+IntToStr(j)+'.Arr_power'+IntToStr(i_1)+' is empty.');
         if (FormatSettings.DecimalSeparator=',') then
         begin
            body[j].arr_s_power[i_1]:='0,0';
         end;
         if (FormatSettings.DecimalSeparator='.') then
         begin
            body[j].arr_s_power[i_1]:='0.0';
         end;
      end
       else
      begin
         body[j].arr_s_power[i_1]:=Trim(sub);
      end;

      bOk:=true;
      body[j].arr_power[i_1]:=FormVariables.my_real_convert(Trim(body[j].arr_s_power[i_1]),bOk);

   end;



      sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'ipower_time_depend',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body'+IntToStr(j)+'.ipower_time_depend is empty.');
         body[j].ipower_time_depend:=0;  // стационарное значение.
      end
       else
      begin
         body[j].ipower_time_depend:=StrToInt(Trim(sub));
         if (not((body[j].ipower_time_depend>=0)and(body[j].ipower_time_depend<=4))) then
         begin
             ShowMessage('error! body'+IntToStr(j)+'.ipower_time_depend is udefined.');
             body[j].ipower_time_depend:=0;  // стационарное значение.
         end;
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'itype',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body'+IntToStr(j)+'.itype is empty.');
         body[j].itype:=0;  // тип блока : SOLID, HOLLOW, FLUID.
      end
       else
      begin
         body[j].itype:=StrToInt(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'iunion',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body'+IntToStr(j)+'.iunion is empty.');
         body[j].iunion:=0;  // номер объединения
      end
       else
      begin
         if ((bAdd_packaje)) then
         begin
            // пакет.
            body[j].iunion:=iunion_old+StrToInt(Trim(sub));
         end
          else
         begin
            body[j].iunion:=StrToInt(Trim(sub));
         end;
      end;

      // Информация о цвете и прозрачности.
      sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'redcolor',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body'+IntToStr(j)+'.redcolor is empty.');
         body[j].redcolor:=0.502;
      end
       else
      begin
         body[j].redcolor:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'greencolor',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body'+IntToStr(j)+'.greencolor is empty.');
         body[j].greencolor:=0.502;
      end
       else
      begin
         body[j].greencolor:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'bluecolor',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body'+IntToStr(j)+'.bluecolor is empty.');
         body[j].bluecolor:=0.502;
      end
       else
      begin
         body[j].bluecolor:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'transparency',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body'+IntToStr(j)+'.transparency is empty.');
         body[j].transparency:=1.0;// непрозрачный, видимый.
      end
       else
      begin
         body[j].transparency:=StrToFloat(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'dcol',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! body'+IntToStr(j)+'.dcol is empty.');
         body[j].dcol:=8421504;
      end
       else
      begin
         body[j].dcol:=StrToInt(Trim(sub));
      end;

      sub:=My_Get_String_for_to_val('body'+IntToStr(j-lb_old)+'lineWidth',f);
      if (length(sub)=0) then
      begin
         //ShowMessage('error! body'+IntToStr(j)+'.BodyLineWidth is empty.');
         body[j].BodyLineWidth:=1;// тонкая линия.
      end
       else
      begin
         body[j].BodyLineWidth:=StrToInt(Trim(sub));
      end;

       body[j].bvisible:=true;

       body[j].priority:=priority_id+priority_id_old;
       // priority_id_old - при считывании пакета учет имеющихся приритетов блоков.
       priority_id:=priority_id+5;

   end;

    ReadyPaint;

   // сообщение на консоль:
   MainMemo.Lines.Add('Reading a text file...');
   for j:=0 to (lb-1) do
   begin
      MainMemo.Lines.Add(body[j].name+' ... ready');
   end;
   // количество источников тепла:

    if ((bAdd_packaje)) then
    begin
       ls_old:=ls;
    end
     else
    begin
       ls_old:=0;
    end;

      sub:=My_Get_String_for_to_val('ls',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! ls is empty.');
         ls:=0;
      end
       else
      begin
         ls:=StrToInt(Trim(sub));
      end;

      if ((bAdd_packaje)) then
      begin
         ics_old:=ics;
      end
      else
      begin
        ics_old:=0;
      end;

       sub:=My_Get_String_for_to_val('ics',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! ics is empty.');
         ics:=1;
      end
       else
      begin
         ics:=StrToInt(Trim(sub));
      end;

      ls:=ls+ls_old;
      ics:=ics+ics_old;
      SetLength(source,ls); // выделение оперативной памяти под источники тепла

      // цикл по всем источникам тепла:
      for j:=ls_old to (ls-1) do
      begin

          sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'name',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! source'+IntToStr(j)+'.name is empty.');
             source[j].name:='source'+IntToStr(j);
          end
           else
          begin
              if ((bAdd_packaje)) then
              begin
                 source[j].name:=Trim(sub)+'imp'+IntToStr(inumber_package_load);
              end
               else
              begin
                 source[j].name:=Trim(sub);
              end;
          end;

          // мощность тепловыделения, плоскость и координаты:

          sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'spower',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! source'+IntToStr(j)+'.spower is empty.');
             if (FormatSettings.DecimalSeparator=',') then
             begin
                source[j].spower:='0,0';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                source[j].spower:='0.0';
             end;
          end
           else
          begin
             // параметризованная пользователем мощность
             source[j].spower:=Trim(sub);
             bOk:=true;
             source[j].power:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;


           sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'itempdep',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! source'+IntToStr(j)+'itempdep is empty.');
              source[j].itempdep:=0;
           end
            else
           begin
              source[j].itempdep:=StrToInt(Trim(sub));
           end;

           // идентификатор таблицы задания мощностей
           sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'id_table',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! source'+IntToStr(j)+'id_table is empty.');
              source[j].id_table:=0;
           end
            else
           begin
              source[j].id_table:=StrToInt(Trim(sub));
           end;

           // смещение стока.
           sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'soperatingoffsetdrain',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! source'+IntToStr(j)+'soperatingoffsetdrain is empty.');
              source[j].soperatingoffsetdrain:='';
           end
            else
           begin
              source[j].soperatingoffsetdrain:=Trim(sub);
           end;

           // плоскость в которой лежит источник тепла
           sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'iPlane',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! source'+IntToStr(j)+'iPlane.');
              source[j].iPlane:=0;
           end
            else
           begin
              source[j].iPlane:=StrToInt(Trim(sub));
           end;

            sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'sxS',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! source'+IntToStr(j)+'.sxS is empty.');
             source[j].sxS:='-0.5';
             source[j].xS:=-0.5;
          end
           else
          begin
             source[j].sxS:=Trim(sub);
             bOk:=true;
             source[j].xS:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;

          sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'syS',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! source'+IntToStr(j)+'.syS is empty.');
             source[j].syS:='-0.5';
             source[j].yS:=-0.5;
          end
           else
         begin
            source[j].syS:=Trim(sub);
            bOk:=true;
            source[j].yS:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'szS',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! source'+IntToStr(j)+'.szS is empty.');
            source[j].szS:='-0.5';
            source[j].zS:=-0.5;
         end
          else
         begin
            source[j].szS:=Trim(sub);
            bOk:=true;
            source[j].zS:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'sxE',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! source'+IntToStr(j)+'.sxE is empty.');
            source[j].sxE:='0.5';
            source[j].xE:=0.5;
         end
          else
         begin
            source[j].sxE:=Trim(sub);
            bOk:=true;
            source[j].xE:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'syE',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! source'+IntToStr(j)+'.syE is empty.');
            source[j].syE:='0.5';
            source[j].yE:=0.5;
         end
          else
         begin
            source[j].syE:=Trim(sub);
            bOk:=true;
            source[j].yE:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'szE',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! source'+IntToStr(j)+'.szE is empty.');
            source[j].szE:='0.5';
            source[j].zE:=0.5;
         end
          else
         begin
            source[j].szE:=Trim(sub);
            bOk:=true;
            source[j].zE:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         // номер объединения
         sub:=My_Get_String_for_to_val('source'+IntToStr(j-ls_old)+'iunion',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! source'+IntToStr(j)+'.iunion is empty.');
            source[j].iunion:=0;
         end
          else
         begin

             if ((bAdd_packaje)) then
             begin
                source[j].iunion:=iunion_old+StrToInt(Trim(sub));
             end
              else
             begin
                source[j].iunion:=StrToInt(Trim(sub));
             end;
         end;

         source[j].bvisible:=true; // видимость источника тепла.

      end;

      for j:=0 to (ls-1) do
      begin
         MainMemo.Lines.Add(source[j].name+' ... ready');
      end;

      if ((bAdd_packaje)) then
      begin
         lw_old:=lw;
      end
       else
      begin
         lw_old:=0;
      end;

      sub:=My_Get_String_for_to_val('lw',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! ls is empty.');
         lw:=0;
      end
       else
      begin
         lw:=StrToInt(Trim(sub));
      end;

      if ((bAdd_packaje)) then
      begin
         icw_old:=ics;
      end
      else
      begin
        icw_old:=0;
      end;

       sub:=My_Get_String_for_to_val('icw',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! icw is empty.');
         icw:=1;
      end
       else
      begin
         icw:=StrToInt(Trim(sub));
      end;

       lw:=lw+lw_old;
      icw:=icw+icw_old;
      SetLength(wall,lw); // выделение оперативной памяти под источники тепла


   // цикл по всем твёрдым стенкам:
   for j:=lw_old to (lw-1) do
   begin
       sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'name',f);
       if (length(sub)=0) then
       begin
          ShowMessage('error! wall'+IntToStr(j)+'.name is empty.');
          wall[j].name:='wall'+IntToStr(j);
       end
        else
       begin
          if ((bAdd_packaje)) then
          begin
             wall[j].name:=Trim(sub)+'imp'+IntToStr(inumber_package_load);
          end
          else
          begin
              wall[j].name:=Trim(sub);
          end;
       end;

       // тип краевого условия, температура и тепловой поток,
       //  плоскость и координаты:

       // тип краевого условия
      sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'family',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! wall'+IntToStr(j)+'family is empty.');
         wall[j].family:=1;
      end
       else
      begin
         wall[j].family:=StrToInt(Trim(sub));
      end;

      // температура на идеальном теплооотводе
      sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'Tamb',f);
      if (length(sub)=0) then
      begin
         ShowMessage('error! wall'+IntToStr(j)+'Tamb is empty.');
         wall[j].Tamb:=20.0;
      end
       else
      begin
          //wall[j].Tamb:=StrToFloat(Trim(sub));
          bOk:=true;
          wall[j].Tamb:=FormVariables.my_real_convert(Trim(sub),bOk);
      end;


         bOk:=true;
         if (wall[j].family=3) then
         begin
             // коэффициент теплоотдачи.

            sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'sheat_transfer_coefficient',f);
            if (length(sub)=0) then
            begin
               ShowMessage('error! wall'+IntToStr(j)+'sheat_transfer_coefficient is empty.');
                if (FormatSettings.DecimalSeparator=',') then
                begin
                   wall[j].sheat_transfer_coefficient:='0,0';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   wall[j].sheat_transfer_coefficient:='0.0';
                end;
                wall[j].heat_transfer_coefficient:=0.0;
                 wall[j].semissivity:='$emiss';
               bOk:=true;
               wall[j].emissivity:=FormVariables.my_real_convert(Trim(sub),bOk);
            end
             else
            begin
              wall[j].sheat_transfer_coefficient:=Trim(sub);
              bOk:=true;
              wall[j].heat_transfer_coefficient:=FormVariables.my_real_convert(Trim(sub),bOk);
               wall[j].semissivity:='$emiss';
               bOk:=true;
               wall[j].emissivity:=FormVariables.my_real_convert(Trim(sub),bOk);
            end;
         end
           else
         begin
            // излучательная способность.

            sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'semissivity',f);
            if (length(sub)=0) then
            begin
               ShowMessage('error! wall'+IntToStr(j)+'semissivity is empty.');
               wall[j].semissivity:='$emiss';
               bOk:=true;
               wall[j].emissivity:=FormVariables.my_real_convert(Trim(sub),bOk);
               if (FormatSettings.DecimalSeparator=',') then
                begin
                   wall[j].sheat_transfer_coefficient:='0,0';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   wall[j].sheat_transfer_coefficient:='0.0';
                end;
                wall[j].heat_transfer_coefficient:=0.0;
            end
             else
            begin
              wall[j].semissivity:=Trim(sub);
              bOk:=true;
              wall[j].emissivity:=FormVariables.my_real_convert(Trim(sub),bOk);
              if (FormatSettings.DecimalSeparator=',') then
                begin
                   wall[j].sheat_transfer_coefficient:='0,0';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   wall[j].sheat_transfer_coefficient:='0.0';
                end;
                wall[j].heat_transfer_coefficient:=0.0;
            end;
         end;

          // для граничного условия Стефана -Больцмана фактор видимости.
          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'ViewFactor',f);
          if (length(sub)=0) then
          begin
             //ShowMessage('error! wall'+IntToStr(j)+'ViewFactor is empty.');
             wall[j].ViewFactor:=1.0;
          end
           else
          begin
             // wall[j].ViewFactor:=StrToFloat(Trim(sub));
             bOk:=true;
             wall[j].ViewFactor:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;

          // для граничного условия 2 или 3 рода.
          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'HF',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'HF is empty.');
             wall[j].HF:=0.0;
          end
           else
          begin
             // wall[j].HF:=StrToFloat(Trim(sub));
             bOk:=true;
             wall[j].HF:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;

          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'bsymmetry',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'bsymmetry is empty.');
             wall[j].bsymmetry:=false;
          end
           else
          begin
             if (StrToInt(Trim(sub))=1) then
             begin
                wall[j].bsymmetry:=true;
             end
              else
             begin
                wall[j].bsymmetry:=false;
             end;
         end;

          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'bpressure',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'bpressure is empty.');
             wall[j].bpressure:=false;
          end
           else
          begin
             if (StrToInt(Trim(sub))=1) then
             begin
                wall[j].bpressure:=true;
             end
              else
             begin
                wall[j].bpressure:=false;
             end;
         end;

          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'bopening',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'bopening is empty.');
             wall[j].bopening:=false;
          end
           else
          begin
             if (StrToInt(Trim(sub))=1) then
             begin
                wall[j].bopening:=true;
             end
              else
             begin
                wall[j].bopening:=false;
             end;
          end;

          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'Vx',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'Vx is empty.');
             wall[j].Vx:=0.0;
          end
           else
          begin
             // wall[j].Vx:=StrToFloat(Trim(sub));
             bOk:=true;
             wall[j].Vx:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;

          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'Vy',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'Vy is empty.');
             wall[j].Vy:=0.0;
          end
           else
          begin
             // wall[j].Vy:=StrToFloat(Trim(sub));
             bOk:=true;
             wall[j].Vy:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;

          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'Vz',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'Vz is empty.');
             wall[j].Vz:=0.0;
          end
           else
          begin
             // wall[j].Vz:=StrToFloat(Trim(sub));
             bOk:=true;
             wall[j].Vz:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;

          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'Pressure',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'Pressure is empty.');
             wall[j].P:=0.0;
          end
           else
          begin
             // wall[j].Pressure:=StrToFloat(Trim(sub));
             bOk:=true;
             wall[j].P:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;

          // Thermal-Stress.

          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'ithermal_stress_boundary_condition',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'ithermal_stress_boundary_condition is empty.');
             wall[j].ithermal_stress_boundary_condition:=0;//FREE ALL
          end
           else
          begin
             wall[j].ithermal_stress_boundary_condition:=StrToInt(Trim(sub));
          end;

          // Приложенная сила в Ньютонах.

           sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'xForce',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'xForce is empty.');
             wall[j].xForce:=0.0;
          end
           else
          begin
             // wall[j].xForce:=StrToFloat(Trim(sub));
             bOk:=true;
             wall[j].xForce:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;

          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'yForce',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'yForce is empty.');
             wall[j].yForce:=0.0;
          end
           else
          begin
             // wall[j].yForce:=StrToFloat(Trim(sub));
             bOk:=true;
             wall[j].yForce:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;

          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'zForce',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'zForce is empty.');
             wall[j].zForce:=0.0;
          end
           else
          begin
             // wall[j].zForce:=StrToFloat(Trim(sub));
             bOk:=true;
             wall[j].zForce:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;


          // плоскость в которой лежит стенка
           sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'iPlane',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! wall'+IntToStr(j)+'iPlane.');
              wall[j].iPlane:=0;
           end
            else
           begin
              wall[j].iPlane:=StrToInt(Trim(sub));
           end;

            sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'sxS',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'.sxS is empty.');
             wall[j].sxS:='-0.5';
             wall[j].xS:=-0.5;
          end
           else
          begin
             wall[j].sxS:=Trim(sub);
             bOk:=true;
             wall[j].xS:=FormVariables.my_real_convert(Trim(sub),bOk);
          end;

          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'syS',f);
          if (length(sub)=0) then
          begin
             ShowMessage('error! wall'+IntToStr(j)+'.syS is empty.');
             wall[j].syS:='-0.5';
             wall[j].yS:=-0.5;
          end
           else
         begin
            wall[j].syS:=Trim(sub);
            bOk:=true;
            wall[j].yS:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'szS',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! wall'+IntToStr(j)+'.szS is empty.');
            wall[j].szS:='-0.5';
            wall[j].zS:=-0.5;
         end
          else
         begin
            wall[j].szS:=Trim(sub);
            bOk:=true;
            wall[j].zS:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'sxE',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! wall'+IntToStr(j)+'.sxE is empty.');
            wall[j].sxE:='0.5';
            wall[j].xE:=0.5;
         end
          else
         begin
            wall[j].sxE:=Trim(sub);
            bOk:=true;
            wall[j].xE:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'syE',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! wall'+IntToStr(j)+'.syE is empty.');
            wall[j].syE:='0.5';
            wall[j].yE:=0.5;
         end
          else
         begin
            wall[j].syE:=Trim(sub);
            bOk:=true;
            wall[j].yE:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'szE',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! wall'+IntToStr(j)+'.szE is empty.');
            wall[j].szE:='0.5';
            wall[j].zE:=0.5;
         end
          else
         begin
            wall[j].szE:=Trim(sub);
            bOk:=true;
            wall[j].zE:=FormVariables.my_real_convert(Trim(sub),bOk);
         end;

         // номер объединения
         sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'iunion',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! wall'+IntToStr(j)+'.iunion is empty.');
            wall[j].iunion:=0;
         end
          else
         begin
             if ((bAdd_packaje)) then
             begin
                wall[j].iunion:=iunion_old+StrToInt(Trim(sub));
             end
             else
             begin
                wall[j].iunion:=StrToInt(Trim(sub));
             end;
         end;


          // cabinet depend признак.
          sub:=My_Get_String_for_to_val('wall'+IntToStr(j-lw_old)+'cabinet_depend',f);
         if (length(sub)=0) then
         begin
            ShowMessage('error! wall'+IntToStr(j)+'.cabinet_depend is empty.');
            wall[j].cabinet_depend:=0;
         end
          else
         begin
            wall[j].cabinet_depend:=StrToInt(Trim(sub));
         end;

         wall[j].bvisible:=true; // видимость стенки

   end;

   for j:=0 to (lw-1) do
   begin
      MainMemo.Lines.Add(wall[j].name+' ... ready');
   end;


     if (not(bAdd_packaje)) then
      begin
    // Запись информации о решаемых уравнениях.
    // Теплопередча, Деформации, Гидродинамика.

    sub:=My_Get_String_for_to_val('solver_itemper',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! solver_itemper is empty.');
       egddata.itemper:=1;
    end
     else
    begin
       egddata.itemper:=StrToInt(Trim(sub));
    end;

    sub:=My_Get_String_for_to_val('solver_StaticStructural',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! solver_StaticStructural is empty.');
       egddata.iStaticStructural:=0;
    end
     else
    begin
       egddata.iStaticStructural:=StrToInt(Trim(sub));
    end;

    sub:=My_Get_String_for_to_val('solver_imaxflD',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! solver_imaxflD is empty.');

       // Гидродинамичекская подобласть отсутствует и мы её не рассчитываем.
      // 9.01.2017 Многие константы взяты наобум, надо уточнить дефолтные значения.
       egddata.imaxflD:=1;
      // Обязательное выделение памяти под количество уникальных жидких зон.
      SetLength(egddata.myflmod,egddata.imaxflD);
      egddata.myflmod[0].xc:=Oxc;
      egddata.myflmod[0].yc:=Oyc;
      egddata.myflmod[0].zc:=Ozc;
      egddata.myflmod[0].iflow:=0;
      egddata.myflmod[0].iflowregime:=0;
      egddata.myflmod[0].iturbmodel:=0;
      egddata.myflmod[0].SmagConst:=0.0;
      egddata.myflmod[0].iDynamicStressGermano:=0;
      egddata.myflmod[0].iLimitersCs:=0;
      egddata.myflmod[0].minCs:=-1.0e30;
      egddata.myflmod[0].maxCs:=+1.0e30;
      egddata.myflmod[0].itypeFiltrGermano:=0;
      egddata.myflmod[0].roughness:=0.0;
      egddata.myflmod[0].rRimult:=1.0;
      egddata.myflmod[0].rSelectiveAngle:=15.0;
      egddata.myflmod[0].ipowerroughness:=0;
      egddata.myflmod[0].itypefiltr:=0;
      egddata.myflmod[0].bfdelta:=true;
      egddata.myflmod[0].bSmagorinsky_Lilly:=false;
      egddata.myflmod[0].bsurface_roughness:=false;
      egddata.myflmod[0].bSwirlamendment:=true;
      egddata.myflmod[0].bSelectiveSmagorinsky:=false;


    end
     else
    begin
       egddata.imaxflD:=StrToInt(Trim(sub));
       SetLength(egddata.myflmod,egddata.imaxflD);



       for j:=0 to egddata.imaxflD-1 do
       begin
           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'xc',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.xc is empty.');
              egddata.myflmod[j].xc:=Oxc;
           end
            else
           begin
              bOk:=true;
              egddata.myflmod[j].xc:=FormVariables.my_real_convert(Trim(sub),bOk);
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'yc',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.yc is empty.');
              egddata.myflmod[j].yc:=Oyc;
           end
            else
           begin
              bOk:=true;
              egddata.myflmod[j].yc:=FormVariables.my_real_convert(Trim(sub),bOk);
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'zc',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.zc is empty.');
              egddata.myflmod[j].zc:=Oyc;
           end
            else
           begin
              bOk:=true;
              egddata.myflmod[j].zc:=FormVariables.my_real_convert(Trim(sub),bOk);
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'iflow',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.iflow is empty.');
              egddata.myflmod[j].iflow:=0;
           end
            else
           begin
              egddata.myflmod[j].iflow:=StrToInt(Trim(sub));
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'iflowregime',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.iflowregime is empty.');
              egddata.myflmod[j].iflowregime:=0;
           end
            else
           begin
              egddata.myflmod[j].iflowregime:=StrToInt(Trim(sub));
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'iturbmodel',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.iturbmodel is empty.');
              egddata.myflmod[j].iturbmodel:=0;
           end
            else
           begin
              egddata.myflmod[j].iturbmodel:=StrToInt(Trim(sub));
           end;

           // параметры модели Смагоринского
            sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'SmagConst',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.SmagConst is empty.');
              egddata.myflmod[j].SmagConst:=0.0;
           end
            else
           begin
              bOk:=true;
              egddata.myflmod[j].SmagConst:=FormVariables.my_real_convert(Trim(sub),bOk);
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'iDynamicStressGermano',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.iDynamicStressGermano is empty.');
              egddata.myflmod[j].iDynamicStressGermano:=0;
           end
            else
           begin
              egddata.myflmod[j].iDynamicStressGermano:=StrToInt(Trim(sub));
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'iLimitersCs',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.iLimitersCs is empty.');
              egddata.myflmod[j].iLimitersCs:=0;
           end
            else
           begin
              egddata.myflmod[j].iLimitersCs:=StrToInt(Trim(sub));
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'minCs',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.minCs is empty.');
              egddata.myflmod[j].minCs:=-1.0e30;
           end
            else
           begin
              bOk:=true;
              egddata.myflmod[j].minCs:=FormVariables.my_real_convert(Trim(sub),bOk);
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'maxCs',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.maxCs is empty.');
              egddata.myflmod[j].maxCs:=1.0e30;
           end
            else
           begin
              bOk:=true;
              egddata.myflmod[j].maxCs:=FormVariables.my_real_convert(Trim(sub),bOk);
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'itypeFiltrGermano',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.itypeFiltrGermano is empty.');
              egddata.myflmod[j].itypeFiltrGermano:=0;
           end
            else
           begin
              egddata.myflmod[j].itypeFiltrGermano:=StrToInt(Trim(sub));
           end;

            sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'roughness',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.roughness is empty.');
              egddata.myflmod[j].roughness:=0.0;
           end
            else
           begin
              bOk:=true;
              egddata.myflmod[j].roughness:=FormVariables.my_real_convert(Trim(sub),bOk);
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'rRimult',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.rRimult is empty.');
              egddata.myflmod[j].rRimult:=1.0;
           end
            else
           begin
              bOk:=true;
              egddata.myflmod[j].rRimult:=FormVariables.my_real_convert(Trim(sub),bOk);
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'rSelectiveAngle',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.rSelectiveAngle is empty.');
              egddata.myflmod[j].rSelectiveAngle:=15.0;
           end
            else
           begin
              bOk:=true;
              egddata.myflmod[j].rSelectiveAngle:=FormVariables.my_real_convert(Trim(sub),bOk);
           end;

            sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'ipowerroughness',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.ipowerroughness is empty.');
              egddata.myflmod[j].ipowerroughness:=0;
           end
            else
           begin
              egddata.myflmod[j].ipowerroughness:=StrToInt(Trim(sub));
           end;

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'itypefiltr',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.itypefiltr is empty.');
              egddata.myflmod[j].itypefiltr:=0;
           end
            else
           begin
              egddata.myflmod[j].itypefiltr:=StrToInt(Trim(sub));
           end;
           // учёт неравномерности сетки.

           sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'bfdelta',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.bfdelta is empty.');
              egddata.myflmod[j].bfdelta:=true;
           end
            else
           begin
              if (StrToInt(Trim(sub))=1) then
              begin
                 egddata.myflmod[j].bfdelta:=true;
              end
                else
              begin
                 egddata.myflmod[j].bfdelta:=false;
              end;
           end;

           // модель Смагоринского-Лиллу.

            sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'bSmagorinsky_Lilly',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.bSmagorinsky_Lilly is empty.');
              egddata.myflmod[j].bSmagorinsky_Lilly:=false;
           end
            else
           begin
              if (StrToInt(Trim(sub))=1) then
              begin
                 egddata.myflmod[j].bSmagorinsky_Lilly:=true;
              end
                else
              begin
                 egddata.myflmod[j].bSmagorinsky_Lilly:=false;
              end;
           end;

           // учёт шероховатости стенки.
            sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'bsurface_roughness',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.bsurface_roughness is empty.');
              egddata.myflmod[j].bsurface_roughness:=false;
           end
            else
           begin
              if (StrToInt(Trim(sub))=1) then
              begin
                 egddata.myflmod[j].bsurface_roughness:=true;
              end
                else
              begin
                 egddata.myflmod[j].bsurface_roughness:=false;
              end;
           end;

           // течения с кривизной линий тока
             sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'bSwirlamendment',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.bSwirlamendment is empty.');
              egddata.myflmod[j].bSwirlamendment:=false;
           end
            else
           begin
              if (StrToInt(Trim(sub))=1) then
              begin
                 egddata.myflmod[j].bSwirlamendment:=true;
              end
                else
              begin
                 egddata.myflmod[j].bSwirlamendment:=false;
              end;
           end;

           // модель Selective Smagorinsky
             sub:=My_Get_String_for_to_val('myflmod'+IntToStr(j)+'bSelectiveSmagorinsky',f);
           if (length(sub)=0) then
           begin
              ShowMessage('error! myflmod'+IntToStr(j)+'.bSelectiveSmagorinsky is empty.');
              egddata.myflmod[j].bSelectiveSmagorinsky:=false;
           end
            else
           begin
              if (StrToInt(Trim(sub))=1) then
              begin
                 egddata.myflmod[j].bSelectiveSmagorinsky:=true;
              end
                else
              begin
                 egddata.myflmod[j].bSelectiveSmagorinsky:=false;
              end;
           end;

       end;

    end;
     end;


   if (not(bAdd_packaje)) then
   begin
   // Считываем параметры освещения.
   sub:=My_Get_String_for_to_val('light_remis',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_remis is empty.');
      remis:=0.0;
   end
    else
   begin
      bOk:=true;
      remis:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_rspec',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_rspec is empty.');
      rspec:=0.0;
   end
    else
   begin
      bOk:=true;
      rspec:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_matdiff',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_matdiff is empty.');
      matdiff:=0.8;
   end
    else
   begin
      bOk:=true;
      matdiff:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_matamb',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_matamb is empty.');
      matamb:=0.2;
   end
    else
   begin
      bOk:=true;
      matamb:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_matt',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_matt is empty.');
      matt:=1.0;
   end
    else
   begin
      bOk:=true;
      matt:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;


   sub:=My_Get_String_for_to_val('light_mr',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_mr is empty.');
      mr:=1.0;
   end
    else
   begin
      bOk:=true;
      mr:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

     sub:=My_Get_String_for_to_val('light_glamb0',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_glamb0 is empty.');
      glamb0:=0.0;
   end
    else
   begin
      bOk:=true;
      glamb0:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_mldx',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_mldx is empty.');
      mldx:=-0.5;
   end
    else
   begin
      bOk:=true;
      mldx:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;


   sub:=My_Get_String_for_to_val('light_mldy',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_mldy is empty.');
      mldy:=0.0;
   end
    else
   begin
      bOk:=true;
      mldy:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_lamb',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_lamb is empty.');
      lamb:=0.0;
   end
    else
   begin
      bOk:=true;
      lamb:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_lspec',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_lspec is empty.');
      lspec:=1.0;
   end
    else
   begin
      bOk:=true;
      lspec:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

    sub:=My_Get_String_for_to_val('light_ldiff',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_ldiff is empty.');
      ldiff:=1.0;
   end
    else
   begin
      bOk:=true;
      ldiff:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

    sub:=My_Get_String_for_to_val('light_lithtangle',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_lithtangle is empty.');
      lithtangle:=180.0;
   end
    else
   begin
      bOk:=true;
      lithtangle:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

    sub:=My_Get_String_for_to_val('light_lithtexponent',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_lithtexponent is empty.');
      lithtexponent:=0.0;
   end
    else
   begin
      bOk:=true;
      lithtexponent:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

    sub:=My_Get_String_for_to_val('light_lithtangle1',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_lithtangle1 is empty.');
      lithtangle1:=180.0;
   end
    else
   begin
      bOk:=true;
      lithtangle1:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

     sub:=My_Get_String_for_to_val('light_lithtexponent1',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_lithtexponent1 is empty.');
      lithtexponent1:=0.0;
   end
    else
   begin
      bOk:=true;
      lithtexponent1:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;


     sub:=My_Get_String_for_to_val('light_mldx1',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_mldx1 is empty.');
      mldx1:=-0.3;
   end
    else
   begin
      bOk:=true;
      mldx1:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_mldy1',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_mldy1 is empty.');
      mldy1:=0.0;
   end
    else
   begin
      bOk:=true;
      mldy1:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_matt1',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_matt1 is empty.');
      matt1:=1.0;
   end
    else
   begin
      bOk:=true;
      matt1:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_mr1',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_mr1 is empty.');
      mr1:=1.0;
   end
    else
   begin
      bOk:=true;
      mr1:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_lamb1',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_lamb1 is empty.');
      lamb1:=0.0;
   end
    else
   begin
      bOk:=true;
      lamb1:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_lspec1',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_lspec1 is empty.');
      lspec1:=0.0;
   end
    else
   begin
      bOk:=true;
      lspec1:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_ldiff1',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_ldiff1 is empty.');
      ldiff1:=0.0;
   end
    else
   begin
      bOk:=true;
      ldiff1:=FormVariables.my_real_convert(Trim(sub),bOk);
   end;

   sub:=My_Get_String_for_to_val('light_rblick',f);
   if (length(sub)=0) then
   begin
      ShowMessage('error! light_rblick is empty.');
      rblick:=60;
   end
    else
   begin
      rblick:=StrToInt(Trim(sub));
   end;


    // Считываем булевы индикаторы связанные с освещением.
    sub:=My_Get_String_for_to_val('light_OnLitht1',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! light_OnLitht1 is empty.');
       chkOnLitht1.Checked:=false;
    end
     else
    begin
       if (StrToInt(Trim(sub))=1) then
       begin
          chkOnLitht1.Checked:=true;
       end
        else
       begin
          chkOnLitht1.Checked:=false;
       end;
    end;

    sub:=My_Get_String_for_to_val('light_DiskretSource1',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! light_DiskretSource1 is empty.');
       chkDiskretSource1.Checked:=false;
    end
     else
    begin
       if (StrToInt(Trim(sub))=1) then
       begin
          chkDiskretSource1.Checked:=true;
       end
        else
       begin
          chkDiskretSource1.Checked:=false;
       end;
    end;

    sub:=My_Get_String_for_to_val('light_distance1',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! light_distance1 is empty.');
       chkdistance1.Checked:=false;
    end
     else
    begin
       if (StrToInt(Trim(sub))=1) then
       begin
          chkdistance1.Checked:=true;
       end
        else
       begin
          chkdistance1.Checked:=false;
       end;
    end;

    sub:=My_Get_String_for_to_val('light_distance',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! light_distance is empty.');
       CheckBoxdistance.Checked:=false;
    end
     else
    begin
       if (StrToInt(Trim(sub))=1) then
       begin
          CheckBoxdistance.Checked:=true;
       end
        else
       begin
          CheckBoxdistance.Checked:=false;
       end;
    end;

    sub:=My_Get_String_for_to_val('light_OnLitht',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! light_OnLitht is empty.');
       CheckBoxOnLitht.Checked:=false;
    end
     else
    begin
       if (StrToInt(Trim(sub))=1) then
       begin
          CheckBoxOnLitht.Checked:=true;
       end
        else
       begin
          CheckBoxOnLitht.Checked:=false;
       end;
    end;

    sub:=My_Get_String_for_to_val('light_PointSources',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! light_PointSources is empty.');
       CheckBoxPointSources.Checked:=false;
    end
     else
    begin
       if (StrToInt(Trim(sub))=1) then
       begin
          CheckBoxPointSources.Checked:=true;
       end
        else
       begin
          CheckBoxPointSources.Checked:=false;
       end;
    end;


    sub:=My_Get_String_for_to_val('light_chkblick',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! light_chkblick is empty.');
       chkblick.Checked:=false;
    end
     else
    begin
       if (StrToInt(Trim(sub))=1) then
       begin
          chkblick.Checked:=true;
       end
        else
       begin
          chkblick.Checked:=false;
       end;
    end;


     sub:=My_Get_String_for_to_val('light_chkemis',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! light_chkemis is empty.');
       chkemis.Checked:=false;
    end
     else
    begin
       if (StrToInt(Trim(sub))=1) then
       begin
          chkemis.Checked:=true;
       end
        else
       begin
          chkemis.Checked:=false;
       end;
    end;


     sub:=My_Get_String_for_to_val('light_chkGlobalAmbient',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! light_chkGlobalAmbient is empty.');
       chkGlobalAmbient.Checked:=false;
    end
     else
    begin
       if (StrToInt(Trim(sub))=1) then
       begin
          chkGlobalAmbient.Checked:=true;
       end
        else
       begin
          chkGlobalAmbient.Checked:=false;
       end;
    end;

    sub:=My_Get_String_for_to_val('light_chksmooter',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! light_chksmooter is empty.');
       chksmooter.Checked:=false;
    end
     else
    begin
       if (StrToInt(Trim(sub))=1) then
       begin
          chksmooter.Checked:=true;
       end
        else
       begin
          chksmooter.Checked:=false;
       end;
    end;

    sub:=My_Get_String_for_to_val('light_chkSpecular',f);
    if (length(sub)=0) then
    begin
       ShowMessage('error! light_chkSpecular is empty.');
       chkSpecular.Checked:=false;
    end
     else
    begin
       if (StrToInt(Trim(sub))=1) then
       begin
          chkSpecular.Checked:=true;
       end
        else
       begin
          chkSpecular.Checked:=false;
       end;
    end;

    sub:=My_Get_String_for_to_val('VxInitialization_Speed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! VxInitialization_Speed is empty.');
       FormSpeedInitialization.EditVx.Text:='0.0';
    end
     else
    begin
       FormSpeedInitialization.EditVx.Text:=Trim(sub);
    end;

    sub:=My_Get_String_for_to_val('VyInitialization_Speed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! VyInitialization_Speed is empty.');
       FormSpeedInitialization.EditVy.Text:='0.0';
    end
     else
    begin
       FormSpeedInitialization.EditVy.Text:=Trim(sub);
    end;

    sub:=My_Get_String_for_to_val('VzInitialization_Speed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! VzInitialization_Speed is empty.');
       FormSpeedInitialization.EditVz.Text:='0.0';
    end
     else
    begin
       FormSpeedInitialization.EditVz.Text:=Trim(sub);
    end;

    sub:=My_Get_String_for_to_val('StaticStructuralSolverSetting',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! StaticStructuralSolverSetting is empty.');
       FormSetting.ComboBoxStaticStructuralSolverSetting.ItemIndex:=0; // BiCGStab+ILU(lfil).
    end
     else
    begin
       if ((StrToInt(Trim(sub))>4)or(StrToInt(Trim(sub))<0)) then
       begin
          FormSetting.ComboBoxStaticStructuralSolverSetting.ItemIndex:=0; // BiCGStab+ILU(lfil).
       end
       else
       begin
          FormSetting.ComboBoxStaticStructuralSolverSetting.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('MeshGenAlgo_id',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! MeshGenAlgo_id is empty.');
       MeshForm.ComboBoxmeshgen.ItemIndex:=2; // CoarseMesh.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
       begin
          MeshForm.ComboBoxmeshgen.ItemIndex:=2; // CoarseMesh.
       end
       else
       begin
          MeshForm.ComboBoxmeshgen.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('AdaptiveLocalRefinementMesh_Checker',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! AdaptiveLocalRefinementMesh_Checker is empty.');
       MeshForm.CheckBoxALICE.Checked:=false; // Структурированная сетка.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          MeshForm.CheckBoxALICE.Checked:=false; // Структурированная сетка.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 :
             begin
                MeshForm.CheckBoxALICE.Checked:=false; // Структурированная сетка.
             end;
             1 :
             begin
                MeshForm.CheckBoxALICE.Checked:=true; // Адаптивная Локально Измельчённая Сетка.
             end;
          end;
       end;
    end;



    sub:=My_Get_String_for_to_val('ALICE_Mesh_Type',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! ALICE_Mesh_Type is empty.');
       MeshForm.ComboBoxALICEType.ItemIndex:=0; // AliceMesh Corse.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          MeshForm.ComboBoxALICEType.ItemIndex:=0; // AliceMesh Corse.
       end
       else
       begin
          MeshForm.ComboBoxALICEType.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    bXY_empty:=false;


    sub:=My_Get_String_for_to_val('XYPlotXo',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! XYPlotXo is empty.');
       bXY_empty:=true;
    end
     else
    begin
       FormXYPlot.EditXo.Text:=Trim(sub);
    end;

     sub:=My_Get_String_for_to_val('XYPlotYo',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! XYPlotYo is empty.');
       bXY_empty:=true;
    end
     else
    begin
       FormXYPlot.EditYo.Text:=Trim(sub);
    end;

     sub:=My_Get_String_for_to_val('XYPlotZo',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! XYPlotZo is empty.');
       bXY_empty:=true;
    end
     else
    begin
       FormXYPlot.EditZo.Text:=Trim(sub);
    end;

    sub:=My_Get_String_for_to_val('line_directional',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! line_directional is empty.');
       bXY_empty:=true;
    end
     else
    begin
       if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
       begin
          bXY_empty:=true;
       end
       else
       begin
          FormXYPlot.ComboBoxdirectional.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    if (bXY_empty) then
    begin
        // При считывании тепловой модели инициализируем XYPlot.
        if (ls>0) then
        begin
           // Инициализируем геометрическим центром первого источника тепла при его наличии.
           FormXYPlot.EditXo.Text:=FloatToStr(0.5*(source[0].xS+source[0].xE));
           FormXYPlot.EditYo.Text:=FloatToStr(0.5*(source[0].yS+source[0].yE));
           FormXYPlot.EditZo.Text:=FloatToStr(0.5*(source[0].zS+source[0].zE));

           if (ls>1) then
           begin
              if (abs(source[0].xS-source[1].xS)>1.0e-23) then
              begin
                 FormXYPlot.ComboBoxdirectional.ItemIndex:=0; // X - directional
              end;
              if (abs(source[0].yS-source[1].yS)>1.0e-23) then
              begin
                 FormXYPlot.ComboBoxdirectional.ItemIndex:=1; // Y - directional
              end;
              if (abs(source[0].zS-source[1].zS)>1.0e-23) then
              begin
                 FormXYPlot.ComboBoxdirectional.ItemIndex:=2; // Z - directional
              end;
           end;
        end
         else
        begin
           // Инициализируем геометрическим центром кабинета.
           FormXYPlot.EditXo.Text:=FloatToStr(0.5*(body[0].xS+body[0].xE));
           FormXYPlot.EditYo.Text:=FloatToStr(0.5*(body[0].yS+body[0].yE));
           FormXYPlot.EditZo.Text:=FloatToStr(0.5*(body[0].zS+body[0].zE));
           i_3:=-1;
           for i_2 := 0 to lb-1 do
           begin
              if (body[i_2].n_power>0) then
              begin
                 if ((i_3>-1)and(abs(body[i_2].arr_power[0])>0.0)) then
                 begin
                    if (abs(body[i_3].xS-body[i_2].xS)>1.0e-23) then
                    begin
                       FormXYPlot.ComboBoxdirectional.ItemIndex:=0; // X - directional
                    end;
                    if (abs(body[i_3].yS-body[i_2].yS)>1.0e-23) then
                    begin
                       FormXYPlot.ComboBoxdirectional.ItemIndex:=1; // Y - directional
                    end;
                    if (abs(body[i_3].zS-body[i_2].zS)>1.0e-23) then
                    begin
                       FormXYPlot.ComboBoxdirectional.ItemIndex:=2; // Z - directional
                    end;
                    break;
                 end;
                 if ((i_3=-1)and(abs(body[i_2].arr_power[0])>0.0)) then
                 begin
                    i_3:=i_2;
                    FormXYPlot.EditXo.Text:=FloatToStr(0.5*(body[i_2].xS+body[i_2].xE));
                    FormXYPlot.EditYo.Text:=FloatToStr(0.5*(body[i_2].yS+body[i_2].yE));
                    FormXYPlot.EditZo.Text:=FloatToStr(0.5*(body[i_2].zS+body[i_2].zE));
                 end;
              end;
           end;
        end;
    end;


     // Read AMGCL settings 25.07.2020

     sub:=My_Get_String_for_to_val('AMGCL_ddemidov_smoother',f);
     if (length(sub)=0) then
     begin
        //ShowMessage('error! AMGCL_ddemidov_smoother is empty.');
        FormAMGCLParameters.RadioGroupAMGCLsmoother1.ItemIndex:=0; // spai0.
     end
       else
     begin
        if ((StrToInt(Trim(sub))>11)or(StrToInt(Trim(sub))<0)) then
        begin
           FormAMGCLParameters.RadioGroupAMGCLsmoother1.ItemIndex:=0; // spai0.
        end
         else
        begin
           FormAMGCLParameters.RadioGroupAMGCLsmoother1.ItemIndex:=StrToInt(Trim(sub));
        end;
     end;

    sub:=My_Get_String_for_to_val('AMGCL_ddemidov_AMG_Coarseng',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! AMGCL_ddemidov_AMG_Coarseng is empty.');
       FormAMGCLParameters.RadioGroupAMGCLCoarseningType.ItemIndex:=1; // samg.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          FormAMGCLParameters.RadioGroupAMGCLCoarseningType.ItemIndex:=1; // samg.
       end
       else
       begin
          FormAMGCLParameters.RadioGroupAMGCLCoarseningType.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;


    sub:=My_Get_String_for_to_val('AMGCL_ddemidov_Krjlov_iterator',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! AMGCL_ddemidov_Krjlov_iterator is empty.');
       FormAMGCLParameters.ComboBoxIterator.ItemIndex:=0; // bicgstab.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          FormAMGCLParameters.ComboBoxIterator.ItemIndex:=0; // bicgstab.
       end
       else
       begin
          FormAMGCLParameters.ComboBoxIterator.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    // Read amg1r5 settings 27.07.2020

    sub:=My_Get_String_for_to_val('inumber_processors',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! inumber_processors is empty.');
       FormSetting.ComboBoxNumberProcessors.ItemIndex:=0; // один поток исполнения.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>31)or(StrToInt(Trim(sub))<0)) then
       begin
          FormSetting.ComboBoxNumberProcessors.ItemIndex:=0; // один поток исполнения.
       end
       else
       begin
          FormSetting.ComboBoxNumberProcessors.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('amg1r5_Stailization',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! amg1r5_Stailization is empty.');
       Formamg1r5Parameters.ComboBoxStabilization.ItemIndex:=2; // FGMRes.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>3)or(StrToInt(Trim(sub))<0)) then
       begin
          Formamg1r5Parameters.ComboBoxStabilization.ItemIndex:=2; // FGMRes.
       end
       else
       begin
          Formamg1r5Parameters.ComboBoxStabilization.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;


    sub:=My_Get_String_for_to_val('amg1r5_number_presmoothers',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! amg1r5_number_presmoothers is empty.');
       Formamg1r5Parameters.ComboBoxNumber_of_smootherssteps.ItemIndex:=0; // одна итерация.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
       begin
          Formamg1r5Parameters.ComboBoxNumber_of_smootherssteps.ItemIndex:=0; // одна итерация.
       end
       else
       begin
          Formamg1r5Parameters.ComboBoxNumber_of_smootherssteps.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;


    sub:=My_Get_String_for_to_val('amg1r5_number_postsmoothers',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! amg1r5_number_postsmoothers is empty.');
       Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex:=0; // одна итерация.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
       begin
          Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex:=0; // одна итерация.
       end
       else
       begin
          Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('amg1r5_type_algorithm_presmoother',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! amg1r5_type_algorithm_presmoother is empty.');
       Formamg1r5Parameters.ComboBoxTypeSmoother.ItemIndex:=0; // C/F relaxation.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>3)or(StrToInt(Trim(sub))<0)) then
       begin
          Formamg1r5Parameters.ComboBoxTypeSmoother.ItemIndex:=0; // C/F relaxation.
       end
       else
       begin
          Formamg1r5Parameters.ComboBoxTypeSmoother.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('amg1r5_type_algorithm_postsmoother',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! amg1r5_type_algorithm_postsmoother is empty.');
       Formamg1r5Parameters.ComboBoxTypePostSmoother.ItemIndex:=0; // C/F relaxation.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>3)or(StrToInt(Trim(sub))<0)) then
       begin
          Formamg1r5Parameters.ComboBoxTypePostSmoother.ItemIndex:=0; // C/F relaxation.
       end
       else
       begin
          Formamg1r5Parameters.ComboBoxTypePostSmoother.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('amg1r5_Strong_threshold',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! amg1r5_Strong_threshold is empty.');
       Formamg1r5Parameters.Editstrongthreshold.Text:='0.25'; // amg1r5_Strong_threshold.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Formamg1r5Parameters.Editstrongthreshold.Text:='0.25'; // amg1r5_Strong_threshold.
       end
       else
       begin
          Formamg1r5Parameters.Editstrongthreshold.Text:=Trim(sub);
       end;
    end;

    sub:=My_Get_String_for_to_val('amg1r5_F_to_F',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! amg1r5_F_to_F is empty.');
       Formamg1r5Parameters.EditF2F.Text:='0.35'; // amg1r5_F_to_F.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Formamg1r5Parameters.EditF2F.Text:='0.35'; // amg1r5_F_to_F.
       end
       else
       begin
          Formamg1r5Parameters.EditF2F.Text:=Trim(sub);
       end;
    end;

    sub:=My_Get_String_for_to_val('amg1r5_amg1r6_version_aggregator',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! amg1r5_amg1r6_version_aggregator is empty.');
       Formamg1r5Parameters.CheckBox_amg1r6.Checked:=false; // amg1r5 version.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Formamg1r5Parameters.CheckBox_amg1r6.Checked:=false; // amg1r5 version.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // amg1r5 version
             begin
                Formamg1r5Parameters.CheckBox_amg1r6.Checked:=false; // amg1r5 version.
             end;
             1 : // amg1r6 version
             begin
                Formamg1r5Parameters.CheckBox_amg1r6.Checked:=true; // amg1r6 version.
             end;
          end;
       end;
    end;


    sub:=My_Get_String_for_to_val('PressureVelocityCoupling',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! PressureVelocityCoupling is empty.');
       FormSetting.ComboBoxPressureVelocityCoupling.ItemIndex:=0; // SIMPLE 1972 С.Патанкар и Б.Сполдинг.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          FormSetting.ComboBoxPressureVelocityCoupling.ItemIndex:=0; // SIMPLE 1972 С.Патанкар и Б.Сполдинг.
       end
       else
       begin
          FormSetting.ComboBoxPressureVelocityCoupling.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('FlowConvectionSchemePrefix_id',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! FlowConvectionSchemePrefix_id is empty.');
       FormSetting.ComboBoxFlowSchemePrefix.ItemIndex:=1; // Upwind.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          FormSetting.ComboBoxFlowSchemePrefix.ItemIndex:=1; // Upwind.
       end
       else
       begin
          FormSetting.ComboBoxFlowSchemePrefix.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('FlowConvectionScheme_id',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! FlowConvectionScheme_id is empty.');
       FormSetting.ComboBoxFlowScheme.ItemIndex:=0; // Upwind.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>15)or(StrToInt(Trim(sub))<0)) then
       begin
          FormSetting.ComboBoxFlowScheme.ItemIndex:=0; // Upwind.
       end
       else
       begin
          FormSetting.ComboBoxFlowScheme.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('TemperatureConvectionScheme_id',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! TemperatureConvectionScheme_id is empty.');
       FormSetting.ComboBoxSchemeTemperature.ItemIndex:=0; // Upwind.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>15)or(StrToInt(Trim(sub))<0)) then
       begin
          FormSetting.ComboBoxSchemeTemperature.ItemIndex:=0; // Upwind.
       end
       else
       begin
          FormSetting.ComboBoxSchemeTemperature.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('ILUK_lfil_number',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! ILUK_lfil_number is empty.');
       FormSetting.ComboBox_lfil.ItemIndex:=2; // lfil=2.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>7)or(StrToInt(Trim(sub))<0)) then
       begin
          FormSetting.ComboBox_lfil.ItemIndex:=2; // lfil=2.
       end
       else
       begin
          FormSetting.ComboBox_lfil.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('FGMRes_mrestart_number',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! FGMRes_mrestart_number is empty.');
       FormSetting.ComboBox_m_restart_for_gmres.ItemIndex:=1; // FGMRes(Mrestart=20).
    end
     else
    begin
       if ((StrToInt(Trim(sub))>9)or(StrToInt(Trim(sub))<0)) then
       begin
          FormSetting.ComboBox_m_restart_for_gmres.ItemIndex:=1; // FGMRes(Mrestart=20).
       end
       else
       begin
          FormSetting.ComboBox_m_restart_for_gmres.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;


     // Считывание настроек Румба v.0.14 решателя.
    // 28.07.2020.

    sub:=My_Get_String_for_to_val('Maximum_reduced_levels_Temperature',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Maximum_reduced_levels_Temperature is empty.');
       Form_amg_manager.ComboBoxmaximumreducedlevels.ItemIndex:=0; // отсутствуют редуцируемые уровни.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>20)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxmaximumreducedlevels.ItemIndex:=0; // отсутствуют редуцируемые уровни.
       end
       else
       begin
          Form_amg_manager.ComboBoxmaximumreducedlevels.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Maximum_reduced_levels_Speed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Maximum_reduced_levels_Speed is empty.');
       Form_amg_manager.ComboBoxmaximumreducedlevelsSpeed.ItemIndex:=0; // отсутствуют редуцируемые уровни.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>20)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxmaximumreducedlevelsSpeed.ItemIndex:=0; // отсутствуют редуцируемые уровни.
       end
       else
       begin
          Form_amg_manager.ComboBoxmaximumreducedlevelsSpeed.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Maximum_reduced_levels_Pressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Maximum_reduced_levels_Pressure is empty.');
       Form_amg_manager.ComboBoxmaximumreducedlevelsPressure.ItemIndex:=0; // отсутствуют редуцируемые уровни.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>20)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxmaximumreducedlevelsPressure.ItemIndex:=0; // отсутствуют редуцируемые уровни.
       end
       else
       begin
          Form_amg_manager.ComboBoxmaximumreducedlevelsPressure.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Maximum_reduced_levels_Stress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Maximum_reduced_levels_Stress is empty.');
       Form_amg_manager.ComboBoxmaximumreducedlevelsStress.ItemIndex:=0; // отсутствуют редуцируемые уровни.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>20)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxmaximumreducedlevelsStress.ItemIndex:=0; // отсутствуют редуцируемые уровни.
       end
       else
       begin
          Form_amg_manager.ComboBoxmaximumreducedlevelsStress.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_nFinnest',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_nFinnest is empty.');
       Form_amg_manager.ComboBoxnFinnest.ItemIndex:=1; // две итерации на самой подробной сетке.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxnFinnest.ItemIndex:=1; // две итерации на самой подробной сетке.
       end
       else
       begin
          Form_amg_manager.ComboBoxnFinnest.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_nFinnestSpeed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_nFinnestSpeed is empty.');
       Form_amg_manager.ComboBoxnFinnestSpeed.ItemIndex:=1; // две итерации на самой подробной сетке.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxnFinnestSpeed.ItemIndex:=1; // две итерации на самой подробной сетке.
       end
       else
       begin
          Form_amg_manager.ComboBoxnFinnestSpeed.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_nFinnestPressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_nFinnestPressure is empty.');
       Form_amg_manager.ComboBoxnFinnestPressure.ItemIndex:=1; // две итерации на самой подробной сетке.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxnFinnestPressure.ItemIndex:=1; // две итерации на самой подробной сетке.
       end
       else
       begin
          Form_amg_manager.ComboBoxnFinnestPressure.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_nFinnestStress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_nFinnestStress is empty.');
       Form_amg_manager.ComboBoxnFinnestStress.ItemIndex:=1; // две итерации на самой подробной сетке.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxnFinnestStress.ItemIndex:=1; // две итерации на самой подробной сетке.
       end
       else
       begin
          Form_amg_manager.ComboBoxnFinnestStress.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_number_presmoothers',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_number_presmoothers is empty.');
       Form_amg_manager.ComboBoxnumberpresmothers.ItemIndex:=1; // Одна итерация для предсглаживания.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxnumberpresmothers.ItemIndex:=1; // Одна итерация для предсглаживания.
       end
       else
       begin
          Form_amg_manager.ComboBoxnumberpresmothers.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_number_presmoothersSpeed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_number_presmoothersSpeed is empty.');
       Form_amg_manager.ComboBoxnumberpresmothersSpeed.ItemIndex:=1; // Одна итерация для предсглаживания.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxnumberpresmothersSpeed.ItemIndex:=1; // Одна итерация для предсглаживания.
       end
       else
       begin
          Form_amg_manager.ComboBoxnumberpresmothersSpeed.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;


     sub:=My_Get_String_for_to_val('Rumba_number_presmoothersPressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_number_presmoothersPressure is empty.');
       Form_amg_manager.ComboBoxnumberpresmothersPressure.ItemIndex:=1; // Одна итерация для предсглаживания.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxnumberpresmothersPressure.ItemIndex:=1; // Одна итерация для предсглаживания.
       end
       else
       begin
          Form_amg_manager.ComboBoxnumberpresmothersPressure.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_number_presmoothersStress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_number_presmoothersStress is empty.');
       Form_amg_manager.ComboBoxnumberpresmoothersStress.ItemIndex:=1; // Одна итерация для предсглаживания.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxnumberpresmoothersStress.ItemIndex:=1; // Одна итерация для предсглаживания.
       end
       else
       begin
          Form_amg_manager.ComboBoxnumberpresmoothersStress.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_number_postsmoothers',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_number_postsmoothers is empty.');
       Form_amg_manager.ComboBoxnumberpostsweeps.ItemIndex:=2; // Две итерации для постсглаживания.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxnumberpostsweeps.ItemIndex:=2; // Две итерации для постсглаживания.
       end
       else
       begin
          Form_amg_manager.ComboBoxnumberpostsweeps.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_number_postsmoothersSpeed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_number_postsmoothersSpeed is empty.');
       Form_amg_manager.ComboBoxnumberpostsweepsSpeed.ItemIndex:=2; // Две итерации для постсглаживания.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxnumberpostsweepsSpeed.ItemIndex:=2; // Две итерации для постсглаживания.
       end
       else
       begin
          Form_amg_manager.ComboBoxnumberpostsweepsSpeed.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_number_postsmoothersPressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_number_postsmoothersPressure is empty.');
       Form_amg_manager.ComboBoxnumberpostsweepsPressure.ItemIndex:=2; // Две итерации для постсглаживания.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxnumberpostsweepsPressure.ItemIndex:=2; // Две итерации для постсглаживания.
       end
       else
       begin
          Form_amg_manager.ComboBoxnumberpostsweepsPressure.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_number_postsmoothersStress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_number_postsmoothersStress is empty.');
       Form_amg_manager.ComboBoxnumberpostsweepsStress.ItemIndex:=2; // Две итерации для постсглаживания.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxnumberpostsweepsStress.ItemIndex:=2; // Две итерации для постсглаживания.
       end
       else
       begin
          Form_amg_manager.ComboBoxnumberpostsweepsStress.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

     sub:=My_Get_String_for_to_val('Rumba_memory_size',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_memory_size is empty.');
       Form_amg_manager.ComboBoxmemorysize.ItemIndex:=5; // Девять размеров исходной матрицы.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>96)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxmemorysize.ItemIndex:=5; // Девять размеров исходной матрицы.
       end
       else
       begin
          Form_amg_manager.ComboBoxmemorysize.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_memory_sizeSpeed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_memory_sizeSpeed is empty.');
       Form_amg_manager.ComboBoxmemorysizeSpeed.ItemIndex:=5; // Девять размеров исходной матрицы.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>96)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxmemorysizeSpeed.ItemIndex:=5; // Девять размеров исходной матрицы.
       end
       else
       begin
          Form_amg_manager.ComboBoxmemorysizeSpeed.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_memory_sizePressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_memory_sizePressure is empty.');
       Form_amg_manager.ComboBoxmemorysizePressure.ItemIndex:=5; // Девять размеров исходной матрицы.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>96)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxmemorysizePressure.ItemIndex:=5; // Девять размеров исходной матрицы.
       end
       else
       begin
          Form_amg_manager.ComboBoxmemorysizePressure.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;


    sub:=My_Get_String_for_to_val('Rumba_memory_sizeStress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_memory_sizeStress is empty.');
       Form_amg_manager.ComboBoxmemorysizeStress.ItemIndex:=5; // Девять размеров исходной матрицы.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>96)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxmemorysizeStress.ItemIndex:=5; // Девять размеров исходной матрицы.
       end
       else
       begin
          Form_amg_manager.ComboBoxmemorysizeStress.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;


    sub:=My_Get_String_for_to_val('Rumba_interpolation_id',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_interpolation_id is empty.');
       Form_amg_manager.ComboBoxinterpolation.ItemIndex:=3; // 4 - ая версия интерполяции.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxinterpolation.ItemIndex:=3; // 4 - ая версия интерполяции.
       end
       else
       begin
          Form_amg_manager.ComboBoxinterpolation.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_interpolation_id_Speed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_interpolation_id_Speed is empty.');
       Form_amg_manager.ComboBoxinterpolationSpeed.ItemIndex:=3; // 4 - ая версия интерполяции.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxinterpolationSpeed.ItemIndex:=3; // 4 - ая версия интерполяции.
       end
       else
       begin
          Form_amg_manager.ComboBoxinterpolationSpeed.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;


    sub:=My_Get_String_for_to_val('Rumba_interpolation_id_Pressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_interpolation_id_Pressure is empty.');
       Form_amg_manager.ComboBoxinterpolationPressure.ItemIndex:=3; // 4 - ая версия интерполяции.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxinterpolationPressure.ItemIndex:=3; // 4 - ая версия интерполяции.
       end
       else
       begin
          Form_amg_manager.ComboBoxinterpolationPressure.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_interpolation_id_Stress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_interpolation_id_Stress is empty.');
       Form_amg_manager.ComboBoxinterpollationStress.ItemIndex:=3; // 4 - ая версия интерполяции.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>5)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxinterpollationStress.ItemIndex:=3; // 4 - ая версия интерполяции.
       end
       else
       begin
          Form_amg_manager.ComboBoxinterpollationStress.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_sort_algo',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_sort_algo is empty.');
       Form_amg_manager.ComboBoxSort.ItemIndex:=0; // CountingSort.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>4)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxSort.ItemIndex:=0; // CountingSort.
       end
       else
       begin
          Form_amg_manager.ComboBoxSort.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;


    sub:=My_Get_String_for_to_val('Rumba_Relaxation_Temperature',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_Relaxation_Temperature is empty.');
       Form_amg_manager.ComboBoxsmoothertypeTemperature.ItemIndex:=0; // Gauss-Seidel.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>7)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxsmoothertypeTemperature.ItemIndex:=0; // Gauss-Seidel.
       end
       else
       begin
          Form_amg_manager.ComboBoxsmoothertypeTemperature.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;


    sub:=My_Get_String_for_to_val('Rumba_Relaxation_Speed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_Relaxation_Speed is empty.');
       Form_amg_manager.ComboBoxsmoothertypeSpeed.ItemIndex:=0; // Gauss-Seidel.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>7)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxsmoothertypeSpeed.ItemIndex:=0; // Gauss-Seidel.
       end
       else
       begin
          Form_amg_manager.ComboBoxsmoothertypeSpeed.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_Relaxation_Pressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_Relaxation_Pressure is empty.');
       Form_amg_manager.ComboBoxsmoothertypePressure.ItemIndex:=0; // Gauss-Seidel.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>7)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxsmoothertypePressure.ItemIndex:=0; // Gauss-Seidel.
       end
       else
       begin
          Form_amg_manager.ComboBoxsmoothertypePressure.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_Relaxation_Stress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_Relaxation_Stress is empty.');
       Form_amg_manager.ComboBoxsmoothertypeStress.ItemIndex:=0; // Gauss-Seidel.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>7)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxsmoothertypeStress.ItemIndex:=0; // Gauss-Seidel.
       end
       else
       begin
          Form_amg_manager.ComboBoxsmoothertypeStress.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_amg_splitting_coarsening',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_amg_splitting_coarsening is empty.');
       Form_amg_manager.ComboBoxcoarseningTemp.ItemIndex:=2; // classical ST all connection.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>9)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxcoarseningTemp.ItemIndex:=2; // classical ST all connection.
       end
       else
       begin
          Form_amg_manager.ComboBoxcoarseningTemp.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

     sub:=My_Get_String_for_to_val('Rumba_amg_splitting_coarseningSpeed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_amg_splitting_coarseningSpeed is empty.');
       Form_amg_manager.ComboBoxcoarseningSpeed.ItemIndex:=2; // classical ST all connection.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>9)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxcoarseningSpeed.ItemIndex:=2; // classical ST all connection.
       end
       else
       begin
          Form_amg_manager.ComboBoxcoarseningSpeed.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_amg_splitting_coarseningPressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_amg_splitting_coarseningPressure is empty.');
       Form_amg_manager.ComboBoxcoarseningPressure.ItemIndex:=2; // classical ST all connection.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>9)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxcoarseningPressure.ItemIndex:=2; // classical ST all connection.
       end
       else
       begin
          Form_amg_manager.ComboBoxcoarseningPressure.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;


    sub:=My_Get_String_for_to_val('Rumba_amg_splitting_coarseningStress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_amg_splitting_coarseningStress is empty.');
       Form_amg_manager.ComboBoxcoarseningStress.ItemIndex:=2; // classical ST all connection.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>9)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxcoarseningStress.ItemIndex:=2; // classical ST all connection.
       end
       else
       begin
          Form_amg_manager.ComboBoxcoarseningStress.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_Stabilization',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_Stabilization is empty.');
       Form_amg_manager.ComboBoxStabilizationTemp.ItemIndex:=0; // none.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>3)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxStabilizationTemp.ItemIndex:=0; // none.
       end
       else
       begin
          Form_amg_manager.ComboBoxStabilizationTemp.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_StabilizationSpeed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_StabilizationSpeed is empty.');
       Form_amg_manager.ComboBoxStabilizationSpeed.ItemIndex:=0; // none.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxStabilizationSpeed.ItemIndex:=0; // none.
       end
       else
       begin
          Form_amg_manager.ComboBoxStabilizationSpeed.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_StabilizationPressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_StabilizationPressure is empty.');
       Form_amg_manager.ComboBoxStabilizationPressure.ItemIndex:=0; // none.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxStabilizationPressure.ItemIndex:=0; // none.
       end
       else
       begin
          Form_amg_manager.ComboBoxStabilizationPressure.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_StabilizationStress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_StabilizationStress is empty.');
       Form_amg_manager.ComboBoxStabilizationStress.ItemIndex:=0; // none.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>2)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxStabilizationStress.ItemIndex:=0; // none.
       end
       else
       begin
          Form_amg_manager.ComboBoxStabilizationStress.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('C_F_decomposition_algorithms_and_data_structure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! C_F_decomposition_algorithms_and_data_structure is empty.');
       Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Temperature.ItemIndex:=2; // BinaryHeap.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Temperature.ItemIndex:=2; // BinaryHeap.
       end
       else
       begin
          Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Temperature.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;


    sub:=My_Get_String_for_to_val('C_F_decomposition_algorithms_and_data_structureSpeed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! C_F_decomposition_algorithms_and_data_structureSpeed is empty.');
       Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Speed.ItemIndex:=2; // BinaryHeap.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Speed.ItemIndex:=2; // BinaryHeap.
       end
       else
       begin
          Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Speed.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('C_F_decomposition_algorithms_and_data_structurePressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! C_F_decomposition_algorithms_and_data_structurePressure is empty.');
       Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Pressure.ItemIndex:=2; // BinaryHeap.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Pressure.ItemIndex:=2; // BinaryHeap.
       end
       else
       begin
          Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Pressure.ItemIndex:=StrToInt(Trim(sub));
       end;
    end;

    sub:=My_Get_String_for_to_val('C_F_decomposition_algorithms_and_data_structureStress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! C_F_decomposition_algorithms_and_data_structureStress is empty.');
       Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Stress.ItemIndex:=2; // BinaryHeap.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>6)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Stress.ItemIndex:=2; // BinaryHeap.
       end
       else
       begin
          Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Stress.ItemIndex:=StrToInt(Trim(sub));
       end;
    end; // 30.07.2020


    // 30.07.2020

    sub:=My_Get_String_for_to_val('Rumba_threshold_Temperature',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_threshold_Temperature is empty.');
       Form_amg_manager.Editthreshold.Text:='0.24'; // recomended threshold.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Form_amg_manager.Editthreshold.Text:='0.24'; // recomended threshold.
       end
       else
       begin
          Form_amg_manager.Editthreshold.Text:=Trim(sub);
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_threshold_Speed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_threshold_Speed is empty.');
       Form_amg_manager.EditthresholdSpeed.Text:='0.24'; // recomended threshold.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Form_amg_manager.EditthresholdSpeed.Text:='0.24'; // recomended threshold.
       end
       else
       begin
          Form_amg_manager.EditthresholdSpeed.Text:=Trim(sub);
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_threshold_Pressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_threshold_Pressure is empty.');
       Form_amg_manager.EditthresholdPressure.Text:='0.24'; // recomended threshold.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Form_amg_manager.EditthresholdPressure.Text:='0.24'; // recomended threshold.
       end
       else
       begin
          Form_amg_manager.EditthresholdPressure.Text:=Trim(sub);
       end;
    end;


    sub:=My_Get_String_for_to_val('Rumba_threshold_Stress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_threshold_Stress is empty.');
       Form_amg_manager.EditthresholdStress.Text:='0.24'; // recomended threshold.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Form_amg_manager.EditthresholdStress.Text:='0.24'; // recomended threshold.
       end
       else
       begin
          Form_amg_manager.EditthresholdStress.Text:=Trim(sub);
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_truncation_interpolation_Temp',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_truncation_interpolation_Temp is empty.');
       Form_amg_manager.Edit_truncation_T.Text:='0.2'; // recomended truncation.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Form_amg_manager.Edit_truncation_T.Text:='0.2'; // recomended truncation.
       end
       else
       begin
          Form_amg_manager.Edit_truncation_T.Text:=Trim(sub);
       end;
    end;

     sub:=My_Get_String_for_to_val('Rumba_truncation_interpolation_Speed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_truncation_interpolation_Speed is empty.');
       Form_amg_manager.Edit_truncation_Speed.Text:='0.2'; // recomended truncation.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Form_amg_manager.Edit_truncation_Speed.Text:='0.2'; // recomended truncation.
       end
       else
       begin
          Form_amg_manager.Edit_truncation_Speed.Text:=Trim(sub);
       end;
    end;

     sub:=My_Get_String_for_to_val('Rumba_truncation_interpolation_Pressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_truncation_interpolation_Pressure is empty.');
       Form_amg_manager.Edit_truncation_Pressure.Text:='0.2'; // recomended truncation.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Form_amg_manager.Edit_truncation_Pressure.Text:='0.2'; // recomended truncation.
       end
       else
       begin
          Form_amg_manager.Edit_truncation_Pressure.Text:=Trim(sub);
       end;
    end;

     sub:=My_Get_String_for_to_val('Rumba_truncation_interpolation_Stress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_truncation_interpolation_Stress is empty.');
       Form_amg_manager.Edittruncation_Stress.Text:='0.2'; // recomended truncation.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Form_amg_manager.Edittruncation_Stress.Text:='0.2'; // recomended truncation.
       end
       else
       begin
          Form_amg_manager.Edittruncation_Stress.Text:=Trim(sub);
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_F2F_Temperature',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_F2F_Temperature is empty.');
       Form_amg_manager.EditmagicT.Text:='0.4'; // recomended F2F value.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Form_amg_manager.EditmagicT.Text:='0.4'; // recomended F2F value.
       end
       else
       begin
          Form_amg_manager.EditmagicT.Text:=Trim(sub);
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_F2F_Speed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_F2F_Speed is empty.');
       Form_amg_manager.EditmagicSpeed.Text:='0.4'; // recomended F2F value.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Form_amg_manager.EditmagicSpeed.Text:='0.4'; // recomended F2F value.
       end
       else
       begin
          Form_amg_manager.EditmagicSpeed.Text:=Trim(sub);
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_F2F_Pressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_F2F_Pressure is empty.');
       Form_amg_manager.EditmagicPressure.Text:='0.4'; // recomended F2F value.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Form_amg_manager.EditmagicPressure.Text:='0.4'; // recomended F2F value.
       end
       else
       begin
          Form_amg_manager.EditmagicPressure.Text:=Trim(sub);
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_F2F_Stress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_F2F_Stress is empty.');
       Form_amg_manager.EditmagicStress.Text:='0.4'; // recomended F2F value.
    end
     else
    begin
       if ((StrToFloat(Trim(sub))>0.98)or(StrToFloat(Trim(sub))<0.02)) then
       begin
          Form_amg_manager.EditmagicStress.Text:='0.4'; // recomended F2F value.
       end
       else
       begin
          Form_amg_manager.EditmagicStress.Text:=Trim(sub);
       end;
    end;


    sub:=My_Get_String_for_to_val('Rumba_Diagonal_dominant',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_Diagonal_dominant is empty.');
       Form_amg_manager.CheckBoxDiagonalDominant.Checked:=true; // diagonal dominant Yes.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxDiagonalDominant.Checked:=true; // diagonal dominant Yes.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // diagonal dominant
             begin
                Form_amg_manager.CheckBoxDiagonalDominant.Checked:=false; // diagonal dominant NO.
             end;
             1 : // diagonal dominant
             begin
                Form_amg_manager.CheckBoxDiagonalDominant.Checked:=true; // diagonal dominant Yes.
             end;
          end;
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_truncationT',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_truncationT is empty.');
       Form_amg_manager.CheckBoxtruncationT.Checked:=true; // truncation Temperature Yes.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxtruncationT.Checked:=true; // truncation Temperature Yes.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // truncation Temperature
             begin
                Form_amg_manager.CheckBoxtruncationT.Checked:=false; // truncation Temperature NO.
             end;
             1 : // truncation Temperature
             begin
                Form_amg_manager.CheckBoxtruncationT.Checked:=true; // truncation Temperature Yes.
             end;
          end;
       end;
    end;

     sub:=My_Get_String_for_to_val('Rumba_truncationSpeed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_truncationSpeed is empty.');
       Form_amg_manager.CheckBoxtruncationSpeed.Checked:=true; // truncation Speed Yes.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxtruncationSpeed.Checked:=true; // truncation Speed Yes.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // truncation Speed
             begin
                Form_amg_manager.CheckBoxtruncationSpeed.Checked:=false; // truncation Speed NO.
             end;
             1 : // truncation Speed
             begin
                Form_amg_manager.CheckBoxtruncationSpeed.Checked:=true; // truncation Speed Yes.
             end;
          end;
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_truncationPressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_truncationPressure is empty.');
       Form_amg_manager.CheckBoxtruncationPressure.Checked:=true; // truncation Pressure Yes.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxtruncationPressure.Checked:=true; // truncation Pressure Yes.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // truncation Pressure
             begin
                Form_amg_manager.CheckBoxtruncationPressure.Checked:=false; // truncation Pressure NO.
             end;
             1 : // truncation Pressure
             begin
                Form_amg_manager.CheckBoxtruncationPressure.Checked:=true; // truncation Pressure Yes.
             end;
          end;
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_truncationStress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_truncationStress is empty.');
       Form_amg_manager.CheckBoxtruncationStress.Checked:=true; // truncation Stress Yes.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxtruncationStress.Checked:=true; // truncation Stress Yes.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // truncation Temperature
             begin
                Form_amg_manager.CheckBoxtruncationStress.Checked:=false; // truncation Stress NO.
             end;
             1 : // truncation Temperature
             begin
                Form_amg_manager.CheckBoxtruncationStress.Checked:=true; // truncation Stress Yes.
             end;
          end;
       end;
    end;


    sub:=My_Get_String_for_to_val('Rumba_StrongTranspose',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_StrongTranspose is empty.');
       Form_amg_manager.CheckBoxStrongTranspose.Checked:=true; // Strong Transpose Yes.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxStrongTranspose.Checked:=true; // Strong Transpose Yes.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // Strong Transpose
             begin
                Form_amg_manager.CheckBoxStrongTranspose.Checked:=false; // Strong Transpose NO.
             end;
             1 : // Strong Transpose
             begin
                Form_amg_manager.CheckBoxStrongTranspose.Checked:=true; // Strong Transpose Yes.
             end;
          end;
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_PrintLogTemperature',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_PrintLogTemperature is empty.');
       Form_amg_manager.CheckBoxprintlogTemperature.Checked:=true; // печататать лог amg решения Yes.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxprintlogTemperature.Checked:=true; // печататать лог amg решения Yes.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // печататать лог amg решения
             begin
                Form_amg_manager.CheckBoxprintlogTemperature.Checked:=false; // печататать лог amg решения NO.
             end;
             1 : // печататать лог amg решения
             begin
                Form_amg_manager.CheckBoxprintlogTemperature.Checked:=true; // печататать лог amg решения Yes.
             end;
          end;
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_PrintLogSpeed',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_PrintLogSpeed is empty.');
       Form_amg_manager.CheckBoxprintlogSpeed.Checked:=true; // печататать лог amg решения Yes.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxprintlogSpeed.Checked:=true; // печататать лог amg решения Yes.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // печататать лог amg решения
             begin
                Form_amg_manager.CheckBoxprintlogSpeed.Checked:=false; // печататать лог amg решения NO.
             end;
             1 : // печататать лог amg решения
             begin
                Form_amg_manager.CheckBoxprintlogSpeed.Checked:=true; // печататать лог amg решения Yes.
             end;
          end;
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_PrintLogPressure',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_PrintLogPressure is empty.');
       Form_amg_manager.CheckBoxprintlogPressure.Checked:=true; // печататать лог amg решения Yes.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxprintlogPressure.Checked:=true; // печататать лог amg решения Yes.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // печататать лог amg решения
             begin
                Form_amg_manager.CheckBoxprintlogPressure.Checked:=false; // печататать лог amg решения NO.
             end;
             1 : // печататать лог amg решения
             begin
                Form_amg_manager.CheckBoxprintlogPressure.Checked:=true; // печататать лог amg решения Yes.
             end;
          end;
       end;
    end;

     sub:=My_Get_String_for_to_val('Rumba_PrintLogStress',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_PrintLogStress is empty.');
       Form_amg_manager.CheckBoxprintlogStress.Checked:=true; // печататать лог amg решения Yes.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxprintlogStress.Checked:=true; // печататать лог amg решения Yes.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // печататать лог amg решения
             begin
                Form_amg_manager.CheckBoxprintlogStress.Checked:=false; // печататать лог amg решения NO.
             end;
             1 : // печататать лог amg решения
             begin
                Form_amg_manager.CheckBoxprintlogStress.Checked:=true; // печататать лог amg решения Yes.
             end;
          end;
       end;
    end;


    sub:=My_Get_String_for_to_val('Rumba_TemperatureMatrixPortrait',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_TemperatureMatrixPortrait is empty.');
       Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked:=false; // печататать портрет матрицы NO.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked:=false; // печататать портрет матрицы NO.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // печататать портрет матрицы
             begin
                Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked:=false; // печататать портрет матрицы NO.
             end;
             1 : // печататать портрет матрицы
             begin
                Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked:=true; // печататать портрет матрицы Yes.
             end;
          end;
       end;
    end;

     sub:=My_Get_String_for_to_val('Rumba_SpeedMatrixPortrait',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_SpeedMatrixPortrait is empty.');
       Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked:=false; // печататать портрет матрицы NO.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked:=false; // печататать портрет матрицы NO.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // печататать портрет матрицы
             begin
                Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked:=false; // печататать портрет матрицы NO.
             end;
             1 : // печататать портрет матрицы
             begin
                Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked:=true; // печататать портрет матрицы Yes.
             end;
          end;
       end;
    end;

     sub:=My_Get_String_for_to_val('Rumba_PressureMatrixPortrait',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_PressureMatrixPortrait is empty.');
       Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked:=false; // печататать портрет матрицы NO.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked:=false; // печататать портрет матрицы NO.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // печататать портрет матрицы
             begin
                Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked:=false; // печататать портрет матрицы NO.
             end;
             1 : // печататать портрет матрицы
             begin
                Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked:=true; // печататать портрет матрицы Yes.
             end;
          end;
       end;
    end;

    sub:=My_Get_String_for_to_val('Rumba_StressMatrixPortrait',f);
    if (length(sub)=0) then
    begin
       //ShowMessage('error! Rumba_StressMatrixPortrait is empty.');
       Form_amg_manager.CheckBoxStressMatrixPortrait.Checked:=false; // печататать портрет матрицы NO.
    end
     else
    begin
       if ((StrToInt(Trim(sub))>1)or(StrToInt(Trim(sub))<0)) then
       begin
          Form_amg_manager.CheckBoxStressMatrixPortrait.Checked:=false; // печататать портрет матрицы NO.
       end
       else
       begin
          case StrToInt(Trim(sub)) of
             0 : // печататать портрет матрицы
             begin
                Form_amg_manager.CheckBoxStressMatrixPortrait.Checked:=false; // печататать портрет матрицы NO.
             end;
             1 : // печататать портрет матрицы
             begin
                Form_amg_manager.CheckBoxStressMatrixPortrait.Checked:=true; // печататать портрет матрицы Yes.
             end;
          end;
       end;
    end;

       end;

       // отображение дерева элементов:
       TreeLoad(Sender);
       breadfinish:=true;
     end
      else
     begin
        MainMemo.Lines.Add('File not model for AliceMesh.v.0.45.');
        ShowMessage('File not model for AliceMesh.v.0.45');
        breadfinish:=false;
     end;

     f.Free;
     // прорисовка геометрии
   end;  // иначе чтение файла не удалось, например пользователь отказался от открытитя файла.


end; // My_read_model_new();

begin

   //My_read_model_old();
   My_read_model_new(bperenapravlenie_na_import);
   bperenapravlenie_na_import:=false;

   // Снимаем флаг первого запуска. Запуск больше уже не первый и инициализация не требуется.
   FormXYPlot.bfirst_zapusk_XYPlot:=false;

end;


procedure TLaplas.TreeLoad(Sender: TObject);
var
  j,iscan_ass, idob, i_2   : Integer;
  NewNode, Nodeloc, Noddy : TTreeNode; // узел дерева элементов
   flagunion : array of Boolean; //  было ли создано объединение
   bdobavlen : array of Boolean; // какие блоки уже были добавлены в дерево.
   SearchTarget : String;
   Searching, not_ignoring : Boolean;
   imeshassemblesseparately : Integer;
   bOk : Boolean;
   Qunion_number : array of Integer; // номера unionov
    im1, im2 : Integer;
   i_1, iunion_old, lb_old, icb_old, imatherial_old : Integer;
   priority_id_old, ls_old, lw_old, ics_old, icw_old : Integer;
   ivar_package, j_var : Integer;
   bfound_variable : Boolean;
   snew, sold, subloc : String;
begin
  // отображение дерева элементов:

   // количество объединений уже известно.
   // Всего lu объединений.
   iscan_ass:=-1;
   for j := 0 to lb-1 do
   begin
      if (body[j].iunion>iscan_ass) then
      begin
         // iunion=0 cabinet
         // identifier с 1.
         iscan_ass:=body[j].iunion;
      end;
   end;
   for j := 0 to ls-1 do
   begin
      if (source[j].iunion>iscan_ass) then
      begin
         // iunion=0 cabinet
         // identifier с 1.
         iscan_ass:=source[j].iunion;
      end;
   end;
   for j := 0 to lw-1 do
   begin
      if (wall[j].iunion>iscan_ass) then
      begin
         // iunion=0 cabinet
         // identifier с 1.
         iscan_ass:=wall[j].iunion;
      end;
   end;
   for j := 0 to lu-1 do
   begin
      if (myassembles[j].identifire>iscan_ass) then
      begin
         // iunion=0 cabinet
         // identifier с 1.
         iscan_ass:=myassembles[j].identifire;
      end;
   end;
   //SetLength(flagunion,lu+1);
   //for j:=0 to lu do flagunion[j]:=false; // ни один union не был создан
   SetLength(flagunion,iscan_ass+1);
   for j := 0 to iscan_ass do flagunion[j]:=false; // ни один union не был создан
   //ShowMessage('lu='+IntToStr(lu)+' iscan_ass='+IntToStr(iscan_ass));


   idob:=0;
   SetLength(bdobavlen,lb);
   for idob := 0 to lb-1 do
   begin
      bdobavlen[idob]:=false;
   end;


   MainTreeView.Items.Clear; // очистка дерева
   for j:=0 to (lb-1) do
   begin
      if (not(bdobavlen[j])) then
      begin

      if (j=0) then
      begin
         // кабинет
         NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,body[j].name);
         NewNode.ImageIndex:=0;  // номер картинки
         NewNode.SelectedIndex:=0; // номер картинки когда элемент выделен
         bdobavlen[j]:=true;
      end
       else
      begin
         // другие блоки
         if (body[j].iunion=0) then
         begin
            MainTreeView.SetFocus;
            MainTreeView.items[0].Selected:=true;  // выделяем кабинет.
            NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,body[j].name);
            NewNode.ImageIndex:=1;  // номер картинки
            NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен
            bdobavlen[j]:=true;
         end
          else
         begin
            // находим номер асемблеса которому принадлежит блок.
            for iscan_ass := 0 to lu do
            begin
               // identifier с 1 . iunion для не cabinet с 1.
               if (myassembles[iscan_ass].identifire=body[j].iunion) then
               begin
                  break;
               end;
            end;

            if (flagunion[body[j].iunion]=false) then
            begin
               // юнион еще не обработан.

               if (myassembles[iscan_ass].iunionparent=-1) then
               begin
                  MainTreeView.SetFocus;
                  MainTreeView.items[0].Selected:=true;  // выделяем кабинет.
                  NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,myassembles[iscan_ass].name);
                  NewNode.ImageIndex:=4;  // номер картинки
                  NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
               end
                else
               begin


                  // у union`а есть родительский union не являющийся кабинетом.
                  im1:=1;
                  SetLength(Qunion_number,im1);
                  Qunion_number[0]:=body[j].iunion;
                  while ((Qunion_number[im1-1]<>0)and (flagunion[Qunion_number[im1-1]]=false)) do
                  begin
                     inc(im1);
                     SetLength(Qunion_number,im1);
                     for i_2 := 0 to lu-1 do
                     begin
                        if (myassembles[i_2].identifire=Qunion_number[im1-2]) then
                        begin
                           break;
                        end;
                     end;
                     Qunion_number[im1-1]:=myassembles[i_2].iunionparent+1;
                  end;
                  // построен список вложенных unionov.
                  // в конце списка либо кабинет либо уже построенный union.
                  // последний значимый элемент im1-2. Всего значимых элементов im1-1.
                  // Теперь надо создать в дереве последовательность вложенных unionov.
                  if (Qunion_number[im1-1]=0) then
                  begin
                     MainTreeView.SetFocus;
                     MainTreeView.items[0].Selected:=true;  // выделяем кабинет.
                     for i_2 := 0 to lu-1 do
                     begin
                        if (myassembles[i_2].identifire=Qunion_number[im1-2]) then
                        begin
                           break;
                        end;
                     end;
                     NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,myassembles[i_2].name);
                     NewNode.ImageIndex:=4;  // номер картинки
                     NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                     for im2:=im1-3 downto 0 do
                     begin
                        for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im2+1]) then
                           begin
                              break;
                           end;
                        end;
                        SearchTarget:=myassembles[i_2].name;
                        Noddy := MainTreeView.Items[0];
                        Searching := true;
                        while (Searching) and (Noddy <> nil) do
                        begin
                           if Noddy.text = SearchTarget then
                           begin
                              // найден
                              Searching := False;
                              MainTreeView.Selected := Noddy;
                              MainTreeView.SetFocus;
                           end
                            else
                           begin
                              Noddy := Noddy.GetNext
                           end;
                        end;
                        Nodeloc:=MainTreeView.Selected;
                         for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im2]) then
                           begin
                              break;
                           end;
                        end;
                        NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,myassembles[i_2].name);
                        NewNode.ImageIndex:=4;  // номер картинки
                        NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                        MainTreeView.Selected:=Nodeloc;
                     end;
                  end
                   else
                  begin
                     for im2:=im1-2 downto 0 do
                     begin
                        for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im2+1]) then
                           begin
                              break;
                           end;
                        end;
                        SearchTarget:=myassembles[i_2].name;
                        Noddy := MainTreeView.Items[0];
                        Searching := true;
                        while (Searching) and (Noddy <> nil) do
                        begin
                           if Noddy.text = SearchTarget then
                           begin
                              // найден
                              Searching := False;
                              MainTreeView.Selected := Noddy;
                              MainTreeView.SetFocus;
                           end
                            else
                           begin
                              Noddy := Noddy.GetNext
                           end;
                        end;
                        Nodeloc:=MainTreeView.Selected;
                        for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im2]) then
                           begin
                              break;
                           end;
                        end;
                        NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,myassembles[i_2].name);
                        NewNode.ImageIndex:=4;  // номер картинки
                        NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                        MainTreeView.Selected:=Nodeloc;
                     end;
                  end;
                  for im2:=0 to im1-2 do
                  begin
                     flagunion[Qunion_number[im2]]:=True;
                  end;
               end;

                SearchTarget:=myassembles[iscan_ass].name;
                Noddy := MainTreeView.Items[0];
                Searching := true;
                while (Searching) and (Noddy <> nil) do
                begin
                   if Noddy.text = SearchTarget then
                   begin
                      // найден
                      Searching := False;
                      MainTreeView.Selected := Noddy;
                      MainTreeView.SetFocus;
                   end
                    else
                   begin
                     Noddy := Noddy.GetNext
                   end;
                 end;
               Nodeloc:=MainTreeView.Selected;
               NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,body[j].name);
               NewNode.ImageIndex:=1;  // номер картинки
               NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен
               MainTreeView.Selected:=Nodeloc;
               flagunion[body[j].iunion]:=true;
               bdobavlen[j]:=true;
            end
             else
            begin
                SearchTarget:=myassembles[iscan_ass].name;
                Noddy := MainTreeView.Items[0];
                Searching := true;
                while (Searching) and (Noddy <> nil) do
                begin
                   if Noddy.text = SearchTarget then
                   begin
                      Searching := False;
                      MainTreeView.Selected := Noddy;
                      MainTreeView.SetFocus;
                   end
                 else
                   begin
                     Noddy := Noddy.GetNext
                   end;
                 end;
                 Nodeloc:=MainTreeView.Selected;
                 NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,body[j].name);
                 NewNode.ImageIndex:=1;  // номер картинки
                 NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен
                 MainTreeView.Selected:=Nodeloc;
                 bdobavlen[j]:=true;

                 // Если данный юнион уже был добавлен в дерево то мы
                 // сразу пишем все блоки принадлежащие этому юниону в дерево
                 // не тратя времени на повторный поиск.
                 for idob:=0 to (lb-1) do
                 begin
                    if (not(bdobavlen[idob])) then
                    begin
                       if (body[j].iunion=body[idob].iunion) then
                       begin
                          MainTreeView.Selected := Noddy;
                          Nodeloc:=MainTreeView.Selected;
                          NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,body[idob].name);
                          NewNode.ImageIndex:=1;  // номер картинки
                          NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен
                          MainTreeView.Selected:=Nodeloc;
                          bdobavlen[idob]:=true;
                       end;
                    end;
                 end;
            end;
         end;
      end;
      end;
   end;
   for j:=0 to (ls-1) do
   begin
      // источники тепла
      if (source[j].iunion=0) then
      begin
         MainTreeView.SetFocus;
         MainTreeView.items[0].Selected:=true;  // выделяем кабинет.
         NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,source[j].name);
         NewNode.ImageIndex:=2;  // номер картинки
         NewNode.SelectedIndex:=2; // номер картинки когда элемент выделен
      end
       else
      begin

         for iscan_ass := 0 to lu do
         begin
            // identifier с 1 . iunion для не cabinet с 1.
            if (myassembles[iscan_ass].identifire=source[j].iunion) then
            begin
               break;
            end;
         end;

          if (flagunion[source[j].iunion]=false) then
            begin

               if (myassembles[iscan_ass].iunionparent=-1) then
               begin
                  MainTreeView.SetFocus;
                  MainTreeView.items[0].Selected:=true;  // выделяем кабинет.
                  NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,myassembles[iscan_ass].name);
                  NewNode.ImageIndex:=4;  // номер картинки
                  NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
               end
               else
               begin
                  // у union`а есть родительский union не являющийся кабинетом.
                  im1:=1;
                  SetLength(Qunion_number,im1);
                  Qunion_number[0]:=source[j].iunion;
                  while ((Qunion_number[im1-1]<>0)and (flagunion[Qunion_number[im1-1]]=false)) do
                  begin
                     inc(im1);
                     SetLength(Qunion_number,im1);
                     for i_2 := 0 to lu-1 do
                     begin
                        if (myassembles[i_2].identifire=Qunion_number[im1-2]) then
                        begin
                           break;
                        end;
                     end;
                     Qunion_number[im1-1]:=myassembles[i_2].iunionparent+1;
                  end;
                  // построен список вложенных unionov.
                  // в конце списка либо кабинет либо уже построенный union.
                  // последний значимый элемент im1-2. Всего значимых элементов im1-1.
                  // Теперь надо создать в дереве последовательность вложенных unionov.
                  if (Qunion_number[im1-1]=0) then
                  begin
                     MainTreeView.SetFocus;
                     MainTreeView.items[0].Selected:=true;  // выделяем кабинет.
                     for i_2 := 0 to lu-1 do
                     begin
                        if (myassembles[i_2].identifire=Qunion_number[im1-2]) then
                        begin
                           break;
                        end;
                     end;
                     NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,myassembles[i_2].name);
                     NewNode.ImageIndex:=4;  // номер картинки
                     NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                     for im2:=im1-3 downto 0 do
                     begin
                        for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im2+1]) then
                           begin
                              break;
                           end;
                        end;
                        SearchTarget:=myassembles[i_2].name;
                        Noddy := MainTreeView.Items[0];
                        Searching := true;
                        while (Searching) and (Noddy <> nil) do
                        begin
                           if Noddy.text = SearchTarget then
                           begin
                              // найден
                              Searching := False;
                              MainTreeView.Selected := Noddy;
                              MainTreeView.SetFocus;
                           end
                            else
                           begin
                              Noddy := Noddy.GetNext
                           end;
                        end;
                        Nodeloc:=MainTreeView.Selected;
                        for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im2]) then
                           begin
                              break;
                           end;
                        end;
                        NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,myassembles[i_2].name);
                        NewNode.ImageIndex:=4;  // номер картинки
                        NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                        MainTreeView.Selected:=Nodeloc;
                     end;
                  end
                   else
                  begin
                     for im2:=im1-2 downto 0 do
                     begin
                         for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im2+1]) then
                           begin
                              break;
                           end;
                        end;
                        SearchTarget:=myassembles[i_2].name;
                        Noddy := MainTreeView.Items[0];
                        Searching := true;
                        while (Searching) and (Noddy <> nil) do
                        begin
                           if Noddy.text = SearchTarget then
                           begin
                              // найден
                              Searching := False;
                              MainTreeView.Selected := Noddy;
                              MainTreeView.SetFocus;
                           end
                            else
                           begin
                              Noddy := Noddy.GetNext
                           end;
                        end;
                        Nodeloc:=MainTreeView.Selected;
                          for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im2]) then
                           begin
                              break;
                           end;
                        end;
                        NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,myassembles[i_2].name);
                        NewNode.ImageIndex:=4;  // номер картинки
                        NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                        MainTreeView.Selected:=Nodeloc;
                     end;
                  end;
                  for im2:=0 to im1-2 do
                  begin
                     flagunion[Qunion_number[im2]]:=True;
                  end;
               end;


               SearchTarget:=myassembles[iscan_ass].name;
                Noddy := MainTreeView.Items[0];
                Searching := true;
                while (Searching) and (Noddy <> nil) do
                begin
                   if Noddy.text = SearchTarget then
                   begin
                      Searching := False;
                      MainTreeView.Selected := Noddy;
                      MainTreeView.SetFocus;
                   end
                 else
                   begin
                     Noddy := Noddy.GetNext
                   end;
                 end;
               Nodeloc:=MainTreeView.Selected;
               NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,source[j].name);
               NewNode.ImageIndex:=2;  // номер картинки
               NewNode.SelectedIndex:=2; // номер картинки когда элемент выделен
               MainTreeView.Selected:=Nodeloc;
               flagunion[source[j].iunion]:=true;
            end
             else
            begin
                SearchTarget:=myassembles[iscan_ass].name;
                Noddy := MainTreeView.Items[0];
                Searching := true;
                while (Searching) and (Noddy <> nil) do
                begin
                   if Noddy.text = SearchTarget then
                   begin
                      Searching := False;
                      MainTreeView.Selected := Noddy;
                      MainTreeView.SetFocus;
                   end
                 else
                   begin
                     Noddy := Noddy.GetNext
                   end;
                 end;
                 Nodeloc:=MainTreeView.Selected;
                 NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,source[j].name);
                 NewNode.ImageIndex:=2;  // номер картинки
                 NewNode.SelectedIndex:=2; // номер картинки когда элемент выделен
                 MainTreeView.Selected:=Nodeloc;
            end;
      end;
   end;
   for j:=0 to (lw-1) do
   begin
      // твёрдые стенки

        // ShowMessage('iunion wall='+IntToStr(wall[j].iunion));

      if (wall[j].iunion=0) then
      begin
         MainTreeView.SetFocus;
         MainTreeView.items[0].Selected:=true;  // выделяем кабинет.
         NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,wall[j].name);
         NewNode.ImageIndex:=3;  // номер картинки
         NewNode.SelectedIndex:=3; // номер картинки когда элемент выделен
      end
       else
       begin
          for iscan_ass := 0 to lu do
         begin
            // identifier с 1 . iunion для не cabinet с 1.
            if (myassembles[iscan_ass].identifire=wall[j].iunion) then
            begin
               break;
            end;
         end;


          if (flagunion[wall[j].iunion]=false) then
            begin

          //      ShowMessage('iscan_ass='+IntToStr(iscan_ass)+' '+IntToStr(myassembles[iscan_ass].iunionparent));
               if (myassembles[iscan_ass].iunionparent=-1) then
               begin
                  MainTreeView.SetFocus;
                  MainTreeView.items[0].Selected:=true;  // выделяем кабинет.
                  NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,myassembles[iscan_ass].name);
                  NewNode.ImageIndex:=4;  // номер картинки
                  NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
               end
               else
               begin
                  // у union`а есть родительский union не являющийся кабинетом.
                  im1:=1;
                  SetLength(Qunion_number,im1);
                  Qunion_number[0]:=wall[j].iunion;
                  while ((Qunion_number[im1-1]<>0)and(flagunion[Qunion_number[im1-1]]=false)) do
                  begin
                     inc(im1);
                     SetLength(Qunion_number,im1);
                       for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im1-2]) then
                           begin
                              break;
                           end;
                        end;
                     Qunion_number[im1-1]:=myassembles[i_2].iunionparent+1;
                  end;
                  // построен список вложенных unionov.
                  // в конце списка либо кабинет либо уже построенный union.
                  // последний значимый элемент im1-2. Всего значимых элементов im1-1.
                  // Теперь надо создать в дереве последовательность вложенных unionov.
                  if (Qunion_number[im1-1]=0) then
                  begin
                     MainTreeView.SetFocus;
                     MainTreeView.items[0].Selected:=true;  // выделяем кабинет.
                       for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im1-2]) then
                           begin
                              break;
                           end;
                        end;
                     NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,myassembles[i_2].name);
                     NewNode.ImageIndex:=4;  // номер картинки
                     NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                     for im2:=im1-3 downto 0 do
                     begin
                        for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im2+1]) then
                           begin
                              break;
                           end;
                        end;
                        SearchTarget:=myassembles[i_2].name;
                        Noddy := MainTreeView.Items[0];
                        Searching := true;
                        while (Searching) and (Noddy <> nil) do
                        begin
                           if Noddy.text = SearchTarget then
                           begin
                              // найден
                              Searching := False;
                              MainTreeView.Selected := Noddy;
                              MainTreeView.SetFocus;
                           end
                            else
                           begin
                              Noddy := Noddy.GetNext
                           end;
                        end;
                        Nodeloc:=MainTreeView.Selected;
                         for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im2]) then
                           begin
                              break;
                           end;
                        end;
                        NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,myassembles[i_2].name);
                        NewNode.ImageIndex:=4;  // номер картинки
                        NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                        MainTreeView.Selected:=Nodeloc;
                     end;
                  end
                   else
                  begin
                     for im2:=im1-2 downto 0 do
                     begin
                         for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im2+1]) then
                           begin
                              break;
                           end;
                        end;
                        SearchTarget:=myassembles[i_2].name;
                        Noddy := MainTreeView.Items[0];
                        Searching := true;
                        while (Searching) and (Noddy <> nil) do
                        begin
                           if Noddy.text = SearchTarget then
                           begin
                              // найден
                              Searching := False;
                              MainTreeView.Selected := Noddy;
                              MainTreeView.SetFocus;
                           end
                            else
                           begin
                              Noddy := Noddy.GetNext
                           end;
                        end;
                        Nodeloc:=MainTreeView.Selected;
                        for i_2 := 0 to lu-1 do
                        begin
                           if (myassembles[i_2].identifire=Qunion_number[im2]) then
                           begin
                              break;
                           end;
                        end;
                        NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,myassembles[i_2].name);
                        NewNode.ImageIndex:=4;  // номер картинки
                        NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                        MainTreeView.Selected:=Nodeloc;
                     end;
                  end;
                  for im2:=0 to im1-2 do
                  begin
                     flagunion[Qunion_number[im2]]:=True;
                  end;
               end;




               SearchTarget:=myassembles[iscan_ass].name;
               Noddy := MainTreeView.Items[0];
               Searching := true;
               while (Searching) and (Noddy <> nil) do
               begin
                  if Noddy.text = SearchTarget then
                  begin
                     Searching := False;
                     MainTreeView.Selected := Noddy;
                     MainTreeView.SetFocus;
                  end
                 else
                   begin
                     Noddy := Noddy.GetNext
                   end;
               end;
               Nodeloc:=MainTreeView.Selected;


               NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,wall[j].name);
               NewNode.ImageIndex:=3;  // номер картинки
               NewNode.SelectedIndex:=3; // номер картинки когда элемент выделен
               MainTreeView.Selected:=Nodeloc;
               flagunion[wall[j].iunion]:=true;
            end
             else
            begin
                SearchTarget:=myassembles[iscan_ass].name;
                Noddy := MainTreeView.Items[0];
                Searching := true;
                while (Searching) and (Noddy <> nil) do
                begin
                   if Noddy.text = SearchTarget then
                   begin
                      Searching := False;
                      MainTreeView.Selected := Noddy;
                      MainTreeView.SetFocus;
                   end
                 else
                   begin
                     Noddy := Noddy.GetNext
                   end;
                 end;
                 Nodeloc:=MainTreeView.Selected;
                 NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,wall[j].name);
                 NewNode.ImageIndex:=3;  // номер картинки
                 NewNode.SelectedIndex:=3; // номер картинки когда элемент выделен
                 MainTreeView.Selected:=Nodeloc;
            end;
      end;
   end;

   // добавляем объединения не содержащие элементов.
   for j:=1 to lu do
   begin
       if (flagunion[myassembles[j-1].identifire]=false) then
       begin
          if (myassembles[j-1].iunionparent=-1) then
          begin
             MainTreeView.SetFocus;
             MainTreeView.items[0].Selected:=true;  // выделяем кабинет.
             NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,myassembles[j-1].name);
             NewNode.ImageIndex:=4;  // номер картинки
             NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
             flagunion[myassembles[j-1].identifire]:=True;
          end
          else
          begin


             // у union`а есть родительский union не являющийся кабинетом.
             im1:=1;
             SetLength(Qunion_number,im1);
             Qunion_number[0]:=j;
             while ((Qunion_number[im1-1]<>0)and(flagunion[Qunion_number[im1-1]]=false)) do
             begin
                inc(im1);
                SetLength(Qunion_number,im1);
                 for i_2 := 0 to lu-1 do
                 begin
                    if (myassembles[i_2].identifire=Qunion_number[im1-2]) then
                    begin
                       break;
                    end;
                 end;
                Qunion_number[im1-1]:=myassembles[i_2].iunionparent+1;
             end;
             // построен список вложенных unionov.
             // в конце списка либо кабинет либо уже построенный union.
             // последний значимый элемент im1-2. Всего значимых элементов im1-1.
             // Теперь надо создать в дереве последовательность вложенных unionov.
             if (Qunion_number[im1-1]=0) then
             begin
                MainTreeView.SetFocus;
                MainTreeView.items[0].Selected:=true;  // выделяем кабинет.
                for i_2 := 0 to lu-1 do
                 begin
                    if (myassembles[i_2].identifire=Qunion_number[im1-2]) then
                    begin
                       break;
                    end;
                 end;
                NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,myassembles[i_2].name);
                NewNode.ImageIndex:=4;  // номер картинки
                NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                for im2:=im1-3 downto 0 do
                begin
                   for i_2 := 0 to lu-1 do
                   begin
                    if (myassembles[i_2].identifire=Qunion_number[im2+1]) then
                    begin
                       break;
                    end;
                   end;
                   SearchTarget:=myassembles[i_2].name;
                   Noddy := MainTreeView.Items[0];
                   Searching := true;
                   while (Searching) and (Noddy <> nil) do
                   begin
                      if Noddy.text = SearchTarget then
                      begin
                         // найден
                         Searching := False;
                         MainTreeView.Selected := Noddy;
                         MainTreeView.SetFocus;
                      end
                       else
                      begin
                         Noddy := Noddy.GetNext
                      end;
                   end;
                   Nodeloc:=MainTreeView.Selected;
                   for i_2 := 0 to lu-1 do
                   begin
                      if (myassembles[i_2].identifire=Qunion_number[im2]) then
                      begin
                         break;
                      end;
                   end;
                   NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,myassembles[i_2].name);
                   NewNode.ImageIndex:=4;  // номер картинки
                   NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                   MainTreeView.Selected:=Nodeloc;
                end;
             end
              else
             begin
                for im2:=im1-2 downto 0 do
                begin
                 for i_2 := 0 to lu-1 do
                   begin
                    if (myassembles[i_2].identifire=Qunion_number[im2+1]) then
                    begin
                       break;
                    end;
                   end;
                   SearchTarget:=myassembles[i_2].name;
                   Noddy := MainTreeView.Items[0];
                   Searching := true;
                   while (Searching) and (Noddy <> nil) do
                   begin
                      if Noddy.text = SearchTarget then
                      begin
                         // найден
                         Searching := False;
                         MainTreeView.Selected := Noddy;
                         MainTreeView.SetFocus;
                      end
                       else
                      begin
                         Noddy := Noddy.GetNext
                      end;
                   end;
                   Nodeloc:=MainTreeView.Selected;
                    for i_2 := 0 to lu-1 do
                   begin
                    if (myassembles[i_2].identifire=Qunion_number[im2]) then
                    begin
                       break;
                    end;
                   end;
                   NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,myassembles[i_2].name);
                   NewNode.ImageIndex:=4;  // номер картинки
                   NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                   MainTreeView.Selected:=Nodeloc;
                end;
             end;
             for im2:=0 to im1-2 do
             begin
                flagunion[Qunion_number[im2]]:=True;
             end;
          end;
       end;
   end;

   MainMemo.Lines.Add('Done');
end;



// возвращение в изометрию
procedure TLaplas.SpeedButtonisogeomClick(Sender: TObject);
begin
   // изометия.
   Alf:=-0.96;
   Bet:=0.51;
   Gam:=2.68;
   cosAlf:=cos(Alf);
   cosBet:=cos(Bet);
   sinAlf:=sin(Alf);
   sinBet:=sin(Bet);
end;

// уменьшение изображения в окошке
procedure TLaplas.FormMouseWheelDown(Sender: TObject; Shift: TShiftState;
  MousePos: TPoint; var Handled: Boolean);
begin
    (*
    chkzbuffer.Checked:=False;
    // колёсико движется вниз
    if (m>11) then
    begin
        m:=m-10; // ZOOM
    end
    else
    begin
       if (m>0.11) then
       begin
          m:=m-0.1;
       end
       else
       begin
          if (m>0.011) then
          begin
             m:=m-0.01;
          end
           else
          begin
             m:=m-0.001;
          end;
       end;
    end;

   // MainPaintBoxPaint(Sender);
   *)
   // Мы уменьшаем perspectiveangle и не можем опуститься ниже -180 градусов.

   (*if (perspectiveangle>-178.0) then
   begin
       if (perspectiveangle>-170.0) then
       begin
          perspectiveangle:=perspectiveangle-1.0;
       end
       else
       begin
          perspectiveangle:=perspectiveangle-0.1;
       end;
   end;
   *)if ((MousePos.X>pnlPaint.Left)and(MousePos.X<pnlPaint.Left+pnlPaint.Width)
   and (MousePos.Y>pnlPaint.Top)and(MousePos.Y<pnlPaint.Top+pnlPaint.Height)) then
   begin
      //MainMemo.Lines.Add(IntToStr(MousePos.X)+' '+IntToStr(MousePos.Y));

      perspectiveangle_counter:=perspectiveangle_counter-4.0; // 1.0  2.0

      //perspectiveangle:=90.0+90.0*arctan(0.08*perspectiveangle_counter)/1.5705;
      perspectiveangle:=return_Perspective_angle(perspectiveangle_counter);
   end;
end;

// увеличение изображения в окошке
procedure TLaplas.FormMouseWheelUp(Sender: TObject; Shift: TShiftState;
  MousePos: TPoint; var Handled: Boolean);
begin
   (*
    chkzbuffer.Checked:=False;
   // колёсико движется вверх
    if (m>11) then
    begin
        m:=m+10; // ZOOM
    end
    else
    begin
       if (m>0.11) then
       begin
          m:=m+0.1;
       end
       else
       begin
          if (m>0.011) then
          begin
             m:=m+0.01; // ZOOM
          end
           else
          begin
             m:=m+0.001;
          end;
       end;
    end;
    //MainPaintBoxPaint(Sender);
    *)
   (*
   if (perspectiveangle<178.0) then
   begin
      if (perspectiveangle<170.0) then
       begin
          perspectiveangle:=perspectiveangle+1.0;
       end
       else
       begin
          perspectiveangle:=perspectiveangle+0.1;
       end;
   end;
   *)
   if ((MousePos.X>pnlPaint.Left)and(MousePos.X<pnlPaint.Left+pnlPaint.Width)
       and (MousePos.Y>pnlPaint.Top)and(MousePos.Y<pnlPaint.Top+pnlPaint.Height)) then
       begin
          //MainMemo.Lines.Add(IntToStr(MousePos.X)+' '+IntToStr(MousePos.Y));

          // 3 февраля 2017
          perspectiveangle_counter:=perspectiveangle_counter+4.0; // 1.0 2.0


         //perspectiveangle:=90.0+90.0*arctan(0.08*perspectiveangle_counter)/1.5705;
         perspectiveangle:=return_Perspective_angle(perspectiveangle_counter);
   end;
end;

// изменение размеров формы
// которое приводит к изменению и друнгих размеров:
procedure TLaplas.FormResize(Sender: TObject);
var
   tmpBool : Boolean;
begin
   // изменение размеров главной панели
   MainPanel.Width:=Width-26;
   MainPanel.Height:=Height-71;
   // изменение положения MainMemo
   MainMemo.Top:=Height-200;
   GroupBoxLight.Top:=MainMemo.Top;
   grpmaterial_litht_prop.Top:=MainMemo.Top;
   grplitht1.Top:=MainMemo.Top;
   pnliso.Top:=Height-200;
   // изменение размеров pnlPaint
   pnlPaint.Width:=Width-266;
   pnlPaint.Height:=Height-223;
   Panel_shkala.Left:=pnlPaint.Left+pnlPaint.Width-420;
   Panel_shkala.Top:=pnlPaint.Top-30;
   MainTreeView.Height:=Height-207;
   Panelorient.Top:=10+MainTreeView.Top+MainTreeView.Height;

   // OpenGL
   glViewport(0,0,pnlPaint.Width,pnlPaint.Height);
   glMatrixMode(GL_PROJECTION); //переходим в матрицу проекции
   glLoadIdentity;  //Сбрасываем текущую матрицу
   gluPerspective(perspectiveangle,pnlPaint.Width/pnlPaint.Height,NearClipping,FarClipping);
   glMatrixMode(GL_MODELVIEW); // переходим в модельную матрицу
   glLoadIdentity; //Сбрасываем текущую матрицу
   // Устарело.
   //gluLookAt(Oxc+R1*cos(Bet)*cos(Alf),Oyc+R1*cos(Bet)*sin(Alf),Ozc-Hscale*(body[0].zE-body[0].zS)+R1*sin(Bet),Oxc,Oyc, Ozc-5.0*(body[0].zE-body[0].zS),0.0,0.0,1.0);
   // откуда, куда, нормаль
   gluLookAt(Oxc,Oyc,Ozc,  Oxc,Oyc, Ozc-Hscale*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS)),0.0,0.05,0.95);
   IdleHandler(Sender,tmpBool);
end;

// создание новой стенки
procedure TLaplas.SBwallClick(Sender: TObject);
var
   hx,hy : real;
   NewNode : TTreeNode;
   bfound : Boolean;
   i : Integer;
   sname : String;

begin
   // создаёт элемент стенку
   inc(lw); itek:=lw-1;
   SetLength(wall,lw); // выделение памяти под дополниткельную стенку
   inc(icw);

   // Часто стенки задаются чтобы задать граничные условия
   // на стенках кабинета, в связи с чем пользователь тратит уйму времени на
   // задание пложения стенок в пространстве : нужно слазить в кабинет посмотреть его размеры,
   // и так для каждой координаты, поэтому следующая программная вставка упрощает эту задачу.
    Formwallgeometryposition_init.RadioGroupwallinitpos.ItemIndex:=0;   // по умолчанию задаём размеры стенки вручную.
    case (body[0].itype) of
       2 : begin
              // HOLLOW
              Formwallgeometryposition_init.RadioGroupwallinitpos.ItemIndex:=0;
           end;
       3 : begin
              // FLUID
              if ((cab_bound_condition.bminX=true)and(cab_bound_condition.bmaxX=true)and
              (cab_bound_condition.bminY=true)and(cab_bound_condition.bmaxY=true)and
              (cab_bound_condition.bminZ=true)and(cab_bound_condition.bmaxZ=true)) then
              begin
                 Formwallgeometryposition_init.RadioGroupwallinitpos.ItemIndex:=0;
              end
              else
              begin
                 // Еще есть возможность привязаться к границам кабинета.
                 if (cab_bound_condition.bminX=true) then
                 begin
                    Formwallgeometryposition_init.RadioGroupwallinitpos.Items[1]:='already defined';
                 end
                 else
                 begin
                    Formwallgeometryposition_init.RadioGroupwallinitpos.Items[1]:='cabinet min X';
                 end;
                  if (cab_bound_condition.bmaxX=true) then
                 begin
                    Formwallgeometryposition_init.RadioGroupwallinitpos.Items[2]:='already defined';
                 end
                 else
                 begin
                    Formwallgeometryposition_init.RadioGroupwallinitpos.Items[2]:='cabinet max X';
                 end;
                  if (cab_bound_condition.bminY=true) then
                 begin
                    Formwallgeometryposition_init.RadioGroupwallinitpos.Items[3]:='already defined';
                 end
                 else
                 begin
                    Formwallgeometryposition_init.RadioGroupwallinitpos.Items[3]:='cabinet min Y';
                 end;
                  if (cab_bound_condition.bmaxY=true) then
                 begin
                    Formwallgeometryposition_init.RadioGroupwallinitpos.Items[4]:='already defined';
                 end
                 else
                 begin
                    Formwallgeometryposition_init.RadioGroupwallinitpos.Items[4]:='cabinet max Y';
                 end;
                  if (cab_bound_condition.bminZ=true) then
                 begin
                    Formwallgeometryposition_init.RadioGroupwallinitpos.Items[5]:='already defined';
                 end
                 else
                 begin
                    Formwallgeometryposition_init.RadioGroupwallinitpos.Items[5]:='cabinet min Z';
                 end;
                  if (cab_bound_condition.bmaxZ=true) then
                 begin
                    Formwallgeometryposition_init.RadioGroupwallinitpos.Items[6]:='already defined';
                 end
                 else
                 begin
                    Formwallgeometryposition_init.RadioGroupwallinitpos.Items[6]:='cabinet max Z';
                 end;


                 Formwallgeometryposition_init.ShowModal;
              end;
           end;
    end;


    if (Formwallgeometryposition_init.RadioGroupwallinitpos.ItemIndex=0) then
    begin
        wall[itek].name:='wall'+IntToStr(icw); // задаёт уникальное имя объекта
        // Настройки по умолчанию. default.
        hx:=abs(body[0].xE-body[0].xS)/5.0;
        hy:=abs(body[0].yE-body[0].yS)/5.0;
        wall[itek].iPlane:=1;//XY
        wall[itek].xS:=body[0].xS+2*hx;  wall[itek].xE:=body[0].xE-2*hx; // числовые значения
        wall[itek].yS:=body[0].yS+2*hy;  wall[itek].yE:=body[0].yE-2*hy; // геометрических размеров
        wall[itek].zS:=0.5*(body[0].zS+body[0].zE);  wall[itek].zE:=0.5*(body[0].zS+body[0].zE);
        wall[itek].sxS:=FloatToStr(body[0].xS+2*hx);  wall[itek].sxE:=FloatToStr(body[0].xE-2*hx); // параметризованные значения
        wall[itek].syS:=FloatToStr(body[0].yS+2*hy);  wall[itek].syE:=FloatToStr(body[0].yE-2*hy); // геометрических размеров
        wall[itek].szS:=FloatToStr(0.5*(body[0].zS+body[0].zE));  wall[itek].szE:=FloatToStr(0.5*(body[0].zS+body[0].zE));
        wall[itek].cabinet_depend:=0;
        AddWallForm.GroupBoxSize.Visible:=true;
        AddWallForm.RadioGroupPlane.Visible:=true;
    end
    else
    begin
        AddWallForm.GroupBoxSize.Visible:=false;
        AddWallForm.RadioGroupPlane.Visible:=false;
        AddWallForm.ComboBoxDeformationBoundaryConditon.ItemIndex:=0;

       case Formwallgeometryposition_init.RadioGroupwallinitpos.ItemIndex of
         1 : begin
                // minX
                 wall[itek].name:='cabinet_minX';
                 wall[itek].iPlane:=3;//XY
                 wall[itek].xS:=body[0].xS;  wall[itek].xE:=body[0].xS; // числовые значения
                 wall[itek].yS:=body[0].yS;  wall[itek].yE:=body[0].yE; // геометрических размеров
                 wall[itek].zS:=body[0].zS;  wall[itek].zE:=body[0].zE;
                 wall[itek].sxS:=body[0].sxS;  wall[itek].sxE:=body[0].sxS; // параметризованные значения
                 wall[itek].syS:=body[0].syS;  wall[itek].syE:=body[0].syE; // геометрических размеров
                 wall[itek].szS:=body[0].szS;  wall[itek].szE:=body[0].szE;
                 wall[itek].cabinet_depend:=1;

         end;
         2 : begin
                // maxX
                wall[itek].name:='cabinet_maxX';
                wall[itek].iPlane:=3;//XY
                wall[itek].xS:=body[0].xE;  wall[itek].xE:=body[0].xE; // числовые значения
                wall[itek].yS:=body[0].yS;  wall[itek].yE:=body[0].yE; // геометрических размеров
                wall[itek].zS:=body[0].zS;  wall[itek].zE:=body[0].zE;
                wall[itek].sxS:=body[0].sxE;  wall[itek].sxE:=body[0].sxE; // параметризованные значения
                wall[itek].syS:=body[0].syS;  wall[itek].syE:=body[0].syE; // геометрических размеров
                wall[itek].szS:=body[0].szS;  wall[itek].szE:=body[0].szE;
                wall[itek].cabinet_depend:=2;

            end;
         3 : begin
                // minY
                 wall[itek].name:='cabinet_minY';
                 wall[itek].iPlane:=2;//XZ
                 wall[itek].xS:=body[0].xS;  wall[itek].xE:=body[0].xE; // числовые значения
                 wall[itek].yS:=body[0].yS;  wall[itek].yE:=body[0].yS; // геометрических размеров
                 wall[itek].zS:=body[0].zS;  wall[itek].zE:=body[0].zE;
                 wall[itek].sxS:=body[0].sxS;  wall[itek].sxE:=body[0].sxE; // параметризованные значения
                 wall[itek].syS:=body[0].syS;  wall[itek].syE:=body[0].syS; // геометрических размеров
                 wall[itek].szS:=body[0].szS;  wall[itek].szE:=body[0].szE;
                 wall[itek].cabinet_depend:=3;

         end;
         4 : begin
                // maxY
                 wall[itek].name:='cabinet_maxY';
                 wall[itek].iPlane:=2;//XZ
                 wall[itek].xS:=body[0].xS;  wall[itek].xE:=body[0].xE; // числовые значения
                 wall[itek].yS:=body[0].yE;  wall[itek].yE:=body[0].yE; // геометрических размеров
                 wall[itek].zS:=body[0].zS;  wall[itek].zE:=body[0].zE;
                 wall[itek].sxS:=body[0].sxS;  wall[itek].sxE:=body[0].sxE; // параметризованные значения
                 wall[itek].syS:=body[0].syE;  wall[itek].syE:=body[0].syE; // геометрических размеров
                 wall[itek].szS:=body[0].szS;  wall[itek].szE:=body[0].szE;
                 wall[itek].cabinet_depend:=4;

         end;
         5 : begin
                // minZ
                wall[itek].name:='cabinet_minZ';
                wall[itek].iPlane:=1;//XY
                wall[itek].xS:=body[0].xS;  wall[itek].xE:=body[0].xE; // числовые значения
                wall[itek].yS:=body[0].yS;  wall[itek].yE:=body[0].yE; // геометрических размеров
                wall[itek].zS:=body[0].zS;  wall[itek].zE:=body[0].zS;
                wall[itek].sxS:=body[0].sxS;  wall[itek].sxE:=body[0].sxE; // параметризованные значения
                wall[itek].syS:=body[0].syS;  wall[itek].syE:=body[0].syE; // геометрических размеров
                wall[itek].szS:=body[0].szS;  wall[itek].szE:=body[0].szS;
                wall[itek].cabinet_depend:=5;

         end;
         6 : begin
                // maxZ
                wall[itek].name:='cabinet_maxZ';
                wall[itek].iPlane:=1;//XY
                wall[itek].xS:=body[0].xS;  wall[itek].xE:=body[0].xE; // числовые значения
                wall[itek].yS:=body[0].yS;  wall[itek].yE:=body[0].yE; // геометрических размеров
                wall[itek].zS:=body[0].zE;  wall[itek].zE:=body[0].zE;
                wall[itek].sxS:=body[0].sxS;  wall[itek].sxE:=body[0].sxE; // параметризованные значения
                wall[itek].syS:=body[0].syS;  wall[itek].syE:=body[0].syE; // геометрических размеров
                wall[itek].szS:=body[0].szE;  wall[itek].szE:=body[0].szE;
                wall[itek].cabinet_depend:=6;

         end;
       end;
    end;

   // Thermal Stress - boundary condition.
   wall[itek].ithermal_stress_boundary_condition:=0;
   wall[itek].xForce:=0.0;
   wall[itek].yForce:=0.0;
   wall[itek].zForce:=0.0;
   wall[itek].family:=1; // род краевого условия
   wall[itek].Tamb:=20.0; // градусов цельсия
   wall[itek].emissivity:=0.0; // излучательная способность.
   wall[itek].ViewFactor:=1.0; // Фактор видимости.
   wall[itek].heat_transfer_coefficient:=0.0; // коэффициент теплоотдачи.
   if (FormatSettings.DecimalSeparator='.') then
   begin
      wall[itek].semissivity:='0.0'; // излучательная способность.
      wall[itek].sheat_transfer_coefficient:='0.0'; // коэффициент теплоотдачи.
   end;
   if (FormatSettings.DecimalSeparator=',') then
   begin
      wall[itek].semissivity:='0,0'; // излучательная способность.
      wall[itek].sheat_transfer_coefficient:='0,0'; // коэффициент теплоотдачи.
   end;
   wall[itek].HF:=0.0;
   wall[itek].Power:=0.0; // не источник тепла
    if (FormatSettings.DecimalSeparator='.') then
   begin
      wall[itek].spower:='0.0'; // не источник тепла
   end;
    if (FormatSettings.DecimalSeparator=',') then
   begin
      wall[itek].spower:='0,0'; // не источник тепла
   end;
   // в гидродинамическом плане твёрдая стенка
   wall[itek].Vx:=0.0;
   wall[itek].Vy:=0.0;
   wall[itek].Vz:=0.0;
   wall[itek].P:=0.0;
   wall[itek].bpressure:=false;
   wall[itek].bsymmetry:=false;
   wall[itek].bopening:=false;
   wall[itek].iunion:=0;
   wall[itek].bvisible:=true;

   if (MainTreeView.Selected=nil) then
   begin
      MainTreeView.Select(MainTreeView.Items[0]);
   end
    else
   begin
       sname:=MainTreeView.Selected.Text; // имя выделенного элемента.
       bfound:=false;
       for i:=0 to lb-1 do
       begin
          if ((length(body[i].name)=length(sname)) and (Pos(body[i].name,sname)=1)) then
          begin
             bfound:=true;
             wall[itek].iunion:=body[i].iunion;
             break;
          end;
       end;
       if (not(bfound)) then
       begin
          for i:=0 to ls-1 do
          begin
             if ((length(source[i].name)=length(sname)) and (Pos(source[i].name,sname)=1)) then
             begin
                bfound:=true;
                wall[itek].iunion:=source[i].iunion;
                break;
             end;
          end;
       end;
       if (not(bfound)) then
       begin
          for i:=0 to lw-2 do
          begin
             if ((length(wall[i].name)=length(sname)) and (Pos(wall[i].name,sname)=1)) then
             begin
                bfound:=true;
                wall[itek].iunion:=wall[i].iunion;
                break;
             end;
          end;
       end;
       // Если bfound=false то выделен асемблес а значит iunion по умолчанию 0.
   end;

   NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,wall[itek].name);
   NewNode.ImageIndex:=3; // загружает картинку твёрдой стенки
   NewNode.SelectedIndex:=3; // номер картинки когда элемент выделен
   ReadyPaint;
   Initializeaddwallform; // инициализирует форму перед запуском
   if (bREALESEversion) then
   begin
      // МАНИФЕСТ СТАБИЛЬНОСТИ
      // ДЛЯ ПОЛЬЗОВАТЕЛЯ 04.08.2019

      // Мы полностью отключаем все
      // недоработанные функциональные
      // возможности из интерфейса программы.
      // Убираем задание механических граничных условий на стенке.
      AddWallForm.GroupBoxThermalStress.Visible:=true;
   end;
   AddWallForm.ShowModal;
   MainTreeView.Items[MainTreeView.Items.Count-1].Text:=wall[itek].name;
   CorrectHollowCabinet;
   ReadyPaint;
   Render;
end;

// Преобразование геометрии
procedure TLaplas.Scale1Click(Sender: TObject);
var
   scale_loc : Real; // Масштабирующий множитель.
   i, i_4 : Integer;
   stext : String;
   bOk : Boolean;
begin
    scale_loc:=1.0;

    FormScale.ShowModal;
    scale_loc:=FormScale.scale674;

     // блоки :
   for i:=0 to (Laplas.lb-1) do
   begin
      // цикл по всем блокам в расчётной области.

      bOk:=true;
      stext:= Laplas.body[i].sxS;
      body[i].sxS:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      body[i].xS:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.body[i].syS;
      body[i].syS:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      body[i].yS:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.body[i].sxE;
      body[i].sxE:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      body[i].xE:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.body[i].syE;
      body[i].syE:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      body[i].yE:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.body[i].szS;
      body[i].szS:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      body[i].zS:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.body[i].szE;
      body[i].szE:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      body[i].zE:=scale_loc*FormVariables.my_real_convert(stext, bOk);

      bOk:=true;
      stext:=Laplas.body[i].sxC;
      body[i].sxC:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      body[i].xC:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:=Laplas.body[i].syC;
      body[i].syC:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      body[i].yC:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:=Laplas.body[i].szC;
      body[i].szC:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      body[i].zC:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:=Laplas.body[i].sHcyl;
      body[i].sHcyl:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      body[i].Hcyl:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:=Laplas.body[i].sR_out_cyl;
      body[i].sR_out_cyl:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      body[i].R_out_cyl:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:=Laplas.body[i].sR_in_cyl;
      body[i].sR_in_cyl:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      body[i].R_in_cyl:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;

     for i_4 := 0 to body[i].nsizei-1 do
     begin
        Laplas.body[i].xi[i_4]:= scale_loc*Laplas.body[i].xi[i_4];
        Laplas.body[i].yi[i_4]:= scale_loc*Laplas.body[i].yi[i_4];
        Laplas.body[i].zi[i_4]:= scale_loc*Laplas.body[i].zi[i_4];
        Laplas.body[i].hi[i_4]:= scale_loc*Laplas.body[i].hi[i_4];
     end;

   end;

   // источники тепла
   for i:=0 to (Laplas.ls-1) do
   begin
      // цикл по всем источникам тепла в расчётной области.

      // координаты плоского бесконечно тонкого источника тепла.
      bOk:=true;
      stext:= Laplas.source[i].sxS;
      source[i].sxS:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      source[i].xS:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.source[i].syS;
      source[i].syS:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      source[i].yS:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.source[i].szS;
      source[i].szS:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      source[i].zS:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.source[i].sxE;
      source[i].sxE:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      source[i].xE:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.source[i].syE;
      source[i].syE:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      source[i].yE:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.source[i].szE;
      source[i].szE:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      source[i].zE:=scale_loc*FormVariables.my_real_convert(stext, bOk);
   end;

   // твёрдые стенки
   for i:=0 to (Laplas.lw-1) do
   begin
      // цикл по всем источникам тепла в расчётной области.

      // координаты стенки
      bOk:=true;
      stext:= Laplas.wall[i].sxS;
      wall[i].sxS:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      wall[i].xS:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.wall[i].syS;
      wall[i].syS:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      wall[i].yS:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.wall[i].szS;
      wall[i].szS:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      wall[i].zS:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.wall[i].sxE;
      wall[i].sxE:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      wall[i].xE:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.wall[i].syE;
      wall[i].syE:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      wall[i].yE:=scale_loc*FormVariables.my_real_convert(stext, bOk);
      bOk:=true;
      stext:= Laplas.wall[i].szE;
      wall[i].szE:=FloatToStr(scale_loc*FormVariables.my_real_convert(stext, bOk));
      wall[i].zE:=scale_loc*FormVariables.my_real_convert(stext, bOk);

   end;
end;

// автомасштабирование.
procedure TLaplas.Scaletofit1Click(Sender: TObject);
begin
   BitBtnScale_to_fitClick(Sender);
end;

procedure TLaplas.ScrollBar1Scroll(Sender: TObject; ScrollCode: TScrollCode;
  var ScrollPos: Integer);
  var
   c : Real;
begin
  c:=  0.01*ScrollBar1.Position;
   case cbbview.ItemIndex of
     1 : begin
            // XY
            edtvalue.Text:=FloatToStr(body[0].zS+c*(body[0].zE-body[0].zS));
         end;
     2 : begin
            // XZ
            edtvalue.Text:=FloatToStr(body[0].yS+c*(body[0].yE-body[0].yS));
         end;
     3 : begin
            // YZ
            edtvalue.Text:=FloatToStr(body[0].xS+c*(body[0].xE-body[0].xS));
        end;
   end;
   // прорисовка после внесения изменеий.
   ReadyPaint;
   Render; // прорисовка геометрии
end;

// Если кабинет имеет тип Hollow то его геометрические размеры естественым
// образом
// корректируются, чтобы соответствовать текущему размеру модели.
procedure TLaplas.CorrectHollowCabinet;
var
    bmodelcheck_cab_hollow : Boolean;
    cab_geom, cab_geom2 : Visible_Line;
    i77 : Integer;
begin
   if (body[0].itype=2) then
    begin
   // HOLLOW BLOCK
                    bmodelcheck_cab_hollow:=true;

                    cab_geom.xS:=1.0e20;
                    cab_geom.xE:=-1.0e20;
                    cab_geom.yS:=1.0e20;
                    cab_geom.yE:=-1.0e20;
                    cab_geom.zS:=1.0e20;
                    cab_geom.zE:=-1.0e20;

                    for i77:=1 to (Laplas.lb-1) do
                    begin
                       with (Laplas.body[i77]) do
                       begin
                          if (xS<cab_geom.xS) then
                          begin
                             cab_geom.xS:=xS;
                          end;
                          if (yS<cab_geom.yS) then
                          begin
                             cab_geom.yS:=yS;
                          end;
                          if (zS<cab_geom.zS) then
                          begin
                             cab_geom.zS:=zS;
                          end;
                          if (xE>cab_geom.xE) then
                          begin
                             cab_geom.xE:=xE;
                          end;
                          if (yE>cab_geom.yE) then
                          begin
                             cab_geom.yE:=yE;
                          end;
                          if (zE>cab_geom.zE) then
                          begin
                             cab_geom.zE:=zE;
                          end;
                       end;
                    end;

                    cab_geom2.xS:=1.0e20;
                    cab_geom2.xE:=-1.0e20;
                    cab_geom2.yS:=1.0e20;
                    cab_geom2.yE:=-1.0e20;
                    cab_geom2.zS:=1.0e20;
                    cab_geom2.zE:=-1.0e20;
                    for i77:=0 to (Laplas.ls-1) do
                    begin
                       with (Laplas.source[i77]) do
                       begin
                          if (xS<cab_geom2.xS) then
                          begin
                             cab_geom2.xS:=xS;
                             Laplas.MainMemo.Lines.Add('error:'+Laplas.source[i77].name+' xS position is incorrect.');
                          end;
                          if (yS<cab_geom2.yS) then
                          begin
                             cab_geom2.yS:=yS;
                             Laplas.MainMemo.Lines.Add('error:'+Laplas.source[i77].name+' yS position is incorrect.');
                          end;
                          if (zS<cab_geom2.zS) then
                          begin
                             cab_geom2.zS:=zS;
                             Laplas.MainMemo.Lines.Add('error:'+Laplas.source[i77].name+' zS position is incorrect.');
                          end;
                          if (xE>cab_geom2.xE) then
                          begin
                             cab_geom2.xE:=xE;
                             Laplas.MainMemo.Lines.Add('error:'+Laplas.source[i77].name+' xE position is incorrect.');
                          end;
                          if (yE>cab_geom2.yE) then
                          begin
                             cab_geom2.yE:=yE;
                             Laplas.MainMemo.Lines.Add('error:'+Laplas.source[i77].name+' yE position is incorrect.');
                          end;
                          if (zE>cab_geom2.zE) then
                          begin
                             cab_geom2.zE:=zE;
                             Laplas.MainMemo.Lines.Add('error:'+Laplas.source[i77].name+' zE position is incorrect.');
                          end;
                       end;
                     end;
                     for i77:=0 to (Laplas.lw-1) do
                     begin
                        with (Laplas.wall[i77]) do
                        begin
                           if (cabinet_depend=0) then
                           begin
                              if (xS<cab_geom2.xS) then
                              begin
                                 cab_geom2.xS:=xS;
                                 Laplas.MainMemo.Lines.Add('error:'+Laplas.wall[i77].name+' xS position is incorrect.');
                              end;
                              if (yS<cab_geom2.yS) then
                              begin
                                 cab_geom2.yS:=yS;
                                 Laplas.MainMemo.Lines.Add('error:'+Laplas.wall[i77].name+' yS position is incorrect.');
                              end;
                              if (zS<cab_geom2.zS) then
                              begin
                                 cab_geom2.zS:=zS;
                                 Laplas.MainMemo.Lines.Add('error:'+Laplas.wall[i77].name+' zS position is incorrect.');
                              end;
                              if (xE>cab_geom2.xE) then
                              begin
                                 cab_geom2.xE:=xE;
                                 Laplas.MainMemo.Lines.Add('error:'+Laplas.wall[i77].name+' xE position is incorrect.');
                              end;
                              if (yE>cab_geom2.yE) then
                              begin
                                 cab_geom2.yE:=yE;
                                 Laplas.MainMemo.Lines.Add('error:'+Laplas.wall[i77].name+' yE position is incorrect.');
                              end;
                              if (zE>cab_geom2.zE) then
                              begin
                                 cab_geom2.zE:=zE;
                                 Laplas.MainMemo.Lines.Add('error:'+Laplas.wall[i77].name+' zE position is incorrect.');
                              end;
                           end;
                        end;
                     end;

                     if (cab_geom2.xS<cab_geom.xS) then
                     begin
                        bmodelcheck_cab_hollow:=false;
                     end;
                     if (cab_geom2.yS<cab_geom.yS) then
                     begin
                         bmodelcheck_cab_hollow:=false;
                     end;
                     if (cab_geom2.zS<cab_geom.zS) then
                     begin
                        bmodelcheck_cab_hollow:=false;
                     end;
                     if (cab_geom2.xE>cab_geom.xE) then
                     begin
                        bmodelcheck_cab_hollow:=false;
                     end;
                     if (cab_geom2.yE>cab_geom.yE) then
                     begin
                        bmodelcheck_cab_hollow:=false;
                     end;
                     if (cab_geom2.zE>cab_geom.zE) then
                     begin
                        bmodelcheck_cab_hollow:=false;
                     end;
                     if (not(bmodelcheck_cab_hollow)) then
                     begin
                        ShowMessage('Error. Your geometry model is incorrect. Dont Start Solver.');
                        Laplas.MainMemo.Lines.Add('Error. Your geometry model is incorrect. Dont Start Solver.');
                     end;
                     Laplas.body[0].xS:=cab_geom.xS;  Laplas.body[0].xE:=cab_geom.xE;  // отображение параметризованной пользователем
                     Laplas.body[0].yS:=cab_geom.yS;  Laplas.body[0].yE:=cab_geom.yE;  // геометрии
                     Laplas.body[0].zS:=cab_geom.zS;  Laplas.body[0].zE:=cab_geom.zE;  // в реальные числа
                     Laplas.body[0].sxS:=FloatToStr(cab_geom.xS);  Laplas.body[0].sxE:=FloatToStr(cab_geom.xE);  // отображение параметризованной пользователем
                     Laplas.body[0].syS:=FloatToStr(cab_geom.yS);  Laplas.body[0].syE:=FloatToStr(cab_geom.yE);  // геометрии
                     Laplas.body[0].szS:=FloatToStr(cab_geom.zS);  Laplas.body[0].szE:=FloatToStr(cab_geom.zE);  // в реальные числа



    end;

end;


// двойной щелчек по дереву элементов
procedure TLaplas.MainTreeViewDblClick(Sender: TObject);
const
    epsilon = 1e-20;
var
   s : string; // имя редактируемого элемента
   i, i_4, i_5, i_6, j : Integer;
   xavg, yavg, zavg : Real;
   ch : Char; // тип выделенного элемента : c - кабинет, b - блок, s - источник, w - стенка, u - объединение.
   bcontinue : Boolean; // нужно ли продолжать поиск
   // Переформирование дерева блоков для наглядного учета правильности их приоритетов.
   isort, jsort : Integer;
   //body_change : TBody;
   massa : Real;
   rdensity : Real; // плотность материала из которого состоит блок.
   ipriority_old : Integer;
   scur_name2,  scur_name3 : String;
   curNodeTree, NewNode : TTreeNode;

procedure FixHeap(root : Integer; m : TBody; bound : Integer; iadd : Integer);
var
   vacant, largerChild : Integer;
   lCadd, lCadd1 : Integer;
begin
   vacant:=root;
   while (2*vacant<=bound) do
   begin
      largerChild:=2*vacant;
      lCadd:=largerChild+iadd;
      lCadd1:=lCadd+1;
      if ((largerChild<bound)and(body[lCadd1].priority>body[lCadd].priority)) then
      begin
         inc(largerChild);
      end;
      lCadd:=largerChild+iadd;
      if (m.priority>body[lCadd].priority) then
      begin
        break;
      end
      else
      begin
         body[vacant+iadd]:=body[lCadd];
         vacant:=largerChild;
      end;
   end;
   body[vacant+iadd]:=m;
end;

// Пирамидальная сортировка.
procedure HeapSort(first,last : Integer);
var
   body_buf : TBody;
   i9 : Integer;
begin
   for i9 := ((last-first+1) div 2) downto 1 do
   begin
      FixHeap(i9,body[i9+first-1],last-first+1,first-1);
   end;
   for i9 := last-first+1 downto 2 do
     begin
       body_buf:=body[first];
       FixHeap(1,body[i9+first-1],i9-1,first-1);
       body[i9+first-1]:=body_buf;
     end;
end;



begin
   // двойной клик по дереву
   s:=MainTreeView.Selected.Text;
   // символ ch может принимать значения : c, b, s, w, u, e-exit
   ch:='e';
   bcontinue:=true;
   // по всем блокам
   for i:=0 to (lb-1) do
   begin
      if (bcontinue and (length(body[i].name) = length(s)) and (Pos(body[i].name,s)=1)) then
      begin
         // найден блок :
         bcontinue:=false;
         itek:=i;
         if (i=0) then
         begin
            ch:='c';
         end
          else
         begin
            ch:='b';
         end;
      end;
   end;
   if (ch='e') then
   begin
      // по всем источникам
      for i:=0 to (ls-1) do
      begin
         if (bcontinue and (length(source[i].name) = length(s)) and (Pos(source[i].name,s)=1)) then
         begin
            // найден источник
            bcontinue:=false;
            ch:='s';
            itek:=i;
         end;
      end;
   end;
   if (ch='e') then
   begin
       // по всем твёрдым стенкам
       for i:=0 to (lw-1) do
       begin
          if (bcontinue and (length(wall[i].name) = length(s)) and (Pos(wall[i].name,s)=1)) then
          begin
             // найдена твёрдая стенка.
             bcontinue:=false;
             itek:=i;
             ch:='w';
          end;
       end;
   end;
   if (ch='e') then
   begin
      // по всем объединениям
      for i:=0 to (lu-1) do
      begin
         if (bcontinue and (length(myassembles[i].name) = length(s)) and (Pos(myassembles[i].name,s)=1)) then
         begin
            bcontinue:=false;
            ch:='u'; // двойной щелчек по объединению
            itek:=myassembles[i].identifire; // идентификатор объединения
            // внимание : обязательно должна быть справедлива связь itek=identifire=i+1;
            // т.е. номер объединения в списке должен быть на единицу меньше его идентификатора.
         end;
      end;
   end;

   case ch of
   'c' : // cabinet
          begin
             // вызов редактирования свойств кабинета
             CabinetForm.ExS.Text:=body[0].sxS;   // параметризованные
             CabinetForm.EyS.Text:=body[0].syS;   // пользователем
             CabinetForm.EzS.Text:=body[0].szS;   // геометрические
             CabinetForm.ExE.Text:=body[0].sxE;   // размеры.
             CabinetForm.EyE.Text:=body[0].syE;
             CabinetForm.EzE.Text:=body[0].szE;

             if (ComboBoxlength.ItemIndex=1) then
             begin
                 CabinetForm.Labelunit1.Caption:='mm';
                 CabinetForm.Labelunit2.Caption:='mm';
                 CabinetForm.Labelunit3.Caption:='mm';
                 CabinetForm.Labelunit4.Caption:='mm';
                 CabinetForm.Labelunit5.Caption:='mm';
                 CabinetForm.Labelunit6.Caption:='mm';
             end;
             if (ComboBoxlength.ItemIndex=0) then
             begin
                CabinetForm.Labelunit1.Caption:='m';
                CabinetForm.Labelunit2.Caption:='m';
                CabinetForm.Labelunit3.Caption:='m';
                CabinetForm.Labelunit4.Caption:='m';
                CabinetForm.Labelunit5.Caption:='m';
                CabinetForm.Labelunit6.Caption:='m';
             end;
             if (ComboBoxlength.ItemIndex=2) then
             begin
                CabinetForm.Labelunit1.Caption:='um';
                CabinetForm.Labelunit2.Caption:='um';
                CabinetForm.Labelunit3.Caption:='um';
                CabinetForm.Labelunit4.Caption:='um';
                CabinetForm.Labelunit5.Caption:='um';
                CabinetForm.Labelunit6.Caption:='um';
             end;


             CabinetForm.EAlf.Text:=FloatToStr(Alf);
             CabinetForm.EBet.Text:=FloatToStr(Bet);
             CabinetForm.EGam.Text:=FloatToStr(Gam);
             // Центр подвижной системы координат
             CabinetForm.EditXo.Text:=FloatToStr(Oxc);
             CabinetForm.EditYo.Text:=FloatToStr(Oyc);
             CabinetForm.EditZo.Text:=FloatToStr(Ozc);
             if (workmat[body[0].imatid].blibmat=0) then
             begin
                // материал определённый пользователем
                CabinetForm.RGCabinetMaterial.ItemIndex:=1;
             end
             else
             begin
                // Библиотечный материал.
                CabinetForm.RGCabinetMaterial.ItemIndex:=0;
             end;
             CabinetForm.EOpTemp.Text:=FloatToStr(operatingtemperature);
             case adiabatic_vs_heat_transfer_coeff of
                0 : begin
                        // однородное условие Неймана.
                        CabinetForm.ComboBoxFilmCoeff.ItemIndex:=0;
                        CabinetForm.EditFilmCoefficient.Visible:=false;
                        CabinetForm.LabelFilmCoefficient.Visible:=false;
                        CabinetForm.Label3.Visible:=false;
                    end;
                1 : begin
                       // Условие Ньютона-Рихмана.
                       CabinetForm.ComboBoxFilmCoeff.ItemIndex:=1;
                       CabinetForm.EditFilmCoefficient.Visible:=true;
                       CabinetForm.LabelFilmCoefficient.Visible:=true;
                       CabinetForm.EditFilmCoefficient.Text:=FloatToStr(filmcoefficient);
                    end;
                2 : begin
                       // Stefan Bolcman
                       CabinetForm.ComboBoxFilmCoeff.ItemIndex:=2;
                       CabinetForm.EditFilmCoefficient.Visible:=false;
                       CabinetForm.LabelFilmCoefficient.Visible:=false;
                        CabinetForm.Label3.Visible:=false;

                    end;
                3 : begin
                       // смешанного типа.
                       CabinetForm.ComboBoxFilmCoeff.ItemIndex:=3;
                       CabinetForm.EditFilmCoefficient.Visible:=true;
                       CabinetForm.LabelFilmCoefficient.Visible:=true;
                       CabinetForm.Label3.Visible:=true;
                       CabinetForm.EditFilmCoefficient.Text:=FloatToStr(filmcoefficient);
                    end;
             end;
             // Инициализация типа геометрии кабинета : None или Prism.
             case (body[0].itype) of
                2 : begin
                       // HOLLOW
                       CabinetForm.ComboBoxGeometryTypeCabinet.ItemIndex:=1;
                       CabinetForm.GroupBoxCabinetSize.Visible:=false;
                       CabinetForm.GBcabinetmaterial.Visible:=false;
                    end;
                3 : begin
                       // FLUID
                       CabinetForm.ComboBoxGeometryTypeCabinet.ItemIndex:=0;
                       CabinetForm.GroupBoxCabinetSize.Visible:=true;
                       CabinetForm.GBcabinetmaterial.Visible:=true;
                    end;
             end;

             // ShowModal не стоит т.к. он блокирует операции в главном модуле.
             CabinetForm.ShowModal;
             ReadyPaint;
          end;
   'b' : // блок
          begin
             // по всем блокам
             initializeaddblockform;

             ipriority_old:=body[itek].priority;
             AddBlockForm.ShowModal;
             if (body[itek].priority=ipriority_old) then
             begin
                MainTreeView.Selected.Text:=body[itek].name;
             end
             else
             begin
                scur_name2:=body[itek].name;
                // Удаляем узел из дерева.
                MainTreeView.Selected.Delete;
                // Сортировка по новым приоритетам.
                HeapSort(1,lb-1);

                // Ищем имя узла-блока который предшествует вставляемому.
                jsort:=0;
                for isort := 1 to lb-1 do
                begin
                   if ((length(body[isort].name)=length(scur_name2))and (Pos(body[isort].name,scur_name2)=1)) then
                   begin
                      jsort:=isort-1;
                      // Меняем принадлежность к юниону.
                      // Принадлежность к union напрямую наследуется от priority.
                      body[isort].iunion:=body[jsort].iunion;
                   end;
                end;

                // Выделяем место в дереве предшествующее месту вставки.
                scur_name3:=body[jsort].name;
                curNodeTree:=MainTreeView.Items.GetFirstNode;
                while (curNodeTree <> nil) do
                begin
                   if ((length(scur_name3)=length(curNodeTree.Text))and(Pos(curNodeTree.Text,scur_name3)=1)) then
                   begin
                      // Найденное место вставки выделяем в дереве.
                      NewNode:=curNodeTree;
                      //curNodeTree.Selected:=true;
                   end;
                   curNodeTree:=curNodeTree.GetNext;
                end; // while


                NewNode.Selected:=true;
                 curNodeTree:=NewNode;
                 curNodeTree.Selected:=true;
                 NewNode:=nil;
                // Вставка узла с учётом приоритета в новое место в дереве.
                NewNode:=MainTreeView.Items.Add(curNodeTree,scur_name2);
                //NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,scur_name2);
                NewNode.ImageIndex:=1;  // номер картинки (1 - блок)
                NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен (1 - блок)


                // Теперь блоки отсортированы по возратанию их приоритетов.
                // Переформировываем имена в дереве в соответстви с новым упорядочиванием.

                isort:=1;
                 for jsort := 1 to MainTreeView.Items.Count-1 do
                 begin
                    if (MainTreeView.Items[jsort].ImageIndex=1) then
                    begin
                       MainTreeView.Items[jsort].Text:=body[isort].name;
                       inc(isort);
                    end;
                  end;


             end;

              // Сортировка блоков по приоритетам:
              // Сортировка блоков по возрастанию значения их priority.
              // 2 мая 2016.
              (*
              for isort:=2 to lb-1 do
              begin
                 for jsort:=lb-1 downto isort do
                 begin
     		            if (body[jsort-1].priority > body[jsort].priority) then
                    begin
			                 // swap
			                 body_change:=body[jsort-1];
			                 body[jsort-1]:=body[jsort];
                       body[jsort]:= body_change;
                    end;
	               end;
              end;
              *)

             

             CorrectHollowCabinet;
             ReadyPaint;
          end;
   's' : // источник
          begin
             // по всем источникам
             InitializeAddSourceForm;
             AddSourceForm.ShowModal;
             MainTreeView.Selected.Text:=source[itek].name;
             CorrectHollowCabinet;
             ReadyPaint;
          end;
    'w' : // стенка
          begin
             // по всем твёрдым стенкам
             InitializeAddWallForm;
             AddWallForm.ShowModal;
             MainTreeView.Selected.Text:=wall[itek].name;
             CorrectHollowCabinet;
             ReadyPaint;
          end;
    'u' : // делает видимыми или невидимыми все элементы объединения
          // и более ничего.
          begin

             // параметр itek; передаётся внутрь формы:
             // Вычисляем массу объектов внутри union.
             massa:=0.0;
             rdensity:=0.0;
             for i_4:=1 to (lb-1) do
             begin
                //if (body[i_4].iunion=myassembles[itek-1].identifire) then
                // itek - номер текущего юниона, 0 - уровень кабинета.
                if (body[i_4].iunion=itek) then
                begin
                   if (body[i_4].itype=1) then
                   begin

                      // SOLID
                      if (workmat[body[i_4].imatid].blibmat=0) then
                      begin
                         rdensity:=workmat[body[i_4].imatid].rho;
                      end
                       else
                      begin
                         case workmat[body[i_4].imatid].ilibident of
                          101 : begin
                                   //'Alumina';
                                   rdensity:=3960.0;
                                end;
                          102 : begin
                                   //'Si';
                                   rdensity:=2330.0;
                                end;
                          103 : begin
                                   //'GaAs';
                                   rdensity:=5316.0;
                                end;
                          104 : begin
                                   //'GaN';
                                   rdensity:=6150.0;
                                end;
                          105 : begin
                                   //'SiC4H';
                                   rdensity:=3200.0;
                                end;
                          106 : begin
                                   //'Sapphire';
                                   rdensity:=3970.0;
                                end;
                          107 : begin
                                   //'Diamond';
                                   rdensity:=3615.0;
                                end;
                          108 : begin
                                   //'MD40';
                                   rdensity:=9600.0;
                                end;
                          109 : begin
                                   //'Au';
                                   rdensity:=19300.0;
                                end;
                          110 : begin
                                   //'SiO2';
                                   rdensity:=2100.0;
                                end;
                          111 : begin
                                   //'Cu';
                                   rdensity:=8933.0;
                                end;
                          112 : begin
                                   //'Kovar';
                                   rdensity:=8360.0;
                                end;
                          113 : begin
                                   //'Brass LS 59-1-L';
                                   rdensity:=8500.0;
                                end;
                          114 : begin
                                   //'Al-Duralumin';
                                   rdensity:=2800.0;
                                end;
                          115 : begin
                                   //'AlN';
                                   rdensity:=3255.0;
                                end;
                          end;
                      end;
                      if (body[i_4].igeometry_type=0) then
                      begin
                          // Prism
                          massa:=massa+rdensity*abs(body[i_4].xE-body[i_4].xS)*abs(body[i_4].yE-body[i_4].yS)*abs(body[i_4].zE-body[i_4].zS);
                      end;
                      if (body[i_4].igeometry_type=1) then
                      begin
                         // Cylinder
                         if (abs(body[i_4].angle_end-body[i_4].angle_start)<0.5) then
                         begin
                            body[i_4].angle_end:=360.0;
                         end;
                         massa:=massa+rdensity*(abs(body[i_4].angle_end-body[i_4].angle_start)/360.0)*body[i_4].Hcyl*3.141*(body[i_4].R_out_cyl*body[i_4].R_out_cyl-body[i_4].R_in_cyl*body[i_4].R_in_cyl);
                      end;
                      if (body[i_4].igeometry_type=2) then
                      begin
                         // Polygon
                         // работает только для треугольника
                         // и только для всюду одинаковых высот.
                         if (body[i_4].nsizei<3) then
                         begin
                            ShowMessage('Polygon error: nsizei<3');
                         end;
                         if (body[i_4].nsizei=3) then
                         begin
                            case body[i_4].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      massa:=massa+rdensity*(abs(body[i_4].hi[0]))*((body[i_4].xi[1]-body[i_4].xi[0])*(body[i_4].yi[2]-body[i_4].yi[0])-(body[i_4].yi[1]-body[i_4].yi[0])*(body[i_4].xi[2]-body[i_4].xi[0]));
                                   end;
                               2: begin
                                     // XZ
                                      massa:=massa+rdensity*(abs(body[i_4].hi[0]))*((body[i_4].xi[1]-body[i_4].xi[0])*(body[i_4].zi[2]-body[i_4].zi[0])-(body[i_4].zi[1]-body[i_4].zi[0])*(body[i_4].xi[2]-body[i_4].xi[0]));
                                  end;
                               3 : begin
                                      // YZ
                                       massa:=massa+rdensity*(abs(body[i_4].hi[0]))*((body[i_4].yi[1]-body[i_4].yi[0])*(body[i_4].zi[2]-body[i_4].zi[0])-(body[i_4].zi[1]-body[i_4].zi[0])*(body[i_4].yi[2]-body[i_4].yi[0]));
                                   end;
                            end;
                         end;
                         if (body[i_4].nsizei>3) then
                         begin
                            //   Только выпуклый полигон, его площадь аппроксимирована
                            // суммой площадей составляющих его треугольников.
                            // Центр масс.
                            xavg:=0.0;
                            yavg:=0.0;
                            zavg:=0.0;
                            for j := 0 to body[i_4].nsizei-1 do
                            begin
                               xavg:=xavg+body[i_4].xi[j];
                               yavg:=yavg+body[i_4].yi[j];
                               zavg:=zavg+body[i_4].zi[j];
                            end;
                            xavg:=xavg/body[i_4].nsizei;
                            yavg:=yavg/body[i_4].nsizei;
                            zavg:=zavg/body[i_4].nsizei;

                            for j := 0 to body[i_4].nsizei-2 do
                            begin
                            case body[i_4].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      massa:=massa+rdensity*(abs(body[i_4].hi[0]))*((body[i_4].xi[j]-xavg)*(body[i_4].yi[j+1]-yavg)-(body[i_4].yi[j]-yavg)*(body[i_4].xi[j+1]-xavg));
                                   end;
                               2: begin
                                     // XZ
                                      massa:=massa+rdensity*(abs(body[i_4].hi[0]))*((body[i_4].xi[j]-xavg)*(body[i_4].zi[j+1]-zavg)-(body[i_4].zi[j]-zavg)*(body[i_4].xi[j+1]-xavg));
                                  end;
                               3 : begin
                                      // YZ
                                       massa:=massa+rdensity*(abs(body[i_4].hi[0]))*((body[i_4].yi[j]-yavg)*(body[i_4].zi[j+1]-zavg)-(body[i_4].zi[j]-zavg)*(body[i_4].yi[j+1]-yavg));
                                   end;
                            end;
                            end;
                         end;
                      end;
                   end;
                   if (body[i_4].itype=2) then
                   begin
                      // HOLLOW
                      // Надо найти из какого блока вырезан hollow, чтобы узнать
                      // его материал.
                      // Центр масс.
                      xavg:=0.0;
                      yavg:=0.0;
                      zavg:=0.0;
                      if (body[i_4].igeometry_type=0) then
                      begin
                        // Прямоугольная призма.
                        xavg:=0.5*(body[i_4].xS+body[i_4].xE);
                        yavg:=0.5*(body[i_4].yS+body[i_4].yE);
                        zavg:=0.5*(body[i_4].zS+body[i_4].zE);
                      end;
                      if (body[i_4].igeometry_type=1) then
                      begin
                         // Cylinder.
                         case body[i_4].iPlane of
                              1 : //XY
                              begin
                                 xavg:=body[i_4].xC;
                                 yavg:=body[i_4].yC;
                                 zavg:=body[i_4].zC+0.5*body[i_4].Hcyl;
                              end;
                              2 : // XZ
                              begin
                                 xavg:=body[i_4].xC;
                                 zavg:=body[i_4].zC;
                                 yavg:=body[i_4].yC+0.5*body[i_4].Hcyl;
                              end;
                              3 : // YZ
                              begin
                                 yavg:=body[i_4].yC;
                                 zavg:=body[i_4].zC;
                                 xavg:=body[i_4].xC+0.5*body[i_4].Hcyl;
                              end;
                            end;
                      end;
                      if (body[i_4].igeometry_type=2) then
                      begin
                          for j := 0 to body[i_4].nsizei-1 do
                            begin
                               xavg:=xavg+body[i_4].xi[j];
                               yavg:=yavg+body[i_4].yi[j];
                               zavg:=zavg+body[i_4].zi[j];
                            end;
                            xavg:=xavg/body[i_4].nsizei;
                            yavg:=yavg/body[i_4].nsizei;
                            zavg:=zavg/body[i_4].nsizei;
                            case body[i_4].iPlane_obj2 of
                              1 : //XY
                              begin
                                 zavg:=body[i_4].zi[0]+0.5*body[i_4].hi[0];
                              end;
                              2 : // XZ
                              begin
                                 yavg:=body[i_4].yi[0]+0.5*body[i_4].hi[0];
                              end;
                              3 : // YZ
                              begin
                                 xavg:=body[i_4].xi[0]+0.5*body[i_4].hi[0];
                              end;
                            end;
                      end;


                      i_5:=0;
                      for i_6 := 0 to i_4-1 do
                        begin
                           // Здесь геометрия i_6 только прямоугольная призма.
                           // TODO предусмотреть другие геометрии.

                           if ((xavg>body[i_6].xS)and(xavg<body[i_6].xE)and(yavg>body[i_6].yS)and(yavg<body[i_6].yE)and(zavg>body[i_6].zS)and(zavg<body[i_6].zE)) then
                           begin
                              if (body[i_6].itype=1) then
                              begin
                                 // Если тот из кого вырезают есть SOLID.
                                 // В остальных случаях мы вообще ничего не вырезаем (плотность тождественный ноль).
                                 i_5:=i_6;
                              end;
                           end;
                        end;
                      if (i_5=0) then
                      begin
                         rdensity:=0.0;
                      end
                      else
                      begin

                      if (workmat[body[i_5].imatid].blibmat=0) then
                      begin
                         rdensity:=workmat[body[i_5].imatid].rho;
                      end
                       else
                      begin
                         case workmat[body[i_5].imatid].ilibident of
                          101 : begin
                                   //'Alumina';
                                   rdensity:=3960.0;
                                end;
                          102 : begin
                                   //'Si';
                                   rdensity:=2330.0;
                                end;
                          103 : begin
                                   //'GaAs';
                                   rdensity:=5316.0;
                                end;
                          104 : begin
                                   //'GaN';
                                   rdensity:=6150.0;
                                end;
                          105 : begin
                                   //'SiC4H';
                                   rdensity:=3200.0;
                                end;
                          106 : begin
                                   //'Sapphire';
                                   rdensity:=3970.0;
                                end;
                          107 : begin
                                   //'Diamond';
                                   rdensity:=3615.0;
                                end;
                          108 : begin
                                   //'MD40';
                                   rdensity:=9600.0;
                                end;
                          109 : begin
                                   //'Au';
                                   rdensity:=19300.0;
                                end;
                          110 : begin
                                   //'SiO2';
                                   rdensity:=2100.0;
                                end;
                          111 : begin
                                   //'Cu';
                                   rdensity:=8933.0;
                                end;
                          112 : begin
                                   //'Kovar';
                                   rdensity:=8360.0;
                                end;
                          113 : begin
                                   //'Brass LS 59-1-L';
                                   rdensity:=8500.0;
                                end;
                          114 : begin
                                   //'Al-Duralumin';
                                   rdensity:=2800.0;
                                end;
                          115 : begin
                                   //'AlN';
                                   rdensity:=3255.0;
                                end;
                          end;
                      end;
                      // hollow
                      // Объём берётся hollow блока а плотность порождающего solid блока.
                      if (body[i_4].igeometry_type=0) then
                      begin
                         // Prism
                         massa:=massa-rdensity*abs(body[i_4].xE-body[i_4].xS)*abs(body[i_4].yE-body[i_4].yS)*abs(body[i_4].zE-body[i_4].zS);
                      end;
                      if (body[i_4].igeometry_type=1) then
                      begin
                          // Cylinder
                          if (abs(body[i_4].angle_end-body[i_4].angle_start)<0.5) then
                          begin
                             body[i_4].angle_end:=360.0;
                          end;
                          massa:=massa-rdensity*body[i_4].Hcyl*3.141*(abs(body[i_4].angle_end-body[i_4].angle_start)/360.0)*(body[i_4].R_out_cyl*body[i_4].R_out_cyl-body[i_4].R_in_cyl*body[i_4].R_in_cyl);
                      end;
                      if (body[i_4].igeometry_type=2) then
                      begin
                         // Polygon
                         // работает только для треугольника
                         // и только для всюду одинаковых высот.
                         if (body[i_4].nsizei<3) then
                         begin
                            ShowMessage('Polygon error: nsizei<3');
                         end;
                         if (body[i_4].nsizei=3) then
                         begin
                            case body[i_4].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      massa:=massa-rdensity*(abs(body[i_4].hi[0]))*((body[i_4].xi[1]-body[i_4].xi[0])*(body[i_4].yi[2]-body[i_4].yi[0])-(body[i_4].yi[1]-body[i_4].yi[0])*(body[i_4].xi[2]-body[i_4].xi[0]));
                                   end;
                               2: begin
                                     // XZ
                                      massa:=massa-rdensity*(abs(body[i_4].hi[0]))*((body[i_4].xi[1]-body[i_4].xi[0])*(body[i_4].zi[2]-body[i_4].zi[0])-(body[i_4].zi[1]-body[i_4].zi[0])*(body[i_4].xi[2]-body[i_4].xi[0]));
                                  end;
                               3 : begin
                                      // YZ
                                       massa:=massa-rdensity*(abs(body[i_4].hi[0]))*((body[i_4].yi[1]-body[i_4].yi[0])*(body[i_4].zi[2]-body[i_4].zi[0])-(body[i_4].zi[1]-body[i_4].zi[0])*(body[i_4].yi[2]-body[i_4].yi[0]));
                                   end;
                            end;
                         end;
                         if (body[i_4].nsizei>3) then
                         begin
                            //   Только выпуклый полигон, его площадь аппроксимирована
                            // суммой площадей составляющих его треугольников.
                            // Центр масс.
                            xavg:=0.0;
                            yavg:=0.0;
                            zavg:=0.0;
                            for j := 0 to body[i_4].nsizei-1 do
                            begin
                               xavg:=xavg+body[i_4].xi[j];
                               yavg:=yavg+body[i_4].yi[j];
                               zavg:=zavg+body[i_4].zi[j];
                            end;
                            xavg:=xavg/body[i_4].nsizei;
                            yavg:=yavg/body[i_4].nsizei;
                            zavg:=zavg/body[i_4].nsizei;

                            for j := 0 to body[i_4].nsizei-2 do
                            begin
                            case body[i_4].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      massa:=massa-rdensity*(abs(body[i_4].hi[0]))*((body[i_4].xi[j]-xavg)*(body[i_4].yi[j+1]-yavg)-(body[i_4].yi[j]-yavg)*(body[i_4].xi[j+1]-xavg));
                                   end;
                               2: begin
                                     // XZ
                                      massa:=massa-rdensity*(abs(body[i_4].hi[0]))*((body[i_4].xi[j]-xavg)*(body[i_4].zi[j+1]-zavg)-(body[i_4].zi[j]-zavg)*(body[i_4].xi[j+1]-xavg));
                                  end;
                               3 : begin
                                      // YZ
                                       massa:=massa-rdensity*(abs(body[i_4].hi[0]))*((body[i_4].yi[j]-yavg)*(body[i_4].zi[j+1]-zavg)-(body[i_4].zi[j]-zavg)*(body[i_4].yi[j+1]-yavg));
                                   end;
                            end;
                            end;
                            end;
                         end;
                      end;
                   end;
                end;
             end;
             // FormUnion.Labelmassa.Caption:='';
             case ComboBoxLength.ItemIndex of
                   0 : begin
                   // m
                   FormUnion.Labelmassa.Caption:='massa= '+FormatFloat('#.###E-0',massa)+' kg';
                   end;
                   1 : begin
                   // mm
                   FormUnion.Labelmassa.Caption:='massa= '+FormatFloat('#.###E-0',1e-9*massa)+' kg';
                   end;
                   2 : begin
                   // micron
                   FormUnion.Labelmassa.Caption:='massa= '+FormatFloat('#.###E-0',1e-18*massa)+' kg';
                   end;
             end;
             //FormUnion.Labelmassa.Caption:='massa= '+FloatToStr(massa)+' kg';
             //FormUnion.Labelmassa.Caption:='massa= '+FormatFloat('#.###E-0',massa)+' kg';
             FormUnion.Editname.Text:=myassembles[itek-1].name; // имя ассемблеса.
             FormUnion.CheckBoxVisible.Checked:=myassembles[itek-1].bVisible; // устанавливаем видимость элементов объединения.

             FormUnion.CBMeshassemblesSeparat.Checked:=myassembles[itek-1].bmesh_assembles_separately;
             FormUnion.GBmeshasembles.Visible:=myassembles[itek-1].bmesh_assembles_separately;
             // инициализация програмной формы.
             FormUnion.Exmin.Text:=myassembles[itek-1].sxmin;
             FormUnion.Eymin.Text:=myassembles[itek-1].symin;
             FormUnion.Ezmin.Text:=myassembles[itek-1].szmin;
             FormUnion.EXmax.Text:=myassembles[itek-1].sxmax;
             FormUnion.EYmax.Text:=myassembles[itek-1].symax;
             FormUnion.EZmax.Text:=myassembles[itek-1].szmax;
             // сетка :
             FormUnion.CBinx.ItemIndex:=myassembles[itek-1].inxloc-4;
             FormUnion.CBiny.ItemIndex:=myassembles[itek-1].inyloc-4;
             FormUnion.CBinz.ItemIndex:=myassembles[itek-1].inzloc-4;

             // Форма готова к показу.
             FormUnion.ShowModal;
             MainTreeView.Selected.Text:=myassembles[itek-1].name;
             CorrectHollowCabinet;
             ReadyPaint;
          end;
   end; // case
end;

// удаление выделенного в дереве элемента
// может быть удалено не более одного элемента.
procedure TLaplas.SpeedButtonDelClick(Sender: TObject);
var
   sdel : String;
   i,j,i_1, idel, idel1 : Integer;
   bcontinue_del : Boolean;


// удаляет элемент с именем sname
// из дерева элементов.
procedure delete_in_Tree(sname : string);
var
   il : Integer;
begin
   MainTreeView.Selected:=nil;   // снимем выделение с дерева.
   // Найдём узел дерева который отвечает выбранному ассемблесу.
   for il:=0 to MainTreeView.Items.Count-1 do
   begin
      if ((length(sname) = length(MainTreeView.Items.Item[il].Text)) and (Pos(sname,MainTreeView.Items.Item[il].Text)=1)) then
      begin
         MainTreeView.Items.Item[il].Delete;
         Break;
      end;
   end;
end;

// удаляет блок с идентификатором id.
procedure delete_body(id : Integer);
var
   il,jl : Integer; // l - local
   body_copy : array of TBody;
begin
   if ((id >-1) and (id<lb)) then
   begin
      // В удаляемом блоке свобождаем память из под динамических массивов.
      SetLength(body[id].xi,0);
      SetLength(body[id].yi,0);
      SetLength(body[id].zi,0);
      SetLength(body[id].hi,0);
      body[id].nsizei:=0;

      SetLength(body_copy,lb-1);
      jl:=0;
      for il:=0 to (lb-1) do
      begin
         if (il<>id) then
         begin
            body_copy[jl]:=body[il];
            if (body[il].nsizei>0) then
            begin
               SetLength(body[il].xi,0);
               SetLength(body[il].yi,0);
               SetLength(body[il].zi,0);
               SetLength(body[il].hi,0);
               body[il].nsizei:=0;
            end;
            inc(jl);
         end;
      end;
      dec(lb);
      SetLength(body,lb);
      for il:=0 to (lb-1) do
      begin
         body[il]:=body_copy[il];
         if (body_copy[il].nsizei>0) then
         begin
            SetLength(body_copy[il].xi,0);
            SetLength(body_copy[il].yi,0);
            SetLength(body_copy[il].zi,0);
            SetLength(body_copy[il].hi,0);
            body_copy[il].nsizei:=0;
         end;
      end;
      SetLength(body_copy,0); // освобождение памяти
      body_copy:=nil;
   end;
end;

// удаляет источник с идентификатором id.
procedure delete_source(id : Integer);
var
   il,jl : Integer; // l - local
   source_copy : array of TPlane;
begin
   if ((id >-1) and (id<ls)) then
   begin
      SetLength(source_copy,ls-1);
      jl:=0;
      for il:=0 to (ls-1) do
      begin
         if (il<>id) then
         begin
            source_copy[jl]:=source[il];
            inc(jl);
         end;
      end;
      dec(ls);
      SetLength(source,ls);
      for il:=0 to (ls-1) do
      begin
         source[il]:=source_copy[il];
      end;
      SetLength(source_copy,0); // освобождение памяти
      source_copy:=nil;
   end;
end;

// удаляет стенку с идентификатором id.
procedure delete_wall(id : Integer);
var
   il,jl : Integer;  // l - local
   wall_copy : array of TPlane;
begin
   if ((id >-1) and (id<lw)) then
   begin

     // Если стенка предопрделялась кабинетом то необходимо
     // освободить заниманиемую настройку при удалении стенки.
      case wall[id].cabinet_depend of
         1 : begin
                // minX
                 cab_bound_condition.bminX:=false;
             end;
         2 : begin
                // maxX
                cab_bound_condition.bmaxX:=false;
             end;
         3 : begin
                // minY
                cab_bound_condition.bminY:=false;
             end;
         4 : begin
                // maxY
                cab_bound_condition.bmaxY:=false;
             end;
         5 : begin
                 // minZ
                 cab_bound_condition.bminZ:=false;
             end;
         6 : begin
                 // maxZ
                 cab_bound_condition.bmaxZ:=false;
             end;
      end;

      SetLength(wall_copy,lw-1);
      jl:=0;
      for il:=0 to (lw-1) do
      begin
         if (il<>id) then
         begin
            wall_copy[jl]:=wall[il];
            inc(jl);
         end;
      end;
      dec(lw);
      SetLength(wall,lw);
      for il:=0 to (lw-1) do
      begin
         wall[il]:=wall_copy[il];
      end;
      SetLength(wall_copy,0); // освобождение памяти
      wall_copy:=nil;
   end;
end;

// удаляет строго пустой union без проверки его пустоты с идентификатором id.
procedure delete_union(id : Integer);
var
   il,jl : Integer;  // l - local
   myassembles_copy : array of TMyAssembles;
begin
   SetLength(myassembles_copy,lu-1);
   jl:=0;
   for il:=0 to (lu-1) do
   begin
      if (myassembles[il].identifire<>id) then
      begin
         myassembles_copy[jl]:=myassembles[il];
         inc(jl);
      end;
   end;
   dec(lu);
   SetLength(myassembles,lu);
   for il:=0 to (lu-1) do
   begin
      myassembles[il]:=myassembles_copy[il];
   end;
   SetLength(myassembles_copy,0); // освобождение памяти
   myassembles_copy:=nil;
end;

// удаляет наполнение union`а
// с заданным идентификатором.
// bsw - block, source, wall.
procedure delete_unionbsw(id : Integer);
var
   il : Integer;
   bstop : Boolean;
begin
   // Если есть элементы принадлежащие данному юниону то юнион не может быть удалён.
   // блоки
   bstop:=False;
   while (not(bstop)) do
   begin
      bstop:=True;
      for il:=1 to (lb-1) do
      begin
         if (body[il].iunion=id) then
         begin     // нумерация identifire начинается с единицы, так что всё корректно.
            bstop:=false;
            delete_in_Tree(body[il].name);
            delete_body(il);
            Break;
         end;
      end;
   end;
   // стенки
   bstop:=False;
   while (not(bstop)) do
   begin
      bstop:=True;
      for il:=0 to (lw-1) do
      begin
         if (wall[il].iunion=id) then
         begin
            bstop:=false;
            delete_in_Tree(wall[il].name);
            delete_wall(il);
            Break;
         end;
      end;
   end;
   // источники
   bstop:=False;
   while (not(bstop)) do
   begin
      bstop:=True;
      for il:=0 to (ls-1) do
      begin
         if (source[il].iunion=id) then
         begin
            bstop:=false;
            delete_in_Tree(source[il].name);
            delete_source(il);
            Break;
         end;
      end;
   end;
end;

//  найдены ли у данного юниона дочерние юнионы.
function is_union_Empty(id : Integer) : Boolean;
var
   il : Integer;
   bfound : Boolean; // найдены ли у данного юниона дочерние юнионы.
begin
   bfound:=False;
   for il:=0 to (lu-1) do
   begin
      if (il<>id) then
      begin
         if (myassembles[il].iunionparent=id) then
         begin
             bfound:=True;
             Break;
         end;
      end;
   end;
   is_union_Empty:=not(bfound);
end;


// мощная рекурсивная процедура удаления которая удаляет всё и всегда.
procedure recursion_delete(snamedel : string);
var
   bstop : Boolean;
   idell, il : Integer;
begin
   bstop:=False;
   while (not(bstop)) do
   begin
      bstop:=True;

      // снова определяем идентификатор удаляемого объединения,
      // так как список объединений мог измениться из-за удаления вложенных.
      idell:=-1;
      for il:=0 to (lu-1) do
      begin
         if ( (length(myassembles[il].name) = length(snamedel)) and (Pos(myassembles[il].name,snamedel)=1)) then
         begin
            idell:=il; // номер удаляемого объединения.
         end;
      end;

      if (idell >-1) then
      begin

         for il:=0 to (lu-1) do
         begin
            if (il<>idell) then
            begin
               if (myassembles[il].iunionparent=myassembles[idell].identifire-1) then
               begin
                  // у удаляемого юниона есть дочерние union`ы.
                  delete_unionbsw(myassembles[il].identifire);
                  if (is_union_Empty(myassembles[il].identifire)) then
                  begin
                     // удаляем из дерева.
                     delete_in_Tree(myassembles[il].name);
                     delete_union(myassembles[il].identifire); // удаляет строго пустой юнион.
                  end
                   else
                  begin
                     // снова есть дочерние.
                     // нужна рекурсивная процедура.
                     recursion_delete(myassembles[il].name);
                     // удаляем из дерева.
                     delete_in_Tree(myassembles[il].name);
                     delete_union(myassembles[il].identifire); // удаляет строго пустой юнион.
                  end;
                  bstop:=False;
                  Break;
               end;
            end;
         end;
      end;
   end;
end;

begin

  FormPattern.ShowModal;

   if (FormPattern.RadioGroupPattern.ItemIndex=1) then
   begin
      // Текстовый шаблон.
      if (length(FormPattern.EdittextnamefragmentPattern.Text)>0) then
      begin
         while(true) do
         begin
            bcontinue_del:=false;
            for i_1 := 1 to (lb-1) do
            begin
               if (Pos(Trim(FormPattern.EdittextnamefragmentPattern.Text),body[i_1].name)>0) then
               begin
                  bcontinue_del:=true;
                  sdel:= body[i_1].name;
               end;
            end;
             if not(bcontinue_del) then
            begin
               for i_1 := 0 to (lw-1) do
               begin
                  if (Pos(Trim(FormPattern.EdittextnamefragmentPattern.Text),wall[i_1].name)>0) then
                  begin
                     bcontinue_del:=true;
                     sdel:= wall[i_1].name;
                  end;
               end;
            end;
              if not(bcontinue_del) then
            begin
               for i_1 := 0 to (ls-1) do
               begin
                  if (Pos(Trim(FormPattern.EdittextnamefragmentPattern.Text),source[i_1].name)>0) then
                  begin
                     bcontinue_del:=true;
                     sdel:= source[i_1].name;
                  end;
               end;
            end;
            if not(bcontinue_del) then
            begin
               break; // досрочный выход из удаления.
            end
            else
            begin
               // очередное удаление
                // по всем блокам
                idel:=-1;
                for i:=1 to (lb-1) do
                begin
                   if ( (length(body[i].name) = length(sdel)) and (Pos(body[i].name,sdel)=1)) then
                   begin
                      idel:=i; // номер удаляемого блока
                   end;
                end;
                delete_body(idel); // удаляем блок с идентификатором idel.
                // по всем источникам
                idel:=-1;
                for i:=0 to (ls-1) do
                begin
                   if ( (length(source[i].name) = length(sdel)) and (Pos(source[i].name,sdel)=1)) then
                   begin
                      idel:=i; // номер удаляемого блока
                   end;
                end;
                delete_source(idel); // удаляет источник с идентификатором idel.
                // по всем стенкам
                idel:=-1;
                for i:=0 to (lw-1) do
                begin
                   if ( (length(wall[i].name) = length(sdel)) and (Pos(wall[i].name,sdel)=1)) then
                   begin
                      idel:=i; // номер удаляемого блока
                   end;
                end;
                delete_wall(idel);

                // по всем объединениям.
                idel:=-1;
                for i:=0 to (lu-1) do
                begin
                   if ( (length(myassembles[i].name) = length(sdel)) and (Pos(myassembles[i].name,sdel)=1)) then
                   begin
                      idel:=i; // номер удаляемого объединения.
                   end;
                end;
                if (idel >-1) then
                begin
                   // удаление наполнения union`а.
                   delete_unionbsw(myassembles[idel].identifire);


                   recursion_delete(sdel);
                   idel:=-1;
                   for i:=0 to (lu-1) do
                   begin
                      if ( (length(myassembles[i].name) = length(sdel)) and (Pos(myassembles[i].name,sdel)=1)) then
                      begin
                         idel:=i; // номер удаляемого объединения.
                      end;
                   end;



                   delete_union(myassembles[idel].identifire); // удаляет строго пустой юнион.

                   // Выделяем в дереве удаляемый юнион.
                   MainTreeView.Selected:=nil;   // снимем выделение с дерева.
                   // Найдём узел дерева который отвечает выбранному ассемблесу.
                   for i:=0 to MainTreeView.Items.Count-1 do
                   begin
                      if ((length(sdel) = length(MainTreeView.Items.Item[i].Text)) and (Pos(sdel,MainTreeView.Items.Item[i].Text)=1)) then
                      begin
                         MainTreeView.Items.Item[i].Selected:=True;
                         Break;
                      end;
                   end;

                end;


            end;
         end;

          // удаление выделенных элементов из дерева
          // перезагрузка дерева.
          TreeLoad(Sender);
          CorrectHollowCabinet;
          ReadyPaint;
          Render;// прорисовка изменений

      end;
   end;
  if (FormPattern.RadioGroupPattern.ItemIndex=0) then
   begin
      //  OnlySelect Text

   if (MainTreeView.Selected<>nil) then
   begin
      // Если элемент выделен !

      // Удаление выделенного в дереве элемента
      sdel:=MainTreeView.Selected.Text; // уникальное имя удаляемого объекта
      // по всем блокам
      idel:=-1;
      for i:=1 to (lb-1) do
      begin
         if ( (length(body[i].name) = length(sdel)) and (Pos(body[i].name,sdel)=1)) then
         begin
            idel:=i; // номер удаляемого блока
         end;
      end;
      delete_body(idel); // удаляем блок с идентификатором idel.
      // по всем источникам
      idel:=-1;
      for i:=0 to (ls-1) do
      begin
         if ( (length(source[i].name) = length(sdel)) and (Pos(source[i].name,sdel)=1)) then
         begin
            idel:=i; // номер удаляемого блока
         end;
      end;
      delete_source(idel); // удаляет источник с идентификатором idel.
      // по всем стенкам
      idel:=-1;
      for i:=0 to (lw-1) do
      begin
         if ( (length(wall[i].name) = length(sdel)) and (Pos(wall[i].name,sdel)=1)) then
         begin
            idel:=i; // номер удаляемого блока
         end;
      end;
      delete_wall(idel);

      // по всем объединениям.
      idel:=-1;
      for i:=0 to (lu-1) do
      begin
         if ( (length(myassembles[i].name) = length(sdel)) and (Pos(myassembles[i].name,sdel)=1)) then
         begin
            idel:=i; // номер удаляемого объединения.
         end;
      end;
      if (idel >-1) then
      begin
         // удаление наполнения union`а.
         delete_unionbsw(myassembles[idel].identifire);


         recursion_delete(sdel);
         idel:=-1;
         for i:=0 to (lu-1) do
         begin
            if ( (length(myassembles[i].name) = length(sdel)) and (Pos(myassembles[i].name,sdel)=1)) then
            begin
               idel:=i; // номер удаляемого объединения.
            end;
         end;



            delete_union(myassembles[idel].identifire); // удаляет строго пустой юнион.

            // Выделяем в дереве удаляемый юнион.
            MainTreeView.Selected:=nil;   // снимем выделение с дерева.
            // Найдём узел дерева который отвечает выбранному ассемблесу.
            for i:=0 to MainTreeView.Items.Count-1 do
            begin
               if ((length(sdel) = length(MainTreeView.Items.Item[i].Text)) and (Pos(sdel,MainTreeView.Items.Item[i].Text)=1)) then
               begin
                  MainTreeView.Items.Item[i].Selected:=True;
                  Break;
               end;
            end;



      end;

      // удаление выделенного элемента из дерева
      if ((not((length(MainTreeView.Selected.Text)=Length(body[0].name))and(Pos(MainTreeView.Selected.Text,body[0].name)=1)))) then
      begin
         MainTreeView.Items.Delete(MainTreeView.Selected);
      end;
      CorrectHollowCabinet;
      ReadyPaint;
      Render;// прорисовка изменений
   end;
   end;

end;

// создание inum копий выделенного объекта.
procedure TLaplas.SpeedButtonCopyClick(Sender: TObject);
var
    scop : String;
    iob,i,j : Integer;
    NewNode : TTreeNode;
    dx, dy, dz, dmbuf : Real;
    bdxchange, bdychange, bdzchange : Boolean;
    bdxconst, bdyconst, bdzconst : Boolean;
    code : Integer;
    iobass, iunionid : Integer;
    lbold, luold, lsold, lwold : Integer;
    imaxuident : Integer; // максимальный идентификатор объединения.
    sforval : String;

function my_sign(x125 : Real) : Real;
begin
   if (x125>0.0) then
   begin
      Result:=1.0;
   end
    else
   begin
      Result:=-1.0;
   end;
end;


// Вычисление углов при повороте.
procedure angle_calc(var phi0 : Real;
              xi_loc : Real; yi_loc : Real;
              dx_loc : Real; dy_loc : Real);
begin
    if (abs(xi_loc-dx_loc)<abs(yi_loc-dy_loc)) then
    begin

       phi0:=arctan((xi_loc-dx_loc)/(yi_loc-dy_loc))+1.5705;;
       // Угол всегда острый



       //MainMemo.Lines.Add(FloatToStr(phic)+' '+FloatToStr(xavg-dx_loc));

       if ((yi_loc-dy_loc)>0.0) then
       begin
          //phi0:=phi0+1.5705;
          phi0:=phi0;
       end
        else
       begin
          //phi0:=phi0+1.5705+3.141;
          phi0:=phi0+3.141;
       end;

    end
     else
    begin
       phi0:=arctan((yi_loc-dy_loc)/(xi_loc-dx_loc));
       //  MainMemo.Lines.Add(FloatToStr(phi0));

       // Угол всегда острый

       // if ((body[id].xi[i_1]-dx_loc)>0.0) then add 0.0

       if ((xi_loc-dx_loc)<0.0) then
       begin
          phi0:=phi0+3.141;
       end
        else
       begin
          phi0:=phi0;
       end;
    end;

end;



// создаёт inum копий блока с идентификатором id.
procedure copyblock(id : Integer; idunion : Integer; bCabinet : Boolean);
var
   lold1, ilen, ikountid : Integer;
   i1, j1 ,j_4, i_4, j, i_1: Integer;
   i2, i2found : Integer; //   счётчик для поиска асемблеса.
   bOk, bOk1 : Boolean;
   sforval, scur_name, scur_name2 : String;
   curNodeTree : TTreeNode;
   bOk_conflict_name : Boolean;
   b_polygon_x, b_polygon_y, b_polygon_z : Boolean;
   phi0, phic, phi_step, xavg, yavg, zavg, Rdd, Rdd2 : Real;
   xmin2, ymin2, zmin2, xmax2, ymax2, zmax2, size_obj : Real;

begin
   b_polygon_x:=false;
   b_polygon_y:=false;
   b_polygon_z:=false;

   if (id>-1) then
   begin
      lold1:=lb;
      // inum - глобальная переменная в данном модуле
      // отвечающая за число копий.
      lb:=lb+inum;
      SetLength(body,lb);

      j_4:=0;
      j1:=1;
      for i1:=lold1 to (lb-1) do
      begin
         // iob - копируемый объект.
         // i - одна из копий.

         inc(j_4);

         if (FormCopyObject.CheckBoxRotate.Checked) then
         begin
            // Вращение полигона.
            xavg:=0.0;
            yavg:=0.0;
            zavg:=0.0;

            body[i1].Hcyl:=body[id].Hcyl;
            body[i1].iPlane:=body[id].iPlane;
            if (body[id].igeometry_type=1) then
            begin
               // Цилиндр.
               // Выбираем правильную плоскость копирования.
               body[id].iPlane_obj2:=body[id].iPlane;
            end;


            case body[id].iPlane_obj2 of
               1 : begin
                      // XY
                       for i_1:=0 to body[id].nsizei-1 do
                       begin
                          xavg:= xavg + body[id].xi[i_1];
                          yavg:= yavg + body[id].yi[i_1];
                       end;
                       xavg:=xavg/body[id].nsizei;
                       yavg:=yavg/body[id].nsizei;
                       zavg:=body[id].zi[0];
                       Rdd:= sqrt((xavg-dx)*(xavg-dx)+(yavg-dy)*(yavg-dy));
                       phi0:=arcsin((yavg-dy)/Rdd);
                       phi_step:=2.0*3.141/ (lb-1-lold1+2);

                       b_polygon_x:=true;
                       b_polygon_y:=true;
                       SetLength(body[i1].xi,body[id].nsizei);
                       SetLength(body[i1].yi,body[id].nsizei);

                       for i_1:=0 to body[id].nsizei-1 do
                       begin
                          Rdd2:= sqrt((body[id].xi[i_1]-dx)*(body[id].xi[i_1]-dx)+(body[id].yi[i_1]-dy)*(body[id].yi[i_1]-dy));

                          angle_calc(phi0,  body[id].xi[i_1], body[id].yi[i_1],  dx, dy);

                          body[i1].xi[i_1]:=dx+Rdd2*cos(phi0+j1*phi_step);
                          body[i1].yi[i_1]:=dy+Rdd2*sin(phi0+j1*phi_step);
                       end;

                       angle_calc(phi0,  body[id].xC, body[id].yC,  dx, dy);

                       Rdd2:=sqrt((body[id].xC-dx)*(body[id].xC-dx)+(body[id].yC-dy)*(body[id].yC-dy));
                       body[i1].xC:=dx+Rdd2*cos(phi0+j1*phi_step);
                       body[i1].yC:=dy+Rdd2*sin(phi0+j1*phi_step);
                       body[i1].sxC:=FloatToStr(body[i1].xC);
                       body[i1].syC:=FloatToStr(body[i1].yC);

                       xmin2:=1.0e30;
                       ymin2:=1.0e30;
                       xmax2:=-1.0e30;
                       ymax2:=-1.0e30;
                       xavg:=0.0;
                       yavg:=0.0;

                       for i_1:=0 to body[id].nsizei-1 do
                       begin
                          xavg:= xavg + body[i1].xi[i_1];
                          yavg:= yavg + body[i1].yi[i_1];
                          if (body[i1].xi[i_1]<xmin2) then
                          begin
                              xmin2:=body[i1].xi[i_1];
                          end;
                          if (body[i1].xi[i_1]>xmax2) then
                          begin
                              xmax2:=body[i1].xi[i_1];
                          end;
                           if (body[i1].yi[i_1]<ymin2) then
                          begin
                              ymin2:=body[i1].yi[i_1];
                          end;
                          if (body[i1].yi[i_1]>ymax2) then
                          begin
                              ymax2:=body[i1].yi[i_1];
                          end;
                       end;
                       xavg:=xavg/body[id].nsizei;
                       yavg:=yavg/body[id].nsizei;
                       body[i1].xS:=xmin2;
                       body[i1].yS:=ymin2;
                       body[i1].xE:=xmax2;
                       body[i1].yE:=ymax2;
                       body[i1].sxS:=FloatToStr(xmin2);
                       body[i1].syS:=FloatToStr(ymin2);
                       body[i1].sxE:=FloatToStr(xmax2);
                       body[i1].syE:=FloatToStr(ymax2);

                        // copy
                       body[i1].szS:=body[id].szS;
                       body[i1].szE:=body[id].szE;
                       body[i1].szC:=body[id].szC;
                       body[i1].zS:=body[id].zS;
                       body[i1].zE:=body[id].zE;
                       body[i1].zC:=body[id].zC;

                   end;
               2 : begin
                      // XZ
                       xavg:=0.0;
                       zavg:=0.0;
                       xmin2:=1.0e30;
                       zmin2:=1.0e30;
                       xmax2:=-1.0e30;
                       zmax2:=-1.0e30;
                       for i_1:=0 to body[id].nsizei-1 do
                       begin
                          xavg:= xavg+body[id].xi[i_1];
                          zavg:= zavg+body[id].zi[i_1];
                           if (body[id].xi[i_1]<xmin2) then
                          begin
                              xmin2:=body[id].xi[i_1];
                          end;
                          if (body[id].xi[i_1]>xmax2) then
                          begin
                              xmax2:=body[id].xi[i_1];
                          end;
                           if (body[id].zi[i_1]<zmin2) then
                          begin
                              zmin2:=body[id].zi[i_1];
                          end;
                          if (body[id].zi[i_1]>zmax2) then
                          begin
                              zmax2:=body[id].zi[i_1];
                          end;
                       end;
                       xavg:=xavg/body[id].nsizei;
                       zavg:=zavg/body[id].nsizei;
                       yavg:=body[id].yi[0];
                       Rdd:= sqrt((xavg-dx)*(xavg-dx)+(zavg-dz)*(zavg-dz));

                       phi_step:=2.0*3.141/ (lb-1-lold1+2);
                       size_obj:=sqrt((zmax2-zmin2)*(zmax2-zmin2)+(xmax2-xmin2)*(xmax2-xmin2));


                      SetLength(body[i1].yi,body[id].nsizei);
                      SetLength(body[i1].hi,body[id].nsizei);
                       for i_1:=0 to body[id].nsizei-1 do
                       begin
                          body[i1].yi[i_1]:=yavg;
                          body[i1].hi[i_1]:=body[id].hi[0];
                       end;

                      b_polygon_x:=true;
                      b_polygon_z:=true;
                      SetLength(body[i1].xi,body[id].nsizei);
                      SetLength(body[i1].zi,body[id].nsizei);

                       for i_1:=0 to body[id].nsizei-1 do
                       begin
                          Rdd2:= sqrt((body[id].xi[i_1]-dx)*(body[id].xi[i_1]-dx)+(body[id].zi[i_1]-dz)*(body[id].zi[i_1]-dz));

                          angle_calc(phi0,  body[id].xi[i_1], body[id].zi[i_1],  dx, dz);

                          body[i1].xi[i_1]:=dx+Rdd2*cos(phi0+j1*phi_step);
                          body[i1].zi[i_1]:=dz+Rdd2*sin(phi0+j1*phi_step);

                       end;



                       angle_calc(phi0,  body[id].xC, body[id].zC,  dx, dz);

                       Rdd2:=sqrt((body[id].xC-dx)*(body[id].xC-dx)+(body[id].zC-dz)*(body[id].zC-dz));
                       body[i1].xC:=dx+Rdd2*cos(phi0+j1*phi_step);
                       body[i1].zC:=dz+Rdd2*sin(phi0+j1*phi_step);
                       body[i1].sxC:=FloatToStr(body[i1].xC);
                       body[i1].szC:=FloatToStr(body[i1].zC);

                       xmin2:=1.0e30;
                       zmin2:=1.0e30;
                       xmax2:=-1.0e30;
                       zmax2:=-1.0e30;
                       xavg:=0.0;
                       zavg:=0.0;

                       for i_1:=0 to body[id].nsizei-1 do
                       begin
                          xavg:= xavg+body[i1].xi[i_1];
                          zavg:= zavg+body[i1].zi[i_1];
                          if (body[i1].xi[i_1]<xmin2) then
                          begin
                              xmin2:=body[i1].xi[i_1];
                          end;
                          if (body[i1].xi[i_1]>xmax2) then
                          begin
                              xmax2:=body[i1].xi[i_1];
                          end;
                           if (body[i1].zi[i_1]<zmin2) then
                          begin
                              zmin2:=body[i1].zi[i_1];
                          end;
                          if (body[i1].zi[i_1]>zmax2) then
                          begin
                              zmax2:=body[i1].zi[i_1];
                          end;
                       end;
                       xavg:=xavg/body[id].nsizei;
                       zavg:=zavg/body[id].nsizei;
                       body[i1].xS:=xmin2;
                       body[i1].zS:=zmin2;
                       body[i1].xE:=xmax2;
                       body[i1].zE:=zmax2;
                       body[i1].sxS:=FloatToStr(xmin2);
                       body[i1].szS:=FloatToStr(zmin2);
                       body[i1].sxE:=FloatToStr(xmax2);
                       body[i1].szE:=FloatToStr(zmax2);

                       // copy
                       body[i1].syS:=body[id].syS;
                       body[i1].syE:=body[id].syE;
                       body[i1].syC:=body[id].syC;
                       body[i1].yS:=body[id].yS;
                       body[i1].yE:=body[id].yE;
                       body[i1].yC:=body[id].yC;



                   end;
               3 : begin

                       // YZ
                       yavg:=0.0;
                       zavg:=0.0;
                       for i_1:=0 to body[id].nsizei-1 do
                       begin
                          yavg:= yavg + body[id].yi[i_1];
                          zavg:= zavg + body[id].zi[i_1];
                       end;
                       yavg:=yavg/body[id].nsizei;
                       zavg:=zavg/body[id].nsizei;
                       xavg:=body[id].xi[0];
                       Rdd:= sqrt((yavg-dy)*(yavg-dy)+(zavg-dz)*(zavg-dz));
                       phi_step:=2.0*3.141/ (lb-1-lold1+2);

                       b_polygon_y:=true;
                       b_polygon_z:=true;
                       SetLength(body[i1].yi,body[id].nsizei);
                       SetLength(body[i1].zi,body[id].nsizei);

                       for i_1:=0 to body[id].nsizei-1 do
                       begin
                          Rdd2:= sqrt((body[id].zi[i_1]-dz)*(body[id].zi[i_1]-dz)+
                          (body[id].yi[i_1]-dy)*(body[id].yi[i_1]-dy));


                          angle_calc(phi0,  body[id].yi[i_1], body[id].zi[i_1],  dy, dz);

                          body[i1].yi[i_1]:=dy+Rdd2*cos(phi0+j1*phi_step);
                          body[i1].zi[i_1]:=dz+Rdd2*sin(phi0+j1*phi_step);

                          //phi0:=arctan((body[id].zi[i_1]-dz)/(body[id].yi[i_1]-dy));
                          //body[i1].zi[i_1]:=dz+Rdd2*cos(phi0+j1*phi_step);
                          //body[i1].yi[i_1]:=dy+Rdd2*sin(phi0+j1*phi_step);
                       end;


                       angle_calc(phi0,  body[id].yC, body[id].zC,  dy, dz);

                       Rdd2:=sqrt((body[id].yC-dy)*(body[id].yC-dy)+(body[id].zC-dz)*(body[id].zC-dz));
                       body[i1].yC:=dy+Rdd2*cos(phi0+j1*phi_step);
                       body[i1].zC:=dz+Rdd2*sin(phi0+j1*phi_step);
                       body[i1].syC:=FloatToStr(body[i1].yC);
                       body[i1].szC:=FloatToStr(body[i1].zC);

                       zmin2:=1.0e30;
                       ymin2:=1.0e30;
                       zmax2:=-1.0e30;
                       ymax2:=-1.0e30;
                       zavg:=0.0;
                       yavg:=0.0;

                       for i_1:=0 to body[id].nsizei-1 do
                       begin
                          zavg:= zavg + body[i1].zi[i_1];
                          yavg:= yavg + body[i1].yi[i_1];
                          if (body[i1].zi[i_1]<zmin2) then
                          begin
                              zmin2:=body[i1].zi[i_1];
                          end;
                          if (body[i1].zi[i_1]>zmax2) then
                          begin
                              zmax2:=body[i1].zi[i_1];
                          end;
                           if (body[i1].yi[i_1]<ymin2) then
                          begin
                              ymin2:=body[i1].yi[i_1];
                          end;
                          if (body[i1].yi[i_1]>ymax2) then
                          begin
                              ymax2:=body[i1].yi[i_1];
                          end;
                       end;
                       zavg:=zavg/body[id].nsizei;
                       yavg:=yavg/body[id].nsizei;
                       body[i1].zS:=zmin2;
                       body[i1].yS:=ymin2;
                       body[i1].zE:=zmax2;
                       body[i1].yE:=ymax2;
                       body[i1].szS:=FloatToStr(zmin2);
                       body[i1].syS:=FloatToStr(ymin2);
                       body[i1].szE:=FloatToStr(zmax2);
                       body[i1].syE:=FloatToStr(ymax2);
                      
                       // copy
                       body[i1].sxS:=body[id].sxS;
                       body[i1].sxE:=body[id].sxE;
                       body[i1].sxC:=body[id].sxC;
                       body[i1].xS:=body[id].xS;
                       body[i1].xE:=body[id].xE;
                       body[i1].xC:=body[id].xC;

                   end;
            end;

         end
         else
         begin


            if (bdxchange) then
            begin
               if (not bdxconst) then
               begin
                  // параметризованное пользователем значение
                  bOk:=true;
                  // Prism
                  body[i1].sxS:=body[id].sxS+'+'+IntToStr(j1)+'*('+spdx+')';
                  body[i1].sxE:=body[id].sxE+'+'+IntToStr(j1)+'*('+spdx+')';
                  if (bOk) then body[i1].xS:=FormVariables.my_real_convert(body[i1].sxS,bOk);
                  if (bOk) then body[i1].xE:=FormVariables.my_real_convert(body[i1].sxE,bOk);
                  // Cylinder
                  body[i1].sxC:=body[id].sxC+'+'+IntToStr(j1)+'*('+spdx+')';
                  if (bOk) then body[i1].xC:=FormVariables.my_real_convert(body[i1].sxC,bOk);
                end
                  else
                begin
                   // числовое значение
                   // Cylinder
                   sforval:='';
                   sforval:=StringReplace(body[id].sxC,',','.',[rfReplaceAll]);
                   val(sforval,dmbuf,code);
                   // val(body[id].sxC,dmbuf,code);
                   if (code=0) then
                   begin
                      // обе константы
                      body[i1].xC:=body[id].xC+j1*dx;
                      body[i1].sxC:=FloatToStr(body[i1].xC);
                   end
                    else
                   begin
                      dmbuf:=j1*dx;
                      if (dmbuf>0.0) then
                      begin
                         body[i1].sxC:=body[id].sxC+'+'+FloatToStr(dmbuf);
                         bOk:=true;
                         body[i1].xC:=FormVariables.my_real_convert(body[i1].sxC,bOk);
                      end
                        else
                      begin
                         body[i1].sxC:=body[id].sxC+'-'+FloatToStr(abs(dmbuf));
                         bOk:=true;
                         body[i1].xC:=FormVariables.my_real_convert(body[i1].sxC,bOk);
                      end;
                    end;

                    // polygon
                    SetLength(body[i1].xi,body[id].nsizei);
                    for i_1:=0 to body[id].nsizei-1 do
                    begin
                       body[i1].xi[i_1]:=body[id].xi[i_1]+j1*dx;
                    end;
                    b_polygon_x:=true;

                    // Prism
                    sforval:='';
                    sforval:=StringReplace(body[id].sxS,',','.',[rfReplaceAll]);
                    val(sforval,dmbuf,code);
                    // val(body[id].sxS,dmbuf,code);
                    if (code=0) then
                    begin
                       // обе константы
                       body[i1].xS:=body[id].xS+j1*dx;
                       body[i1].sxS:=FloatToStr(body[i1].xS);
                    end
                      else
                    begin
                       dmbuf:=j1*dx;
                       if (dmbuf>0.0) then
                       begin
                          body[i1].sxS:=body[id].sxS+'+'+FloatToStr(dmbuf);
                          bOk:=true;
                          body[i1].xS:=FormVariables.my_real_convert(body[i1].sxS,bOk);
                       end
                        else
                       begin
                          body[i1].sxS:=body[id].sxS+'-'+FloatToStr(abs(dmbuf));
                          bOk:=true;
                          body[i1].xS:=FormVariables.my_real_convert(body[i1].sxS,bOk);
                       end;
                    end;

                    sforval:='';
                    sforval:=StringReplace(body[id].sxE,',','.',[rfReplaceAll]);
                    val(sforval,dmbuf,code);
                    //val(body[id].sxE,dmbuf,code);
                    if (code=0) then
                    begin
                       // обе константы
                       body[i1].xE:=body[id].xE+j1*dx;
                       body[i1].sxE:=FloatToStr(body[i1].xE);
                    end
                     else
                    begin
                       // слева параметризованная величина а справа константа.
                       dmbuf:=j1*dx;
                       if (dmbuf>0.0) then
                       begin
                          body[i1].sxE:=body[id].sxE+'+'+FloatToStr(dmbuf);
                          bOk:=true;
                          body[i1].xE:=FormVariables.my_real_convert(body[i1].sxE,bOk);
                       end
                        else
                       begin
                          body[i1].sxE:=body[id].sxE+'-'+FloatToStr(abs(dmbuf));
                          bOk:=true;
                          body[i1].xE:=FormVariables.my_real_convert(body[i1].sxE,bOk);
                       end;
                    end;
                end;
            end
             else
            begin
               // по этой оси размеры копии остаются такими же как и размеры оригинала.
               // Prism
               body[i1].sxS:=body[id].sxS;
               body[i1].sxE:=body[id].sxE;
               body[i1].xS:=body[id].xS;
               body[i1].xE:=body[id].xE;
               // Cylinder
               body[i1].sxC:=body[id].sxC;
               body[i1].xC:=body[id].xC;
               // polygon
               SetLength(body[i1].xi,body[id].nsizei);
               for i_1:=0 to body[id].nsizei-1 do
               begin
                  body[i1].xi[i_1]:=body[id].xi[i_1];
               end;
               b_polygon_x:=true;
            end;

            if (bdychange) then
            begin
               if (not bdyconst) then
               begin
                  // параметризованное пользователем значение
                  bOk:=true;
                  // Prism
                  body[i1].syS:=body[id].syS+'+'+IntToStr(j1)+'*('+spdy+')';
                  body[i1].syE:=body[id].syE+'+'+IntToStr(j1)+'*('+spdy+')';
                  if (bOk) then body[i1].yS:=FormVariables.my_real_convert(body[i1].syS,bOk);
                  if (bOk) then body[i1].yE:=FormVariables.my_real_convert(body[i1].syE,bOk);
                  // Cylinder
                  body[i1].syC:=body[id].syC+'+'+IntToStr(j1)+'*('+spdy+')';
                  if (bOk) then body[i1].yC:=FormVariables.my_real_convert(body[i1].syC,bOk);
               end
                else
               begin
                  // числовое значение
                  // Cylinder
                  sforval:='';
                  sforval:=StringReplace(body[id].syC,',','.',[rfReplaceAll]);
                  val(sforval,dmbuf,code);
                  //val(body[id].syC,dmbuf,code);
                  if (code=0) then
                  begin
                     // обе константы
                     body[i1].yC:=body[id].yC+j1*dy;
                     body[i1].syC:=FloatToStr(body[i1].yC);
                  end
                    else
                  begin
                     dmbuf:=j1*dy;
                     if (dmbuf>0.0) then
                     begin
                        body[i1].syC:=body[id].syC+'+'+FloatToStr(dmbuf);
                        bOk:=true;
                        body[i1].yC:=FormVariables.my_real_convert(body[i1].syC,bOk);
                     end
                      else
                     begin
                        body[i1].syC:=body[id].syC+'-'+FloatToStr(abs(dmbuf));
                        bOk:=true;
                        body[i1].yC:=FormVariables.my_real_convert(body[i1].syC,bOk);
                     end;
                  end;

                  // polygon
                  SetLength(body[i1].yi,body[id].nsizei);
                  for i_1:=0 to body[id].nsizei-1 do
                  begin
                     body[i1].yi[i_1]:=body[id].yi[i_1]+j1*dy;
                  end;
                  b_polygon_y:=true;

                  // Prism
                  sforval:='';
                  sforval:=StringReplace(body[id].syS,',','.',[rfReplaceAll]);
                  val(sforval,dmbuf,code);
                  //val(body[id].syS,dmbuf,code);
                  if (code=0) then
                  begin
                     // обе константы
                     body[i1].yS:=body[id].yS+j1*dy;
                     body[i1].syS:=FloatToStr(body[i1].yS);
                  end
                   else
                  begin
                     dmbuf:=j1*dy;
                     if (dmbuf>0.0) then
                     begin
                        body[i1].syS:=body[id].syS+'+'+FloatToStr(dmbuf);
                        bOk:=true;
                        body[i1].yS:=FormVariables.my_real_convert(body[i1].syS,bOk);
                     end
                      else
                     begin
                        body[i1].syS:=body[id].syS+'-'+FloatToStr(abs(dmbuf));
                        bOk:=true;
                        body[i1].yS:=FormVariables.my_real_convert(body[i1].syS,bOk);
                     end;
                  end;

                  sforval:='';
                  sforval:=StringReplace(body[id].syE,',','.',[rfReplaceAll]);
                  val(sforval,dmbuf,code);
                  //val(body[id].syE,dmbuf,code);
                  if (code=0) then
                  begin
                     // обе константы
                     body[i1].yE:=body[id].yE+j1*dy;
                     body[i1].syE:=FloatToStr(body[i1].yE);
                  end
                   else
                  begin
                     // слева параметризованная величина а справа константа.
                     dmbuf:=j1*dy;
                     if (dmbuf>0.0) then
                     begin
                        body[i1].syE:=body[id].syE+'+'+FloatToStr(dmbuf);
                        bOk:=true;
                        body[i1].yE:=FormVariables.my_real_convert(body[i1].syE,bOk);
                     end
                      else
                     begin
                        body[i1].syE:=body[id].syE+'-'+FloatToStr(abs(dmbuf));
                        bOk:=true;
                        body[i1].yE:=FormVariables.my_real_convert(body[i1].syE,bOk);
                     end;
                  end;
               end;
            end
             else
            begin
               // по этой оси размеры копии остаются такими же как и размеры оригинала.
               // Prism
               body[i1].syS:=body[id].syS;
               body[i1].syE:=body[id].syE;
               body[i1].yS:=body[id].yS;
               body[i1].yE:=body[id].yE;
               // Cylinder
               body[i1].syC:=body[id].syC;
               body[i1].yC:=body[id].yC;

               // polygon
               SetLength(body[i1].yi,body[id].nsizei);
               for i_1:=0 to body[id].nsizei-1 do
               begin
                  body[i1].yi[i_1]:=body[id].yi[i_1];
               end;
               b_polygon_y:=true;
            end;

            if (bdzchange) then
            begin
               if (not bdzconst) then
               begin
                  // параметризованное пользователем значение
                  bOk:=true;
                  // Prism
                  body[i1].szS:=body[id].szS+'+'+IntToStr(j1)+'*('+spdz+')';
                  body[i1].szE:=body[id].szE+'+'+IntToStr(j1)+'*('+spdz+')';
                  if (bOk) then body[i1].zS:=FormVariables.my_real_convert(body[i1].szS,bOk);
                  if (bOk) then body[i1].zE:=FormVariables.my_real_convert(body[i1].szE,bOk);
                  // Cylinder
                  body[i1].szC:=body[id].szC+'+'+IntToStr(j1)+'*('+spdz+')';
                  if (bOk) then body[i1].zC:=FormVariables.my_real_convert(body[i1].szC,bOk);
               end
                else
               begin
                  // числовое значение
                  // Cylinder
                  sforval:='';
                  sforval:=StringReplace(body[id].szC,',','.',[rfReplaceAll]);
                  val(sforval,dmbuf,code);
                  //val(body[id].szC,dmbuf,code);
                  if (code=0) then
                  begin
                     // обе константы
                     body[i1].zC:=body[id].zC+j1*dz;
                     body[i1].szC:=FloatToStr(body[i1].zC);
                  end
                   else
                  begin
                     dmbuf:=j1*dz;
                     if (dmbuf>0.0) then
                     begin
                        body[i1].szC:=body[id].szC+'+'+FloatToStr(dmbuf);
                        bOk:=true;
                        body[i1].zC:=FormVariables.my_real_convert(body[i1].szC,bOk);
                     end
                       else
                     begin
                        body[i1].szC:=body[id].szC+'-'+FloatToStr(abs(dmbuf));
                        bOk:=true;
                        body[i1].zC:=FormVariables.my_real_convert(body[i1].szC,bOk);
                     end;
                  end;


                  // polygon
                  SetLength(body[i1].zi,body[id].nsizei);
                  for i_1:=0 to body[id].nsizei-1 do
                  begin
                     body[i1].zi[i_1]:=body[id].zi[i_1]+j1*dz;
                  end;
                  b_polygon_z:=true;

                  // Prism
                  sforval:='';
                  sforval:=StringReplace(body[id].szS,',','.',[rfReplaceAll]);
                  val(sforval,dmbuf,code);
                  //val(body[id].szS,dmbuf,code);
                  if (code=0) then
                  begin
                     // обе константы
                     body[i1].zS:=body[id].zS+j1*dz;
                     body[i1].szS:=FloatToStr(body[i1].zS);
                  end
                   else
                  begin
                     dmbuf:=j1*dz;
                     if (dmbuf>0.0) then
                     begin
                        body[i1].szS:=body[id].szS+'+'+FloatToStr(dmbuf);
                        bOk:=true;
                        body[i1].zS:=FormVariables.my_real_convert(body[i1].szS,bOk);
                     end
                      else
                     begin
                        body[i1].szS:=body[id].szS+'-'+FloatToStr(abs(dmbuf));
                        bOk:=true;
                        body[i1].zS:=FormVariables.my_real_convert(body[i1].szS,bOk);
                     end;
                  end;

                  sforval:='';
                  sforval:=StringReplace(body[id].szE,',','.',[rfReplaceAll]);
                  val(sforval,dmbuf,code);
                  //val(body[id].szE,dmbuf,code);
                  if (code=0) then
                  begin
                     // обе константы
                     body[i1].zE:=body[id].zE+j1*dz;
                     body[i1].szE:=FloatToStr(body[i1].zE);
                  end
                   else
                  begin
                     // слева параметризованная величина а справа константа.
                    dmbuf:=j1*dz;
                    if (dmbuf>0.0) then
                    begin
                       body[i1].szE:=body[id].szE+'+'+FloatToStr(dmbuf);
                       bOk:=true;
                       body[i1].zE:=FormVariables.my_real_convert(body[i1].szE,bOk);
                    end
                     else
                    begin
                       body[i1].szE:=body[id].szE+'-'+FloatToStr(abs(dmbuf));
                       bOk:=true;
                       body[i1].zE:=FormVariables.my_real_convert(body[i1].szE,bOk);
                    end;
                  end;
               end;
            end
             else
            begin
               // по этой оси размеры копии остаются такими же как и размеры оригинала.
               // Prism
               body[i1].szS:=body[id].szS;
               body[i1].szE:=body[id].szE;
               body[i1].zS:=body[id].zS;
               body[i1].zE:=body[id].zE;
               // Cylinder
               body[i1].szC:=body[id].szC;
               body[i1].zC:=body[id].zC;
               // polygon
               SetLength(body[i1].zi,body[id].nsizei);
               for i_1:=0 to body[id].nsizei-1 do
               begin
                  body[i1].zi[i_1]:=body[id].zi[i_1];
               end;
               b_polygon_z:=true;
            end;

         end;

         // новые блоки имеют наиболее высокий приоритет.
         body[i1].priority:=priority_id;
         priority_id:=priority_id+5;
         body[i1].igeometry_type:=body[id].igeometry_type;
         body[i1].iPlane:=body[id].iPlane;
         body[i1].Hcyl:=body[id].Hcyl;
         body[i1].R_out_cyl:=body[id].R_out_cyl;
         body[i1].R_in_cyl:=body[id].R_in_cyl;
          body[i1].sHcyl:=body[id].sHcyl;
         body[i1].sR_out_cyl:=body[id].sR_out_cyl;
         body[i1].sR_in_cyl:=body[id].sR_in_cyl;
         body[i1].bCylinder2Prism:=body[id].bCylinder2Prism;
         // sector, conoid
         body[i1].R_out_cyl2:=body[id].R_out_cyl2;
         body[i1].R_in_cyl2:=body[id].R_in_cyl2;
         body[i1].sR_out_cyl2:=body[id].sR_out_cyl2;
         body[i1].sR_in_cyl2:=body[id].sR_in_cyl2;
         body[i1].angle_start:=body[id].angle_start;
         body[i1].angle_end:=body[id].angle_end;
         body[i1].sangle_start:=body[id].sangle_start;
         body[i1].sangle_end:=body[id].sangle_end;
         // Polygon
         body[i1].nsizei:=body[id].nsizei;
         body[i1].iPlane_obj2:= body[id].iPlane_obj2;
         if (not(b_polygon_x)) then
         begin
            SetLength(body[i1].xi,body[id].nsizei);
         end;
         if (not(b_polygon_y)) then
         begin
            SetLength(body[i1].yi,body[id].nsizei);
         end;
         if (not(b_polygon_z)) then
         begin
            SetLength(body[i1].zi,body[id].nsizei);
         end;
         SetLength(body[i1].hi,body[id].nsizei);
         for j := 0 to body[id].nsizei-1 do
         begin
            if (not(b_polygon_x)) then
            begin
               body[i1].xi[j]:=body[id].xi[j];
            end;
            if (not(b_polygon_y)) then
            begin
               body[i1].yi[j]:=body[id].yi[j];
            end;
            if (not(b_polygon_z)) then
            begin
               body[i1].zi[j]:=body[id].zi[j];
            end;
            body[i1].hi[j]:=body[id].hi[j];
         end;


         // emissivity:
         body[i1].emissW:=body[id].emissW;
         body[i1].emissE:=body[id].emissE;
         body[i1].emissS:=body[id].emissS;
         body[i1].emissN:=body[id].emissN;
         body[i1].emissB:=body[id].emissB;
         body[i1].emissT:=body[id].emissT;

         body[i1].semissW:=body[id].semissW;
         body[i1].semissE:=body[id].semissE;
         body[i1].semissS:=body[id].semissS;
         body[i1].semissN:=body[id].semissN;
         body[i1].semissB:=body[id].semissB;
         body[i1].semissT:=body[id].semissT;
         body[i1].binternalRadiation:=body[id].binternalRadiation;

         body[i1].imatid:=body[id].imatid; // привязка к свойствам материала
         body[i1].itype:=body[id].itype;
         // Фиксация боковой стенки цилиндра для задач Механики.
         body[i1].CylinderFixed:=body[id].CylinderFixed;
         //body[i1].power:=body[id].power;
         //body[i1].spower:=body[id].spower; // не забываем при копировании копировать символьную мощность тепловыделения в блоке
         body[i1].n_power:=body[id].n_power;
         SetLength(body[i1].temp_power, body[i1].n_power);
         SetLength(body[i1].arr_power, body[i1].n_power);
         SetLength(body[i1].arr_s_power, body[i1].n_power);
         for i_4 := 0 to body[i1].n_power-1 do
         begin
            body[i1].temp_power[i_4]:= body[id].temp_power[i_4];
            body[i1].arr_power[i_4]:=body[id].arr_power[i_4];
            body[i1].arr_s_power[i_4]:=body[id].arr_s_power[i_4];
         end;
         // стиль зависимости мощности тепловыделения в блоке от времени.
         body[i1].ipower_time_depend:=body[id].ipower_time_depend;
         // копируем также цвет и прозрачность.
         body[i1].redcolor:=body[id].redcolor;
         body[i1].greencolor:=body[id].greencolor;
         body[i1].bluecolor:=body[id].bluecolor;
         body[i1].transparency:=body[id].transparency;
         body[i1].dcol:=body[id].dcol;
         body[i1].BodyLineWidth:=body[id].BodyLineWidth;
         // Копирование объекта происходит на уровне юниона в котоый включён родительский объект.
         if (bCabinet) then
         begin
            body[i1].iunion:=idunion;
         end
         else
         begin
            body[i1].iunion:=myassembles[idunion+i1-lold1-1].identifire;
         end;
         // результат копирования обязательно должен быть виден.
         body[id].bvisible:=True;
         body[i1].bvisible:=true;


         inc(icb);
         //body[i1].name:='block'+IntToStr(icb);
         //body[i1].name:=body[id].name+'_'+IntToStr(j_4);
         // Защита от совпадения имён:
         // Сделано и протестировано 14 января 2017.
         scur_name:=Trim(body[id].name+'_'+IntToStr(j_4));
         scur_name2:=scur_name;
         bOk_conflict_name:=false;
         ikountid:=1;
         while (not(bOk_conflict_name)) do
         begin
            bOk_conflict_name:=true;
            curNodeTree:=MainTreeView.Items.GetFirstNode;
            ilen:=length(scur_name); // сокращает время на вычисление длины.
            while (curNodeTree <> nil) do
            begin
               if ((ilen=length(curNodeTree.Text))and(Pos(curNodeTree.Text,scur_name)=1)) then
               begin
                  // Устраняем конфликт имён.
                  if (ikountid<=9) then
                  begin
                     if ((scur_name[ilen-1]='_') and (ord(scur_name[ilen])-ord('0')=ikountid)) then
                     begin
                        case ikountid of
                           1 : scur_name[ilen]:='1';
                           2 : scur_name[ilen]:='2';
                           3 : scur_name[ilen]:='3';
                           4 : scur_name[ilen]:='4';
                           5 : scur_name[ilen]:='5';
                           6 : scur_name[ilen]:='6';
                           7 : scur_name[ilen]:='7';
                           8 : scur_name[ilen]:='8';
                           9 : scur_name[ilen]:='9';
                        end;
                        IntToStr(ikountid);
                     end
                      else
                     begin
                        scur_name2:=scur_name+'_'+IntToStr(ikountid);
                     end;
                     inc(ikountid);
                  end
                  else
                  begin
                     ikountid:=1;
                     scur_name2:=scur_name+'_'+IntToStr(ikountid);
                     inc(ikountid);
                  end;
                  bOk_conflict_name:=false;
                  break; // досрочный выход сокращает время на сканирование.
               end;
               curNodeTree:=curNodeTree.GetNext;
            end; // while
            scur_name:=scur_name2;
          end;
          // конец защиты от совпадения имён.
          body[i1].name:=scur_name2;

         if (bCabinet) then
         begin
            NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,body[i1].name);
         end
         else
         begin
            // найти асемблес с именем  myassembles[luold+i-lbold].name.
            for i2:=0 to MainTreeView.Items.Count-1 do
            begin
               if ((length(MainTreeView.Items[i2].Text)=length(myassembles[idunion+i1-lold1-1].name)) and (Pos(MainTreeView.Items[i2].Text,myassembles[idunion+i1-lold1-1].name)=1)) then
               begin
                  i2found:=i2;
                  break;
               end;
            end;

            NewNode:=MainTreeView.Items.AddChild(MainTreeView.Items[i2found],body[i1].name);
         end;
         NewNode.ImageIndex:=1;  // номер картинки
         NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен
         NewNode.Text:=body[i1].name;
         inc(j1);
      end;

      // Если мы копируем блок принадлежащий некоторому юниону, то этот блок
      // и все его копии будут принадлежать также этому юниону и все элементы юниона
      // станут видимыми.
      if (bCabinet) then
      begin
         for i1:=1 to (lb-1) do
         begin
            if (body[i1].iunion=idunion) then
            begin
               body[i1].bvisible:=true;
            end;
         end;
         for i1:=0 to ls-1 do
         begin
            if (source[i1].iunion=idunion) then
            begin
               source[i1].bvisible:=true;
            end;
         end;
         for i1:=0 to lw-1 do
         begin
            if (wall[i1].iunion=idunion) then
            begin
               wall[i1].bvisible:=true;
            end;
         end;
         for i1:=0 to lu-1 do
         begin
            if (myassembles[i1].identifire=idunion) then
            begin
               myassembles[i1].bVisible:=True;
               Break;
            end;
         end;
        //myassembles[idunion-1].bVisible:=True; // Возможно можно делать и так.

        //Rotate;
      end;
   end;

end;

// создаёт inum копий источника с идентификатором id.
procedure copysource(id : Integer; idunion : Integer; bCabinet : Boolean);
var
   lold1 : Integer;
   i1, j1 , j_4, i2, i2found : Integer;
   bOk, bOk1 : Boolean;
   sforval, scur_name, scur_name2: String;
   curNodeTree : TTreeNode;
   bOk_conflict_name : Boolean;
begin
   if (id>-1) then
   begin
      lold1:=ls;
      ls:=ls+inum;
      SetLength(source,ls);

      j_4:=0;
      j1:=1;
      for i1:=lold1 to (ls-1) do
      begin

         inc(j_4);
         if (bdxchange) then
         begin
            if (not bdxconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               source[i1].sxS:=source[id].sxS+'+'+IntToStr(j1)+'*('+spdx+')';
               source[i1].sxE:=source[id].sxE+'+'+IntToStr(j1)+'*('+spdx+')';
               if (bOk) then source[i1].xS:=FormVariables.my_real_convert(source[i1].sxS,bOk);
               if (bOk) then source[i1].xE:=FormVariables.my_real_convert(source[i1].sxE,bOk);
            end
             else
            begin
               // числовое значение
               sforval:='';
               sforval:=StringReplace(source[id].sxS,',','.',[rfReplaceAll]);
               val(sforval,dmbuf,code);
               //val(source[id].sxS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  source[i1].xS:=source[id].xS+j1*dx;
                  source[i1].sxS:=FloatToStr(source[i1].xS);
               end
               else
               begin
                  dmbuf:=j1*dx;
                  if (dmbuf>0.0) then
                  begin
                     source[i1].sxS:=source[id].sxS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     source[i1].xS:=FormVariables.my_real_convert(source[i1].sxS,bOk);
                  end
                  else
                  begin
                     source[i1].sxS:=source[id].sxS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     source[i1].xS:=FormVariables.my_real_convert(source[i1].sxS,bOk);
                  end;
               end;

               sforval:='';
               sforval:=StringReplace(source[id].sxE,',','.',[rfReplaceAll]);
               val(sforval,dmbuf,code);
              // val(source[id].sxE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  source[i1].xE:=source[id].xE+j1*dx;
                  source[i1].sxE:=FloatToStr(source[i1].xE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j1*dx;
                  if (dmbuf>0.0) then
                  begin
                     source[i1].sxE:=source[id].sxE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     source[i1].xE:=FormVariables.my_real_convert(source[i1].sxE,bOk);
                  end
                  else
                  begin
                     source[i1].sxE:=source[id].sxE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     source[i1].xE:=FormVariables.my_real_convert(source[i1].sxE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            source[i1].sxS:=source[id].sxS;
            source[i1].sxE:=source[id].sxE;
            source[i1].xS:=source[id].xS;
            source[i1].xE:=source[id].xE;
         end;

         if (bdychange) then
         begin
            if (not bdyconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               source[i1].syS:=source[id].syS+'+'+IntToStr(j1)+'*('+spdy+')';
               source[i1].syE:=source[id].syE+'+'+IntToStr(j1)+'*('+spdy+')';
               if (bOk) then source[i1].yS:=FormVariables.my_real_convert(source[i1].syS,bOk);
               if (bOk) then source[i1].yE:=FormVariables.my_real_convert(source[i1].syE,bOk);
            end
             else
            begin
               // числовое значение
               sforval:='';
               sforval:=StringReplace(source[id].syS,',','.',[rfReplaceAll]);
               val(sforval,dmbuf,code);

               //val(source[id].syS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  source[i1].yS:=source[id].yS+j1*dy;
                  source[i1].syS:=FloatToStr(source[i1].yS);
               end
               else
               begin
                  dmbuf:=j1*dy;
                  if (dmbuf>0.0) then
                  begin
                     source[i1].syS:=source[id].syS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     source[i1].yS:=FormVariables.my_real_convert(source[i1].syS,bOk);
                  end
                  else
                  begin
                     source[i1].syS:=source[id].syS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     source[i1].yS:=FormVariables.my_real_convert(source[i1].syS,bOk);
                  end;
               end;

               sforval:='';
               sforval:=StringReplace(source[id].syE,',','.',[rfReplaceAll]);
               val(sforval,dmbuf,code);
               //val(source[id].syE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  source[i1].yE:=source[id].yE+j1*dy;
                  source[i1].syE:=FloatToStr(source[i1].yE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j1*dy;
                  if (dmbuf>0.0) then
                  begin
                     source[i1].syE:=source[id].syE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     source[i1].yE:=FormVariables.my_real_convert(source[i1].syE,bOk);
                  end
                  else
                  begin
                     source[i1].syE:=source[id].syE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     source[i1].yE:=FormVariables.my_real_convert(source[i1].syE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            source[i1].syS:=source[id].syS;
            source[i1].syE:=source[id].syE;
            source[i1].yS:=source[id].yS;
            source[i1].yE:=source[id].yE;
         end;

         if (bdzchange) then
         begin
            if (not bdzconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               source[i1].szS:=source[id].szS+'+'+IntToStr(j1)+'*('+spdz+')';
               source[i1].szE:=source[id].szE+'+'+IntToStr(j1)+'*('+spdz+')';
               if (bOk) then source[i1].zS:=FormVariables.my_real_convert(source[i1].szS,bOk);
               if (bOk) then source[i1].zE:=FormVariables.my_real_convert(source[i1].szE,bOk);
            end
             else
            begin
               // числовое значение
                sforval:='';
                sforval:=StringReplace(source[id].szS,',','.',[rfReplaceAll]);
                val(sforval,dmbuf,code);

              // val(source[id].szS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  source[i1].zS:=source[id].zS+j1*dz;
                  source[i1].szS:=FloatToStr(source[i1].zS);
               end
               else
               begin
                  dmbuf:=j1*dz;
                  if (dmbuf>0.0) then
                  begin
                     source[i1].szS:=source[id].szS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     source[i1].zS:=FormVariables.my_real_convert(source[i1].szS,bOk);
                  end
                  else
                  begin
                     source[i1].szS:=source[id].szS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     source[i1].zS:=FormVariables.my_real_convert(source[i1].szS,bOk);
                  end;
               end;


               sforval:='';
               sforval:=StringReplace(source[id].szE,',','.',[rfReplaceAll]);
               val(sforval,dmbuf,code);
              // val(source[id].szE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  source[i1].zE:=source[id].zE+j1*dz;
                  source[i1].szE:=FloatToStr(source[i1].zE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j1*dz;
                  if (dmbuf>0.0) then
                  begin
                     source[i1].szE:=source[id].szE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     source[i1].zE:=FormVariables.my_real_convert(source[i1].szE,bOk);
                  end
                  else
                  begin
                     source[i1].szE:=source[id].szE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     source[i1].zE:=FormVariables.my_real_convert(source[i1].szE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            source[i1].szS:=source[id].szS;
            source[i1].szE:=source[id].szE;
            source[i1].zS:=source[id].zS;
            source[i1].zE:=source[id].zE;
         end;

         source[i1].iPlane:=source[id].iPlane;
         source[i1].Power:=source[id].Power;
         source[i1].spower:=source[id].spower;
         source[i1].itempdep:=source[id].itempdep;
         source[i1].id_table:=source[id].id_table;
         source[i1].soperatingoffsetdrain:=source[id].soperatingoffsetdrain;
         //source[i1].operatingoffsetdrain:=source[id].operatingoffsetdrain;
         bOk1:=true;
         if (bOk1) then source[i1].operatingoffsetdrain:=FormVariables.my_real_convert(source[id].soperatingoffsetdrain,bOk);
         source[i1].family:=source[id].family;
         source[i1].Tamb:=source[id].Tamb;
         source[i1].emissivity:=source[id].emissivity;
         source[i1].ViewFactor:=source[id].ViewFactor;
         source[i1].heat_transfer_coefficient:=source[id].heat_transfer_coefficient;
         source[i1].semissivity:=source[id].semissivity;
         source[i1].sheat_transfer_coefficient:=source[id].sheat_transfer_coefficient;
         source[i1].HF:=source[id].HF;
         source[i1].Vx:=source[id].Vx;
         source[i1].Vy:=source[id].Vy;
         source[i1].Vz:=source[id].Vz;
         source[i1].P:=source[id].P;
         source[i1].bpressure:=source[id].bpressure;
         source[i1].bsymmetry:=source[id].bsymmetry;
         source[i1].bopening:=source[id].bopening;
         source[i1].cabinet_depend:=0;
         if (bCabinet) then
         begin
            source[i1].iunion:=idunion;
         end
         else
         begin
            source[i1].iunion:=myassembles[idunion+i1-lold1-1].identifire;
         end;
         source[i1].bvisible:=True;
         source[id].bvisible:=True;


         inc(ics);
         //source[i1].name:='source'+IntToStr(ics);
         // 23_11_2016
         //source[i1].name:=source[id].name+'_'+IntToStr(j_4);
         // Защита от совпадения имён:
         // Сделано и протестировано 14 января 2017.
         scur_name:=Trim(source[id].name+'_'+IntToStr(j_4));
         scur_name2:=scur_name;
         bOk_conflict_name:=false;
         while (not(bOk_conflict_name)) do
         begin
            bOk_conflict_name:=true;
            curNodeTree:=MainTreeView.Items.GetFirstNode;
            while (curNodeTree <> nil) do
            begin
               if ((length(scur_name)=length(curNodeTree.Text))and(Pos(curNodeTree.Text,scur_name)=1)) then
               begin
                  // Устраняем конфликт имён.
                  scur_name2:=scur_name+'_1';
                  bOk_conflict_name:=false;
               end;
               curNodeTree:=curNodeTree.GetNext;
            end; // while
            scur_name:=scur_name2;
          end;
          // конец защиты от совпадения имён.
           source[i1].name:= scur_name2;

         if (bCabinet) then
         begin
            NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,source[i1].name);
         end
         else
         begin
            // найти асемблес с именем  myassembles[luold+i-lbold].name.
            for i2:=0 to MainTreeView.Items.Count-1 do
            begin
               if ((length(MainTreeView.Items[i2].Text)=length(myassembles[idunion+i1-lold1-1].name)) and (Pos(MainTreeView.Items[i2].Text,myassembles[idunion+i1-lold1-1].name)=1)) then
               begin
                  i2found:=i2;
                  break;
               end;
            end;

            NewNode:=MainTreeView.Items.AddChild(MainTreeView.Items[i2found],source[i1].name);
         end;
         NewNode.ImageIndex:=2;  // номер картинки
         NewNode.SelectedIndex:=2; // номер картинки когда элемент выделен
         NewNode.Text:=source[i1].name;
         inc(j1);
      end;

      if (bCabinet) then
      begin
      // Если мы копируем источник принадлежащий некоторому юниону, то этот источник
      // и все его копии будут принадлежать также этому юниону и все элементы юниона
      // станут видимыми.
      for i1:=1 to (lb-1) do
      begin
         if (body[i1].iunion=idunion) then
         begin
            body[i1].bvisible:=true;
         end;
      end;
      for i1:=0 to ls-1 do
      begin
         if (source[i1].iunion=idunion) then
         begin
            source[i1].bvisible:=true;
         end;
      end;
      for i1:=0 to lw-1 do
      begin
         if (wall[i1].iunion=idunion) then
         begin
            wall[i1].bvisible:=true;
         end;
      end;
      for i1:=0 to lu-1 do
      begin
         if (myassembles[i1].identifire=idunion) then
         begin
            myassembles[i1].bVisible:=True;
            Break;
         end;
      end;
      //myassembles[idunion-1].bVisible:=True; // Возможно можно делать и так.

      //RotateSource;
      end;
   end;

end;

// создаёт inum копий стенки с идентификатором id.
procedure copywall(id : Integer; idunion : Integer; bCabinet : Boolean);
var
   lold1 : Integer;
   i1, j1, j_4, i2, i2found : Integer;
   bOk, bOk1 : Boolean;
   sforval, scur_name, scur_name2: String;
   curNodeTree : TTreeNode;
   bOk_conflict_name : Boolean;
begin
   if (id>-1) then
   begin
      lold1:=lw;
      lw:=lw+inum;
      SetLength(wall,lw);

      j_4:=0;
      j1:=1;
      for i1:=lold1 to (lw-1) do
      begin
         inc(j_4);

         if (bdxchange) then
         begin
            if (not bdxconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               wall[i1].sxS:=wall[id].sxS+'+'+IntToStr(j1)+'*('+spdx+')';
               wall[i1].sxE:=wall[id].sxE+'+'+IntToStr(j1)+'*('+spdx+')';
               if (bOk) then wall[i1].xS:=FormVariables.my_real_convert(wall[i1].sxS,bOk);
               if (bOk) then wall[i1].xE:=FormVariables.my_real_convert(wall[i1].sxE,bOk);
            end
             else
            begin
               // числовое значение

               sforval:='';
               sforval:=StringReplace(wall[id].sxS,',','.',[rfReplaceAll]);
               val(sforval,dmbuf,code);
               //val(wall[id].sxS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  wall[i1].xS:=wall[id].xS+j1*dx;
                  wall[i1].sxS:=FloatToStr(wall[i1].xS);
               end
               else
               begin
                  dmbuf:=j1*dx;
                  if (dmbuf>0.0) then
                  begin
                     wall[i1].sxS:=wall[id].sxS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     wall[i1].xS:=FormVariables.my_real_convert(wall[i1].sxS,bOk);
                  end
                   else
                  begin
                     wall[i1].sxS:=wall[id].sxS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     wall[i1].xS:=FormVariables.my_real_convert(wall[i1].sxS,bOk);
                  end;
               end;

               sforval:='';
               sforval:=StringReplace(wall[id].sxE,',','.',[rfReplaceAll]);
               val(sforval,dmbuf,code);
               //val(wall[id].sxE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  wall[i1].xE:=wall[id].xE+j1*dx;
                  wall[i1].sxE:=FloatToStr(wall[i1].xE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j1*dx;
                  if (dmbuf>0.0) then
                  begin
                     wall[i1].sxE:=wall[id].sxE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     wall[i1].xE:=FormVariables.my_real_convert(wall[i1].sxE,bOk);
                  end
                  else
                  begin
                     wall[i1].sxE:=wall[id].sxE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     wall[i1].xE:=FormVariables.my_real_convert(wall[i1].sxE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            wall[i1].sxS:=wall[id].sxS;
            wall[i1].sxE:=wall[id].sxE;
            wall[i1].xS:=wall[id].xS;
            wall[i1].xE:=wall[id].xE;
         end;

         if (bdychange) then
         begin
            if (not bdyconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               wall[i1].syS:=wall[id].syS+'+'+IntToStr(j1)+'*('+spdy+')';
               wall[i1].syE:=wall[id].syE+'+'+IntToStr(j1)+'*('+spdy+')';
               if (bOk) then wall[i1].yS:=FormVariables.my_real_convert(wall[i1].syS,bOk);
               if (bOk) then wall[i1].yE:=FormVariables.my_real_convert(wall[i1].syE,bOk);
            end
             else
            begin
               // числовое значение
               sforval:='';
               sforval:=StringReplace(wall[id].syS,',','.',[rfReplaceAll]);
               val(sforval,dmbuf,code);
               //val(wall[id].syS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  wall[i1].yS:=wall[id].yS+j1*dy;
                  wall[i1].syS:=FloatToStr(wall[i1].yS);
               end
                else
               begin
                  dmbuf:=j1*dy;
                  if (dmbuf>0.0) then
                  begin
                     wall[i1].syS:=wall[id].syS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     wall[i1].yS:=FormVariables.my_real_convert(wall[i1].syS,bOk);
                  end
                  else
                  begin
                     wall[i1].syS:=wall[id].syS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     wall[i1].yS:=FormVariables.my_real_convert(wall[i1].syS,bOk);
                  end;
               end;

               sforval:='';
               sforval:=StringReplace(wall[id].syE,',','.',[rfReplaceAll]);
               val(sforval,dmbuf,code);
               //val(wall[id].syE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  wall[i1].yE:=wall[id].yE+j1*dy;
                  wall[i1].syE:=FloatToStr(wall[i1].yE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j1*dy;
                  if (dmbuf>0.0) then
                  begin
                     wall[i1].syE:=wall[id].syE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     wall[i1].yE:=FormVariables.my_real_convert(wall[i1].syE,bOk);
                  end
                  else
                  begin
                     wall[i1].syE:=wall[id].syE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     wall[i1].yE:=FormVariables.my_real_convert(wall[i1].syE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            wall[i1].syS:=wall[id].syS;
            wall[i1].syE:=wall[id].syE;
            wall[i1].yS:=wall[id].yS;
            wall[i1].yE:=wall[id].yE;
         end;

         if (bdzchange) then
         begin
            if (not bdzconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               wall[i1].szS:=wall[id].szS+'+'+IntToStr(j1)+'*('+spdz+')';
               wall[i1].szE:=wall[id].szE+'+'+IntToStr(j1)+'*('+spdz+')';
               if (bOk) then wall[i1].zS:=FormVariables.my_real_convert(wall[i1].szS,bOk);
               if (bOk) then wall[i1].zE:=FormVariables.my_real_convert(wall[i1].szE,bOk);
            end
             else
            begin
               // числовое значение

               sforval:='';
               sforval:=StringReplace(wall[id].szS,',','.',[rfReplaceAll]);
               val(sforval,dmbuf,code);
               //val(wall[id].szS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  wall[i1].zS:=wall[id].zS+j1*dz;
                  wall[i1].szS:=FloatToStr(wall[i1].zS);
               end
               else
               begin
                  dmbuf:=j1*dz;
                  if (dmbuf>0.0) then
                  begin
                     wall[i1].szS:=wall[id].szS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     wall[i1].zS:=FormVariables.my_real_convert(wall[i1].szS,bOk);
                  end
                  else
                  begin
                     wall[i1].szS:=wall[id].szS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     wall[i1].zS:=FormVariables.my_real_convert(wall[i1].szS,bOk);
                  end;
               end;

               sforval:='';
               sforval:=StringReplace(wall[id].szE,',','.',[rfReplaceAll]);
               val(sforval,dmbuf,code);
               //val(wall[id].szE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  wall[i1].zE:=wall[id].zE+j1*dz;
                  wall[i1].szE:=FloatToStr(wall[i1].zE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j1*dz;
                  if (dmbuf>0.0) then
                  begin
                     wall[i1].szE:=wall[id].szE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     wall[i1].zE:=FormVariables.my_real_convert(wall[i1].szE,bOk);
                  end
                  else
                  begin
                     wall[i1].szE:=wall[id].szE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     wall[i1].zE:=FormVariables.my_real_convert(wall[i1].szE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            wall[i1].szS:=wall[id].szS;
            wall[i1].szE:=wall[id].szE;
            wall[i1].zS:=wall[id].zS;
            wall[i1].zE:=wall[id].zE;
         end;

         wall[i1].ithermal_stress_boundary_condition:=wall[id].ithermal_stress_boundary_condition;
         wall[i1].xForce:=wall[id].xForce;
         wall[i1].yForce:=wall[id].yForce;
         wall[i1].zForce:=wall[id].zForce;
         wall[i1].iPlane:=wall[id].iPlane;
         wall[i1].Power:=wall[id].Power;
         wall[i1].family:=wall[id].family;
         wall[i1].Tamb:=wall[id].Tamb;
         wall[i1].emissivity:=wall[id].emissivity;
         wall[i1].ViewFactor:=wall[id].ViewFactor;
         wall[i1].heat_transfer_coefficient:=wall[id].heat_transfer_coefficient;
         wall[i1].semissivity:=wall[id].semissivity;
         wall[i1].sheat_transfer_coefficient:=wall[id].sheat_transfer_coefficient;
         wall[i1].HF:=wall[id].HF;
         wall[i1].Vx:=wall[id].Vx;
         wall[i1].Vy:=wall[id].Vy;
         wall[i1].Vz:=wall[id].Vz;
         wall[i1].P:=wall[id].P;
         wall[i1].bpressure:=wall[id].bpressure;
         wall[i1].bsymmetry:=wall[id].bsymmetry;
         wall[i1].bopening:=wall[id].bopening;
         wall[i1].cabinet_depend:=0;
         if (bCabinet) then
         begin
            wall[i1].iunion:=idunion;
         end
         else
         begin
            wall[i1].iunion:=myassembles[idunion+i1-lold1-1].identifire;
         end;
         wall[i1].bvisible:=True;
         wall[id].bvisible:=True;


         inc(icw);
         //wall[i1].name:='wall'+IntToStr(icw);
         // 23_11_2016.
         //wall[i1].name:=wall[id].name+'_'+IntToStr(j_4);
         // Защита от совпадения имён:
         // Сделано и протестировано 14 января 2017.
         scur_name:=Trim(wall[id].name+'_'+IntToStr(j_4));
         scur_name2:=scur_name;
         bOk_conflict_name:=false;
         while (not(bOk_conflict_name)) do
         begin
            bOk_conflict_name:=true;
            curNodeTree:=MainTreeView.Items.GetFirstNode;
            while (curNodeTree <> nil) do
            begin
               if ((length(scur_name)=length(curNodeTree.Text))and(Pos(curNodeTree.Text,scur_name)=1)) then
               begin
                  // Устраняем конфликт имён.
                  scur_name2:=scur_name+'_1';
                  bOk_conflict_name:=false;
               end;
               curNodeTree:=curNodeTree.GetNext;
            end; // while
            scur_name:=scur_name2;
          end;
          // конец защиты от совпадения имён.
           wall[i1].name:= scur_name2;

         if (bCabinet) then
         begin
            NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,wall[i1].name);
         end
           else
         begin
            // найти асемблес с именем  myassembles[luold+i-lbold].name.
            for i2:=0 to MainTreeView.Items.Count-1 do
            begin
               if ((length(MainTreeView.Items[i2].Text)=length(myassembles[idunion+i1-lold1-1].name)) and (Pos(MainTreeView.Items[i2].Text,myassembles[idunion+i1-lold1-1].name)=1)) then
               begin
                  i2found:=i2;
                  break;
               end;
            end;

            NewNode:=MainTreeView.Items.AddChild(MainTreeView.Items[i2found],wall[i1].name);
         end;
         NewNode.ImageIndex:=3; // номер картинки
         NewNode.SelectedIndex:=3; // номер картинки когда элемент выделен
         NewNode.Text:=wall[i1].name;
         inc(j1);
      end;

      if (bCabinet) then
      begin
      // Если мы копируем источник принадлежащий некоторому юниону, то этот источник
      // и все его копии будут принадлежать также этому юниону и все элементы юниона
      // станут видимыми.
      for i1:=1 to (lb-1) do
      begin
         if (body[i1].iunion=idunion) then
         begin
            body[i1].bvisible:=true;
         end;
      end;
      for i1:=0 to ls-1 do
      begin
         if (source[i1].iunion=idunion) then
         begin
            source[i1].bvisible:=true;
         end;
      end;
      for i1:=0 to lw-1 do
      begin
         if (wall[i1].iunion=idunion) then
         begin
            wall[i1].bvisible:=true;
         end;
      end;
      for i1:=0 to lu-1 do
      begin
         if (myassembles[i1].identifire=idunion) then
         begin
            myassembles[i1].bVisible:=True;
            Break;
         end;
      end;
      //myassembles[idunion-1].bVisible:=True; // Возможно можно делать и так.

      //RotateWall;
      end;
   end;
end;

// рекурсивная процедура копирования uniona и всего его содержимого.
procedure recursion_copy_ass(icopyassid : Integer; inumberass : Integer);
var
    i1, j1, i2, i2found : Integer;
    lwold1, iobl, lsold1, lbold1, luold1, imaxuident1 : Integer;
begin
   for i1:=0 to inumberass-1 do
       begin
          if (myassembles[i1].iunionparent=icopyassid) then
          begin
             // У union`а есть дочерние union`ы
             luold1:=lu;
             imaxuident1:=-1;
             for i2:=0 to lu-1 do
             begin
                if (myassembles[i2].identifire>imaxuident1) then
                begin
                   imaxuident1:=myassembles[i2].identifire;
                end;
             end;
             lu:=lu+inum;
             SetLength(myassembles,lu);
             for j1:=luold1 to lu-1 do
             begin
                myassembles[j1].name:='union'+IntToStr(imaxuident1+j1-luold1+1);
                myassembles[j1].bVisible:=true;
                myassembles[j1].identifire:=imaxuident1+j1-luold1+1;
                myassembles[j1].iunionparent:=inumberass+j1-luold1;
                myassembles[j1].bmesh_assembles_separately:=myassembles[i1].bmesh_assembles_separately;
                // на сколько отстоит граница ассеблеса от границ образующих его элементов на периметре.
                myassembles[j1].xmin:=myassembles[i1].xmin;
                myassembles[j1].xmax:=myassembles[i1].xmax;
                myassembles[j1].ymin:=myassembles[i1].ymin;
                myassembles[j1].ymax:=myassembles[i1].ymax;
                myassembles[j1].zmin:=myassembles[i1].zmin;
                myassembles[j1].zmax:=myassembles[i1].zmax;
                myassembles[j1].sxmin:=myassembles[i1].sxmin;
                myassembles[j1].sxmax:=myassembles[i1].sxmax;
                myassembles[j1].symin:=myassembles[i1].symin;
                myassembles[j1].symax:=myassembles[i1].symax;
                myassembles[j1].szmin:=myassembles[i1].szmin;
                myassembles[j1].szmax:=myassembles[i1].szmax;
                myassembles[j1].inxloc:=myassembles[i1].inxloc;
                myassembles[j1].inyloc:=myassembles[i1].inyloc;
                myassembles[j1].inzloc:=myassembles[i1].inzloc;

                // Найти нужный union и сделать у него дочерний.
                // найти асемблес с именем  myassembles[luold+j-luold1].name.
                for i2:=0 to MainTreeView.Items.Count-1 do
                begin
                   if ((length(MainTreeView.Items[i2].Text)=length(myassembles[inumberass+j1-luold1].name)) and (Pos(MainTreeView.Items[i2].Text,myassembles[inumberass+j1-luold1].name)=1)) then
                   begin
                      i2found:=i2;
                      break;
                   end;
                end;

                NewNode:=MainTreeView.Items.AddChild(MainTreeView.Items[i2found],myassembles[j1].name);
                NewNode.ImageIndex:=4; // номер картинки
                NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
                NewNode.Text:=myassembles[j1].name;
             end;

              // Создаём копии блоков принадлежащих юниону iunionid.
              lbold1:=lb; // запоминаем первоначальное число блоков, до копирования.
              for iobl:=1 to lbold1-1 do
              begin
                 if (body[iobl].iunion=myassembles[i1].identifire) then
                 begin
                    if (iobl>-1) then
                    begin
                       copyblock(iobl,luold1+1,false);
                    end;
                 end;
              end;

              // Создаём копии источников тепла принадлежащих юниону iunionid.
              lsold1:=ls; // запоминаем первоначальное число источников тепла, до копирования.
              for iobl:=0 to lsold1-1 do
              begin
                 if (source[iobl].iunion=myassembles[i1].identifire) then
                 begin
                    if (iobl>-1) then
                    begin
                       copysource(iobl,luold1+1,false);
                    end;
                 end;
              end;

              // Создаём копии стенок принадлежащих юниону iunionid.
              lwold1:=lw; // запоминаем первоначальное число стенок, до копирования.
              for iobl:=0 to lwold1-1 do
              begin
                 if (wall[iobl].iunion=myassembles[i1].identifire) then
                 begin
                    if (iobl>-1) then
                    begin
                       copywall(iobl,luold1+1,false);
                    end;
                 end;
              end;

              // рекурсивный вызов
              recursion_copy_ass(i1,luold1);
          end;
       end;

end;

begin
   bcontinuecopy:=true; // по умолчанию всё впорядке и нужно осуществить операцию копирования.


   // копированию подвергается только один объект,
   // имя данного объекта выделено в дереве.
   scop:=MainTreeView.Selected.Text;

   // по всем блокам
   iob:=-1;
   for i:=1 to (lb-1) do
   begin
      if ( (length(body[i].name) = length(scop)) and (Pos(body[i].name,scop)=1)) then
      begin
         iob:=i; // номер копируемого блока
      end;
   end;

    // Если выделено объединение то мы его тоже можем вращать.
    // По всем объединениям.
   iobass:=-1;
   for i:=0 to (lu-1) do
   begin
      if ( (length(myassembles[i].name) = length(scop)) and (Pos(myassembles[i].name,scop)=1)) then
      begin
         iobass:=i; // номер копируемого асемблеса
      end;
   end;
   if (iobass>-1) then
   begin
      FormCopyObject.CheckBoxRotate.Visible:=true;
   end;

    // копирование элементов
   FormCopyObject.ShowModal;

   if (FormCopyObject.CheckBoxRotate.Checked) then
   begin
      // Вращаем
      if (bon_rotate_polygon) then
    begin
       if (iob>-1) then
       begin
          if ((body[iob].igeometry_type=2)or(body[iob].igeometry_type=1)) then
          begin
             // Найденный блок полигон 2 или цилиндр 1. Можно вращать в плоскости полигона,
             // вокруг заданного центра.

          end
           else
          begin
             // Вращать нельзя.
            // FormCopyObject.CheckBoxRotate.Visible:=false;
            FormSelectPlaneRotation.ShowModal;
            body[iob].igeometry_type:=2;
            body[iob].iPlane_obj2:=FormSelectPlaneRotation.ComboBoxPlane.ItemIndex+1;
            body[iob].nsizei:=4;
            SetLength(body[iob].xi,body[iob].nsizei);
            SetLength(body[iob].yi,body[iob].nsizei);
            SetLength(body[iob].zi,body[iob].nsizei);
            SetLength(body[iob].hi,body[iob].nsizei);
            case FormSelectPlaneRotation.ComboBoxPlane.ItemIndex of
             0 : // XY
             begin
                for i := 0 to body[iob].nsizei do
                begin
                   body[iob].hi[i]:=body[iob].zE-body[iob].zS;
                   body[iob].zi[i]:=body[iob].zS;
                end;
                // Против часовой стрелки.
                body[iob].xi[0]:=body[iob].xS;
                body[iob].yi[0]:=body[iob].yS;
                body[iob].xi[1]:=body[iob].xE;
                body[iob].yi[1]:=body[iob].yS;
                body[iob].xi[2]:=body[iob].xE;
                body[iob].yi[2]:=body[iob].yE;
                body[iob].xi[3]:=body[iob].xS;
                body[iob].yi[3]:=body[iob].yE;
             end;
             1 : // XZ
             begin
                 for i := 0 to body[iob].nsizei do
                begin
                   body[iob].hi[i]:=body[iob].yE-body[iob].yS;
                   body[iob].yi[i]:=body[iob].yS;
                end;
                // Против часовой стрелки.
                body[iob].xi[0]:=body[iob].xS;
                body[iob].zi[0]:=body[iob].zS;
                body[iob].xi[1]:=body[iob].xE;
                body[iob].zi[1]:=body[iob].zS;
                body[iob].xi[2]:=body[iob].xE;
                body[iob].zi[2]:=body[iob].zE;
                body[iob].xi[3]:=body[iob].xS;
                body[iob].zi[3]:=body[iob].zE;
             end;
             2 : // YZ
             begin
                for i := 0 to body[iob].nsizei do
                begin
                   body[iob].hi[i]:=body[iob].xE-body[iob].xS;
                   body[iob].xi[i]:=body[iob].xS;
                end;
                // Против часовой стрелки.
                body[iob].yi[0]:=body[iob].yS;
                body[iob].zi[0]:=body[iob].zS;
                body[iob].yi[1]:=body[iob].yE;
                body[iob].zi[1]:=body[iob].zS;
                body[iob].yi[2]:=body[iob].yE;
                body[iob].zi[2]:=body[iob].zE;
                body[iob].yi[3]:=body[iob].yS;
                body[iob].zi[3]:=body[iob].zE;

             end;
            end;

          end;
          FormCopyObject.CheckBoxRotate.Visible:=true;
      end
       else
      begin
         // Вращать нельзя.
         FormCopyObject.CheckBoxRotate.Visible:=false;
      end;
    end
     else
    begin
        // Вращать нельзя.
        FormCopyObject.CheckBoxRotate.Visible:=false;
    end;

   end;


   if (bcontinuecopy) then
   begin

      // нужно ли осуществлять копирование
      // вдоль соответствующей координатной оси
      bdxchange:=true;  // по умолчанию надо везде.
      bdychange:=true;
      bdzchange:=true;
      // если bdxconst=true то величина перемещения
      // является непараметризованной константой. Иначе
      // величина перемещения является параметризованной величиной.
      bdxconst:=true;
      bdyconst:=true;
      bdzconst:=true;

      sforval:='';
      sforval:=StringReplace(spdx,',','.',[rfReplaceAll]);
      val(sforval,dx,code);
      //val(spdx,dx,code);
      if (code=0) then
      begin
         // константа
         bdxconst:=true;
         if (abs(dx)<1e-10) then
         begin
            spdx:='';
            bdxchange:=false; //вдоль оси Ох передвигать ненужно.
         end
          else
         begin
            bdxchange:=true; // нужно сдвигать вдоль оси Ох
         end;
      end
       else
      begin
         bdxconst:=false; // параметризованное смещение по оси X
         bdxchange:=true; // нужно сдвигать вдоль оси Ох
      end;

      sforval:='';
      sforval:=StringReplace(spdy,',','.',[rfReplaceAll]);
      val(sforval,dy,code);
      //val(spdy,dy,code);
      if (code=0) then
      begin
         // константа
         bdyconst:=true;
         if (abs(dy)<1e-10) then
         begin
            spdy:='';
            bdychange:=false; //вдоль оси Оy передвигать ненужно.
         end
          else
         begin
            bdychange:=true; // нужно сдвигать вдоль оси Оy
         end;
      end
       else
      begin
         bdyconst:=false; // параметризованное смещение по оси Y
         bdychange:=true; // нужно сдвигать вдоль оси Оy
      end;

      sforval:='';
      sforval:=StringReplace(spdz,',','.',[rfReplaceAll]);
      val(sforval,dz,code);
      //val(spdz,dz,code);
      if (code=0) then
      begin
         // константа
         bdzconst:=true;
         if (abs(dz)<1e-10) then
         begin
            spdz:='';
            bdzchange:=false; //вдоль оси Оz передвигать ненужно.
         end
          else
         begin
            bdzchange:=true; // нужно сдвигать вдоль оси Оz
         end;
      end
       else
      begin
         bdzconst:=false; // параметризованное смещение по оси Z
         bdzchange:=true; // нужно сдвигать вдоль оси Оz
      end;


      if (iob>-1) then
      begin
         copyblock(iob,body[iob].iunion,true);
      end;


      // по всем источникам
      iob:=-1;
      for i:=0 to (ls-1) do
      begin
         if ( (length(source[i].name) = length(scop)) and (Pos(source[i].name,scop)=1)) then
         begin
            iob:=i; // номер копируемого  источника
         end;
      end;
      if (iob>-1) then
      begin
         copysource(iob,source[iob].iunion,true);
      end;

      // по всем стенкам
      iob:=-1;
      for i:=0 to (lw-1) do
      begin
         if ( (length(wall[i].name) = length(scop)) and (Pos(wall[i].name,scop)=1)) then
         begin
            if (wall[i].cabinet_depend=0) then
            begin
               iob:=i; // номер копируемой стенки
            end;
         end;
      end;
      if (iob>-1) then
      begin
         copywall(iob, wall[iob].iunion,true);
      end;




   // По всем объединениям.
   iobass:=-1;
   for i:=0 to (lu-1) do
   begin
      if ( (length(myassembles[i].name) = length(scop)) and (Pos(myassembles[i].name,scop)=1)) then
      begin
         iobass:=i; // номер копируемого асемблеса
      end;
   end;
   if (iobass>-1) then
   begin

      if (bon_rotate_polygon) then
      begin
          if (FormCopyObject.CheckBoxRotate.Checked) then
          begin
             FormSelectPlaneRotation.ShowModal;
          end;
         FormCopyObject.CheckBoxRotate.Visible:=true;


       end
        else
       begin
          // Вращать нельзя.
          FormCopyObject.CheckBoxRotate.Visible:=false;
       end;


       iunionid:=myassembles[iobass].identifire;
       //iunionid:=iobass+1; // номер выделеннного юниона.   НЕВЕРНО !!!

       luold:=lu;
       imaxuident:=-1;
       for i:=0 to lu-1 do
       begin
          if (myassembles[i].identifire>imaxuident) then
          begin
             imaxuident:=myassembles[i].identifire;
          end;
       end;
       lu:=lu+inum;
       SetLength(myassembles,lu);
       for i:=luold to lu-1 do
       begin
          myassembles[i].name:='union'+IntToStr(imaxuident+i-luold+1);
          myassembles[i].bVisible:=true;
          myassembles[i].identifire:=imaxuident+i-luold+1;
          myassembles[i].iunionparent:=myassembles[iobass].iunionparent;
          myassembles[i].bmesh_assembles_separately:=myassembles[iobass].bmesh_assembles_separately;
          // на сколько отстоит граница ассеблеса от границ образующих его элементов на периметре.
          myassembles[i].xmin:=myassembles[iobass].xmin;
          myassembles[i].xmax:=myassembles[iobass].xmax;
          myassembles[i].ymin:=myassembles[iobass].ymin;
          myassembles[i].ymax:=myassembles[iobass].ymax;
          myassembles[i].zmin:=myassembles[iobass].zmin;
          myassembles[i].zmax:=myassembles[iobass].zmax;
          myassembles[i].sxmin:=myassembles[iobass].sxmin;
          myassembles[i].sxmax:=myassembles[iobass].sxmax;
          myassembles[i].symin:=myassembles[iobass].symin;
          myassembles[i].symax:=myassembles[iobass].symax;
          myassembles[i].szmin:=myassembles[iobass].szmin;
          myassembles[i].szmax:=myassembles[iobass].szmax;
          myassembles[i].inxloc:=myassembles[iobass].inxloc;
          myassembles[i].inyloc:=myassembles[iobass].inyloc;
          myassembles[i].inzloc:=myassembles[iobass].inzloc;

          NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,myassembles[i].name);
          NewNode.ImageIndex:=4; // номер картинки
          NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
          NewNode.Text:=myassembles[i].name;
       end;




       // Создаём копии блоков принадлежащих юниону iunionid.
       lbold:=lb; // запоминаем первоначальное число блоков, до копирования.
       for iob:=1 to lbold-1 do
       begin
          if (body[iob].iunion=iunionid) then
          begin
              if (iob>-1) then
              begin

                 if (bon_rotate_polygon) then
                 begin
                   if (FormCopyObject.CheckBoxRotate.Checked) then
                   begin

                    if ((body[iob].igeometry_type=2)or
                        (body[iob].igeometry_type=1)) then
                        begin
                          // Найденный блок полигон 2 или цилиндр 1. Можно вращать в плоскости полигона,
                          // вокруг заданного центра.

                        end
                         else
                        begin
                           // Вращать нельзя.
                           // FormCopyObject.CheckBoxRotate.Visible:=false;

                          body[iob].igeometry_type:=2;
                          body[iob].iPlane_obj2:=FormSelectPlaneRotation.ComboBoxPlane.ItemIndex+1;
                          body[iob].nsizei:=4;
                         SetLength(body[iob].xi,body[iob].nsizei);
                         SetLength(body[iob].yi,body[iob].nsizei);
                         SetLength(body[iob].zi,body[iob].nsizei);
                         SetLength(body[iob].hi,body[iob].nsizei);
                         case FormSelectPlaneRotation.ComboBoxPlane.ItemIndex of
                           0 : // XY
                               begin
                                  for i := 0 to body[iob].nsizei do
                                  begin
                                     body[iob].hi[i]:=body[iob].zE-body[iob].zS;
                                     body[iob].zi[i]:=body[iob].zS;
                                  end;
                                  // Против часовой стрелки.
                                  body[iob].xi[0]:=body[iob].xS;
                                  body[iob].yi[0]:=body[iob].yS;
                                  body[iob].xi[1]:=body[iob].xE;
                                  body[iob].yi[1]:=body[iob].yS;
                                  body[iob].xi[2]:=body[iob].xE;
                                  body[iob].yi[2]:=body[iob].yE;
                                  body[iob].xi[3]:=body[iob].xS;
                                  body[iob].yi[3]:=body[iob].yE;
                               end;
                            1 : // XZ
                               begin
                                 for i := 0 to body[iob].nsizei do
                                 begin
                                    body[iob].hi[i]:=body[iob].yE-body[iob].yS;
                                    body[iob].yi[i]:=body[iob].yS;
                                 end;
                                 // Против часовой стрелки.
                                 body[iob].xi[0]:=body[iob].xS;
                                 body[iob].zi[0]:=body[iob].zS;
                                 body[iob].xi[1]:=body[iob].xE;
                                 body[iob].zi[1]:=body[iob].zS;
                                 body[iob].xi[2]:=body[iob].xE;
                                 body[iob].zi[2]:=body[iob].zE;
                                 body[iob].xi[3]:=body[iob].xS;
                                 body[iob].zi[3]:=body[iob].zE;
                               end;
                            2 : // YZ
                               begin
                                  for i := 0 to body[iob].nsizei do
                                  begin
                                     body[iob].hi[i]:=body[iob].xE-body[iob].xS;
                                     body[iob].xi[i]:=body[iob].xS;
                                  end;
                                 // Против часовой стрелки.
                                 body[iob].yi[0]:=body[iob].yS;
                                 body[iob].zi[0]:=body[iob].zS;
                                 body[iob].yi[1]:=body[iob].yE;
                                 body[iob].zi[1]:=body[iob].zS;
                                 body[iob].yi[2]:=body[iob].yE;
                                 body[iob].zi[2]:=body[iob].zE;
                                 body[iob].yi[3]:=body[iob].yS;
                                 body[iob].zi[3]:=body[iob].zE;

                               end;
                         end;

                        end;

                   end;
                 end;

                 copyblock(iob,luold+1,false);
              end;
           end;
       end;

       // Создаём копии источников тепла принадлежащих юниону iunionid.
       lsold:=ls; // запоминаем первоначальное число источников тепла, до копирования.
       for iob:=0 to lsold-1 do
       begin
          if (source[iob].iunion=iunionid) then
          begin
              if (iob>-1) then
              begin
                 copysource(iob,luold+1,false);
              end;
          end;
       end;

       // Создаём копии стенок принадлежащих юниону iunionid.
       lwold:=lw; // запоминаем первоначальное число стенок, до копирования.
       for iob:=0 to lwold-1 do
       begin
          if (wall[iob].iunion=iunionid) then
          begin
              if (iob>-1) then
              begin
                 copywall(iob,luold+1,false);
              end;
          end;
       end;

       // копирование объединений дочерних к iobass юниону включая
       // всё их наполнение и все их дочерние юнионы.
       recursion_copy_ass(iobass, luold);

   end;


   ReadyPaint;
   Render;  // прорисовка изменений


   end; // bcontinuecopy=true;
end;

// вид в плоскости YZ  pos_X
procedure TLaplas.SpeedButtonplanepos_XClick(Sender: TObject);
begin
   // 22 апреля 2015
   // Alf - вращение вокруг оси Oz.
   // Bet - вращение вокруг вектора лежащего в плоскости XOY и направленного под 45 градусов к оси абсцисс.
   // Ориентация YOZ.
   Alf:=0.0;
   Bet:=-0.5*3.1415926;
   Gam:=0.0;
   cosAlf:=cos(Alf);
   cosBet:=cos(Bet);
   sinAlf:=sin(Alf);
   sinBet:=sin(Bet);
end;

// вид в плоскости XZ  pos_Y
procedure TLaplas.SpeedButtonplanepos_YClick(Sender: TObject);
begin
   // plane XZ
   //Alf:=-1.57;
   //Bet:=0.0;
   // 22 апреля 2015
   // Alf - вращение вокруг оси Oz.
   // Bet - вращение вокруг вектора лежащего в плоскости XOY и направленного под 45 градусов к оси абсцисс.
   // Ориентация XOZ.
   Alf:=-0.5*3.141592;
   Bet:=0.0;
   Gam:=0.0;
   cosAlf:=cos(Alf);
   cosBet:=cos(Bet);
   sinAlf:=sin(Alf);
   sinBet:=sin(Bet);
   //ShowMessage('impossible'); // более корректно чем непредсказуемое поведение.
end;

// устанавливаем плоскость XY pos_Z
procedure TLaplas.SpeedButtonplanepos_ZClick(Sender: TObject);
begin
   // 22 апреля 2015
   // Alf - вращение вокруг оси Oz.
   // Bet - вращение вокруг вектора лежащего в плоскости XOY и направленного под 45 градусов к оси абсцисс.
   // Ориентация XOY.
   Alf:=0.0;  //X
   Bet:=3.1415926;  // Y
   Gam:=0.0;  // Z
   cosAlf:=cos(Alf);
   cosBet:=cos(Bet);
   sinAlf:=sin(Alf);
   sinBet:=sin(Bet);
end;

// вид в плоскости YZ  neg_X
procedure TLaplas.SpeedButtonplaneneg_XClick(Sender: TObject);
begin
   // plane YZ
   //Alf:=0.0;
   //Bet:=0.0;
   // 22 апреля 2015
   // Alf - вращение вокруг оси Oz.
   // Bet - вращение вокруг вектора лежащего в плоскости XOY и направленного под 45 градусов к оси абсцисс.
   // Ориентация YOZ.
   Alf:=0.0;
   Bet:=0.5*3.1415926;
   Gam:=0.0;
   cosAlf:=cos(Alf);
   cosBet:=cos(Bet);
   sinAlf:=sin(Alf);
   sinBet:=sin(Bet);
end;

// вид в плоскости XZ  neg_Y
procedure TLaplas.SpeedButtonplaneneg_YClick(Sender: TObject);
begin
    // plane XZ
   // 22 апреля 2015
   // Alf - вращение вокруг оси Oz.
   // Bet - вращение вокруг вектора лежащего в плоскости XOY и направленного под 45 градусов к оси абсцисс.
   // Ориентация XOZ.
   Alf:=-0.5*3.141592;
   Bet:=0.0;
   Gam:=3.1415926;
   cosAlf:=cos(Alf);
   cosBet:=cos(Bet);
   sinAlf:=sin(Alf);
   sinBet:=sin(Bet);
end;

// Создаёт обединение
procedure TLaplas.SpeedButtonUnionClick(Sender: TObject);
var
    NewNode : TTreeNode;
    sname, nameselect : String;
    i : Integer;
    bfound : Boolean;
begin
   // нумерация объединений начинается с 1.
   // этот номер служит идентификатором объединения.
   inc(lu);
   SetLength(myassembles,lu);
   sname:='union'+IntToStr(lu);
   myassembles[lu-1].name:=sname; // присваиваем имя объекту.
   // идентификаторы объединений присваиваются последовательно начиная с 1.
   myassembles[lu-1].identifire:=lu;
   myassembles[lu-1].bVisible:=True; // по умолчанию все элементы объединения видимы.

   // Для блочно структурированной сетки.
   myassembles[lu-1].bmesh_assembles_separately:=false;
   myassembles[lu-1].xmin:=0.0;
   myassembles[lu-1].xmax:=0.0;
   myassembles[lu-1].ymin:=0.0;
   myassembles[lu-1].ymax:=0.0;
   myassembles[lu-1].zmin:=0.0;
   myassembles[lu-1].zmax:=0.0;
   // в параметризованном виде :
   myassembles[lu-1].sxmin:='0.0';
   myassembles[lu-1].sxmax:='0.0';
   myassembles[lu-1].symin:='0.0';
   myassembles[lu-1].symax:='0.0';
   myassembles[lu-1].szmin:='0.0';
   myassembles[lu-1].szmax:='0.0';
   // информация о сеточном разбиении.
   myassembles[lu-1].inxloc:=23;
   myassembles[lu-1].inyloc:=23;
   myassembles[lu-1].inzloc:=23;

   // Правильно определяем родительский юнион.
   myassembles[lu-1].iunionparent:=-1;  // кабинет.
   if (MainTreeView.Selected<>nil) then
   begin
      nameselect:=MainTreeView.Selected.Text;
      bfound:=false;
      for i:=0 to lb-1 do
      begin
         if ((length(nameselect)=length(body[i].name))and(Pos(nameselect,body[i].name)=1)) then
         begin
            myassembles[lu-1].iunionparent:=body[i].iunion-1;
            bfound:=true;
            break;
         end;
      end;
      if (not(bfound)) then
      begin
         for i:=0 to ls-1 do
         begin
            if ((length(nameselect)=length(source[i].name))and(Pos(nameselect,source[i].name)=1)) then
            begin
               myassembles[lu-1].iunionparent:=source[i].iunion-1;
               bfound:=true;
               break;
            end;
         end;
      end;
      if (not(bfound)) then
      begin
         for i:=0 to lw-1 do
         begin
            if ((length(nameselect)=length(wall[i].name))and(Pos(nameselect,wall[i].name)=1)) then
            begin
               myassembles[lu-1].iunionparent:=wall[i].iunion-1;
               bfound:=true;
               break;
            end;
         end;
      end;
      if (not(bfound)) then
      begin
         for i:=0 to lu-2 do
         begin
            if ((length(nameselect)=length(myassembles[i].name))and(Pos(nameselect,myassembles[i].name)=1)) then
            begin
               myassembles[lu-1].iunionparent:=myassembles[i].iunionparent;
               bfound:=true;
               break;
            end;
         end;
      end;
   end
    else
   begin
      // Выделяем корень.
      MainTreeView.Items[0].Selected:=true;
   end;

   NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,sname);
   NewNode.ImageIndex:=4; // номер картинки
   NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
   NewNode.Text:=sname;
end;

procedure TLaplas.SpeedButtonVisualizationMabagementClick(Sender: TObject);
var
  bupdatecbbview : Boolean;
begin
   case ComboBoxlength.ItemIndex of
     0 : begin
         // m
         labelunits1.Caption:='m';
         labelunits2.Caption:='m';
     end;
      1 : begin
         // mm
         labelunits1.Caption:='mm';
         labelunits2.Caption:='mm';
     end;
      2 : begin
         // um
         labelunits1.Caption:='um';
         labelunits2.Caption:='um';
     end;
   end;

   //GroupBoxVisualizationManagment.Visible:=true;
   bupdatecbbview:=GroupBoxVisualizationManagment.Visible;
   GroupBoxVisualizationManagment.Visible:=not(GroupBoxVisualizationManagment.Visible);
   GroupBoxMoveObject.Visible:=false;
   // Делаем невидимыми параметры визуализации.
   GroupBoxLight.Visible:=False;
   grplitht1.Visible:=False;
   grpmaterial_litht_prop.Visible:=False;
   if (bupdatecbbview) then
   begin
      cbbViewChange(Sender);
   end
    else
   begin
      edtvalue.Visible:=False; // не предлагаем изо сечения.
      ComboBoxplaneViewSelect.Visible:=false;
      lblvalue.Visible:=False;
   end;
end;

// Задаёт сеточные параметры
procedure TLaplas.Mesh1Click(Sender: TObject);
begin
   // Задаёт параметры расчётной сетки
   // инициализация :
   MeshForm.CBinx.ItemIndex:=Laplas.inx-4;
   MeshForm.CBiny.ItemIndex:=Laplas.iny-4;
   MeshForm.CBinz.ItemIndex:=Laplas.inz-4;
   MeshForm.edtmaxsizeratio.Text:=FloatToStr(Laplas.etalon_max_size_ratio);
   MeshForm.Editmaxsizeratio2.Text:=FloatToStr(Laplas.etalon_max_size_ratio2);
   // Вызов :
   MeshForm.ShowModal;
end;

// Задаёт силу тяжести
{*
// Теперь (с 6 августа 2016года) этот модуль не используется
// и его функции взяла на себя EGDForm.
procedure TLaplas.Gravity1Click(Sender: TObject);
begin
   // Задаёт силу тяжести
   // инициализация :
   FormGravity.Egx.Text:=FloatToStr(Laplas.gx);
   FormGravity.Egy.Text:=FloatToStr(Laplas.gy);
   FormGravity.Egz.Text:=FloatToStr(Laplas.gz);
   // Вызов :
   FormGravity.ShowModal;
end;
*}



procedure TLaplas.Variables1Click(Sender: TObject);
var
    i : Integer;
begin
    // Вызываем форму задания и редактирования переменных.
    for i:=1 to FormVariables.StringGridVariables.RowCount-1 do
    begin
       if (i-1>=ivar) then
       begin
          FormVariables.StringGridVariables.Cells[1,i]:='';
          FormVariables.StringGridVariables.Cells[2,i]:='';
       end
       else
       begin
          FormVariables.StringGridVariables.Cells[1,i]:=parametric[i-1].svar;
          FormVariables.StringGridVariables.Cells[2,i]:=parametric[i-1].sval;
       end;
    end;
    //FormVariables.ShowModal;
    FormRenameVar.Label2.Visible:=false;
    FormRenameVar.LabelConflictName.Visible:=false;
    FormRenameVar.LabelRenamecandidate.Caption:='Project variable rename candidate.';
    FormVariables.Show;
    FormRenameVar.Label2.Visible:=true;
    FormRenameVar.LabelConflictName.Visible:=true;
    FormRenameVar.LabelRenamecandidate.Caption:='List of the names project variables.';
end;

// Вызывает калькулятор расчёта углов видимости.
// скрипт.
procedure TLaplas.ViewFactorCalculatorClick(Sender: TObject);
begin
   FormViewFactors.ShowModal;
end;


procedure TLaplas.WriteStartSolutionOLD(Sender: TObject);
var
    f, freport : TStringList; // переменная типа объект TStringList
    s,subx,sub,s1, s2 : String; // текущая рабочая строка
    i, i1,i2,i3, i_4, j : Integer; // текущий номер блока или источника при записи
    xavg, yavg, zavg, powertri : Real;
    Sc : Real; // мощность тепловыделения на единицу объёма
   // StartupInfo:TStartupInfo;  // Устаревший синтаксис.
    //ProcessInfo:TProcessInformation;
    fmin, fmax : Real;
    starttime, endtime, deltatime : TTime;
    ShellInfo : TShellExecuteInfo;
    ExitCode : DWORD;
    QuoteParams : Boolean;
    bmodelcheck, bmodelcheck_cab_hollow : Boolean; // проверка на наличие теплоотвода.
    bOk : Boolean;
    irun : Integer;
    // Для сортировки блоков по приоритетам.
  //  isort, jsort : Integer;
   // body_change : TBody;
   cab_geom, cab_geom2 : Visible_Line;
   lw_dec : Integer;
   myDate : TDateTime;
   checkFLUIDtoSOLID, bf7 : Boolean;
   // для преобразования Цилиндра в призму.
   xS1, yS1, zS1, xE1, yE1, zE1 : Real;
   iu_number, i5 :   Integer;
   xSass, xEass, ySass, yEass, zSass, zEass : Real;

   procedure FixHeap(root : Integer; m : TBody; bound : Integer; iadd : Integer);
var
   vacant, largerChild : Integer;
   lCadd, lCadd1 : Integer;
begin
   vacant:=root;
   while (2*vacant<=bound) do
   begin
      largerChild:=2*vacant;
      lCadd:=largerChild+iadd;
      lCadd1:=lCadd+1;
      if ((largerChild<bound)and(body[lCadd1].priority>body[lCadd].priority)) then
      begin
         inc(largerChild);
      end;
      lCadd:=largerChild+iadd;
      if (m.priority>body[lCadd].priority) then
      begin
        break;
      end
      else
      begin
         body[vacant+iadd]:=body[lCadd];
         vacant:=largerChild;
      end;
   end;
   body[vacant+iadd]:=m;
end;

// Пирамидальная сортировка.
procedure HeapSort(first,last : Integer);
var
   body_buf : TBody;
   i9 : Integer;
begin
   for i9 := ((last-first+1) div 2) downto 1 do
   begin
      FixHeap(i9,body[i9+first-1],last-first+1,first-1);
   end;
   for i9 := last-first+1 downto 2 do
     begin
       body_buf:=body[first];
       FixHeap(1,body[i9+first-1],i9-1,first-1);
       body[i9+first-1]:=body_buf;
     end;
end;


begin
    checkFLUIDtoSOLID:=false; // 8 september 2017 не трогать т.к. усторело.

   if (brun) then
   begin
      // мы спрашиваем снять ли защиту от уже запущенного вычисления.
      irun:=Application.MessageBox('The calculation is already running. Ok-LOCK, Cancel-Recalculation.','Clean history and restart.',mb_OkCancel);
      if (irun=1) then
      begin
         brun:=false;
      end;
   end
   else
   begin
      // Установка переменой TDateTime в полное значение даты и времени:
      // 09/02/2000 в 01:02:03.004 (.004 миллисекунд).
      //myDate:=EncodeDataTime(2000, 2, 9, 1, 2, 3, 4);
      myDate:=Now;
      MainMemo.Lines.Add('solver start '+FormatDateTime('c',myDate));
      freport:=TStringList.Create();
      freport.Add('solver start '+FormatDateTime('c',myDate));
      freport.Add('Project name '+Laplas.Caption);
      freport.Add('');
      freport.SaveToFile('report_temperature.txt');
      freport.Free;
   end;



   if (not(brun)) then
   begin
      brun:=true;

      // Автоматическое переключение на теплопередачу в твёрдом теле с cfd
      // если сила тяжести нулевая а на всех стенках стоит условие прилипания
      // к неподвижной стенке т.е. условие по умолчанию.
      if ((abs(gx)<1.0e-20) and (abs(gy)<1.0e-20) and (abs(gz)<1.0e-20)) then
      begin
         bOk:=true;
         for i := 0 to lw-1 do
         begin
            if ((wall[i].bpressure=false)
            and (wall[i].bopening=false) and
            (abs(wall[i].Vx)<1.0e-20) and
            (abs(wall[i].Vy)<1.0e-20) and
            (abs(wall[i].Vz)<1.0e-20)) then
            begin
               // Выполняется условие прилипания к неподвижной стенке по скорости,
               // т.е. условие по умолчанию.
            end
            else
            begin
               // Это точно НЕ условие по умолчанию по скорости, поэтому
               // нужно решать гидродинамику.
                bOk:=false;
            end;
         end;

         // Включаем теплопередачу в твёрдом теле.
         if (bOk) then
         begin
            // Делаем умное переключение т.к. решаем только уравнение
            // теплопередачи в твёрдом теле.

             // Чисто теплопередача в твёрдом теле.
             if (egddata.iStaticStructural=0) then
             begin
                egddata.imaxflD:=1;
                egddata.itemper:=1; // Метод контрольного объёма
                egddata.myflmod[0].iflow:=0;
             end;
             if (egddata.iStaticStructural=1) then
             begin
                 // Static Structural only
                egddata.imaxflD:=1;
                // Не нужно делать здесь принудительного присваивания.
                // Пользователь уже сделал выбор в интерфейсе выше.
                //egddata.itemper:=0;
                egddata.myflmod[0].iflow:=0;
             end;
         end;
      end;



   //  Проблема теплоотвода в задачах чистой теплопередачи :
   //  Если рассматривать задачу чистой теплопередачи
   //  то в ней необходимо наличие изотермической поверхности иначе задача
   //  неопределена в стационарной постановке (имеется бесконечная температура при наличии)
   //  источников тепла и отсутствии теплоотвода.
   // В задачах вычислительной гидродинамики также чрезвычайно важно наличие
   // стенки на которой задана скорость потока.
   // Есть и более тонкие ситуации но о них позже, т.к. сначала нужно добиться
   // 100% работоспособности простых ситуаций.
   bmodelcheck:=false; // по умолчанию модель не проходит проверку.
   // Проверка правильности размеров объектов модели при типе кбинета hollow.
   // По умолчанию всё корректно.
   bmodelcheck_cab_hollow:=true;


   if (((egddata.imaxflD=0) and (egddata.itemper>0)) or ((egddata.imaxflD=1) and (egddata.itemper>0) and(egddata.myflmod[0].iflow=0))) then
   begin
      // Чистая теплопередача
      // в твёрдом теле.
      if (FormUnsteady.RadioGroup1.ItemIndex=0) then
      begin
         // Стационарный расчёт.
         FormUnsteady.PanelTime.Visible:=false;
      end
      else
      begin
         // Нестационарный расчёт.
         FormUnsteady.PanelTime.Visible:=true;
      end;
      FormUnsteady.RadioGroup1.Visible:=true;

   end
   else
   begin
      // запускаем tecplot 360 в любом случае.
      //FormUnsteady.CheckBoxdonttec360.Checked:=false;
      FormUnsteady.PanelTime.Visible:=false;
      FormUnsteady.RadioGroup1.Visible:=false;
      if (not(bonly_mesh_gen_call)) then
      begin
         // только если это не вызов сеточного генератора.
         FormUnsteady.GroupBoxNumberIterationsSimpleAlgorithm.Visible:=true;
      end
      else
      begin
         FormUnsteady.GroupBoxNumberIterationsSimpleAlgorithm.Visible:=false;
      end;
   end;
   if (bonly_mesh_gen_call) then
   begin
      FormUnsteady.GroupBox1.Top:=5;
      // Только построение расчётной сетки.
      FormUnsteady.PanelTime.Visible:=false;
      FormUnsteady.RadioGroup1.Visible:=false;
      // FormUnsteady.ButtonTimeStepLaw.Visible:=false;
      FormUnsteady.ClientHeight:=180;
      FormUnsteady.Height:=243;
      FormUnsteady.ButtonCalc.Caption:='Meshing start';
   end
    else
   begin
      FormUnsteady.PanelTime.Visible:=true;
      FormUnsteady.RadioGroup1.Visible:=true;
      FormUnsteady.GroupBox1.Top:=215;
      FormUnsteady.ClientHeight:=409;
      FormUnsteady.Height:=448;
      FormUnsteady.ButtonCalc.Top:=163;
      //FormUnsteady.ButtonTimeStepLaw.Visible:=true;
      FormUnsteady.ButtonCalc.Caption:='Calculation start';
      FormUnsteady.ButtonCalc.Visible:=true;
      FormUnsteady.RadioGroup1Click(Sender);
      FormUnsteady.ComboBoxTimeStepChange(Sender);
   end;

   if (not(bVisualization_Management_now)) then
   begin
      FormUnsteady.ShowModal;
   end
   else
   begin
      FormUnsteady.bRunOk:=true;
   end;

    if (FormUnsteady.bRunOk=true) then
    begin
       FormUnsteady.bRunOk:=false;

   starttime:=Now(); // Началор счёта.
   f:=TStringList.Create();


   case ComboBoxlength.ItemIndex of
     0 : begin
            // m
            mlength:=1.0;
         end;
     1 : begin
            // mm
            mlength:=1e-3;
         end;
     2 : begin
            // micron
            mlength:=1e-6;
         end;
   end;

   i2:=0;
   for i1 := 1 to lb-1 do
   begin

      if ((body[i1].itype=1)or(body[i1].itype=2)) then
      begin
         // SOLID or HOLLOW
         inc(i2);
      end;
   end;

   if FormUnsteady.CheckBoxonlysolidvisible.Checked=true then
   begin
       // печатает только твердотельное исполнение.
       // 18.02.2017 если есть хоть один solid block.
       //if ((egddata.imaxflD=1) and (i2>=1)) then
       if (((egddata.imaxflD=0) and (egddata.itemper>0)) or ((egddata.imaxflD=1) and (egddata.itemper>0) and(egddata.myflmod[0].iflow=0))) then
      begin
         // Чистая теплопередача
         // в твёрдом теле.
          // Если сетка грубая Coarse Mesh то твердотельная визуализация
          // даёт сбой т.к. при Coarse Mesh в твёрдом теле лишь одна клетка
          // и такая одноклеточная в толщину структура не образует nvtx
          // состоящий целиком из Solid'ов.
          s:='0 ';
          MainMemo.Lines.Add('Only solid blocks visible translated on all visible.');
          MainMemo.Lines.Add('Because using only thermal model without cfd.');
          FormUnsteady.CheckBoxonlysolidvisible.Checked:=false;
      end
       else
      begin
         s:='1 ';
      end;

   end
    else
   begin
      s:='0 ';
   end;
   s:=s+FloatToStr(mlength)+' '+IntToStr(lmatmax)+' ';
   if (body[0].itype=3) then
   begin
      // Fluid.
      s:=s+IntToStr(lb)+' ';
   end
    else if (body[0].itype=2) then
   begin
       // HOLLOW
       s:=s+IntToStr(lb+1)+' ';
   end;
   s:=s+IntToStr(ls)+' ';
   if (body[0].itype=3) then
   begin
      // Fluid
      s:=s+IntToStr(lw)+' ';
   end
   else if (body[0].itype=2) then
   begin
      // HOLLOW
      // нужно уменьшить счётчик на количество стенок жёстко связанных с кабинетом.
      // поскольку кабинета нет то и стенок жёстко связанных с геометрическими размерами
      // кабинета тоже нет.
      lw_dec:=0;
      for i:=0 to (lw-1) do
      begin
         if (wall[i].cabinet_depend>1) then
         begin
            inc(lw_dec);
         end;
      end;
      s:=s+IntToStr(lw-lw_dec)+' ';
   end;
   s:=s+IntToStr(iltdp);
   s:=s+' '+FloatToStr(gx)+' '+FloatToStr(gy)+' '+FloatToStr(gz)+' ';
   s:=s+IntToStr(inx)+' '+IntToStr(iny)+' '+IntToStr(inz)+' '+FloatToStr(operatingtemperature);

   // заменить все точки в FormSpeedInitialization на запятые.
   s2:=FormSpeedInitialization.EditVx.Text;
   FormSpeedInitialization.EditVx.Text:=StringReplace(s2,',','.',[rfReplaceAll]);

   s2:=FormSpeedInitialization.EditVy.Text;
   FormSpeedInitialization.EditVy.Text:=StringReplace(s2,',','.',[rfReplaceAll]);

   s2:=FormSpeedInitialization.EditVz.Text;
   FormSpeedInitialization.EditVz.Text:=StringReplace(s2,',','.',[rfReplaceAll]);

   // Инициализация начальной скорости.
   s:=s+' '+FormSpeedInitialization.EditVx.Text;
   s:=s+' '+FormSpeedInitialization.EditVy.Text;
   s:=s+' '+FormSpeedInitialization.EditVz.Text;

   if (FormXYPlot.bfirst_zapusk_XYPlot) then
   begin
      if (ls>0) then
      begin
         // Инициализируем геометрическим центром первого источника тепла при его наличии.
         FormXYPlot.EditXo.Text:=FloatToStr(0.5*(source[0].xS+source[0].xE));
         FormXYPlot.EditYo.Text:=FloatToStr(0.5*(source[0].yS+source[0].yE));
         FormXYPlot.EditZo.Text:=FloatToStr(0.5*(source[0].zS+source[0].zE));
         if (ls>1) then
         begin
            if (abs(source[0].xS-source[1].xS)>1.0e-23) then
            begin
               FormXYPlot.ComboBoxdirectional.ItemIndex:=0; // X - directional
            end;
            if (abs(source[0].yS-source[1].yS)>1.0e-23) then
            begin
               FormXYPlot.ComboBoxdirectional.ItemIndex:=1; // Y - directional
            end;
            if (abs(source[0].zS-source[1].zS)>1.0e-23) then
            begin
               FormXYPlot.ComboBoxdirectional.ItemIndex:=2; // Z - directional
            end;
         end;
      end
       else
      begin
         // Инициализируем геометрическим центром кабинета.
         FormXYPlot.EditXo.Text:=FloatToStr(0.5*(body[0].xS+body[0].xE));
         FormXYPlot.EditYo.Text:=FloatToStr(0.5*(body[0].yS+body[0].yE));
         FormXYPlot.EditZo.Text:=FloatToStr(0.5*(body[0].zS+body[0].zE));
      end;
      // Не снимаем флаг первого запуска.
   end;

   // XY-Plot
   // Построение графика Variation Plot с координатами передаваемыми из Delphi-интерфейса.
   s2:=Trim(FormXYPlot.EditXo.Text);
   FormXYPlot.EditXo.Text:=StringReplace(s2,',','.',[rfReplaceAll]);
   if (length(s2)=0) then
   begin
      ShowMessage('Xo XYPlot is empty');
   end;
   s2:=Trim(FormXYPlot.EditYo.Text);
   FormXYPlot.EditYo.Text:=StringReplace(s2,',','.',[rfReplaceAll]);
   if (length(s2)=0) then
   begin
      ShowMessage('Yo XYPlot is empty');
   end;
   s2:=Trim(FormXYPlot.EditZo.Text);
   FormXYPlot.EditZo.Text:=StringReplace(s2,',','.',[rfReplaceAll]);
   if (length(s2)=0) then
   begin
      ShowMessage('Zo XYPlot is empty');
   end;

   // Мы передаём точку через которую проходит линия и направление линии совпадающее
   // с направлением одной из осей декартовой прямоугольной системы координат.
   s:=s+' '+FormXYPlot.EditXo.Text;
   s:=s+' '+FormXYPlot.EditYo.Text;
   s:=s+' '+FormXYPlot.EditZo.Text;
   s:=s+' '+IntToStr(FormXYPlot.ComboBoxdirectional.ItemIndex);


   s:=s+' '+FloatToStr(etalon_max_size_ratio);
   s:=s+' '+FloatToStr(etalon_max_size_ratio2)+' ';
   s:=s+IntToStr(MeshForm.ComboBoxSnapTo.ItemIndex)+' ';


   for i:=0 to (lw-1) do
   begin
      if ((wall[i].family=3) or (wall[i].family=4)) then
      begin
         // Чистая теплопередача
         // в твёрдом теле.

         // На стенке задано нелинейное условие Стефана-Больцмана или Ньютона-Рихмана.
         // Это условие возможно только для твёрдотельной постановки задачи (без гидродинамики).
         // На данный момент 1 мая 2016 с этим условием справляется только РУМБА решатель cl_agl_amg_v0_14.
         // Поэтому здесь будет осуществлён перевод решателя на этот солвер.
         // FormSetting.rgsolver.ItemIndex:=3; // РУМБА решатель.
         // MainMemo.Lines.Add('с граничным условием Ньютона-Рихмана или Стефана-Больцмана на wall стенке ');
         // MainMemo.Lines.Add('на данный момент справляется только РУМБА v0_14 решатель.');
         // MainMemo.Lines.Add('решатель переведён на РУМБА v0_14 алгоритм.');
         // РУМБА 0.14 решатель в случае сбоя пытается справиться с проблемой своими силами
         // не привлекая сторонних решателей.
      end;
   end;

   if (adiabatic_vs_heat_transfer_coeff>0) then
   begin
      if (((egddata.imaxflD=0) and (egddata.itemper>0)) or ((egddata.imaxflD=1) and (egddata.itemper>0) and(egddata.myflmod[0].iflow=0))) then
      begin
         // Чистая теплопередача
         // в твёрдом теле.

         // По умолчанию условие Ньютона Рихмана на всей default границе.
         // Это условие возможно только для твёрдотельной постановки задачи (без гидродинамики).
         // На данный момент 1 мая 2016 с этим условием справляется только РУМБА решатель cl_agl_amg_v0_14.
         // Поэтому здесь будет осуществлён перевод решателя на этот солвер.
         //FormSetting.rgsolver.ItemIndex:=3; // РУМБА решатель.
         //MainMemo.Lines.Add('с граничным условием Ньютона-Рихмана, Стефана-Больцмана,');
         //MainMemo.Lines.Add('смешанным условием (Излучение плюс конвекция) на default границе ');
         //MainMemo.Lines.Add('на данный момент справляется только РУМБА v0_14 решатель.');
         //MainMemo.Lines.Add('решатель переведён на РУМБА v0_14 алгоритм.');
         // РУМБА 0.14 решатель в случае сбоя пытается справиться с проблемой своими силами
         // не привлекая сторонних решателей.
      end
       else
      begin
         // Решаем Навье - Стокса
         // значит это условие на default границе (Ньютона - Рихмана) надо вырубить за ненадобностью.
         // надо выставить адиабатическую стенку.
         // адиабатическая стенка.
          MainMemo.Lines.Add('При решении уравнений Навье-Стокса граничное условие по');
          MainMemo.Lines.Add('умолчанию только адиабатическая стенка.');
         adiabatic_vs_heat_transfer_coeff:=0;
         filmcoefficient:=0.0;
         CabinetForm.ComboBoxFilmcoeff.ItemIndex:=0;
         CabinetForm.EditFilmCoefficient.Text:='0.0';
         CabinetForm.EditFilmCoefficient.Visible:=false;
         CabinetForm.LabelFilmCoefficient.Visible:=false;
         CabinetForm.Label3.Visible:=false;
      end;
   end;

   if (EGDForm.CBFlow.Checked = false) then
   begin
       if (egddata.imaxflD=0) then
      begin
         if (MeshForm.CheckBoxALICE.Checked = true) then
         begin
            if (FormSetting.ComboBoxSolverSetting.ItemIndex=2) then
            begin
               // bicgstab + ADI решатель.
               // не может быть использован на ALICE сетке.
                Laplas.MainMemo.Lines.Add('Do not supported ADI preconditioner in ALICE Mesh.');
                ShowMessage('Do not supported ADI preconditioner in ALICE Mesh. ADI off.  BiCGStab+ILU2 solver on.');
               // Солвер переводится на BiCGStab автоматическим образом.
               FormSetting.ComboBoxSolverSetting.ItemIndex:=0;
            end;
         end;
      end;
   end;

   // Выбор решающего устройства.
   s:=s+IntToStr(FormSetting.ComboBoxSolverSetting.ItemIndex);
   // Static Structural linear equation solver.
   s:=s+' '+IntToStr(FormSetting.ComboBoxStaticStructuralSolverSetting.ItemIndex);
   s:=s+' '+IntToStr(FormSetting.ComboBoxPressureVelocityCoupling.ItemIndex);
   s:=s+' '+IntToStr(FormSetting.ComboBoxFlowSchemePrefix.ItemIndex);  // Prefix схема аппроксимации конвективного члена
   s:=s+' '+IntToStr(FormSetting.ComboBoxFlowScheme.ItemIndex);  // Схема аппроксимации конвективного члена
   s:=s+' '+IntToStr(FormSetting.ComboBoxSchemeTemperature.ItemIndex);  // Схема аппроксимации конвективного члена


   if ((egddata.imaxflD=1) and (egddata.myflmod[0].iflow=1) and (i2>=10)) then
   begin
      // Выбор сеточного генератора
      // при большеразмерной модели обязательный переход на Coarse Mesh генератор.
      // Но только в случае гидродинамического решателя
      // s:=s + ' 2'; // Coarse Mesh.
      // MainMemo.Lines.Add('Model is very big. Mesh generator translated into Coarse Mesh.');
      // Пользователь сам решает какую сетку выбрать.
      s:=s+' '+IntToStr(MeshForm.ComboBoxmeshgen.ItemIndex); // выбор сеточного генератора
   end
    else
   begin
      s:=s+' '+IntToStr(MeshForm.ComboBoxmeshgen.ItemIndex); // выбор сеточного генератора
   end;
   bOk:=true;
      // Теперь конечное время можно параметризовывать через переменную.
      // 0 - стационарная теплопередача в твёрдом теле,
      // 1 - нестационарная теплопередача в твёрдом теле,
      // 2 - сеточный генератор только,
      // 3 - чистая гидродинамика,
      // 3 - гидродинамика совместно с теплопередачей.
      // 5 - Static Structural  (Стационарный температурный солвер №2)
      // 6 - Thermal Stress
      // 7 - Нестационарный температурный солвер №2
      // 8 - подготовка данных к печати только. 5.01.2018
      // 9 - нестационарная гидродинамика возможно с теплопередачей. 14.05.2019
      // 10 - NetWork_T solver
      // 11 - NetWork_T solver unsteady
      if (egddata.itemper=3) then
      begin
         if (bVisualization_Management_now) then
          begin
             //8 - подготовка данных к печати только. 5.01.2018
             s:=s+' 8';
          end
          else
          begin
             if (bonly_mesh_gen_call) then
             begin
               // Отдельный вызов сеточного генератора только.
               s:=s+' 2';
               //bonly_mesh_gen_call:=false;  сделано позже по коду.
             end
              else
             begin
                if (FormUnsteady.RadioGroup1.ItemIndex=1) then
                begin
                   // Нестационарный графовый температурный солвер
                   s:=s+' 11';
                end
                 else
                begin
                   // Стационарный графовый температурный солвер.
                   s:=s+' 10';
                end;
             end;
          end;
      end
       else
      begin

      if (bVisualization_Management_now) then
      begin
         //8 - подготовка данных к печати только. 5.01.2018
         s:=s+' 8';
      end
      else
      begin
         if (bonly_mesh_gen_call) then
         begin
            // Отдельный вызов сеточного генератора только.
            s:=s+' 2';
            //bonly_mesh_gen_call:=false;  сделано позже по коду.
         end
          else
         begin
            if (EGDForm.CBFlow.Checked = false) then
            begin
               if (egddata.iStaticStructural=1) then
               begin
                  if (egddata.itemper>0) then
                  begin
                     // Thermal Stress
                      if (FormUnsteady.RadioGroup1.ItemIndex=1) then
                     begin
                        if (egddata.itemper=1) then
                        begin
                           // Теплопередача на основе метода контрольного объёма.
                           // Нестационарная механика и теплопередача.
                           s:=' 13';
                        end;
                         if (egddata.itemper=2) then
                        begin
                           // Нестационарный температурный солвер   #2 (10,11,2018)
                           s:=s+' 7';
                        end;
                     end
                     else
                     begin
                        // Стационарная механика и теплопередача.
                        s:=s+' 6';
                     end;
                  end
                   else
                  begin
                     // Static Structural
                     if (FormUnsteady.RadioGroup1.ItemIndex=1) then
                     begin
                        s:=s+' 12'; // Нестационарный механический солвер.
                     end
                      else
                     begin
                        // Устарело- Стационарный температурный солвер #2. (10,11,2018)
                        // 14.08.2020
                        s:=s+' 5';  // Стационарный механический солвер.
                     end;
                  end;
               end
                else
               begin

                  if (egddata.imaxflD=1) then
                  begin
                     if ((egddata.itemper>0)and(egddata.myflmod[0].iflow=0)) then
                     begin
                        // Теплопередача в твёрдом теле.
                        s:=s+' '+IntToStr(FormUnsteady.RadioGroup1.ItemIndex); // 1 - Нестационарность или 0 - стационарность.
                     end
                      else
                     begin
                        //  гидродинамика.
                        // Default Structural Mesh
                        if (FormUnsteady.RadioGroup1.ItemIndex=0) then
                        begin
                           // Стационарная гидродинамика.
                           s:=s+' 3';
                        end
                         else
                        begin
                           // 14.05.2019
                           // Нестационарная гидродинамика
                           s:=s+' 9';
                        end;
                     end;
                  end
                   else
                  begin
                     if (FormUnsteady.RadioGroup1.ItemIndex=0) then
                     begin
                        // Стационарная гидродинамика.
                        //  гидродинамика.
                        // Default Structural Mesh
                        s:=s+' 3';
                     end
                      else
                     begin
                        // 14.05.2019
                        // Нестационарная гидродинамика
                        s:=s+' 9';
                     end;
                  end;
               end;
            end
             else
             begin
                //  EGDForm.CBFlow.Checked = true
                // Гидродинамика включена.
                //  гидродинамика.
                // Default Structural Mesh
                if (FormUnsteady.RadioGroup1.ItemIndex=0) then
                begin
                   // Стационарная гидродинамика.
                   //  гидродинамика.
                   // Default Structural Mesh
                   s:=s+' 3';
                end
                 else
                begin
                   // 14.05.2019
                   // Нестационарная гидродинамика
                   s:=s+' 9';
                end;
             end;
         end;
      end;
   end;
   s:=s+' '+IntToStr(FormUnsteady.ComboBoxTimeStep.ItemIndex); // Закон изменения шага по времени.
   s:=s+' '+FloatToStr(glSTL.Factor_a_for_Linear); // Factor (a) for Linear Law.
   s:=s+' '+FloatToStr(glSTL.tau); // длительность импульса.
   s:=s+' '+FloatToStr(glSTL.iQ)+' '; // Скважность.
   // параметры импульсного режима работы для темы АППАРАТ.
   s:=s+FloatToStr(glSTL.m1)+' '+FloatToStr(glSTL.tau1)+' ';
   s:=s+FloatToStr(glSTL.tau2)+' '+FloatToStr(glSTL.tau_pause)+' '+FloatToStr(glSTL.off_multiplyer)+' ';
   s:=s+IntToStr(glSTL.n)+' '+FloatToStr(glSTL.T)+' '+FloatToStr(glSTL.on_time_double_linear);
   s:=s+' '+FloatToStr(FormVariables.my_real_convert(FormUnsteady.EditTime.Text,bOk)); // данные предполагаются корректными.
   s:=s+' '+IntToStr(adiabatic_vs_heat_transfer_coeff)+' '+FloatToStr(filmcoefficient)+' ';  // Условие Ньютона-Рихмана.
   if (EGDForm.CBFlow.Checked = false) then
   begin
      if (egddata.imaxflD=1) then
      begin
         if ((egddata.itemper>0)and(egddata.myflmod[0].iflow=0)) then
         begin
            // Теплопередача в твёрдом теле:
            // Теплопередача в твёрдом теле.
            if (MeshForm.CheckBoxALICE.Checked = false) then
            begin
               // Default Structural Mesh
               s:=s+' 0';
            end
             else
            begin
               // Adaptive Local Refinement Mesh
               s:=s+' 1';
               if (FormSetting.ComboBoxSolverSetting.ItemIndex=2) then
               begin
                  // bicgstab + ADI решатель.
                  // не может быть использован на ALICE сетке.
                  Laplas.MainMemo.Lines.Add('Do not supported ADI preconditioner in ALICE Mesh.');
                  ShowMessage('Do not supported ADI preconditioner in ALICE Mesh. ADI off.  BiCGStab+ILU2 solver on.');
                  // Солвер переводится на BiCGStab автоматическим образом.
                  FormSetting.ComboBoxSolverSetting.ItemIndex:=0;
               end;
            end;
         end
         else
         begin
            //  гидродинамика.
            // Default Structural Mesh
            if (egddata.myflmod[0].iflow=1) then
            begin
               // Гидродинамика только на структурированной сетке.
               s:=s+' 0';
            end
            else
            begin
               if (egddata.iStaticStructural=1) then
               begin
                  // Решаем только Stress задачу и мы имеем право решать её на АЛИС сетке.
                  if (MeshForm.CheckBoxALICE.Checked = false) then
                  begin
                     // Default Structural Mesh
                     s:=s+' 0';
                  end
                   else
                  begin
                     // Stress in ALICE Mesh. 21.01.2018.
                     // Adaptive Local Refinement Mesh
                     s:=s+' 1';
                  end;
               end
                else
               begin
                  s:=s+' 0';
               end;
            end;
         end;
      end
      else
      begin
         // Теплопередача в твёрдом теле.
         if (MeshForm.CheckBoxALICE.Checked = false) then
         begin
            // Default Structural Mesh
            s:=s+' 0';
         end
          else
         begin
            // Adaptive Local Refinement Mesh
            s:=s+' 1';
            if (FormSetting.ComboBoxSolverSetting.ItemIndex=2) then
            begin
               // bicgstab + ADI решатель.
               // не может быть использован на ALICE сетке.
                Laplas.MainMemo.Lines.Add('Do not supported ADI preconditioner in ALICE Mesh.');
                ShowMessage('Do not supported ADI preconditioner in ALICE Mesh. ADI off.  BiCGStab+ILU2 solver on.');
               // Солвер переводится на BiCGStab автоматическим образом.
               FormSetting.ComboBoxSolverSetting.ItemIndex:=0;
            end;
         end;
      end;
   end
    else
   begin
      if (MeshForm.CheckBoxALICE.Checked = false) then
      begin
         // Default Structural Mesh
         s:=s+' 0';
      end
      else
      begin
          // 09.12.2018
          // Adaptive Local Refinement Mesh
          s:=s+' 1';

          if (FormSetting.ComboBoxSolverSetting.ItemIndex=2) then
            begin
               // bicgstab + ADI решатель.
               // не может быть использован на ALICE сетке.
                Laplas.MainMemo.Lines.Add('Do not supported ADI preconditioner in ALICE Mesh.');
                ShowMessage('Do not supported ADI preconditioner in ALICE Mesh. ADI off.  BiCGStab+ILU2 solver on.');
               // Солвер переводится на BiCGStab автоматическим образом.
               FormSetting.ComboBoxSolverSetting.ItemIndex:=0;
            end;
      end;
   end;
   // Версия АЛИС сетки. Быстрая -0, умеренно точная - 1.
   s:=s+' '+IntToStr(MeshForm.ComboBoxALICEType.ItemIndex);
   // Количество итераций алгориртма gmres до следующего рестарта (перезапуска).
   // В статьях рекомеддуется 20. При увеличении алгоритм стремиться к алгоритму gmres и
   // его скорость сходимости увеличивается.
   s:=s+' '+FormSetting.ComboBox_m_restart_for_gmres.Items[FormSetting.ComboBox_m_restart_for_gmres.ItemIndex];
   // Настройки amg mager`a:
   // Алгоритм сортировки в алгебраическом мноосеточном методе РУМБА.
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxSort.ItemIndex);
   // level reduction
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevels.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevelsSpeed.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevelsPressure.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevelsStress.ItemIndex);
   // interpolation
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxinterpolation.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxinterpolationSpeed.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxinterpolationPressure.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxinterpollationStress.ItemIndex);
   // Алгоритмы и структуры данных, лежащие в основе C-F разбиения.
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Temperature.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Speed.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Pressure.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Stress.ItemIndex);
   // экспериментальные параметры модифицирующие четвёртую процедуру интерполляции.
   // 12,01,2018 заглушка, данные параметры более не используются в коде солвера.
   //s:=s+' '+IntToStr(Form_amg_manager.ComboBoxmodinterpol.ItemIndex);
   //s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnumberadapt.ItemIndex);
   if (Form_amg_manager.CheckBoxDiagonalDominant.Checked=true) then
   begin
      // agglomeration with consistency scaling
      s:=s+' 1 0';
   end
   else
   begin
      s:=s+' 0 0';
   end;
    //Matrix Portrait
    // Temperature:
   if (Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked)then
   begin
      s:=s+' 1';
   end
    else
   begin
      s:=s+' 0';
   end;
   // Speed:
   if (Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked)then
   begin
      s:=s+' 1';
   end
    else
   begin
      s:=s+' 0';
   end;
   // Pressure:
   if (Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked) then
   begin
      s:=s+' 1';
   end
    else
   begin
      s:=s+' 0';
   end;
   // Stress
   if (Form_amg_manager.CheckBoxStressMatrixPortrait.Checked) then
   begin
      s:=s+' 1';
   end
    else
   begin
      s:=s+' 0';
   end;

   // 01.05.2017
   // truncation of interpolation:
   // Temperature:
   if (Form_amg_manager.CheckBoxtruncationT.Checked) then
   begin
      s:=s+' 0';
   end
    else
   begin
      s:=s+' 1';
   end;
   // Speed:
   if (Form_amg_manager.CheckBoxtruncationSpeed.Checked) then
   begin
      s:=s+' 0';
   end
    else
   begin
      s:=s+' 1';
   end;
   // Pressure:
   if (Form_amg_manager.CheckBoxtruncationPressure.Checked) then
   begin
      s:=s+' 0';
   end
    else
   begin
      s:=s+' 1';
   end;
   // Stress:
   if (Form_amg_manager.CheckBoxtruncationStress.Checked) then
   begin
      s:=s+' 0';
   end
    else
   begin
      s:=s+' 1';
   end;
   // Temperature:
   s1:=Form_amg_manager.Edit_truncation_T.Text;
   for i := 1 to length(s1) do
   begin
      if (s1[i]=',') then s1[i]:='.';
   end;
   Form_amg_manager.Edit_truncation_T.Text:=s1;

   s:=s+' '+Trim(Form_amg_manager.Edit_truncation_T.Text);
   // Speed:
   s1:=Form_amg_manager.Edit_truncation_Speed.Text;
   for i := 1 to length(s1) do
   begin
      if (s1[i]=',') then s1[i]:='.';
   end;
   Form_amg_manager.Edit_truncation_Speed.Text:=s1;

   s:=s+' '+Trim(Form_amg_manager.Edit_truncation_Speed.Text);
   // Pressure:
   s1:=Form_amg_manager.Edit_truncation_Pressure.Text;
   for i := 1 to length(s1) do
   begin
      if (s1[i]=',') then s1[i]:='.';
   end;
   Form_amg_manager.Edit_truncation_Pressure.Text:=s1;

   s:=s+' '+Trim(Form_amg_manager.Edit_truncation_Pressure.Text);
   // Stress:
   s1:=Form_amg_manager.Edittruncation_Stress.Text;
   for i := 1 to length(s1) do
   begin
      if (s1[i]=',') then s1[i]:='.';
   end;
   Form_amg_manager.Edittruncation_Stress.Text:=s1;

   s:=s+' '+Trim(Form_amg_manager.Edittruncation_Stress.Text);


   //  this is the end truncation of interpolation:

   // nFinnest
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnFinnest.ItemIndex+1);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnFinnestSpeed.ItemIndex+1);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnFinnestPressure.ItemIndex+1);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnFinnestStress.ItemIndex+1);
   // nu1
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnumberpresmothers.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnumberpresmothersSpeed.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnumberpresmothersPressure.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnumberpresmoothersStress.ItemIndex);
   // nu2
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnumberpostsweeps.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnumberpostsweepsSpeed.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnumberpostsweepsPressure.ItemIndex);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxnumberpostsweepsStress.ItemIndex);
   // memory
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxmemorysize.ItemIndex+4);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxmemorysizeSpeed.ItemIndex+4);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxmemorysizePressure.ItemIndex+4);
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxmemorysizeStress.ItemIndex+4);

   //  0 - Gauss-Seidel; 1 - iluk(k=lfil); 2 - Рунге-Кутта 3 порядка;
   // 3 - Рунге -Кутта 5 порядка; 4 - damped Jacoby; 5 - Rouch sor;
   // Температура :
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxsmoothertypeTemperature.ItemIndex);
   // Скорость :
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxsmoothertypeSpeed.ItemIndex);
   // Давление :
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxsmoothertypePressure.ItemIndex);
   // Stress :
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxsmoothertypeStress.ItemIndex);
   // threshold
   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.Editthreshold.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.Editthreshold.Text:=s1;
   end;
   s:=s+' '+Trim(Form_amg_manager.Editthreshold.Text);
   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditthresholdSpeed.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditthresholdSpeed.Text:=s1;
   end;
   s:=s+' '+Trim(Form_amg_manager.EditthresholdSpeed.Text);
   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditthresholdPressure.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditthresholdPressure.Text:=s1;
   end;
   s:=s+' '+Trim(Form_amg_manager.EditthresholdPressure.Text);
   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditthresholdStress.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditthresholdStress.Text:=s1;
   end;
   s:=s+' '+Trim(Form_amg_manager.EditthresholdStress.Text);

   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditmagicT.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditmagicT.Text:=s1;
   end;
   s:=s+' '+Trim(Form_amg_manager.EditmagicT.Text);

   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditmagicSpeed.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditmagicSpeed.Text:=s1;
   end;
   s:=s+' '+Trim(Form_amg_manager.EditmagicSpeed.Text);

   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditmagicPressure.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditmagicPressure.Text:=s1;
   end;
   s:=s+' '+Trim(Form_amg_manager.EditmagicPressure.Text);

   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditmagicStress.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditmagicStress.Text:=s1;
   end;
   s:=s+' '+Trim(Form_amg_manager.EditmagicStress.Text);

   // Temperature standart coarsening vs RS 2.
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxcoarseningTemp.ItemIndex);
   // Speed standart coarsening vs RS 2.
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxcoarseningSpeed.ItemIndex);
   // Pressure standart coarsening vs RS 2.
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxcoarseningPressure.ItemIndex);
   // Stress standart coarsening vs RS 2.
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxcoarseningStress.ItemIndex);
   // Stabilization BiCGStab + amg (РУМБА).
   // 8.01.2017
   // Temperature
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxStabilizationTemp.ItemIndex); // none
   // Speed
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxStabilizationSpeed.ItemIndex); // none
   // Pressure
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxStabilizationPressure.ItemIndex); // none
   // Stress
   s:=s+' '+IntToStr(Form_amg_manager.ComboBoxStabilizationStress.ItemIndex); // none

   // Strong Transpose select
   if (Form_amg_manager.CheckBoxStrongTranspose.Checked) then
   begin
      s:=s+' 7'; // Strong Transpose
   end
   else
   begin
     s:=s+' 0';  // Просто strong
   end;
   // 01.05.2017
   // print log:
   // Temperature:
   if (Form_amg_manager.CheckBoxprintlogTemperature.Checked) then
   begin
      s:=s+' 1';
   end
    else
   begin
      s:=s+' 0';
   end;
   // Speed:
   if (Form_amg_manager.CheckBoxprintlogSpeed.Checked) then
   begin
      s:=s+' 1';
   end
    else
   begin
      s:=s+' 0';
   end;
   // Pressure:
   if (Form_amg_manager.CheckBoxprintlogPressure.Checked) then
   begin
      s:=s+' 1';
   end
    else
   begin
      s:=s+' 0';
   end;
   // Stress:
   if (Form_amg_manager.CheckBoxprintlogStress.Checked) then
   begin
      s:=s+' 1';
   end
    else
   begin
      s:=s+' 0';
   end;
   s:=s+' '+IntToStr(FormAMGCLParameters.RadioGroupAMGCLsmoother1.ItemIndex);
   s:=s+' '+IntToStr(FormAMGCLParameters.RadioGroupAMGCLCoarseningType.ItemIndex);
   s:=s+' '+IntToStr(FormAMGCLParameters.ComboBoxIterator.ItemIndex);
   s:=s+' '+IntToStr(FormSetting.ComboBox_lfil.ItemIndex);

   // Делать ли уничтожения памяти и новые построения.
   // 9 september 2017.
   if (FormUnsteady.CheckBoxreconstruct.Checked) then
   begin
      s:=s+' 1';
   end
    else
   begin
      s:=s+' 0';
   end;

   // 17 november 2017.
   // Сохранять ли анимацию в текстовый файл.
   if (FormUnsteady.CheckBoxAnimationFields.Checked) then
   begin
      s:=s+' 1';
   end
    else
   begin
      s:=s+' 0';
   end;


   f.Add(s);

   // имена файлов в которых хранятся таблицы мощностей
   // зависящие от температуры и смещения стока.
   for i:=0 to (iltdp-1) do
   begin
      f.Add(listtablename[i]);
   end;

   for i:=0 to (lmatmax-1) do
   begin
      //s:=workmat[i].namemat+' '; // имя материала не требуется
      // плотность, теплоёмкость и теплопроводность.
      s:=FloatToStr(workmat[i].rho)+ ' '; // плотность
      //s:=s+FloatToStr(workmat[i].cp)+ ' '; // теплоёмкость
      //s:=s+FloatToStr(workmat[i].lambda)+ ' '; // теплопроводность
      // 17.11.2016
      s:=s+IntToStr(workmat[i].n_cp)+' ';
      for i3 := 0 to workmat[i].n_cp-1 do
      begin
          s:=s+FloatToStr(workmat[i].temp_cp[i3])+' '+FloatToStr(workmat[i].arr_cp[i3])+' ';
      end;
      //s:=s+'1 20.0 '+FloatToStr(workmat[i].arr_cp[0])+ ' '; // теплоёмкость
      s:=s+IntToStr(workmat[i].n_lam)+' ';
      for i3 := 0 to workmat[i].n_lam-1 do
      begin
          s:=s+FloatToStr(workmat[i].temp_lam[i3])+' '+FloatToStr(workmat[i].arr_lam[i3])+' ';
      end;
      //s:=s+'1 20.0 '+FloatToStr(workmat[i].arr_lam[0])+ ' '; // теплопроводность
      // Ортотропность теплопроводности.
      s:=s+FloatToStr(workmat[i].mult_lam_x)+ ' ';
      s:=s+FloatToStr(workmat[i].mult_lam_y)+ ' ';
      s:=s+FloatToStr(workmat[i].mult_lam_z)+ ' ';
      // Thermal Stress
      // Ортотропность Коэффициента теплового линейного расширения.
      s:=s+FloatToStr(workmat[i].mult_Linear_expansion_coefficient_x)+ ' ';
      s:=s+FloatToStr(workmat[i].mult_Linear_expansion_coefficient_y)+ ' ';
      s:=s+FloatToStr(workmat[i].mult_Linear_expansion_coefficient_z)+ ' ';
       // Ортотропность модуля Юнга.
      s:=s+FloatToStr(workmat[i].mult_Young_Module_x)+ ' ';
      s:=s+FloatToStr(workmat[i].mult_Young_Module_y)+ ' ';
      s:=s+FloatToStr(workmat[i].mult_Young_Module_z)+ ' ';
      // Ортотропность коэффициента Пуассона.
      s:=s+FloatToStr(workmat[i].mult_Poisson_ratio_xy)+ ' ';
      s:=s+FloatToStr(workmat[i].mult_Poisson_ratio_xz)+ ' ';
      s:=s+FloatToStr(workmat[i].mult_Poisson_ratio_yz)+ ' ';
      s:=s+FloatToStr(workmat[i].mult_Poisson_ratio_yx)+ ' ';
      s:=s+FloatToStr(workmat[i].mult_Poisson_ratio_zx)+ ' ';
      s:=s+FloatToStr(workmat[i].mult_Poisson_ratio_zy)+ ' ';
      // Модуль сдвига
      if (workmat[i].bShearModuleActive) then
      begin
         s:=s+'1 ';  // Модуль сдвига задаётся пользователем.
      end
      else
      begin
         s:=s+'0 ';  // Модуль сдвига не задаётся пользователем.
      end;
      s:=s+FloatToStr(workmat[i].ShearModuleGxy)+ ' ';
      s:=s+FloatToStr(workmat[i].ShearModuleGyz)+ ' ';
      s:=s+FloatToStr(workmat[i].ShearModuleGxz)+ ' ';


      //s:=s+FloatToStr(workmat[i].Poisson_ratio)+ ' ';
      s:=s+IntToStr(workmat[i].n_Poisson_ratio)+' ';
      for i3 := 0 to workmat[i].n_Poisson_ratio-1 do
      begin
          // Poisson_ratio
          s:=s+FloatToStr(workmat[i].temp_Poisson_ratio[i3])+' '+FloatToStr(workmat[i].arr_Poisson_ratio[i3])+' ';
      end;
      //s:=s+FloatToStr(workmat[i].Young_Module)+ ' ';  // GPa
      s:=s+IntToStr(workmat[i].n_Young_Module)+' ';
      for i3 := 0 to workmat[i].n_Young_Module-1 do
      begin
          // Young_Module  GPa
          s:=s+FloatToStr(workmat[i].temp_Young_Module[i3])+' '+FloatToStr(workmat[i].arr_Young_Module[i3])+' ';
      end;
      //s:=s+FloatToStr(workmat[i].Linear_expansion_coefficient)+ ' '; // *1E-6
      s:=s+IntToStr(workmat[i].n_Linear_expansion_coefficient)+' ';
      for i3 := 0 to workmat[i].n_Linear_expansion_coefficient-1 do
      begin
          // Linear_expansion_coefficient *1E-6
          s:=s+FloatToStr(workmat[i].temp_Linear_expansion_coefficient[i3])+' '+FloatToStr(workmat[i].arr_Linear_expansion_coefficient[i3])+' ';
      end;
      s:=s+FloatToStr(workmat[i].mu)+ ' '; // динамическая вязкость
      s:=s+FloatToStr(workmat[i].beta_t)+ ' '; // коэффициент линейного температурного расширения
      s:=s+IntToStr(workmat[i].blibmat)+' '; // является ли материал библиотечным ?
      s:=s+IntToStr(workmat[i].ilibident)+' '; // идентификатор библиотечного материаала
      s:=s+IntToStr(workmat[i].bBoussinesq)+' '; // использовать приближение Обербека-Буссинеска или нет.
      s:=s+IntToStr(workmat[i].ilawmu)+' ';  // номер закона для динамической вязкости
      s:=s+FloatToStr(workmat[i].mumin)+' '; // ограничители
      s:=s+FloatToStr(workmat[i].mumax)+' '; // динамической вязкости.
      s:=s+FloatToStr(workmat[i].Amu)+' ';   // параметры
      s:=s+FloatToStr(workmat[i].Bmu)+' ';   // модельных
      s:=s+FloatToStr(workmat[i].Cmu)+' ';   // зависимостей
      s:=s+FloatToStr(workmat[i].degreennmu)+' '; // показатель степени
      f.Add(s);
   end;


   // Сортировка блоков по возрастанию значения их priority.
   // 2 мая 2016.
   (*
    for isort:=2 to lb-1 do
   begin
	   for jsort:=lb-1 downto isort do
     begin
     		if (body[jsort-1].priority > body[jsort].priority) then
        begin
			     // swap
			     body_change:=body[jsort-1];
			     body[jsort-1]:=body[jsort];
			     body[jsort]:= body_change;
		    end;
	   end;
   end;
   *)
   // Теперь блоки отсортированы по возратанию их приоритетов.
   HeapSort(1,lb-1); // Пирамидальная сортировка.

   if (body[0].itype=3) then
   begin
      // Cabinet типа Fluid.
      for i:=0 to (lb-1) do
      begin
         with (body[i]) do
         begin
            bf7:=false;
            // Принадлежность union (Асемблесу).
            for i3 := 0 to (lu-1) do
            begin
               if (myassembles[i3].identifire=iunion)then
               begin
                  if (myassembles[i3].bmesh_assembles_separately) then
                  begin
                     bf7:=true;
                  end;
               end;
            end;
            if (bf7) then
            begin
               s:=IntToStr(iunion)+' ';
            end
             else
            begin
               s:='0 ';
            end;
            // 0 - Prism, 1 - Cylinder.
            if (FormUnsteady.CheckBoxCylinderToPrism.Checked and (igeometry_type=1) and (bCylinder2Prism))  then
            begin
               // to Prism
               s:=s+IntToStr(0)+' ';
               case iPlane of
               1 : begin
                      // XY
                      zS1:=zC;
                      zE1:=zC+Hcyl;
                      xS1:=xC-0.8861433*R_out_cyl;
                      xE1:=xC+0.8861433*R_out_cyl;
                      yS1:=yC-0.8861433*R_out_cyl;
                      yE1:=yC+0.8861433*R_out_cyl;
                   end;
               2 : begin
                      //XZ
                      yS1:=yC;
                      yE1:=yC+Hcyl;
                      xS1:=xC-0.8861433*R_out_cyl;
                      xE1:=xC+0.8861433*R_out_cyl;
                      zS1:=zC-0.8861433*R_out_cyl;
                      zE1:=zC+0.8861433*R_out_cyl;
                   end;
               3 : begin
                      // YZ
                      xS1:=xC;
                      xE1:=xC+Hcyl;
                      yS1:=yC-0.8861433*R_out_cyl;
                      yE1:=yC+0.8861433*R_out_cyl;
                      zS1:=zC-0.8861433*R_out_cyl;
                      zE1:=zC+0.8861433*R_out_cyl;
                   end;
               end;
            end
            else
            begin
               s:=s+IntToStr(igeometry_type)+' ';
            end;
            // visible or not visible
            if (bvisible) then
            begin
               // Участвует в расчёте и прорисовывается в tecplot 360.
               s:=s+'1 '; // Visible
            end
            else
            begin
               // Участвует в расчёте но не прорисовывается в Tecplot 360.
               s:=s+'0 '; // not Visible
               MainMemo.Lines.Add('body['+IntToStr(i)+'] not vible');
            end;
            // Prism
            if (FormUnsteady.CheckBoxCylinderToPrism.Checked and (igeometry_type=1) and (bCylinder2Prism))  then
            begin
               s:=s+FloatToStr(xS1)+' ';
               s:=s+FloatToStr(yS1)+' ';
               s:=s+FloatToStr(zS1)+' ';
               s:=s+FloatToStr(xE1)+' ';
               s:=s+FloatToStr(yE1)+' ';
               s:=s+FloatToStr(zE1)+' ';
            end
             else
            begin
               s:=s+FloatToStr(xS)+' ';
               s:=s+FloatToStr(yS)+' ';
               s:=s+FloatToStr(zS)+' ';
               s:=s+FloatToStr(xE)+' ';
               s:=s+FloatToStr(yE)+' ';
               s:=s+FloatToStr(zE)+' ';
            end;
            // Cylinder
            s:=s+IntToStr(iPlane)+' ';  // 1 - XY, 2 - XZ, 3 - YZ.
            s:=s+FloatToStr(xC)+' ';
            s:=s+FloatToStr(yC)+' ';
            s:=s+FloatToStr(zC)+' ';
            s:=s+FloatToStr(Hcyl)+' ';
            s:=s+FloatToStr(R_out_cyl)+' ';
            s:=s+FloatToStr(R_in_cyl)+' ';
            // sector, conoid
            (*
            s:=s+FloatToStr(R_out_cyl2)+ ' ';
            s:=s+FloatToStr(R_in_cyl2)+' ';
            s:=s+FloatToStr(angle_start)+ ' ';
            s:=s+FloatToStr(angle_end)+' ';
            *)
             f.Add(s);
             s:='';
             // Polygon
             s:=s+IntToStr(iPlane_obj2)+' '; // 1 - XY, 2 - XZ, 3 - YZ.
             s:=s+IntToStr(nsizei)+' ';
             for j := 0 to nsizei-1 do
             begin
                s:=s+FloatToStr(hi[j])+' ';
                s:=s+FloatToStr(xi[j])+' ';
                s:=s+FloatToStr(yi[j])+' ';
                s:=s+FloatToStr(zi[j])+' ';
             end;
             f.Add(s);
             s:='';

            // emissivity :
            bOk:=true;
            if (abs(FormVariables.my_real_convert(body[i].semissW,bOk))<1.0e-12) then
            begin
               body[i].emissW:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissW:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissW:='0.001';
             end;
            end;
            s:=s+FloatToStr(FormVariables.my_real_convert(body[i].semissW,bOk))+' ';
            if (abs(FormVariables.my_real_convert(body[i].semissE,bOk))<1.0e-12) then
            begin
               body[i].emissE:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissE:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissE:='0.001';
             end;
            end;
            s:=s+FloatToStr(FormVariables.my_real_convert(body[i].semissE,bOk))+' ';
            if (abs(FormVariables.my_real_convert(body[i].semissS,bOk))<1.0e-12) then
            begin
               body[i].emissS:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissS:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissS:='0.001';
             end;
            end;
            s:=s+FloatToStr(FormVariables.my_real_convert(body[i].semissS,bOk))+' ';
            if (abs(FormVariables.my_real_convert(body[i].semissN,bOk))<1.0e-12) then
            begin
               body[i].emissN:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissN:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissN:='0.001';
             end;
            end;
            s:=s+FloatToStr(FormVariables.my_real_convert(body[i].semissN,bOk))+' ';
             if (abs(FormVariables.my_real_convert(body[i].semissB,bOk))<1.0e-12) then
            begin
               body[i].emissB:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissB:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissB:='0.001';
             end;
            end;
            s:=s+FloatToStr(FormVariables.my_real_convert(body[i].semissB,bOk))+' ';
             if (abs(FormVariables.my_real_convert(body[i].semissT,bOk))<1.0e-12) then
            begin
               body[i].emissT:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissT:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissT:='0.001';
             end;
            end;
            s:=s+FloatToStr(FormVariables.my_real_convert(body[i].semissT,bOk))+' ';
            // для emissivity мы задаём не ноль а малое положительное число,
            // т.к. с нулём может возникнуть деление на ноль в программе.
            s:=s+IntToStr(binternalRadiation)+' ';

            s:=s+IntToStr(imatid)+' ';

            // Фиксация боковой стенки Цилидра.
            if (body[i].CylinderFixed) then
            begin
               s:=s+'1 ';  // Фиксируем.
            end
              else
            begin
               s:=s+'0 ';  // Free.
            end;


            // Внимание ! нужно брать именно модуль разности координат,
            // т.к. в теории может быть нарушен порядок следования, например
            // xE может быть меньше xS что в конечном счёте может привести к смене
            // знака у мощности тепловыделения и к отрицательным температурам при
            // при положительной реальной мощности.
            // исправление от 23 сентября 2015 года.
            //Sc:=power/(abs(xE-xS)*abs(yE-yS)*abs(zE-zS)*mlength*mlength*mlength);
            //s:=s+FloatToStr(Sc)+' '; // мощность тепловыделения блока на единицу объёма
            s:=s+IntToStr(body[i].n_power)+' ';
            for i_4 := 0 to body[i].n_power-1 do
            begin
               if (body[i].igeometry_type=0) then
               begin
                  // Prism
                  if ((abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS)*mlength*mlength*mlength>1.0e-40)) then
                   begin
                  s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(body[i].arr_power[i_4]/(abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS)*mlength*mlength*mlength))+' ';
                   end
                   else
                   begin
                     ShowMessage('body['+IntToStr(i)+'] volume is bad:'+FloatToStr((abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS))));
                   end;
               end;
                if (body[i].igeometry_type=1) then
               begin
                  // Cylinder
                  if (abs(body[i].angle_end-body[i].angle_start)<0.5) then
                  begin
                      body[i].angle_end:=360.0;
                  end;
                  s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(body[i].arr_power[i_4]/(((abs(body[i].angle_end-body[i].angle_start))/360.0)*body[i].Hcyl*3.141*(body[i].R_out_cyl*body[i].R_out_cyl-body[i].R_in_cyl*body[i].R_in_cyl)*mlength*mlength*mlength))+' ';
               end;
               if (body[i].igeometry_type=2) then
               begin
                  // Polygon
                  // Для полигона мы передаём значение температуры при которой задана тепловая мощность и значение
                  // тепловой мощности в Вт.
                  s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(body[i].arr_power[i_4])+' ';
                  // 26.01.2018.
                  // Для полигона мы всегда задаём нулевое значение тепловой мощности.
                  // Главная причина. Я не умею правильно вычислять объём полигона в интерфейсе.
                  //s:=s+FloatToStr(body[i].temp_power[i_4])+' 0.0 ';

                         (*
                         // работает только для треугольника
                         // и только для всюду одинаковых высот.
                         if (body[i].nsizei<3) then
                         begin
                            ShowMessage('Polygon error: power nsizei<3');
                         end;
                         if (body[i].nsizei=3) then
                         begin
                            case body[i].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*((body[i].xi[1]-body[i].xi[0])*(body[i].yi[2]-body[i].yi[0])-(body[i].yi[1]-body[i].yi[0])*(body[i].xi[2]-body[i].xi[0]))))+' ';
                                   end;
                               2: begin
                                     // XZ
                                     s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*((body[i].xi[1]-body[i].xi[0])*(body[i].zi[2]-body[i].zi[0])-(body[i].zi[1]-body[i].zi[0])*(body[i].xi[2]-body[i].xi[0]))))+' ';
                                  end;
                               3 : begin
                                      // YZ
                                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*((body[i].yi[1]-body[i].yi[0])*(body[i].zi[2]-body[i].zi[0])-(body[i].zi[1]-body[i].zi[0])*(body[i].yi[2]-body[i].yi[0]))))+' ';
                                   end;
                            end;
                         end;
                         if (body[i].nsizei>3) then
                         begin
                            //   Только выпуклый полигон, его площадь аппроксимирована
                            // суммой площадей составляющих его треугольников.
                            // Центр масс.
                            xavg:=0.0;
                            yavg:=0.0;
                            zavg:=0.0;
                            for j := 0 to body[i].nsizei-1 do
                            begin
                               xavg:=xavg+body[i].xi[j];
                               yavg:=yavg+body[i].yi[j];
                               zavg:=zavg+body[i].zi[j];
                            end;
                            xavg:=xavg/body[i].nsizei;
                            yavg:=yavg/body[i].nsizei;
                            zavg:=zavg/body[i].nsizei;

                            powertri:=0.0;
                            for j := 0 to body[i].nsizei-2 do
                            begin
                              case body[i].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      powertri:=(mlength*mlength*mlength*powertri+body[i].arr_power[i_4])/((abs(body[i].hi[0]))*(body[i].nsizei-1)*((body[i].xi[j]-xavg)*(body[i].yi[j+1]-yavg)-(body[i].yi[j]-yavg)*(body[i].xi[j+1]-xavg)));
                                   end;
                               2: begin
                                     // XZ
                                     powertri:=powertri+(mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*(body[i].nsizei-1)*((body[i].xi[j]-xavg)*(body[i].zi[j+1]-zavg)-(body[i].zi[j]-zavg)*(body[i].xi[j+1]-xavg)));
                                  end;
                               3 : begin
                                     // YZ
                                     powertri:=powertri+(mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*(body[i].nsizei-1)*((body[i].yi[j]-yavg)*(body[i].zi[j+1]-zavg)-(body[i].zi[j]-zavg)*(body[i].yi[j+1]-yavg)));
                                   end;
                               end;
                            end;
                              s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(powertri)+' ';
                            end;
                            *)
               end;
            end;
            s:=s+IntToStr(ipower_time_depend)+' '; // зависимость мощности тепловыделения в блоке от времени.
            if ((i<>0)and checkFLUIDtoSOLID) then
            begin
                if (itype=3) then
                begin
                   s:=s+'2 '; // FLUID to SOLID
                end;
            end
             else
            begin
               s:=s+IntToStr(itype)+' '; // тип блока : SOLID, HOLLOW, FLUID.
            end;
         end;
         f.Add(s);
      end;
   end
   else if (body[0].itype=2) then
   begin
      // HOLLOW BLOCK
      cab_geom.xS:=1.0e20;
      cab_geom.xE:=-1.0e20;
      cab_geom.yS:=1.0e20;
      cab_geom.yE:=-1.0e20;
      cab_geom.zS:=1.0e20;
      cab_geom.zE:=-1.0e20;

      for i:=1 to (lb-1) do
      begin
         with (body[i]) do
         begin
            if (xS<cab_geom.xS) then
            begin
               cab_geom.xS:=xS;
            end;
            if (yS<cab_geom.yS) then
            begin
               cab_geom.yS:=yS;
            end;
            if (zS<cab_geom.zS) then
            begin
               cab_geom.zS:=zS;
            end;
             if (xE>cab_geom.xE) then
            begin
               cab_geom.xE:=xE;
            end;
            if (yE>cab_geom.yE) then
            begin
               cab_geom.yE:=yE;
            end;
            if (zE>cab_geom.zE) then
            begin
               cab_geom.zE:=zE;
            end;
         end;
      end;

      cab_geom2.xS:=1.0e20;
      cab_geom2.xE:=-1.0e20;
      cab_geom2.yS:=1.0e20;
      cab_geom2.yE:=-1.0e20;
      cab_geom2.zS:=1.0e20;
      cab_geom2.zE:=-1.0e20;
      for i:=0 to (ls-1) do
      begin
         with (source[i]) do
         begin
             if (xS<cab_geom2.xS) then
            begin
               cab_geom2.xS:=xS;
               MainMemo.Lines.Add('error:'+source[i].name+' xS position is incorrect.');
            end;
            if (yS<cab_geom2.yS) then
            begin
               cab_geom2.yS:=yS;
               MainMemo.Lines.Add('error:'+source[i].name+' yS position is incorrect.');
            end;
            if (zS<cab_geom2.zS) then
            begin
               cab_geom2.zS:=zS;
               MainMemo.Lines.Add('error:'+source[i].name+' zS position is incorrect.');
            end;
             if (xE>cab_geom2.xE) then
            begin
               cab_geom2.xE:=xE;
               MainMemo.Lines.Add('error:'+source[i].name+' xE position is incorrect.');
            end;
            if (yE>cab_geom2.yE) then
            begin
               cab_geom2.yE:=yE;
               MainMemo.Lines.Add('error:'+source[i].name+' yE position is incorrect.');
            end;
            if (zE>cab_geom2.zE) then
            begin
               cab_geom2.zE:=zE;
               MainMemo.Lines.Add('error:'+source[i].name+' zE position is incorrect.');
            end;
         end;
      end;
       for i:=0 to (lw-1) do
      begin
         with (wall[i]) do
         begin
            if (cabinet_depend=0) then
            begin
               if (xS<cab_geom2.xS) then
               begin
                  cab_geom2.xS:=xS;
                   MainMemo.Lines.Add('error:'+wall[i].name+' xS position is incorrect.');
               end;
               if (yS<cab_geom2.yS) then
               begin
                  cab_geom2.yS:=yS;
                  MainMemo.Lines.Add('error:'+wall[i].name+' yS position is incorrect.');
               end;
               if (zS<cab_geom2.zS) then
               begin
                  cab_geom2.zS:=zS;
                  MainMemo.Lines.Add('error:'+wall[i].name+' zS position is incorrect.');
               end;
               if (xE>cab_geom2.xE) then
               begin
                  cab_geom2.xE:=xE;
                  MainMemo.Lines.Add('error:'+wall[i].name+' xE position is incorrect.');
               end;
               if (yE>cab_geom2.yE) then
               begin
                  cab_geom2.yE:=yE;
                  MainMemo.Lines.Add('error:'+wall[i].name+' yE position is incorrect.');
               end;
               if (zE>cab_geom2.zE) then
               begin
                  cab_geom2.zE:=zE;
                  MainMemo.Lines.Add('error:'+wall[i].name+' zE position is incorrect.');
               end;
            end;
         end;
      end;

       if (cab_geom2.xS<cab_geom.xS) then
       begin
          bmodelcheck_cab_hollow:=false;
       end;
       if (cab_geom2.yS<cab_geom.yS) then
       begin
          bmodelcheck_cab_hollow:=false;
       end;
       if (cab_geom2.zS<cab_geom.zS) then
       begin
          bmodelcheck_cab_hollow:=false;
       end;
       if (cab_geom2.xE>cab_geom.xE) then
       begin
          bmodelcheck_cab_hollow:=false;
       end;
        if (cab_geom2.yE>cab_geom.yE) then
       begin
          bmodelcheck_cab_hollow:=false;
       end;
        if (cab_geom2.zE>cab_geom.zE) then
       begin
          bmodelcheck_cab_hollow:=false;
       end;
       if (not(bmodelcheck_cab_hollow)) then
       begin
          ShowMessage('Error. Your geometry model is incorrect. Dont Start Solver.');
          MainMemo.Lines.Add('Error. Your geometry model is incorrect. Dont Start Solver.');
       end;


       with (body[0]) do
         begin
            s:=IntToStr(iunion)+' ';
            s:=s+IntToStr(0)+' ';// igeometryType= Prism.
            s:=s+FloatToStr(cab_geom.xS)+' ';
            s:=s+FloatToStr(cab_geom.yS)+' ';
            s:=s+FloatToStr(cab_geom.zS)+' ';
            s:=s+FloatToStr(cab_geom.xE)+' ';
            s:=s+FloatToStr(cab_geom.yE)+' ';
            s:=s+FloatToStr(cab_geom.zE)+' ';
            // emissivity :
            bOk:=true;
            if (abs(FormVariables.my_real_convert(semissW,bOk))<1.0e-12) then
            begin
               body[0].emissW:=0.001;
                 if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissW:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissW:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissW)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissW,bOk))+' ';
            if (abs(FormVariables.my_real_convert(semissE,bOk))<1.0e-12) then
            begin
               body[0].emissE:=0.001;
                   if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissE:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissE:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissE)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissE,bOk))+' ';
            if (abs(FormVariables.my_real_convert(semissS,bOk))<1.0e-12) then
            begin
               body[0].emissS:=0.001;
                   if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissS:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissS:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissS)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissS,bOk))+' ';
            if (abs(FormVariables.my_real_convert(semissN,bOk))<1.0e-12) then
            begin
               body[0].emissN:=0.001;
             if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissN:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissN:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissN)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissN,bOk))+' ';
             if (abs(FormVariables.my_real_convert(semissB,bOk))<1.0e-12) then
            begin
               body[0].emissB:=0.001;
                   if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissB:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissB:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissB)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissB,bOk))+' ';
             if (abs(FormVariables.my_real_convert(semissT,bOk))<1.0e-12) then
            begin
               body[0].emissT:=0.001;
                   if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissT:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissT:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissT)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissT,bOk))+' ';
            // для emissivity мы задаём не ноль а малое положительное число,
            // т.к. с нулём может возникнуть деление на ноль в программе.
            s:=s+IntToStr(binternalRadiation)+' ';


            // Материал по умолчанию для Fluid блока.
            s:=s+IntToStr(0)+' ';
            // Внимание ! нужно брать именно модуль разности координат,
            // т.к. в теории может быть нарушен порядок следования, например
            // xE может быть меньше xS что в конечном счёте может привести к смене
            // знака у мощности тепловыделения и к отрицательным температурам при
            // при положительной реальной мощности.
            // исправление от 23 сентября 2015 года.
            //Sc:=power/(abs(xE-xS)*abs(yE-yS)*abs(zE-zS)*mlength*mlength*mlength);
            Sc:=0.0;
            s:=s+FloatToStr(Sc)+' '; // мощность тепловыделения блока на единицу объёма
            // Мощность тепловыделения от времени не зависит.
            s:=s+IntToStr(0)+' '; // зависимость мощности тепловыделения в блоке от времени.
            // Принудительно пишем тип FLUID, а потом перезаписываем HOLLOW блоком.
            s:=s+IntToStr(3)+' '; // тип блока : SOLID, HOLLOW, FLUID.
         end;
         f.Add(s);
         with (body[0]) do
         begin
             // Принадлежность union (Асемблесу).
            s:=IntToStr(iunion)+' ';
            s:=s+IntToStr(0)+' ';// igeometryType= Prism.
            s:=s+FloatToStr(cab_geom.xS)+' ';
            s:=s+FloatToStr(cab_geom.yS)+' ';
            s:=s+FloatToStr(cab_geom.zS)+' ';
            s:=s+FloatToStr(cab_geom.xE)+' ';
            s:=s+FloatToStr(cab_geom.yE)+' ';
            s:=s+FloatToStr(cab_geom.zE)+' ';
             // emissivity :
            bOk:=true;
            if (abs(FormVariables.my_real_convert(semissW,bOk))<1.0e-12) then
            begin
               body[0].emissW:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
               begin
                  body[0].semissW:='0,001';
               end;
               if (FormatSettings.DecimalSeparator='.') then
               begin
                  body[0].semissW:='0.001';
               end;
            end;
            //s:=s+FloatToStr(emissW)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissW,bOk))+' ';
            if (abs(FormVariables.my_real_convert(semissE,bOk))<1.0e-12) then
            begin
               body[0].emissE:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
               begin
                  body[0].semissE:='0,001';
               end;
               if (FormatSettings.DecimalSeparator='.') then
               begin
                  body[0].semissE:='0.001';
               end;
            end;
            //s:=s+FloatToStr(emissE)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissE,bOk))+' ';
            if (abs(FormVariables.my_real_convert(semissS,bOk))<1.0e-12) then
            begin
               body[0].emissS:=0.001;
                if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[0].semissS:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[0].semissS:='0.001';
                end;
            end;
            //s:=s+FloatToStr(emissS)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissS,bOk))+' ';
            if (abs(FormVariables.my_real_convert(semissN,bOk))<1.0e-12) then
            begin
               body[0].emissN:=0.001;
                if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[0].semissN:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[0].semissN:='0.001';
                end;
            end;
            //s:=s+FloatToStr(emissN)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissN,bOk))+' ';
             if (abs(FormVariables.my_real_convert(semissB,bOk))<1.0e-12) then
            begin
               body[0].emissB:=0.001;
                if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[0].semissB:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[0].semissB:='0.001';
                end;
            end;
            //s:=s+FloatToStr(emissB)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissB,bOk))+' ';
             if (abs(FormVariables.my_real_convert(semissT,bOk))<1.0e-12) then
            begin
               body[0].emissT:=0.001;
                if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[0].semissT:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[0].semissT:='0.001';
                end;
            end;
            //s:=s+FloatToStr(emissT)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissT,bOk))+' ';
            // для emissivity мы задаём не ноль а малое положительное число,
            // т.к. с нулём может возникнуть деление на ноль в программе.
            s:=s+IntToStr(binternalRadiation)+' ';

            // Материал по умолчанию для SOLID блока.
            s:=s+IntToStr(1)+' ';
            // Внимание ! нужно брать именно модуль разности координат,
            // т.к. в теории может быть нарушен порядок следования, например
            // xE может быть меньше xS что в конечном счёте может привести к смене
            // знака у мощности тепловыделения и к отрицательным температурам при
            // при положительной реальной мощности.
            // исправление от 23 сентября 2015 года.
            //Sc:=power/(abs(xE-xS)*abs(yE-yS)*abs(zE-zS)*mlength*mlength*mlength);
            Sc:=0.0;
            s:=s+FloatToStr(Sc)+' '; // мощность тепловыделения блока на единицу объёма
            // Мощность тепловыделения от времени не зависит.
            s:=s+IntToStr(0)+' '; // зависимость мощности тепловыделения в блоке от времени.
            // Принудительно пишем тип FLUID, а потом перезаписываем HOLLOW блоком.
            s:=s+IntToStr(2)+' '; // тип блока : SOLID, HOLLOW, FLUID.
         end;
         f.Add(s);

      // остальные блоки.
      for i:=1 to (lb-1) do
      begin
         with (body[i]) do
         begin

             // Принадлежность union (Асемблесу).
              for i3 := 0 to (lu-1) do
            begin
               if (myassembles[i3].identifire=iunion)then
               begin
                  if (myassembles[i3].bmesh_assembles_separately) then
                  begin
                     bf7:=true;
                  end;
               end;
            end;
            if (bf7) then
            begin
               s:=IntToStr(iunion)+' ';
            end
             else
            begin
               s:='0 ';
            end;
             // 0 - Prism, 1 - Cylinder.
            if (FormUnsteady.CheckBoxCylinderToPrism.Checked and (igeometry_type=1))  then
            begin
               // to Prism
               s:=s+IntToStr(0)+' ';
               case iPlane of
               1 : begin
                      // XY
                      zS1:=zC;
                      zE1:=zC+Hcyl;
                      xS1:=xC-0.8861433*R_out_cyl;
                      xE1:=xC+0.8861433*R_out_cyl;
                      yS1:=yC-0.8861433*R_out_cyl;
                      yE1:=yC+0.8861433*R_out_cyl;
                   end;
               2 : begin
                      //XZ
                      yS1:=yC;
                      yE1:=yC+Hcyl;
                      xS1:=xC-0.8861433*R_out_cyl;
                      xE1:=xC+0.8861433*R_out_cyl;
                      zS1:=zC-0.8861433*R_out_cyl;
                      zE1:=zC+0.8861433*R_out_cyl;
                   end;
               3 : begin
                      // YZ
                      xS1:=xC;
                      xE1:=xC+Hcyl;
                      yS1:=yC-0.8861433*R_out_cyl;
                      yE1:=yC+0.8861433*R_out_cyl;
                      zS1:=zC-0.8861433*R_out_cyl;
                      zE1:=zC+0.8861433*R_out_cyl;
                   end;
               end;
            end
             else
            begin
               s:=s+IntToStr(igeometry_type)+' ';
            end;
            // Prism
            if (FormUnsteady.CheckBoxCylinderToPrism.Checked and (igeometry_type=1))  then
            begin
               s:=s+FloatToStr(xS1)+' ';
               s:=s+FloatToStr(yS1)+' ';
               s:=s+FloatToStr(zS1)+' ';
               s:=s+FloatToStr(xE1)+' ';
               s:=s+FloatToStr(yE1)+' ';
               s:=s+FloatToStr(zE1)+' ';
            end
             else
            begin
               s:=s+FloatToStr(xS)+' ';
               s:=s+FloatToStr(yS)+' ';
               s:=s+FloatToStr(zS)+' ';
               s:=s+FloatToStr(xE)+' ';
               s:=s+FloatToStr(yE)+' ';
               s:=s+FloatToStr(zE)+' ';
            end;
            // Cylinder
            s:=s+IntToStr(iPlane)+' ';  // 1 - XY, 2 - XZ, 3 - YZ.
            s:=s+FloatToStr(xC)+' ';
            s:=s+FloatToStr(yC)+' ';
            s:=s+FloatToStr(zC)+' ';
            s:=s+FloatToStr(Hcyl)+' ';
            s:=s+FloatToStr(R_out_cyl)+' ';
            s:=s+FloatToStr(R_in_cyl)+' ';
            // sector, conoid
            (*
            s:=s+FloatToStr(R_out_cyl2)+ ' ';
            s:=s+FloatToStr(R_in_cyl2)+' ';
            s:=s+FloatToStr(angle_start)+ ' ';
            s:=s+FloatToStr(angle_end)+' ';
            *)
             // Polygon
             s:=s+IntToStr(iPlane_obj2)+' '; // 1 - XY, 2 - XZ, 3 - YZ.
             s:=s+IntToStr(nsizei)+' ';
             for j := 0 to nsizei-1 do
             begin
                s:=s+FloatToStr(hi[j])+' ';
                s:=s+FloatToStr(xi[j])+' ';
                s:=s+FloatToStr(yi[j])+' ';
                s:=s+FloatToStr(zi[j])+' ';
             end;

             // emissivity :
            if (abs(FormVariables.my_real_convert(semissW,bOk))<1.0e-12) then
            begin
               body[i].emissW:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[i].semissW:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[i].semissW:='0.001';
                end;
            end;
           // s:=s+FloatToStr(emissW)+' ';
              s:=s+FloatToStr(FormVariables.my_real_convert(semissW,bOk))+' ';
            if (abs(FormVariables.my_real_convert(semissE,bOk))<1.0e-12) then
            begin
               body[i].emissE:=0.001;
                if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[i].semissE:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[i].semissE:='0.001';
                end;
            end;
           // s:=s+FloatToStr(emissE)+' ';
            s:=s+FloatToStr(FormVariables.my_real_convert(semissE,bOk))+' ';
            if (abs(FormVariables.my_real_convert(semissS,bOk))<1.0e-12) then
            begin
               body[i].emissS:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[i].semissS:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[i].semissS:='0.001';
                end;
            end;
            //s:=s+FloatToStr(emissS)+' ';
             s:=s+FloatToStr(FormVariables.my_real_convert(semissS,bOk))+' ';
            if (abs(FormVariables.my_real_convert(semissN,bOk))<1.0e-12) then
            begin
               body[i].emissN:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[i].semissN:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[i].semissN:='0.001';
                end;
            end;
            //s:=s+FloatToStr(emissN)+' ';
             s:=s+FloatToStr(FormVariables.my_real_convert(semissN,bOk))+' ';
             if (abs(FormVariables.my_real_convert(semissB,bOk))<1.0e-12) then
            begin
               body[i].emissB:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[i].semissB:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[i].semissB:='0.001';
                end;
            end;
            s:=s+FloatToStr(emissB)+' ';
             s:=s+FloatToStr(FormVariables.my_real_convert(semissB,bOk))+' ';
             if (abs(FormVariables.my_real_convert(semissT,bOk))<1.0e-12) then
            begin
               body[i].emissT:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[i].semissT:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[i].semissT:='0.001';
                end;
            end;
            //s:=s+FloatToStr(emissT)+' ';
             s:=s+FloatToStr(FormVariables.my_real_convert(semissT,bOk))+' ';
            // для emissivity мы задаём не ноль а малое положительное число,
            // т.к. с нулём может возникнуть деление на ноль в программе.
            if (FormUnsteady.CheckBoxNo_vacuum_Prism.Checked) then
            begin
               // Вакуумная призма неактивна.
               s:=s+'0 ';
            end
            else
            begin
               s:=s+IntToStr(binternalRadiation)+' ';
            end;

            s:=s+IntToStr(imatid)+' ';
            // Внимание ! нужно брать именно модуль разности координат,
            // т.к. в теории может быть нарушен порядок следования, например
            // xE может быть меньше xS что в конечном счёте может привести к смене
            // знака у мощности тепловыделения и к отрицательным температурам при
            // при положительной реальной мощности.
            // исправление от 23 сентября 2015 года.
            //Sc:=power/(abs(xE-xS)*abs(yE-yS)*abs(zE-zS)*mlength*mlength*mlength);
            //s:=s+FloatToStr(Sc)+' '; // мощность тепловыделения блока на единицу объёма
            // 20_11_2016.
            s:=s+IntToStr(body[i].n_power)+' ';
            for i_4 := 0 to body[i].n_power-1 do
            begin
               if (body[i].igeometry_type=0) then
               begin
                  // Прямоугольная призма.
                  s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(body[i].arr_power[i_4]/(abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS)*mlength*mlength*mlength))+' ';
               end;
               if (body[i].igeometry_type=1) then
               begin
                  // Cylinder
                  if (abs(body[i].angle_end-body[i].angle_start)<0.5) then
                  begin
                      body[i].angle_end:=360.0;
                  end;
                  s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(body[i].arr_power[i_4]/(((abs(body[i].angle_end-body[i].angle_start))/360.0)*body[i].Hcyl*3.141*(body[i].R_out_cyl*body[i].R_out_cyl-body[i].R_in_cyl*body[i].R_in_cyl)*mlength*mlength*mlength))+' ';
               end;
               if (body[i].igeometry_type=2) then
               begin
                  // Polygon
                   begin
                      // Polygon
                      // Для полигона мы передаём значение температуры при которой задана тепловая мощность и значение
                      // тепловой мощности в Вт.
                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(body[i].arr_power[i_4])+' ';
                      // 26.01.2018.
                      // Для полигона мы всегда задаём нулевое значение тепловой мощности.
                      // Главная причина. Я не умею правильно вычислять объём полигона в интерфейсе.
                      //s:=s+FloatToStr(body[i].temp_power[i_4])+' 0.0 ';

                         (*
                         // работает только для треугольника
                         // и только для всюду одинаковых высот.
                         if (body[i_4].nsizei<3) then
                         begin
                            ShowMessage('Polygon error: power nsizei<3');
                         end;
                         if (body[i_4].nsizei=3) then
                         begin
                            case body[i_4].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i_4].hi[0]))*((body[i_4].xi[1]-body[i_4].xi[0])*(body[i_4].yi[2]-body[i_4].yi[0])-(body[i_4].yi[1]-body[i_4].yi[0])*(body[i_4].xi[2]-body[i_4].xi[0]))))+' ';
                                   end;
                               2: begin
                                     // XZ
                                     s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i_4].hi[0]))*((body[i_4].xi[1]-body[i_4].xi[0])*(body[i_4].zi[2]-body[i_4].zi[0])-(body[i_4].zi[1]-body[i_4].zi[0])*(body[i_4].xi[2]-body[i_4].xi[0]))))+' ';
                                  end;
                               3 : begin
                                      // YZ
                                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i_4].hi[0]))*((body[i_4].yi[1]-body[i_4].yi[0])*(body[i_4].zi[2]-body[i_4].zi[0])-(body[i_4].zi[1]-body[i_4].zi[0])*(body[i_4].yi[2]-body[i_4].yi[0]))))+' ';
                                   end;
                            end;
                         end;
                         if (body[i_4].nsizei>3) then
                         begin
                            //   Только выпуклый полигон, его площадь аппроксимирована
                            // суммой площадей составляющих его треугольников.
                            // Центр масс.
                            xavg:=0.0;
                            yavg:=0.0;
                            zavg:=0.0;
                            for j := 0 to body[i_4].nsizei-1 do
                            begin
                               xavg:=xavg+body[i_4].xi[j];
                               yavg:=yavg+body[i_4].yi[j];
                               zavg:=zavg+body[i_4].zi[j];
                            end;
                            xavg:=xavg/body[i_4].nsizei;
                            yavg:=yavg/body[i_4].nsizei;
                            zavg:=zavg/body[i_4].nsizei;


                            powertri:=0.0;
                            for j := 0 to body[i_4].nsizei-2 do
                            begin
                              case body[i_4].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      powertri:=(mlength*mlength*mlength*powertri+body[i].arr_power[i_4])/((abs(body[i_4].hi[0]))*(body[i_4].nsizei-1)*((body[i_4].xi[j]-xavg)*(body[i_4].yi[j+1]-yavg)-(body[i_4].yi[j]-yavg)*(body[i_4].xi[j+1]-xavg)));
                                   end;
                               2: begin
                                     // XZ
                                     powertri:=powertri+(mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i_4].hi[0]))*(body[i_4].nsizei-1)*((body[i_4].xi[j]-xavg)*(body[i_4].zi[j+1]-zavg)-(body[i_4].zi[j]-zavg)*(body[i_4].xi[j+1]-xavg)));
                                  end;
                               3 : begin
                                     // YZ
                                     powertri:=powertri+(mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i_4].hi[0]))*(body[i_4].nsizei-1)*((body[i_4].yi[j]-yavg)*(body[i_4].zi[j+1]-zavg)-(body[i_4].zi[j]-zavg)*(body[i_4].yi[j+1]-yavg)));
                                   end;
                               end;
                            end;
                              s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(powertri)+' ';
                            end;
                            *)
                   end;
               end;
            end;
            s:=s+IntToStr(ipower_time_depend)+' '; // зависимость мощности тепловыделения в блоке от времени.
            if (checkFLUIDtoSOLID) then
            begin
                if (itype=3) then
                begin
                   s:=s+'2 '; // FLUID to SOLID
                end;
            end
            else
            begin
              s:=s+IntToStr(itype)+' '; // тип блока : SOLID, HOLLOW, FLUID.
            end;
         end;
         f.Add(s);
      end;
   end;


   // цикл по всем источникам тепла:
   for i:=0 to (ls-1) do
   begin
      with (source[i]) do
      begin
         // Принадлежность union (Асемблесу).
              for i3 := 0 to (lu-1) do
            begin
               if (myassembles[i3].identifire=iunion)then
               begin
                  if (myassembles[i3].bmesh_assembles_separately) then
                  begin
                     bf7:=true;
                  end;
               end;
            end;
            if (bf7) then
            begin
               s:=IntToStr(iunion)+' ';
            end
             else
            begin
               s:='0 ';
            end;

         // мощность тепловыделения, плоскость и координаты:
         // Для холодных режимов "АППАРАТА" мощность тепловыделения
         // в плоских бесконечно-тонких источниках тепла должна отсутствовать.
         // Поэтому только в этом случае для простоты использования мы зануляем
         // мощность.
         //s:=FloatToStr(0.0)+' '; // only for холодные режимы АППАРАТ. 27_10_2016.
         s:=s+FloatToStr(Power)+' ';  // мощность
         s:=s+IntToStr(itempdep)+' '; // зависит ли мощность от температуры
         s:=s+IntToStr(id_table)+' '; // уникальный идентификатор таблицы.
         s:=s+FloatToStr(operatingoffsetdrain)+' '; // смещение стока
         s:=s+IntToStr(iPlane)+' '; // плоскость в которой лежит источник тепла
         s:=s+FloatToStr(xS)+' ';
         s:=s+FloatToStr(yS)+' ';
         s:=s+FloatToStr(zS)+' ';
         s:=s+FloatToStr(xE)+' ';
         s:=s+FloatToStr(yE)+' ';
         s:=s+FloatToStr(zE);
      end;
      f.Add(s);
   end;


   // цикл по всем твёрдым стенкам:
   if (body[0].itype=2) then
   begin
      // HOLLOW
      for i:=0 to (lw-1) do
       begin

          bOk:=true;
          wall[i].heat_transfer_coefficient:= FormVariables.my_real_convert(wall[i].sheat_transfer_coefficient,bOk);
          bOk:=true;
          wall[i].emissivity:= FormVariables.my_real_convert(wall[i].semissivity,bOk);

          with (wall[i]) do
          begin
              // Поскольку кабинета нету то нет и стенок геометрические
              // размеры которых жёстко связаны с размером кабинета.
              if (cabinet_depend=0) then
              begin

                  // Принадлежность union (Асемблесу).
                  for i3 := 0 to (lu-1) do
                  begin
                     if (myassembles[i3].identifire=iunion)then
                     begin
                        if (myassembles[i3].bmesh_assembles_separately) then
                        begin
                           bf7:=true;
                        end;
                     end;
                 end;
                 if (bf7) then
                 begin
                    s:=IntToStr(iunion)+' ';
                 end
                   else
                 begin
                    s:='0 ';
                 end;

                 // тип краевого условия, температура и тепловой поток,
                 //  плоскость и координаты:
                 s:=s+IntToStr(family)+' '; // тип краевого условия
                 s:=s+FloatToStr(Tamb)+' '; // температура на идеальном теплооотводе
                 if (family=3) then
                 begin
                    s:=s+FloatToStr(heat_transfer_coefficient)+' '; // коэффициент теплоотдачи.
                 end
                  else
                 begin
                    // 1,2,4
                     s:=s+FloatToStr(emissivity)+' '; // излучательная способность
                 end;
                 s:=s+FloatToStr(ViewFactor)+' ';// Фактор видимости.
                 s:=s+FloatToStr(HF)+' '; // для граничного условия 2 или 3 рода.
                 if (bsymmetry) then s:=s+'1 ' else s:=s+'0 ';
                 if (bpressure) then s:=s+'1 ' else s:=s+'0 ';
                 if (bopening) then s:=s+'1 ' else s:=s+'0 ';

                 s:=s+FloatToStr(Vx)+' ';
                 s:=s+FloatToStr(Vy)+' ';
                 s:=s+FloatToStr(Vz)+' ';
                 s:=s+FloatToStr(P)+' ';
                 s:=s+IntToStr(ithermal_stress_boundary_condition)+' '; // Thermal-Stress.
                 s:=s+FloatToStr(xForce)+' ';
                 s:=s+FloatToStr(yForce)+' ';
                 s:=s+FloatToStr(zForce)+' ';
                 s:=s+IntToStr(iPlane)+' '; // плоскость в которой лежит источник тепла
                 s:=s+FloatToStr(xS)+' ';
                 s:=s+FloatToStr(yS)+' ';
                 s:=s+FloatToStr(zS)+' ';
                 s:=s+FloatToStr(xE)+' ';
                 s:=s+FloatToStr(yE)+' ';
                 s:=s+FloatToStr(zE);
                 if ((family=1)or(family=3)or(family=4)) then
                 begin
                    // 1 изотермическая стенка идеальный теплоотвод.
                    // 3 Newton-Richman,
                    // 4 Stefan Bolcman.
                    bmodelcheck:=true;
                 end;
              end;
              f.Add(s);
          end;
       end;
   end
   else
   if (body[0].itype=3) then
   begin
       // Fluid.
       for i:=0 to (lw-1) do
       begin

          bOk:=true;
          wall[i].heat_transfer_coefficient:= FormVariables.my_real_convert(wall[i].sheat_transfer_coefficient,bOk);
          bOk:=true;
          wall[i].emissivity:= FormVariables.my_real_convert(wall[i].semissivity,bOk);

          with (wall[i]) do
          begin
             // Принадлежность union (Асемблесу).
                  for i3 := 0 to (lu-1) do
                  begin
                     if (myassembles[i3].identifire=iunion)then
                     begin
                        if (myassembles[i3].bmesh_assembles_separately) then
                        begin
                           bf7:=true;
                        end;
                     end;
                 end;
                 if (bf7) then
                 begin
                    s:=IntToStr(iunion)+' ';
                 end
                   else
                 begin
                    s:='0 ';
                 end;
             // тип краевого условия, температура и тепловой поток,
             //  плоскость и координаты:
             s:=s+IntToStr(family)+' '; // тип краевого условия
             s:=s+FloatToStr(Tamb)+' '; // температура на идеальном теплооотводе
             if (family=3) then
             begin
                  s:=s+FloatToStr(heat_transfer_coefficient)+' '; // коэффициент теплоотдачи.
             end
              else
             begin
                // 1,2,4
                  s:=s+FloatToStr(emissivity)+' '; // излучательная способность
             end;
             s:=s+FloatToStr(ViewFactor)+' ';// Фактор видимости.
             s:=s+FloatToStr(HF)+' '; // для граничного условия 2 или 3 рода.
             if (bsymmetry) then s:=s+'1 ' else s:=s+'0 ';
             if (bpressure) then s:=s+'1 ' else s:=s+'0 ';
             if (bopening) then s:=s+'1 ' else s:=s+'0 ';

             s:=s+FloatToStr(Vx)+' ';
             s:=s+FloatToStr(Vy)+' ';
             s:=s+FloatToStr(Vz)+' ';
             s:=s+FloatToStr(P)+' ';
             s:=s+IntToStr(ithermal_stress_boundary_condition)+' '; // Thermal-Stress.
             s:=s+FloatToStr(xForce)+' ';
             s:=s+FloatToStr(yForce)+' ';
             s:=s+FloatToStr(zForce)+' ';
             s:=s+IntToStr(iPlane)+' '; // плоскость в которой лежит источник тепла
             s:=s+FloatToStr(xS)+' ';
             s:=s+FloatToStr(yS)+' ';
             s:=s+FloatToStr(zS)+' ';
             s:=s+FloatToStr(xE)+' ';
             s:=s+FloatToStr(yE)+' ';
             s:=s+FloatToStr(zE);
             if ((family=1)or(family=3)or(family=4)) then
             begin
                // 1 изотермическая стенка идеальный теплоотвод.
                // 3 Newton-Richman,
                // 4 Stefan Bolcman.
                bmodelcheck:=true;
             end;
          end;
          f.Add(s);
       end;
   end;

   // Пишем информацию об асемблесе.
   iu_number:=0; // Счётчик активных асемблесов.
   for i := 0 to (lu-1) do
   begin
      if (Laplas.myassembles[i].bmesh_assembles_separately) then
      begin
         inc(iu_number);
      end;
   end;
   s:=IntToStr(iu_number)+' ';
   f.Add(s);
   iu_number:=0; // Счётчик активных асемблесов.
   for i := 0 to (lu-1) do
   begin
       if (Laplas.myassembles[i].bmesh_assembles_separately) then
       begin
         inc(iu_number);
         xSass:=1.0e30;
         ySass:=1.0e30;
         zSass:=1.0e30;
         xEass:=-1.0e30;
         yEass:=-1.0e30;
         zEass:=-1.0e30;
         for i5 := 1 to (lb-1) do
         begin
            if (body[i5].iunion=Laplas.myassembles[i].identifire) then
            begin
               if (body[i5].igeometry_type=0) then
               begin
                  // Прямая прямоугольная призма.
                  if (body[i5].xS<xSass) then
                  begin
                     xSass:= body[i5].xS;
                  end;
                  if (body[i5].yS<ySass) then
                  begin
                     ySass:= body[i5].yS;
                  end;
                  if (body[i5].zS<zSass) then
                  begin
                     zSass:= body[i5].zS;
                  end;
                  if (body[i5].xE>xEass) then
                  begin
                     xEass:= body[i5].xE;
                  end;
                  if (body[i5].yE>yEass) then
                  begin
                     yEass:= body[i5].yE;
                  end;
                  if (body[i5].zE>zEass) then
                  begin
                     zEass:= body[i5].zE;
                  end;
               end;
               if (body[i5].igeometry_type=1) then
               begin
                  // Цилиндр
                  case body[i5].iPlane of
                      1 : begin
                             // XY
                             if (body[i5].xC-body[i5].R_out_cyl<xSass) then
                             begin
                                xSass:= body[i5].xC-body[i5].R_out_cyl;
                             end;
                             if (body[i5].xC+body[i5].R_out_cyl>xEass) then
                             begin
                                xEass:= body[i5].xC+body[i5].R_out_cyl;
                             end;
                             if (body[i5].yC-body[i5].R_out_cyl<ySass) then
                             begin
                                ySass:= body[i5].yC-body[i5].R_out_cyl;
                             end;
                             if (body[i5].yC+body[i5].R_out_cyl>yEass) then
                             begin
                                yEass:= body[i5].yC+body[i5].R_out_cyl;
                             end;
                              // h хвост.
                             if (body[i5].zC<zSass) then
                             begin
                                zSass:= body[i5].zC;
                             end;
                             if (body[i5].zC+body[i5].Hcyl>zEass) then
                             begin
                                zEass:= body[i5].zC+body[i5].Hcyl;
                             end;
                          end;
                      2: begin
                            // XZ
                             if (body[i5].xC-body[i5].R_out_cyl<xSass) then
                             begin
                                xSass:= body[i5].xC-body[i5].R_out_cyl;
                             end;
                             if (body[i5].xC+body[i5].R_out_cyl>xEass) then
                             begin
                                xEass:= body[i5].xC+body[i5].R_out_cyl;
                             end;
                             if (body[i5].zC-body[i5].R_out_cyl<zSass) then
                             begin
                                zSass:= body[i5].zC-body[i5].R_out_cyl;
                             end;
                              if (body[i5].zC+body[i5].R_out_cyl>zEass) then
                             begin
                                zEass:= body[i5].zC+body[i5].R_out_cyl;
                             end;
                              // h хвост.
                             if (body[i5].yC<ySass) then
                             begin
                                ySass:= body[i5].yC;
                             end;
                             if (body[i5].yC+body[i5].Hcyl>yEass) then
                             begin
                                yEass:= body[i5].yC+body[i5].Hcyl;
                             end;
                         end;
                      3 : begin
                             // YZ
                             if (body[i5].yC-body[i5].R_out_cyl<ySass) then
                             begin
                                ySass:= body[i5].yC-body[i5].R_out_cyl;
                             end;
                             if (body[i5].yC+body[i5].R_out_cyl>yEass) then
                             begin
                                yEass:= body[i5].yC+body[i5].R_out_cyl;
                             end;
                             if (body[i5].zC-body[i5].R_out_cyl<zSass) then
                             begin
                                zSass:= body[i5].zC-body[i5].R_out_cyl;
                             end;
                             if (body[i5].zC+body[i5].R_out_cyl>zEass) then
                             begin
                                zEass:= body[i5].zC+body[i5].R_out_cyl;
                             end;
                             // h хвост.
                             if (body[i5].zC<zSass) then
                             begin
                                zSass:= body[i5].zC;
                             end;
                             if (body[i5].zC+body[i5].Hcyl>zEass) then
                             begin
                                zEass:= body[i5].zC+body[i5].Hcyl;
                             end;
                         end;
                  end;
               end;
                if (body[i5].igeometry_type=2) then
               begin
                  // Полигон
                   for j := 0 to body[i5].nsizei-1 do
                   begin
                      case body[i5].iPlane_obj2 of
                      1 : begin
                             // XY
                             if (body[i5].xi[j]<xSass) then
                             begin
                                xSass:= body[i5].xi[j];
                             end;
                             if (body[i5].xi[j]>xEass) then
                             begin
                                xEass:= body[i5].xi[j];
                             end;
                             if (body[i5].yi[j]<ySass) then
                             begin
                                ySass:= body[i5].yi[j];
                             end;
                              if (body[i5].yi[j]>yEass) then
                             begin
                                yEass:= body[i5].yi[j];
                             end;
                             // h хвост.
                              if (body[i5].zi[j]<zSass) then
                             begin
                                zSass:= body[i5].zi[j];
                             end;
                              if (body[i5].zi[j]+body[i5].hi[j]>zEass) then
                             begin
                                zEass:= body[i5].zi[j]+body[i5].hi[j];
                             end;
                           end;
                      2: begin
                            // XZ
                            if (body[i5].xi[j]<xSass) then
                             begin
                                xSass:= body[i5].xi[j];
                             end;
                             if (body[i5].xi[j]>xEass) then
                             begin
                                xEass:= body[i5].xi[j];
                             end;
                             if (body[i5].zi[j]<zSass) then
                             begin
                                zSass:= body[i5].zi[j];
                             end;
                              if (body[i5].zi[j]>zEass) then
                             begin
                                zEass:= body[i5].zi[j];
                             end;
                              // h хвост.
                              if (body[i5].yi[j]<ySass) then
                             begin
                                ySass:= body[i5].yi[j];
                             end;
                              if (body[i5].yi[j]+body[i5].hi[j]>yEass) then
                             begin
                                yEass:= body[i5].yi[j]+body[i5].hi[j];
                             end;
                         end;
                      3 : begin
                             // YZ
                             if (body[i5].yi[j]<ySass) then
                             begin
                                ySass:= body[i5].yi[j];
                             end;
                             if (body[i5].yi[j]>yEass) then
                             begin
                                yEass:= body[i5].yi[j];
                             end;
                             if (body[i5].zi[j]<zSass) then
                             begin
                                zSass:= body[i5].zi[j];
                             end;
                              if (body[i5].zi[j]>zEass) then
                             begin
                                zEass:= body[i5].zi[j];
                             end;
                               // h хвост.
                              if (body[i5].xi[j]<xSass) then
                             begin
                                xSass:= body[i5].xi[j];
                             end;
                              if (body[i5].xi[j]+body[i5].hi[j]>xEass) then
                             begin
                                xEass:= body[i5].xi[j]+body[i5].hi[j];
                             end;
                          end;
                      end;
                   end;

               end;
            end;
         end;

         s:=FloatToStr(xSass-Laplas.myassembles[i].xmin)+' ';
         s:=s+FloatToStr(xEass+Laplas.myassembles[i].xmax)+' ';
         s:=s+FloatToStr(ySass-Laplas.myassembles[i].ymin)+' ';
         s:=s+FloatToStr(yEass+Laplas.myassembles[i].ymax)+' ';
         s:=s+FloatToStr(zSass-Laplas.myassembles[i].zmin)+' ';
         s:=s+FloatToStr(zEass+Laplas.myassembles[i].zmax)+' ';
         s:=s+IntToStr(Laplas.myassembles[i].identifire)+' ';
         s:=s+IntToStr(Laplas.myassembles[i].inxloc)+' ';
         s:=s+IntToStr(Laplas.myassembles[i].inyloc)+' ';
         s:=s+IntToStr(Laplas.myassembles[i].inzloc)+' ';
          f.Add(s);
      end;
   end;


   // Запись информации о решаемых уравнениях.
   s:=IntToStr(egddata.itemper)+' '+IntToStr(egddata.imaxflD)+' ';
   f.Add(s);
   for i:=0 to egddata.imaxflD-1 do
   begin
      s:=FloatToStr(egddata.myflmod[i].xc)+' '+FloatToStr(egddata.myflmod[i].yc)+' ';
      s:=s+FloatToStr(egddata.myflmod[i].zc)+' ';
      s:=s+IntToStr(egddata.myflmod[i].iflow)+' ';
      s:=s+IntToStr(egddata.myflmod[i].iflowregime)+' ';
      s:=s+IntToStr(egddata.myflmod[i].iturbmodel)+' ';
      // параметры модели Смагоринского
      s:=s+FloatToStr(egddata.myflmod[i].SmagConst)+' ';
      s:=s+IntToStr(egddata.myflmod[i].iDynamicStressGermano)+' ';
      s:=s+IntToStr(egddata.myflmod[i].iLimitersCs)+' ';
      s:=s+FloatToStr(egddata.myflmod[i].minCs)+' ';
      s:=s+FloatToStr(egddata.myflmod[i].maxCs)+' ';
      s:=s+IntToStr(egddata.myflmod[i].itypeFiltrGermano)+' ';
      s:=s+FloatToStr(egddata.myflmod[i].roughness)+' ';
      s:=s+FloatToStr(egddata.myflmod[i].rRimult)+' ';
      s:=s+FloatToStr(egddata.myflmod[i].rSelectiveAngle)+' ';
      s:=s+IntToStr(egddata.myflmod[i].ipowerroughness)+' ';
      s:=s+IntToStr(egddata.myflmod[i].itypefiltr)+' ';
      // учёт неравномерности сетки.
      if (egddata.myflmod[i].bfdelta) then
      begin
         s:=s+'1 ';
      end
      else
      begin
         s:=s+'0 ';
      end;
      // модель Смагоринского-Лиллу.
      if (egddata.myflmod[i].bSmagorinsky_Lilly) then
      begin
         s:=s+'1 ';
      end
      else
      begin
         s:=s+'0 ';
      end;
      // учёт шероховатости стенки.
      if (egddata.myflmod[i].bsurface_roughness) then
      begin
         s:=s+'1 ';
      end
      else
      begin
         s:=s+'0 ';
      end;
      // учёт течений с кривизной линий тока.
      if (egddata.myflmod[i].bSwirlamendment) then
      begin
         s:=s+'1 ';
      end
      else
      begin
         s:=s+'0 ';
      end;
      // учёт избирательности в модели Смагоринского.
      if (egddata.myflmod[i].bSelectiveSmagorinsky) then
      begin
         s:=s+'1 ';
      end
      else
      begin
         s:=s+'0 ';
      end;
      f.Add(s);
   end;
      // Для подготовки картинок в отчете 05.01.2018
      s:=Trim(Editminimum.Text)+' '+Trim(Editmaximum.Text)+' '+IntToStr(ComboBoxdirectional.ItemIndex)+' ';
      f.Add(s);
       if (Formamg1r5Parameters.CheckBox_amg1r6.Checked) then
      begin
         s:='1 ';
      end
      else
      begin
         s:='0 ';
      end;
      f.Add(s);
      s:='1131 ';
      case Formamg1r5Parameters.ComboBoxNumber_of_smootherssteps.ItemIndex of
         0 : s[2]:='1';
         1 : s[2]:='2';
         2 : s[2]:='3';
      end;
      case Formamg1r5Parameters.ComboBoxTypeSmoother.ItemIndex of
         0 : begin
                s[3]:='3'; // C/F relaxation
                s[4]:='1';
             end;
         1 : begin
                s[3]:='2'; // Full GS SWEEP
                s[4]:='2';
             end;
         2 : begin
                s[3]:='4'; // Full MORE COLOR SWEEP
                s[4]:='4';
             end;
         3 : begin
                s:='11122 '; // ILU(lfil) smoother
                 case Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex of
                 0 : s[3]:='1';
                 1 : s[3]:='2';
                 2 : s[3]:='3';
                end;
             end;
      end;
      f.Add(s);
      s:='1131 ';
      case Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex of
         0 : s[2]:='1';
         1 : s[2]:='2';
         2 : s[2]:='3';
      end;
      case Formamg1r5Parameters.ComboBoxTypePostSmoother.ItemIndex of
         0 : begin
                s[3]:='3'; // C/F relaxation
                s[4]:='1';
             end;
         1 : begin
                s[3]:='2'; // Full GS SWEEP
                s[4]:='2';
             end;
         2 : begin
                s[3]:='4'; // Full MORE COLOR SWEEP
                s[4]:='4';
             end;
         3 : begin
                s:='11122 '; // ILU(lfil) smoother
                 case Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex of
                 0 : s[3]:='1';
                 1 : s[3]:='2';
                 2 : s[3]:='3';
                end;
             end;
      end;
      f.Add(s);
      s:=Trim(Formamg1r5Parameters.Editstrongthreshold.Text)+' ';
      f.Add(s);
      s:=Trim(Formamg1r5Parameters.EditF2F.Text)+' ';
      f.Add(s);
      // # processors
      s:=IntToStr(1+FormSetting.ComboBoxNumberProcessors.ItemIndex)+' ';
      f.Add(s);
      // # iterations SIMPLE Algorithm
      s:=IntToStr(FormUnsteady.ComboBoxNumberIterationsSIMPLEAlgoritm.ItemIndex)+' ';
      f.Add(s);
      // amg1r5 stabilization: 0 - none, 1 - bicgstab, 2 - fgmres, 3 - nonlinear.
      s:=IntToStr(Formamg1r5Parameters.ComboBoxStabilization.ItemIndex)+' ';
      f.Add(s);


   // Дело в том что компилятор языка СИ понимает только точку
   // в качестве разделителя целой и дробной части, поэтому
   // если в системе windows установлена запятая в качестве разделителя
   // целой и дробной части то Delphi печатает все свои данные с разделителем запятая,
   // которая при передаче в си файл должна стать точкой.
   if (FormatSettings.DecimalSeparator=',') then
   begin
      // заменить все запятые в файле на точки.
      for i:=0 to f.Count-1 do
      begin
         s:=f.Strings[i];
         f.Strings[i]:=StringReplace(s,',','.',[rfReplaceAll]);
      end;
   end;

   if not(bmodelcheck) then
   begin
      if (adiabatic_vs_heat_transfer_coeff>0) then
      begin
        // при условии Ньютона-Рихмана можно считать и без наличия условия Дирихле.
        // аналогичный случай с условием Стефана-Больцмана и смешанного условия.
        bmodelcheck:=true;
      end;

      if (FormUnsteady.RadioGroup1.ItemIndex=1) then
      begin
        // нестационарное моделирование
        bmodelcheck:=true; // при нестационарном моделировании можно считать и без теплоотвода.
      end;
   end;


  // if (bmodelcheck and bmodelcheck_cab_hollow) then
  if (true) then // Убрал защиту.
   begin
      // модель прошла проверку на корректность.

   f.SaveToFile('premeshin.txt'); // сохранение результата
   if ((egddata.imaxflD=0) or ((egddata.imaxflD=1) and (egddata.itemper>0) and(egddata.myflmod[0].iflow=0))) then
   begin
      // Есть одна Fluid зона но она не активна.

      // Мы имеем дело с задачей чистой теплопроводности,
      // следующий код запускает задачу чистой теплопроводности
      // в твёрдом теле.
     // f.SaveToFile('test_pattern/solver/solid_static/premeshin.txt');
      f.Clear;
      MainMemo.Lines.Add('File successfully written premeshin.txt.');


      if (bonly_mesh_gen_call) then
      begin
         MainMemo.Lines.Add('Meshing started.');
      end
      else
      begin
         MainMemo.Lines.Add('Calculation started.');
      end;
      //ShellExecute(Laplas.Handle,'open','solver/solid_static/AliceFlow_v0_07.exe',nil,nil,SW_SHOWNORMAL);
      //WinExec('solver/solid_static/AliceFlow_v0_07.exe',SW_SHOWNORMAL);

      DeleteFile('avtosave.txt');

      // Запускает приложение и ждёт окончания его работы.
      if (FormSetting.rgParallel.ItemIndex=0) then
      begin

      (*
         // Serial
        // CreateProcess(nil,'test_pattern/solver/solid_static/AliceFlow_v0_07.exe',nil,nil,false,Create_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
        //     nil,nil,StartupInfo,ProcessInfo);

        ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        if (FormUnsteady.RadioGroup1.ItemIndex=0) then
        begin
           // Steady Calculation
           ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_07.exe"');
        end
        else
        begin
           // Unsteady Calculation
           ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_07Unsteady.exe"');
        end;
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;
        *)



          MyThread1:=TmyThread1.Create(true);
          // поток завершиться автоматически.
          MyThread1.FreeOnTerminate:=true;
          MyThread1.Priority:=tpLower;
          MyThread1.Resume;



      end
      else
      begin
          // MainMemo.Lines.Add('Solver not started. Solver not found. Use Serial solver.');
           //ShowMessage('Use Serial Solver');
           MainMemo.Lines.Add('WARNING! We use x86 version.');
      {
         // Parallel
         //CreateProcess(nil,'test_pattern/solver/solid_static/AliceFlow_v0_07P.exe',nil,nil,false,Create_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
          //   nil,nil,StartupInfo,ProcessInfo);

          ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        // Паралельный солвер для чистой теплопроводности не реализован.
        ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_07P.exe"');
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;
        }

           MyThread1:=TmyThread1.Create(true);
          // поток завершиться автоматически.
          MyThread1.FreeOnTerminate:=true;
          MyThread1.Priority:=tpLower;
          MyThread1.Resume;

      end;
      //WaitforSingleObject(ProcessInfo.hProcess,INFINITE);



   end
   else if ((egddata.imaxflD=1) and (egddata.itemper=0)) then
   begin

      //f.SaveToFile('test_pattern/solver/fluid_static/premeshin.txt');
      // Мы имеем дело с задачей чистой стационарной гидродинамики.
      if (FileExists('premeshin.txt')) then
      begin

      f.Clear;
      MainMemo.Lines.Add('File successfully written premeshin.txt.');
      if (bonly_mesh_gen_call) then
      begin
         MainMemo.Lines.Add('Meshing started.');
      end
      else
      begin
         MainMemo.Lines.Add('Calculation started.');
      end;
      // Удаление файла avtosave.txt
       if DeleteFile('avtosave.txt') then
            MainMemo.Lines.Add('File avtosave.txt removed!')
       else MainMemo.Lines.Add('Avtosave.txt file can not be deleted because likely exist.');
      DeleteFile('statistic_convergence.txt');
      // Запускает приложение и ждёт окончания его работы.
      //CreateProcess(nil,'test_pattern/solver/fluid_static/AliceFlow_v0_07.exe',nil,nil,false,Create_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
        //     nil,nil,StartupInfo,ProcessInfo);

        (*
        ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        if (FormSetting.rgParallel.ItemIndex=0) then
        begin
           // однопоточная версия.
           ShellInfo.lpFile:=PChar('"test_pattern\solver\fluid_static\AliceFlow_v0_07.exe"');
        end;
         if (FormSetting.rgParallel.ItemIndex=1) then
        begin
           // параллельные вычисления.
           ShellInfo.lpFile:=PChar('"test_pattern\solver\fluid_static\AliceFlow_v0_07P.exe"');
        end;
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;

      //WaitforSingleObject(ProcessInfo.hProcess,INFINITE);
      *)

        DeleteFile('statistic_convergence.txt');
          if (Laplas.egddata.itemper>0) then
          begin
               if ((Laplas.egddata.myflmod[0].iflowregime=1) and
                   (Laplas.egddata.myflmod[0].iturbmodel=6)) then
                begin
                    // Модель Лангтрии Ментора gamma-ReTheta-SST [2009].
                    Formresidual2.brun_visible2:=false;
                    FormResidualSATemp.brun_visibleSA2:=false;
                    FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                    FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=true;
                    FormResidual_Lagtry_Menter_Temp.Show;
                end
                else
               if ((Laplas.egddata.myflmod[0].iflowregime=1)and
               (Laplas.egddata.myflmod[0].iturbmodel=5)) then
                begin
                    // Standart K-Epsilon model на основе двухслойной модели [2001].
                    Formresidual2.brun_visible2:=false;
                    FormResidualSATemp.brun_visibleSA2:=false;
                    FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                    FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=true;
                    FormResidualStandart_k_epsilon_Temp.Show;
                end
                else
               if ((Laplas.egddata.myflmod[0].iflowregime=1)and
               (Laplas.egddata.myflmod[0].iturbmodel=4)) then
                begin
                    // K-Omega SST Menter [1993]
                    Formresidual2.brun_visible2:=false;
                    FormResidualSATemp.brun_visibleSA2:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                    FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                    FormResidualSSTTemp.brun_visibleSSTTemp:=true;
                    FormResidualSSTTemp.Show;
                end
                else
               if ((Laplas.egddata.myflmod[0].iflowregime=1)and
               (Laplas.egddata.myflmod[0].iturbmodel=3)) then
                begin
                    // Спаларт Аллмарес [1992]
                    Formresidual2.brun_visible2:=false;
                    FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                    FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                    FormResidualSATemp.brun_visibleSA2:=true;
                    FormResidualSATemp.Show;
                end
                else
                begin
                   FormResidualSATemp.brun_visibleSA2:=false;
                   FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                   FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                   FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                   Formresidual2.brun_visible2:=true;
                   Formresidual2.Show;
                end;
          end
           else
          begin
             if (egddata.iStaticStructural=0) then
             begin
                if (Laplas.egddata.myflmod[0].iturbmodel=6) then
                begin
                   // Модель Ментора Лантгрии gamma-ReTheta-SST
                   FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=true;
                   FormResidual_Langtry_Menter.Show;
                end
                else
                if (Laplas.egddata.myflmod[0].iturbmodel=5) then
                begin
                   // Standart K-Epsilon model
                   FormResidualStandartKEpsilon.brun_visibleKEpsilon:=true;
                   FormResidualStandartKEpsilon.Show;
                end
                else
                if (Laplas.egddata.myflmod[0].iturbmodel=4) then
                begin
                   // SST Ментер
                   FormResidualSST.brun_visibleSST:=true;
                   FormResidualSST.Show;
                end
                else
                if (Laplas.egddata.myflmod[0].iturbmodel=3) then
                begin
                   // Спаларт Аллмарес
                   FormResidualSpallart_Allmares.brun_visibleSA:=true;
                   FormResidualSpallart_Allmares.Show;
                end
                else
                begin
                   Formresidual.brun_visible:=true;
                   Formresidual.Show;
                end;
             end;
          end;

          MyThread2:=TmyThread2.Create(true);
          // поток завершиться автоматически.
          MyThread2.FreeOnTerminate:=true;
          MyThread2.Priority:=tpLower;
          MyThread2.Resume;



       end
      else
      begin
         Laplas.MainMemo.Lines.Add('premeshin.txt not found.');
      end;

   end
   else if ((egddata.imaxflD=1) and (egddata.itemper>0) and(egddata.myflmod[0].iflow=1)) then
   begin
      // Считается первая Fluid зона и только она.

      // f.SaveToFile('test_pattern/solver/conjugate_heat_transfer_static/premeshin.txt');
      // Мы имеем дело с задачей чистой стационарной гидродинамики.
      if (FileExists('premeshin.txt')) then
      begin

      f.Clear;
      MainMemo.Lines.Add('File successfully written premeshin.txt.');
      if (bonly_mesh_gen_call) then
      begin
         MainMemo.Lines.Add('Meshing started.');
      end
       else
      begin
         MainMemo.Lines.Add('Calculation started.');
      end;
      // Удаление файла avtosave.txt
      if DeleteFile('avtosave.txt') then
            MainMemo.Lines.Add('File avtosave.txt successfully removed !')
      else MainMemo.Lines.Add('Avtosave.txt file can not be deleted because likely exist.');
       DeleteFile('statistic_convergence.txt');
      // Запускает приложение и ждёт окончания его работы.
      // CreateProcess(nil,'test_pattern/solver/conjugate_heat_transfer_static/AliceFlow_v0_07.exe',nil,nil,false,Create_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
      //        nil,nil,StartupInfo,ProcessInfo);
      //WaitforSingleObject(ProcessInfo.hProcess,INFINITE);

        (*
        ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        ShellInfo.lpFile:=PChar('"test_pattern\solver\conjugate_heat_transfer_static\AliceFlow_v0_07.exe"');
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;
        *)

          DeleteFile('statistic_convergence.txt');
          if (Laplas.egddata.itemper>0) then
          begin
           if ((Laplas.egddata.myflmod[0].iflowregime=1)and
               (Laplas.egddata.myflmod[0].iturbmodel=6)) then
                begin
                    // Модель ламинарно турбулентного перехода Ментора Лантгрии [2009]
                    Formresidual2.brun_visible2:=false;
                    FormResidualSATemp.brun_visibleSA2:=false;
                    FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                       FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=true;
                    FormResidual_Lagtry_Menter_Temp.Show;
                end
                else
              if ((Laplas.egddata.myflmod[0].iflowregime=1)and
               (Laplas.egddata.myflmod[0].iturbmodel=5)) then
                begin
                    // Standart K-Epsilon на основе двухслойной модели [2001]
                    Formresidual2.brun_visible2:=false;
                    FormResidualSATemp.brun_visibleSA2:=false;
                    FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                    FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=true;
                    FormResidualStandart_k_epsilon_Temp.Show;
                end
                else
              if ((Laplas.egddata.myflmod[0].iflowregime=1)and
               (Laplas.egddata.myflmod[0].iturbmodel=4)) then
                begin
                    // K-Omega SST Menter [1993]
                    Formresidual2.brun_visible2:=false;
                    FormResidualSATemp.brun_visibleSA2:=false;
                    FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                    FormResidualSSTTemp.brun_visibleSSTTemp:=true;
                    FormResidualSSTTemp.Show;
                end
                else
               if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                   (Laplas.egddata.myflmod[0].iturbmodel=3)) then
                begin
                   // Спаларт Аллмарес
                   FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                   Formresidual2.brun_visible2:=false;
                   FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                   FormResidualSATemp.brun_visibleSA2:=true;
                   FormResidualSATemp.Show;
                end
                 else
                begin
                   FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                   FormResidualSATemp.brun_visibleSA2:=false;
                   FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                   Formresidual2.brun_visible2:=true;
                   Formresidual2.Show;
                end;
          end
           else
          begin
               if (Laplas.egddata.myflmod[0].iturbmodel=6) then
               begin
                   // Модель Ментора Лантгрии 2009. gamma-ReTheta-SST
                   FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=true;
                   FormResidual_Langtry_Menter.Show;
                end
                else
               if (Laplas.egddata.myflmod[0].iturbmodel=5) then
               begin
                   // Standart K-Epsilon
                   FormResidualStandartKEpsilon.brun_visibleKEpsilon:=true;
                   FormResidualStandartKEpsilon.Show;
                end
                else
                if (Laplas.egddata.myflmod[0].iturbmodel=4) then
                begin
                   // SST Ментер
                   FormResidualSST.brun_visibleSST:=true;
                   FormResidualSST.Show;
                end
                else
             if (Laplas.egddata.myflmod[0].iturbmodel=3) then
             begin
                FormResidualSpallart_Allmares.brun_visibleSA:=true;
                FormResidualSpallart_Allmares.Show;
             end
             else
             begin
                Formresidual.brun_visible:=true;
                Formresidual.Show;
             end;
          end;

          MyThread3:=TmyThread3.Create(true);
          // поток завершиться автоматически.
          MyThread3.FreeOnTerminate:=true;
          MyThread3.Priority:=tpLower;
          MyThread3.Resume;


      end
      else
      begin
         MainMemo.Lines.Add('premeshin.txt not found.');
      end;

     end
      else
     begin
        MainMemo.Lines.Add('The solver is not running because we are dealing with an unforeseen situation.');
        MainMemo.Lines.Add('Perhaps the number of isolated Fluid zones exceeds one.');

        // Запускаем на свой страх и риск больше одной fluid зоны.
        (*
        if (FileExists('premeshin.txt')) then
        begin

           f.Clear;
           MainMemo.Lines.Add('File successfully written premeshin.txt.');
           if (bonly_mesh_gen_call) then
           begin
              MainMemo.Lines.Add('Meshing started.');
           end
            else
           begin
              MainMemo.Lines.Add('Calculation started.');
           end;
           // Удаление файла avtosave.txt
           if DeleteFile('avtosave.txt') then
               MainMemo.Lines.Add('File avtosave.txt successfully removed !')
           else MainMemo.Lines.Add('Avtosave.txt file can not be deleted because likely exist.');
               DeleteFile('statistic_convergence.txt');

               DeleteFile('statistic_convergence.txt');
               Formresidual.Show;

            MyThread3:=TmyThread3.Create(true);
            // поток завершиться автоматически.
            MyThread3.FreeOnTerminate:=true;
            MyThread3.Priority:=tpLower;
            MyThread3.Resume;


         end
          else
         begin
            MainMemo.Lines.Add('premeshin.txt not found.');
         end;
         *)
     end;
   end
   else
   begin
      MainMemo.Lines.Add('Созданная вами модель некорректна. Возможно отсутствует теплоотвод.');
      MainMemo.Lines.Add('Решатель не может быть запущен.');
      ShowMessage('Созданная вами модель некорректна. Возможно отсутствует теплоотвод.');
   end;
   f.Free;
      end;


   end
    else
   begin
      // вычисление уже запущено.
      //ShowMessage('The calculation is already running');
      irun:=Application.MessageBox('The calculation is already running. Ok-LOCK, Cancel-Recalculation.','Clean history and restart.',mb_OkCancel);
      if (irun=1) then
      begin
         brun:=false;
      end;
   end;


end;

procedure TLaplas.WriteStartSolutionNEW(Sender: TObject);
var
    f, fpiecewise, freport : TStringList; // переменная типа объект TStringList
    s,subx,sub,s1, s2, spiecewise : String; // текущая рабочая строка
    i, i1,i2,i3, i_4, j, i_2, i_3, i_1, i_piecewise : Integer; // текущий номер блока или источника при записи
    xavg, yavg, zavg, powertri : Real;
    Sc : Real; // мощность тепловыделения на единицу объёма
    // StartupInfo:TStartupInfo;  // Устаревший синтаксис.
    //ProcessInfo:TProcessInformation;
    fmin, fmax : Real;
    starttime, endtime, deltatime : TTime;
    ShellInfo : TShellExecuteInfo;
    ExitCode : DWORD;
    QuoteParams : Boolean;
    bmodelcheck, bmodelcheck_cab_hollow : Boolean; // проверка на наличие теплоотвода.
    bOk : Boolean;
    irun : Integer;
    // Для сортировки блоков по приоритетам.
    // isort, jsort : Integer;
    // body_change : TBody;
    cab_geom, cab_geom2 : Visible_Line;
    lw_dec : Integer;
    myDate : TDateTime;
    checkFLUIDtoSOLID, bf7 : Boolean;
    // для преобразования Цилиндра в призму.
    xS1, yS1, zS1, xE1, yE1, zE1 : Real;
    iu_number, i5 :   Integer;
    xSass, xEass, ySass, yEass, zSass, zEass : Real;

    procedure FixHeap(root : Integer; m : TBody; bound : Integer; iadd : Integer);
var
   vacant, largerChild : Integer;
   lCadd, lCadd1 : Integer;
begin
   vacant:=root;
   while (2*vacant<=bound) do
   begin
      largerChild:=2*vacant;
      lCadd:=largerChild+iadd;
      lCadd1:=lCadd+1;
      if ((largerChild<bound)and(body[lCadd1].priority>body[lCadd].priority)) then
      begin
         inc(largerChild);
      end;
      lCadd:=largerChild+iadd;
      if (m.priority>body[lCadd].priority) then
      begin
        break;
      end
      else
      begin
         body[vacant+iadd]:=body[lCadd];
         vacant:=largerChild;
      end;
   end;
   body[vacant+iadd]:=m;
end;

// Пирамидальная сортировка.
procedure HeapSort(first,last : Integer);
var
   body_buf : TBody;
   i9 : Integer;
begin
   for i9 := ((last-first+1) div 2) downto 1 do
   begin
      FixHeap(i9,body[i9+first-1],last-first+1,first-1);
   end;
   for i9 := last-first+1 downto 2 do
     begin
       body_buf:=body[first];
       FixHeap(1,body[i9+first-1],i9-1,first-1);
       body[i9+first-1]:=body_buf;
     end;
end;

begin
   checkFLUIDtoSOLID:=false; // 8 september 2017 не трогать т.к. усторело.

   if (brun) then
   begin
      // мы спрашиваем снять ли защиту от уже запущенного вычисления.
      irun:=Application.MessageBox('The calculation is already running. Ok-LOCK, Cancel-Recalculation.','Clean history and restart.',mb_OkCancel);
      if (irun=1) then
      begin
         brun:=false;
      end;
   end;


   // Установка переменой TDateTime в полное значение даты и времени:
   // 09/02/2000 в 01:02:03.004 (.004 миллисекунд).
   //myDate:=EncodeDataTime(2000, 2, 9, 1, 2, 3, 4);
   myDate:=Now;
   MainMemo.Lines.Add('solver start '+FormatDateTime('c',myDate));
   freport:=TStringList.Create();
   freport.Add('solver start '+FormatDateTime('c',myDate));
   freport.Add('Project name '+Laplas.Caption);
   freport.Add('');
   freport.SaveToFile('report_temperature.txt');
   freport.Free;


   if (not(brun)) then
   begin
      brun:=true;

      // Автоматическое переключение на теплопередачу в твёрдом теле с cfd
      // если сила тяжести нулевая а на всех стенках стоит условие прилипания
      // к неподвижной стенке т.е. условие по умолчанию.
      if ((abs(gx)<1.0e-20) and (abs(gy)<1.0e-20) and (abs(gz)<1.0e-20)) then
      begin
         bOk:=true;
         for i := 0 to lw-1 do
         begin
            if ((wall[i].bpressure=false)
            and (wall[i].bopening=false) and
            (abs(wall[i].Vx)<1.0e-20) and
            (abs(wall[i].Vy)<1.0e-20) and
            (abs(wall[i].Vz)<1.0e-20)) then
            begin
               // Выполняется условие прилипания к неподвижной стенке по скорости,
               // т.е. условие по умолчанию.
            end
            else
            begin
               // Это точно НЕ условие по умолчанию по скорости, поэтому
               // нужно решать гидродинамику.
                bOk:=false;
            end;
         end;

         // Включаем теплопередачу в твёрдом теле.
         if (bOk) then
         begin
            // Делаем умное переключение т.к. решаем только уравнение
            // теплопередачи в твёрдом теле.

             // Чисто теплопередача в твёрдом теле.
             if (egddata.iStaticStructural=0) then
             begin
                egddata.imaxflD:=1;
                if (egddata.itemper=0) then
                begin
                   egddata.itemper:=1; // МКО
                end;
                egddata.myflmod[0].iflow:=0;
             end;
             if (egddata.iStaticStructural=1) then
             begin
                 // Static Structural only
                egddata.imaxflD:=1;
                // Не нужно делать здесь принудительного присваивания.
                // Пользователь уже сделал выбор в интерфейсе выше.
                //egddata.itemper:=0;
                egddata.myflmod[0].iflow:=0;
             end;
         end;
      end;



   //  Проблема теплоотвода в задачах чистой теплопередачи :
   //  Если рассматривать задачу чистой теплопередачи
   //  то в ней необходимо наличие изотермической поверхности иначе задача
   //  неопределена в стационарной постановке (имеется бесконечная температура при наличии)
   //  источников тепла и отсутствии теплоотвода.
   // В задачах вычислительной гидродинамики также чрезвычайно важно наличие
   // стенки на которой задана скорость потока.
   // Есть и более тонкие ситуации но о них позже, т.к. сначала нужно добиться
   // 100% работоспособности простых ситуаций.
   bmodelcheck:=false; // по умолчанию модель не проходит проверку.
   // Проверка правильности размеров объектов модели при типе кбинета hollow.
   // По умолчанию всё корректно.
   bmodelcheck_cab_hollow:=true;


   if (((egddata.imaxflD=0) and (egddata.itemper>0)) or
   ((egddata.imaxflD=1) and (egddata.itemper>0)
   and(egddata.myflmod[0].iflow=0))) then
   begin
      // Чистая теплопередача
      // в твёрдом теле.
      if (FormUnsteady.RadioGroup1.ItemIndex=0) then
      begin
         // Стационарный расчёт.
         FormUnsteady.PanelTime.Visible:=false;
      end
      else
      begin
         // Нестационарный расчёт.
         FormUnsteady.PanelTime.Visible:=true;
      end;
      FormUnsteady.RadioGroup1.Visible:=true;
      FormUnsteady.GroupBoxNumberIterationsSimpleAlgorithm.Visible:=false;
   end
   else
   begin
      // запускаем tecplot 360 в любом случае.
      //FormUnsteady.CheckBoxdonttec360.Checked:=false;
      FormUnsteady.PanelTime.Visible:=false;
      FormUnsteady.RadioGroup1.Visible:=false;
      if (not(bonly_mesh_gen_call)) then
      begin
         // только если это не вызов сеточного генератора.
         FormUnsteady.GroupBoxNumberIterationsSimpleAlgorithm.Visible:=true;
      end
      else
      begin
         FormUnsteady.GroupBoxNumberIterationsSimpleAlgorithm.Visible:=false;
      end;
   end;
   if (bonly_mesh_gen_call) then
   begin
      FormUnsteady.GroupBox1.Top:=5;
      // Только построение расчётной сетки.
      FormUnsteady.PanelTime.Visible:=false;
      FormUnsteady.RadioGroup1.Visible:=false;
      // FormUnsteady.ButtonTimeStepLaw.Visible:=false;
      FormUnsteady.ClientHeight:=180;
      FormUnsteady.Height:=243;
      FormUnsteady.ButtonCalc.Caption:='Meshing start';
   end
    else
   begin
      FormUnsteady.PanelTime.Visible:=true;
      FormUnsteady.RadioGroup1.Visible:=true;
      FormUnsteady.GroupBox1.Top:=215;
      FormUnsteady.ClientHeight:=409;
      FormUnsteady.Height:=448;
      FormUnsteady.ButtonCalc.Top:=163;
      //FormUnsteady.ButtonTimeStepLaw.Visible:=true;
      FormUnsteady.ButtonCalc.Caption:='Calculation start';
      FormUnsteady.ButtonCalc.Visible:=true;
      FormUnsteady.RadioGroup1Click(Sender);
      FormUnsteady.ComboBoxTimeStepChange(Sender);
   end;
   if (not(bVisualization_Management_now)) then
   begin
      if (bOkTrials=true) then
      begin
         FormUnsteady.ShowModal;
      end
      else
      begin
         FormUnsteady.bRunOk:=true;
      end;
   end
   else
   begin
      FormUnsteady.bRunOk:=true;
   end;

    if (FormUnsteady.bRunOk=true) then
    begin
       FormUnsteady.bRunOk:=false;

   starttime:=Now(); // Началор счёта.
   f:=TStringList.Create();


   case ComboBoxlength.ItemIndex of
     0 : begin
            // m
            mlength:=1.0;
         end;
     1 : begin
            // mm
            mlength:=1e-3;
         end;
     2 : begin
            // micron
            mlength:=1e-6;
         end;
   end;

   i2:=0;
   for i1 := 1 to lb-1 do
   begin

      if ((body[i1].itype=1)or(body[i1].itype=2)) then
      begin
         // SOLID or HOLLOW
         inc(i2);
      end;
   end;

   s:='# This is internal input file for programm AliceFlow_v0_48.exe.';
   f.Add(s);
   s:='# If you found any problem for this file, please ';
   f.Add(s);
   s:='# send message on mail: kirill7785@mail.ru for support.';
   f.Add(s);
   s:='# AliceMesh_v0_45.exe - GUI, AliceFlow_v0_48.exe - Solver. 2009-2020.';
   f.Add(s);

   if FormUnsteady.CheckBoxonlysolidvisible.Checked=true then
   begin
       // печатает только твердотельное исполнение.
       // 18.02.2017 если есть хоть один solid block.
       //if ((egddata.imaxflD=1) and (i2>=1)) then
       if (((egddata.imaxflD=0) and (egddata.itemper>0)) or ((egddata.imaxflD=1) and (egddata.itemper>0) and(egddata.myflmod[0].iflow=0))) then
      begin
         // Чистая теплопередача
         // в твёрдом теле.
          // Если сетка грубая Coarse Mesh то твердотельная визуализация
          // даёт сбой т.к. при Coarse Mesh в твёрдом теле лишь одна клетка
          // и такая одноклеточная в толщину структура не образует nvtx
          // состоящий целиком из Solid'ов.
          s:='only_solid_visible=0 # 0 - OFF, 1 - ON';
          MainMemo.Lines.Add('Only solid blocks visible translated on all visible.');
          MainMemo.Lines.Add('Because using only thermal model without cfd.');
          FormUnsteady.CheckBoxonlysolidvisible.Checked:=false;
      end
       else
      begin
         s:='only_solid_visible=1 # 0 - OFF, 1 - ON';
      end;

   end
    else
   begin
      s:='only_solid_visible=0 # 0 - OFF, 1 - ON';
   end;
   f.Add(s);


   s:='mlength='+FloatToStr(mlength)+'  # 1.0 - m; 1.0e-3 - mm; 1.0e-6 - micron';
   f.Add(s);
   s:='lmatmax='+IntToStr(lmatmax)+' # number of matherials in model';
   f.Add(s);

   if (body[0].itype=3) then
   begin
      // Fluid.
      s:=IntToStr(lb)+' ';
   end
    else if (body[0].itype=2) then
   begin
       // HOLLOW
       s:=IntToStr(lb+1)+' ';
   end;
   s:='lb='+s+' # number of blocks in model';
   f.Add(s);


   s:='ls='+IntToStr(ls)+' # number of sources in model';
   f.Add(s);

   if (body[0].itype=3) then
   begin
      // Fluid
      s:=IntToStr(lw)+' ';
   end
   else if (body[0].itype=2) then
   begin
      // HOLLOW
      // нужно уменьшить счётчик на количество стенок жёстко связанных с кабинетом.
      // поскольку кабинета нет то и стенок жёстко связанных с геометрическими размерами
      // кабинета тоже нет.
      lw_dec:=0;
      for i:=0 to (lw-1) do
      begin
         if (wall[i].cabinet_depend>1) then
         begin
            inc(lw_dec);
         end;
      end;
      s:=IntToStr(lw-lw_dec)+' ';
   end;
   s:='lw='+s+' # number of wall in model';
   f.Add(s);

   s:='iltdp='+IntToStr(iltdp)+' # not usage. default value is 0.';
   f.Add(s);


   s:='gx='+ FloatToStr(gx)+' # gravity vector x component';
   f.Add(s);
   s:='gy='+ FloatToStr(gy)+' # gravity vector y component';
   f.Add(s);
   s:='gz='+ FloatToStr(gz)+' # gravity vector z component';
   f.Add(s);

   s:='inx='+ IntToStr(inx)+' # number control volume on x axis';
   f.Add(s);
   s:='iny='+ IntToStr(iny)+' # number control volume on y axis';
   f.Add(s);
   s:='inz='+ IntToStr(inz)+' # number control volume on z axis';
   f.Add(s);
   s:='operatingtemperature='+FloatToStr(operatingtemperature)+' # ambient temperature, C';
   f.Add(s);

   // заменить все запятые в FormSpeedInitialization на точки.
   s2:=FormSpeedInitialization.EditVx.Text;
   FormSpeedInitialization.EditVx.Text:=StringReplace(s2,',','.',[rfReplaceAll]);

   s2:=FormSpeedInitialization.EditVy.Text;
   FormSpeedInitialization.EditVy.Text:=StringReplace(s2,',','.',[rfReplaceAll]);

   s2:=FormSpeedInitialization.EditVz.Text;
   FormSpeedInitialization.EditVz.Text:=StringReplace(s2,',','.',[rfReplaceAll]);

   // Инициализация начальной скорости.
   s:='SpeedInitializationVx='+FormSpeedInitialization.EditVx.Text+' # initialization for x component velocity';
   f.Add(s);
   s:='SpeedInitializationVy='+FormSpeedInitialization.EditVy.Text+' # initialization for y component velocity';
   f.Add(s);
   s:='SpeedInitializationVz='+FormSpeedInitialization.EditVz.Text+' # initialization for z component velocity';
   f.Add(s);

   if (FormXYPlot.bfirst_zapusk_XYPlot) then
   begin
      if (ls>0) then
      begin
         // Инициализируем геометрическим центром первого источника тепла при его наличии.
         FormXYPlot.EditXo.Text:=FloatToStr(0.5*(source[0].xS+source[0].xE));
         FormXYPlot.EditYo.Text:=FloatToStr(0.5*(source[0].yS+source[0].yE));
         FormXYPlot.EditZo.Text:=FloatToStr(0.5*(source[0].zS+source[0].zE));
         if (ls>1) then
         begin
            if (abs(source[0].xS-source[1].xS)>1.0e-23) then
            begin
               FormXYPlot.ComboBoxdirectional.ItemIndex:=0; // X - directional
            end;
            if (abs(source[0].yS-source[1].yS)>1.0e-23) then
            begin
               FormXYPlot.ComboBoxdirectional.ItemIndex:=1; // Y - directional
            end;
            if (abs(source[0].zS-source[1].zS)>1.0e-23) then
            begin
               FormXYPlot.ComboBoxdirectional.ItemIndex:=2; // Z - directional
            end;
         end;
      end
       else
      begin
         // Инициализируем геометрическим центром кабинета.
         FormXYPlot.EditXo.Text:=FloatToStr(0.5*(body[0].xS+body[0].xE));
         FormXYPlot.EditYo.Text:=FloatToStr(0.5*(body[0].yS+body[0].yE));
         FormXYPlot.EditZo.Text:=FloatToStr(0.5*(body[0].zS+body[0].zE));
         i_3:=-1;
         for i_2 := 0 to lb-1 do
         begin
            if (body[i_2].n_power>0) then
            begin
               if ((i_3>-1)and(abs(body[i_2].arr_power[0])>0.0)) then
               begin
                  if (abs(body[i_3].xS-body[i_2].xS)>1.0e-23) then
                  begin
                     FormXYPlot.ComboBoxdirectional.ItemIndex:=0; // X - directional
                  end;
                  if (abs(body[i_3].yS-body[i_2].yS)>1.0e-23) then
                  begin
                     FormXYPlot.ComboBoxdirectional.ItemIndex:=1; // Y - directional
                  end;
                  if (abs(body[i_3].zS-body[i_2].zS)>1.0e-23) then
                  begin
                     FormXYPlot.ComboBoxdirectional.ItemIndex:=2; // Z - directional
                  end;
                  break;
               end;
               if ((i_3=-1)and(abs(body[i_2].arr_power[0])>0.0)) then
               begin
                  i_3:=i_2;
                  FormXYPlot.EditXo.Text:=FloatToStr(0.5*(body[i_2].xS+body[i_2].xE));
                  FormXYPlot.EditYo.Text:=FloatToStr(0.5*(body[i_2].yS+body[i_2].yE));
                  FormXYPlot.EditZo.Text:=FloatToStr(0.5*(body[i_2].zS+body[i_2].zE));
               end;
            end;
         end;
      end;
      // Не снимаем флаг первого запуска.
   end;

   // XY-Plot
   // Построение графика Variation Plot с координатами передаваемыми из Delphi-интерфейса.
   s2:=Trim(FormXYPlot.EditXo.Text);
   FormXYPlot.EditXo.Text:=StringReplace(s2,',','.',[rfReplaceAll]);
   if (length(s2)=0) then
   begin
      ShowMessage('Xo XYPlot is empty');
   end;
   s2:=Trim(FormXYPlot.EditYo.Text);
   FormXYPlot.EditYo.Text:=StringReplace(s2,',','.',[rfReplaceAll]);
   if (length(s2)=0) then
   begin
      ShowMessage('Yo XYPlot is empty');
   end;
   s2:=Trim(FormXYPlot.EditZo.Text);
   FormXYPlot.EditZo.Text:=StringReplace(s2,',','.',[rfReplaceAll]);
   if (length(s2)=0) then
   begin
      ShowMessage('Zo XYPlot is empty');
   end;

   // Мы передаём точку через которую проходит линия и направление линии совпадающее
   // с направлением одной из осей декартовой прямоугольной системы координат.
   s:='XYPlotXo='+FormXYPlot.EditXo.Text+' # x coordinate for plot graphics.';
   f.Add(s);
   s:='XYPlotYo='+FormXYPlot.EditYo.Text+' # y coordinate for plot graphics.';
   f.Add(s);
   s:='XYPlotZo='+FormXYPlot.EditZo.Text+' # z coordinate for plot graphics.';
   f.Add(s);
   s:='line_directional='+IntToStr(FormXYPlot.ComboBoxdirectional.ItemIndex)+' # 0 - X; 1 - Y; 2 - Z.';
   f.Add(s);


   s:='etalon_max_size_ratio='+ FloatToStr(etalon_max_size_ratio)+'  # recomended value 2 - 10';
   f.Add(s);
   s:='etalon_max_size_ratio2='+FloatToStr(etalon_max_size_ratio2)+' # recomended value 30 - 1e9';
   f.Add(s);

   // Snap to grid
   s:=IntToStr(MeshForm.ComboBoxSnapTo.ItemIndex)+' ';
   s:='snap_to_grid='+s+' # not usage. recomended value is 0. 0 - none, 1 - snap to, 2 - snap to ALICE, 3 - snap to ++.';
   f.Add(s);


   for i:=0 to (lw-1) do
   begin
      if ((wall[i].family=3) or (wall[i].family=4)) then
      begin
         // Чистая теплопередача
         // в твёрдом теле.

         // На стенке задано нелинейное условие Стефана-Больцмана или Ньютона-Рихмана.
         // Это условие возможно только для твёрдотельной постановки задачи (без гидродинамики).
         // На данный момент 1 мая 2016 с этим условием справляется только РУМБА решатель cl_agl_amg_v0_14.
         // Поэтому здесь будет осуществлён перевод решателя на этот солвер.
         // FormSetting.rgsolver.ItemIndex:=3; // РУМБА решатель.
         // MainMemo.Lines.Add('с граничным условием Ньютона-Рихмана или Стефана-Больцмана на wall стенке ');
         // MainMemo.Lines.Add('на данный момент справляется только РУМБА v0_14 решатель.');
         // MainMemo.Lines.Add('решатель переведён на РУМБА v0_14 алгоритм.');
         // РУМБА 0.14 решатель в случае сбоя пытается справиться с проблемой своими силами
         // не привлекая сторонних решателей.
      end;
   end;

   if (adiabatic_vs_heat_transfer_coeff>0) then
   begin
      if (((egddata.imaxflD=0) and (egddata.itemper>0)) or ((egddata.imaxflD=1) and (egddata.itemper>0) and(egddata.myflmod[0].iflow=0))) then
      begin
         // Чистая теплопередача
         // в твёрдом теле.

         // По умолчанию условие Ньютона Рихмана на всей default границе.
         // Это условие возможно только для твёрдотельной постановки задачи (без гидродинамики).
         // На данный момент 1 мая 2016 с этим условием справляется только РУМБА решатель cl_agl_amg_v0_14.
         // Поэтому здесь будет осуществлён перевод решателя на этот солвер.
         //FormSetting.rgsolver.ItemIndex:=3; // РУМБА решатель.
         //MainMemo.Lines.Add('с граничным условием Ньютона-Рихмана, Стефана-Больцмана,');
         //MainMemo.Lines.Add('смешанным условием (Излучение плюс конвекция) на default границе ');
         //MainMemo.Lines.Add('на данный момент справляется только РУМБА v0_14 решатель.');
         //MainMemo.Lines.Add('решатель переведён на РУМБА v0_14 алгоритм.');
         // РУМБА 0.14 решатель в случае сбоя пытается справиться с проблемой своими силами
         // не привлекая сторонних решателей.
      end
       else
      begin
         // Решаем Навье - Стокса
         // значит это условие на default границе (Ньютона - Рихмана) надо вырубить за ненадобностью.
         // надо выставить адиабатическую стенку.
         // адиабатическая стенка.
          MainMemo.Lines.Add('При решении уравнений Навье-Стокса граничное условие по');
          MainMemo.Lines.Add('умолчанию только адиабатическая стенка.');
          adiabatic_vs_heat_transfer_coeff:=0;
          filmcoefficient:=0.0;
          CabinetForm.ComboBoxFilmcoeff.ItemIndex:=0;
          CabinetForm.EditFilmCoefficient.Text:='0.0';
          CabinetForm.EditFilmCoefficient.Visible:=false;
          CabinetForm.LabelFilmCoefficient.Visible:=false;
          CabinetForm.Label3.Visible:=false;
      end;
   end;

   if (EGDForm.CBFlow.Checked = false) then
   begin
       if (egddata.imaxflD=0) then
      begin
         if (MeshForm.CheckBoxALICE.Checked = true) then
         begin
            if (FormSetting.ComboBoxSolverSetting.ItemIndex=2) then
            begin
               // bicgstab + ADI решатель.
               // не может быть использован на ALICE сетке.
                Laplas.MainMemo.Lines.Add('Do not supported ADI preconditioner in ALICE Mesh.');
                ShowMessage('Do not supported ADI preconditioner in ALICE Mesh. ADI off.  BiCGStab+ILU2 solver on.');
               // Солвер переводится на BiCGStab автоматическим образом.
               FormSetting.ComboBoxSolverSetting.ItemIndex:=0;
            end;
         end;
      end;
   end;

   // Выбор решающего устройства.
   s:='# 0 - BiCGStab +ILU(lfil); 1 - amg1r5 (r6); 2 - BiCGStab + ADI(not recomended);';
   f.Add(s);
   s:='# 3 - GIBRID; 4 - CUSP BiCGStab+AINV; 5 - AMGCL Denis Demidov; 6 - CPU CUSP BiCGStab + samg;';
   f.Add(s);
   s:='# 7 - Algebraic Multigrid RUMBA V0.14 (kirill7785@mail.ru); 8 - GPU CUSP BiCGStab + samg;';
   f.Add(s);
   s:='# 9 - ViennaCL BiCGStab + ILU0; 10 - FGMRes + ILU(lfil); 11 - CUSP BiCGStab + AINV;';
   f.Add(s);
   s:='SolverSetting='+IntToStr(FormSetting.ComboBoxSolverSetting.ItemIndex)+'  ';
   f.Add(s);
   // Static Structural linear equation solver.
   s:='# 0 - BiCGStab +ILU(lfil); 1 - Direct Method; 2 - Algebraic Multigrid RUMBA v0.14 (kirill7785@mail.ru)';
   f.Add(s);
   s:='# 3 - amg1r5 (r6); 4 - BiCGStab + amg1r5 (r6); 5 - FGMRes + amg1r5 (r6).';
   f.Add(s);
   s:='StaticStructuralSolverSetting='+IntToStr(FormSetting.ComboBoxStaticStructuralSolverSetting.ItemIndex)+'  ';
   f.Add(s);
   s:='# 0 - SIMPLE [1972]; 1 - SIMPLEC [1984];';
   f.Add(s);
   s:='PressureVelocityCoupling='+IntToStr(FormSetting.ComboBoxPressureVelocityCoupling.ItemIndex)+'   ';
   f.Add(s);
   s:='# 0 - CD, 1 - UDS, 2 - COMB, 3 - POLY, 4 - EXP, 5 - BULG, 6 - POW;';
   f.Add(s);
   s:='FlowSchemePrefix='+ IntToStr(FormSetting.ComboBoxFlowSchemePrefix.ItemIndex)+'  ';  // Prefix схема аппроксимации конвективного члена
   f.Add(s);
   s:='# 0 - Upwind; 1 - MUSCL; 2 - SOUCUP; 3 - HLPA; 4 - SMART; 5 - WACEB;';
   f.Add(s);
   s:='# 6 - SMARTER; 7 - LPPA; 8 - VONOS; 9 - STOIC; 10 -  CLAM; 11 - OSHER;';
   f.Add(s);
   s:='# 12 - EXPONENTIAL; 13 - SUPER-C;  14 - ISNAS; 15 - CUBISTA.';
   f.Add(s);
   s:='FlowScheme='+ IntToStr(FormSetting.ComboBoxFlowScheme.ItemIndex)+'  ';  // Схема аппроксимации конвективного члена
   f.Add(s);
   s:='SchemeTemperature='+ IntToStr(FormSetting.ComboBoxSchemeTemperature.ItemIndex)+'  ';  // Схема аппроксимации конвективного члена
   f.Add(s);

   if ((egddata.imaxflD=1) and (egddata.myflmod[0].iflow=1) and (i2>=10)) then
   begin
      // Выбор сеточного генератора
      // при большеразмерной модели обязательный переход на Coarse Mesh генератор.
      // Но только в случае гидродинамического решателя
      // s:=s + ' 2'; // Coarse Mesh.
      // MainMemo.Lines.Add('Model is very big. Mesh generator translated into Coarse Mesh.');
      // Пользователь сам решает какую сетку выбрать.
      s:=IntToStr(MeshForm.ComboBoxmeshgen.ItemIndex); // выбор сеточного генератора
   end
    else
   begin
      s:=IntToStr(MeshForm.ComboBoxmeshgen.ItemIndex); // выбор сеточного генератора
   end;
   s:='mesh_generator_algorithm='+s+'  # 0 - mesh generator 1; 1 - mesh generator 2; 2 - coarse mesh;';
   f.Add(s);

      bOk:=true;
      // Теперь конечное время можно параметризовывать через переменную.
      // 0 - стационарная теплопередача в твёрдом теле,
      // 1 - нестационарная теплопередача в твёрдом теле,
      // 2 - сеточный генератор только,
      // 3 - чистая гидродинамика,
      // 3 - гидродинамика совместно с теплопередачей.
      // 5 - Static Structural
      // 6 - Thermal Stress
      // 8 - подготовка данных к печати только. 5.01.2018
      // 9 - Нестационарная чистая гидродинамика.
      // 10 - NetWork_T solver
      // 11 - NetWork_T solver unsteady   04.07.2020
      // 12 - Нестационарная механика 14.08.2020
      // 13 - Нестационарная механика в сочетании с теплопередачей 14.08.2020.
      if (egddata.itemper=3) then
      begin
         if (bVisualization_Management_now) then
          begin
             //8 - подготовка данных к печати только. 5.01.2018
             s:='8';
          end
          else
          begin
             if (bonly_mesh_gen_call) then
             begin
               // Отдельный вызов сеточного генератора только.
               s:='2';
               //bonly_mesh_gen_call:=false;  сделано позже по коду.
             end
              else
             begin
                if (FormUnsteady.RadioGroup1.ItemIndex=1) then
                begin
                   // Нестационарный графовый температурный солвер
                   s:='11';
                end
                 else
                begin
                   // Стационарный графовый температурный солвер.
                   s:='10';
                end;
             end;
          end;
      end
       else
      begin

         if (bVisualization_Management_now) then
         begin
            //8 - подготовка данных к печати только. 5.01.2018
            s:='8';
         end
          else
         begin
            if (bonly_mesh_gen_call) then
            begin
               // Отдельный вызов сеточного генератора только.
               s:='2';
               //bonly_mesh_gen_call:=false;  сделано позже по коду.
            end
             else
            begin
               if (EGDForm.CBFlow.Checked = false) then
               begin
                  if (egddata.iStaticStructural=1) then
                  begin


                     if (egddata.itemper>0) then
                     begin
                        // Thermal Stress
                        if (FormUnsteady.RadioGroup1.ItemIndex=1) then
                        begin
                           if (egddata.itemper=1) then
                           begin
                              // На основе метода Контрольного объёма для теплопередачи.
                              s:='13'; // Нестационарная механика и теплопередача.
                           end;
                           if (egddata.itemper=2) then
                           begin
                              // На основе метода Конечных Элементов
                              // Нестационарный температурный солвер   #2 (10,11,2018)
                              // Только теплопередача без механики.
                              s:='7';
                           end;
                        end
                        else
                        begin
                           s:='6'; // Стационарная механика и теплопередача.
                        end;
                     end
                      else
                     begin
                        // Static Structural
                        if (FormUnsteady.RadioGroup1.ItemIndex=1) then
                        begin
                           s:='12'; // Нестационарная механика.
                        end
                         else
                        begin
                           // Стационарная Механика. (14,08,2020) (температурный солве №2 10,11,2018)
                           s:='5';
                        end;
                     end;
                  end
                  else
                  begin

                     if (egddata.imaxflD=1) then
                     begin
                        if ((egddata.itemper>0)and(egddata.myflmod[0].iflow=0)) then
                        begin
                            // Теплопередача в твёрдом теле.
                            s:=IntToStr(FormUnsteady.RadioGroup1.ItemIndex); // 1 - Нестационарность или 0 - стационарность.
                        end
                         else
                        begin
                           //  гидродинамика.
                           // Default Structural Mesh
                            if (FormUnsteady.RadioGroup1.ItemIndex=1) then
                            begin
                               // Нестационарная гидродинамика.
                               s:='9';
                            end
                              else
                            begin
                              // Стационарная гидродинамика.
                              s:='3';
                            end;
                        end;
                     end
                      else
                     begin
                        //  гидродинамика.
                        // Default Structural Mesh
                        if (FormUnsteady.RadioGroup1.ItemIndex=1) then
                        begin
                           // Нестационарная гидродинамика.
                           s:='9';
                        end
                        else
                        begin
                           // Стационарная гидродинамика.
                           s:='3';
                        end;
                     end;
                  end;
               end
                else
               begin
                  //  EGDForm.CBFlow.Checked = true
                  // Гидродинамика включена.
                  //  гидродинамика.
                  // Default Structural Mesh
                   if (FormUnsteady.RadioGroup1.ItemIndex=1) then
                   begin
                      // Нестационарная гидродинамика.
                      s:='9';
                   end
                    else
                   begin
                      // Стационарная гидродинамика.
                      s:='3';
                   end;
               end;
            end;
         end;
      end;
      s:='Schedule='+s+' ';
      f.Add(s);

      s:='TimeStep='+IntToStr(FormUnsteady.ComboBoxTimeStep.ItemIndex)+' '; // Закон изменения шага по времени.
      f.Add(s);
      s:='Factor_a_for_Linear='+FloatToStr(glSTL.Factor_a_for_Linear)+' '; // Factor (a) for Linear Law.
      f.Add(s);
      s:='tau='+FloatToStr(glSTL.tau)+' '; // длительность импульса.
      f.Add(s);
      s:='DutyCycle='+FloatToStr(glSTL.iQ)+' '; // Скважность.
      f.Add(s);
      // параметры импульсного режима работы для темы АППАРАТ.
      s:='m1='+FloatToStr(glSTL.m1)+' ';
      f.Add(s);
      s:='tau1='+FloatToStr(glSTL.tau1)+' ';
      f.Add(s);
      s:='tau2='+FloatToStr(glSTL.tau2)+' ';
      f.Add(s);
      s:='tau_pause='+FloatToStr(glSTL.tau_pause)+' ';
      f.Add(s);
      s:='off_multiplyer='+FloatToStr(glSTL.off_multiplyer)+' ';
      f.Add(s);
      s:='n='+IntToStr(glSTL.n)+' ';
      f.Add(s);
      s:='T='+FloatToStr(glSTL.T)+' ';
      f.Add(s);
      s:='on_time_double_linear='+FloatToStr(glSTL.on_time_double_linear)+' ';
      f.Add(s);
      // данные предполагаются корректными.
      s:='EndTime='+FloatToStr(FormVariables.my_real_convert(FormUnsteady.EditTime.Text,bOk))+' ';
      f.Add(s);
      fpiecewise:=TStringList.Create();
      // 0 - time (s); 1 - duration time (s); 21.12.2019
      fpiecewise.Add(IntToStr(Formpiecewiseconstant.ComboBoxpiecewiseconst.ItemIndex));

     i_piecewise:=0;
     for i := 0 to Formpiecewiseconstant.Memopiecewiseconst.Lines.Count do
     begin
        if (length(Formpiecewiseconstant.Memopiecewiseconst.Lines[i])>0) then
        begin
           inc(i_piecewise);
           spiecewise:=Formpiecewiseconstant.Memopiecewiseconst.Lines[i];
           if (FormatSettings.DecimalSeparator=',') then
           begin
              for i_1 := 1 to length(s) do
              begin
                 if (spiecewise[i_1]=',') then spiecewise[i_1]:='.';
              end;
           end;
           fpiecewise.Add(spiecewise);
        end;
     end;
     s:='n_string_PiecewiseConst='+IntToStr(i_piecewise)+' ';
     f.Add(s);
     fpiecewise.SaveToFile('premeshin_piecewise_const.txt');
     fpiecewise.Free;
     // Условие Ньютона-Рихмана.
     s:='adiabatic_vs_heat_transfer_coeff='+IntToStr(adiabatic_vs_heat_transfer_coeff)+' ';
     f.Add(s);
     s:='filmcoefficient='+FloatToStr(filmcoefficient)+' ';
     f.Add(s);

   if (EGDForm.CBFlow.Checked = false) then
   begin
      if (egddata.imaxflD=1) then
      begin
         if ((egddata.itemper>0)and(egddata.myflmod[0].iflow=0)) then
         begin
            // Теплопередача в твёрдом теле.
            if (MeshForm.CheckBoxALICE.Checked = false) then
            begin
               // Default Structural Mesh
               s:='0 ';
            end
             else
            begin
               // Adaptive Local Refinement Mesh
               s:='1 ';
               if (FormSetting.ComboBoxSolverSetting.ItemIndex=2) then
               begin
                  // bicgstab + ADI решатель.
                  // не может быть использован на ALICE сетке.
                  Laplas.MainMemo.Lines.Add('Do not supported ADI preconditioner in ALICE Mesh.');
                  ShowMessage('Do not supported ADI preconditioner in ALICE Mesh. ADI off.  BiCGStab+ILU2 solver on.');
                  // Солвер переводится на BiCGStab автоматическим образом.
                  FormSetting.ComboBoxSolverSetting.ItemIndex:=0;
               end;
            end;
         end
         else
         begin
            //  гидродинамика.
            // Default Structural Mesh
            if (egddata.myflmod[0].iflow=1) then
            begin
               // Гидродинамика.
                if (MeshForm.CheckBoxALICE.Checked = false) then
                begin
                   // Default Structural Mesh
                   s:='0 ';
                end
                else
                begin
                  // Adaptive Local Refinement Mesh
                  s:='1 ';
                end;
            end
            else
            begin
               if (egddata.iStaticStructural=1) then
               begin
                  // Решаем только Stress задачу и мы имеем право решать её на АЛИС сетке.
                  if (MeshForm.CheckBoxALICE.Checked = false) then
                  begin
                     // Default Structural Mesh
                     s:='0 ';
                  end
                   else
                  begin
                     // Stress in ALICE Mesh. 21.01.2018.
                     // Adaptive Local Refinement Mesh
                     s:='1 ';
                  end;
               end
                else
               begin
                  s:='0 ';
               end;
            end;
         end;
      end
      else
      begin
         // Теплопередача в твёрдом теле.
         if (MeshForm.CheckBoxALICE.Checked = false) then
         begin
            // Default Structural Mesh
            s:='0 ';
         end
          else
         begin
            // Adaptive Local Refinement Mesh
            s:='1 ';
            if (FormSetting.ComboBoxSolverSetting.ItemIndex=2) then
            begin
               // bicgstab + ADI решатель.
               // не может быть использован на ALICE сетке.
                Laplas.MainMemo.Lines.Add('Do not supported ADI preconditioner in ALICE Mesh.');
                ShowMessage('Do not supported ADI preconditioner in ALICE Mesh. ADI off.  BiCGStab+ILU2 solver on.');
               // Солвер переводится на BiCGStab автоматическим образом.
               FormSetting.ComboBoxSolverSetting.ItemIndex:=0;
            end;
         end;
      end;
   end
    else
   begin
      if (MeshForm.CheckBoxALICE.Checked = false) then
      begin
         // Default Structural Mesh
         s:='0 ';
      end
      else
      begin
         // Adaptive Local Refinement Mesh
         s:='1 ';
      end;
   end;
   s:='itypeMesh='+s+' # 0 - Structural Mesh; 1 - Adaptive Local Refinement Mesh';
   f.Add(s);
   // Версия АЛИС сетки. Быстрая -0, умеренно точная - 1.
   s:='version_ALICE_Mesh='+IntToStr(MeshForm.ComboBoxALICEType.ItemIndex)+' # 0 - Coarse; 1 - Medium.';
   f.Add(s);
   // Количество итераций алгориртма gmres до следующего рестарта (перезапуска).
   // В статьях рекомеддуется 20. При увеличении алгоритм стремиться к алгоритму gmres и
   // его скорость сходимости увеличивается.
   s:='m_restart_gmres='+FormSetting.ComboBox_m_restart_for_gmres.Items[FormSetting.ComboBox_m_restart_for_gmres.ItemIndex]+' # value 20 is recomended.';
   f.Add(s);
   // Настройки amg mager`a:
   s:='##########################################################';
   f.Add(s);
   s:='# Algebraic Multigrid RUMBA v0.14 configuration setting: #';
   f.Add(s);
   s:='##########################################################';
   f.Add(s);
   // Алгоритм сортировки в алгебраическом мноосеточном методе РУМБА.
   s:='# 0 - Counting Sort (recomended); 1 -  Quick Sort; 2 - Heap Sort; 3 - TIM Sort.';
   f.Add(s);
   s:='amg_manager_sorting_alg='+IntToStr(Form_amg_manager.ComboBoxSort.ItemIndex)+' ';
   f.Add(s);
   // level reduction
   s:='# number backward levels for ignoring in the V cycle.';
   f.Add(s);
   s:='inum_reduced_levels='+IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevels.ItemIndex)+' # 0 is recomended value.';
   f.Add(s);
   s:='inum_reduced_levels_Speed='+IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevelsSpeed.ItemIndex)+' # 0 is recomended value.';
   f.Add(s);
   s:='inum_reduced_levels_Pressure='+IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevelsPressure.ItemIndex)+' # 0 is recomended value.';
   f.Add(s);
   s:='inum_reduced_levels_Stress='+IntToStr(Form_amg_manager.ComboBoxmaximumreducedlevelsStress.ItemIndex)+' # 0 is recomended value.';
   f.Add(s);
   // interpolation
   s:='# interpolation: ';
   f.Add(s);
   s:='# 0 - Jacobi, 1 - AMG1R5, 2 - long range interpolation distanse=3;  ';
   f.Add(s);
   s:='# 3 - version 4; 4 - light version 4; 5 - second lite version 4;';
   f.Add(s);
   s:='# recomended 0 - Jacobi; default 3 - version 4.';
   f.Add(s);
   s:='interpolation='+IntToStr(Form_amg_manager.ComboBoxinterpolation.ItemIndex)+' ';
   f.Add(s);
   s:='interpolationSpeed='+IntToStr(Form_amg_manager.ComboBoxinterpolationSpeed.ItemIndex)+' ';
   f.Add(s);
   s:='interpolationPressure='+IntToStr(Form_amg_manager.ComboBoxinterpolationPressure.ItemIndex)+' ';
   f.Add(s);
   s:='interpollationStress='+IntToStr(Form_amg_manager.ComboBoxinterpollationStress.ItemIndex)+' ';
   f.Add(s);
   // Алгоритмы и структуры данных, лежащие в основе C-F разбиения.
   s:='# CF algorithm and Data Structure: 0 - AVL Tree; 1 - SPLAY Tree; ';
   f.Add(s);
   s:='# 2 - Binary Heap; 3 - Treap; 4 - Red Black Tree; 5 - Fibbonachi Heap;';
   f.Add(s);
   s:='# 6 - Van Emde Boas Tree.';
   f.Add(s);
   s:='CFalgorithmandDataStruct_Temperature='+IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Temperature.ItemIndex)+' ';
   f.Add(s);
   s:='CFalgorithmandDataStruct_Speed='+IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Speed.ItemIndex)+' ';
   f.Add(s);
   s:='CFalgorithmandDataStruct_Pressure='+IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Pressure.ItemIndex)+' ';
   f.Add(s);
   s:='CFalgorithmandDataStruct_Stress='+IntToStr(Form_amg_manager.ComboBoxCFalgorithmandDataStruct_Stress.ItemIndex)+' ';
   f.Add(s);
   // экспериментальные параметры модифицирующие четвёртую процедуру интерполляции.
   //s:='modinterpol='+IntToStr(Form_amg_manager.ComboBoxmodinterpol.ItemIndex);
   //s:='modinterpol=0';// 12,01,2018 заглушка, данные параметры более не используются в коде солвера.
   s:='# diagonal dominance: ON or OFF. ON is recomended.';
   f.Add(s);
   if (Form_amg_manager.CheckBoxDiagonalDominant.Checked=true) then
   begin
      // agglomeration with consistency scaling
      s:='modinterpol=1 '+' # 0 - OFF; 1 - ON;';
   end
   else
   begin
      s:='modinterpol=0 '+' # 0 - OFF; 1 - ON;';
   end;
   f.Add(s);
   //s:='numberadapt='+IntToStr(Form_amg_manager.ComboBoxnumberadapt.ItemIndex);
   s:='numberadapt=0 # not usage. Old parameter.'; // 12,01,2018 заглушка, данные параметры более не используются в коде солвера.
   f.Add(s);
    //Matrix Portrait
    // Temperature:
   if (Form_amg_manager.CheckBoxTemperatureMatrixPortrait.Checked)then
   begin
      s:='1 ';
   end
    else
   begin
      s:='0 ';
   end;
   s:='TemperatureMatrixPortrait='+s+' # 0 - OFF; 1 - ON;';
   f.Add(s);
   // Speed:
   if (Form_amg_manager.CheckBoxSpeedMatrixPortrait.Checked)then
   begin
      s:='1 ';
   end
    else
   begin
      s:='0 ';
   end;
   s:='SpeedMatrixPortrait='+s+' # 0 - OFF; 1 - ON;';
   f.Add(s);
   // Pressure:
   if (Form_amg_manager.CheckBoxPressureMatrixPortrait.Checked) then
   begin
      s:='1 ';
   end
    else
   begin
      s:='0 ';
   end;
   s:='PressureMatrixPortrait='+s+' # 0 - OFF; 1 - ON;';
   f.Add(s);
   // Stress
   if (Form_amg_manager.CheckBoxStressMatrixPortrait.Checked) then
   begin
      s:='1 ';
   end
    else
   begin
      s:='0 ';
   end;
   s:='StressMatrixPortrait='+s+' # 0 - OFF; 1 - ON;';
   f.Add(s);

   // 01.05.2017
   // truncation of interpolation:
   // Temperature:
   if (Form_amg_manager.CheckBoxtruncationT.Checked) then
   begin
      s:='0 ';
   end
    else
   begin
      s:='1 ';
   end;
   s:='truncationT='+s+' # 0 - OFF; 1 - ON;';
   f.Add(s);
   // Speed:
   if (Form_amg_manager.CheckBoxtruncationSpeed.Checked) then
   begin
      s:='0 ';
   end
    else
   begin
      s:='1 ';
   end;
   s:='truncationSpeed='+s+' # 0 - OFF; 1 - ON;';
   f.Add(s);
   // Pressure:
   if (Form_amg_manager.CheckBoxtruncationPressure.Checked) then
   begin
      s:='0 ';
   end
    else
   begin
      s:='1 ';
   end;
   s:='truncationPressure='+s+' # 0 - OFF; 1 - ON;';
   f.Add(s);
   // Stress:
   if (Form_amg_manager.CheckBoxtruncationStress.Checked) then
   begin
      s:='0 ';
   end
    else
   begin
      s:='1 ';
   end;
   s:='truncationStress='+s+' # 0 - OFF; 1 - ON;';
   f.Add(s);
   // Temperature:
   s1:=Form_amg_manager.Edit_truncation_T.Text;
   for i := 1 to length(s1) do
   begin
      if (s1[i]=',') then s1[i]:='.';
   end;
   Form_amg_manager.Edit_truncation_T.Text:=s1;

   //s:=s+' '+Trim(Form_amg_manager.Edit_truncation_T.Text);
   s:='truncation_Temperature_drop_tolerance='+Trim(Form_amg_manager.Edit_truncation_T.Text)+' # value 0.2 is recomended.';
   f.Add(s);
   // Speed:
   s1:=Form_amg_manager.Edit_truncation_Speed.Text;
   for i := 1 to length(s1) do
   begin
      if (s1[i]=',') then s1[i]:='.';
   end;
   Form_amg_manager.Edit_truncation_Speed.Text:=s1;

   // s:=s+' '+Trim(Form_amg_manager.Edit_truncation_Speed.Text);
   s:='truncation_Speed_drop_tolerance='+Trim(Form_amg_manager.Edit_truncation_Speed.Text)+' # value 0.2 is recomended.';
   f.Add(s);
   // Pressure:
   s1:=Form_amg_manager.Edit_truncation_Pressure.Text;
   for i := 1 to length(s1) do
   begin
      if (s1[i]=',') then s1[i]:='.';
   end;
   Form_amg_manager.Edit_truncation_Pressure.Text:=s1;

   //s:=s+' '+Trim(Form_amg_manager.Edit_truncation_Pressure.Text);
   s:='truncation_Pressure_drop_tolerance='+ Trim(Form_amg_manager.Edit_truncation_Pressure.Text)+' # value 0.2 is recomended.';
   f.Add(s);

   // Stress:
   s1:=Form_amg_manager.Edittruncation_Stress.Text;
   for i := 1 to length(s1) do
   begin
      if (s1[i]=',') then s1[i]:='.';
   end;
   Form_amg_manager.Edittruncation_Stress.Text:=s1;

   //s:=s+' '+Trim(Form_amg_manager.Edittruncation_Stress.Text);
   s:='truncation_Stress_drop_tolerance='+ Trim(Form_amg_manager.Edittruncation_Stress.Text)+' # value 0.2 is recomended.';
   f.Add(s);

   //  this is the end truncation of interpolation:

   // nFinnest
   s:='# number of iteration on the Finnest grid. 2 is recomended.';
   f.Add(s);
   s:='nFinnest='+IntToStr(Form_amg_manager.ComboBoxnFinnest.ItemIndex+1)+' ';
   f.Add(s);
   s:='nFinnestSpeed='+IntToStr(Form_amg_manager.ComboBoxnFinnestSpeed.ItemIndex+1)+' ';
   f.Add(s);
   s:='nFinnestPressure='+IntToStr(Form_amg_manager.ComboBoxnFinnestPressure.ItemIndex+1)+' ';
   f.Add(s);
   s:='nFinnestStress='+IntToStr(Form_amg_manager.ComboBoxnFinnestStress.ItemIndex+1)+' ';
   f.Add(s);
   // nu1
   s:='# number of iteration on the pre smoothers. 1 is recomended.';
   f.Add(s);
   s:='numberpresmothers='+IntToStr(Form_amg_manager.ComboBoxnumberpresmothers.ItemIndex)+' ';
   f.Add(s);
   s:='numberpresmothersSpeed='+IntToStr(Form_amg_manager.ComboBoxnumberpresmothersSpeed.ItemIndex)+' ';
   f.Add(s);
   s:='numberpresmothersPressure='+IntToStr(Form_amg_manager.ComboBoxnumberpresmothersPressure.ItemIndex)+' ';
   f.Add(s);
   s:='numberpresmoothersStress='+IntToStr(Form_amg_manager.ComboBoxnumberpresmoothersStress.ItemIndex)+' ';
   f.Add(s);
   // nu2
   s:='# number of iterations on the post smoothers. 2 is recomended.';
   f.Add(s);
   s:='numberpostsweeps='+IntToStr(Form_amg_manager.ComboBoxnumberpostsweeps.ItemIndex)+' ';
   f.Add(s);
   s:='numberpostsweepsSpeed='+IntToStr(Form_amg_manager.ComboBoxnumberpostsweepsSpeed.ItemIndex)+' ';
   f.Add(s);
   s:='numberpostsweepsPressure='+IntToStr(Form_amg_manager.ComboBoxnumberpostsweepsPressure.ItemIndex)+' ';
   f.Add(s);
   s:='numberpostsweepsStress='+IntToStr(Form_amg_manager.ComboBoxnumberpostsweepsStress.ItemIndex)+' ';
   f.Add(s);
   // memory
   s:='# memory size for AMG in the size A matrix. value 9- 14 is usually recomended. ';
   f.Add(s);
   s:='# WARNING! Ionov radiator and sample others is neded value 53 or biggest.';
   f.Add(s);
   s:='memorysize='+IntToStr(Form_amg_manager.ComboBoxmemorysize.ItemIndex+4)+' ';
   f.Add(s);
   s:='memorysizeSpeed='+IntToStr(Form_amg_manager.ComboBoxmemorysizeSpeed.ItemIndex+4)+' ';
   f.Add(s);
   s:='memorysizePressure='+IntToStr(Form_amg_manager.ComboBoxmemorysizePressure.ItemIndex+4)+' ';
   f.Add(s);
   s:='memorysizeStress='+IntToStr(Form_amg_manager.ComboBoxmemorysizeStress.ItemIndex+4)+' ';
   f.Add(s);

   // 0 - Gauss-Seidel; 1 - iluk(k=lfil); 2 - Рунге-Кутта 3 порядка;
   // 3 - Рунге -Кутта 5 порядка; 4 - damped Jacoby; 5 - Rouch sor;
   // Температура :
   s:='smoothertypeTemperature='+IntToStr(Form_amg_manager.ComboBoxsmoothertypeTemperature.ItemIndex)+' # 0 - Gauss-Seidel; 1 - iluk (k=lfil); 2 - Runge-Kutta 3 order; 3 - Runge-Kutta 5 order; 4 - damped Jacoby; 5 - Rouch sor.';
   f.Add(s);
   // Скорость :
   s:='smoothertypeSpeed='+IntToStr(Form_amg_manager.ComboBoxsmoothertypeSpeed.ItemIndex)+' # 0 - Gauss-Seidel; 1 - iluk (k=lfil); 2 - Runge-Kutta 3 order; 3 - Runge-Kutta 5 order; 4 - damped Jacoby; 5 - Rouch sor.';
   f.Add(s);
   // Давление :
   s:='smoothertypePressure='+IntToStr(Form_amg_manager.ComboBoxsmoothertypePressure.ItemIndex)+' # 0 - Gauss-Seidel; 1 - iluk (k=lfil); 2 - Runge-Kutta 3 order; 3 - Runge-Kutta 5 order; 4 - damped Jacoby; 5 - Rouch sor.';
   f.Add(s);
   // Stress :
   s:='smoothertypeStress='+IntToStr(Form_amg_manager.ComboBoxsmoothertypeStress.ItemIndex)+' # 0 - Gauss-Seidel; 1 - iluk (k=lfil); 2 - Runge-Kutta 3 order; 3 - Runge-Kutta 5 order; 4 - damped Jacoby; 5 - Rouch sor.';
   f.Add(s);

   // threshold
   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.Editthreshold.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.Editthreshold.Text:=s1;
   end;
   s:='threshold='+Trim(Form_amg_manager.Editthreshold.Text)+' # value 0.24 is recomended.';
   f.Add(s);
   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditthresholdSpeed.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditthresholdSpeed.Text:=s1;
   end;
   s:='thresholdSpeed='+Trim(Form_amg_manager.EditthresholdSpeed.Text)+' # value 0.24 is recomended.';
   f.Add(s);
   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditthresholdPressure.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditthresholdPressure.Text:=s1;
   end;
   s:='thresholdPressure='+Trim(Form_amg_manager.EditthresholdPressure.Text)+' # value 0.24 is recomended.';
   f.Add(s);
   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditthresholdStress.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditthresholdStress.Text:=s1;
   end;
   s:='thresholdStress='+Trim(Form_amg_manager.EditthresholdStress.Text)+' # value 0.24 is recomended.';
   f.Add(s);

   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditmagicT.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditmagicT.Text:=s1;
   end;
   s:='magicT='+Trim(Form_amg_manager.EditmagicT.Text)+' # value 0.4 is recomended.';
   f.Add(s);

   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditmagicSpeed.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditmagicSpeed.Text:=s1;
   end;
   s:='magicSpeed='+Trim(Form_amg_manager.EditmagicSpeed.Text)+' # value 0.4 is recomended.';
   f.Add(s);

   if (FormatSettings.DecimalSeparator=',') then
   begin
      s1:=Form_amg_manager.EditmagicPressure.Text;
      for i := 1 to length(s) do
      begin
         if (s1[i]=',') then s1[i]:='.';
      end;
       Form_amg_manager.EditmagicPressure.Text:=s1;
   end;
   s:='magicPressure='+Trim(Form_amg_manager.EditmagicPressure.Text)+' # value 0.4 is recomended.';
   f.Add(s);

     if (FormatSettings.DecimalSeparator=',') then
     begin
        s1:=Form_amg_manager.EditmagicStress.Text;
        for i := 1 to length(s) do
         begin
            if (s1[i]=',') then s1[i]:='.';
         end;
         Form_amg_manager.EditmagicStress.Text:=s1;
     end;
     s:='magicStress='+Trim(Form_amg_manager.EditmagicStress.Text)+' # value 0.4 is recomended.';
     f.Add(s);

     // Temperature standart coarsening vs RS 2.
     s:='coarseningTemp='+IntToStr(Form_amg_manager.ComboBoxcoarseningTemp.ItemIndex)+' ';
     f.Add(s);
     // Speed standart coarsening vs RS 2.
     s:='coarseningSpeed='+IntToStr(Form_amg_manager.ComboBoxcoarseningSpeed.ItemIndex)+' ';
     f.Add(s);
     // Pressure standart coarsening vs RS 2.
     s:='coarseningPressure='+IntToStr(Form_amg_manager.ComboBoxcoarseningPressure.ItemIndex)+' ';
     f.Add(s);
     // Stress standart coarsening vs RS 2.
     s:='coarseningStress='+IntToStr(Form_amg_manager.ComboBoxcoarseningStress.ItemIndex)+' ';
     f.Add(s);
     // Stabilization BiCGStab + amg (РУМБА).
     // 8.01.2017
     // Temperature
     s:='StabilizationTemp='+IntToStr(Form_amg_manager.ComboBoxStabilizationTemp.ItemIndex)+' # 0 - none; 1 - BiCGStab; 2 - FGMRes; 3 - nonlinear problem.'; // none
     f.Add(s);
     // Speed
     s:='StabilizationSpeed='+IntToStr(Form_amg_manager.ComboBoxStabilizationSpeed.ItemIndex)+' # 0 - none; 1 - BiCGStab; 2 - FGMRes;'; // none
     f.Add(s);
     // Pressure
     s:='StabilizationPressure='+IntToStr(Form_amg_manager.ComboBoxStabilizationPressure.ItemIndex)+' # 0 - none; 1 - BiCGStab; 2 - FGMRes;'; // none
     f.Add(s);
     // Stress
     s:='StabilizationStress='+IntToStr(Form_amg_manager.ComboBoxStabilizationStress.ItemIndex)+' # 0 - none; 1 - BiCGStab; 2 - FGMRes;'; // none
     f.Add(s);

     // Strong Transpose select
     if (Form_amg_manager.CheckBoxStrongTranspose.Checked) then
     begin
        s:='Patch_number='+'7'+' '; // Strong Transpose
     end
      else
     begin
        s:='Patch_number='+'0'+' ';  // Просто strong
     end;
     s:=s+' # 0 or 7. 0 - none; 7 - Strong Transpose, value 7 is recomended.';
     f.Add(s);
     // 01.05.2017
     // print log:
     // Temperature:
     if (Form_amg_manager.CheckBoxprintlogTemperature.Checked) then
     begin
        s:='1 ';
     end
      else
     begin
        s:='0 ';
     end;
     s:='printlogTemperature='+s+' # 0 - OFF; 1 - ON;';
     f.Add(s);
     // Speed:
     if (Form_amg_manager.CheckBoxprintlogSpeed.Checked) then
     begin
        s:='1 ';
     end
      else
     begin
        s:='0 ';
     end;
     s:='printlogSpeed='+s+' # 0 - OFF; 1 - ON;';
     f.Add(s);
     // Pressure:
     if (Form_amg_manager.CheckBoxprintlogPressure.Checked) then
     begin
        s:='1 ';
     end
      else
     begin
        s:='0 ';
     end;
     s:='printlogPressure='+s+' # 0 - OFF; 1 - ON;';
     f.Add(s);
     // Stress:
     if (Form_amg_manager.CheckBoxprintlogStress.Checked) then
     begin
        s:='1 ';
     end
      else
     begin
        s:='0 ';
     end;
     s:='printlogStress='+s+' # 0 - OFF; 1 - ON;';
     f.Add(s);
     // 08.09.2019 amgcl parameters
     s:='amgcl_smoother='+IntToStr(FormAMGCLParameters.RadioGroupAMGCLsmoother1.ItemIndex)+' # 0 - spai0; 1 - ilu0; 2- gauss-seidel; 3 - damped-jacobi; 4 - spai1; 5 - chebyshev; 6 - ilu1; 7 - ilu2.';
     f.Add(s);
     s:='amgcl_selector='+IntToStr(FormAMGCLParameters.RadioGroupAMGCLCoarseningType.ItemIndex)+' # 0 - Ruge-Stueben; 1 - smoother aggregation.';
     f.Add(s);
     s:='amgcl_iterator='+IntToStr(FormAMGCLParameters.ComboBoxIterator.ItemIndex)+' # 0 - BiCGStab; 1 - FGMRES.';
     f.Add(s);
     s:='lfil='+IntToStr(FormSetting.ComboBox_lfil.ItemIndex)+' ';
     f.Add(s);

     // Делать ли уничтожения памяти и новые построения.
     // 9 september 2017.
     if (FormUnsteady.CheckBoxreconstruct.Checked) then
     begin
        s:='1 ';
     end
      else
     begin
        s:='0 ';
     end;
     s:='reconstruct='+s+' # 0 - OFF; 1 - ON; 1 is recomended.';
     f.Add(s);

     // 17 november 2017.
     // Сохранять ли анимацию в текстовый файл.
     if (FormUnsteady.CheckBoxAnimationFields.Checked) then
     begin
        s:='1 ';
     end
      else
     begin
        s:='0 ';
     end;
     s:='AnimationFields='+s+' # 0 - OFF; 1 - ON;';
     f.Add(s);

     // имена файлов в которых хранятся таблицы мощностей
     // зависящие от температуры и смещения стока.
     for i:=0 to (iltdp-1) do
     begin
        s:='tablename'+IntToStr(i)+'='+listtablename[i]+' ';
        f.Add(s);
     end;

     s:='################################################################';
     f.Add(s);
     s:='# Matherial properties for this project configuration setting: #';
     f.Add(s);
     s:='################################################################';
     f.Add(s);

   for i:=0 to (lmatmax-1) do
   begin
      s:='matherial'+IntToStr(i)+'_name='+workmat[i].namemat+' '; // имя материала не требуется
      f.Add(s);
      // плотность, теплоёмкость и теплопроводность.
      s:='matherial'+IntToStr(i)+'_rho='+FloatToStr(workmat[i].rho)+ ' # density kg/m!3';// плотность
      f.Add(s);
      //s:=s+FloatToStr(workmat[i].cp)+ ' '; // теплоёмкость
      //s:=s+FloatToStr(workmat[i].lambda)+ ' '; // теплопроводность
      // 17.11.2016
      s:='matherial'+IntToStr(i)+'n_cp='+IntToStr(workmat[i].n_cp)+' # number points for define temperature depend heat capacity.';
      f.Add(s);
      for i3 := 0 to workmat[i].n_cp-1 do
      begin
          s:='matherial'+IntToStr(i)+'temp_cp'+IntToStr(i3)+'=' +FloatToStr(workmat[i].temp_cp[i3])+' # temperature';
          f.Add(s);
          s:='matherial'+IntToStr(i)+'arr_cp'+IntToStr(i3)+'='+FloatToStr(workmat[i].arr_cp[i3])+' # heat capacity, J/(kg*K).';
          f.Add(s);
      end;
      //s:=s+'1 20.0 '+FloatToStr(workmat[i].arr_cp[0])+ ' '; // теплоёмкость
      s:='matherial'+IntToStr(i)+'n_lam='+IntToStr(workmat[i].n_lam)+' # number points for define temperature depend thermal conductivity.';
      f.Add(s);
      for i3 := 0 to workmat[i].n_lam-1 do
      begin
          s:='matherial'+IntToStr(i)+'temp_lam'+IntToStr(i3)+'='+FloatToStr(workmat[i].temp_lam[i3])+' # temperature';
          f.Add(s);
          s:='matherial'+IntToStr(i)+'arr_lam'+IntToStr(i3)+'='+FloatToStr(workmat[i].arr_lam[i3])+' # thermal conductivity, W/(m*K).';
          f.Add(s);
      end;
      //s:=s+'1 20.0 '+FloatToStr(workmat[i].arr_lam[0])+ ' '; // теплопроводность
      // Ортотропность теплопроводности.
      s:='matherial'+IntToStr(i)+'mult_lam_x='+FloatToStr(workmat[i].mult_lam_x)+ ' # x -axis thermal conductivity orthotropal multiplyer.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mult_lam_y='+FloatToStr(workmat[i].mult_lam_y)+ ' # y -axis thermal conductivity orthotropal multiplyer.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mult_lam_z='+FloatToStr(workmat[i].mult_lam_z)+ ' # z -axis thermal conductivity orthotropal multiplyer.';
      f.Add(s);
      // Thermal Stress
       // Ортотропность коэффициента линейного теплового расширения.
      s:='matherial'+IntToStr(i)+'mult_Linear_expansion_coefficient_x='+FloatToStr(workmat[i].mult_Linear_expansion_coefficient_x)+ ' # x -axis Linear_expansion_coefficient orthotropal multiplyer.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mult_Linear_expansion_coefficient_y='+FloatToStr(workmat[i].mult_Linear_expansion_coefficient_y)+ ' # y -axis Linear_expansion_coefficient orthotropal multiplyer.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mult_Linear_expansion_coefficient_z='+FloatToStr(workmat[i].mult_Linear_expansion_coefficient_z)+ ' # z -axis Linear_expansion_coefficient orthotropal multiplyer.';
      f.Add(s);
      // Ортотропность модуля Юнга.
      s:='matherial'+IntToStr(i)+'mult_Young_Module_x='+FloatToStr(workmat[i].mult_Young_Module_x)+ ' # x - axis Young_Module orthotropal multiplyer.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mult_Young_Module_y='+FloatToStr(workmat[i].mult_Young_Module_y)+ ' # y - axis Young_Module orthotropal multiplyer.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mult_Young_Module_z='+FloatToStr(workmat[i].mult_Young_Module_z)+ ' # z - axis Young_Module orthotropal multiplyer.';
      f.Add(s);
      // Ортотропность коэффициента Пуассона.
      s:='matherial'+IntToStr(i)+'mult_Poisson_ratio_xy='+FloatToStr(workmat[i].mult_Poisson_ratio_xy)+ ' # z -axis thermal conductivity orthotropal multiplyer.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mult_Poisson_ratio_xz='+FloatToStr(workmat[i].mult_Poisson_ratio_xz)+ ' # y -axis thermal conductivity orthotropal multiplyer.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mult_Poisson_ratio_yz='+FloatToStr(workmat[i].mult_Poisson_ratio_yz)+ ' # x -axis thermal conductivity orthotropal multiplyer.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mult_Poisson_ratio_yx='+FloatToStr(workmat[i].mult_Poisson_ratio_yx)+ ' # z -axis thermal conductivity orthotropal multiplyer.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mult_Poisson_ratio_zx='+FloatToStr(workmat[i].mult_Poisson_ratio_zx)+ ' # y -axis thermal conductivity orthotropal multiplyer.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mult_Poisson_ratio_zy='+FloatToStr(workmat[i].mult_Poisson_ratio_zy)+ ' # x -axis thermal conductivity orthotropal multiplyer.';
      f.Add(s);
      // Модуль сдвига
      if (workmat[i].bShearModuleActive) then
      begin
         s:='matherial'+IntToStr(i)+'bShearModuleActive='+'1 # z -axis Shear Module.';
      end
      else
      begin
         s:='matherial'+IntToStr(i)+'bShearModuleActive='+'0 # z -axis Shear Module.';
      end;
      f.Add(s);
      s:='matherial'+IntToStr(i)+'ShearModuleGxy='+FloatToStr(workmat[i].ShearModuleGxy)+ ' # z -axis Shear Module.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'ShearModuleGyz='+FloatToStr(workmat[i].ShearModuleGyz)+ ' # x -axis Shear Module.';
      f.Add(s);
      s:='matherial'+IntToStr(i)+'ShearModuleGxz='+FloatToStr(workmat[i].ShearModuleGxz)+ ' # y -axis Shear Module.';
      f.Add(s);

      //s:='matherial'+IntToStr(i)+'Poisson_ratio='+FloatToStr(workmat[i].Poisson_ratio)+ ' ';
      //f.Add(s);
      // 24.08.2020
      s:='matherial'+IntToStr(i)+'n_Poisson_ratio='+IntToStr(workmat[i].n_Poisson_ratio)+' # number points for define temperature depend Poisson_ratio.';
      f.Add(s);
      for i3 := 0 to workmat[i].n_Poisson_ratio-1 do
      begin
          s:='matherial'+IntToStr(i)+'temp_Poisson_ratio'+IntToStr(i3)+'=' +FloatToStr(workmat[i].temp_Poisson_ratio[i3])+' # temperature';
          f.Add(s);
          s:='matherial'+IntToStr(i)+'arr_Poisson_ratio'+IntToStr(i3)+'='+FloatToStr(workmat[i].arr_Poisson_ratio[i3])+' # Poisson_ratio.';
          f.Add(s);
      end;
      //s:='matherial'+IntToStr(i)+'Young_Module='+FloatToStr(workmat[i].Young_Module)+ ' # GPa';  // GPa
      //f.Add(s);
      s:='matherial'+IntToStr(i)+'n_Young_Module='+IntToStr(workmat[i].n_Young_Module)+' # number points for define temperature depend Young_Module GPa.';
      f.Add(s);
      for i3 := 0 to workmat[i].n_Young_Module-1 do
      begin
          s:='matherial'+IntToStr(i)+'temp_Young_Module'+IntToStr(i3)+'=' +FloatToStr(workmat[i].temp_Young_Module[i3])+' # temperature';
          f.Add(s);
          s:='matherial'+IntToStr(i)+'arr_Young_Module'+IntToStr(i3)+'='+FloatToStr(workmat[i].arr_Young_Module[i3])+' # Young_Module GPa.';
          f.Add(s);
      end;
      //s:='matherial'+IntToStr(i)+'Linear_expansion_coefficient='+FloatToStr(workmat[i].Linear_expansion_coefficient)+ ' # *1e-6 1/K'; // *1E-6
      //f.Add(s);
      // 17.08.2020
      s:='matherial'+IntToStr(i)+'n_Linear_expansion_coefficient='+IntToStr(workmat[i].n_Linear_expansion_coefficient)+' # number points for define temperature depend linear expansion coefficient.';
      f.Add(s);
      for i3 := 0 to workmat[i].n_Linear_expansion_coefficient-1 do
      begin
          s:='matherial'+IntToStr(i)+'temp_Linear_expansion_coefficient'+IntToStr(i3)+'=' +FloatToStr(workmat[i].temp_Linear_expansion_coefficient[i3])+' # temperature';
          f.Add(s);
          s:='matherial'+IntToStr(i)+'arr_Linear_expansion_coefficient'+IntToStr(i3)+'='+FloatToStr(workmat[i].arr_Linear_expansion_coefficient[i3])+' # linear expansion coefficient, 1E-6/(K).';
          f.Add(s);
      end;
      s:='matherial'+IntToStr(i)+'mu='+FloatToStr(workmat[i].mu)+ ' '; // динамическая вязкость
      f.Add(s);
      s:='matherial'+IntToStr(i)+'beta_t='+FloatToStr(workmat[i].beta_t)+ ' '; // коэффициент линейного температурного расширения
      f.Add(s);
      s:='matherial'+IntToStr(i)+'blibmat='+IntToStr(workmat[i].blibmat)+' '; // является ли материал библиотечным ?
      f.Add(s);
      s:='matherial'+IntToStr(i)+'ilibident='+IntToStr(workmat[i].ilibident)+' '; // идентификатор библиотечного материаала
      f.Add(s);
      s:='matherial'+IntToStr(i)+'bBoussinesq='+IntToStr(workmat[i].bBoussinesq)+' '; // использовать приближение Обербека-Буссинеска или нет.
      f.Add(s);
      s:='matherial'+IntToStr(i)+'ilawmu='+IntToStr(workmat[i].ilawmu)+' ';  // номер закона для динамической вязкости
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mumin='+FloatToStr(workmat[i].mumin)+' '; // ограничители
      f.Add(s);
      s:='matherial'+IntToStr(i)+'mumax='+FloatToStr(workmat[i].mumax)+' '; // динамической вязкости.
      f.Add(s);
      s:='matherial'+IntToStr(i)+'Amu='+FloatToStr(workmat[i].Amu)+' ';   // параметры
      f.Add(s);
      s:='matherial'+IntToStr(i)+'Bmu='+FloatToStr(workmat[i].Bmu)+' ';   // модельных
      f.Add(s);
      s:='matherial'+IntToStr(i)+'Cmu='+FloatToStr(workmat[i].Cmu)+' ';   // зависимостей
      f.Add(s);
      s:='matherial'+IntToStr(i)+'degreennmu='+FloatToStr(workmat[i].degreennmu)+' '; // показатель степени
      f.Add(s);
   end;


   // Сортировка блоков по возрастанию значения их priority.
   // 2 мая 2016.
   (*
    for isort:=2 to lb-1 do
   begin
	   for jsort:=lb-1 downto isort do
     begin
     		if (body[jsort-1].priority > body[jsort].priority) then
        begin
			     // swap
			     body_change:=body[jsort-1];
			     body[jsort-1]:=body[jsort];
			     body[jsort]:= body_change;
		    end;
	   end;
   end;
   *)


   s:='################################################################';
   f.Add(s);
   s:='# Block`s properties for this project configuration setting: #';
   f.Add(s);
   s:='################################################################';
   f.Add(s);

   // Теперь блоки отсортированы по возратанию их приоритетов.
   HeapSort(1,lb-1); // Пирамидальная сортировка.

   // 1 - SOLID; 2 - HOLLOW; 3 - FLUID
   if (body[0].itype=3) then
   begin
      // Cabinet типа Fluid.
      for i:=0 to (lb-1) do
      begin
         with (body[i]) do
         begin
            bf7:=false;
            // Принадлежность union (Асемблесу).
            for i3 := 0 to (lu-1) do
            begin
               if (myassembles[i3].identifire=iunion)then
               begin
                  if (myassembles[i3].bmesh_assembles_separately) then
                  begin
                     bf7:=true;
                  end;
               end;
            end;

            s:='body'+IntToStr(i)+'name='+name+' ';
            f.Add(s);

            if (bf7) then
            begin
               s:=IntToStr(iunion)+' ';
            end
             else
            begin
               s:='0 ';
            end;

            s:='body'+IntToStr(i)+'iunion='+s+' # 0 - cabinet. default 0.';
            f.Add(s);
            // 0 - Prism, 1 - Cylinder, 2 - Polygon.
            if (FormUnsteady.CheckBoxCylinderToPrism.Checked and (igeometry_type=1) and (bCylinder2Prism))  then
            begin
               // to Prism
               s:=IntToStr(0)+' ';
               case iPlane of
               1 : begin
                      // XY
                      zS1:=zC;
                      zE1:=zC+Hcyl;
                      xS1:=xC-0.8861433*R_out_cyl;
                      xE1:=xC+0.8861433*R_out_cyl;
                      yS1:=yC-0.8861433*R_out_cyl;
                      yE1:=yC+0.8861433*R_out_cyl;
                   end;
               2 : begin
                      //XZ
                      yS1:=yC;
                      yE1:=yC+Hcyl;
                      xS1:=xC-0.8861433*R_out_cyl;
                      xE1:=xC+0.8861433*R_out_cyl;
                      zS1:=zC-0.8861433*R_out_cyl;
                      zE1:=zC+0.8861433*R_out_cyl;
                   end;
               3 : begin
                      // YZ
                      xS1:=xC;
                      xE1:=xC+Hcyl;
                      yS1:=yC-0.8861433*R_out_cyl;
                      yE1:=yC+0.8861433*R_out_cyl;
                      zS1:=zC-0.8861433*R_out_cyl;
                      zE1:=zC+0.8861433*R_out_cyl;
                   end;
               end;
            end
            else
            begin
               s:=IntToStr(igeometry_type)+' ';
            end;
            s:='body'+IntToStr(i)+'igeometry_type='+s+' # 0 - Prism, 1 - Cylinder, 2 - Polygon';
            f.Add(s);
            // visible or not visible
            if (bvisible) then
            begin
               // Участвует в расчёте и прорисовывается в tecplot 360.
               s:='1 '; // Visible
            end
            else
            begin
               // Участвует в расчёте но не прорисовывается в Tecplot 360.
               s:='0 '; // not Visible
               MainMemo.Lines.Add('body['+IntToStr(i)+'] not vible');
            end;
            s:='body'+IntToStr(i)+'bvisible='+s+' # 1 - VISIBLE, 0 - NOT VISIBLE';
            f.Add(s);
            // Prism
            if (FormUnsteady.CheckBoxCylinderToPrism.Checked and (igeometry_type=1) and (bCylinder2Prism))  then
            begin
               s:=FloatToStr(xS1)+' ';
               s:='body'+IntToStr(i)+'xS='+s;
               f.Add(s);
               s:=FloatToStr(yS1)+' ';
               s:='body'+IntToStr(i)+'yS='+s;
               f.Add(s);
               s:=FloatToStr(zS1)+' ';
               s:='body'+IntToStr(i)+'zS='+s;
               f.Add(s);
               s:=FloatToStr(xE1)+' ';
               s:='body'+IntToStr(i)+'xE='+s;
               f.Add(s);
               s:=FloatToStr(yE1)+' ';
               s:='body'+IntToStr(i)+'yE='+s;
               f.Add(s);
               s:=FloatToStr(zE1)+' ';
               s:='body'+IntToStr(i)+'zE='+s;
               f.Add(s);
            end
             else
            begin
               s:=FloatToStr(xS)+' ';
               s:='body'+IntToStr(i)+'xS='+s;
               f.Add(s);
               s:=FloatToStr(yS)+' ';
               s:='body'+IntToStr(i)+'yS='+s;
               f.Add(s);
               s:=FloatToStr(zS)+' ';
               s:='body'+IntToStr(i)+'zS='+s;
               f.Add(s);
               s:=FloatToStr(xE)+' ';
               s:='body'+IntToStr(i)+'xE='+s;
               f.Add(s);
               s:=FloatToStr(yE)+' ';
               s:='body'+IntToStr(i)+'yE='+s;
               f.Add(s);
               s:=FloatToStr(zE)+' ';
               s:='body'+IntToStr(i)+'zE='+s;
               f.Add(s);
            end;
            // Cylinder
            s:=IntToStr(iPlane)+' ';  // 1 - XY, 2 - XZ, 3 - YZ.
            s:='body'+IntToStr(i)+'iPlane='+s+' # 1 - XY, 2 - XZ, 3 - YZ';
            f.Add(s);
            s:=FloatToStr(xC)+' ';
            s:='body'+IntToStr(i)+'xC='+s;
            f.Add(s);
            s:=FloatToStr(yC)+' ';
            s:='body'+IntToStr(i)+'yC='+s;
            f.Add(s);
            s:=FloatToStr(zC)+' ';
            s:='body'+IntToStr(i)+'zC='+s;
            f.Add(s);
            s:=FloatToStr(Hcyl)+' ';
            s:='body'+IntToStr(i)+'Hcyl='+s+' # Height on cylinder';
            f.Add(s);
            s:=FloatToStr(R_out_cyl)+' ';
            s:='body'+IntToStr(i)+'R_out_cyl='+s+' # radius on cylinder';
            f.Add(s);
            s:=FloatToStr(R_in_cyl)+' ';
            s:='body'+IntToStr(i)+'R_in_cyl='+s+' # internal radius on cylinder';
            f.Add(s);
            // sector, conoid
            (*
            s:=s+FloatToStr(R_out_cyl2)+ ' ';
            s:=s+FloatToStr(R_in_cyl2)+' ';
            s:=s+FloatToStr(angle_start)+ ' ';
            s:=s+FloatToStr(angle_end)+' ';
            *)

             // Polygon
             s:=IntToStr(iPlane_obj2)+' '; // 1 - XY, 2 - XZ, 3 - YZ.
             s:='body'+IntToStr(i)+'iPlane_obj2=' + s;
             f.Add(s);
             s:=IntToStr(nsizei)+' ';
             s:='body'+IntToStr(i)+'nsizei=' + s+' # number of points for polygon';
             f.Add(s);
             for j := 0 to nsizei-1 do
             begin
                s:=FloatToStr(hi[j])+' ';
                s:='body'+IntToStr(i)+'hi'+IntToStr(j)+'='+ s;
                f.Add(s);
                s:=FloatToStr(xi[j])+' ';
                s:='body'+IntToStr(i)+'xi'+IntToStr(j)+'='+ s;
                f.Add(s);
                s:=FloatToStr(yi[j])+' ';
                s:='body'+IntToStr(i)+'yi'+IntToStr(j)+'='+ s;
                f.Add(s);
                s:=FloatToStr(zi[j])+' ';
                s:='body'+IntToStr(i)+'zi'+IntToStr(j)+'='+ s;
                f.Add(s);
             end;


            // emissivity :
            bOk:=true;
            if (abs(FormVariables.my_real_convert(body[i].semissW,bOk))<1.0e-12) then
            begin
               body[i].emissW:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissW:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissW:='0.001';
             end;
            end;
            s:=FloatToStr(FormVariables.my_real_convert(body[i].semissW,bOk))+' ';
            s:='body'+IntToStr(i)+'emissW=' + s;
            f.Add(s);
            if (abs(FormVariables.my_real_convert(body[i].semissE,bOk))<1.0e-12) then
            begin
               body[i].emissE:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissE:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissE:='0.001';
             end;
            end;
            s:=FloatToStr(FormVariables.my_real_convert(body[i].semissE,bOk))+' ';
            s:='body'+IntToStr(i)+'emissE=' + s;
            f.Add(s);
            if (abs(FormVariables.my_real_convert(body[i].semissS,bOk))<1.0e-12) then
            begin
               body[i].emissS:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissS:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissS:='0.001';
             end;
            end;
            s:=FloatToStr(FormVariables.my_real_convert(body[i].semissS,bOk))+' ';
            s:='body'+IntToStr(i)+'emissS=' + s;
            f.Add(s);
            if (abs(FormVariables.my_real_convert(body[i].semissN,bOk))<1.0e-12) then
            begin
               body[i].emissN:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissN:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissN:='0.001';
             end;
            end;
            s:=FloatToStr(FormVariables.my_real_convert(body[i].semissN,bOk))+' ';
            s:='body'+IntToStr(i)+'emissN=' + s;
            f.Add(s);
             if (abs(FormVariables.my_real_convert(body[i].semissB,bOk))<1.0e-12) then
            begin
               body[i].emissB:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissB:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissB:='0.001';
             end;
            end;
            s:=FloatToStr(FormVariables.my_real_convert(body[i].semissB,bOk))+' ';
            s:='body'+IntToStr(i)+'emissB=' + s;
            f.Add(s);
             if (abs(FormVariables.my_real_convert(body[i].semissT,bOk))<1.0e-12) then
            begin
               body[i].emissT:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
             begin
                body[i].semissT:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[i].semissT:='0.001';
             end;
            end;
            s:=FloatToStr(FormVariables.my_real_convert(body[i].semissT,bOk))+' ';
            s:='body'+IntToStr(i)+'emissT=' + s;
            f.Add(s);
            // для emissivity мы задаём не ноль а малое положительное число,
            // т.к. с нулём может возникнуть деление на ноль в программе.
            if (FormUnsteady.CheckBoxNo_vacuum_Prism.Checked) then
            begin
               // Вакуумная призма неактивна.
               s:='body'+IntToStr(i)+'binternalRadiation=' + '0 ';
               f.Add(s);
            end
            else
            begin
               s:=IntToStr(binternalRadiation)+' ';
               s:='body'+IntToStr(i)+'binternalRadiation=' + s;
               f.Add(s);
            end;
            s:=IntToStr(imatid)+' ';
            s:='body'+IntToStr(i)+'imatid=' + s;
            f.Add(s);

            // Фиксация боковой стенки Цилидра.
            if (body[i].CylinderFixed) then
            begin
               s:='1 ';  // Фиксируем.
            end
              else
            begin
               s:='0 ';  // Free.
            end;
            s:='body'+IntToStr(i)+'bCylinderFixed=' + s+' # 1 - FIXIT, 0 - FREE.';
            f.Add(s);

            // Внимание ! нужно брать именно модуль разности координат,
            // т.к. в теории может быть нарушен порядок следования, например
            // xE может быть меньше xS что в конечном счёте может привести к смене
            // знака у мощности тепловыделения и к отрицательным температурам при
            // при положительной реальной мощности.
            // исправление от 23 сентября 2015 года.
            //Sc:=power/(abs(xE-xS)*abs(yE-yS)*abs(zE-zS)*mlength*mlength*mlength);
            //s:=s+FloatToStr(Sc)+' '; // мощность тепловыделения блока на единицу объёма
            s:=IntToStr(body[i].n_power)+' ';
            s:='body'+IntToStr(i)+'n_power='+s;
            f.Add(s);
            for i_4 := 0 to body[i].n_power-1 do
            begin
               if (body[i].igeometry_type=0) then
               begin
                  // Prism
                  s:=FloatToStr(body[i].temp_power[i_4])+' ';
                  s:='body'+IntToStr(i)+'temp_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
                  s:=FloatToStr(body[i].arr_power[i_4]/(abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS)*mlength*mlength*mlength))+' ';
                  s:='body'+IntToStr(i)+'arr_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
               end;
                if (body[i].igeometry_type=1) then
               begin
                  // Cylinder
                  if (abs(body[i].angle_end-body[i].angle_start)<0.5) then
                  begin
                      body[i].angle_end:=360.0;
                  end;
                  s:=FloatToStr(body[i].temp_power[i_4])+' ';
                  s:='body'+IntToStr(i)+'temp_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
                  s:=FloatToStr(body[i].arr_power[i_4]/(((abs(body[i].angle_end-body[i].angle_start))/360.0)*body[i].Hcyl*3.141*(body[i].R_out_cyl*body[i].R_out_cyl-body[i].R_in_cyl*body[i].R_in_cyl)*mlength*mlength*mlength))+' ';
                  s:='body'+IntToStr(i)+'arr_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
               end;
               if (body[i].igeometry_type=2) then
               begin
                  // Polygon
                  // Для полигона мы передаём значение температуры при которой задана тепловая мощность и значение
                  // тепловой мощности в Вт.
                  //s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(body[i].arr_power[i_4])+' ';
                  // 26.01.2018.
                  // Для полигона мы всегда задаём нулевое значение тепловой мощности.
                  // Главная причина. Я не умею правильно вычислять объём полигона в интерфейсе.
                  s:=FloatToStr(body[i].temp_power[i_4])+' ';
                  s:='body'+IntToStr(i)+'temp_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
                  // Для полигона передаётся значение тепловой мощности в Вт.
                  s:=FloatToStr(body[i].arr_power[i_4]);
                  s:='body'+IntToStr(i)+'arr_power'+IntToStr(i_4)+'='+s+' ';
                  f.Add(s);
                         (*
                         // работает только для треугольника
                         // и только для всюду одинаковых высот.
                         if (body[i].nsizei<3) then
                         begin
                            ShowMessage('Polygon error: power nsizei<3');
                         end;
                         if (body[i].nsizei=3) then
                         begin
                            case body[i].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*((body[i].xi[1]-body[i].xi[0])*(body[i].yi[2]-body[i].yi[0])-(body[i].yi[1]-body[i].yi[0])*(body[i].xi[2]-body[i].xi[0]))))+' ';
                                   end;
                               2: begin
                                     // XZ
                                     s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*((body[i].xi[1]-body[i].xi[0])*(body[i].zi[2]-body[i].zi[0])-(body[i].zi[1]-body[i].zi[0])*(body[i].xi[2]-body[i].xi[0]))))+' ';
                                  end;
                               3 : begin
                                      // YZ
                                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*((body[i].yi[1]-body[i].yi[0])*(body[i].zi[2]-body[i].zi[0])-(body[i].zi[1]-body[i].zi[0])*(body[i].yi[2]-body[i].yi[0]))))+' ';
                                   end;
                            end;
                         end;
                         if (body[i].nsizei>3) then
                         begin
                            //   Только выпуклый полигон, его площадь аппроксимирована
                            // суммой площадей составляющих его треугольников.
                            // Центр масс.
                            xavg:=0.0;
                            yavg:=0.0;
                            zavg:=0.0;
                            for j := 0 to body[i].nsizei-1 do
                            begin
                               xavg:=xavg+body[i].xi[j];
                               yavg:=yavg+body[i].yi[j];
                               zavg:=zavg+body[i].zi[j];
                            end;
                            xavg:=xavg/body[i].nsizei;
                            yavg:=yavg/body[i].nsizei;
                            zavg:=zavg/body[i].nsizei;

                            powertri:=0.0;
                            for j := 0 to body[i].nsizei-2 do
                            begin
                              case body[i].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      powertri:=(mlength*mlength*mlength*powertri+body[i].arr_power[i_4])/((abs(body[i].hi[0]))*(body[i].nsizei-1)*((body[i].xi[j]-xavg)*(body[i].yi[j+1]-yavg)-(body[i].yi[j]-yavg)*(body[i].xi[j+1]-xavg)));
                                   end;
                               2: begin
                                     // XZ
                                     powertri:=powertri+(mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*(body[i].nsizei-1)*((body[i].xi[j]-xavg)*(body[i].zi[j+1]-zavg)-(body[i].zi[j]-zavg)*(body[i].xi[j+1]-xavg)));
                                  end;
                               3 : begin
                                     // YZ
                                     powertri:=powertri+(mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*(body[i].nsizei-1)*((body[i].yi[j]-yavg)*(body[i].zi[j+1]-zavg)-(body[i].zi[j]-zavg)*(body[i].yi[j+1]-yavg)));
                                   end;
                               end;
                            end;
                              s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(powertri)+' ';
                            end;
                            *)
               end;
            end;
            s:=IntToStr(ipower_time_depend)+' '; // зависимость мощности тепловыделения в блоке от времени.
            s:='body'+IntToStr(i)+'ipower_time_depend='+s;
            f.Add(s);
            if ((i<>0)and checkFLUIDtoSOLID) then
            begin
                if (itype=3) then
                begin
                   s:='2 '; // FLUID to SOLID
                end;
            end
             else
            begin
               s:=IntToStr(itype)+' '; // тип блока : SOLID, HOLLOW, FLUID.
            end;
            s:='body'+IntToStr(i)+'itype='+s+' # 1 - SOLID; 2 - HOLLOW; 3 - FLUID';
            f.Add(s);
         end;

      end;
   end
   else if (body[0].itype=2) then
   begin
      // HOLLOW BLOCK
      cab_geom.xS:=1.0e20;
      cab_geom.xE:=-1.0e20;
      cab_geom.yS:=1.0e20;
      cab_geom.yE:=-1.0e20;
      cab_geom.zS:=1.0e20;
      cab_geom.zE:=-1.0e20;

      for i:=1 to (lb-1) do
      begin
         with (body[i]) do
         begin
            // 0 - PRISM; 1 - CYLINDER; 2 - POLYGON.
            if (igeometry_type=2) then
            begin
                // 1 - XY, 2 - XZ, 3 - YZ.
                case iPlane_obj2 of
                   1 : begin  //   1 - XY
                          for i_1 := 0 to nsizei-1 do
                          begin
                             if (xi[i_1]<cab_geom.xS) then
                             begin
                                cab_geom.xS:=xi[i_1];
                             end;
                             if (yi[i_1]<cab_geom.yS) then
                             begin
                                cab_geom.yS:=yi[i_1];
                             end;
                             if (xi[i_1]>cab_geom.xE) then
                             begin
                                cab_geom.xE:=xi[i_1];
                             end;
                             if (yi[i_1]>cab_geom.yE) then
                             begin
                                cab_geom.yE:=yi[i_1];
                             end;
                             if (zi[i_1]<cab_geom.zS) then
                             begin
                                cab_geom.zS:=zi[i_1];
                             end;
                             if (zi[i_1]+hi[i_1]>cab_geom.zE) then
                             begin
                                cab_geom.zE:=zi[i_1]+hi[i_1];
                             end;
                          end;
                        end;
                                2 : begin // 2 - XZ
                                       if (xi[i_1]<cab_geom.xS) then
                                       begin
                                          cab_geom.xS:=xi[i_1];
                                       end;
                                       if (zi[i_1]<cab_geom.zS) then
                                       begin
                                          cab_geom.zS:=zi[i_1];
                                       end;
                                       if (xi[i_1]>cab_geom.xE) then
                                       begin
                                          cab_geom.xE:=xi[i_1];
                                       end;
                                       if (zi[i_1]>cab_geom.zE) then
                                       begin
                                          cab_geom.zE:=zi[i_1];
                                       end;
                                       if (yi[i_1]<cab_geom.yS) then
                                       begin
                                          cab_geom.yS:=yi[i_1];
                                       end;
                                       if (yi[i_1]+hi[i_1]>cab_geom.yE) then
                                       begin
                                          cab_geom.yE:=yi[i_1]+hi[i_1];
                                       end;
                                     end;
                                3 : begin  //  3 - YZ
                                        for i_1 := 0 to nsizei-1 do
                                        begin
                                           if (zi[i_1]<cab_geom.zS) then
                                           begin
                                              cab_geom.zS:=zi[i_1];
                                           end;
                                           if (yi[i_1]<cab_geom.yS) then
                                           begin
                                              cab_geom.yS:=yi[i_1];
                                           end;
                                           if (zi[i_1]>cab_geom.zE) then
                                           begin
                                              cab_geom.zE:=zi[i_1];
                                           end;
                                           if (yi[i_1]>cab_geom.yE) then
                                           begin
                                              cab_geom.yE:=yi[i_1];
                                           end;
                                           if (xi[i_1]<cab_geom.xS) then
                                           begin
                                              cab_geom.xS:=xi[i_1];
                                           end;
                                           if (xi[i_1]+hi[i_1]>cab_geom.xE) then
                                           begin
                                              cab_geom.xE:=xi[i_1]+hi[i_1];
                                           end;
                                        end;
                                    end;
                             end;
                          end
                          else
                          begin
            if (xS<cab_geom.xS) then
            begin
               cab_geom.xS:=xS;
            end;
            if (yS<cab_geom.yS) then
            begin
               cab_geom.yS:=yS;
            end;
            if (zS<cab_geom.zS) then
            begin
               cab_geom.zS:=zS;
            end;
             if (xE>cab_geom.xE) then
            begin
               cab_geom.xE:=xE;
            end;
            if (yE>cab_geom.yE) then
            begin
               cab_geom.yE:=yE;
            end;
            if (zE>cab_geom.zE) then
            begin
               cab_geom.zE:=zE;
            end;
         end;
         end;
      end;

      cab_geom2.xS:=cab_geom.xS;
      cab_geom2.xE:=cab_geom.xE;
      cab_geom2.yS:=cab_geom.yS;
      cab_geom2.yE:=cab_geom.yE;
      cab_geom2.zS:=cab_geom.zS;
      cab_geom2.zE:=cab_geom.zE;
      for i:=0 to (ls-1) do
      begin
         with (source[i]) do
         begin
             if (xS<cab_geom2.xS) then
            begin
               cab_geom2.xS:=xS;
               MainMemo.Lines.Add('error:'+source[i].name+' xS position is incorrect.');
            end;
            if (yS<cab_geom2.yS) then
            begin
               cab_geom2.yS:=yS;
               MainMemo.Lines.Add('error:'+source[i].name+' yS position is incorrect.');
            end;
            if (zS<cab_geom2.zS) then
            begin
               cab_geom2.zS:=zS;
               MainMemo.Lines.Add('error:'+source[i].name+' zS position is incorrect.');
            end;
             if (xE>cab_geom2.xE) then
            begin
               cab_geom2.xE:=xE;
               MainMemo.Lines.Add('error:'+source[i].name+' xE position is incorrect.');
            end;
            if (yE>cab_geom2.yE) then
            begin
               cab_geom2.yE:=yE;
               MainMemo.Lines.Add('error:'+source[i].name+' yE position is incorrect.');
            end;
            if (zE>cab_geom2.zE) then
            begin
               cab_geom2.zE:=zE;
               MainMemo.Lines.Add('error:'+source[i].name+' zE position is incorrect.');
            end;
         end;
      end;
       for i:=0 to (lw-1) do
      begin
         with (wall[i]) do
         begin
            if (cabinet_depend=0) then
            begin
               if (xS<cab_geom2.xS) then
               begin
                  cab_geom2.xS:=xS;
                   MainMemo.Lines.Add('error:'+wall[i].name+' xS position is incorrect.');
               end;
               if (yS<cab_geom2.yS) then
               begin
                  cab_geom2.yS:=yS;
                  MainMemo.Lines.Add('error:'+wall[i].name+' yS position is incorrect.');
               end;
               if (zS<cab_geom2.zS) then
               begin
                  cab_geom2.zS:=zS;
                  MainMemo.Lines.Add('error:'+wall[i].name+' zS position is incorrect.');
               end;
               if (xE>cab_geom2.xE) then
               begin
                  cab_geom2.xE:=xE;
                  MainMemo.Lines.Add('error:'+wall[i].name+' xE position is incorrect.');
               end;
               if (yE>cab_geom2.yE) then
               begin
                  cab_geom2.yE:=yE;
                  MainMemo.Lines.Add('error:'+wall[i].name+' yE position is incorrect.');
               end;
               if (zE>cab_geom2.zE) then
               begin
                  cab_geom2.zE:=zE;
                  MainMemo.Lines.Add('error:'+wall[i].name+' zE position is incorrect.');
               end;
            end;
         end;
      end;

       if (cab_geom2.xS<cab_geom.xS) then
       begin
          bmodelcheck_cab_hollow:=false;
       end;
       if (cab_geom2.yS<cab_geom.yS) then
       begin
          bmodelcheck_cab_hollow:=false;
       end;
       if (cab_geom2.zS<cab_geom.zS) then
       begin
          bmodelcheck_cab_hollow:=false;
       end;
       if (cab_geom2.xE>cab_geom.xE) then
       begin
          bmodelcheck_cab_hollow:=false;
       end;
        if (cab_geom2.yE>cab_geom.yE) then
       begin
          bmodelcheck_cab_hollow:=false;
       end;
        if (cab_geom2.zE>cab_geom.zE) then
       begin
          bmodelcheck_cab_hollow:=false;
       end;
       if (not(bmodelcheck_cab_hollow)) then
       begin
          ShowMessage('Error. Your geometry model is incorrect. Dont Start Solver.');
          MainMemo.Lines.Add('Error. Your geometry model is incorrect. Dont Start Solver.');
       end;

       i:=0;
       with (body[0]) do
         begin
             s:='body'+IntToStr(i)+'name='+name+' ';
             f.Add(s);

            s:=IntToStr(iunion)+' ';
            s:='body'+IntToStr(i)+'iunion='+s;
            f.Add(s);
            s:=IntToStr(0)+' ';// igeometry_type= Prism.
            s:='body'+IntToStr(i)+'igeometry_type='+s;
            f.Add(s);
            // visible or not visible
            if (bvisible) then
            begin
               // Участвует в расчёте и прорисовывается в tecplot 360.
               s:='1 '; // Visible
            end
            else
            begin
               // Участвует в расчёте но не прорисовывается в Tecplot 360.
               s:='0 '; // not Visible
               //MainMemo.Lines.Add('body['+IntToStr(i)+'] not vible');
            end;
            s:='body'+IntToStr(i)+'bvisible='+s+' # 1 - VISIBLE, 0 - NOT VISIBLE';
            f.Add(s);
            s:=FloatToStr(cab_geom.xS)+' ';
            s:='body'+IntToStr(i)+'xS='+s;
            f.Add(s);
            s:=FloatToStr(cab_geom.yS)+' ';
            s:='body'+IntToStr(i)+'yS='+s;
            f.Add(s);
            s:=FloatToStr(cab_geom.zS)+' ';
            s:='body'+IntToStr(i)+'zS='+s;
            f.Add(s);
            s:=FloatToStr(cab_geom.xE)+' ';
            s:='body'+IntToStr(i)+'xE='+s;
            f.Add(s);
            s:=FloatToStr(cab_geom.yE)+' ';
            s:='body'+IntToStr(i)+'yE='+s;
            f.Add(s);
            s:=FloatToStr(cab_geom.zE)+' ';
            s:='body'+IntToStr(i)+'zE='+s;
            f.Add(s);
            // Cylinder
            s:=IntToStr(iPlane)+' ';  // 1 - XY, 2 - XZ, 3 - YZ.
            s:='body'+IntToStr(i)+'iPlane='+s+' # 1 - XY, 2 - XZ, 3 - YZ';
            f.Add(s);
             s:=FloatToStr(xC)+' ';
            s:='body'+IntToStr(i)+'xC='+s;
            f.Add(s);
            s:=FloatToStr(yC)+' ';
            s:='body'+IntToStr(i)+'yC='+s;
            f.Add(s);
            s:=FloatToStr(zC)+' ';
            s:='body'+IntToStr(i)+'zC='+s;
            f.Add(s);
            s:=FloatToStr(Hcyl)+' ';
            s:='body'+IntToStr(i)+'Hcyl='+s+' # Height on cylinder';
            f.Add(s);
            s:=FloatToStr(R_out_cyl)+' ';
            s:='body'+IntToStr(i)+'R_out_cyl='+s+' # radius on cylinder';
            f.Add(s);
            s:=FloatToStr(R_in_cyl)+' ';
            s:='body'+IntToStr(i)+'R_in_cyl='+s+' # internal radius on cylinder';
            f.Add(s);
            // sector, conoid
            (*
            s:=s+FloatToStr(R_out_cyl2)+ ' ';
            s:=s+FloatToStr(R_in_cyl2)+' ';
            s:=s+FloatToStr(angle_start)+ ' ';
            s:=s+FloatToStr(angle_end)+' ';
            *)

             // Polygon
             s:=IntToStr(iPlane_obj2)+' '; // 1 - XY, 2 - XZ, 3 - YZ.
             s:='body'+IntToStr(i)+'iPlane_obj2=' + s;
             f.Add(s);
             s:=IntToStr(nsizei)+' ';
             s:='body'+IntToStr(i)+'nsizei=' + s+' # number of points for polygon';
             f.Add(s);
             for j := 0 to nsizei-1 do
             begin
                s:=FloatToStr(hi[j])+' ';
                s:='body'+IntToStr(i)+'hi'+IntToStr(j)+'='+ s;
                f.Add(s);
                s:=FloatToStr(xi[j])+' ';
                s:='body'+IntToStr(i)+'xi'+IntToStr(j)+'='+ s;
                f.Add(s);
                s:=FloatToStr(yi[j])+' ';
                s:='body'+IntToStr(i)+'yi'+IntToStr(j)+'='+ s;
                f.Add(s);
                s:=FloatToStr(zi[j])+' ';
                s:='body'+IntToStr(i)+'zi'+IntToStr(j)+'='+ s;
                f.Add(s);
             end;

            // emissivity :
            bOk:=true;
            if (abs(FormVariables.my_real_convert(semissW,bOk))<1.0e-12) then
            begin
               body[0].emissW:=0.001;
                 if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissW:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissW:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissW)+' ';
            s:=FloatToStr(FormVariables.my_real_convert(semissW,bOk))+' ';
            s:='body'+IntToStr(i)+'emissW='+s;
            f.Add(s);
            if (abs(FormVariables.my_real_convert(semissE,bOk))<1.0e-12) then
            begin
               body[0].emissE:=0.001;
                   if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissE:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissE:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissE)+' ';
            s:=FloatToStr(FormVariables.my_real_convert(semissE,bOk))+' ';
            s:='body'+IntToStr(i)+'emissE='+s;
            f.Add(s);
            if (abs(FormVariables.my_real_convert(semissS,bOk))<1.0e-12) then
            begin
               body[0].emissS:=0.001;
                   if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissS:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissS:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissS)+' ';
            s:=FloatToStr(FormVariables.my_real_convert(semissS,bOk))+' ';
            s:='body'+IntToStr(i)+'emissS='+s;
            f.Add(s);
            if (abs(FormVariables.my_real_convert(semissN,bOk))<1.0e-12) then
            begin
               body[0].emissN:=0.001;
             if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissN:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissN:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissN)+' ';
            s:=FloatToStr(FormVariables.my_real_convert(semissN,bOk))+' ';
             s:='body'+IntToStr(i)+'emissN='+s;
            f.Add(s);
             if (abs(FormVariables.my_real_convert(semissB,bOk))<1.0e-12) then
            begin
               body[0].emissB:=0.001;
                   if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissB:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissB:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissB)+' ';
            s:=FloatToStr(FormVariables.my_real_convert(semissB,bOk))+' ';
            s:='body'+IntToStr(i)+'emissB='+s;
            f.Add(s);
             if (abs(FormVariables.my_real_convert(semissT,bOk))<1.0e-12) then
            begin
               body[0].emissT:=0.001;
                   if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissT:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissT:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissT)+' ';
            s:=FloatToStr(FormVariables.my_real_convert(semissT,bOk))+' ';
            s:='body'+IntToStr(i)+'emissT='+s;
            f.Add(s);

            // для emissivity мы задаём не ноль а малое положительное число,
            // т.к. с нулём может возникнуть деление на ноль в программе.
            s:=IntToStr(binternalRadiation)+' ';
            s:='body'+IntToStr(i)+'binternalRadiation=' + s;
            f.Add(s);
            s:=IntToStr(imatid)+' ';
            s:='body'+IntToStr(i)+'imatid=' + s;
            f.Add(s);

            // Фиксация боковой стенки Цилидра.
            if (body[i].CylinderFixed) then
            begin
               s:='1 ';  // Фиксируем.
            end
              else
            begin
               s:='0 ';  // Free.
            end;
            s:='body'+IntToStr(i)+'bCylinderFixed=' + s+' # 1 - FIXIT, 0 - FREE.';
            f.Add(s);

            // Внимание ! нужно брать именно модуль разности координат,
            // т.к. в теории может быть нарушен порядок следования, например
            // xE может быть меньше xS что в конечном счёте может привести к смене
            // знака у мощности тепловыделения и к отрицательным температурам при
            // при положительной реальной мощности.
            // исправление от 23 сентября 2015 года.
            //Sc:=power/(abs(xE-xS)*abs(yE-yS)*abs(zE-zS)*mlength*mlength*mlength);
            //s:=s+FloatToStr(Sc)+' '; // мощность тепловыделения блока на единицу объёма
            s:=IntToStr(body[i].n_power)+' ';
            s:='body'+IntToStr(i)+'n_power='+s;
            f.Add(s);
            for i_4 := 0 to body[i].n_power-1 do
            begin
               if (body[i].igeometry_type=0) then
               begin
                  // Prism
                  s:=FloatToStr(body[i].temp_power[i_4])+' ';
                  s:='body'+IntToStr(i)+'temp_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
                  s:=FloatToStr(body[i].arr_power[i_4]/(abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS)*mlength*mlength*mlength))+' ';
                  s:='body'+IntToStr(i)+'arr_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
               end;
                if (body[i].igeometry_type=1) then
               begin
                  // Cylinder
                  if (abs(body[i].angle_end-body[i].angle_start)<0.5) then
                  begin
                      body[i].angle_end:=360.0;
                  end;
                  s:=FloatToStr(body[i].temp_power[i_4])+' ';
                  s:='body'+IntToStr(i)+'temp_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
                  s:=FloatToStr(body[i].arr_power[i_4]/(((abs(body[i].angle_end-body[i].angle_start))/360.0)*body[i].Hcyl*3.141*(body[i].R_out_cyl*body[i].R_out_cyl-body[i].R_in_cyl*body[i].R_in_cyl)*mlength*mlength*mlength))+' ';
                  s:='body'+IntToStr(i)+'arr_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
               end;
               if (body[i].igeometry_type=2) then
               begin
                  // Polygon
                  // Для полигона мы передаём значение температуры при которой задана тепловая мощность и значение
                  // тепловой мощности в Вт.
                  //s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(body[i].arr_power[i_4])+' ';
                  // 26.01.2018.
                  // Для полигона мы всегда задаём нулевое значение тепловой мощности.
                  // Главная причина. Я не умею правильно вычислять объём полигона в интерфейсе.
                  s:=FloatToStr(body[i].temp_power[i_4])+' ';
                  s:='body'+IntToStr(i)+'temp_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
                  // Для полигона передаётся значение тепловой мощности в Вт.
                  s:=FloatToStr(body[i].arr_power[i_4]);
                  s:='body'+IntToStr(i)+'arr_power'+IntToStr(i_4)+'='+s+' ';
                  f.Add(s);
                         (*
                         // работает только для треугольника
                         // и только для всюду одинаковых высот.
                         if (body[i].nsizei<3) then
                         begin
                            ShowMessage('Polygon error: power nsizei<3');
                         end;
                         if (body[i].nsizei=3) then
                         begin
                            case body[i].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*((body[i].xi[1]-body[i].xi[0])*(body[i].yi[2]-body[i].yi[0])-(body[i].yi[1]-body[i].yi[0])*(body[i].xi[2]-body[i].xi[0]))))+' ';
                                   end;
                               2: begin
                                     // XZ
                                     s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*((body[i].xi[1]-body[i].xi[0])*(body[i].zi[2]-body[i].zi[0])-(body[i].zi[1]-body[i].zi[0])*(body[i].xi[2]-body[i].xi[0]))))+' ';
                                  end;
                               3 : begin
                                      // YZ
                                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*((body[i].yi[1]-body[i].yi[0])*(body[i].zi[2]-body[i].zi[0])-(body[i].zi[1]-body[i].zi[0])*(body[i].yi[2]-body[i].yi[0]))))+' ';
                                   end;
                            end;
                         end;
                         if (body[i].nsizei>3) then
                         begin
                            //   Только выпуклый полигон, его площадь аппроксимирована
                            // суммой площадей составляющих его треугольников.
                            // Центр масс.
                            xavg:=0.0;
                            yavg:=0.0;
                            zavg:=0.0;
                            for j := 0 to body[i].nsizei-1 do
                            begin
                               xavg:=xavg+body[i].xi[j];
                               yavg:=yavg+body[i].yi[j];
                               zavg:=zavg+body[i].zi[j];
                            end;
                            xavg:=xavg/body[i].nsizei;
                            yavg:=yavg/body[i].nsizei;
                            zavg:=zavg/body[i].nsizei;

                            powertri:=0.0;
                            for j := 0 to body[i].nsizei-2 do
                            begin
                              case body[i].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      powertri:=(mlength*mlength*mlength*powertri+body[i].arr_power[i_4])/((abs(body[i].hi[0]))*(body[i].nsizei-1)*((body[i].xi[j]-xavg)*(body[i].yi[j+1]-yavg)-(body[i].yi[j]-yavg)*(body[i].xi[j+1]-xavg)));
                                   end;
                               2: begin
                                     // XZ
                                     powertri:=powertri+(mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*(body[i].nsizei-1)*((body[i].xi[j]-xavg)*(body[i].zi[j+1]-zavg)-(body[i].zi[j]-zavg)*(body[i].xi[j+1]-xavg)));
                                  end;
                               3 : begin
                                     // YZ
                                     powertri:=powertri+(mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*(body[i].nsizei-1)*((body[i].yi[j]-yavg)*(body[i].zi[j+1]-zavg)-(body[i].zi[j]-zavg)*(body[i].yi[j+1]-yavg)));
                                   end;
                               end;
                            end;
                              s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(powertri)+' ';
                            end;
                            *)
                         end;
            end;
            s:=IntToStr(ipower_time_depend)+' '; // зависимость мощности тепловыделения в блоке от времени.
            s:='body'+IntToStr(i)+'ipower_time_depend='+s;
            f.Add(s);
            if ((i<>0)and checkFLUIDtoSOLID) then
            begin
                if (itype=3) then
                begin
                   s:='2 '; // FLUID to SOLID
                end;
            end
             else
            begin
               s:=IntToStr(itype)+' '; // тип блока : SOLID, HOLLOW, FLUID.
            end;
            s:='body'+IntToStr(i)+'itype='+s+' # 1 - SOLID; 2 - HOLLOW; 3 - FLUID';
            f.Add(s);

         end;

       i:=0;
       with (body[0]) do
         begin

             s:='body'+IntToStr(i+1)+'name='+name+' ';
             f.Add(s);
            s:=IntToStr(iunion)+' ';
            s:='body'+IntToStr(i+1)+'iunion='+s;
            f.Add(s);
            s:=IntToStr(0)+' ';// igeometry_type= Prism.
            s:='body'+IntToStr(i+1)+'igeometry_type='+s;
            f.Add(s);
            // visible or not visible
            if (bvisible) then
            begin
               // Участвует в расчёте и прорисовывается в tecplot 360.
               s:='1 '; // Visible
            end
            else
            begin
               // Участвует в расчёте но не прорисовывается в Tecplot 360.
               s:='0 '; // not Visible
               //MainMemo.Lines.Add('body['+IntToStr(i+1)+'] not vible');
            end;
            s:='body'+IntToStr(i+1)+'bvisible=1 # 1 - VISIBLE, 0 - NOT VISIBLE';
            f.Add(s);
            s:=FloatToStr(cab_geom.xS)+' ';
            s:='body'+IntToStr(i+1)+'xS='+s;
            f.Add(s);
            s:=FloatToStr(cab_geom.yS)+' ';
            s:='body'+IntToStr(i+1)+'yS='+s;
            f.Add(s);
            s:=FloatToStr(cab_geom.zS)+' ';
            s:='body'+IntToStr(i+1)+'zS='+s;
            f.Add(s);
            s:=FloatToStr(cab_geom.xE)+' ';
            s:='body'+IntToStr(i+1)+'xE='+s;
            f.Add(s);
            s:=FloatToStr(cab_geom.yE)+' ';
            s:='body'+IntToStr(i+1)+'yE='+s;
            f.Add(s);
            s:=FloatToStr(cab_geom.zE)+' ';
            s:='body'+IntToStr(i+1)+'zE='+s;
            f.Add(s);
            // Cylinder
            s:=IntToStr(iPlane)+' ';  // 1 - XY, 2 - XZ, 3 - YZ.
            s:='body'+IntToStr(i+1)+'iPlane='+s+' # 1 - XY, 2 - XZ, 3 - YZ';
            f.Add(s);
             s:=FloatToStr(xC)+' ';
            s:='body'+IntToStr(i+1)+'xC='+s;
            f.Add(s);
            s:=FloatToStr(yC)+' ';
            s:='body'+IntToStr(i+1)+'yC='+s;
            f.Add(s);
            s:=FloatToStr(zC)+' ';
            s:='body'+IntToStr(i+1)+'zC='+s;
            f.Add(s);
            s:=FloatToStr(Hcyl)+' ';
            s:='body'+IntToStr(i+1)+'Hcyl='+s+' # Height on cylinder';
            f.Add(s);
            s:=FloatToStr(R_out_cyl)+' ';
            s:='body'+IntToStr(i+1)+'R_out_cyl='+s+' # radius on cylinder';
            f.Add(s);
            s:=FloatToStr(R_in_cyl)+' ';
            s:='body'+IntToStr(i+1)+'R_in_cyl='+s+' # internal radius on cylinder';
            f.Add(s);
            // sector, conoid
            (*
            s:=s+FloatToStr(R_out_cyl2)+ ' ';
            s:=s+FloatToStr(R_in_cyl2)+' ';
            s:=s+FloatToStr(angle_start)+ ' ';
            s:=s+FloatToStr(angle_end)+' ';
            *)

             // Polygon
             s:=IntToStr(iPlane_obj2)+' '; // 1 - XY, 2 - XZ, 3 - YZ.
             s:='body'+IntToStr(i+1)+'iPlane_obj2=' + s;
             f.Add(s);
             s:=IntToStr(nsizei)+' ';
             s:='body'+IntToStr(i+1)+'nsizei=' + s+' # number of points for polygon';
             f.Add(s);
             for j := 0 to nsizei-1 do
             begin
                s:=FloatToStr(hi[j])+' ';
                s:='body'+IntToStr(i+1)+'hi'+IntToStr(j)+'='+ s;
                f.Add(s);
                s:=FloatToStr(xi[j])+' ';
                s:='body'+IntToStr(i+1)+'xi'+IntToStr(j)+'='+ s;
                f.Add(s);
                s:=FloatToStr(yi[j])+' ';
                s:='body'+IntToStr(i+1)+'yi'+IntToStr(j)+'='+ s;
                f.Add(s);
                s:=FloatToStr(zi[j])+' ';
                s:='body'+IntToStr(i+1)+'zi'+IntToStr(j)+'='+ s;
                f.Add(s);
             end;

            // emissivity :
            bOk:=true;
            if (abs(FormVariables.my_real_convert(semissW,bOk))<1.0e-12) then
            begin
               body[0].emissW:=0.001;
                 if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissW:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissW:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissW)+' ';
            s:=FloatToStr(FormVariables.my_real_convert(semissW,bOk))+' ';
            s:='body'+IntToStr(i+1)+'emissW='+s;
            f.Add(s);
            if (abs(FormVariables.my_real_convert(semissE,bOk))<1.0e-12) then
            begin
               body[0].emissE:=0.001;
                   if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissE:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissE:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissE)+' ';
            s:=FloatToStr(FormVariables.my_real_convert(semissE,bOk))+' ';
            s:='body'+IntToStr(i+1)+'emissE='+s;
            f.Add(s);
            if (abs(FormVariables.my_real_convert(semissS,bOk))<1.0e-12) then
            begin
               body[0].emissS:=0.001;
                   if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissS:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissS:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissS)+' ';
            s:=FloatToStr(FormVariables.my_real_convert(semissS,bOk))+' ';
            s:='body'+IntToStr(i+1)+'emissS='+s;
            f.Add(s);
            if (abs(FormVariables.my_real_convert(semissN,bOk))<1.0e-12) then
            begin
               body[0].emissN:=0.001;
             if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissN:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissN:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissN)+' ';
            s:=FloatToStr(FormVariables.my_real_convert(semissN,bOk))+' ';
             s:='body'+IntToStr(i+1)+'emissN='+s;
            f.Add(s);
             if (abs(FormVariables.my_real_convert(semissB,bOk))<1.0e-12) then
            begin
               body[0].emissB:=0.001;
                   if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissB:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissB:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissB)+' ';
            s:=FloatToStr(FormVariables.my_real_convert(semissB,bOk))+' ';
            s:='body'+IntToStr(i+1)+'emissB='+s;
            f.Add(s);
             if (abs(FormVariables.my_real_convert(semissT,bOk))<1.0e-12) then
            begin
               body[0].emissT:=0.001;
                   if (FormatSettings.DecimalSeparator=',') then
             begin
                body[0].semissT:='0,001';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                body[0].semissT:='0.001';
             end;
            end;
            //s:=s+FloatToStr(emissT)+' ';
            s:=FloatToStr(FormVariables.my_real_convert(semissT,bOk))+' ';
            s:='body'+IntToStr(i+1)+'emissT='+s;
            f.Add(s);

            // для emissivity мы задаём не ноль а малое положительное число,
            // т.к. с нулём может возникнуть деление на ноль в программе.
            s:=IntToStr(binternalRadiation)+' ';
            s:='body'+IntToStr(i+1)+'binternalRadiation=0 ';
            f.Add(s);
            s:=IntToStr(imatid)+' ';
            s:='body'+IntToStr(i+1)+'imatid=' + s;
            f.Add(s);

            // Фиксация боковой стенки Цилидра.
            if (body[i].CylinderFixed) then
            begin
               s:='1 ';  // Фиксируем.
            end
              else
            begin
               s:='0 ';  // Free.
            end;
            s:='body'+IntToStr(i+1)+'bCylinderFixed=' + s+' # 1 - FIXIT, 0 - FREE.';
            f.Add(s);

            // Внимание ! нужно брать именно модуль разности координат,
            // т.к. в теории может быть нарушен порядок следования, например
            // xE может быть меньше xS что в конечном счёте может привести к смене
            // знака у мощности тепловыделения и к отрицательным температурам при
            // при положительной реальной мощности.
            // исправление от 23 сентября 2015 года.
            //Sc:=power/(abs(xE-xS)*abs(yE-yS)*abs(zE-zS)*mlength*mlength*mlength);
            //s:=s+FloatToStr(Sc)+' '; // мощность тепловыделения блока на единицу объёма
            s:=IntToStr(body[i].n_power)+' ';
            s:='body'+IntToStr(i+1)+'n_power='+s;
            f.Add(s);
            for i_4 := 0 to body[i].n_power-1 do
            begin
               if (body[i].igeometry_type=0) then
               begin
                  // Prism
                  s:=FloatToStr(body[i].temp_power[i_4])+' ';
                  s:='body'+IntToStr(i+1)+'temp_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
                  s:=FloatToStr(body[i].arr_power[i_4]/(abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS)*mlength*mlength*mlength))+' ';
                  s:='body'+IntToStr(i+1)+'arr_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
               end;
                if (body[i].igeometry_type=1) then
               begin
                  // Cylinder
                  if (abs(body[i].angle_end-body[i].angle_start)<0.5) then
                  begin
                      body[i].angle_end:=360.0;
                  end;
                  s:=FloatToStr(body[i].temp_power[i_4])+' ';
                  s:='body'+IntToStr(i+1)+'temp_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
                  s:=FloatToStr(body[i].arr_power[i_4]/(((abs(body[i].angle_end-body[i].angle_start))/360.0)*body[i].Hcyl*3.141*(body[i].R_out_cyl*body[i].R_out_cyl-body[i].R_in_cyl*body[i].R_in_cyl)*mlength*mlength*mlength))+' ';
                  s:='body'+IntToStr(i+1)+'arr_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
               end;
               if (body[i].igeometry_type=2) then
               begin
                  // Polygon
                  // Для полигона мы передаём значение температуры при которой задана тепловая мощность и значение
                  // тепловой мощности в Вт.
                  //s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(body[i].arr_power[i_4])+' ';
                  // 26.01.2018.
                  // Для полигона мы всегда задаём нулевое значение тепловой мощности.
                  // Главная причина. Я не умею правильно вычислять объём полигона в интерфейсе.
                  s:=FloatToStr(body[i].temp_power[i_4])+' ';
                  s:='body'+IntToStr(i+1)+'temp_power'+IntToStr(i_4)+'='+s;
                  f.Add(s);
                  // Для полигона передаётся значение тепловой мощности в Вт.
                  s:=FloatToStr(body[i].arr_power[i_4]);
                  s:='body'+IntToStr(i+1)+'arr_power'+IntToStr(i_4)+'='+s+' ';
                  f.Add(s);
                         (*
                         // работает только для треугольника
                         // и только для всюду одинаковых высот.
                         if (body[i].nsizei<3) then
                         begin
                            ShowMessage('Polygon error: power nsizei<3');
                         end;
                         if (body[i].nsizei=3) then
                         begin
                            case body[i].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*((body[i].xi[1]-body[i].xi[0])*(body[i].yi[2]-body[i].yi[0])-(body[i].yi[1]-body[i].yi[0])*(body[i].xi[2]-body[i].xi[0]))))+' ';
                                   end;
                               2: begin
                                     // XZ
                                     s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*((body[i].xi[1]-body[i].xi[0])*(body[i].zi[2]-body[i].zi[0])-(body[i].zi[1]-body[i].zi[0])*(body[i].xi[2]-body[i].xi[0]))))+' ';
                                  end;
                               3 : begin
                                      // YZ
                                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*((body[i].yi[1]-body[i].yi[0])*(body[i].zi[2]-body[i].zi[0])-(body[i].zi[1]-body[i].zi[0])*(body[i].yi[2]-body[i].yi[0]))))+' ';
                                   end;
                            end;
                         end;
                         if (body[i].nsizei>3) then
                         begin
                            //   Только выпуклый полигон, его площадь аппроксимирована
                            // суммой площадей составляющих его треугольников.
                            // Центр масс.
                            xavg:=0.0;
                            yavg:=0.0;
                            zavg:=0.0;
                            for j := 0 to body[i].nsizei-1 do
                            begin
                               xavg:=xavg+body[i].xi[j];
                               yavg:=yavg+body[i].yi[j];
                               zavg:=zavg+body[i].zi[j];
                            end;
                            xavg:=xavg/body[i].nsizei;
                            yavg:=yavg/body[i].nsizei;
                            zavg:=zavg/body[i].nsizei;

                            powertri:=0.0;
                            for j := 0 to body[i].nsizei-2 do
                            begin
                              case body[i].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      powertri:=(mlength*mlength*mlength*powertri+body[i].arr_power[i_4])/((abs(body[i].hi[0]))*(body[i].nsizei-1)*((body[i].xi[j]-xavg)*(body[i].yi[j+1]-yavg)-(body[i].yi[j]-yavg)*(body[i].xi[j+1]-xavg)));
                                   end;
                               2: begin
                                     // XZ
                                     powertri:=powertri+(mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*(body[i].nsizei-1)*((body[i].xi[j]-xavg)*(body[i].zi[j+1]-zavg)-(body[i].zi[j]-zavg)*(body[i].xi[j+1]-xavg)));
                                  end;
                               3 : begin
                                     // YZ
                                     powertri:=powertri+(mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i].hi[0]))*(body[i].nsizei-1)*((body[i].yi[j]-yavg)*(body[i].zi[j+1]-zavg)-(body[i].zi[j]-zavg)*(body[i].yi[j+1]-yavg)));
                                   end;
                               end;
                            end;
                              s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(powertri)+' ';
                            end;
                            *)
                         end;
            end;
            s:=IntToStr(ipower_time_depend)+' '; // зависимость мощности тепловыделения в блоке от времени.
            s:='body'+IntToStr(i+1)+'ipower_time_depend='+s;
            f.Add(s);
            if ((i<>0)and checkFLUIDtoSOLID) then
            begin
                if (itype=3) then
                begin
                   s:='2 '; // FLUID to SOLID
                end;
            end
             else
            begin
               s:=IntToStr(itype)+' '; // тип блока : SOLID, HOLLOW, FLUID.
            end;
            s:='body'+IntToStr(i+1)+'itype=2 # 1 - SOLID; 2 - HOLLOW; 3 - FLUID';
            f.Add(s);

         end;

      // остальные блоки.
      for i:=1 to (lb-1) do
      begin
         with (body[i]) do
         begin

             s:='body'+IntToStr(i+1)+'name='+name+' ';
             f.Add(s);

             // Принадлежность union (Асемблесу).
              for i3 := 0 to (lu-1) do
            begin
               if (myassembles[i3].identifire=iunion)then
               begin
                  if (myassembles[i3].bmesh_assembles_separately) then
                  begin
                     bf7:=true;
                  end;
               end;
            end;
            if (bf7) then
            begin
               s:=IntToStr(iunion)+' ';
            end
             else
            begin
               s:='0 ';
            end;
            s:='body'+IntToStr(i+1)+'iunion='+s;
            f.Add(s);
             // 0 - Prism, 1 - Cylinder, 2 - Polygon.
            if (FormUnsteady.CheckBoxCylinderToPrism.Checked and (igeometry_type=1))  then
            begin
               // to Prism
               s:=IntToStr(0)+' ';
               case iPlane of
               1 : begin
                      // XY
                      zS1:=zC;
                      zE1:=zC+Hcyl;
                      xS1:=xC-0.8861433*R_out_cyl;
                      xE1:=xC+0.8861433*R_out_cyl;
                      yS1:=yC-0.8861433*R_out_cyl;
                      yE1:=yC+0.8861433*R_out_cyl;
                   end;
               2 : begin
                      //XZ
                      yS1:=yC;
                      yE1:=yC+Hcyl;
                      xS1:=xC-0.8861433*R_out_cyl;
                      xE1:=xC+0.8861433*R_out_cyl;
                      zS1:=zC-0.8861433*R_out_cyl;
                      zE1:=zC+0.8861433*R_out_cyl;
                   end;
               3 : begin
                      // YZ
                      xS1:=xC;
                      xE1:=xC+Hcyl;
                      yS1:=yC-0.8861433*R_out_cyl;
                      yE1:=yC+0.8861433*R_out_cyl;
                      zS1:=zC-0.8861433*R_out_cyl;
                      zE1:=zC+0.8861433*R_out_cyl;
                   end;
               end;
            end
             else
            begin
               s:=IntToStr(igeometry_type)+' ';
            end;
            s:='body'+IntToStr(i+1)+'igeometry_type='+s;
            f.Add(s);
             // visible or not visible
            if (bvisible) then
            begin
               // Участвует в расчёте и прорисовывается в tecplot 360.
               s:='1 '; // Visible
            end
            else
            begin
               // Участвует в расчёте но не прорисовывается в Tecplot 360.
               s:='0 '; // not Visible
               //MainMemo.Lines.Add('body['+IntToStr(i)+'] not vible');
            end;
            s:='body'+IntToStr(i+1)+'bvisible='+s+' # 1 - VISIBLE, 0 - NOT VISIBLE';
            f.Add(s);

            // Prism
            if (FormUnsteady.CheckBoxCylinderToPrism.Checked and (igeometry_type=1))  then
            begin
               //s:=s+FloatToStr(xS1)+' ';
               s:='body'+IntToStr(i+1)+'xS='+FloatToStr(xS1)+' ';
               f.Add(s);
               //s:=s+FloatToStr(yS1)+' ';
               s:='body'+IntToStr(i+1)+'yS='+FloatToStr(yS1)+' ';
               f.Add(s);
               //s:=s+FloatToStr(zS1)+' ';
               s:='body'+IntToStr(i+1)+'zS='+FloatToStr(zS1)+' ';
               f.Add(s);
               //s:=s+FloatToStr(xE1)+' ';
               s:='body'+IntToStr(i+1)+'xE='+FloatToStr(xE1)+' ';
               f.Add(s);
               //s:=s+FloatToStr(yE1)+' ';
               s:='body'+IntToStr(i+1)+'yE='+FloatToStr(yE1)+' ';
               f.Add(s);
               //s:=s+FloatToStr(zE1)+' ';
               s:='body'+IntToStr(i+1)+'zE='+FloatToStr(zE1)+' ';
               f.Add(s);
            end
             else
            begin
               //s:=s+FloatToStr(xS)+' ';
               s:='body'+IntToStr(i+1)+'xS='+FloatToStr(xS)+' ';
               f.Add(s);
               //s:=s+FloatToStr(yS)+' ';
               s:='body'+IntToStr(i+1)+'yS='+FloatToStr(yS)+' ';
               f.Add(s);
               // s:=s+FloatToStr(zS)+' ';
               s:='body'+IntToStr(i+1)+'zS='+FloatToStr(zS)+' ';
               f.Add(s);
               //s:=s+FloatToStr(xE)+' ';
                s:='body'+IntToStr(i+1)+'xE='+FloatToStr(xE)+' ';
               f.Add(s);
               //s:=s+FloatToStr(yE)+' ';
               s:='body'+IntToStr(i+1)+'yE='+FloatToStr(yE)+' ';
               f.Add(s);
               //s:=s+FloatToStr(zE)+' ';
               s:='body'+IntToStr(i+1)+'zE='+FloatToStr(zE)+' ';
               f.Add(s);
            end;
            // Cylinder
           // s:=s+IntToStr(iPlane)+' ';  // 1 - XY, 2 - XZ, 3 - YZ.
            s:='body'+IntToStr(i+1)+'iPlane='+ IntToStr(iPlane)+' ';  // 1 - XY, 2 - XZ, 3 - YZ.
            f.Add(s);
            //s:=s+FloatToStr(xC)+' ';
            s:='body'+IntToStr(i+1)+'xC='+ FloatToStr(xC)+' ';
            f.Add(s);
            //s:=s+FloatToStr(yC)+' ';
            s:='body'+IntToStr(i+1)+'yC='+ FloatToStr(yC)+' ';
            f.Add(s);
            //s:=s+FloatToStr(zC)+' ';
            s:='body'+IntToStr(i+1)+'zC='+ FloatToStr(zC)+' ';
            f.Add(s);
            //s:=s+FloatToStr(Hcyl)+' ';
            s:='body'+IntToStr(i+1)+'Hcyl='+ FloatToStr(Hcyl)+' ';
            f.Add(s);
           // s:=s+FloatToStr(R_out_cyl)+' ';
            s:='body'+IntToStr(i+1)+'R_out_cyl='+FloatToStr(R_out_cyl)+' ';
            f.Add(s);
            //s:=s+FloatToStr(R_in_cyl)+' ';
            s:='body'+IntToStr(i+1)+'R_in_cyl='+ FloatToStr(R_in_cyl)+' ';
            f.Add(s);
            // sector, conoid
            (*
            s:=s+FloatToStr(R_out_cyl2)+ ' ';
            s:=s+FloatToStr(R_in_cyl2)+' ';
            s:=s+FloatToStr(angle_start)+ ' ';
            s:=s+FloatToStr(angle_end)+' ';
            *)
             // Polygon
             //s:=s+IntToStr(iPlane_obj2)+' '; // 1 - XY, 2 - XZ, 3 - YZ.
             s:='body'+IntToStr(i+1)+'iPlane_obj2='+ IntToStr(iPlane_obj2)+' ';
             f.Add(s);
             //s:=s+IntToStr(nsizei)+' ';
             s:='body'+IntToStr(i+1)+'nsizei='+IntToStr(nsizei)+' ';
             f.Add(s);
             for j := 0 to nsizei-1 do
             begin
                //s:=s+FloatToStr(hi[j])+' ';
                s:='body'+IntToStr(i+1)+'hi'+IntToStr(j)+'='+FloatToStr(hi[j])+' ';
                f.Add(s);
                //s:=s+FloatToStr(xi[j])+' ';
                s:='body'+IntToStr(i+1)+'xi'+IntToStr(j)+'='+FloatToStr(xi[j])+' ';
                f.Add(s);
               // s:=s+FloatToStr(yi[j])+' ';
                s:='body'+IntToStr(i+1)+'yi'+IntToStr(j)+'='+FloatToStr(yi[j])+' ';
                f.Add(s);
                //s:=s+FloatToStr(zi[j])+' ';
                s:='body'+IntToStr(i+1)+'zi'+IntToStr(j)+'='+FloatToStr(zi[j])+' ';
                f.Add(s);
             end;

             // emissivity :
            if (abs(FormVariables.my_real_convert(semissW,bOk))<1.0e-12) then
            begin
               body[i].emissW:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[i].semissW:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[i].semissW:='0.001';
                end;
            end;
           // s:=s+FloatToStr(emissW)+' ';
              //s:=s+FloatToStr(FormVariables.my_real_convert(semissW,bOk))+' ';
              s:='body'+IntToStr(i+1)+'emissW='+FloatToStr(FormVariables.my_real_convert(semissW,bOk))+' ';
            f.Add(s);
            if (abs(FormVariables.my_real_convert(semissE,bOk))<1.0e-12) then
            begin
               body[i].emissE:=0.001;
                if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[i].semissE:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[i].semissE:='0.001';
                end;
            end;
           // s:=s+FloatToStr(emissE)+' ';
            //s:=s+FloatToStr(FormVariables.my_real_convert(semissE,bOk))+' ';
            s:='body'+IntToStr(i+1)+'emissE='+FloatToStr(FormVariables.my_real_convert(semissE,bOk))+' ';
            f.Add(s);
            if (abs(FormVariables.my_real_convert(semissS,bOk))<1.0e-12) then
            begin
               body[i].emissS:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[i].semissS:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[i].semissS:='0.001';
                end;
            end;
            //s:=s+FloatToStr(emissS)+' ';
            // s:=s+FloatToStr(FormVariables.my_real_convert(semissS,bOk))+' ';
             s:='body'+IntToStr(i+1)+'emissS='+ FloatToStr(FormVariables.my_real_convert(semissS,bOk))+' ';
            f.Add(s);
            if (abs(FormVariables.my_real_convert(semissN,bOk))<1.0e-12) then
            begin
               body[i].emissN:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[i].semissN:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[i].semissN:='0.001';
                end;
            end;
            //s:=s+FloatToStr(emissN)+' ';
             //s:=s+FloatToStr(FormVariables.my_real_convert(semissN,bOk))+' ';
             s:='body'+IntToStr(i+1)+'emissN='+ FloatToStr(FormVariables.my_real_convert(semissN,bOk))+' ';
            f.Add(s);
             if (abs(FormVariables.my_real_convert(semissB,bOk))<1.0e-12) then
            begin
               body[i].emissB:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[i].semissB:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[i].semissB:='0.001';
                end;
            end;
           // s:=s+FloatToStr(emissB)+' ';
            // s:=s+FloatToStr(FormVariables.my_real_convert(semissB,bOk))+' ';
             s:='body'+IntToStr(i+1)+'emissB='+FloatToStr(FormVariables.my_real_convert(semissB,bOk))+' ';
             f.Add(s);
             if (abs(FormVariables.my_real_convert(semissT,bOk))<1.0e-12) then
            begin
               body[i].emissT:=0.001;
               if (FormatSettings.DecimalSeparator=',') then
                begin
                   body[i].semissT:='0,001';
                end;
                if (FormatSettings.DecimalSeparator='.') then
                begin
                   body[i].semissT:='0.001';
                end;
            end;
            //s:=s+FloatToStr(emissT)+' ';
            //s:=s+FloatToStr(FormVariables.my_real_convert(semissT,bOk))+' ';
            s:='body'+IntToStr(i+1)+'emissT='+FloatToStr(FormVariables.my_real_convert(semissT,bOk))+' ';
            f.Add(s);
            // для emissivity мы задаём не ноль а малое положительное число,
            // т.к. с нулём может возникнуть деление на ноль в программе.
            // s:=s+IntToStr(binternalRadiation)+' ';
            s:='body'+IntToStr(i+1)+'binternalRadiation='+IntToStr(binternalRadiation)+' ';
            f.Add(s);

            //s:=s+IntToStr(imatid)+' ';
            s:='body'+IntToStr(i+1)+'imatid='+IntToStr(imatid)+' ';
            f.Add(s);
             // Фиксация боковой стенки Цилидра.
            if (body[i].CylinderFixed) then
            begin
               s:='1 ';  // Фиксируем.
            end
              else
            begin
               s:='0 ';  // Free.
            end;
            s:='body'+IntToStr(i+1)+'bCylinderFixed=' + s+' # 1 - FIXIT, 0 - FREE.';
            f.Add(s);
            // Внимание ! нужно брать именно модуль разности координат,
            // т.к. в теории может быть нарушен порядок следования, например
            // xE может быть меньше xS что в конечном счёте может привести к смене
            // знака у мощности тепловыделения и к отрицательным температурам при
            // при положительной реальной мощности.
            // исправление от 23 сентября 2015 года.
            //Sc:=power/(abs(xE-xS)*abs(yE-yS)*abs(zE-zS)*mlength*mlength*mlength);
            //s:=s+FloatToStr(Sc)+' '; // мощность тепловыделения блока на единицу объёма
            // 20_11_2016.
            //s:=s+IntToStr(body[i].n_power)+' ';
             s:='body'+IntToStr(i+1)+'n_power='+ IntToStr(body[i].n_power)+' ';
            f.Add(s);
            for i_4 := 0 to body[i].n_power-1 do
            begin
               if (body[i].igeometry_type=0) then
               begin
                  // Прямоугольная призма.
                  //s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(body[i].arr_power[i_4]/(abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS)*mlength*mlength*mlength))+' ';
                  s:='body'+IntToStr(i+1)+'temp_power'+IntToStr(i_4)+'='+FloatToStr(body[i].temp_power[i_4])+' ';
               f.Add(s);
                  s:='body'+IntToStr(i+1)+'arr_power'+IntToStr(i_4)+'='+ FloatToStr(body[i].arr_power[i_4]/(abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS)*mlength*mlength*mlength))+' ';
               f.Add(s);
               end;
               if (body[i].igeometry_type=1) then
               begin
                  // Cylinder
                  if (abs(body[i].angle_end-body[i].angle_start)<0.5) then
                  begin
                      body[i].angle_end:=360.0;
                  end;
                 //s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(body[i].arr_power[i_4]/(((abs(body[i].angle_end-body[i].angle_start))/360.0)*body[i].Hcyl*3.141*(body[i].R_out_cyl*body[i].R_out_cyl-body[i].R_in_cyl*body[i].R_in_cyl)*mlength*mlength*mlength))+' ';
                  s:='body'+IntToStr(i+1)+'temp_power'+IntToStr(i_4)+'='+FloatToStr(body[i].temp_power[i_4])+' ';
                  f.Add(s);
                  s:='body'+IntToStr(i+1)+'arr_power'+IntToStr(i_4)+'='+ FloatToStr(body[i].arr_power[i_4]/(((abs(body[i].angle_end-body[i].angle_start))/360.0)*body[i].Hcyl*3.141*(body[i].R_out_cyl*body[i].R_out_cyl-body[i].R_in_cyl*body[i].R_in_cyl)*mlength*mlength*mlength))+' ';
                  f.Add(s);
               end;
               if (body[i].igeometry_type=2) then
               begin
                  // Polygon
                   begin
                      // Polygon
                      // Для полигона мы передаём значение температуры при которой задана тепловая мощность и значение
                      // тепловой мощности в Вт.
                      //s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(body[i].arr_power[i_4])+' ';
                      // 26.01.2018.
                      // Для полигона мы всегда задаём нулевое значение тепловой мощности.
                      // Главная причина. Я не умею правильно вычислять объём полигона в интерфейсе.
                      //s:=s+FloatToStr(body[i].temp_power[i_4])+' 0.0 ';
                      s:='body'+IntToStr(i+1)+'temp_power'+IntToStr(i_4)+'='+FloatToStr(body[i].temp_power[i_4])+' ';
                      f.Add(s);
                      // Для полигона передаётся значение тепловой мощности в Вт.
                      s:= FloatToStr(body[i].arr_power[i_4]);
                      s:='body'+IntToStr(i+1)+'arr_power'+IntToStr(i_4)+'='+s+' ';
                      f.Add(s);
                         (*
                         // работает только для треугольника
                         // и только для всюду одинаковых высот.
                         if (body[i_4].nsizei<3) then
                         begin
                            ShowMessage('Polygon error: power nsizei<3');
                         end;
                         if (body[i_4].nsizei=3) then
                         begin
                            case body[i_4].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i_4].hi[0]))*((body[i_4].xi[1]-body[i_4].xi[0])*(body[i_4].yi[2]-body[i_4].yi[0])-(body[i_4].yi[1]-body[i_4].yi[0])*(body[i_4].xi[2]-body[i_4].xi[0]))))+' ';
                                   end;
                               2: begin
                                     // XZ
                                     s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i_4].hi[0]))*((body[i_4].xi[1]-body[i_4].xi[0])*(body[i_4].zi[2]-body[i_4].zi[0])-(body[i_4].zi[1]-body[i_4].zi[0])*(body[i_4].xi[2]-body[i_4].xi[0]))))+' ';
                                  end;
                               3 : begin
                                      // YZ
                                      s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr((mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i_4].hi[0]))*((body[i_4].yi[1]-body[i_4].yi[0])*(body[i_4].zi[2]-body[i_4].zi[0])-(body[i_4].zi[1]-body[i_4].zi[0])*(body[i_4].yi[2]-body[i_4].yi[0]))))+' ';
                                   end;
                            end;
                         end;
                         if (body[i_4].nsizei>3) then
                         begin
                            //   Только выпуклый полигон, его площадь аппроксимирована
                            // суммой площадей составляющих его треугольников.
                            // Центр масс.
                            xavg:=0.0;
                            yavg:=0.0;
                            zavg:=0.0;
                            for j := 0 to body[i_4].nsizei-1 do
                            begin
                               xavg:=xavg+body[i_4].xi[j];
                               yavg:=yavg+body[i_4].yi[j];
                               zavg:=zavg+body[i_4].zi[j];
                            end;
                            xavg:=xavg/body[i_4].nsizei;
                            yavg:=yavg/body[i_4].nsizei;
                            zavg:=zavg/body[i_4].nsizei;


                            powertri:=0.0;
                            for j := 0 to body[i_4].nsizei-2 do
                            begin
                              case body[i_4].iPlane_obj2 of
                               1 : begin
                                      // XY
                                      powertri:=(mlength*mlength*mlength*powertri+body[i].arr_power[i_4])/((abs(body[i_4].hi[0]))*(body[i_4].nsizei-1)*((body[i_4].xi[j]-xavg)*(body[i_4].yi[j+1]-yavg)-(body[i_4].yi[j]-yavg)*(body[i_4].xi[j+1]-xavg)));
                                   end;
                               2: begin
                                     // XZ
                                     powertri:=powertri+(mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i_4].hi[0]))*(body[i_4].nsizei-1)*((body[i_4].xi[j]-xavg)*(body[i_4].zi[j+1]-zavg)-(body[i_4].zi[j]-zavg)*(body[i_4].xi[j+1]-xavg)));
                                  end;
                               3 : begin
                                     // YZ
                                     powertri:=powertri+(mlength*mlength*mlength*body[i].arr_power[i_4])/((abs(body[i_4].hi[0]))*(body[i_4].nsizei-1)*((body[i_4].yi[j]-yavg)*(body[i_4].zi[j+1]-zavg)-(body[i_4].zi[j]-zavg)*(body[i_4].yi[j+1]-yavg)));
                                   end;
                               end;
                            end;
                              s:=s+FloatToStr(body[i].temp_power[i_4])+' '+FloatToStr(powertri)+' ';
                            end;
                            *)
                    end;
               end;
            end;
            //s:=s+IntToStr(ipower_time_depend)+' '; // зависимость мощности тепловыделения в блоке от времени.
            s:='body'+IntToStr(i+1)+'ipower_time_depend='+IntToStr(ipower_time_depend)+' ';
            f.Add(s);
            if (checkFLUIDtoSOLID) then
            begin
                if (itype=3) then
                begin
                   s:='2 '; // FLUID to SOLID
                end;
            end
            else
            begin
              s:=IntToStr(itype)+' '; // тип блока : 1 - SOLID, 2 - HOLLOW, 3 - FLUID.
            end;
            s:='body'+IntToStr(i+1)+'itype='+s+' # 1 - SOLID, 2 - HOLLOW, 3 - FLUID';
            f.Add(s);
         end;
      end;
   end;


   s:='################################################################';
   f.Add(s);
   s:='# Sources properties for this project configuration setting: #';
   f.Add(s);
   s:='################################################################';
   f.Add(s);

   // цикл по всем источникам тепла:
   for i:=0 to (ls-1) do
   begin
      with (source[i]) do
      begin
          s:='source'+IntToStr(i)+'name='+name+' ';
          f.Add(s);

         // Принадлежность union (Асемблесу).
            for i3 := 0 to (lu-1) do
            begin
               if (myassembles[i3].identifire=iunion)then
               begin
                  if (myassembles[i3].bmesh_assembles_separately) then
                  begin
                     bf7:=true;
                  end;
               end;
            end;
            if (bf7) then
            begin
               s:=IntToStr(iunion)+' ';
            end
             else
            begin
               s:='0 ';
            end;
            s:='source'+IntToStr(i)+'iunion='+s;
            f.Add(s);

         // мощность тепловыделения, плоскость и координаты:
         // Для холодных режимов "АППАРАТА" мощность тепловыделения
         // в плоских бесконечно-тонких источниках тепла должна отсутствовать.
         // Поэтому только в этом случае для простоты использования мы зануляем
         // мощность.
         //s:=FloatToStr(0.0)+' '; // only for холодные режимы АППАРАТ. 27_10_2016.
         //s:=s+FloatToStr(Power)+' ';  // мощность
         s:='source'+IntToStr(i)+'Power='+FloatToStr(Power)+' # W';  // мощность
         f.Add(s);
        // s:=s+IntToStr(itempdep)+' '; // зависит ли мощность от температуры
         s:='source'+IntToStr(i)+'itempdep='+ IntToStr(itempdep)+' '; // зависит ли мощность от температуры
         f.Add(s);
         //s:=s+IntToStr(id_table)+' '; // уникальный идентификатор таблицы.
         s:='source'+IntToStr(i)+'id_table='+IntToStr(id_table)+' # not usage'; // уникальный идентификатор таблицы.
         f.Add(s);
         //s:=s+FloatToStr(operatingoffsetdrain)+' '; // смещение стока
         s:='source'+IntToStr(i)+'operatingoffsetdrain='+FloatToStr(operatingoffsetdrain)+' # not usage'; // смещение стока
         f.Add(s);
         //s:=s+IntToStr(iPlane)+' '; // плоскость в которой лежит источник тепла
         s:='source'+IntToStr(i)+'iPlane='+IntToStr(iPlane)+' # 1 - XY; 2 - XZ; 3 - YZ;'; // плоскость в которой лежит источник тепла
         f.Add(s);
         //s:=s+FloatToStr(xS)+' ';
         s:='source'+IntToStr(i)+'xS='+FloatToStr(xS)+' ';
         f.Add(s);
         //s:=s+FloatToStr(yS)+' ';
         s:='source'+IntToStr(i)+'yS='+FloatToStr(yS)+' ';
         f.Add(s);
         //s:=s+FloatToStr(zS)+' ';
         s:='source'+IntToStr(i)+'zS='+FloatToStr(zS)+' ';
         f.Add(s);
         //s:=s+FloatToStr(xE)+' ';
         s:='source'+IntToStr(i)+'xE='+FloatToStr(xE)+' ';
         f.Add(s);
         //s:=s+FloatToStr(yE)+' ';
         s:='source'+IntToStr(i)+'yE='+FloatToStr(yE)+' ';
         f.Add(s);
         //s:=s+FloatToStr(zE);
         s:='source'+IntToStr(i)+'zE='+FloatToStr(zE)+' ';
         f.Add(s);
      end;
   end;

   s:='#############################################################';
   f.Add(s);
   s:='# Walls properties for this project configuration setting:  #';
   f.Add(s);
   s:='#############################################################';
   f.Add(s);

   // цикл по всем твёрдым стенкам:
   if (body[0].itype=2) then
   begin
      // HOLLOW
      for i:=0 to (lw-1) do
       begin

          bOk:=true;
          wall[i].heat_transfer_coefficient:= FormVariables.my_real_convert(wall[i].sheat_transfer_coefficient,bOk);
          bOk:=true;
          wall[i].emissivity:= FormVariables.my_real_convert(wall[i].semissivity,bOk);

          with (wall[i]) do
          begin
              // Поскольку кабинета нету то нет и стенок геометрические
              // размеры которых жёстко связаны с размером кабинета.
              if (cabinet_depend=0) then
              begin

                s:='wall'+IntToStr(i)+'name='+name+' ';
                 f.Add(s);

                  // Принадлежность union (Асемблесу).
                  for i3 := 0 to (lu-1) do
                  begin
                     if (myassembles[i3].identifire=iunion)then
                     begin
                        if (myassembles[i3].bmesh_assembles_separately) then
                        begin
                           bf7:=true;
                        end;
                     end;
                 end;
                 if (bf7) then
                 begin
                    s:=IntToStr(iunion)+' ';
                 end
                   else
                 begin
                    s:='0 ';
                 end;


                 s:='wall'+IntToStr(i)+'iunion='+s;
                 f.Add(s);

                 // тип краевого условия, температура и тепловой поток,
                 //  плоскость и координаты:
                 //s:=s+IntToStr(family)+' '; // тип краевого условия
                 s:='# 1 - Dirichlet boundary condition.';
                 f.Add(s);
                 s:='# 2 - Homogenius Neiman boundary condition.';
                 f.Add(s);
                 s:='# 3 - Newton Richman boundary condition.';
                 f.Add(s);
                 s:='# 4 - Stefan Bolcman boundary condition.';
                 f.Add(s);
                 s:='wall'+IntToStr(i)+'family='+IntToStr(family)+' ';
                 f.Add(s);
                 //s:=s+FloatToStr(Tamb)+' '; // температура на идеальном теплооотводе
                 s:='wall'+IntToStr(i)+'Tamb='+FloatToStr(Tamb)+' ';
                 f.Add(s);
                 if (family=3) then
                 begin
                    s:=FloatToStr(heat_transfer_coefficient)+' '; // коэффициент теплоотдачи.
                 end
                  else
                 begin
                    // 1,2,4
                     s:=FloatToStr(emissivity)+' '; // излучательная способность
                 end;
                 s:='wall'+IntToStr(i)+'heat_transfer_coefficient_vs_emissivity='+s;
                 f.Add(s);
                // s:=s+FloatToStr(HF)+' '; // для граничного условия 2 или 3 рода.
                 s:='wall'+IntToStr(i)+'ViewFactor='+FloatToStr(ViewFactor)+' ';
                 f.Add(s);
                 s:='wall'+IntToStr(i)+'HF='+ FloatToStr(HF)+' ';
                 f.Add(s);
                 if (bsymmetry) then s:='1 ' else s:='0 ';
                 s:='wall'+IntToStr(i)+'bsymmetry='+s;
                 f.Add(s);
                 if (bpressure) then s:='1 ' else s:='0 ';
                 s:='wall'+IntToStr(i)+'bpressure='+s;
                 f.Add(s);
                 if (bopening) then s:='1 ' else s:='0 ';
                 s:='wall'+IntToStr(i)+'bopening='+s;
                 f.Add(s);

                 //s:=s+FloatToStr(Vx)+' ';
                  s:='wall'+IntToStr(i)+'Vx='+FloatToStr(Vx)+' ';
                 f.Add(s);
                 //s:=s+FloatToStr(Vy)+' ';
                  s:='wall'+IntToStr(i)+'Vy='+FloatToStr(Vy)+' ';
                 f.Add(s);
                 //s:=s+FloatToStr(Vz)+' ';
                  s:='wall'+IntToStr(i)+'Vz='+FloatToStr(Vz)+' ';
                 f.Add(s);
                 //s:=s+FloatToStr(P)+' ';
                  s:='wall'+IntToStr(i)+'P='+FloatToStr(P)+' ';
                 f.Add(s);
                // s:=s+IntToStr(ithermal_stress_boundary_condition)+' '; // Thermal-Stress.
                  s:='wall'+IntToStr(i)+'ithermal_stress_boundary_condition='+ IntToStr(ithermal_stress_boundary_condition)+' ';
                 f.Add(s);
                 //s:=s+FloatToStr(xForce)+' ';
                  s:='wall'+IntToStr(i)+'xForce='+FloatToStr(xForce)+' ';
                 f.Add(s);
                 //s:=s+FloatToStr(yForce)+' ';
                  s:='wall'+IntToStr(i)+'yForce='+FloatToStr(yForce)+' ';
                 f.Add(s);
                 //s:=s+FloatToStr(zForce)+' ';
                  s:='wall'+IntToStr(i)+'zForce='+FloatToStr(zForce)+' ';
                 f.Add(s);
                 //s:=s+IntToStr(iPlane)+' '; // плоскость в которой лежит источник тепла
                  s:='wall'+IntToStr(i)+'iPlane='+ IntToStr(iPlane)+' # 1 - XY; 2 - XZ; 3 - YZ;';
                 f.Add(s);
                 //s:=s+FloatToStr(xS)+' ';
                  s:='wall'+IntToStr(i)+'xS='+FloatToStr(xS)+' ';
                 f.Add(s);
                 //s:=s+FloatToStr(yS)+' ';
                  s:='wall'+IntToStr(i)+'yS='+FloatToStr(yS)+' ';
                 f.Add(s);
                 //s:=s+FloatToStr(zS)+' ';
                  s:='wall'+IntToStr(i)+'zS='+FloatToStr(zS)+' ';
                 f.Add(s);
                // s:=s+FloatToStr(xE)+' ';
                  s:='wall'+IntToStr(i)+'xE='+ FloatToStr(xE)+' ';
                 f.Add(s);
                // s:=s+FloatToStr(yE)+' ';
                  s:='wall'+IntToStr(i)+'yE='+ FloatToStr(yE)+' ';
                 f.Add(s);
                 //s:=s+FloatToStr(zE);
                  s:='wall'+IntToStr(i)+'zE='+FloatToStr(zE)+' ';
                 f.Add(s);
                 if ((family=1)or(family=3)or(family=4)) then
                 begin
                    // 1 изотермическая стенка идеальный теплоотвод.
                    // 3 Newton-Richman,
                    // 4 Stefan Bolcman.
                    bmodelcheck:=true;
                 end;
              end;

          end;
       end;
   end
   else
   if (body[0].itype=3) then
   begin
       // Fluid.
       for i:=0 to (lw-1) do
       begin

          bOk:=true;
          wall[i].heat_transfer_coefficient:= FormVariables.my_real_convert(wall[i].sheat_transfer_coefficient,bOk);
          bOk:=true;
          wall[i].emissivity:= FormVariables.my_real_convert(wall[i].semissivity,bOk);

          with (wall[i]) do
          begin

              s:='wall'+IntToStr(i)+'name='+name+' ';
                 f.Add(s);

             // Принадлежность union (Асемблесу).
                  for i3 := 0 to (lu-1) do
                  begin
                     if (myassembles[i3].identifire=iunion)then
                     begin
                        if (myassembles[i3].bmesh_assembles_separately) then
                        begin
                           bf7:=true;
                        end;
                     end;
                 end;
                 if (bf7) then
                 begin
                    s:=IntToStr(iunion)+' ';
                 end
                   else
                 begin
                    s:='0 ';
                 end;
                 s:='wall'+IntToStr(i)+'iunion='+s;
                 f.Add(s);
             // тип краевого условия, температура и тепловой поток,
             //  плоскость и координаты:
             //s:=s+IntToStr(family)+' '; // тип краевого условия
              s:='# 1 - Dirichlet boundary condition.';
              f.Add(s);
              s:='# 2 - Homogenius Neiman boundary condition.';
              f.Add(s);
              s:='# 3 - Newton-Richman boundary condition.';
              f.Add(s);
              s:='# 4 - Stefan-Bolcman boundary condition.';
              f.Add(s);
             s:='wall'+IntToStr(i)+'family='+IntToStr(family)+' ';
             f.Add(s);
             //s:=s+FloatToStr(Tamb)+' '; // температура на идеальном теплооотводе
             s:='wall'+IntToStr(i)+'Tamb='+FloatToStr(Tamb)+' ';
             f.Add(s);
             if (family=3) then
             begin
                s:=FloatToStr(heat_transfer_coefficient)+' '; // коэффициент теплоотдачи.
             end
              else
             begin
                // 1,2,4
                s:=FloatToStr(emissivity)+' '; // излучательная способность
             end;
             s:='wall'+IntToStr(i)+'heat_transfer_coefficient_vs_emissivity='+s;
             f.Add(s);
             //s:=s+FloatToStr(HF)+' '; // для граничного условия 2 или 3 рода.
             s:='wall'+IntTostr(i)+'ViewFactor='+FloatToStr(ViewFactor)+' '; // Фактор видимости.
             f.Add(s);
             s:='wall'+IntToStr(i)+'HF='+FloatToStr(HF)+' ';
             f.Add(s);
             if (bsymmetry) then s:='1 ' else s:='0 ';
             s:='wall'+IntToStr(i)+'bsymmetry='+s;
             f.Add(s);
             if (bpressure) then s:='1 ' else s:='0 ';
             s:='wall'+IntToStr(i)+'bpressure='+s;
             f.Add(s);
             if (bopening) then s:='1 ' else s:='0 ';
             s:='wall'+IntToStr(i)+'bopening='+s;
             f.Add(s);

             //s:=s+FloatToStr(Vx)+' ';
             s:='wall'+IntToStr(i)+'Vx='+FloatToStr(Vx)+' ';
             f.Add(s);
             //s:=s+FloatToStr(Vy)+' ';
             s:='wall'+IntToStr(i)+'Vy='+FloatToStr(Vy)+' ';
             f.Add(s);
             //s:=s+FloatToStr(Vz)+' ';
             s:='wall'+IntToStr(i)+'Vz='+FloatToStr(Vz)+' ';
             f.Add(s);
             //s:=s+FloatToStr(P)+' ';
             s:='wall'+IntToStr(i)+'P='+FloatToStr(P)+' ';
             f.Add(s);
             //s:=s+IntToStr(ithermal_stress_boundary_condition)+' '; // Thermal-Stress.
             s:='wall'+IntToStr(i)+'ithermal_stress_boundary_condition='+IntToStr(ithermal_stress_boundary_condition)+' ';
             f.Add(s);
             //s:=s+FloatToStr(xForce)+' ';
             s:='wall'+IntToStr(i)+'xForce='+FloatToStr(xForce)+' ';
             f.Add(s);
             //s:=s+FloatToStr(yForce)+' ';
             s:='wall'+IntToStr(i)+'yForce='+FloatToStr(yForce)+' ';
             f.Add(s);
             //s:=s+FloatToStr(zForce)+' ';
             s:='wall'+IntToStr(i)+'zForce='+FloatToStr(zForce)+' ';
             f.Add(s);
             //s:=s+IntToStr(iPlane)+' '; // плоскость в которой лежит источник тепла
             s:='wall'+IntToStr(i)+'iPlane='+IntToStr(iPlane)+' # 1 - XY; 2 - XZ; 3 - YZ;';
             f.Add(s);
             //s:=s+FloatToStr(xS)+' ';
              s:='wall'+IntToStr(i)+'xS='+FloatToStr(xS)+' ';
             f.Add(s);
             //s:=s+FloatToStr(yS)+' ';
              s:='wall'+IntToStr(i)+'yS='+FloatToStr(yS)+' ';
             f.Add(s);
             //s:=s+FloatToStr(zS)+' ';
              s:='wall'+IntToStr(i)+'zS='+FloatToStr(zS)+' ';
             f.Add(s);
            // s:=s+FloatToStr(xE)+' ';
              s:='wall'+IntToStr(i)+'xE='+FloatToStr(xE)+' ';
             f.Add(s);
             //s:=s+FloatToStr(yE)+' ';
              s:='wall'+IntToStr(i)+'yE='+FloatToStr(yE)+' ';
             f.Add(s);
             //s:=s+FloatToStr(zE)+' ';
              s:='wall'+IntToStr(i)+'zE='+FloatToStr(zE)+' ';
             f.Add(s);
             if ((family=1)or(family=3)or(family=4)) then
             begin
                // 1 изотермическая стенка идеальный теплоотвод.
                // 3 Newton-Richman,
                // 4 Stefan Bolcman.
                bmodelcheck:=true;
             end;
          end;
       end;
   end;

   s:='#################################################################';
   f.Add(s);
   s:='# Assembles properties for this project configuration setting:  #';
   f.Add(s);
   s:='#################################################################';
   f.Add(s);

   // Пишем информацию об асемблесе.
   iu_number:=0; // Счётчик активных асемблесов.
   for i := 0 to (lu-1) do
   begin
      if (Laplas.myassembles[i].bmesh_assembles_separately) then
      begin
         inc(iu_number);
      end;
   end;
   s:=IntToStr(iu_number)+' ';
   s:='iu_number='+s;
   f.Add(s);
   iu_number:=0; // Счётчик активных асемблесов.
   for i := 0 to (lu-1) do
   begin
       if (Laplas.myassembles[i].bmesh_assembles_separately) then
       begin
         inc(iu_number);
         xSass:=1.0e30;
         ySass:=1.0e30;
         zSass:=1.0e30;
         xEass:=-1.0e30;
         yEass:=-1.0e30;
         zEass:=-1.0e30;
         for i5 := 1 to (lb-1) do
         begin
            if (body[i5].iunion=Laplas.myassembles[i].identifire) then
            begin
               if (body[i5].igeometry_type=0) then
               begin
                  // Прямая прямоугольная призма.
                  if (body[i5].xS<xSass) then
                  begin
                     xSass:= body[i5].xS;
                  end;
                  if (body[i5].yS<ySass) then
                  begin
                     ySass:= body[i5].yS;
                  end;
                  if (body[i5].zS<zSass) then
                  begin
                     zSass:= body[i5].zS;
                  end;
                  if (body[i5].xE>xEass) then
                  begin
                     xEass:= body[i5].xE;
                  end;
                  if (body[i5].yE>yEass) then
                  begin
                     yEass:= body[i5].yE;
                  end;
                  if (body[i5].zE>zEass) then
                  begin
                     zEass:= body[i5].zE;
                  end;
               end;
               if (body[i5].igeometry_type=1) then
               begin
                  // Цилиндр
                  case body[i5].iPlane of
                      1 : begin
                             // XY
                             if (body[i5].xC-body[i5].R_out_cyl<xSass) then
                             begin
                                xSass:= body[i5].xC-body[i5].R_out_cyl;
                             end;
                             if (body[i5].xC+body[i5].R_out_cyl>xEass) then
                             begin
                                xEass:= body[i5].xC+body[i5].R_out_cyl;
                             end;
                             if (body[i5].yC-body[i5].R_out_cyl<ySass) then
                             begin
                                ySass:= body[i5].yC-body[i5].R_out_cyl;
                             end;
                             if (body[i5].yC+body[i5].R_out_cyl>yEass) then
                             begin
                                yEass:= body[i5].yC+body[i5].R_out_cyl;
                             end;
                              // h хвост.
                             if (body[i5].zC<zSass) then
                             begin
                                zSass:= body[i5].zC;
                             end;
                             if (body[i5].zC+body[i5].Hcyl>zEass) then
                             begin
                                zEass:= body[i5].zC+body[i5].Hcyl;
                             end;
                          end;
                      2: begin
                            // XZ
                             if (body[i5].xC-body[i5].R_out_cyl<xSass) then
                             begin
                                xSass:= body[i5].xC-body[i5].R_out_cyl;
                             end;
                             if (body[i5].xC+body[i5].R_out_cyl>xEass) then
                             begin
                                xEass:= body[i5].xC+body[i5].R_out_cyl;
                             end;
                             if (body[i5].zC-body[i5].R_out_cyl<zSass) then
                             begin
                                zSass:= body[i5].zC-body[i5].R_out_cyl;
                             end;
                              if (body[i5].zC+body[i5].R_out_cyl>zEass) then
                             begin
                                zEass:= body[i5].zC+body[i5].R_out_cyl;
                             end;
                              // h хвост.
                             if (body[i5].yC<ySass) then
                             begin
                                ySass:= body[i5].yC;
                             end;
                             if (body[i5].yC+body[i5].Hcyl>yEass) then
                             begin
                                yEass:= body[i5].yC+body[i5].Hcyl;
                             end;
                         end;
                      3 : begin
                             // YZ
                             if (body[i5].yC-body[i5].R_out_cyl<ySass) then
                             begin
                                ySass:= body[i5].yC-body[i5].R_out_cyl;
                             end;
                             if (body[i5].yC+body[i5].R_out_cyl>yEass) then
                             begin
                                yEass:= body[i5].yC+body[i5].R_out_cyl;
                             end;
                             if (body[i5].zC-body[i5].R_out_cyl<zSass) then
                             begin
                                zSass:= body[i5].zC-body[i5].R_out_cyl;
                             end;
                             if (body[i5].zC+body[i5].R_out_cyl>zEass) then
                             begin
                                zEass:= body[i5].zC+body[i5].R_out_cyl;
                             end;
                             // h хвост.
                             if (body[i5].zC<zSass) then
                             begin
                                zSass:= body[i5].zC;
                             end;
                             if (body[i5].zC+body[i5].Hcyl>zEass) then
                             begin
                                zEass:= body[i5].zC+body[i5].Hcyl;
                             end;
                         end;
                  end;
               end;
                if (body[i5].igeometry_type=2) then
               begin
                  // Полигон
                   for j := 0 to body[i5].nsizei-1 do
                   begin
                      case body[i5].iPlane_obj2 of
                      1 : begin
                             // XY
                             if (body[i5].xi[j]<xSass) then
                             begin
                                xSass:= body[i5].xi[j];
                             end;
                             if (body[i5].xi[j]>xEass) then
                             begin
                                xEass:= body[i5].xi[j];
                             end;
                             if (body[i5].yi[j]<ySass) then
                             begin
                                ySass:= body[i5].yi[j];
                             end;
                              if (body[i5].yi[j]>yEass) then
                             begin
                                yEass:= body[i5].yi[j];
                             end;
                             // h хвост.
                              if (body[i5].zi[j]<zSass) then
                             begin
                                zSass:= body[i5].zi[j];
                             end;
                              if (body[i5].zi[j]+body[i5].hi[j]>zEass) then
                             begin
                                zEass:= body[i5].zi[j]+body[i5].hi[j];
                             end;
                           end;
                      2: begin
                            // XZ
                            if (body[i5].xi[j]<xSass) then
                             begin
                                xSass:= body[i5].xi[j];
                             end;
                             if (body[i5].xi[j]>xEass) then
                             begin
                                xEass:= body[i5].xi[j];
                             end;
                             if (body[i5].zi[j]<zSass) then
                             begin
                                zSass:= body[i5].zi[j];
                             end;
                              if (body[i5].zi[j]>zEass) then
                             begin
                                zEass:= body[i5].zi[j];
                             end;
                              // h хвост.
                              if (body[i5].yi[j]<ySass) then
                             begin
                                ySass:= body[i5].yi[j];
                             end;
                              if (body[i5].yi[j]+body[i5].hi[j]>yEass) then
                             begin
                                yEass:= body[i5].yi[j]+body[i5].hi[j];
                             end;
                         end;
                      3 : begin
                             // YZ
                             if (body[i5].yi[j]<ySass) then
                             begin
                                ySass:= body[i5].yi[j];
                             end;
                             if (body[i5].yi[j]>yEass) then
                             begin
                                yEass:= body[i5].yi[j];
                             end;
                             if (body[i5].zi[j]<zSass) then
                             begin
                                zSass:= body[i5].zi[j];
                             end;
                              if (body[i5].zi[j]>zEass) then
                             begin
                                zEass:= body[i5].zi[j];
                             end;
                               // h хвост.
                              if (body[i5].xi[j]<xSass) then
                             begin
                                xSass:= body[i5].xi[j];
                             end;
                              if (body[i5].xi[j]+body[i5].hi[j]>xEass) then
                             begin
                                xEass:= body[i5].xi[j]+body[i5].hi[j];
                             end;
                          end;
                      end;
                   end;

               end;
            end;
         end;

         s:=FloatToStr(xSass-Laplas.myassembles[i].xmin)+' ';
         s:='assembles'+IntToStr(i)+'xS='+s;
         f.Add(s);
         s:=FloatToStr(xEass+Laplas.myassembles[i].xmax)+' ';
         s:='assembles'+IntToStr(i)+'xE='+s;
         f.Add(s);
         s:=FloatToStr(ySass-Laplas.myassembles[i].ymin)+' ';
         s:='assembles'+IntToStr(i)+'yS='+s;
         f.Add(s);
         s:=FloatToStr(yEass+Laplas.myassembles[i].ymax)+' ';
         s:='assembles'+IntToStr(i)+'yE='+s;
         f.Add(s);
         s:=FloatToStr(zSass-Laplas.myassembles[i].zmin)+' ';
         s:='assembles'+IntToStr(i)+'zS='+s;
         f.Add(s);
         s:=FloatToStr(zEass+Laplas.myassembles[i].zmax)+' ';
         s:='assembles'+IntToStr(i)+'zE='+s;
         f.Add(s);
         s:=IntToStr(Laplas.myassembles[i].identifire)+' ';
         s:='assembles'+IntToStr(i)+'identifire='+s;
         f.Add(s);
         s:=IntToStr(Laplas.myassembles[i].inxloc)+' ';
         s:='assembles'+IntToStr(i)+'inx='+s;
         f.Add(s);
         s:=IntToStr(Laplas.myassembles[i].inyloc)+' ';
         s:='assembles'+IntToStr(i)+'iny='+s;
         f.Add(s);
         s:=IntToStr(Laplas.myassembles[i].inzloc)+' ';
         s:='assembles'+IntToStr(i)+'inz='+s;
         f.Add(s);
      end;
   end;

   s:='#################################################################';
   f.Add(s);
   s:='# Equation properties for this project configuration setting:  #';
   f.Add(s);
   s:='#################################################################';
   f.Add(s);

   // Запись информации о решаемых уравнениях.
   s:=IntToStr(egddata.itemper)+' ';
   s:='egddata_itemper='+s+'# 0 - none, 1 - Finite Volume Method, 2 - Finite Element Method, 3 - Network Method.';
   f.Add(s);
   s:=IntToStr(egddata.imaxflD)+' ';
   s:='egddata_imaxflD='+s;
   f.Add(s);
   for i:=0 to egddata.imaxflD-1 do
   begin
      s:=FloatToStr(egddata.myflmod[i].xc)+' ';
      s:='egddata'+IntToStr(i)+'xc='+s;
      f.Add(s);
      s:=FloatToStr(egddata.myflmod[i].yc)+' ';
       s:='egddata'+IntToStr(i)+'yc='+s;
      f.Add(s);
      s:=FloatToStr(egddata.myflmod[i].zc)+' ';
       s:='egddata'+IntToStr(i)+'zc='+s;
      f.Add(s);
      s:=IntToStr(egddata.myflmod[i].iflow)+' ';
       s:='egddata'+IntToStr(i)+'iflow='+s;
      f.Add(s);
      s:=IntToStr(egddata.myflmod[i].iflowregime)+' ';
       s:='egddata'+IntToStr(i)+'iflowregime='+s;
      f.Add(s);
      s:=IntToStr(egddata.myflmod[i].iturbmodel)+' ';
       s:='egddata'+IntToStr(i)+'iturbmodel='+s;
      f.Add(s);
      // параметры модели Смагоринского
      s:=FloatToStr(egddata.myflmod[i].SmagConst)+' ';
       s:='egddata'+IntToStr(i)+'SmagConst='+s;
      f.Add(s);
      s:=IntToStr(egddata.myflmod[i].iDynamicStressGermano)+' ';
       s:='egddata'+IntToStr(i)+'iDynamicStressGermano='+s;
      f.Add(s);
      s:=IntToStr(egddata.myflmod[i].iLimitersCs)+' ';
       s:='egddata'+IntToStr(i)+'iLimitersCs='+s;
      f.Add(s);
      s:=FloatToStr(egddata.myflmod[i].minCs)+' ';
       s:='egddata'+IntToStr(i)+'minCs='+s;
      f.Add(s);
      s:=FloatToStr(egddata.myflmod[i].maxCs)+' ';
       s:='egddata'+IntToStr(i)+'maxCs='+s;
      f.Add(s);
      s:=IntToStr(egddata.myflmod[i].itypeFiltrGermano)+' ';
       s:='egddata'+IntToStr(i)+'itypeFiltrGermano='+s;
      f.Add(s);
      s:=FloatToStr(egddata.myflmod[i].roughness)+' ';
       s:='egddata'+IntToStr(i)+'roughness='+s;
      f.Add(s);
      s:=FloatToStr(egddata.myflmod[i].rRimult)+' ';
       s:='egddata'+IntToStr(i)+'rRimult='+s;
      f.Add(s);
      s:=FloatToStr(egddata.myflmod[i].rSelectiveAngle)+' ';
       s:='egddata'+IntToStr(i)+'rSelectiveAngle='+s;
      f.Add(s);
      s:=IntToStr(egddata.myflmod[i].ipowerroughness)+' ';
       s:='egddata'+IntToStr(i)+'ipowerroughness='+s;
      f.Add(s);
      s:=IntToStr(egddata.myflmod[i].itypefiltr)+' ';
       s:='egddata'+IntToStr(i)+'itypefiltr='+s;
      f.Add(s);
      // учёт неравномерности сетки.
      if (egddata.myflmod[i].bfdelta) then
      begin
         s:='1 ';
      end
      else
      begin
         s:='0 ';
      end;
       s:='egddata'+IntToStr(i)+'bfdelta='+s;
      f.Add(s);
      // модель Смагоринского-Лиллу.
      if (egddata.myflmod[i].bSmagorinsky_Lilly) then
      begin
         s:='1 ';
      end
      else
      begin
         s:='0 ';
      end;
       s:='egddata'+IntToStr(i)+'bSmagorinsky_Lilly='+s;
      f.Add(s);
      // учёт шероховатости стенки.
      if (egddata.myflmod[i].bsurface_roughness) then
      begin
         s:='1 ';
      end
      else
      begin
         s:='0 ';
      end;
       s:='egddata'+IntToStr(i)+'bsurface_roughness='+s;
      f.Add(s);
      // учёт течений с кривизной линий тока.
      if (egddata.myflmod[i].bSwirlamendment) then
      begin
         s:='1 ';
      end
      else
      begin
         s:='0 ';
      end;
       s:='egddata'+IntToStr(i)+'bSwirlamendment='+s;
      f.Add(s);
      // учёт избирательности в модели Смагоринского.
      if (egddata.myflmod[i].bSelectiveSmagorinsky) then
      begin
         s:='1 ';
      end
      else
      begin
         s:='0 ';
      end;
       s:='egddata'+IntToStr(i)+'bSelectiveSmagorinsky='+s;
       f.Add(s);
      end;
       // Для подготовки картинок в отчете 05.01.2018
      s:=Trim(Editminimum.Text)+' ';
      s:='report_min='+s;
      f.Add(s);
      s:=Trim(Editmaximum.Text)+' ';
      s:='report_max='+s;
      f.Add(s);
      s:=IntToStr(ComboBoxdirectional.ItemIndex)+' ';
      s:='report_directional='+s;
      f.Add(s);
      if (Formamg1r5Parameters.CheckBox_amg1r6.Checked) then
      begin
         s:='1 ';
      end
      else
      begin
         s:='0 ';
      end;
      s:='amg1r6_checker='+s;
      f.Add(s);
       s:='1131 ';
      case Formamg1r5Parameters.ComboBoxNumber_of_smootherssteps.ItemIndex of
         0 : s[2]:='1';
         1 : s[2]:='2';
         2 : s[2]:='3';
      end;
      case Formamg1r5Parameters.ComboBoxTypeSmoother.ItemIndex of
         0 : begin
                s[3]:='3'; // C/F relaxation
                s[4]:='1';
             end;
         1 : begin
                s[3]:='2'; // Full GS SWEEP
                s[4]:='2';
             end;
         2 : begin
                s[3]:='4'; // Full MORE COLOR SWEEP
                s[4]:='4';
             end;
         3 : begin
                s:='11122 '; // ILU(lfil) smoother
                case Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex of
                 0 : s[3]:='1';
                 1 : s[3]:='2';
                 2 : s[3]:='3';
                end;
             end;
      end;
      s:='nrd='+s;
      f.Add(s);
      s:='1131 ';
      case Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex of
         0 : s[2]:='1';
         1 : s[2]:='2';
         2 : s[2]:='3';
      end;
      case Formamg1r5Parameters.ComboBoxTypePostSmoother.ItemIndex of
         0 : begin
                s[3]:='3'; // C/F relaxation
                s[4]:='1';
             end;
         1 : begin
                s[3]:='2'; // Full GS SWEEP
                s[4]:='2';
             end;
         2 : begin
                s[3]:='4'; // Full MORE COLOR SWEEP
                s[4]:='4';
             end;
         3 : begin
                s:='11122 '; // ILU(lfil) smoother
                case Formamg1r5Parameters.ComboBoxNumber_of_post_smooth.ItemIndex of
                 0 : s[3]:='1';
                 1 : s[3]:='2';
                 2 : s[3]:='3';
                end;
             end;
      end;
      s:='nru='+s;
      f.Add(s);
      s:='ecg2='+Trim(Formamg1r5Parameters.Editstrongthreshold.Text)+' ';
      f.Add(s);
      s:='ewt2='+Trim(Formamg1r5Parameters.EditF2F.Text)+' ';
      f.Add(s);

      s:='number_processors='+IntToStr(1+FormSetting.ComboBoxNumberProcessors.ItemIndex)+' ';
      f.Add(s);

      s:='number_iterations_SIMPLE_algorithm='+IntToStr(FormUnsteady.ComboBoxNumberIterationsSIMPLEAlgoritm.ItemIndex)+' ';
      f.Add(s);

      // amg1r5 stabilization: 0 - none, 1 - bicgstab, 2 - fgmres, 3 - nonlinear.
      s:='stabilization_amg1r5_algorithm='+IntToStr(Formamg1r5Parameters.ComboBoxStabilization.ItemIndex)+' ';
      f.Add(s);

      // free_debug_parameter1 06.08.2020
      s:='free_debug_parametr1='+Trim(Form_debug_panel.Edit_free_debug_param.Text)+' ';
      f.Add(s);

   // Дело в том что компилятор языка СИ понимает только точку
   // в качестве разделителя целой и дробной части, поэтому
   // если в системе windows установлена запятая в качестве разделителя
   // целой и дробной части то Delphi печатает все свои данные с разделителем запятая,
   // которая при передаче в си файл должна стать точкой.
   if (FormatSettings.DecimalSeparator=',') then
   begin
      // заменить все запятые в файле на точки.
      for i:=0 to f.Count-1 do
      begin
         s:=f.Strings[i];
         f.Strings[i]:=StringReplace(s,',','.',[rfReplaceAll]);
      end;
   end;

   if not(bmodelcheck) then
   begin
      if (adiabatic_vs_heat_transfer_coeff>0) then
      begin
        // при условии Ньютона-Рихмана можно считать и без наличия условия Дирихле.
        // аналогичный случай с условием Стефана-Больцмана и смешанного условия.
        bmodelcheck:=true;
      end;

      if (FormUnsteady.RadioGroup1.ItemIndex=1) then
      begin
        // нестационарное моделирование
        bmodelcheck:=true; // при нестационарном моделировании можно считать и без теплоотвода.
      end;
   end;


  // if (bmodelcheck and bmodelcheck_cab_hollow) then
  if (true) then // Убрал защиту.
   begin
      // модель прошла проверку на корректность.

   f.SaveToFile('premeshin.txt'); // сохранение результата
   if ((egddata.imaxflD=0) or
   ((egddata.imaxflD=1) and (egddata.itemper>0)
   and(egddata.myflmod[0].iflow=0))) then
   begin
      // Есть одна Fluid зона но она не активна.

      // Мы имеем дело с задачей чистой теплопроводности,
      // следующий код запускает задачу чистой теплопроводности
      // в твёрдом теле.
     // f.SaveToFile('test_pattern/solver/solid_static/premeshin.txt');
      f.Clear;
      MainMemo.Lines.Add('File successfully written premeshin.txt.');


      if (bonly_mesh_gen_call) then
      begin
         MainMemo.Lines.Add('Meshing started.');
      end
      else
      begin
         MainMemo.Lines.Add('Calculation started.');
      end;
      //ShellExecute(Laplas.Handle,'open','solver/solid_static/AliceFlow_v0_07.exe',nil,nil,SW_SHOWNORMAL);
      //WinExec('solver/solid_static/AliceFlow_v0_07.exe',SW_SHOWNORMAL);

      DeleteFile('avtosave.txt');

      // Запускает приложение и ждёт окончания его работы.
      if (FormSetting.rgParallel.ItemIndex=0) then
      begin

      (*
         // Serial
        // CreateProcess(nil,'test_pattern/solver/solid_static/AliceFlow_v0_07.exe',nil,nil,false,Create_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
        //     nil,nil,StartupInfo,ProcessInfo);

        ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        if (FormUnsteady.RadioGroup1.ItemIndex=0) then
        begin
           // Steady Calculation
           ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_07.exe"');
        end
        else
        begin
           // Unsteady Calculation
           ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_07Unsteady.exe"');
        end;
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;
        *)

           if (boptimetric=true) then
           begin
              // однопоточный запуск

              SerialExecute1;
           end
           else
           begin

              MyThread1:=TmyThread1.Create(true);
              // поток завершиться автоматически.
              MyThread1.FreeOnTerminate:=true;
              MyThread1.Priority:=tpLower;
              MyThread1.Resume;


          end;

          bonly_mesh_gen_call:=false;

      end
      else
      begin
           MainMemo.Lines.Add('Solver not started. Solver not found. Use Serial solver.');
           ShowMessage('Use Serial Solver');
      {
         // Parallel
         //CreateProcess(nil,'test_pattern/solver/solid_static/AliceFlow_v0_07P.exe',nil,nil,false,Create_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
          //   nil,nil,StartupInfo,ProcessInfo);

          ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        // Паралельный солвер для чистой теплопроводности не реализован.
        ShellInfo.lpFile:=PChar('"test_pattern\solver\solid_static\AliceFlow_v0_07P.exe"');
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;
        }
      end;
      //WaitforSingleObject(ProcessInfo.hProcess,INFINITE);



   end
   else if ((egddata.imaxflD=1) and (egddata.itemper=0)) then
   begin

      //f.SaveToFile('test_pattern/solver/fluid_static/premeshin.txt');
      // Мы имеем дело с задачей чистой стационарной гидродинамики.
      if (FileExists('premeshin.txt')) then
      begin

      f.Clear;
      MainMemo.Lines.Add('File successfully written premeshin.txt.');
      if (bonly_mesh_gen_call) then
      begin
         MainMemo.Lines.Add('Meshing started.');
      end
      else
      begin
         MainMemo.Lines.Add('Calculation started.');
      end;
      // Удаление файла avtosave.txt
       if DeleteFile('avtosave.txt') then
            MainMemo.Lines.Add('File avtosave.txt removed!')
       else MainMemo.Lines.Add('Avtosave.txt file can not be deleted because likely exist.');
      DeleteFile('statistic_convergence.txt');
      // Запускает приложение и ждёт окончания его работы.
      //CreateProcess(nil,'test_pattern/solver/fluid_static/AliceFlow_v0_07.exe',nil,nil,false,Create_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
        //     nil,nil,StartupInfo,ProcessInfo);

        (*
        ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        if (FormSetting.rgParallel.ItemIndex=0) then
        begin
           // однопоточная версия.
           ShellInfo.lpFile:=PChar('"test_pattern\solver\fluid_static\AliceFlow_v0_07.exe"');
        end;
         if (FormSetting.rgParallel.ItemIndex=1) then
        begin
           // параллельные вычисления.
           ShellInfo.lpFile:=PChar('"test_pattern\solver\fluid_static\AliceFlow_v0_07P.exe"');
        end;
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;

      //WaitforSingleObject(ProcessInfo.hProcess,INFINITE);
      *)

        DeleteFile('statistic_convergence.txt');
          if (Laplas.egddata.itemper>0) then
          begin
          if ((Laplas.egddata.myflmod[0].iflowregime=1)and
               (Laplas.egddata.myflmod[0].iturbmodel=6)) then
                begin
                    // Модель ламинарно турбулентного перехода Ментора Лантгрии [2009]
                    Formresidual2.brun_visible2:=false;
                    FormResidualSATemp.brun_visibleSA2:=false;
                    FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                    FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=true;
                    FormResidual_Lagtry_Menter_Temp.Show;
                end
                else
               if ((Laplas.egddata.myflmod[0].iflowregime=1)and
               (Laplas.egddata.myflmod[0].iturbmodel=5)) then
                begin
                    // Standart K-epsilon Model на основе двухслойной модели [2001]
                    Formresidual2.brun_visible2:=false;
                    FormResidualSATemp.brun_visibleSA2:=false;
                    FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                    FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=true;
                    FormResidualStandart_k_epsilon_Temp.Show;
                end
                else
                if ((Laplas.egddata.myflmod[0].iflowregime=1)and
               (Laplas.egddata.myflmod[0].iturbmodel=4)) then
                begin
                    // K-Omega SST Menter [1993]
                    Formresidual2.brun_visible2:=false;
                    FormResidualSATemp.brun_visibleSA2:=false;
                    FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                    FormResidualSSTTemp.brun_visibleSSTTemp:=true;
                    FormResidualSSTTemp.Show;
                end
                else
                if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                  (Laplas.egddata.myflmod[0].iturbmodel=3)) then
                begin
                   // Спаларт Аллмарес
                   FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                   Formresidual2.brun_visible2:=false;
                   FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                   FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                   FormResidualSATemp.brun_visibleSA2:=true;
                   FormResidualSATemp.Show;
                end
                 else
                begin
                   FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                   FormResidualSATemp.brun_visibleSA2:=false;
                   FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                   FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                   Formresidual2.brun_visible2:=true;
                   Formresidual2.Show;
                end;
          end
           else
          begin
             if (egddata.iStaticStructural=0) then
             begin
                if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                (Laplas.egddata.myflmod[0].iturbmodel=6)) then
                begin
                   // Модель Ментора Лангтрии.
                   FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=true;
                   FormResidual_Langtry_Menter.Show;
                end
                else
                if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                (Laplas.egddata.myflmod[0].iturbmodel=5)) then
                begin
                   // Standart K-Epsilon
                   FormResidualStandartKEpsilon.brun_visibleKEpsilon:=true;
                   FormResidualStandartKEpsilon.Show;
                end
                else
                if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                (Laplas.egddata.myflmod[0].iturbmodel=4)) then
                begin
                   // SST Ментер
                   FormResidualSST.brun_visibleSST:=true;
                   FormResidualSST.Show;
                end
                else
                if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                (Laplas.egddata.myflmod[0].iturbmodel=3)) then
                begin
                   // Спаларт Аллмарес
                   FormResidualSpallart_Allmares.brun_visibleSA:=true;
                   FormResidualSpallart_Allmares.Show;
                end
                else
                begin
                   Formresidual.brun_visible:=true;
                   Formresidual.Show;
                end;
             end;
          end;

           if (boptimetric=true) then
           begin
              // однопоточный запуск

              SerialExecute2;
           end
           else
           begin

              MyThread2:=TmyThread2.Create(true);
              // поток завершится автоматически.
              MyThread2.FreeOnTerminate:=true;
              MyThread2.Priority:=tpLower;
              MyThread2.Resume;
          end;

          bonly_mesh_gen_call:=false;

       end
      else
      begin
         Laplas.MainMemo.Lines.Add('premeshin.txt not found.');
      end;

   end
   else if ((egddata.imaxflD=1) and (egddata.itemper>0) and(egddata.myflmod[0].iflow=1)) then
   begin
      // Считается первая Fluid зона и только она.

      // f.SaveToFile('test_pattern/solver/conjugate_heat_transfer_static/premeshin.txt');
      // Мы имеем дело с задачей чистой стационарной гидродинамики.
      if (FileExists('premeshin.txt')) then
      begin

      f.Clear;
      MainMemo.Lines.Add('File successfully written premeshin.txt.');
      if (bonly_mesh_gen_call) then
      begin
         MainMemo.Lines.Add('Meshing started.');
      end
       else
      begin
         MainMemo.Lines.Add('Calculation started.');
      end;
      // Удаление файла avtosave.txt
      if DeleteFile('avtosave.txt') then
            MainMemo.Lines.Add('File avtosave.txt successfully removed !')
      else MainMemo.Lines.Add('Avtosave.txt file can not be deleted because likely exist.');
       DeleteFile('statistic_convergence.txt');
      // Запускает приложение и ждёт окончания его работы.
      // CreateProcess(nil,'test_pattern/solver/conjugate_heat_transfer_static/AliceFlow_v0_07.exe',nil,nil,false,Create_NEW_CONSOLE or NORMAL_PRIORITY_CLASS,
      //        nil,nil,StartupInfo,ProcessInfo);
      //WaitforSingleObject(ProcessInfo.hProcess,INFINITE);

        (*
        ShellInfo.cbSize:=SizeOf(ShellInfo);
        ShellInfo.fMask:=SEE_MASK_NOCLOSEPROCESS;
        ShellInfo.Wnd:=HWND_DESKTOP;
        ShellInfo.lpVerb:='open';
        ShellInfo.lpFile:=PChar('"test_pattern\solver\conjugate_heat_transfer_static\AliceFlow_v0_07.exe"');
        QuoteParams:=true;
        if QuoteParams then
        ShellInfo.lpParameters:=PChar('""')
        else
        ShellInfo.lpParameters:=PChar('');
        ShellInfo.lpDirectory:=PChar('".\"');
        ShellInfo.nShow:=SW_SHOWNORMAL;
        if not ShellExecuteEx(@ShellInfo) then
        RaiseLastOSError;
        if ShellInfo.hProcess<>0 then
        try
          WaitForSingleObjectEx(ShellInfo.hProcess,INFINITE,false);
          GetExitCodeProcess(ShellInfo.hProcess,ExitCode);
        finally
           CloseHandle(ShellInfo.hProcess);
        end;
        *)

          DeleteFile('statistic_convergence.txt');
          if (Laplas.egddata.itemper>0) then
          begin
          if ((Laplas.egddata.myflmod[0].iflowregime=1)and
               (Laplas.egddata.myflmod[0].iturbmodel=6)) then
                begin
                    // Модель ламинарно турбулентного перехода Ментора Лантгрии [2009]
                    Formresidual2.brun_visible2:=false;
                    FormResidualSATemp.brun_visibleSA2:=false;
                    FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                    FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                    FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=true;
                    FormResidual_Lagtry_Menter_Temp.Show;
                end
                else
              if ((Laplas.egddata.myflmod[0].iflowregime=1)and
              (Laplas.egddata.myflmod[0].iturbmodel=5)) then
              begin
                 // Standart K-Epsilon Model на основе двухслойной модели.
                 FormResidualSATemp.brun_visibleSA2:=false;
                 Formresidual2.brun_visible2:=false;
                 FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                 FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                 FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=true;
                 FormResidualStandart_k_epsilon_Temp.Show;
              end
               else
              if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                  (Laplas.egddata.myflmod[0].iturbmodel=4)) then
              begin
                 // K-Omega SST
                 FormResidualSATemp.brun_visibleSA2:=false;
                 Formresidual2.brun_visible2:=false;
                 FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                 FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                 FormResidualSSTTemp.brun_visibleSSTTemp:=true;
                 FormResidualSSTTemp.Show;
              end
               else
              if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                  (Laplas.egddata.myflmod[0].iturbmodel=3)) then
              begin
                 // Спаларт Аллмарес
                 FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                 Formresidual2.brun_visible2:=false;
                 FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                 FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                 FormResidualSATemp.brun_visibleSA2:=true;
                 FormResidualSATemp.Show;
              end
               else
              begin
                 FormResidualSATemp.brun_visibleSA2:=false;
                 FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                 FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                 FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                 Formresidual2.brun_visible2:=true;
                 Formresidual2.Show;
              end;
          end
           else
          begin
               if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                   (Laplas.egddata.myflmod[0].iturbmodel=6)) then
                begin
                   // модель Ментора Лангтрии [2009]
                   FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=true;
                   FormResidual_Langtry_Menter.Show;
                end
                else
               if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                   (Laplas.egddata.myflmod[0].iturbmodel=5)) then
                begin
                   // Standart K-epsilon model
                   FormResidualStandartKEpsilon.brun_visibleKEpsilon:=true;
                   FormResidualStandartKEpsilon.Show;
                end
                else
                 if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                    (Laplas.egddata.myflmod[0].iturbmodel=4)) then
                begin
                   // SST Ментер
                   FormResidualSST.brun_visibleSST:=true;
                   FormResidualSST.Show;
                end
                else
              if ((Laplas.egddata.myflmod[0].iflowregime=1)and
                  (Laplas.egddata.myflmod[0].iturbmodel=3)) then
               begin
                  // Спаларт Аллмарес
                  FormResidualSpallart_Allmares.brun_visibleSA:=true;
                  FormResidualSpallart_Allmares.Show;
              end
             else
             begin
                Formresidual.brun_visible:=true;
                Formresidual.Show;
             end;
          end;

           if (boptimetric=true) then
           begin
              // однопоточный запуск

              SerialExecute3;
           end
           else
           begin

              MyThread3:=TmyThread3.Create(true);
              // поток завершиться автоматически.
              MyThread3.FreeOnTerminate:=true;
              MyThread3.Priority:=tpLower;
              MyThread3.Resume;
          end;

          bonly_mesh_gen_call:=false;
      end
      else
      begin
         MainMemo.Lines.Add('premeshin.txt not found.');
      end;

     end
      else
     begin
        MainMemo.Lines.Add('The solver is not running because we are dealing with an unforeseen situation.');
        MainMemo.Lines.Add('Perhaps the number of isolated Fluid zones exceeds one.');

        // Запускаем на свой страх и риск больше одной fluid зоны.
        (*
        if (FileExists('premeshin.txt')) then
        begin

           f.Clear;
           MainMemo.Lines.Add('File successfully written premeshin.txt.');
           if (bonly_mesh_gen_call) then
           begin
              MainMemo.Lines.Add('Meshing started.');
           end
            else
           begin
              MainMemo.Lines.Add('Calculation started.');
           end;
           // Удаление файла avtosave.txt
           if DeleteFile('avtosave.txt') then
               MainMemo.Lines.Add('File avtosave.txt successfully removed !')
           else MainMemo.Lines.Add('Avtosave.txt file can not be deleted because likely exist.');
               DeleteFile('statistic_convergence.txt');

               DeleteFile('statistic_convergence.txt');
               Formresidual.Show;

            MyThread3:=TmyThread3.Create(true);
            // поток завершиться автоматически.
            MyThread3.FreeOnTerminate:=true;
            MyThread3.Priority:=tpLower;
            MyThread3.Resume;


         end
          else
         begin
            MainMemo.Lines.Add('premeshin.txt not found.');
         end;
         *)
     end;
   end
   else
   begin
      MainMemo.Lines.Add('Созданная вами модель некорректна. Возможно отсутствует теплоотвод.');
      MainMemo.Lines.Add('Решатель не может быть запущен.');
      ShowMessage('Созданная вами модель некорректна. Возможно отсутствует теплоотвод.');
   end;
   f.Free;
      end;


   end
    else
   begin
      // вычисление уже запущено.
      //ShowMessage('The calculation is already running');
      irun:=Application.MessageBox('The calculation is already running. Ok-LOCK, Cancel-Recalculation.','Clean history and restart.',mb_OkCancel);
      if (irun=1) then
      begin
         brun:=false;
      end;
   end;
end;



// Оптиметрик 13.02.2021
procedure TLaplas.Runoptimization1Click(Sender: TObject);
var
  ivar_id, i,j, n_id_0, n_id_1, ivar_id1 : Integer;
  value_var_id0, value_var_id1 : array of Real;
  s, sub : String;

begin
     // Вызываем форму задания и редактирования переменных.
    for i:=1 to FormVariables.StringGridVariables.RowCount-1 do
    begin
       if (i-1>=ivar) then
       begin
          FormVariables.StringGridVariables.Cells[1,i]:='';
          FormVariables.StringGridVariables.Cells[2,i]:='';
       end
       else
       begin
          FormVariables.StringGridVariables.Cells[1,i]:=Laplas.parametric[i-1].svar;
          FormVariables.StringGridVariables.Cells[2,i]:=Laplas.parametric[i-1].sval;
       end;
    end;

     FormOptimetric.ComboBoxvar_id0.Items.Clear;
     FormOptimetric.ComboBoxvar_id1.Items.Clear;
     for i:=0 to Laplas.ivar-1 do
    begin
       FormOptimetric.ComboBoxvar_id0.Items.Add(Laplas.parametric[i].svar);
       FormOptimetric.ComboBoxvar_id1.Items.Add(Laplas.parametric[i].svar);
    end;

    FormOptimetric.ComboBoxvar_id0.ItemIndex:=id_0_index;
    FormOptimetric.ComboBoxvar_id1.ItemIndex:=id_1_index;

    bOkTrials:=false;
    FormOptimetric.ShowModal;

    s:=Trim(FormOptimetric.EditListVariable.Text);

    n_id_0:=0;
    n_id_1:=0;

    if (length(s)>0) then
    begin

       n_id_0:=0;
       while (pos(' ',s)>0) do
       begin
          sub:=Trim(Copy(s,1,pos(' ',s)));
          inc(n_id_0);
          SetLength(value_var_id0, n_id_0);
          for i:=1 to length(sub) do
          begin
             if (FormatSettings.DecimalSeparator=',') then
             begin
                if (sub[i]='.') then sub[i]:=',';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                if (sub[i]=',') then sub[i]:='.';
             end;
          end;

          value_var_id0[n_id_0-1]:=StrToFloat(sub);
          s:=Trim(Copy(s,pos(' ',s),length(s)));
       end;
       inc(n_id_0);
       SetLength(value_var_id0, n_id_0);
       sub:=Trim(s);
       for i:=1 to length(sub) do
          begin
             if (FormatSettings.DecimalSeparator=',') then
             begin
                if (sub[i]='.') then sub[i]:=',';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                if (sub[i]=',') then sub[i]:='.';
             end;
          end;
       value_var_id0[n_id_0-1]:=StrToFloat(sub);

       s:=Trim(FormOptimetric.EditListVariable1.Text);

    if (length(s)>0) then
    begin

       n_id_1:=0;
       while (pos(' ',s)>0) do
       begin
          sub:=Trim(Copy(s,1,pos(' ',s)));
          inc(n_id_1);
          SetLength(value_var_id1, n_id_1);
          for i:=1 to length(sub) do
          begin
             if (FormatSettings.DecimalSeparator=',') then
             begin
                if (sub[i]='.') then sub[i]:=',';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                if (sub[i]=',') then sub[i]:='.';
             end;
          end;

          value_var_id1[n_id_1-1]:=StrToFloat(sub);
          s:=Trim(Copy(s,pos(' ',s),length(s)));
       end;
       inc(n_id_1);
       SetLength(value_var_id1, n_id_1);
       sub:=Trim(s);
        for i:=1 to length(sub) do
          begin
             if (FormatSettings.DecimalSeparator=',') then
             begin
                if (sub[i]='.') then sub[i]:=',';
             end;
             if (FormatSettings.DecimalSeparator='.') then
             begin
                if (sub[i]=',') then sub[i]:='.';
             end;
          end;
       value_var_id1[n_id_1-1]:=StrToFloat(sub);

    end;

    if (bOkTrials=true) then
    begin

       if (n_id_1>0) then
       begin
          // Две переменные
          ivar_id:=FormOptimetric.ComboBoxvar_id0.ItemIndex;
          ivar_id1:=FormOptimetric.ComboBoxvar_id1.ItemIndex;

          id_0_index:=ivar_id;
          id_1_index:=ivar_id1;

          // Варьируем  одну переменную.
          for i:=0 to   n_id_0-1 do
          begin
             for j:=0 to   n_id_1-1 do
             begin
                if ((i>0)or(j>0))  then
                begin
                   bOkTrials:=false;
                end;
                Laplas.parametric[ivar_id].sval:= FloatToStr(value_var_id0[i]);
                FormVariables.StringGridVariables.Cells[2,ivar_id+1]:=Laplas.parametric[ivar_id].sval;

                Laplas.parametric[ivar_id1].sval:= FloatToStr(value_var_id1[j]);
                FormVariables.StringGridVariables.Cells[2,ivar_id1+1]:=Laplas.parametric[ivar_id1].sval;

                FormVariables.BApplyClick(Sender);

                boptimetric:=true;

                //WriteStartSolutionOLD(Sender);
                // начало 3.11.2018 - окончание 20.08.2019
                WriteStartSolutionNEW(Sender);
             end;
          end;

       end
       else
       begin
          // Одна переменная.

          //Laplas.MainMemo.Lines.Add('n_id_0'+IntToStr(n_id_0));

          ivar_id:=FormOptimetric.ComboBoxvar_id0.ItemIndex;

          id_0_index:=ivar_id;

          // Варьируем  одну переменную.
          for i:=0 to   n_id_0-1 do
          begin
             if (i>0)  then
             begin
                bOkTrials:=false;
             end;
             Laplas.parametric[ivar_id].sval:= FloatToStr(value_var_id0[i]);
             FormVariables.StringGridVariables.Cells[2,ivar_id+1]:=Laplas.parametric[ivar_id].sval;
             FormVariables.BApplyClick(Sender);

             boptimetric:=true;

             //WriteStartSolutionOLD(Sender);
             // начало 3.11.2018 - окончание 20.08.2019
             WriteStartSolutionNEW(Sender);
          end;
       end;
    end;
   end;

end;

// записывает файл premeshin.txt
procedure TLaplas.RunSolution1Click(Sender: TObject);
begin

    bOkTrials:=true;
    boptimetric:=false;



    //WriteStartSolutionOLD(Sender);
    // начало 3.11.2018 - окончание 20.08.2019
    WriteStartSolutionNEW(Sender);

end;

// проверка уникальности имени объекта
function TLaplas.isduplicatenameobj(chidobj : Char; scandidate : string; iobjid : Integer) : Boolean;
var
   i : Integer;
   bOk : Boolean;
begin
   bOk:=true;
   // проверка всех блоков :
   for i:=0 to lb-1 do
   begin
      if (((length(body[i].name)=length(scandidate)) and (pos(scandidate,body[i].name)=1))) then
      begin
         if (not((chidobj='b')and(iobjid=i))) then
         begin
            bOk:=false;
         end;
      end;
   end;

   if (bOk) then
   begin
      // проверка всех стенок :
      for i:=0 to lw-1 do
      begin
         if (((length(wall[i].name)=length(scandidate)) and (pos(scandidate,wall[i].name)=1))) then
         begin
            if (not(((chidobj='w'))and(iobjid=i))) then
            begin
               bOk:=false;
            end;
         end;
      end;
   end;

   if (bOk) then
   begin
      // проверка всех источников тепла :
      for i:=0 to ls-1 do
      begin
         if (((length(source[i].name)=length(scandidate)) and (pos(scandidate,source[i].name)=1))) then
         begin
            if (not((chidobj='s')and(iobjid=i))) then
            begin
               bOk:=false;
            end;
         end;
      end;
   end;

   if (bOk) then
   begin
      // проверка всех объединений :
      for i:=0 to lu-1 do
      begin
         if (((length(myassembles[i].name)=length(scandidate)) and (pos(scandidate,myassembles[i].name)=1))) then
         begin
            if (not((chidobj='u')and(iobjid=i))) then
            begin
               bOk:=false;
            end;
         end;
      end;
   end;

   Result:=bOk;
end;

// возвращение в изометрию
procedure TLaplas.Isometricview1Click(Sender: TObject);
begin
    SpeedButtonisogeomClick(Sender);
end;



// Загрузка репорта с достигнутыми температурами.
procedure TLaplas.Loadreport1Click(Sender: TObject);
var
   i : Integer;
   f : TStringList;
begin
   // 26.07.2016
   if (Laplas.bonly_mesh_gen_call=false) then
   begin
      if (FileExists('report_temperature.txt')) then
      begin

         WinExec('notepad.exe report_temperature.txt',sw_ShowNormal);
         //ShellExecute(Handle, 'open', 'c:\ProgramFiles\Windows NT\Accessories\wordpad.exe', Pchar(ExtractFilePath(ParamStr(0))+'report_temperature.txt'), nil, SW_SHOWNORMAL); //открываем файл через WordPad
         (*f:=TStringList.Create();
         f.LoadFromFile('report_temperature.txt');
         // Проверка на совместимость проверяется только по
         // равенству количества элементов модели каждого типа.
         if (f.Count=Laplas.ls+Laplas.lw+Laplas.lb+1) then
         begin
            Laplas.MainMemo.Lines.Add(f.Strings[0]);
            for i:=0 to Laplas.lb-1 do
            begin
               Laplas.MainMemo.Lines.Add(f.Strings[i+1]);
            end;
            for i:=0 to Laplas.ls-1 do
            begin
               Laplas.MainMemo.Lines.Add(f.Strings[i+Laplas.lb+1]);
            end;
            for i:=0 to Laplas.lw-1 do
            begin
               Laplas.MainMemo.Lines.Add(f.Strings[i+Laplas.lb+Laplas.ls+1]);
            end;
         end
          else
         begin
            // загружаемая модель не соответствует текущей.
            ShowMessage('error! the loaded model does not match the current.');
            MainMemo.Lines.Add('error! the loaded model does not match the current.');
         end;
         //DeleteFile('solver/solid_static/report_temperature.txt');
         f.Clear;
         f.Free;
         *)
      end
      else
      begin
        ShowMessage('file report_temperature.txt not found ');
        Laplas.MainMemo.Lines.Add('file report_temperature.txt not found ');
      end;
   end;
end;

// Вызов tecplot360 и загрузка файла с решением.
procedure TLaplas.LoadSolution1Click(Sender: TObject);
var
  FName : string;
  i,j : Integer;
begin
   // Загружает решение отдельно.
   // 22.07.2016.

   if OpenDialog2.Execute then
   begin

      // Обрезаем полный путь к файлу.
      // Оставляем только имя файла с расширением.
      FName:=ExtractFileName(OpenDialog2.FileName);

      j:=0; // инициализация.
      for i := length(FName) downto 1  do
      begin
        if (FName[i]='\') then
        begin
           j:=i;
           break;
        end;
      end;
      FName:=Copy(FName, j+1, length(FName));

      // Тестирование извлечения имени.
      //MainMemo.Lines.Add(FName);

       // Finite Element Method
      if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
      begin
         //WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe '+OpenDialog2.FileName),SW_SHOWNORMAL);
      ShellExecute(Laplas.Handle, 'open', 'C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe',
             PWideChar(FName), nil, SW_SHOWNORMAL);
      end
       else
      begin
         if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
         begin
            //WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe '+OpenDialog2.FileName),SW_SHOWNORMAL);
         ShellExecute(Laplas.Handle, 'open', 'C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe',
             PWideChar(FName), nil, SW_SHOWNORMAL);
         end
          else
         begin
            if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
            begin
               //WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe '+OpenDialog2.FileName),SW_SHOWNORMAL);
            ShellExecute(Laplas.Handle, 'open', 'C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe',
             PWideChar(FName), nil, SW_SHOWNORMAL);
            end
             else
            begin
               if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
               begin
                  //WinExec(PAnsiChar('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe '+OpenDialog2.FileName),SW_SHOWNORMAL);
               ShellExecute(Laplas.Handle, 'open', 'C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe',
               PWideChar(FName), nil, SW_SHOWNORMAL);
               end
                else
               begin
                  if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                  begin
                     //WinExec(PAnsiChar('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe '+OpenDialog2.FileName),SW_SHOWNORMAL);
                      ShellExecute(Laplas.Handle, 'open', 'C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe',
                      PWideChar(FName), nil, SW_SHOWNORMAL);
                  end
                   else
                  begin
                     Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 or 2017 unfound.');
                  end;
               end;
            end;
         end;
      end;


   end;




   (*
   if (egddata.itemper=2) then
   begin
      // Finite Element Method
      if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
      begin
         WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe ALICEFLOW0_08_temp.PLT'),SW_SHOWNORMAL);
      end
       else
      begin
         if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
         begin
            WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
         end
          else
         begin
            if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
            begin
               WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
            end
             else
            begin
               if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
               begin
                  WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
               end
                else
               begin
                  if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                  begin
                     WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe ALICEFLOW0_08_temp.PLT',SW_SHOWNORMAL);
                  end
                   else
                  begin
                     Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 or 2017 unfound.');
                  end;
               end;
            end;
         end;
      end;
   end
    else
   begin
      // Control Volume Method
      if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
      begin
         WinExec(PAnsiChar('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT'),SW_SHOWNORMAL);
      end
       else
      begin
         if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
         begin
            WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
         end
          else
         begin
            if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
            begin
               WinExec('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
            end
             else
            begin
               if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
               begin
                  WinExec('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
               end
                else
               begin
                  if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                  begin
                     WinExec('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe ALICEFLOW0_07_temp.PLT',SW_SHOWNORMAL);
                  end
                   else
                  begin
                     Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 or 2017 unfound.');
                  end;
               end;
            end;
         end;
      end;
   end;
   *)
end;

// процедура корректировки имени объекта
procedure TLaplas.correctobjname(chidobj : Char;var scandidate : string; iobjid : Integer);
var
   bOk : Boolean;
   i : integer;
   snamebuf : String;
begin
   bOk:=false;
   i:=0;
   snamebuf:=scandidate;
   while (not(bOk)) do
   begin
      bOk:=isduplicatenameobj(chidobj, snamebuf, iobjid);
      if (not(bOk)) then
      begin
         inc(i);
         snamebuf:=scandidate+'_'+IntToStr(i);
      end;
   end;
   scandidate:=snamebuf;
end;




(*
procedure TLaplas.PowerTable1Click(Sender: TObject);
var
   i : Integer;
begin
   // формирование списка таблиц.
   FormPowerList.Eltdp.Text:=IntToStr(iltdp);
   FormPowerList.CBidtable.Clear;
   for i:=0 to iltdp-1 do
   begin
      FormPowerList.CBidtable.AddItem(IntToStr(i),Sender);
   end;
   if (iltdp=0) then
   begin
       FormPowerList.GBtableparam.Visible:=false;
       FormPowerList.Efilename.Text:=''; // пустая строека.
   end
   else
   begin
      FormPowerList.GBtableparam.Visible:=true;
      FormPowerList.CBidtable.ItemIndex:=0;
      FormPowerList.Efilename.Text:=listtablename[0];
   end;
   FormPowerList.ShowModal;
end;
*)

// Одиночный клик по дереву, вызывает выделение элемента.
procedure TLaplas.MainTreeViewClick(Sender: TObject);
begin
   // нужно вызвать прорисовку геометрии.
   // нужно прописать алгоритм выделения элемента.
   // прорисовка геометрии
end;

// Печать изображения модели на принтере.
procedure TLaplas.guiPrintClick(Sender: TObject);
var
   ScaleX, ScaleY : Double;
   dwloc : HWND;
   dcloc : HDC;
   PrintDlg : TPrintDialog;
   Bmp : TBitmap;
   R : TRect;
   ileft, itop : Integer;
begin
   // TODO
   Sleep(500);
   // Делает скриншот всей экранной формы.
   Bmp:=TBitmap.Create;
   Bmp.Width:=pnlPaint.Width;
   Bmp.Height:=pnlPaint.Height;
   dwloc:=GetDesktopWindow;
   dcloc:=GetDC(dwloc);
    // 8 - магическое универсальное число пикселей при котором
   // скриншот рабочего пространства скриншотится без бортиков.
   ileft:=Laplas.Left+MainPanel.Left+pnlPaint.Left+8;
   itop:=Laplas.Top+(Laplas.Height-Laplas.ClientHeight)+pnlPaint.Top-8;
   BitBlt(bmp.Canvas.Handle,0,0,bmp.Width,bmp.Height,dcloc,ileft,itop,SRCCOPY);
   ReleaseDC(dwloc,dcloc);
   //Bmp.SaveToFile('screen.bmp');


   PrintDlg:=TPrintDialog.Create(Owner);
    if PrintDlg.Execute then
    begin
    //Bmp:=TBitmap.Create;
    try
       //cht1.SaveToBitmapFile('vax_pic.bmp');
       //Bmp.LoadFromFile('vax_pic.bmp');

      // Printer.Orientation:=poLandscape;
       Printer.BeginDoc;
       with Printer do
       begin
         try

              ScaleX:=GetDeviceCaps(Handle,logPixelsX) div PixelsPerInch;
              ScaleY:=GetDeviceCaps(Handle,logPixelsY) div PixelsPerInch;
              if (Printer.Orientation=poLandscape) then
              begin
                 // альбомная.
                 ScaleX:=Round(1.36*ScaleX);
                 ScaleY:=Round(1.36*ScaleY);
              end;
              R:=Rect(0,0,Round(Bmp.Width*ScaleX),Round(Bmp.Height*ScaleY));
              Canvas.StretchDraw(R,Bmp);

         finally
           Printer.EndDoc;
           if Printer.Aborted then
           begin
              MessageDlg('Принтер не отвечает.',mtInformation,[mbOk],0);
           end;
         end;
       end;

    finally
        Bmp.Free;
    end;

    end;

     
      Application.MessageBox('График отправлен на печать.','Mesage: print');

end;

// Визуализирует результат нестационарного моделирования.
procedure TLaplas.HistoryPlot1Click(Sender: TObject);
begin
    if (FormUnsteady.RadioGroup1.ItemIndex=1) then
      begin
         // Запуск визуализации графика зависимости максимальной температуры в расчётной области
         // от времени.
         if (FileExists('GraphicsKras.exe')) then
         begin
            WinExec('GraphicsKras.exe',SW_SHOWNORMAL);
         end;
      end;
end;

// Плоскость XY neg_Z плюс автомасштабирование по размерам кабинета.
procedure TLaplas.Homeposition1Click(Sender: TObject);
begin
   SpeedButtonplaneneg_ZClick(Sender);
   BitBtnScale_to_fitClick(Sender);
end;

// Редактирование наполнения объединения.
procedure TLaplas.MainTreeViewMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
   s : string; // имя редактируемого элемента
   i : Integer;
   ch : Char; // тип выделенного элемента : c - кабинет, b - блок, s - источник, w - стенка, u - объединение.
   bcontinue : Boolean; // нужно ли продолжать поиск
   NewNode, node2 : TTreeNode; // новый узел в дереве.
   iunionfound : Integer; // номер найденного юниона.

begin
   // нажатие кнопки мыши в дереве элементов.
   if (Button = mbRight) then
   begin
       // Алгоритм.
       // Если есть assembles и
       // и элемент является не Assembles и не кабинет а простой элемент расположенный вне всяких Assemblesoв.
       // то вызвать форму.
       // На форме есть ListBox.
       // Загрузить в ListBox все доступные assembles.
       // По умолчанию установить первый.
       // Как только пользователь выбрал нужный assembles и нажалл кнопку Add
       // добавть элемент в выбранный пользователем Assembles.
       // Если ассемблесов нет или выделенный элемент есть ассемблес, то
       //  игнорировать событие.
       // Если элемент находится внутри ассемблеса и нажата правая кнопка о вернуть этот элемент
       // на нулевой уровень.

       if (MainTreeView.Selected<>nil) then
       begin
          // Выделен лишь один элемент !


          // Определяем какой элемент выделен.
          s:=MainTreeView.Selected.Text;
          // символ ch может принимать значения : c, b, s, w, u, e-exit
          ch:='e';
          bcontinue:=true;
          if (Length(s)=0) then
          begin
             bcontinue:=false;
          end;
          // по всем блокам
          for i:=0 to (lb-1) do
          begin
             if (bcontinue and (length(body[i].name) = length(s)) and (Pos(body[i].name,s)=1)) then
             begin
                // найден блок :
                bcontinue:=false;
                itek:=i;
                if (i=0) then
                begin
                   ch:='c';
                   iunionfound:=-1; // кабинет
                end
                 else
                begin
                   ch:='b';
                   iunionfound:=body[itek].iunion-1;
                end;
                break;
             end;
          end;
          if (ch='e') then
          begin
             // по всем источникам
             for i:=0 to (ls-1) do
             begin
                if (bcontinue and (length(source[i].name) = length(s)) and (Pos(source[i].name,s)=1)) then
                begin
                   // найден источник
                   bcontinue:=false;
                   ch:='s';
                   itek:=i;
                   iunionfound:=source[itek].iunion-1;
                   break;
                end;
             end;
          end;
          if (ch='e') then
          begin
             // по всем твёрдым стенкам
             for i:=0 to (lw-1) do
             begin
                if (bcontinue and (length(wall[i].name) = length(s)) and (Pos(wall[i].name,s)=1)) then
                begin
                   if (wall[i].cabinet_depend=0) then
                   begin
                      // найдена твёрдая стенка.
                      bcontinue:=false;
                      itek:=i;
                      ch:='w';
                      iunionfound:=wall[itek].iunion-1;
                      break;
                   end;
                end;
             end;
           end;
           if (ch='e') then
           begin
              // по всем объединениям
              for i:=0 to (lu-1) do
              begin
                 if (bcontinue and (length(myassembles[i].name) = length(s)) and (Pos(myassembles[i].name,s)=1)) then
                 begin
                    bcontinue:=false;
                    ch:='u'; // двойной щелчек по объединению
                    itek:=myassembles[i].identifire; // идентификатор объединения
                    // внимание : обязательно должна быть справедлива связь itek=identifire=i+1;
                    // т.е. номер объединения в списке должен быть на единицу меньше его идентификатора.
                    iunionfound:=i;
                    break;
                 end;
              end;
           end;


           if ((lu=0) or (ch='c') or (ch='e')) then
           begin
              // игнорируем нажатие правой кнопки мыши, т.к.
              // мы либо ничего не выбрали ch='e', либо выбрали
              // cabinet ch='c', либо у нас нет объединений.
           end
            else
           begin
              // у нас выбран некий элемент.
              // выясним какой :
              case ch of
              'b' : begin
                      if (body[itek].iunion>0) then
                       begin
                          // данный элемент уже принадлежит некоторому assembles.
                          // его надо вернуть на уровень ноль.
                          body[itek].iunion:=0;
                          body[itek].bvisible:=True; // возвращаем видимость исключенного элемента.
                          // возвращаем на нулевой уровень.
                          node2:=MainTreeView.Selected;
                          while (node2.Parent<>nil) do
                          begin  // ищем корень.
                             node2:=node2.Parent;
                          end;
                          MainTreeView.Items.Delete(MainTreeView.Selected);
                          NewNode:=MainTreeView.Items.Add(node2,body[itek].name);
                          NewNode.ImageIndex:=1;  // номер картинки блока
                          NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен  (блока)
                          //MainTreeView.Items[MainTreeView.Items.Count-1].Text:=body[itek].name;
                          NewNode.Text:=body[itek].name;
                       end
                      else
                       begin
                          Form_formirateunion.cbbselectnameunion.Clear;
                          for i:=0 to lu-1 do
                          begin
                             Form_formirateunion.cbbselectnameunion.Items.Add(myassembles[i].name)
                          end;
                          if (Form_formirateunion.iselectedunion<lu) then
                          begin
                             Form_formirateunion.cbbselectnameunion.ItemIndex:=Form_formirateunion.iselectedunion;
                          end
                           else
                          begin
                             Form_formirateunion.cbbselectnameunion.ItemIndex:=0;
                          end;
                          Form_formirateunion.ShowModal;
                          MainTreeView.Items.Delete(MainTreeView.Selected);
                          Form_formirateunion.iselectedunion:=Form_formirateunion.cbbselectnameunion.ItemIndex;
                          body[itek].iunion:=Form_formirateunion.cbbselectnameunion.ItemIndex+1;
                          // при включении в union элемент приобретает свойства видимости union`а
                          body[itek].bvisible:=myassembles[Form_formirateunion.cbbselectnameunion.ItemIndex].bVisible;
                          MainTreeView.Selected:=nil;
                          for i:=0 to MainTreeView.Items.Count-1 do
                          begin
                             if ((length(myassembles[Form_formirateunion.cbbselectnameunion.ItemIndex].name) = length(MainTreeView.Items.Item[i].Text)) and (Pos(myassembles[Form_formirateunion.cbbselectnameunion.ItemIndex].name,MainTreeView.Items.Item[i].Text)=1)) then
                             begin
                                node2:=MainTreeView.Items.Item[i];
                                Break;
                             end;
                          end;

                          if (node2 <>nil) then
                          begin
                             NewNode:=MainTreeView.Items.AddChild(node2,body[itek].name);
                             NewNode.ImageIndex:=1;  // номер картинки блока
                             NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен  (блока)
                             NewNode.Text:=body[itek].name;
                          end;
                      end;
                    end;
              'u' : begin
                       // Объединение.
                       Form_formirateunion.cbbselectnameunion.Clear;
                       Form_formirateunion.cbbselectnameunion.Items.Add('cabinet');
                       for i:=0 to lu-1 do
                       begin
                          if (i<>iunionfound) then
                          begin
                             Form_formirateunion.cbbselectnameunion.Items.Add(myassembles[i].name);
                          end;
                       end;
                       if (Form_formirateunion.iselectedunion<lu) then
                       begin
                          Form_formirateunion.cbbselectnameunion.ItemIndex:=Form_formirateunion.iselectedunion;
                       end
                        else
                       begin
                          Form_formirateunion.cbbselectnameunion.ItemIndex:=0;
                       end;
                       Form_formirateunion.ShowModal;
                    end;
              's' : begin
                      if (source[itek].iunion>0) then
                       begin
                         // данный элемент уже принадлежит некоторому assembles.
                         // его надо вернуть на уровень ноль.
                         source[itek].iunion:=0;
                         source[itek].bvisible:=True; // возвращаем видимость исключенного элемента.
                         // возвращаем на нулевой уровень.
                         node2:=MainTreeView.Selected;
                         while (node2.Parent<>nil) do
                         begin  // ищем корень.
                            node2:=node2.Parent;
                         end;
                         MainTreeView.Items.Delete(MainTreeView.Selected);
                         NewNode:=MainTreeView.Items.Add(node2,source[itek].name);
                         NewNode.ImageIndex:=2;  // номер картинки источника
                         NewNode.SelectedIndex:=2; // номер картинки когда элемент выделен  (источник)
                         NewNode.Text:=source[itek].name;
                       end
                     else
                      begin
                         Form_formirateunion.cbbselectnameunion.Clear;
                         for i:=0 to lu-1 do
                         begin
                            Form_formirateunion.cbbselectnameunion.Items.Add(myassembles[i].name)
                         end;
                         if (Form_formirateunion.iselectedunion<lu) then
                         begin
                            Form_formirateunion.cbbselectnameunion.ItemIndex:=Form_formirateunion.iselectedunion;
                         end
                          else
                         begin
                            Form_formirateunion.cbbselectnameunion.ItemIndex:=0;
                         end;
                         Form_formirateunion.ShowModal;
                         MainTreeView.Items.Delete(MainTreeView.Selected);
                         Form_formirateunion.iselectedunion:=Form_formirateunion.cbbselectnameunion.ItemIndex;
                         source[itek].iunion:=Form_formirateunion.cbbselectnameunion.ItemIndex+1;
                         // при добавлении источника в юнион, видимость источника становится такая же как у юниона.
                         source[itek].bvisible:=myassembles[Form_formirateunion.cbbselectnameunion.ItemIndex].bVisible;
                         MainTreeView.Selected:=nil;   // снимем выделение с дерева.
                         // Найдём узел дерева который отвечает выбранному ассемблесу.
                         for i:=0 to MainTreeView.Items.Count-1 do
                         begin
                            if ((length(myassembles[Form_formirateunion.cbbselectnameunion.ItemIndex].name) = length(MainTreeView.Items.Item[i].Text)) and (Pos(myassembles[Form_formirateunion.cbbselectnameunion.ItemIndex].name,MainTreeView.Items.Item[i].Text)=1)) then
                            begin
                               node2:=MainTreeView.Items.Item[i];
                               Break;
                            end;
                         end;
                         // Создадим дочерний узел в выбранном ассемблесе.
                         if (node2 <>nil) then
                         begin
                            NewNode:=MainTreeView.Items.AddChild(node2,source[itek].name);
                            NewNode.ImageIndex:=2;  // номер картинки блока
                            NewNode.SelectedIndex:=2; // номер картинки когда элемент выделен  (блока)
                            NewNode.Text:=source[itek].name;
                         end;
                      end;
                    end;
              'w' : begin // стенка.
                      if (wall[itek].iunion>0) then
                       begin
                          // данный элемент уже принадлежит некоторому assembles.
                          // его надо вернуть на уровень ноль.
                          wall[itek].iunion:=0;
                          wall[itek].bvisible:=true; // возвращаем видимость исключенного элемента.
                          // возвращаем на нулевой уровень.
                          node2:=MainTreeView.Selected;
                          while (node2.Parent<>nil) do
                          begin  // ищем корень.
                             node2:=node2.Parent;
                          end;
                          MainTreeView.Items.Delete(MainTreeView.Selected);
                          NewNode:=MainTreeView.Items.Add(node2,wall[itek].name);
                          NewNode.ImageIndex:=3;  // номер картинки блока
                          NewNode.SelectedIndex:=3; // номер картинки когда элемент выделен  (блока)
                          NewNode.Text:=wall[itek].name;
                       end
                     else
                       begin
                          Form_formirateunion.cbbselectnameunion.Clear;
                          for i:=0 to lu-1 do
                          begin
                             Form_formirateunion.cbbselectnameunion.Items.Add(myassembles[i].name)
                          end;
                          if (Form_formirateunion.iselectedunion<lu) then
                          begin
                             Form_formirateunion.cbbselectnameunion.ItemIndex:=Form_formirateunion.iselectedunion;
                          end
                           else
                          begin
                             Form_formirateunion.cbbselectnameunion.ItemIndex:=0;
                          end;
                          Form_formirateunion.ShowModal;
                          MainTreeView.Items.Delete(MainTreeView.Selected);
                          Form_formirateunion.iselectedunion:=Form_formirateunion.cbbselectnameunion.ItemIndex;
                          wall[itek].iunion:=Form_formirateunion.cbbselectnameunion.ItemIndex+1;
                          // при добавлении стенки в юнион её видимость становится равной видимости юниона.
                          wall[itek].bvisible:=myassembles[Form_formirateunion.cbbselectnameunion.ItemIndex].bVisible;
                          MainTreeView.Selected:=nil;
                          for i:=0 to MainTreeView.Items.Count-1 do
                          begin
                             if ((length(myassembles[Form_formirateunion.cbbselectnameunion.ItemIndex].name) = length(MainTreeView.Items.Item[i].Text)) and (Pos(myassembles[Form_formirateunion.cbbselectnameunion.ItemIndex].name,MainTreeView.Items.Item[i].Text)=1)) then
                             begin
                                node2:=MainTreeView.Items.Item[i];
                                Break;
                             end;
                          end;

                          if (node2 <>nil) then
                          begin
                             NewNode:=MainTreeView.Items.AddChild(node2,wall[itek].name);
                             NewNode.ImageIndex:=3;  // номер картинки блока
                             NewNode.SelectedIndex:=3; // номер картинки когда элемент выделен  (блока)
                             NewNode.Text:=wall[itek].name;
                          end;
                       end;
                   end;
              end;
           end;
           ReadyPaint; // прорисовка геометрии
           Render;
       end;
   end;

end;

// Вращение геометрии даже в изометрии на 90 градусов вокруг оси OZ глобальной системы координат.
procedure TLaplas.btnrotateClick(Sender: TObject);
var
  a, b, c : Real;
  a1, b1, c1 : Real;
begin
  
   // Поворот на 90 градусов.
  // Alf:=Alf+1.5705;
   //if (Alf>3.141) then
   //begin
      //Alf:=Alf-3.141;
      //Alf:=-3.141+Alf;
     //--> Alf:=Alf-6.282;
   //end;

   // Поворот на 90 градусов вокруг оси Oz.
   Gam0:=Gam0+1.5705;
   if (Gam0> 3.141) then
   begin
      Gam0:=Gam0-6.282;
   end;

   (*
   // для нахождения Bet составим уравнение вида:
   // a*cos(Bet)+b*sin(Bet)+c=0;
   // Вычислим коэффициенты.
   a:=(1.0-Oxc)*sin(Alf)+(1.0-Oyc)*cos(Alf)+(1.0-Ozc);
   b:=-(1.0-Ozc)+(1.0-Oxc)*sin(Alf)+(1.0-Oyc)*cos(Alf);
   c:=(1.0-Oxc)*cos(Alf)-(1.0-Oyc)*sin(Alf);

   // Нахождение корня этого уравнения даст нам значение Bet.
   a1:=-3.141; b1:=3.140; c1:=0.0;
   while (b1-a1>0.001) do
   begin
      if ((a*cos(a1)+b*sin(a1)+c)*(a*cos(c1)+b*sin(c1)+c)<0.0) then
      begin
         b1:=c1;
         c1:=0.5*(a1+b1);
      end
       else
      begin
         a1:=c1;
         c1:=0.5*(a1+b1);
      end;
   end;

   Bet:=Bet+c1;
   if (Bet>3.141) then
   begin
      Bet:=Bet-3.141;
      Bet:=-3.141+Bet;
   end;
   //*)

   Render; // прорисовка геометрии
end;

procedure TLaplas.cbbviewChange(Sender: TObject);
begin
   case cbbview.ItemIndex of
      0 : begin
             // all
             lblvalue.Visible:=False;
             edtvalue.Visible:=False;
             ScrollBar1.Visible:=False;
             btndxf.Visible:=False;
             ComboBoxplaneViewSelect.Visible:=False;
             if (rgview.ItemIndex=0) then
             begin
                // изометия.
                Alf:=-0.96;
                Bet:=0.51;
             end;
          end;
      1 : begin
             // XY
             lblvalue.Visible:=True;
             edtvalue.Visible:=True;
             ScrollBar1.Visible:=True;
             ScrollBar1.Position:=50;
             edtvalue.Text:=FloatToStr(0.5*(body[0].zS+body[0].zE));
             btndxf.Visible:=True;
             ComboBoxplaneViewSelect.Visible:=True;
             if (rgview.ItemIndex=0) then
             begin
                //Alf:=-1.57;
                //Bet:=1.57;
                // Ориентация XOY.
                Alf:=0.0;  //X
                Bet:=0.0;  // Y
                Gam:=0.0;  // Z
             end;
          end;
      2 : begin
             // XZ
             lblvalue.Visible:=True;
             edtvalue.Visible:=True;
             ScrollBar1.Visible:=True;
             ScrollBar1.Position:=50;
             edtvalue.Text:=FloatToStr(0.5*(body[0].yS+body[0].yE));
             btndxf.Visible:=True;
             ComboBoxplaneViewSelect.Visible:=True;
             if (rgview.ItemIndex=0) then
             begin
                //  Alf:=-1.57;
                // Bet:=0.0;
                // Ориентация XOZ.
                Alf:=-0.5*3.141;
                Bet:=0.0;
                Gam:=0.0;
             end;
          end;
      3 : begin
             // YZ
             lblvalue.Visible:=True;
             edtvalue.Visible:=True;
             ScrollBar1.Visible:=True;
             ScrollBar1.Position:=50;
             edtvalue.Text:=FloatToStr(0.5*(body[0].xS+body[0].xE));
             btndxf.Visible:=True;
             ComboBoxplaneViewSelect.Visible:=True;
             if (rgview.ItemIndex=0) then
             begin
                //Alf:=0.0;
                //Bet:=0.0;
                // Ориентация YOZ.
                Alf:=0.0;
                Bet:=0.5*3.141;
                Gam:=0.0;
             end;
          end;
   end;
   cosAlf:=cos(Alf);
   cosBet:=cos(Bet);
   sinAlf:=sin(Alf);
   sinBet:=sin(Bet);
   Render; // прорисовка геометрии
end;

// Введены координаты сечения.
// bug06
procedure TLaplas.btnapplyClick(Sender: TObject);
var
   c : Real;
   code, iisoscan : Integer;
   sforval,striso : String;
begin
  sforval:='';
  sforval:=StringReplace(edtvalue.Text,',','.',[rfReplaceAll]);
   val(sforval,c,code);
  //val(edtvalue.Text,c,code);
  if (code<>0) then
  begin
     // введено некоректное значение iso значения.
     case cbbview.ItemIndex of
        1 : // XY
           begin
              edtvalue.Text:=FloatToStr(0.5*(body[0].zS+body[0].zE));
           end;
        2 : // XZ
           begin
              edtvalue.Text:=FloatToStr(0.5*(body[0].yS+body[0].yE));
           end;
        3 : // YZ
           begin
              edtvalue.Text:=FloatToStr(0.5*(body[0].xS+body[0].xE));
           end;
     end;
  end
  else
  begin
     // Всё в порядке значение корректное но оно должно лежать в пределах
     // кабинета.
     case cbbview.ItemIndex of
        1 : // XY
           begin
              if (c > body[0].zE) then
              begin
                 c:= body[0].zE - 0.01*(body[0].zE-body[0].zS);
              end;
              if (c < body[0].zS) then
              begin
                 c:= body[0].zS + 0.01*(body[0].zE-body[0].zS);
              end;
           end;
        2 : // XZ
           begin
               if (c > body[0].yE) then
              begin
                 c:= body[0].yE - 0.01*(body[0].yE-body[0].yS);
              end;
              if (c < body[0].yS) then
              begin
                 c:= body[0].yS + 0.01*(body[0].yE-body[0].yS);
              end;
           end;
        3 : // YZ
           begin
               if (c > body[0].xE) then
              begin
                 c:= body[0].xE - 0.01*(body[0].xE-body[0].xS);
              end;
              if (c < body[0].xS) then
              begin
                 c:= body[0].xS + 0.01*(body[0].xE-body[0].xS);
              end;
           end;
     end;
  end;
  if (bvisiblepic) then
  begin
     striso:=Trim(edtvalue.Text);
     for iisoscan:=1 to length(striso) do
     begin
        if (FormatSettings.DecimalSeparator=',') then
        begin
           if (striso[iisoscan]='.') then striso[iisoscan]:=',';
        end;
        if (FormatSettings.DecimalSeparator='.') then
        begin
           if (striso[iisoscan]=',') then striso[iisoscan]:='.';
        end;
     end;
     edtvalue.Text:=striso;

     sforval:='';
     sforval:=StringReplace(edtvalue.Text,',','.',[rfReplaceAll]);
     val(sforval,c,code);
     //val(edtvalue.Text,c,code);
     if (code=0) then
     begin
        risopic:=StrToFloat(edtvalue.Text);
     end
      else
     begin
        ShowMessage('Error! Incorrect iso value...');
        edtvalue.Text:='0.0';
     end;
  end;

   // прорисовка после внесения изменеий.
   ReadyPaint;
   Render; // прорисовка геометрии
end;

(*
// EXPORT to SYMMIC не поддерживается начиная с 23 октября 2016.
// Создаёт файл входных данных для программы SYMMIC
// начало разработки 27 января 2014.
procedure TLaplas.ExportSYMMIC1Click(Sender: TObject);
const epsilon=1.0e-10; // точность с которой равны два вещественных числа.
var
   filename, titlename : string; // имя записываемого файла
   f : TStringList; // переменная типа объект TStringList
   s,sbuf : String; // текущая рабочая строка
   i,i1,isize, istart, iend : Integer; // текущий номер блока или источника при записи
   fbuf, xbuf, ybuf, zbuf : array of Real;
   bOk, bfind : Boolean;
   rdelta : Real;
   ierror, iwarning : Integer; // количество ошибок при записи файла.
   intervalcount : Integer;
   maxlength, tolerance : Real; // запомним максимальное значение интервала и
   // терпимость в 10% 0.1, если отношение длины интервала к максимальному интервалу меньше 10% то
   // количество разбиений на таком маленьком интервалеравно 5.

// Возвращает строковый индекс слоя.
// работает для не более чем 100 слоёв (этого должно хватить).
function getid2string(id : Integer) : String;
var
   s : string;
begin
   s:='';
   case id of
    0 : begin
           s:='00';
        end;
    1..9 : begin
           s:='0'+IntToStr(id);
        end;
    10..99 : begin
               s:=IntToStr(id);
            end;
    100..10000 : begin
                   s:=IntToStr(id);
                end;
   end;
   getid2string:=s;
end;

begin
   tolerance:=0.05+0.05*Formexport2SYMMIC.cbbtol.ItemIndex; // для построения сетки см. объявление выше.
   ierror:=0;
   iwarning:=0;

   // записывает файл с постановкой задачи для программы SYMMIC.
   filename:='';
   titlename:='';

   Formexport2SYMMIC.ShowModal;
   filename:=Formexport2SYMMIC.edtname.Text; // имя файла без расширения.
   titlename:=Formexport2SYMMIC.edttitle.Text; // имя заголовка.
   if ((Length(filename)>0) and (Length(titlename)>0)) then
   begin

      f:=TStringList.Create();  // выделение памяти

      // печать заголовка.
      s:='<?xml version="1.0"?>';
      f.Add(s);
      s:='<!DOCTYPE Template SYSTEM "template_format.dtd">';
      f.Add(s);
      s:='<Template title="'+titlename+'">';
      f.Add(s);

      // Дальше печатаются 8 разделов для SYMMIC

      // Секция параметров моделирования.
      // Parameters :
      //-->//s:='<Parameters> ';
      // В этой секции можно определить параметры
      // параметризующие геометрию модели.
      // На начальном этапе оставим эту секцию пустой.

      // Приведём пример возможного шаблона.

      //s:=s+'<AParam id="P1"  name="Number of Source" value="125"';
      //s:=s+'min="50" max="200" units="microns" type="Source Lengths"';
      //s:=s+'description="Length of the heat source"'

      //-->//s:=s+'</Parameters>';
      //f.Add(s);


      // Points :
      isize:=0;
      SetLength(fbuf,isize);
      // пропускаем кабинет.
      for i:=1 to (lb-1) do
      begin
         bfind:=False;
         bOk:=True;
         body[i].xS:=FormVariables.my_real_convert(Trim(body[i].sxS),bOk);
         for i1:=0 to (isize-1) do
         begin
            if (abs(fbuf[i1]-body[i].xS)<epsilon) then
            begin
               // найдена уникальная позиция в массиве.
               bfind:=True;
            end;
         end;
         if (not(bfind)) then
         begin
            // позиция уникальна, значит мы добавляем позицию.
            inc(isize);
            SetLength(fbuf,isize);
            fbuf[isize-1]:=body[i].xS;
         end;
         bfind:=False;
         bOk:=True;
         body[i].xE:=FormVariables.my_real_convert(Trim(body[i].sxE),bOk);
         for i1:=0 to (isize-1) do
         begin
            if (abs(fbuf[i1]-body[i].xE)<epsilon) then
            begin
               // найдена уникальная позиция в массиве.
               bfind:=True;
            end;
         end;
         if (not(bfind)) then
         begin
            // позиция уникальна, значит мы добавляем позицию.
            inc(isize);
            SetLength(fbuf,isize);
            fbuf[isize-1]:=body[i].xE;
         end;
      end;
      // источники
      for i:=0 to (ls-1) do
      begin
         if (source[i].iPlane=1 ) then
         begin
            // только если источник лежит в плоскости XY
            // 1 - XY

            bfind:=False;
            bOk:=True;
            source[i].xS:=FormVariables.my_real_convert(Trim(source[i].sxS),bOk);
            for i1:=0 to (isize-1) do
            begin
               if (abs(fbuf[i1]-source[i].xS)<epsilon) then
               begin
                  // найдена уникальная позиция в массиве.
                  bfind:=True;
               end;
            end;
            if (not(bfind)) then
            begin
               // позиция уникальна, значит мы добавляем позицию.
               inc(isize);
               SetLength(fbuf,isize);
               fbuf[isize-1]:=source[i].xS;
            end;
            bfind:=False;
            bOk:=True;
            source[i].xE:=FormVariables.my_real_convert(Trim(source[i].sxE),bOk);
            for i1:=0 to (isize-1) do
            begin
               if (abs(fbuf[i1]-source[i].xE)<epsilon) then
               begin
                  // найдена уникальная позиция в массиве.
                  bfind:=True;
               end;
            end;
            if (not(bfind)) then
            begin
               // позиция уникальна, значит мы добавляем позицию.
               inc(isize);
               SetLength(fbuf,isize);
               fbuf[isize-1]:=source[i].xE;
            end;
         end
          else
         begin
             MainMemo.Lines.Add('Error export SYMMIC! Plane source is not XY');
             Inc(ierror);
         end;
      end;
      // твёрдые стенки.
      for i:=0 to (lw-1) do
      begin
         if (wall[i].iPlane=1 ) then
         begin
         //1 - XY
            // только если источник лежит в плоскости XY

            bfind:=False;
            bOk:=True;
            wall[i].xS:=FormVariables.my_real_convert(Trim(wall[i].sxS),bOk);
            for i1:=0 to (isize-1) do
            begin
               if (abs(fbuf[i1]-wall[i].xS)<epsilon) then
               begin
                  // найдена уникальная позиция в массиве.
                  bfind:=True;
               end;
            end;
            if (not(bfind)) then
            begin
               // позиция уникальна, значит мы добавляем позицию.
               inc(isize);
               SetLength(fbuf,isize);
               fbuf[isize-1]:=wall[i].xS;
            end;
            bfind:=False;
            bOk:=True;
            wall[i].xE:=FormVariables.my_real_convert(Trim(wall[i].sxE),bOk);
            for i1:=0 to (isize-1) do
            begin
               if (abs(fbuf[i1]-wall[i].xE)<epsilon) then
               begin
                  // найдена уникальная позиция в массиве.
                  bfind:=True;
               end;
            end;
            if (not(bfind)) then
            begin
               // позиция уникальна, значит мы добавляем позицию.
               inc(isize);
               SetLength(fbuf,isize);
               fbuf[isize-1]:=wall[i].xE;
            end;
         end
          else
         begin
             MainMemo.Lines.Add('Error export SYMMIC! Plane wall is not XY');
             Inc(ierror);
         end;
      end;

      // сортировка по возрастанию.
      for i:=(isize-1) downto 1 do
      begin
         for i1:=0 to (i-1) do
         begin
            if (fbuf[i1]>fbuf[i1+1]) then
            begin
               rdelta:=fbuf[i1];
               fbuf[i1]:=fbuf[i1+1];
               fbuf[i1+1]:=rdelta;
            end;
         end;
      end;


      SetLength(xbuf,isize);
      for i:=0 to isize-1 do
      begin
         xbuf[i]:=fbuf[i];
      end;
      maxlength:=-1;
       for i:=1 to isize-1 do
      begin
         if ((fbuf[i]-fbuf[i-1]) > maxlength) then
         begin
            maxlength:=fbuf[i]-fbuf[i-1];
         end;
      end;


      intervalcount:=5+(Formexport2SYMMIC.cbbnx.ItemIndex)*5;

      s:='<Points> ';
      f.Add(s);
      for i:=1 to (isize-1) do
      begin
         // если единицы длины микроны.
         rdelta:=fbuf[i]-fbuf[i-1];
         // перевод в микроны.
         case ComboBoxlength.ItemIndex of
         0 : begin
                // метры.
                rdelta:=1.0e6*rdelta;
             end;
         1 : begin
                // мм.
                rdelta:=1.0e3*rdelta;
             end;
         2 : begin
                // micron.
                rdelta:=1.0*rdelta;
             end;
         end;
         // количество сеточных интервалов между точками равно 5.
         if (((fbuf[i]-fbuf[i-1])/maxlength) <tolerance) then
         begin
            // слишком короткий интервал.
            s:='<RefX delta="'+FloatToStr(rdelta)+'" refn="5" bias="1"/>';
         end
         else
         begin
            s:='<RefX delta="'+FloatToStr(rdelta)+'" refn="'+IntToStr(intervalcount)+'" bias="1"/>';
         end;
         f.Add(s);
      end;


      isize:=0;
      SetLength(fbuf,isize);
      for i:=1 to (lb-1) do
      begin
         bfind:=False;
         bOk:=True;
         body[i].yS:=FormVariables.my_real_convert(Trim(body[i].syS),bOk);
         for i1:=0 to (isize-1) do
         begin
            if (abs(fbuf[i1]-body[i].yS)<epsilon) then
            begin
               // найдена уникальная позиция в массиве.
               bfind:=True;
            end;
         end;
         if (not(bfind)) then
         begin
            // позиция уникальна, значит мы добавляем позицию.
            inc(isize);
            SetLength(fbuf,isize);
            fbuf[isize-1]:=body[i].yS;
         end;
         bfind:=False;
         bOk:=True;
         body[i].yE:=FormVariables.my_real_convert(Trim(body[i].syE),bOk);
         for i1:=0 to (isize-1) do
         begin
            if (abs(fbuf[i1]-body[i].yE)<epsilon) then
            begin
               // найдена уникальная позиция в массиве.
               bfind:=True;
            end;
         end;
         if (not(bfind)) then
         begin
            // позиция уникальна, значит мы добавляем позицию.
            inc(isize);
            SetLength(fbuf,isize);
            fbuf[isize-1]:=body[i].yE;
         end;
      end;
      // источники
      for i:=0 to (ls-1) do
      begin
         if (source[i].iPlane=1 ) then
         begin
            //  1 - XY

            // только если источник лежит в плоскости XY

            bfind:=False;
            bOk:=True;
            source[i].yS:=FormVariables.my_real_convert(Trim(source[i].syS),bOk);
            for i1:=0 to (isize-1) do
            begin
               if (abs(fbuf[i1]-source[i].yS)<epsilon) then
               begin
                  // найдена уникальная позиция в массиве.
                  bfind:=True;
               end;
            end;
            if (not(bfind)) then
            begin
               // позиция уникальна, значит мы добавляем позицию.
               inc(isize);
               SetLength(fbuf,isize);
               fbuf[isize-1]:=source[i].yS;
            end;
            bfind:=False;
            bOk:=True;
            source[i].yE:=FormVariables.my_real_convert(Trim(source[i].syE),bOk);
            for i1:=0 to (isize-1) do
            begin
               if (abs(fbuf[i1]-source[i].yE)<epsilon) then
               begin
                  // найдена уникальная позиция в массиве.
                  bfind:=True;
               end;
            end;
            if (not(bfind)) then
            begin
               // позиция уникальна, значит мы добавляем позицию.
               inc(isize);
               SetLength(fbuf,isize);
               fbuf[isize-1]:=source[i].yE;
            end;
         end
          else
         begin
             MainMemo.Lines.Add('Error export SYMMIC! Plane source is not XY');
             Inc(ierror);
         end;
      end;
      // твёрдые стенки.
      for i:=0 to (lw-1) do
      begin
         if (wall[i].iPlane=1 ) then
         begin
            //1 - XY

            // только если источник лежит в плоскости XY

            bfind:=False;
            bOk:=True;
            wall[i].yS:=FormVariables.my_real_convert(Trim(wall[i].syS),bOk);
            for i1:=0 to (isize-1) do
            begin
               if (abs(fbuf[i1]-wall[i].yS)<epsilon) then
               begin
                  // найдена уникальная позиция в массиве.
                  bfind:=True;
               end;
            end;
            if (not(bfind)) then
            begin
               // позиция уникальна, значит мы добавляем позицию.
               inc(isize);
               SetLength(fbuf,isize);
               fbuf[isize-1]:=wall[i].yS;
            end;
            bfind:=False;
            bOk:=True;
            wall[i].yE:=FormVariables.my_real_convert(Trim(wall[i].syE),bOk);
            for i1:=0 to (isize-1) do
            begin
               if (abs(fbuf[i1]-wall[i].yE)<epsilon) then
               begin
                  // найдена уникальная позиция в массиве.
                  bfind:=True;
               end;
            end;
            if (not(bfind)) then
            begin
               // позиция уникальна, значит мы добавляем позицию.
               inc(isize);
               SetLength(fbuf,isize);
               fbuf[isize-1]:=wall[i].yE;
            end;
         end
          else
         begin
             MainMemo.Lines.Add('Error export SYMMIC! Plane wall is not XY');
             Inc(ierror);
         end;
      end;

      // сортировка по возрастанию.
      for i:=(isize-1) downto 1 do
      begin
         for i1:=0 to (i-1) do
         begin
            if (fbuf[i1]>fbuf[i1+1]) then
            begin
               rdelta:=fbuf[i1];
               fbuf[i1]:=fbuf[i1+1];
               fbuf[i1+1]:=rdelta;
            end;
         end;
      end;

      SetLength(ybuf,isize);
      for i:=0 to isize-1 do
      begin
         ybuf[i]:=fbuf[i];
      end;

      intervalcount:=5+(Formexport2SYMMIC.cbbny.ItemIndex)*5;

      maxlength:=-1;
      for i:=1 to isize-1 do
      begin
         if ((fbuf[i]-fbuf[i-1]) > maxlength) then
         begin
            maxlength:=fbuf[i]-fbuf[i-1];
         end;
      end;

      // формирование разбиения по оси Oy.
      for i:=1 to (isize-1) do
      begin
         // если единицы длины микроны.
         rdelta:=fbuf[i]-fbuf[i-1];
         // перевод в микроны.
         case ComboBoxlength.ItemIndex of
         0 : begin
                // метры.
                rdelta:=1.0e6*rdelta;
             end;
         1 : begin
                // мм.
                rdelta:=1.0e3*rdelta;
             end;
         2 : begin
                // micron.
                rdelta:=1.0*rdelta;
             end;
         end;
         // количество сеточных интервалов между точками равно 5.
         if (((fbuf[i]-fbuf[i-1])/maxlength) <tolerance) then
         begin
            s:='<RefY delta="'+FloatToStr(rdelta)+'" refn="5" bias="1"/>';
         end
         else
         begin
            s:='<RefY delta="'+FloatToStr(rdelta)+'" refn="'+IntTostr(intervalcount)+'" bias="1"/>';
         end;
         f.Add(s);
      end;
      //FormVariables.my_real_convert(sub,bOk);


      s:='</Points>';
      f.Add(s);
      // ZLayers :

      // Источники тепла располагаются при Zmax>Zmin.
      isize:=0;
      SetLength(fbuf,isize);
      // Кабинет мы игнорируем.
      for i:=1 to (lb-1) do
      begin
         bfind:=False;
         bOk:=True;
         body[i].zS:=FormVariables.my_real_convert(Trim(body[i].szS),bOk);
         for i1:=0 to (isize-1) do
         begin
            if (abs(fbuf[i1]-body[i].zS)<epsilon) then
            begin
               // найдена уникальная позиция в массиве.
               bfind:=True;
            end;
         end;
         if (not(bfind)) then
         begin
            // позиция уникальна, значит мы добавляем позицию.
            inc(isize);
            SetLength(fbuf,isize);
            fbuf[isize-1]:=body[i].zS;
         end;
         bfind:=False;
         bOk:=True;
         body[i].zE:=FormVariables.my_real_convert(Trim(body[i].szE),bOk);
         for i1:=0 to (isize-1) do
         begin
            if (abs(fbuf[i1]-body[i].zE)<epsilon) then
            begin
               // найдена уникальная позиция в массиве.
               bfind:=True;
            end;
         end;
         if (not(bfind)) then
         begin
            // позиция уникальна, значит мы добавляем позицию.
            inc(isize);
            SetLength(fbuf,isize);
            fbuf[isize-1]:=body[i].zE;
         end;
      end;
      // источники
      for i:=0 to (ls-1) do
      begin
         if (source[i].iPlane=1 ) then
         begin
            // только если источник лежит в плоскости XY
            // 1 - XY

            bfind:=False;
            bOk:=True;
            source[i].zS:=FormVariables.my_real_convert(Trim(source[i].szS),bOk);
            for i1:=0 to (isize-1) do
            begin
               if (abs(fbuf[i1]-source[i].zS)<epsilon) then
               begin
                  // найдена уникальная позиция в массиве.
                  bfind:=True;
               end;
            end;
            if (not(bfind)) then
            begin
               // позиция уникальна, значит мы добавляем позицию.
               inc(isize);
               SetLength(fbuf,isize);
               fbuf[isize-1]:=source[i].zS;
            end;
         end
          else
         begin
             MainMemo.Lines.Add('Error export SYMMIC! Plane source is not XY');
             Inc(ierror);
         end;
      end;
      // твёрдые стенки.
      for i:=0 to (lw-1) do
      begin
         if (wall[i].iPlane=1 ) then
         begin
            //1 - XY

            // только если источник лежит в плоскости XY

            bfind:=False;
            bOk:=True;
            wall[i].zS:=FormVariables.my_real_convert(Trim(wall[i].szS),bOk);
            for i1:=0 to (isize-1) do
            begin
               if (abs(fbuf[i1]-wall[i].zS)<epsilon) then
               begin
                  // найдена уникальная позиция в массиве.
                  bfind:=True;
               end;
            end;
            if (not(bfind)) then
            begin
               // позиция уникальна, значит мы добавляем позицию.
               inc(isize);
               SetLength(fbuf,isize);
               fbuf[isize-1]:=wall[i].zS;
            end;
         end
          else
         begin
             MainMemo.Lines.Add('Error export SYMMIC! Plane wall is not XY');
             Inc(ierror);
         end;
      end;

      // сортировка по возрастанию.
      for i:=(isize-1) downto 1 do
      begin
         for i1:=0 to (i-1) do
         begin
            if (fbuf[i1]>fbuf[i1+1]) then
            begin
               rdelta:=fbuf[i1];
               fbuf[i1]:=fbuf[i1+1];
               fbuf[i1+1]:=rdelta;
            end;
         end;
      end;

      SetLength(zbuf,isize);
      for i:=0 to isize-1 do
      begin
         zbuf[i]:=fbuf[i];
      end;

      intervalcount:=5+(Formexport2SYMMIC.cbbnz.ItemIndex)*5;

      maxlength:=-1;
      for i:=1 to isize-1 do
      begin
         if ((fbuf[i]-fbuf[i-1]) > maxlength) then
         begin
            maxlength:=fbuf[i]-fbuf[i-1];
         end;
      end;


      s:='<ZLayers> ';
      f.Add(s);

      // формирование разбиения по оси Oy.
      for i:=1 to (isize-1) do
      begin
         // если единицы длины микроны.
         rdelta:=fbuf[i-1];
         // перевод в микроны.
         case ComboBoxlength.ItemIndex of
         0 : begin
                // метры.
                rdelta:=1.0e6*rdelta;
             end;
         1 : begin
                // мм.
                rdelta:=1.0e3*rdelta;
             end;
         2 : begin
                // micron.
                rdelta:=1.0*rdelta;
             end;
         end;
         // количество сеточных интервалов между точками равно 5.
         s:='<Layer id="layer'+getid2string(i-1)+'" begin="'+FloatToStr(rdelta)+'"';
         // если единицы длины микроны.
         rdelta:=fbuf[i];
         // перевод в микроны.
         case ComboBoxlength.ItemIndex of
         0 : begin
                // метры.
                rdelta:=1.0e6*rdelta;
             end;
         1 : begin
                // мм.
                rdelta:=1.0e3*rdelta;
             end;
         2 : begin
                // micron.
                rdelta:=1.0*rdelta;
             end;
         end;
         if (((fbuf[i]-fbuf[i-1])/maxlength) <tolerance) then
         begin
            s:=s+' end="'+FloatToStr(rdelta)+'" refn="5" bias="1"/>';
         end
          else
         begin
            s:=s+' end="'+FloatToStr(rdelta)+'" refn="'+IntToStr(intervalcount)+'" bias="1"/>';
         end;
         f.Add(s);
      end;
      //FormVariables.my_real_convert(sub,bOk);

      s:='</ZLayers>';
      f.Add(s);

      //xbuf, ybuf и zbuf - сохраняются для формирования секции Device.

      // Materials :
      // Материалы возможно свойства которых зависят от температуры.
      // Пока перечислим только материалы с постоянными свойствами.
      //(Цвета присваиваются произвольно).

      s:='<Materials> ';
      f.Add(s);
      for i:=0 to lmatmax-1 do
      begin
         // Все материалы в данном программном интерфейсе задаются
         // в единицах СИ. Здесь осуществляется перевод в единицы
         // которые использует программа SYMMIC автоматическим образом.
         // Записываются иолько материалы используемые пользователем в
         // текущей постановке задач.
         if (Laplas.workmat[i].blibmat=0) then
         begin
            // только пользовательский материал (blibmat=0).
            s:='<AMaterial id="'+Laplas.workmat[i].namemat+'" description="'+Laplas.workmat[i].namemat+'" ';
            f.Add(s);
            s:='color="250 250 '+IntToStr(Min(10+i*10,250))+'" '; // Цвет материала случайный.
            s:=s+'conductivity="'+FloatToStr(1.0e-6*Laplas.workmat[i].lambda)+' 300" '; // Вт/(мкм*К)
            s:=s+'capacity="'+FloatToStr(1e-3*Laplas.workmat[i].cp)+' 300" '; // Дж/(мг*К)
            s:=s+'density="'+FloatToStr(1.0e-12*Laplas.workmat[i].rho)+' 300" ';  // мг/мкм!3
            s:=s+'/>';
            f.Add(s);
         end
          else
         begin
            if (Laplas.workmat[i].blibmat=1) then
            begin
               case (Laplas.workmat[i].ilibident-101) of
                0 : begin
                       // AuSn
                       s:='<AMaterial description="Solder (80% Au)" id="AuSn" ';
                       s:=s+' density="1.5e-008 300" capacity="0.00015 300" ';
                       s:=s+' conductivity="5.5e-005 300" color="151 159 119" />';
                       f.Add(s);
                    end;
                1 : begin
                       //Si
                       s:='<AMaterial description="Silicon" id="Si" ';
                       s:=s+'density="2.33e-009 300" ';
                       s:=s+' capacity="0.00018 77, 0.00049 173, 0.00068 273, 0.0007 300, ';
                       s:=s+'0.00077 373, 0.00085 573, 0.00088 773" ';
                       s:=s+' conductivity="0.000266 200, ';
                       s:=s+' 0.000156 300, 0.000105 400, 8e-005 500, ';
                       s:=s+' 6.4e-005 600, 5.2e-005 700, 4.3e-005 800" ';
                       s:=s+' color="137 165 165" />';
                       f.Add(s);
                    end;
                2 : begin
                       // GaAs
                       s:='<AMaterial id="GaAs" description="Gallium Arsenide" color="112 128 141" ';
                       s:=s+'conductivity="6.46e-005 200, ';
                       s:=s+'4.15e-005 300, ';
                       s:=s+'3.8e-005 325, ';
                       s:=s+'3.51e-005 350, ';
                       s:=s+'3.25e-005 375, ';
                       s:=s+'3.03e-005 400, ';
                       s:=s+'2.67e-005 450, ';
                       s:=s+'2.38e-005 500, ';
                       s:=s+'1.95e-005 600, ';
                       s:=s+'1.65e-005 700, ';
                       s:=s+'1.43e-005 800" ';
                       s:=s+'capacity="0.000325 300" ';
                       s:=s+'density="5.316e-009 300" ';
                       s:=s+'/>';
                       f.Add(s);
                    end;
                3 : begin
                       // GaN
                       s:='<AMaterial description="Gallium Nitride" ';
                       s:=s+'id="GaN" density="6.15e-009 300" ';
                       s:=s+'capacity="0.00049 300" ';
                       s:=s+'conductivity="0.000268 200, 0.00015 300, ';
                       s:=s+' 0.000134 325, 0.00012 350, 0.000109 375, ';
                       s:=s+' 9.9e-005 400, 8.4e-005 450, 7.2e-005 500, ';
                       s:=s+' 5.6e-005 600, 4.5e-005 700, 3.7e-005 800" ';
                       s:=s+' color="100 150 125" />';
                       f.Add(s);
                    end;
                4 : begin
                       // SiC4H
                       s:='<AMaterial id="SiC4H" description="Silicon Carbide" ';
                       s:=s+'color="203 153 3" isotropic="false" ';
                       s:=s+'conductivity="0.000863 0.000863 0.00068 200, ';
                       s:=s+'0.00047 0.00047 0.00037 300, ';
                       s:=s+'0.000417 0.000417 0.000328 325, ';
                       s:=s+'0.000373 0.000373 0.000294 350, ';
                       s:=s+'0.000336 0.000336 0.000265 375, ';
                       s:=s+'0.000305 0.000305 0.00024 400, ';
                       s:=s+'0.000256 0.000256 0.000201 450, ';
                       s:=s+'0.000218 0.000218 0.000172 500, ';
                       s:=s+'0.000166 0.000166 0.000131 600, ';
                       s:=s+'0.000132 0.000132 0.000104 700, ';
                       s:=s+'0.000108 0.000108 8.5e-005 800" ';
                       s:=s+'capacity="0.00005 77 ,0.00067 300,';
                       s:=s+' 0.00082 373, 0.00101 573, 0.00112 773" ';
                       s:=s+' density="3.2e-009 300" ';
                       s:=s+'/>';
                       f.Add(s);
                    end;
                5 : begin
                       // Sapphire
                       s:='<AMaterial description="Al2O3" id="Sapphire" ';
                       s:=s+'density="3.97e-009 300" ';
                       s:=s+'capacity="0.00006 77, 0.000403 173, 0.000718 273, 0.000765 300, ';
                       s:=s+'0.000907 373, 0.001089 573, 0.001168 773" ';
                       s:=s+' conductivity="4.2e-005 298, 3.2e-005 373, 2e-005 573,';
                       s:=s+' 1.3e-005 773" color="8 37 103" />';
                       f.Add(s);
                    end;
                6 : begin
                       // CVD Diamond
                       s:='<AMaterial description="CVD Diamond" id="Diamond" ';
                       s:=s+'density="3.515e-009 300" ';
                       s:=s+'capacity="0.000008 77, 0.00014 173, 0.00042 273, 0.00052 300, ';
                       s:=s+'0.00077 373, 0.0013 573, 0.00159 773" ';
                       s:=s+'conductivity="0.00125 300, 0.0011 360, 0.00102 420,';
                       s:=s+' 0.00095 480" color="5 24 69" />';
                       f.Add(s);
                    end;
                7 : begin
                       // МД40
                       s:='<AMaterial id="MD40" description="Molybdenum Copper (60% Mo)" ';
                       s:=s+'color="219 191 166" ';
                       s:=s+'conductivity="0.00021 300" ';
                       s:=s+'capacity="0.000305 300" ';
                       s:=s+'density="9.6e-009 300" ';
                       s:=s+'/>';
                       f.Add(s);
                    end;
                8 : begin
                       // Au
                       s:='<AMaterial id="Au" description="Pure Gold" color="255 215 0" ';
                       s:=s+'conductivity="0.000323 200, ';
                       s:=s+'0.000317 300, ';
                       s:=s+'0.000311 400, ';
                       s:=s+'0.000304 500, ';
                       s:=s+'0.000298 600, ';
                       s:=s+'0.000284 800" ';
                       s:=s+'capacity="0.000124 200, ';
                       s:=s+'0.000129 300, ';
                       s:=s+'0.000131 400, ';
                       s:=s+'0.000133 500, ';
                       s:=s+'0.000135 600, ';
                       s:=s+'0.00014 800" ';
                       s:=s+'density="1.93e-008 300" ';
                       s:=s+'/>';
                       f.Add(s);
                    end;
                9 : begin
                       // SiO2
                       s:='<AMaterial id="SiO2" description="Silicon Dioxide" color="183 183 180" ';
                       s:=s+'conductivity="1.6e-6 298, ';
                       s:=s+'1.7e-6 373, ';
                       s:=s+'2.1e-6 773" ';
                       s:=s+'capacity="700.0e-6 273, ';
                       s:=s+'830.0e-6 373, ';
                       s:=s+'1020.0e-6 573, ';
                       s:=s+'1110.0e-6 773" ';
                       s:=s+'density="2.1e-9 300" ';
                       s:=s+'/>';
                       f.Add(s);
                    end;
                10 : begin
                       // Cu
                       s:='<AMaterial description="Pure Copper" id="Cu" ';
                       s:=s+'density="8.933e-009 300" capacity="0.000356 200,';
                       s:=s+' 0.000385 300, 0.000397 400, 0.000412 500, ';
                       s:=s+'0.000417 600, 0.000433 800" ';
                       s:=s+' conductivity="0.000413 200, ';
                       s:=s+'0.000401 300, 0.000393 400, ';
                       s:=s+'0.000386 500, 0.000379 600, ';
                       s:=s+'0.000366 800" color="184 115 51" />';
                       f.Add(s);
                    end;
                11 : begin
                        // Kovar
                        s:='<AMaterial id="Kovar" description="Kovar(R) Alloy" color="228 0 64" ';
                        s:=s+'conductivity="1.41e-005 273, ';
                        s:=s+'1.47e-5 373, 1.56e-5 573, ';
                        s:=s+'1.75e-5 773, 1.93e-5 973" ';
                        s:=s+'capacity="0.000439 300" ';
                        s:=s+'density="8.36e-009 300" ';
                        s:=s+'/>';
                        f.Add(s);
                     end;
                12 : begin
                        //  Brass LS 59-1-L
                        s:='<AMaterial id="BrassLS59_1_L" description="Brass LS 59 1 L" color="183 183 200" ';
                        s:=s+'conductivity="108.784e-6 300" ';
                        s:=s+'capacity="200.0e-6 77, 340.0e-6 173, 387.0e-6 273, 390.0e-6 373, 448.0e-6 573" ';
                        s:=s+'density="8.5e-9 300" ';
                        s:=s+'/>';
                        f.Add(s);
                     end;
                13 : begin
                        // Al-Duralumin
                        s:='<AMaterial id="Al_Duralumin" description="Al Duralumin" color="183 183 204" ';
                        s:=s+'conductivity="164.0e-6 300" ';
                        s:=s+'capacity="480.0e-6 300" ';
                        s:=s+'density="2.8e-9 300" ';
                        s:=s+'/>';
                        f.Add(s);
                     end;
                14 : begin
                        // Glue ECHES
                        s:='<AMaterial id="GlueECHES" description="Glue ECHES" color="193 208 230" ';
                        s:=s+'conductivity="4.0e-6 300" ';
                        s:=s+'capacity="0.0001 300" ';
                        s:=s+'density="1.0e-9 300" ';
                        s:=s+'/>';
                        f.Add(s);
                     end;
               end;
            end
            else
            begin
               MainMemo.Lines.Add('Error export ! Unknown material.');
               Inc(ierror);
            end;
         end;
      end;
      s:='</Materials>';
      f.Add(s);
      // Device :
      s:='<Device> ';
      f.Add(s);

      // В этой секции описано взаимодействие секций
      // Points, Layers и Materials так чтобы они составляли единое устройство.

      // проход по всем блокам.
      for i:=1 to lb-1 do
      begin
         // кабинет и hollow (fluid) block игнорируются.
         if (body[i].itype= 1) then
         begin
            // Т.к. в программу могут быть введены переменные то
            // конкретные числовые значения размеров вычисляются на лету.
            bOk:=True;
            body[i].zS:=FormVariables.my_real_convert(body[i].szS,bOk);
            bOk:=True;
            body[i].zE:=FormVariables.my_real_convert(body[i].szE,bOk);
            if (body[i].zE<body[i].zS) then
            begin
               // коррдината начала всегда меньше координаты конца.
               rdelta:=body[i].zS;
               body[i].zS:=body[i].zE;
               body[i].zE:=rdelta;
               sbuf:=body[i].szS;
               body[i].szS:=body[i].szE;
               body[i].szE:=sbuf;
               MainMemo.Lines.Add('warning : zE< zS');
               inc(iwarning);
            end;
            bOk:=True;
            body[i].xS:=FormVariables.my_real_convert(body[i].sxS,bOk);
            bOk:=True;
            body[i].xE:=FormVariables.my_real_convert(body[i].sxE,bOk);
            if (body[i].xE<body[i].xS) then
            begin
               // коррдината начала всегда меньше координаты конца.
               rdelta:=body[i].xS;
               body[i].xS:=body[i].xE;
               body[i].xE:=rdelta;
               sbuf:=body[i].sxS;
               body[i].sxS:=body[i].sxE;
               body[i].sxE:=sbuf;
               MainMemo.Lines.Add('warning : xE< xS');
               inc(iwarning);
            end;
            bOk:=True;
            body[i].yS:=FormVariables.my_real_convert(body[i].syS,bOk);
            bOk:=True;
            body[i].yE:=FormVariables.my_real_convert(body[i].syE,bOk);
            if (body[i].yE<body[i].yS) then
            begin
               // коррдината начала всегда меньше координаты конца.
               rdelta:=body[i].yS;
               body[i].yS:=body[i].yE;
               body[i].yE:=rdelta;
               sbuf:=body[i].syS;
               body[i].syS:=body[i].syE;
               body[i].syE:=sbuf;
               MainMemo.Lines.Add('warning : yE< yS');
               inc(iwarning);
            end;



            if (Laplas.workmat[body[i].imatid].blibmat=0) then
            begin
               // материал пользователя.
               s:='<Component name="component'+getid2string(i-1)+'" ';
               s:=s+'material="'+Laplas.workmat[body[i].imatid].namemat+'" ';
            end
             else
            begin
               if (Laplas.workmat[body[i].imatid].blibmat=1) then
               begin
                  if ((Laplas.workmat[body[i].imatid].ilibident>=101) and
                      (Laplas.workmat[body[i].imatid].ilibident<=115)) then
                   begin
                      s:='<Component name="component'+getid2string(i-1)+'" ';
                      s:=s+'material="'+Laplas.workmat[body[i].imatid].namemat+'" ';
                   end
                    else
                   begin
                      // Непредусмотренный библиотечный материал со свойствами заданными внутри программы.
                      MainMemo.Lines.Add('Error export ! Material is not user defined, properties is function temperature.');
                      inc(ierror);
                   end;
               end
                else
               begin
                  // Непредусмотренный библиотечный материал со свойствами заданными внутри программы.
                  MainMemo.Lines.Add('Error export ! Material is not user defined, properties is function temperature.');
                  inc(ierror);
               end;
            end;
            // требуется определить layer.
            // Мы будем печатать слой соответствующий блоку
            // предполагая что каждому блоку соответствует не более одного слоя.
            // Если это не так (что возможно, но можно так перечертить модель чтобы
            // этого избежать) то мы выдадим сообщение об ошибке.
            isize:=Length(zbuf);
            istart:=-1; iend:=-1;
            for i1:=0 to isize-1 do
            begin
               if (Abs(body[i].zS-zbuf[i1])<epsilon) then
               begin
                  istart:=i1;
               end;
               if (Abs(body[i].zE-zbuf[i1])<epsilon) then
               begin
                  iend:=i1;
               end;
            end;
            if ((iend-istart)>1) then
            begin
               // больше одного layer на блок.
               MainMemo.Lines.Add('Error ! More than one layer in the block.');
               inc(ierror);
            end
            else
            begin
               // один layer на блок.
               s:=s+'layer="layer'+getid2string(istart)+'">';
               f.Add(s);
            end;
            // требуется определить положение блока в плоскости XY.
            // положения определяются секциями, а секции определяет раздел Points.
            //  x=1, y=2  |  x=2, y=2 | ...
            //  x=1, y=1  |  x=2, y=1 | ...
            s:='<Blocks ';
            isize:=Length(xbuf);
            istart:=-1; iend:=-1;
            for i1:=0 to isize-1 do
            begin
               if (Abs(body[i].xS-xbuf[i1])<epsilon) then
               begin
                  istart:=i1;
               end;
               if (Abs(body[i].xE-xbuf[i1])<epsilon) then
               begin
                  iend:=i1;
               end;
            end;
            if ((iend-istart)=1) then
            begin
               s:=s+'x="'+IntToStr(iend)+'" ';
            end;
            if ((iend-istart)>1) then
            begin
               s:=s+'x="'+IntToStr(istart+1)+'-'+IntToStr(iend)+'" ';
            end;
            // Случай (iend-istart)>1 невозможен в силу проверяющего кода в начале.
            isize:=Length(ybuf);
            istart:=-1; iend:=-1;
            for i1:=0 to isize-1 do
            begin
               if (Abs(body[i].yS-ybuf[i1])<epsilon) then
               begin
                  istart:=i1;
               end;
               if (Abs(body[i].yE-ybuf[i1])<epsilon) then
               begin
                  iend:=i1;
               end;
            end;
            if ((iend-istart)=1) then
            begin
               s:=s+'y="'+IntToStr(iend)+'" ';
            end;
            if ((iend-istart)>1) then
            begin
               s:=s+'y="'+IntToStr(istart+1)+'-'+IntToStr(iend)+'" ';
            end;
            // Случай (iend-istart)>1 невозможен в силу проверяющего кода в начале.

            s:=s+' />';
            f.Add(s);
            s:='</Component>';
            f.Add(s);
         end;
      end;

      s:='</Device>';
      f.Add(s);
      // Boundary Conditions :
      // Секция граничных условий.
      // Первым делом мы обработаем источники тепла,
      // на их поверхности задан тепловой поток.

      s:='<BoundaryConditions> ';
      f.Add(s);

      // Сначала перечисляем поверхностные источники тепла.
      for i:=0 to ls-1 do
      begin
         if (source[i].iPlane=1 ) then
         begin
            // только если источник лежит в плоскости XY
            // если единицы длины микроны.
            // 1 - XY

            // Площадь занимаемая источником тепла.
            rdelta:=abs(source[i].xE-source[i].xS)*abs(source[i].yE-source[i].yS);
            // перевод в микроны.
            case ComboBoxlength.ItemIndex of
              0 : begin
                     // метры.
                     rdelta:=1.0e12*rdelta;
                  end;
              1 : begin
                     // мм.
                     rdelta:=1.0e6*rdelta;
                  end;
              2 : begin
                     // micron.
                     rdelta:=1.0*rdelta;
                  end;
            end;

            // тепловой поток в Вт/мкм!2 см. SYMMIC
            rdelta:=source[i].Power/rdelta;
            s:='<SFlux flux="'+FloatToStr(rdelta)+'" face="top" ';
            // определяем layer лежащий строго под источником тепла.
            isize:=Length(zbuf);
            iend:=-1;
            for i1:=0 to isize-1 do
            begin
               if (Abs(source[i].zS-zbuf[i1])<epsilon) then
               begin
                  iend:=i1;
               end;
            end;
            if (iend>0) then
            begin
               s:=s+'layer="layer'+getid2string(iend-1)+'">';
               f.Add(s);
            end
            else
            begin
               // источник лежит на нижней границе нижнего слоя.
               MainMemo.Lines.Add('Error ! source is at the lower boundary of the lower layer.');
               inc(ierror);
            end;
            // определение положения источника тепла в плоскости (x,y).
            // положения определяются секциями, а секции определяет раздел Points.
            //  x=1, y=2  |  x=2, y=2 | ...
            //  x=1, y=1  |  x=2, y=1 | ...
            s:='<Blocks ';
            isize:=Length(xbuf);
            istart:=-1; iend:=-1;
            for i1:=0 to isize-1 do
            begin
               if (Abs(source[i].xS-xbuf[i1])<epsilon) then
               begin
                  istart:=i1;
               end;
               if (Abs(source[i].xE-xbuf[i1])<epsilon) then
               begin
                  iend:=i1;
               end;
            end;
            if ((iend-istart)=1) then
            begin
               s:=s+'x="'+IntToStr(iend)+'" ';
            end;
            if ((iend-istart)>1) then
            begin
               s:=s+'x="'+IntToStr(istart+1)+'-'+IntToStr(iend)+'" ';
            end;
            // Случай (iend-istart)>1 невозможен в силу проверяющего кода в начале.
            isize:=Length(ybuf);
            istart:=-1; iend:=-1;
            for i1:=0 to isize-1 do
            begin
               if (Abs(source[i].yS-ybuf[i1])<epsilon) then
               begin
                  istart:=i1;
               end;
               if (Abs(source[i].yE-ybuf[i1])<epsilon) then
               begin
                  iend:=i1;
               end;
            end;
            if ((iend-istart)=1) then
            begin
               s:=s+'y="'+IntToStr(iend)+'" ';
            end;
            if ((iend-istart)>1) then
            begin
               s:=s+'y="'+IntToStr(istart+1)+'-'+IntToStr(iend)+'" ';
            end;
            // Случай (iend-istart)>1 невозможен в силу проверяющего кода в начале.
            s:=s+'/>';
            f.Add(s);

            s:='</Sflux>';
            f.Add(s);

         end;
      end;

      // Перечисляем объёмные источники тепла.
      for i:=1 to lb-1 do
      begin
         // Вычисляем текущее значение мощности на основе значений переменных.
         body[i].power:=FormVariables.my_real_convert(Trim(body[i].spower),bOk);
         if (body[i].power>0.0) then
         begin
            // Если блок является тепловыделяющим.
            // Вычислим объёмный тепловой поток в блоке.
            // объём блока.
            rdelta:=abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS);
            // перевод в микроны.
            case ComboBoxlength.ItemIndex of
              0 : begin
                     // метры.
                     rdelta:=1.0e18*rdelta;
                  end;
              1 : begin
                     // мм.
                     rdelta:=1.0e9*rdelta;
                  end;
              2 : begin
                     // micron.
                     rdelta:=1.0*rdelta;
                  end;
            end;
            // Объёмная мощность тепловыделения.
            rdelta:=body[i].power/rdelta; // W/micron!3
            s:='<BFlux ';
            // Определим номер слоя в котором находится блок.
            // требуется определить layer.
            // Мы будем печатать слой соответствующий блоку
            // предполагая что каждому блоку соответствует не более одного слоя.
            // Если это не так (что возможно, но можно так перечертить модель чтобы
            // этого избежать) то мы выдадим сообщение об ошибке.
            isize:=Length(zbuf);
            istart:=-1; iend:=-1;
            for i1:=0 to isize-1 do
            begin
               if (Abs(body[i].zS-zbuf[i1])<epsilon) then
               begin
                  istart:=i1;
               end;
               if (Abs(body[i].zE-zbuf[i1])<epsilon) then
               begin
                  iend:=i1;
               end;
            end;
            if ((iend-istart)>1) then
            begin
               // больше одного layer на блок.
               MainMemo.Lines.Add('Error ! More than one layer in the block.');
               inc(ierror);
            end
            else
            begin
               // один layer на блок.
               s:=s+'layer="layer'+getid2string(istart)+'" ';
               s:=s+'flux="'+FloatToStr(rdelta)+'">';
               f.Add(s);
            end;



            // требуется определить положение блока в плоскости XY.
            // положения определяются секциями, а секции определяет раздел Points.
            //  x=1, y=2  |  x=2, y=2 | ...
            //  x=1, y=1  |  x=2, y=1 | ...
            s:='<Blocks ';
            isize:=Length(xbuf);
            istart:=-1; iend:=-1;
            for i1:=0 to isize-1 do
            begin
               if (Abs(body[i].xS-xbuf[i1])<epsilon) then
               begin
                  istart:=i1;
               end;
               if (Abs(body[i].xE-xbuf[i1])<epsilon) then
               begin
                  iend:=i1;
               end;
            end;
            if ((iend-istart)=1) then
            begin
               s:=s+'x="'+IntToStr(iend)+'" ';
            end;
            if ((iend-istart)>1) then
            begin
               s:=s+'x="'+IntToStr(istart+1)+'-'+IntToStr(iend)+'" ';
            end;
            // Случай (iend-istart)>1 невозможен в силу проверяющего кода в начале.
            isize:=Length(ybuf);
            istart:=-1; iend:=-1;
            for i1:=0 to isize-1 do
            begin
               if (Abs(body[i].yS-ybuf[i1])<epsilon) then
               begin
                  istart:=i1;
               end;
               if (Abs(body[i].yE-ybuf[i1])<epsilon) then
               begin
                  iend:=i1;
               end;
            end;
            if ((iend-istart)=1) then
            begin
               s:=s+'y="'+IntToStr(iend)+'" ';
            end;
            if ((iend-istart)>1) then
            begin
               s:=s+'y="'+IntToStr(istart+1)+'-'+IntToStr(iend)+'" ';
            end;
            // Случай (iend-istart)>1 невозможен в силу проверяющего кода в начале.

            s:=s+' />';
            f.Add(s);

            s:='</BFlux>';
            f.Add(s);
         end;
      end;


      // Теперь зададим поверхности идеального теплоотвода.
      for i:=0 to lw-1 do
      begin
         if (wall[i].iPlane=1 ) then
         begin
            // 1 - XY

            if (wall[i].family=1) then
            begin
               // заданная температура на поверхности.
               s:='<Constant face="bottom" ';


               // определение слоя в котором поставлено данное краевое условие.
               isize:=Length(zbuf);
               istart:=-1;
               for i1:=0 to isize-1 do
               begin
                  if (Abs(wall[i].zS-zbuf[i1])<epsilon) then
                  begin
                     istart:=i1;
                  end;
               end;
               if (istart>=0) then
               begin
                  s:=s+'layer="layer'+getid2string(istart)+'" ';
               end
                else
               begin
                  // идеальный теплоотвод лежит на несуществующей плоскости.
                  MainMemo.Lines.Add('Error ! Perfect heat sink rests on a non-existent plane.');
                  inc(ierror);
               end;

               // запись поставленной температуры на границе.
               s:=s+'temperature="'+FloatToStr(273+wall[i].Tamb)+'">';
               f.Add(s);

               // Положение данной границы в плоскости XY.
               // положения определяются секциями, а секции определяет раздел Points.
               //  x=1, y=2  |  x=2, y=2 | ...
               //  x=1, y=1  |  x=2, y=1 | ...
               s:='<Blocks ';
               isize:=Length(xbuf);
               istart:=-1; iend:=-1;
               for i1:=0 to isize-1 do
               begin
                  if (Abs(wall[i].xS-xbuf[i1])<epsilon) then
                  begin
                     istart:=i1;
                  end;
                  if (Abs(wall[i].xE-xbuf[i1])<epsilon) then
                  begin
                     iend:=i1;
                  end;
               end;
               if ((iend-istart)=1) then
               begin
                  s:=s+'x="'+IntToStr(iend)+'" ';
               end;
               if ((iend-istart)>1) then
               begin
                  s:=s+'x="'+IntToStr(istart+1)+'-'+IntToStr(iend)+'" ';
               end;
               // Случай (iend-istart)>1 невозможен в силу проверяющего кода в начале.
               isize:=Length(ybuf);
               istart:=-1; iend:=-1;
               for i1:=0 to isize-1 do
               begin
                  if (Abs(wall[i].yS-ybuf[i1])<epsilon) then
                  begin
                     istart:=i1;
                  end;
                  if (Abs(wall[i].yE-ybuf[i1])<epsilon) then
                  begin
                     iend:=i1;
                  end;
               end;
               if ((iend-istart)=1) then
               begin
                  s:=s+'y="'+IntToStr(iend)+'" ';
               end;
               if ((iend-istart)>1) then
               begin
                  s:=s+'y="'+IntToStr(istart+1)+'-'+IntToStr(iend)+'" ';
               end;
               // Случай (iend-istart)>1 невозможен в силу проверяющего кода в начале.
               s:=s+'/>';
               f.Add(s);


               s:='</Constant>';
               f.Add(s);
            end
            else
            begin
               // Условие Ньютона-Рихмана не предусмотрено.
               MainMemo.Lines.Add('Error ! Conditions of Newton - Richman is not provided.');
               inc(ierror);
            end;
         end;
      end;


      s:='</BoundaryConditions>';
      f.Add(s);
      // Simulation :
      s:='<Simulation> ';
      s:=s+'<Time steady="true" </Time>';
      // определяем минимальную температуру в граничном условии :
      rdelta:=1e20;
      for i:=0 to lw-1 do
      begin
         if (wall[i].iPlane=1 ) then
         begin
           //  1 - XY
            if (wall[i].family=1) then
            begin
               if (wall[i].Tamb<rdelta) then
               begin
                  rdelta:=wall[i].Tamb;
               end;
            end;
         end;
      end;
      if (rdelta>1e19) then
      begin
         // идеальный теплоотвод не определён.
         MainMemo.Lines.Add('Error ! Perfect heat sink is not defined. ');
         inc(ierror);
      end
      else
      begin
         s:=s+'<Temperature initial="'+FloatToStr(273+rdelta)+'"/>';
      end;
      s:=s+'</Simulation>';
      f.Add(s);
      // History :
      // Уберём раздел истории за ненадобностью.
      //s:='<History> ';
      //f.Add(s);
      // Данный раздел оставим пустым.
      //s:='</History>';
      //f.Add(s);
      // Конец печати 8 разделов для SYMMIC.


      // Запись результата и освобождение памяти.
      f.SaveToFile(filename+'.xml'); // сохранение результата
      f.Free;
      if ((ierror=0) and (iwarning=0)) then
      begin
         MainMemo.Lines.Add(filename+'.xml  file successfully written .');
      end
      else
      begin
         MainMemo.Lines.Add(filename+'.xml file is not recorded  '+IntToStr(ierror)+' faults  '+IntToStr(iwarning)+'  warnings .');
      end;

   end
    else
   begin
      MainMemo.Lines.Add('Error! Please, input file name and title');
   end;

end; // EXPORT TO SYMMIC перестал поддерживать 23_10_2016
*)


// Управление показом графики в плоскости.
function TLaplas.if_visible_now(riso_loc : Real; start_loc : Real; end_loc : Real) : Boolean;
var
  bret : Boolean;
begin
   bret:=false;
   case ComboBoxplaneViewSelect.ItemIndex of
   0 : begin
          // iso
          if ((riso_loc>=start_loc)and(riso_loc<=end_loc)) then
          begin
              bret:=true;
          end;
       end;
   1 : begin
          // +
          if ((riso_loc>=start_loc)and(riso_loc>=end_loc)) then
          begin
              bret:=true;
          end;
       end;
   2 : begin
          // -
          if ((riso_loc<=start_loc)and(riso_loc<=end_loc)) then
          begin
              bret:=true;
          end;
       end;
   end;

   Result:=bret;
end;

// экспортирование в чертёжном формате dxf
procedure TLaplas.btndxfClick(Sender: TObject);
var
   filename : string; // имя записываемого файла
   f : TStringList; // переменная типа объект TStringList
   i,j,L,code : Integer;
   xs1, ys1, xe1, ye1, c, riso : Real;
   sforval : String;

procedure line_dxf(x1 : Real; y1 : Real; z1 : Real;
                   x2 : Real; y2 : Real; z2 : Real;
                   s : string);
begin
   f.Add('0');
   f.Add('LINE');
   f.Add('8');
   f.Add(s);
   f.Add('10');
   f.Add(FloatToStr(x1));
   f.Add('20');
   f.Add(FloatToStr(y1));
   f.Add('30');
   f.Add(FloatToStr(z1));
   f.Add('11');
   f.Add(FloatToStr(x2));
   f.Add('21');
   f.Add(FloatToStr(y2));
   f.Add('31');
   f.Add(FloatToStr(z2));
end;  // line_dxf

// Рисует окружность из 36 линий.
procedure circle_dxf(xc : Real; yc : Real; Radius : Real);
var
   angle_start, angle_end : Real;
   i_1 : Integer;
begin
    for i_1 := 1 to 36 do
    begin
       angle_start:=(i_1-1)*10.0*3.141/180;
       angle_end:=(i_1)*10.0*3.141/180;
       line_dxf(xc+Radius*cos(angle_start),yc+Radius*sin(angle_start),0.0,xc+Radius*cos(angle_end),yc+Radius*sin(angle_end),0.0,'layer1');
    end;
end; // circle_dxf

begin


    sforval:='';
    sforval:=StringReplace(edtvalue.Text,',','.',[rfReplaceAll]);
    val(sforval,c,code);
    //val(edtvalue.Text,c,code);
    if (code=0) then
    begin
        riso:=StrToFloat(edtvalue.Text);

        // записывает файл с геометрией задачи
        filename:='';
        if not InputQuery('Input name file', 'Please, enter name writing file',filename)
        then exit;

        f:=TStringList.Create();

        f.Add('0');
        f.Add('SECTION');
        f.Add('2');
        f.Add('ENTITIES');

     for j:=0 to (ls-1) do
     begin // проход по всем источникам тепла
        with source[j] do
        begin
           if (source[j].bvisible) then
           begin
               if (cbbview.ItemIndex=iPlane) then
               begin
                  case iPlane of
                   1 : // XY
                   begin
                      if (abs(zS-riso)<2.0*min(abs(xE-xS),abs(yS-yE))) then
                      begin
                         // Так размеры искажаться не должны.
                         line_dxf(xS,yS,0.0,xE,yS,0.0,'layer1');
                         line_dxf(xE,yS,0.0,xE,yE,0.0,'layer1');
                         line_dxf(xS,yE,0.0,xE,yE,0.0,'layer1');
                         line_dxf(xS,yS,0.0,xS,yE,0.0,'layer1');
                      end;
                   end;
                   2 : // XZ
                   begin
                      if (abs(yS-riso)<2.0*min(abs(xE-xS),abs(zS-zE))) then
                      begin
                         // Так размеры искажаться не должны.
                         line_dxf(xS,zS,0.0,xE,zS,0.0,'layer1');
                         line_dxf(xE,zS,0.0,xE,zE,0.0,'layer1');
                         line_dxf(xS,zE,0.0,xE,zE,0.0,'layer1');
                         line_dxf(xS,zS,0.0,xS,zE,0.0,'layer1');
                      end;
                   end;
                   3 : // YZ
                   begin
                      if (abs(xS-riso)<2.0*min(abs(yE-yS),abs(zS-zE))) then
                      begin
                         // Так размеры искажаться не должны.
                         line_dxf(yS,zS,0.0,yE,zS,0.0,'layer1');
                         line_dxf(yE,zS,0.0,yE,zE,0.0,'layer1');
                         line_dxf(yS,zE,0.0,yE,zE,0.0,'layer1');
                         line_dxf(yS,zS,0.0,yS,zE,0.0,'layer1');
                     end;
                  end;
               end;
           end;
        end;
     end;
     end;


     // Прорисовка блоков:

     // Внимание : если потребуется изобразить кабинет то
     // индекс j нужно сканировать не с 1, а начиная с нуля.

     for j:=1 to lb-1 do
     begin
        with (body[j]) do
        begin
           if (bvisible) then
           begin
              case cbbview.ItemIndex of
              0 : // all
                 begin
                    // осуществляем поддержку только сечений,
                    // изометрия не экспортируется !!!.
                 end;
              1 : // XY
                 begin
                       if (if_visible_now(riso,zS,zE)) then
                       begin
                         if ((igeometry_type=1)and(iPlane=1)) then
                         begin
                            // Цилиндр.
                            circle_dxf(xC, yC, R_out_cyl);
                            if (abs(R_in_cyl)>1.0e-37) then
                            begin
                               circle_dxf(xC, yC, R_in_cyl);
                            end;
                         end
                          else if ((igeometry_type=2)and(iPlane_obj2=1)) then
                         begin
                            // Полигон
                            for i := 0 to nsizei-2 do
                            begin
                               line_dxf(xi[i],yi[i],0.0,xi[i+1],yi[i+1],0.0,'layer0');
                            end;
                            line_dxf(xi[nsizei-1],yi[nsizei-1],0.0,xi[0],yi[0],0.0,'layer0');
                         end
                          else
                         begin
                            // Так размеры искажаться не должны.
                            line_dxf(xS,yS,0.0,xE,yS,0.0,'layer0');
                            line_dxf(xE,yS,0.0,xE,yE,0.0,'layer0');
                            line_dxf(xS,yE,0.0,xE,yE,0.0,'layer0');
                            line_dxf(xS,yS,0.0,xS,yE,0.0,'layer0');
                         end;
                       end;
                 end;
              2 : // XZ
                 begin
                       if (if_visible_now(riso,yS,yE)) then
                       begin
                         if ((igeometry_type=1)and(iPlane=2)) then
                         begin
                            // Цилиндр.
                            circle_dxf(xC, zC, R_out_cyl);
                            if (abs(R_in_cyl)>1.0e-37) then
                            begin
                               circle_dxf(xC, zC, R_in_cyl);
                            end;
                         end
                          else if ((igeometry_type=2)and(iPlane_obj2=2)) then
                         begin
                            // Полигон
                            for i := 0 to nsizei-2 do
                            begin
                               line_dxf(xi[i],zi[i],0.0,xi[i+1],zi[i+1],0.0,'layer0');
                            end;
                            line_dxf(xi[nsizei-1],zi[nsizei-1],0.0,xi[0],zi[0],0.0,'layer0');
                         end
                         else
                         begin
                            // Так размеры искажаться не должны.
                            line_dxf(xS,zS,0.0,xE,zS,0.0,'layer0');
                            line_dxf(xE,zS,0.0,xE,zE,0.0,'layer0');
                            line_dxf(xS,zE,0.0,xE,zE,0.0,'layer0');
                            line_dxf(xS,zS,0.0,xS,zE,0.0,'layer0');
                         end;
                       end;
                 end;
              3 : // YZ
                 begin
                       if (if_visible_now(riso,xS,xE)) then
                       begin
                         if ((igeometry_type=1)and(iPlane=3)) then
                         begin
                            // Цилиндр.
                            circle_dxf(yC, zC, R_out_cyl);
                            if (abs(R_in_cyl)>1.0e-37) then
                            begin
                               circle_dxf(yC, zC, R_in_cyl);
                            end;
                         end
                          else if ((igeometry_type=2)and(iPlane_obj2=3)) then
                         begin
                            // Полигон
                            for i := 0 to nsizei-2 do
                            begin
                               line_dxf(yi[i],zi[i],0.0,yi[i+1],zi[i+1],0.0,'layer0');
                            end;
                            line_dxf(yi[nsizei-1],zi[nsizei-1],0.0,yi[0],zi[0],0.0,'layer0');
                         end
                          else
                         begin
                            // Так размеры искажаться не должны.
                            line_dxf(yS,zS,0.0,yE,zS,0.0,'layer0');
                            line_dxf(yE,zS,0.0,yE,zE,0.0,'layer0');
                            line_dxf(yS,zE,0.0,yE,zE,0.0,'layer0');
                            line_dxf(yS,zS,0.0,yS,zE,0.0,'layer0');
                          end;
                       end;
                 end;
              end;
           end;
        end;
     end;



     // прорисовка стенок
     for j:=0 to (lw-1) do
     begin // проход по всем твёрдым стенкам
        with wall[j] do
        begin
           if (wall[j].bvisible) then
           begin
               if (cbbview.ItemIndex=iPlane) then
               begin
                  case iPlane of
                   // 0 : all изометрию мы не экспортируем.
                   1 : // XY
                   begin
                      if (abs(zS-riso)<2.0*min(abs(xE-xS),abs(yS-yE))) then
                      begin
                         // Так размеры искажаться не должны.
                         line_dxf(xS,yS,0.0,xE,yS,0.0,'layer1');
                         line_dxf(xE,yS,0.0,xE,yE,0.0,'layer1');
                         line_dxf(xS,yE,0.0,xE,yE,0.0,'layer1');
                         line_dxf(xS,yS,0.0,xS,yE,0.0,'layer1');
                      end;
                   end;
                   2 : // XZ
                   begin
                      if (abs(yS-riso)<2.0*min(abs(xE-xS),abs(zS-zE))) then
                      begin
                         // Так размеры искажаться не должны.
                         line_dxf(xS,zS,0.0,xE,zS,0.0,'layer1');
                         line_dxf(xE,zS,0.0,xE,zE,0.0,'layer1');
                         line_dxf(xS,zE,0.0,xE,zE,0.0,'layer1');
                         line_dxf(xS,zS,0.0,xS,zE,0.0,'layer1');
                      end;
                   end;
                   3 : // YZ
                   begin
                      if (abs(xS-riso)<2.0*min(abs(yE-yS),abs(zS-zE))) then
                      begin
                         // Так размеры искажаться не должны.
                         line_dxf(yS,zS,0.0,yE,zS,0.0,'layer1');
                         line_dxf(yE,zS,0.0,yE,zE,0.0,'layer1');
                         line_dxf(yS,zE,0.0,yE,zE,0.0,'layer1');
                         line_dxf(yS,zS,0.0,yS,zE,0.0,'layer1');
                      end;
                   end;
                  end;
               end;
           end;
        end;
     end;


     f.Add('0');
     f.Add('ENDSEC');
     f.Add('0');
     f.Add('EOF');

     f.SaveToFile(filename+'.dxf'); // сохранение результата
     f.Free;
     MainMemo.Lines.Add('File ' + filename+'.dxf   successfully written.');

   end
    else
   begin
      ShowMessage('Error! Incorrect iso value...');
      edtvalue.Text:='0.0';
   end;

end;

procedure TLaplas.Convergenceplot1Click(Sender: TObject);
var
   f : TStringList; // переменная типа объект TStringList
   i : Integer;
   fmin, fmax : Real;
   s, sub, subx : string;
begin
    f:=TStringList.Create();

    if ((Laplas.egddata.myflmod[0].iflowregime=1)and
        (Laplas.egddata.myflmod[0].iturbmodel=6)) then
    begin
       // Модель Ментора Лангтрии [2009].
       Formresidual2.brun_visible2:=false;
       FormResidualSATemp.brun_visibleSA2:=false;
       FormResidualSSTTemp.brun_visibleSSTTemp:=false;
       FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
       FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=true;
    end
     else
      if ((Laplas.egddata.myflmod[0].iflowregime=1)and
        (Laplas.egddata.myflmod[0].iturbmodel=5)) then
    begin
       // Standart K-Epsilon Model на основе двухслойной модели.
       Formresidual2.brun_visible2:=false;
       FormResidualSATemp.brun_visibleSA2:=false;
       FormResidualSSTTemp.brun_visibleSSTTemp:=false;
       FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
       FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=true;
    end
     else
     if ((Laplas.egddata.myflmod[0].iflowregime=1)and
        (Laplas.egddata.myflmod[0].iturbmodel=4)) then
    begin
       // SST K-Omega
       Formresidual2.brun_visible2:=false;
       FormResidualSATemp.brun_visibleSA2:=false;
        FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
       FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
       FormResidualSSTTemp.brun_visibleSSTTemp:=true;
    end
     else
    if ((Laplas.egddata.myflmod[0].iflowregime=1)and
    (Laplas.egddata.myflmod[0].iturbmodel=3)) then
    begin
       // Спаларт Аллмарес
       FormResidualSSTTemp.brun_visibleSSTTemp:=false;
       Formresidual2.brun_visible2:=false;
        FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
       FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
       FormResidualSATemp.brun_visibleSA2:=true;
    end
     else
    begin
        FormResidualSSTTemp.brun_visibleSSTTemp:=false;
        FormResidualSATemp.brun_visibleSA2:=false;
         FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
        FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
        Formresidual2.brun_visible2:=true;
    end;

    if ((Laplas.egddata.myflmod[0].iflowregime=1)and
     (Laplas.egddata.myflmod[0].iturbmodel=6)) then
     begin
        // Модель Ментора Лангтрии [2009]
        Formresidual.brun_visible:=false;
        FormResidualSpallart_Allmares.brun_visibleSA:=false;
        FormResidualSST.brun_visibleSST:=false;
        FormResidualStandartKEpsilon.brun_visibleKEpsilon:=false;
        FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=true;
     end
     else
      if ((Laplas.egddata.myflmod[0].iflowregime=1)and
     (Laplas.egddata.myflmod[0].iturbmodel=5)) then
     begin
        // Standart K-epsilon model
        FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=false;
        Formresidual.brun_visible:=false;
        FormResidualSpallart_Allmares.brun_visibleSA:=false;
        FormResidualSST.brun_visibleSST:=false;
        FormResidualStandartKEpsilon.brun_visibleKEpsilon:=true;
     end
     else
     if ((Laplas.egddata.myflmod[0].iflowregime=1)and
     (Laplas.egddata.myflmod[0].iturbmodel=4)) then
     begin
        // SST Ментер
        FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=false;
        Formresidual.brun_visible:=false;
        FormResidualSpallart_Allmares.brun_visibleSA:=false;
        FormResidualStandartKEpsilon.brun_visibleKEpsilon:=false;
        FormResidualSST.brun_visibleSST:=true;

     end
     else
    if ((Laplas.egddata.myflmod[0].iflowregime=1)and
        (Laplas.egddata.myflmod[0].iturbmodel=3)) then
    begin
        FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=false;
        Formresidual.brun_visible:=false;
        FormResidualSST.brun_visibleSST:=false;
        FormResidualStandartKEpsilon.brun_visibleKEpsilon:=false;
        FormResidualSpallart_Allmares.brun_visibleSA:=true;

    end
    else
    begin
       FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=false;
       FormResidualSST.brun_visibleSST:=false;
       FormResidualSpallart_Allmares.brun_visibleSA:=false;
        FormResidualStandartKEpsilon.brun_visibleKEpsilon:=false;
       Formresidual.brun_visible:=true;

    end;



     if (egddata.itemper>0) then
     begin
        // С учётом уравнения теплопередачи.
         if (FileExists('statistic_convergence.txt')) then
         begin
            f.LoadFromFile('statistic_convergence.txt');

            if (FormatSettings.DecimalSeparator=',') then
            begin
               // заменить все точки в файле на запятые.
               for i:=0 to f.Count-1 do
               begin
                  s:=f.Strings[i];
                  f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
               end;
             end;

                if ((Laplas.egddata.myflmod[0].iflowregime=1)and
             (Laplas.egddata.myflmod[0].iturbmodel=6)) then
            begin
               // Модель ламинарно турбулентного перехода Менторпа Лантгрии [2009].
               // первые две строки нужно пропустить.
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[0].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[1].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[2].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[3].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[4].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[5].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[6].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[7].Clear;
               FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[8].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                            s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[7].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);


                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              if (Pos(s,' ')>0) then
                              begin
                                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                              end
                              else
                              begin
                                 sub:=Trim(Copy(s,1,length(s)));
                              end;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidual_Lagtry_Menter_Temp.Chart1.SeriesList[8].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                              end
                               else
                              begin
                                 // TODO
                                 // обрыв данных после первых трёх значений.
                              end;
                           end;
                           end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                        end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidual_Lagtry_Menter_Temp.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidual_Lagtry_Menter_Temp.Chart1.LeftAxis.Maximum:=fmax;
                end;


                f.Free;
                Formresidual2.brun_visible2:=false;
                FormResidualSATemp.brun_visibleSA2:=false;
                FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=true;
                FormResidual_Lagtry_Menter_Temp.Show;
            end
            else
              if ((Laplas.egddata.myflmod[0].iflowregime=1)and
             (Laplas.egddata.myflmod[0].iturbmodel=5)) then
            begin
               // Standart K-epsilon model на основе двухслойной модели [2001].
               // первые две строки нужно пропустить.
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[0].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[1].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[2].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[3].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[4].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[5].Clear;
               FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[6].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                            s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              if (Pos(s,' ')>0) then
                              begin
                                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                              end
                              else
                              begin
                                 sub:=Trim(Copy(s,1,length(s)));
                              end;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualStandart_k_epsilon_Temp.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                              end
                               else
                              begin
                                 // TODO
                                 // обрыв данных после первых трёх значений.
                              end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                        end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualStandart_k_epsilon_Temp.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualStandart_k_epsilon_Temp.Chart1.LeftAxis.Maximum:=fmax;
                end;


                f.Free;
                Formresidual2.brun_visible2:=false;
                FormResidualSATemp.brun_visibleSA2:=false;
                FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=true;
                FormResidualStandart_k_epsilon_Temp.Show;
            end
            else
              if ((Laplas.egddata.myflmod[0].iflowregime=1)and
             (Laplas.egddata.myflmod[0].iturbmodel=4)) then
            begin
               // K-Omega SST.
               // первые две строки нужно пропустить.
               FormResidualSSTTemp.Chart1.SeriesList[0].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[1].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[2].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[3].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[4].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[5].Clear;
               FormResidualSSTTemp.Chart1.SeriesList[6].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSSTTemp.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSSTTemp.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSSTTemp.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSSTTemp.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                            s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                             FormResidualSSTTemp.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSSTTemp.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              if (Pos(s,' ')>0) then
                              begin
                                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                              end
                              else
                              begin
                                 sub:=Trim(Copy(s,1,length(s)));
                              end;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualSSTTemp.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                              end
                               else
                              begin
                                 // TODO
                                 // обрыв данных после первых трёх значений.
                              end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                        end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSSTTemp.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSSTTemp.Chart1.LeftAxis.Maximum:=fmax;
                end;


                f.Free;
                Formresidual2.brun_visible2:=false;
                FormResidualSATemp.brun_visibleSA2:=false;
                FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                FormResidualSSTTemp.brun_visibleSSTTemp:=true;
                FormResidualSSTTemp.Show;
            end
            else
             if ((Laplas.egddata.myflmod[0].iflowregime=1)and
             (Laplas.egddata.myflmod[0].iturbmodel=3)) then
            begin
               // Спаларт Аллмарес.
               // первые две строки нужно пропустить.
               FormResidualSATemp.Chart1.SeriesList[0].Clear;
               FormResidualSATemp.Chart1.SeriesList[1].Clear;
               FormResidualSATemp.Chart1.SeriesList[2].Clear;
               FormResidualSATemp.Chart1.SeriesList[3].Clear;
               FormResidualSATemp.Chart1.SeriesList[4].Clear;
               FormResidualSATemp.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSATemp.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSATemp.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSATemp.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSATemp.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSATemp.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              if (Pos(s,' ')>0) then
                              begin
                                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                              end
                              else
                              begin
                                 sub:=Trim(Copy(s,1,length(s)));
                              end;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualSATemp.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                              end
                               else
                              begin
                                 // TODO
                                 // обрыв данных после первых трёх значений.
                              end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSATemp.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSATemp.Chart1.LeftAxis.Maximum:=fmax;
                end;


                f.Free;
                Formresidual2.brun_visible2:=false;
                FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
                FormResidualSATemp.brun_visibleSA2:=true;
                FormResidualSATemp.Show;
            end
            else
            begin

             // первые две строки нужно пропустить.
             Formresidual2.cht1.SeriesList[0].Clear;
             Formresidual2.cht1.SeriesList[1].Clear;
             Formresidual2.cht1.SeriesList[2].Clear;
             Formresidual2.cht1.SeriesList[3].Clear;
             Formresidual2.cht1.SeriesList[4].Clear;
             for i:=2 to f.Count-1 do
             begin
                fmin:=20.0;
                fmax:=120.0;
                s:=Trim(f.Strings[i]);
                subx:=Trim(Copy(s,1,Pos(' ',s)));
                s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                sub:=Trim(Copy(s,1,Pos(' ',s)));
                if (StrToFloat(sub)<fmin) then
                begin
                   fmin:=StrToFloat(sub);
                end;
                if (StrToFloat(sub)>fmax) then
                begin
                   fmax:=StrToFloat(sub);
                end;
                Formresidual2.cht1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                sub:=Trim(Copy(s,1,Pos(' ',s)));
                if (length(sub)>0) then
                begin
                   if (StrToFloat(sub)<fmin) then
                   begin
                      fmin:=StrToFloat(sub);
                   end;
                   if (StrToFloat(sub)>fmax) then
                   begin
                      fmax:=StrToFloat(sub);
                   end;
                   Formresidual2.cht1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                   s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                   sub:=Trim(Copy(s,1,Pos(' ',s)));
                   if (length(sub)>0) then
                   begin
                      if (StrToFloat(sub)<fmin) then
                      begin
                         fmin:=StrToFloat(sub);
                      end;
                      if (StrToFloat(sub)>fmax) then
                      begin
                         fmax:=StrToFloat(sub);
                      end;
                      Formresidual2.cht1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                      s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                      sub:=Trim(Copy(s,1,Pos(' ',s)));
                      if (length(sub)>0) then
                      begin
                         if (StrToFloat(sub)<fmin) then
                         begin
                            fmin:=StrToFloat(sub);
                         end;
                         if (StrToFloat(sub)>fmax) then
                         begin
                            fmax:=StrToFloat(sub);
                         end;
                         Formresidual2.cht1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                         s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                         sub:=s;
                         if (length(sub)>0) then
                         begin
                            if (StrToFloat(sub)<fmin) then
                            begin
                               fmin:=StrToFloat(sub);
                            end;
                            if (StrToFloat(sub)>fmax) then
                            begin
                               fmax:=StrToFloat(sub);
                            end;
                            Formresidual2.cht1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clBlack);
                          end
                           else
                          begin
                             // TODO
                             // обрыв данных после первых трёх значений.
                          end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после первых трёх значений.
                      end;

                    end
                     else
                    begin
                       // TODO
                       // обрыв данных после двух первых значений.
                    end;
                  end
                   else
                  begin
                     // TODO
                     // обрыв данных.
                  end;
                  Formresidual2.cht1.LeftAxis.Minimum:=1e-4*fmin;
                  Formresidual2.cht1.LeftAxis.Maximum:=1e4*fmax;
               end;


                f.Free;
                FormResidualSATemp.brun_visibleSA2:=false;
                FormResidualSSTTemp.brun_visibleSSTTemp:=false;
                FormResidual_Lagtry_Menter_Temp.brun_visible_Langtry_Menter_Temp:=false;
                FormResidualStandart_k_epsilon_Temp.brun_visibleStandartK_EpsilonTemp:=false;
               Formresidual2.brun_visible2:=true;
               Formresidual2.Show;

               end;
             end
              else
             begin
                MainMemo.Lines.Add('statistic_convergence.txt not found.');
             end;

     end
     else
     begin
         // Чистая гидродинамика без уравнения теплопередачи.

         if (FileExists('statistic_convergence.txt')) then
         begin
            f.LoadFromFile('statistic_convergence.txt');

            if (FormatSettings.DecimalSeparator=',') then
            begin
               // заменить все точки в файле на запятые.
               for i:=0 to f.Count-1 do
               begin
                  s:=f.Strings[i];
                  f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
               end;
             end;


                if (Laplas.egddata.myflmod[0].iturbmodel=6) then
            begin
               // Модель Лангтрии Ментора gamma-ReTheta-SST.
               // первые две строки нужно пропустить.
               FormResidual_Langtry_Menter.Chart1.SeriesList[0].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[1].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[2].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[3].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[4].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[5].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[6].Clear;
               FormResidual_Langtry_Menter.Chart1.SeriesList[7].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=Max(1.0e-12,StrToFloat(sub));
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidual_Langtry_Menter.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=Max(1.0e-12,StrToFloat(sub));
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidual_Langtry_Menter.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=Max(1.0e-12,StrToFloat(sub));
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidual_Langtry_Menter.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=Max(1.0e-12,StrToFloat(sub));
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidual_Langtry_Menter.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=Max(1.0e-12,StrToFloat(sub));
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidual_Langtry_Menter.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=Trim(Copy(s,1,Pos(' ',s)));
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=Max(1.0e-12,StrToFloat(sub));
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidual_Langtry_Menter.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                                 s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                                 sub:=Trim(Copy(s,1,Pos(' ',s)));
                                 if (length(sub)>0) then
                                 begin
                                    if (StrToFloat(sub)<fmin) then
                                    begin
                                       fmin:=Max(1.0e-12,StrToFloat(sub));
                                    end;
                                    if (StrToFloat(sub)>fmax) then
                                    begin
                                       fmax:=StrToFloat(sub);
                                    end;
                                    FormResidual_Langtry_Menter.Chart1.SeriesList[6].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);



                                    s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                                    sub:=s;
                                    if (length(sub)>0) then
                                    begin
                                       if (StrToFloat(sub)<fmin) then
                                       begin
                                          fmin:=Max(1.0e-12,StrToFloat(sub));
                                       end;
                                       if (StrToFloat(sub)>fmax) then
                                       begin
                                          fmax:=StrToFloat(sub);
                                       end;
                                       FormResidual_Langtry_Menter.Chart1.SeriesList[7].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                                    end
                                     else
                                    begin
                                       // TODO
                                       // обрыв данных после первых трёх значений.
                                    end;
                                 end;
                              end;
                           end
                            else
                           begin
                              // TODO
                              // обрыв данных после первых трёх значений.
                           end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   //FormResidual_Langtry_Menter.Chart1.LeftAxis.Minimum:=fmin;
                   //FormResidual_Langtry_Menter.Chart1.LeftAxis.Maximum:=fmax;
                end;

                f.Free;
                Formresidual.brun_visible:=false;
                FormResidualSpallart_Allmares.brun_visibleSA:=false;
                FormResidualSST.brun_visibleSST:=false;
                FormResidualStandartKEpsilon.brun_visibleKEpsilon:=false;
                FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=true;
                FormResidual_Langtry_Menter.Show;
            end
            else
              if (Laplas.egddata.myflmod[0].iturbmodel=5) then
            begin
               // Standart K-epsilon model.
               // первые две строки нужно пропустить.
               FormResidualStandartKEpsilon.Chart1.SeriesList[0].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[1].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[2].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[3].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[4].Clear;
               FormResidualStandartKEpsilon.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualStandartKEpsilon.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualStandartKEpsilon.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualStandartKEpsilon.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualStandartKEpsilon.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualStandartKEpsilon.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualStandartKEpsilon.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                               end
                                else
                               begin
                                  // TODO
                                  // обрыв данных после первых трёх значений.
                               end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualStandartKEpsilon.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualStandartKEpsilon.Chart1.LeftAxis.Maximum:=fmax;
                end;

                f.Free;
                FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=false;
                Formresidual.brun_visible:=false;
                FormResidualSpallart_Allmares.brun_visibleSA:=false;
                FormResidualSST.brun_visibleSST:=false;
                FormResidualStandartKEpsilon.brun_visibleKEpsilon:=true;
                FormResidualStandartKEpsilon.Show;
            end
            else
              if (Laplas.egddata.myflmod[0].iturbmodel=4) then
            begin
               // SST K-Omega Menter.
               // первые две строки нужно пропустить.
               FormResidualSST.Chart1.SeriesList[0].Clear;
               FormResidualSST.Chart1.SeriesList[1].Clear;
               FormResidualSST.Chart1.SeriesList[2].Clear;
               FormResidualSST.Chart1.SeriesList[3].Clear;
               FormResidualSST.Chart1.SeriesList[4].Clear;
               FormResidualSST.Chart1.SeriesList[5].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSST.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSST.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSST.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSST.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=Trim(Copy(s,1,Pos(' ',s)));
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSST.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                              s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                              sub:=s;
                              if (length(sub)>0) then
                              begin
                                 if (StrToFloat(sub)<fmin) then
                                 begin
                                    fmin:=StrToFloat(sub);
                                 end;
                                 if (StrToFloat(sub)>fmax) then
                                 begin
                                    fmax:=StrToFloat(sub);
                                 end;
                                 FormResidualSST.Chart1.SeriesList[5].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                               end
                                else
                               begin
                                  // TODO
                                  // обрыв данных после первых трёх значений.
                               end;
                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSST.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSST.Chart1.LeftAxis.Maximum:=fmax;
                end;

                f.Free;
                FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=false;
                Formresidual.brun_visible:=false;
                FormResidualSpallart_Allmares.brun_visibleSA:=false;
                FormResidualStandartKEpsilon.brun_visibleKEpsilon:=false;
                FormResidualSST.brun_visibleSST:=true;
                FormResidualSST.Show;
            end
            else
             if (Laplas.egddata.myflmod[0].iturbmodel=3) then
            begin
               // Спаларт Аллмарес.
               // первые две строки нужно пропустить.
               FormResidualSpallart_Allmares.Chart1.SeriesList[0].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[1].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[2].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[3].Clear;
               FormResidualSpallart_Allmares.Chart1.SeriesList[4].Clear;
               for i:=2 to f.Count-1 do
               begin
                  fmin:=20.0;
                  fmax:=120.0;
                  s:=Trim(f.Strings[i]);
                  subx:=Trim(Copy(s,1,Pos(' ',s)));
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (StrToFloat(sub)<fmin) then
                  begin
                     fmin:=StrToFloat(sub);
                  end;
                  if (StrToFloat(sub)>fmax) then
                  begin
                     fmax:=StrToFloat(sub);
                  end;
                  FormResidualSpallart_Allmares.Chart1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                  s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                  sub:=Trim(Copy(s,1,Pos(' ',s)));
                  if (length(sub)>0) then
                  begin
                     if (StrToFloat(sub)<fmin) then
                     begin
                        fmin:=StrToFloat(sub);
                     end;
                     if (StrToFloat(sub)>fmax) then
                     begin
                        fmax:=StrToFloat(sub);
                     end;
                     FormResidualSpallart_Allmares.Chart1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                     s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                     sub:=Trim(Copy(s,1,Pos(' ',s)));
                     if (length(sub)>0) then
                     begin
                        if (StrToFloat(sub)<fmin) then
                        begin
                           fmin:=StrToFloat(sub);
                        end;
                        if (StrToFloat(sub)>fmax) then
                        begin
                           fmax:=StrToFloat(sub);
                        end;
                        FormResidualSpallart_Allmares.Chart1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                        s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                        sub:=Trim(Copy(s,1,Pos(' ',s)));
                        if (length(sub)>0) then
                        begin
                           if (StrToFloat(sub)<fmin) then
                           begin
                              fmin:=StrToFloat(sub);
                           end;
                           if (StrToFloat(sub)>fmax) then
                           begin
                              fmax:=StrToFloat(sub);
                           end;
                           FormResidualSpallart_Allmares.Chart1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);

                           s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                           sub:=s;
                           if (length(sub)>0) then
                           begin
                              if (StrToFloat(sub)<fmin) then
                              begin
                                 fmin:=StrToFloat(sub);
                              end;
                              if (StrToFloat(sub)>fmax) then
                              begin
                                 fmax:=StrToFloat(sub);
                              end;
                              FormResidualSpallart_Allmares.Chart1.SeriesList[4].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);

                            end
                             else
                            begin
                               // TODO
                               // обрыв данных после первых трёх значений.
                            end;
                         end
                          else
                         begin
                            // TODO
                            // обрыв данных после двух первых значений.
                         end;
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после двух первых значений.
                      end;
                   end
                    else
                   begin
                     // TODO
                     // обрыв данных.
                   end;
                   FormResidualSpallart_Allmares.Chart1.LeftAxis.Minimum:=fmin;
                   FormResidualSpallart_Allmares.Chart1.LeftAxis.Maximum:=fmax;
                end;


                f.Free;
                FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=false;
                FormResidualSST.brun_visibleSST:=false;
                Formresidual.brun_visible:=false;
                FormResidualStandartKEpsilon.brun_visibleKEpsilon:=false;
                FormResidualSpallart_Allmares.brun_visibleSA:=true;
                FormResidualSpallart_Allmares.Show;
            end
            else
            begin

             // первые две строки нужно пропустить.
             Formresidual.cht1.SeriesList[0].Clear;
             Formresidual.cht1.SeriesList[1].Clear;
             Formresidual.cht1.SeriesList[2].Clear;
             Formresidual.cht1.SeriesList[3].Clear;
             for i:=2 to f.Count-1 do
             begin
                fmin:=20.0;
                fmax:=120.0;
                s:=Trim(f.Strings[i]);
                subx:=Trim(Copy(s,1,Pos(' ',s)));
                s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                sub:=Trim(Copy(s,1,Pos(' ',s)));
                if (StrToFloat(sub)<fmin) then
                begin
                   fmin:=StrToFloat(sub);
                end;
                if (StrToFloat(sub)>fmax) then
                begin
                   fmax:=StrToFloat(sub);
                end;
                Formresidual.cht1.SeriesList[0].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clred);
                s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                sub:=Trim(Copy(s,1,Pos(' ',s)));
                if (length(sub)>0) then
                begin
                   if (StrToFloat(sub)<fmin) then
                   begin
                      fmin:=StrToFloat(sub);
                   end;
                   if (StrToFloat(sub)>fmax) then
                   begin
                      fmax:=StrToFloat(sub);
                   end;
                   Formresidual.cht1.SeriesList[1].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clgreen);
                   s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                   sub:=Trim(Copy(s,1,Pos(' ',s)));
                   if (length(sub)>0) then
                   begin
                      if (StrToFloat(sub)<fmin) then
                      begin
                         fmin:=StrToFloat(sub);
                      end;
                      if (StrToFloat(sub)>fmax) then
                      begin
                         fmax:=StrToFloat(sub);
                      end;
                      Formresidual.cht1.SeriesList[2].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clblue);
                      s:=Trim(Copy(s,Pos(' ',s),Length(s)));
                       if (pos(' ',Trim(s))=0) then
                       begin
                          sub:=s;
                       end
                        else
                       begin
                          sub:=Trim(Copy(s,1,Pos(' ',s)));
                       end;
                      if (length(sub)>0) then
                      begin
                         if (StrToFloat(sub)<fmin) then
                         begin
                            fmin:=StrToFloat(sub);
                         end;
                         if (StrToFloat(sub)>fmax) then
                         begin
                            fmax:=StrToFloat(sub);
                         end;
                         Formresidual.cht1.SeriesList[3].AddXY(StrToFloat(subx),StrToFloat(sub),subx,clOlive);
                      end
                       else
                      begin
                         // TODO
                         // обрыв данных после первых трёх значений.
                      end;

                    end
                     else
                    begin
                       // TODO
                       // обрыв данных после двух первых значений.
                    end;
                  end
                   else
                  begin
                     // TODO
                     // обрыв данных.
                  end;
                  Formresidual.cht1.LeftAxis.Minimum:=1e-4*fmin;
                  Formresidual.cht1.LeftAxis.Maximum:=1e4*fmax;
               end;

                f.Free;
                FormResidual_Langtry_Menter.brun_visible_Langtry_Menter:=false;
                FormResidualSST.brun_visibleSST:=false;
                FormResidualSpallart_Allmares.brun_visibleSA:=false;
                FormResidualStandartKEpsilon.brun_visibleKEpsilon:=false;
                Formresidual.brun_visible:=true;
                Formresidual.Show;
               end;

             end
              else
             begin
                MainMemo.Lines.Add('statistic_convergence.txt not found.');
             end;

        end;

end;

procedure TLaplas.FormClose(Sender: TObject; var Action: TCloseAction);
begin
   DeactivateRenderingContext; //деактивируем контекст рендеринга (разрываем связь между контекстами)
   DestroyRenderingContext(hrc); //разрушаем контекст рендеринга
   ReleaseDC(pnlPaint.Handle,dc); //разрушаем контекст устройства
end;

// если мы зажимаем правую кнопку мыши и перемещаем курсор при зажатой правой кнопке,
// а потом отпускаем правую кнопку то картинка перемещается в ту сторону в которую была перетащена мышь.
procedure TLaplas.pnlPaintMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
const
     epsilon = 0.01;
var
    dxz, dyz, dzz : Real;
    dxold, dyold, dzold, rm : Real;
    pnew, pold : Pointxy;
    mashtab, mul2 : Real;
begin
   isleep_render:=0; // Пауза при рендере.
   if (Button = mbLeft) then
   begin
      drawing:=false;
       ixo:=X; iyo:=Y;
   end
    else
   begin
      if (Button = mbMiddle) then
      begin

        // if (rgview.ItemIndex>0) then
        // begin
            // Здесь Z буффер включён,
            // мы используем новую функцию
            //  GetOGLPos( x : Integer;  y : Integer):Pointxy;

            (*
            mashtab:=sqrt(sqr(body[0].xE-body[0].xS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].zE-body[0].zS));
            pold:=GetOGLPos(ixo,iyo);
            pnew:=GetOGLPos(X,Y);
            //Oxc:=Oxc-0.07*mashtab*(pnew.x-pold.x);
            //Oyc:=Oyc-0.07*mashtab*(pnew.y-pold.y);
            //Ozc:=Ozc-0.07*mashtab*(pnew.z-pold.z);
            mashtab:=1.0;
            mul2:=1.0;
            if (perspectiveangle>60.0) then
            begin
              mul2:=0.1;
            end;
            Oxc:=Oxc-0.07*mul2*perspectiveangle*(pnew.x-pold.x);
            Oyc:=Oyc-0.07*mul2*perspectiveangle*(pnew.y-pold.y);
            Ozc:=Ozc-0.07*mul2*perspectiveangle*(pnew.z-pold.z);
            *)
             // Oxc:=Oxc-0.000001*mashtab*(pnew.x-pold.x);
            //Oyc:=Oyc-0.000001*mashtab*(pnew.y-pold.y);
            //Ozc:=Ozc-0.000001*mashtab*(pnew.z-pold.z);

            // Основание области видимости есть высота умноженная на тангенс полуугла перспективы.
            //mul2:=tan(0.5*perspectiveangle)*Hscale*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS));
            //Oxc:=Oxc-0.007*mul2*(pnew.x-pold.x)/mashtab;
            //Oyc:=Oyc-0.007*mul2*(pnew.y-pold.y)/mashtab;
            //Ozc:=Ozc-0.007*mul2*(pnew.z-pold.z)/mashtab;


         (*end
         else
         begin
         rm:=Sqrt(Sqr(body[0].xE-body[0].xS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].zE-body[0].zS));
         if ((Abs(Alf)<epsilon) and (Abs(Bet)<epsilon)) then
         begin
            dyold:=-(X-ixo)*0.005*(rm);
            dzold:=(Y-iyo)*0.005*(rm);
            dxold:=0.0;

            Oxc:=Oxc+dxold;
            Oyc:=Oyc+dyold;
            Ozc:=Ozc+dzold;
         end
         else
         begin

            dxold:=-(X-ixo)*0.005*(rm);
            dyold:=-(Y-iyo)*0.005*(rm);
            dzold:=0.0;


            // домножаем на обратную матрицу поворота, найденную аналитически в maple.
            dxz:=-dxold*sin(Alf)+dyold*cos(Alf)*cos(Bet)+dzold*cos(Alf)*sin(Bet);
            dyz:=-dyold*sin(Bet)+dzold*cos(Bet);
            dzz:=dxold*cos(Alf)+dyold*sin(Alf)*cos(Bet)+dzold*sin(Alf)*sin(Bet);


            Oxc:=Oxc+dxz;
            Oyc:=Oyc+dyz;
            Ozc:=Ozc+dzz;
         end;
         end;
         *)
         drawing:=false;
         ixo:=X; iyo:=Y;
      end
      else
   begin
      if (Button = mbRight) then
      begin
         drawing:=false;
         ixo:=X; iyo:=Y;
      end;
   end;
   end;
   button_right_push:=false;
end;



procedure TLaplas.pnlPaintMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
   // Ускоряем рендер.

   if (Button = mbLeft) then
   begin
      isleep_render:=0; // Пауза при рендере.
      drawing:=true;
      // запоминаем начальную позицию мыши
      ixo:=X;
      iyo:=Y;
      button_right_push:=false;
   end
    else
   begin
       if (Button = mbMiddle) then
       begin
          // Нажата правая кнопка мыши
          // запоминаем начальную позицию мыши
          isleep_render:=50; // Пауза при рендере.
          //drawing:=true;
          ixo:=X;
          iyo:=Y;
          button_right_push:=true;
       end;
   end;
end;

(*
// Устаревшее вращение две степени свободы.
procedure TLaplas.pnlPaintMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
   iAlf, iBet : Integer; // углы в градусах
   idx, idy : Integer;
begin
   if drawing then
   begin

      // Alf [-Pi..Pi]
      // Bet [-Pi..Pi]

      idx:=X-ixo;
      idy:=Y-iyo;
      if (idx>0) then Alf:=Alf+3.141/180; // добавляем один градус
      if (idx<0) then Alf:=Alf-3.141/180; // вычитаем один градус

      iAlf:=Round((Alf/3.141)*180);
      // конструкция приведённая ниже должна обеспечивать непрерывное
      // плавное вращение во всём спектре.
      if (iAlf>180) then
      begin
        iAlf:=-180+(iAlf-180);
      end
      else
      if (iAlf<-180) then
      begin
        iAlf:=180+(iAlf+180);
      end;
      Alf:=(iAlf/180)*3.141;

      if (idy>0) then Bet:=Bet+3.141/180; // добавляем один градус
      if (idy<0) then Bet:=Bet-3.141/180; // вычитаем один градус


      iBet:=Round((Bet/3.141)*180);
      //if ((iBet>90) or (iBet<-90)) then iBet:=iBet mod 90; // разрывы при вращении.
      // конструкция приведённая ниже должна обеспечивать непрерывное
      // плавное вращение во всём спектре.
      if (iBet>180) then
      begin
        iBet:=-180+(iBet-180);
      end
      else
      if (iBet<-180) then
      begin
        iBet:=180+(iBet+180);
      end;
      Bet:=(iBet/180)*3.141;

      ixo:=X; iyo:=Y;
   end;
end;
*)



procedure TLaplas.pnlPaintMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
const
    module_m=0.03;
var
   pnew, pold, paxis : Pointxy; // Вращение будет вокруг центра кабинета.
   oxc1, oyc1, ozc1, d1, d2, rotangle : Single;
   raddit : Single;
   mashtab, mul2, mul_sign : Real;
begin

    if (button_right_push) then
      begin
        // Нажата и удерживается правая кнопка
        // Перемещение.
        //if drawing then
        ///begin

         mashtab:=sqrt(sqr(body[0].xE-body[0].xS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].zE-body[0].zS));

             mul2:=1.0;
            if (perspectiveangle>60.0) then
            begin
              //mul2:=0.1;
            end;

        // Простейший способ без масштабирования по Oz.
          mul_sign:=1.0;
            if (X-ixo>0) then
            begin
              mul_sign:=1;
            end
            else
            begin
               mul_sign:=-1;
            end;

             mul_sign:=  mul_sign* mashtab;
            Oxc:=Oxc-module_m*mul2*perspectiveangle*mul_sign;

             mul_sign:=1.0;
            if (Y-iyo>0) then
            begin
              mul_sign:=-1;
            end
            else
            begin
               mul_sign:=1;
            end;
            mul_sign:=  mul_sign* mashtab;

            Oyc:=Oyc-module_m*mul2*perspectiveangle*mul_sign;

        (*
        // if (rgview.ItemIndex>0) then
        // begin
            // Здесь Z буффер включён,
            // мы используем новую функцию
            //  GetOGLPos( x : Integer;  y : Integer):Pointxy;
            mashtab:=sqrt(sqr(body[0].xE-body[0].xS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].zE-body[0].zS));
            pold:=GetOGLPos(ixo,iyo);
            pnew:=GetOGLPos(X,Y);

            mashtab:=1.0;
            mul2:=1.0;
            if (perspectiveangle>60.0) then
            begin
              mul2:=0.1;
            end;
            // Проблема в том что сдесь величина перемещения зависит от
            // позиции мыши, т.е она разная в центре экрана и на краях экрана.
            // Обычно в центре экрана скорость удовлетворительна а на краях
            // становится недопустимо высокой.
            //Oxc:=Oxc-0.007*mul2*perspectiveangle*(pnew.x-pold.x);
            //Oyc:=Oyc-0.007*mul2*perspectiveangle*(pnew.y-pold.y);
            //Ozc:=Ozc-0.007*mul2*perspectiveangle*(pnew.z-pold.z);

            // Здесь скорость сдвига не зависит от положения курсора
            // мыши в центре или на краю экрана, но от положения мыши
            // зависит лишь направление сдвига абсолютная величина которого фиксирована.
            mul_sign:=1.0;
            if (pnew.x-pold.x>0) then
            begin
              mul_sign:=0.01*abs(body[0].xE-body[0].xS);
            end
            else
            begin
               mul_sign:=-0.01*abs(body[0].xE-body[0].xS);
            end;

            Oxc:=Oxc-module_m*mul2*perspectiveangle*mul_sign;

             mul_sign:=1.0;
            if (pnew.y-pold.y>0) then
            begin
              mul_sign:=0.01*abs(body[0].yE-body[0].yS);
            end
            else
            begin
               mul_sign:=-0.01*abs(body[0].yE-body[0].yS);
            end;

            Oyc:=Oyc-module_m*mul2*perspectiveangle*mul_sign;

             mul_sign:=1.0;
            if (pnew.z-pold.z>0) then
            begin
              mul_sign:=0.01*abs(body[0].zE-body[0].zS);
            end
            else
            begin
               mul_sign:=-0.01*abs(body[0].zE-body[0].zS);
            end;
            Ozc:=Ozc-module_m*mul2*perspectiveangle*mul_sign;
            *)
           // end;
      end
      else
      begin
         // Нажата и удерживается левая кнопка
         // Вращение.


   if drawing then
   begin



      // Alf [-Pi..Pi]
      // Bet [-Pi..Pi]
      // Gam [-Pi..Pi]

      // ixo, iyo  - начальная позиция курсора мыши.
      // X, Y - конечная позиция курсора мыши.

      // точки в 3D соответствующие позициям мыши.
      raddit:= Hscale*sqrt(sqr(body[0].xS-body[0].xE)+sqr(body[0].yS-body[0].yE)+sqr(body[0].zS-body[0].zE));
      //MainMemo.Lines.Add(FloatToStr(raddit));
      pold:=GetOGLPos(ixo,iyo);
      pold.z:=pold.z+raddit;
      //MainMemo.Lines.Add(FloatToStr(pold.x)+' '+FloatToStr(pold.y)+' '+FloatToStr(pold.z));
      pnew:=GetOGLPos(X,Y);
      pnew.z:=pnew.z+raddit;
      //MainMemo.Lines.Add(FloatToStr(pnew.x)+' '+FloatToStr(pnew.y)+' '+FloatToStr(pnew.z));
      // центр кабинета.
      oxc1:=0.5*(body[0].xS+body[0].xE);
      oyc1:=0.5*(body[0].yS+body[0].yE);
      ozc1:=0.5*(body[0].zS+body[0].zE);
      //MainMemo.Lines.Add(FloatToStr(oxc1)+' '+FloatToStr(oyc1)+' '+FloatToStr(ozc1));
      //MainMemo.Lines.Add('====');
      // было без этого . начало.
      // Хотя по логике вроде с этим более правильно, но вращение какое-то получается неуправляемое.
      // Хотя и без мёртвых зон.
     // ozc1:=0.5*(body[0].zS+body[0].zE)-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS));
      // pold и pnew должны быть отнормированы на длину вектора [oxc1,oyc1,ozc1]
      d1:=Sqrt(oxc1*oxc1+oyc1*oyc1+ozc1*ozc1);
      // нормируем pold.
      d2:=Sqrt(Sqr(pold.x)+Sqr(pold.y)+Sqr(pold.z));
      if ((d1>1.0e-8) and (d2>1.0e-8)) then
      begin
         pold.x:=pold.x*d1/d2;
         pold.y:=pold.y*d1/d2;
         pold.z:=pold.z*d1/d2;
      end;
      // нормируем pnew.
      d2:=Sqrt(Sqr(pnew.x)+Sqr(pnew.y)+Sqr(pnew.z));
      if ((d1>1.0e-8) and (d2>1.0e-8)) then
      begin
         pnew.x:=pnew.x*d1/d2;
         pnew.y:=pnew.y*d1/d2;
         pnew.z:=pnew.z*d1/d2;
      end;
      // Диагностика положений опорных точек:
     // MainMemo.Lines.Add('diagnostic ocenter :'+FloatToStr(oxc1)+' '+FloatToStr(oyc1)+' '+FloatToStr(ozc1)+' ');
     // MainMemo.Lines.Add('diagnostic pold :'+FloatToStr(pold.x)+' '+FloatToStr(pold.y)+' '+FloatToStr(pold.z)+' ');
     // MainMemo.Lines.Add('diagnostic pnew :'+FloatToStr(pnew.x)+' '+FloatToStr(pnew.y)+' '+FloatToStr(pnew.z)+' ');
     // было без этого. конец.
      // вектора отложены от центра кабинета.
      pold.x:=pold.x-oxc1;
      pold.y:=pold.y-oyc1;
      pold.z:=pold.z-ozc1;
      pnew.x:=pnew.x-oxc1;
      pnew.y:=pnew.y-oyc1;
      pnew.z:=pnew.z-ozc1;
      // нормировка.
      d1:=sqrt(pold.x*pold.x+pold.y*pold.y+pold.z*pold.z);
      d2:=sqrt(pnew.x*pnew.x+pnew.y*pnew.y+pnew.z*pnew.z);
      if ((d1>1.0e-8)and(d2>1.0e-8)) then
      begin
         // нормируем получаем единичные вектора.
         pold.x:=pold.x/d1;
         pold.y:=pold.y/d1;
         pold.z:=pold.z/d1;
         pnew.x:=pnew.x/d2;
         pnew.y:=pnew.y/d2;
         pnew.z:=pnew.z/d2;
         // вычисление оси поворота как векторного произведения.
         paxis.x:=pold.y*pnew.z-pnew.y*pold.z;
         paxis.y:=pold.z*pnew.x-pnew.z*pold.x;
         paxis.z:=pold.x*pnew.y-pnew.x*pold.y;
         // нормировка.
         d1:=sqrt(paxis.x*paxis.x+paxis.y*paxis.y+paxis.z*paxis.z);
         if (d1>1.0e-8) then
         begin
            paxis.x:=paxis.x/d1;
            paxis.y:=paxis.y/d1;
            paxis.z:=paxis.z/d1;
            // Компоненты paxis могут быть как положительными так и отрицательными.
            // paxis - ось поворота.
            rotangle:=5.0/180; // амплитуда угла поворота.
            Alf:=Alf+rotangle*paxis.x;
            Bet:=Bet+rotangle*paxis.y;
            Gam:=Gam+rotangle*paxis.z;
            (*
            if (Alf>2.0*3.141) then
            begin
               Alf:=Alf-2.0*3.141;
            end;
             if (Bet>2.0*3.141) then
            begin
               Bet:=Bet-2.0*3.141;
            end;
             if (Gam>2.0*3.141) then
            begin
               Gam:=Gam-2.0*3.141;
            end;
             if (Alf<-2.0*3.141) then
            begin
               Alf:=Alf+2.0*3.141;
            end;
             if (Bet<-2.0*3.141) then
            begin
               Bet:=Bet+2.0*3.141;
            end;
             if (Gam<-2.0*3.141) then
            begin
               Gam:=Gam+2.0*3.141;
            end;
            *)
             if (Alf>3.141) then
            begin
               Alf:=Alf-2.0*3.141;
            end;
             if (Bet>3.141) then
            begin
               Bet:=Bet-2.0*3.141;
            end;
             if (Gam>3.141) then
            begin
               Gam:=Gam-2.0*3.141;
            end;
             if (Alf<-3.141) then
            begin
               Alf:=Alf+2.0*3.141;
            end;
             if (Bet<-3.141) then
            begin
               Bet:=Bet+2.0*3.141;
            end;
             if (Gam<-3.141) then
            begin
               Gam:=Gam+2.0*3.141;
            end;

            (*
            if (Alf>3.141) then
            begin
               Alf:=3.141-Alf;
            end;
             if (Bet>3.141) then
            begin
               Bet:=3.141-Bet;
            end;
             if (Gam>3.141) then
            begin
               Gam:=3.141-Gam;
            end;
            *)
            cosAlf:=cos(Alf);
            cosBet:=cos(Bet);
            sinAlf:=sin(Alf);
            sinBet:=sin(Bet);
         end;
      end;

      //ixo:=X; iyo:=Y;
      end;
   end;
end;



procedure TLaplas.Render;
const
  epsilon = 1.0e-20;
  bVisibleCount = 7;
  //dopusk = 0.01;// 0.005; // 0.01

var
    i, j, j3 : Integer;
    c, riso, ax : Real;
    code, itekpaint : Integer;
    bsel, bcontinue : Boolean;
    ch : Char;
    s : string;
    median_size : Single;
    amb0, spec0, diff0, light0_direction : array [0..3] of GLfloat;   // LITHT0
    amb1, spec1, diff1, light1_direction : array [0..3] of GLfloat;   // LITHT1
    direction_spoot, direction_spoot1 : array [0..2] of GLfloat;
    global_ambient, mdiffpat, mambpat, mspecpat, memispat : array [0..3] of GLfloat;
    //position, direction, up, right : TGLVectorf3;
    dopusk1, dopusk2 : GLfloat;   // 0.01;// 0.005; // 0.01
    radius, att, kQ, kL, kC, rmod : GLfloat;
    radius1, att1, kQ1, kL1, kC1, rmod1 : GLfloat;
    // для сглаживателя.
    hx, hy, rdivision : GLfloat;
    ihx, ihy, idivision : Integer;
    striso : String;
    iisoscan, i33 : Integer;
    sforval : String;
    raddit : GLfloat;
    // для каркасной визуализации цилиндра.
    dx33, dy33, r33, angle33 : GLfloat;
    icol : Integer;
    arr_ax : array of GLfloat;
    tmin, tmax : Real; // Локальный диапазхон для картинки.
    // При прорисовке каркасной модели мы нарисуем кубик немножко
    // большего размера для SOLID и FLUID и немножко меньшего
    // размера для HOLLOW. Константа dopusk будет регулировать насколько
    // больший (меньший) кубик будет нарисован.
    xS1, xE1, yS1, yE1, zS1, zE1 : Real; // координаты рёбер для отрисовки.


    function CheckLine(il1 : Integer; il2 : Integer) : Boolean;
    begin
       if ((il1<>4) and
           (il1<>8) and
           (il2<>4)and
           (il2<>8)and
           (il1=il2)) then
      begin
         Result:=true;
      end
       else
      begin
         if (((il1=1)and((il2=2)or(il2=3)or(il2=5)))
         or ((il2=1)and((il1=2)or(il1=3)or(il1=5))))  then
         begin
            Result:=true;
         end
         else
         if (((il1=3)and(il2=2))or
         ((il2=3)and(il1=2))) then
         begin
            Result:=true;
         end
         else
         if (((il1=7)and(il2=5))or
         ((il2=7)and(il1=5))) then
         begin
            Result:=true;
         end
         else
         if (((il1=7)and(il2=3))or
         ((il2=7)and(il1=3))) then
         begin
            Result:=true;
         end
         else
         //if (((il1=6)and(il2=3))or
         //((il2=6)and(il1=3))) then
         //begin
           // Result:=true;
         //end
         //else
          if (((il1=6)and(il2=5))or
         ((il2=6)and(il1=5))) then
         begin
            Result:=true;
         end
         else
         begin
            if (((il1=6)and(il2=7))or
                ((il2=6)and(il1=7)))then
                begin
                   Result:=true;
                end
                else
                begin
                   Result:=false;
                end;
         end;
      end;
    end;

// Пузырьковая сортировка по возрастанию ключа key.
procedure BubbleSort;
var
   i2, j2 : Integer;
   zchange : GBody;
begin
   // key - расстояние от камеры до прорисовываемого объекта
   // в последнюю очередь нужно прорисовывать самых близких, т.е с минимальным значением key.

   for i2:=1 to Length(blockgraphics)-1 do
   begin
	   for j2:=Length(blockgraphics)-1 downto i2 do
     begin
     		if (blockgraphics[j2-1].key > blockgraphics[j2].key) then
        begin
			     // swap
			     zchange:=blockgraphics[j2-1];
			     blockgraphics[j2-1]:=blockgraphics[j2];
			     blockgraphics[j2]:=zchange;
		    end;
	   end;
   end;
end; // BubbleSort

// Для генерации матрицы СЛАУ требуется в случае реализации
// на динамических массивах переупорядочивание элементов:
// сортировка. Здесь будет реализована быстрая сортировка.
// Брайан Керниган и Денис Ритчи "The C programming language".
// swap: Обмен местами v[i] и v[j]
procedure swap( i2 : Integer;  j2 : Integer);
var
   temp : GBody;
begin

		// change  blockgraphics[i2] <->  blockgraphics[j2]
		temp :=  blockgraphics[i2];
		blockgraphics[i2] :=  blockgraphics[j2];
		blockgraphics[j2] := temp;
end; // swap

// Для генерации матрицы СЛАУ требуется в случае реализации
// на динамических массивах переупорядочивание элементов:
// сортировка. Здесь будет реализована быстрая сортировка.
// Брайан Керниган и Денис Ритчи "The C programming language".
// swap: Обмен местами v[i] и v[j]
procedure swap2( i2 : Integer;  j2 : Integer);
var
   temp : VisibleGran;
begin

		// change  vg[i2] <->  vg[j2]
		temp :=  vg[i2];
		vg[i2] :=  vg[j2];
		vg[j2] := temp;
end; // swap2


// Вот алгоритм PivotList
function PivotList( first : Integer; last : Integer) : Integer;
var
   PivotValue : Real;
   PivotPoint, index : Integer;
begin
	// blockgraphics обрабатываемый список
	// first номер первого элемента
	// last номер последнего элемента

	PivotValue := blockgraphics[first].key;
	PivotPoint := first;

	for  index:=(first+1) to last do
  begin
  		if (blockgraphics[index].key<PivotValue) then
      begin
			   Inc(PivotPoint);
			   swap(PivotPoint, index);
	   	end;
	end;

	swap(first, PivotPoint);

	Result:=PivotPoint;
end; // PivotList

// Вот алгоритм PivotList
function PivotList2( first : Integer; last : Integer) : Integer;
var
   PivotValue : Real;
   PivotPoint, index : Integer;
begin
	// blockgraphics обрабатываемый список
	// first номер первого элемента
	// last номер последнего элемента

	PivotValue := vg[first].key;
	PivotPoint := first;

	for  index:=(first+1) to last do
  begin
  		if (blockgraphics[index].key<PivotValue) then
      begin
			   Inc(PivotPoint);
			   swap(PivotPoint, index);
	   	end;
	end;

	swap2(first, PivotPoint);

	Result:=PivotPoint;
end; // PivotList2


// Быстрая сортировка Хоара.
// Запрограммировано с использованием ДЖ. Макконелл Анализ алгоритмов
// стр. 106.
procedure QuickSort(first : Integer; last : Integer);
var
   pivot : Integer;
begin
	// blockgraphics - упорядочиваемый список элементов
	// first номер первого элемента в сортируемой части списка
	// last номер последнего элемента в сортируемой части списка


	if (first < last) then
  begin
     pivot := PivotList(first, last);
     QuickSort(first, pivot-1);
	   QuickSort(pivot+1, last);
	end;
end; // QuickSort

// Быстрая сортировка Хоара.
// Запрограммировано с использованием ДЖ. Макконелл Анализ алгоритмов
// стр. 106.
// 2 - сортировка граней.
procedure QuickSort2(first : Integer; last : Integer);
var
   pivot : Integer;
begin
	// blockgraphics - упорядочиваемый список элементов
	// first номер первого элемента в сортируемой части списка
	// last номер последнего элемента в сортируемой части списка


	if (first < last) then
  begin
     pivot := PivotList2(first, last);
     QuickSort2(first, pivot-1);
	   QuickSort2(pivot+1, last);
	end;
end; // QuickSort2

// Возвращает преобразованную позицию камеры.
function move_camera(cnd : Char): Single;
var
  a1,b1,r1, ret : Single;
begin
   // Oxc, Oyc, Ozc
   // преобразование из декартовых координат в сферические.
   r1:=Sqrt(Oxc*Oxc+Oyc*Oyc+Ozc*Ozc);
   // если r1 не ноль.
   if (Abs(r1)>0.001) then
   begin
      b1:=3.141*arcsin(Ozc/r1)/180.0;

      if (Oxc>0.001) then
      begin
         a1:=ArcTan(Oyc/Oxc);
      end;
      if (Abs(Oxc)<=0.001) then
      begin
         if (Oyc>0.0) then
         begin
            a1:=3.141/2.0;
         end;
         if (Oyc<0.0) then
         begin
            a1:=-3.141/2.0;
         end;
      end;
      if (Oxc<-0.001) then
      begin
         if (Oyc>0.001) then
         begin
            a1:=3.141/2.0+ArcTan(Abs(Oxc)/Oyc);
         end;
         if (Oyc<-0.001) then
         begin
            a1:=-3.141/2.0-ArcTan(Abs(Oxc)/Abs(Oyc));
         end;
         if (Abs(Oyc)<0.001) then
         begin
            a1:=-3.141;
         end;
      end;


      case cnd of
      'x' : begin
               ret:=r1*cos(b1+Bet)*cos(a1+Alf);
            end;
      'y' : begin
               ret:=r1*cos(b1+Bet)*sin(a1+Alf);
            end;
      'z' : begin
               ret:=r1*sin(b1+Bet);
            end;
      end;
   end
   else
   begin
      ret:=0.0;
   end;

   Result:=ret;
end;


function binvisible_face_detectq(nx : Real;
ny : Real; nz : Real): Boolean;
var
   nz1 : Real;
begin

   // Использует заранее вычисленные значения синуса и косинуса.
   nz1:= -sinBet*CosAlf*nx + sinAlf*ny + cosAlf*cosBet*nz;
   if (nz1>-1.0e-3) then
   begin
      Result:=true;
   end
   else
   begin
      Result:=false;
   end;
end;

function binvisible_face_detect(nx : Real;
ny : Real; nz : Real): Boolean;
var
   br : Boolean;
   mx : array [1..3] of  array [1..3] of Real;
   my : array [1..3] of  array [1..3] of Real;
   mz0 : array [1..3] of  array [1..3] of Real;
   mz : array [1..3] of  array [1..3] of Real;
   mr : array [1..3] of  array [1..3] of Real;
   mr1 : array [1..3] of  array [1..3] of Real;
   i88, j88, k88 : Integer;
   nx1,ny1,nz1 : Real;
begin
   // (nx,ny,nz) - нормаль.
   //
   br:=true;

  // glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
   //glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
   //glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
   //glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
    // Матрица поворота вокруг оси Oz
   mz0[1][1]:=cos(Gam0); mz0[1][2]:=-sin(Gam0); mz0[1][3]:=0.0;
   mz0[2][1]:=sin(Gam0); mz0[2][2]:=cos(Gam0); mz0[2][3]:=0.0;
   mz0[3][1]:=0.0; mz0[3][2]:=0.0; mz0[3][3]:=1.0;
   // Матрица поворота вокруг оси Ox
   mx[1][1]:=1.0; mx[1][2]:=0.0; mx[1][3]:=0.0;
   mx[2][1]:=0.0; mx[2][2]:=cos(Alf); mx[2][3]:=-sin(Alf);
   mx[3][1]:=0.0; mx[3][2]:=sin(Alf); mx[3][3]:=cos(Alf);
   // Матрица поворота вокруг оси Oy
   my[1][1]:=cos(Bet); my[1][2]:=0.0; my[1][3]:=sin(Bet);
   my[2][1]:=0.0; my[2][2]:=1.0; my[2][3]:=0.0;
   my[3][1]:=-sin(Bet); my[3][2]:=0.0; my[3][3]:=cos(Bet);
   // Матрица поворота вокруг оси Oz
   mz[1][1]:=cos(Gam); mz[1][2]:=-sin(Gam); mz[1][3]:=0.0;
   mz[2][1]:=sin(Gam); mz[2][2]:=cos(Gam); mz[2][3]:=0.0;
   mz[3][1]:=0.0; mz[3][2]:=0.0; mz[3][3]:=1.0;

   mr[1][1]:=0.0; mr[1][2]:=0.0; mr[1][3]:=0.0;
   mr[2][1]:=0.0; mr[2][2]:=0.0; mr[2][3]:=0.0;
   mr[3][1]:=0.0; mr[3][2]:=0.0; mr[3][3]:=0.0;
   for i88 := 1 to 3 do
   begin
     for j88 := 1 to 3 do
     begin
        for k88 := 1 to 3 do
        begin
           mr[i88][j88]:=mr[i88][j88]+mz0[i88][k88]*mx[k88][j88];
        end;
     end;
   end;
   mr1[1][1]:=0.0; mr1[1][2]:=0.0; mr1[1][3]:=0.0;
   mr1[2][1]:=0.0; mr1[2][2]:=0.0; mr1[2][3]:=0.0;
   mr1[3][1]:=0.0; mr1[3][2]:=0.0; mr1[3][3]:=0.0;
   for i88 := 1 to 3 do
   begin
     for j88 := 1 to 3 do
     begin
        for k88 := 1 to 3 do
        begin
           mr1[i88][j88]:=mr1[i88][j88]+mr[i88][k88]*my[k88][j88];
        end;
     end;
   end;
   for i88 := 1 to 3 do
   begin
      for j88 := 1 to 3 do
      begin
         mr[i88][j88]:=mr1[i88][j88];
         mr1[i88][j88]:=0.0;
      end;
   end;
   for i88 := 1 to 3 do
   begin
     for j88 := 1 to 3 do
     begin
        for k88 := 1 to 3 do
        begin
           mr1[i88][j88]:=mr1[i88][j88]+mr[i88][k88]*mz[k88][j88];
        end;
     end;
   end;
   nx1:=0.0;
   ny1:=0.0;
   nz1:=0.0;
   nx1:=mr1[1][1]*nx+mr1[1][2]*ny+mr1[1][3]*nz;
   ny1:=mr1[2][1]*nx+mr1[2][2]*ny+mr1[2][3]*nz;
   nz1:=mr1[3][1]*nx+mr1[3][2]*ny+mr1[3][3]*nz;

   //if (nx*nx1+ny*ny1+nz*nz1>-1.0e-3) then
   if (nz1>-1.0e-3) then
   begin
      br:=true;
   end
   else
   begin
      br:=false;
   end;

   if (br) then
   begin
      Result:=true;
   end
   else
   begin
       Result:=false;
   end;
end;


begin

    // 25.11.2019
    // Значение допуска для z-буффера задается пользователем.
    dopusk1:=dopusk_gl1; // для наибольшей протяженности объекта.
    dopusk2:=dopusk_gl2; // для наименьшей протяженности объекта.


    // z буфер теперь используется для всех трёх режимов.
    //очищаем буфер цвета и буфер глубины
    glEnable(GL_DEPTH_TEST);  // может надо выключить.
    //glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
    glClear(GL_COLOR_BUFFER_BIT);
    glClear(GL_DEPTH_BUFFER_BIT);
   (*
   if (rgview.ItemIndex>0) then
   begin
      glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT); //очищаем буфер цвета и буфер глубины
   end
    else
   begin
      glClear(GL_COLOR_BUFFER_BIT);
   end;
   *)

     glEnable(GL_COLOR_MATERIAL);
     glEnable(GL_NORMALIZE);// автоматическая нормировка нормалей под единичные.

   (*
   if ((rgview.ItemIndex=2)) then
   begin

      glEnable(GL_LIGHTING); //включаем освещение
      //glEnable(GL_COLOR_MATERIAL);

      //glEnable(GL_NORMALIZE);// автоматическая нормировка нормалей под единичные.

      if (CheckBoxOnLitht.Checked=true) then
      begin
         // включить источник света.
         // если не освещать то объект будет закрашен сплошным белым цветом.


         glEnable(GL_LIGHT0); //включаем источник света №0


         amb0[0]:=lamb;
         amb0[1]:=lamb;
         amb0[2]:=lamb;
         amb0[3]:=1.0;
         glLightfv(GL_LIGHT0, GL_AMBIENT, @amb0);

         // настроим зеркальное отражение.
         spec0[0] := lspec;
         spec0[1] := lspec;
         spec0[2] := lspec;
         spec0[3] := 1.0;
         glLightfv(GL_LIGHT0, GL_SPECULAR, @spec0);

          // настроим диффузионную составляющую света.
         diff0[0] := ldiff;
         diff0[1] := ldiff;
         diff0[2] := ldiff;
         diff0[3] := 1.0;
         glLightfv(GL_LIGHT0, GL_DIFFUSE, @diff0);


         direction_spoot[0]:=-mldx;
         direction_spoot[1]:=-mldy;
         direction_spoot[2]:=-4;
         rmod:=Sqrt(sqr(direction_spoot[0])+sqr(direction_spoot[1])+sqr(direction_spoot[2]));
         direction_spoot[0]:=direction_spoot[0]/rmod;
         direction_spoot[1]:=direction_spoot[1]/rmod;
         direction_spoot[2]:=direction_spoot[2]/rmod;


         // Свойства материалов.
         mdiffpat[0]:=matdiff;
         mdiffpat[1]:=matdiff;
         mdiffpat[2]:=matdiff;
         mdiffpat[3]:=1.0;
         glmaterialfv( GL_FRONT_AND_BACK, GL_DIFFUSE, @mdiffpat);
         mambpat[0]:=matamb;
         mambpat[1]:=matamb;
         mambpat[2]:=matamb;
         mambpat[3]:=1.0;
         glmaterialfv( GL_FRONT_AND_BACK, GL_AMBIENT, @mambpat);

         if (ChkSpecular.Checked=true) then
         begin
            // настроим зеркальное отражение.
            mspecpat[0] := rspec;
            mspecpat[1] := rspec;
            mspecpat[2] := rspec;
            mspecpat[3] := 1.0;
            glmaterialfv( GL_FRONT_AND_BACK, GL_SPECULAR, @mspecpat);
         end
          else
         begin
            // default
            mspecpat[0] := 0.0;
            mspecpat[1] := 0.0;
            mspecpat[2] := 0.0;
            mspecpat[3] := 1.0;
            glmaterialfv( GL_FRONT_AND_BACK, GL_SPECULAR, @mspecpat);
         end;
         if (ChkEmis.Checked=true) then
         begin
            // настроим собственное излучение
            memispat[0]:=remis;
            memispat[1]:=remis;
            memispat[2]:=remis;
            memispat[3]:=1.0;
            glmaterialfv( GL_FRONT_AND_BACK,GL_EMISSION, @memispat);
         end
         else
         begin
            // default
            memispat[0]:=0.0;
            memispat[1]:=0.0;
            memispat[2]:=0.0;
            memispat[3]:=1.0;
            glmaterialfv( GL_FRONT_AND_BACK,GL_EMISSION, @memispat);
         end;
         if (Chkblick.Checked=true) then
         begin
            //[0..128]
            glmaterialf ( GL_FRONT_AND_BACK ,GL_SHININESS, rblick); // мощность блика  0
         end
         else
         begin
            glmaterialf ( GL_FRONT_AND_BACK ,GL_SHININESS, 0);
         end;

         if (chkGlobalAmbient.Checked=true) then
         begin
            global_ambient[0]:=glamb0;
            global_ambient[1]:=glamb0;
            global_ambient[2]:=glamb0;
            global_ambient[3]:=1.0;
            glLightModelfv(GL_LIGHT_MODEL_AMBIENT,@global_ambient);
         end
         else
         begin
            global_ambient[0]:=0.0;
            global_ambient[1]:=0.0;
            global_ambient[2]:=0.0;
            global_ambient[3]:=1.0;
            glLightModelfv(GL_LIGHT_MODEL_AMBIENT,@global_ambient);
         end;

         if (CheckBoxPointSources.Checked=false) then
         begin
             // бесконечно удалённый источник света.
             light0_direction[0]:=0.0;
             light0_direction[1]:=0.0;
             light0_direction[2]:=1.0;
             light0_direction[3]:=0.0;
             glLightfv(GL_LIGHT0,GL_POSITION,@light0_direction);

             kQ:=0.0;
             kL:=0.0;
             kC:=1.0;
             glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, kC);
             glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, kL);
             glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, kQ);
             glmaterialf ( GL_FRONT_AND_BACK ,GL_SHININESS, 0);
         end
          else
         begin
             light0_direction[0]:=Oxc+mldx*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS));
             light0_direction[1]:=Oyc+mldy*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS));
             light0_direction[2]:=Ozc-1.0*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS));
             light0_direction[3]:=1.0;
             glLightfv(GL_LIGHT0,GL_POSITION,@light0_direction);

             glLightf(GL_LIGHT0, GL_SPOT_CUTOFF, lithtangle);
             glLightf(GL_LIGHT0, GL_SPOT_EXPONENT, lithtexponent);

             if (CheckBoxDistance.Checked=true) then
             begin
                att:=matt*1.0;
                radius:=mr*4.0*(Hscale/5.0)*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS));
                kQ:=att/(3.0*radius*radius);
                kL:=att/(3.0*radius);
                kC:=att/3.0;
                glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, kC);
                glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, kL);
                glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, kQ);
             end
             else
             begin
                kQ:=0.0;
                kL:=0.0;
                kC:=1.0;
                glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, kC);
                glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, kL);
                glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, kQ);
                glmaterialf ( GL_FRONT_AND_BACK ,GL_SHININESS, 0);
             end;
         end;

      end;


      if (ChkOnLitht1.Checked=true) then
      begin
         // включить источник света.
         // если не освещать то объект будет закрашен сплошным белым цветом.


         glEnable(GL_LIGHT1); //включаем источник света №0


         amb1[0]:=lamb1;
         amb1[1]:=lamb1;
         amb1[2]:=lamb1;
         amb1[3]:=1.0;
         glLightfv(GL_LIGHT1, GL_AMBIENT, @amb1);

         // настроим зеркальное отражение.
         spec1[0] := lspec1;
         spec1[1] := lspec1;
         spec1[2] := lspec1;
         spec1[3] := 1.0;
         glLightfv(GL_LIGHT1, GL_SPECULAR, @spec1);

          // настроим диффузионную составляющую света.
         diff1[0] := ldiff1;
         diff1[1] := ldiff1;
         diff1[2] := ldiff1;
         diff1[3] := 1.0;
         glLightfv(GL_LIGHT1, GL_DIFFUSE, @diff1);


         direction_spoot1[0]:=-mldx1;
         direction_spoot1[1]:=-mldy1;
         direction_spoot1[2]:=-4;
         rmod1:=Sqrt(sqr(direction_spoot1[0])+sqr(direction_spoot1[1])+sqr(direction_spoot1[2]));
         direction_spoot1[0]:=direction_spoot1[0]/rmod1;
         direction_spoot1[1]:=direction_spoot1[1]/rmod1;
         direction_spoot1[2]:=direction_spoot1[2]/rmod1;






         if (chkDiskretSource1.Checked=false) then
         begin
             // бесконечно удалённый источник света.
             light1_direction[0]:=0.0;
             light1_direction[1]:=0.0;
             light1_direction[2]:=1.0;
             light1_direction[3]:=0.0;
             glLightfv(GL_LIGHT1,GL_POSITION,@light1_direction);

             kQ1:=0.0;
             kL1:=0.0;
             kC1:=1.0;
             glLightf(GL_LIGHT1, GL_CONSTANT_ATTENUATION, kC1);
             glLightf(GL_LIGHT1, GL_LINEAR_ATTENUATION, kL1);
             glLightf(GL_LIGHT1, GL_QUADRATIC_ATTENUATION, kQ1);

         end
          else
         begin
             light1_direction[0]:=Oxc+mldx1*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS));
             light1_direction[1]:=Oyc+mldy1*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS));
             light1_direction[2]:=Ozc-1.0*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS));
             light1_direction[3]:=1.0;
             glLightfv(GL_LIGHT1,GL_POSITION,@light1_direction);

             glLightf(GL_LIGHT1, GL_SPOT_CUTOFF, lithtangle1);
             glLightf(GL_LIGHT1, GL_SPOT_EXPONENT, lithtexponent1);

             if (ChkDistance1.Checked=true) then
             begin
                att1:=matt1*1.0;
                radius1:=mr1*4.0*(Hscale/5.0)*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS));
                kQ1:=att1/(3.0*radius1*radius1);
                kL1:=att1/(3.0*radius1);
                kC1:=att1/3.0;
                glLightf(GL_LIGHT1, GL_CONSTANT_ATTENUATION, kC1);
                glLightf(GL_LIGHT1, GL_LINEAR_ATTENUATION, kL1);
                glLightf(GL_LIGHT1, GL_QUADRATIC_ATTENUATION, kQ1);
             end
             else
             begin
                kQ1:=0.0;
                kL1:=0.0;
                kC1:=1.0;
                glLightf(GL_LIGHT1, GL_CONSTANT_ATTENUATION, kC1);
                glLightf(GL_LIGHT1, GL_LINEAR_ATTENUATION, kL1);
                glLightf(GL_LIGHT1, GL_QUADRATIC_ATTENUATION, kQ1);
             end;
         end;

      end;


   end;
   *)


   //эти команды мы изучим позже
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity;
   gluPerspective(perspectiveangle,pnlPaint.Width/pnlPaint.Height,NearClipping,FarClipping);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity;
   //
   (*
   if (Bet>6.282) then
   begin
      Bet:=Bet-6.282;
   end;
   if (Bet<-6.282) then
   begin
      Bet:=Bet+6.282;
   end;
   if (((Bet>3.9) and (Bet<5.46)) or ((Bet>0.78) and (Bet<2.35)) or ((Bet<-0.78) and (Bet>-2.35)) or (((Bet<-3.9) and (Bet>-5.46)))) then
   begin
      gluLookAt(Oxc+R1*cos(Bet)*cos(Alf),Oyc+R1*cos(Bet)*sin(Alf), Ozc-Hscale*(body[0].zE-body[0].zS)+R1*sin(Bet),Oxc,Oyc, Ozc-Hscale*(body[0].zE-body[0].zS),0.0,1.0,0.0);
   end
    else
   begin
      gluLookAt(Oxc+R1*cos(Bet)*cos(Alf),Oyc+R1*cos(Bet)*sin(Alf), Ozc-Hscale*(body[0].zE-body[0].zS)+R1*sin(Bet),Oxc,Oyc, Ozc-Hscale*(body[0].zE-body[0].zS),0.0,0.0,1.0);
   end;
   *)
   (*
   if (cos(Bet)>0.0) then
   begin
      // смотрим вниз.
      gluLookAt(Oxc+R1*cos(Bet)*cos(Alf),Oyc+R1*cos(Bet)*sin(Alf), Ozc-Hscale*(body[0].zE-body[0].zS)+R1*sin(Bet),Oxc,Oyc, Ozc-Hscale*(body[0].zE-body[0].zS),0.0,0.0,1.0);
   end
   else
   begin
      // смотрим вверх.
      gluLookAt(Oxc+R1*cos(Bet)*cos(Alf),Oyc+R1*cos(Bet)*sin(Alf), Ozc-Hscale*(body[0].zE-body[0].zS)+R1*sin(Bet),Oxc,Oyc, Ozc-Hscale*(body[0].zE-body[0].zS),0.0,0.0,-1.0);
   end;
   *)

   //if (cos(Bet)>0.0) then
   //begin
      // смотрим вниз.
    // gluLookAt(Oxc(*+R1*cos(Bet)*cos(Alf)*),Oyc(*+R1*cos(Bet)*sin(Alf)*), Ozc(*-Hscale*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS))*)(*+R1*sin(Bet)*),Oxc,Oyc, Ozc-Hscale*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS)),0.0,0.05,0.95);
   //end
   //else
   //begin
      // смотрим вверх.
    //  gluLookAt(Oxc+R1*cos(Bet)*cos(Alf),Oyc+R1*cos(Bet)*sin(Alf), Ozc(*-Hscale*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS))*)+R1*sin(Bet),Oxc,Oyc, Ozc-Hscale*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS)),0.0,0.0,-1.0);
   //end;

   // откуда, куда, нормаль
    if (not(bvisiblepic)) then
    begin
       gluLookAt(Oxc,Oyc,Ozc,  Oxc,Oyc,
       Ozc-Hscale*sqrt(sqr(body[0].zE-body[0].zS)+
       sqr(body[0].yE-body[0].yS)+
       sqr(body[0].xE-body[0].xS)),0.0,0.05,0.95);
    end
     else
    begin
       gluLookAt(Oxc,Oyc,Ozc,  Oxc,Oyc,
        Ozc-Hscale*sqrt(sqr(zmaxpic-zminpic)+
        sqr(ymaxpic-yminpic)+
        sqr(xmaxpic-xminpic)),0.0,0.05,0.95);
    end;

   (*
   // 17 марта 2015.
    if (cos(Bet)>0.0) then
   begin
      // смотрим вниз.
      gluLookAt(move_camera('x')+R1*cos(Bet)*cos(Alf),move_camera('y')+R1*cos(Bet)*sin(Alf), move_camera('z')-Hscale*(body[0].zE-body[0].zS)+R1*sin(Bet),move_camera('x'),move_camera('y'), move_camera('z')-Hscale*(body[0].zE-body[0].zS),0.0,0.0,1.0);
   end
   else
   begin
      // смотрим вверх.
      gluLookAt(move_camera('x')+R1*cos(Bet)*cos(Alf),move_camera('y')+R1*cos(Bet)*sin(Alf), move_camera('z')-Hscale*(body[0].zE-body[0].zS)+R1*sin(Bet),move_camera('x'),move_camera('y'), move_camera('z')-Hscale*(body[0].zE-body[0].zS),0.0,0.0,-1.0);
   end;
   *)

   (*
   Position[0]:=Oxc;
   Position[1]:=Oyc;
   Position[2]:=Ozc;
   right[0]:=Sin(Alf-0.5*3.141);
   right[1]:=0.0;
   right[2]:=Cos(Alf-0.5*3.141);
   direction[0]:=Cos(Bet)*sin(Alf);
   direction[1]:=Sin(Bet);
   direction[2]:=Cos(Bet)*cos(Alf);
   up:=CrossVector(right,direction);// векторное произведение.
   gluLookAt(position,position+direction, up);
   *)





  (*
   glBegin(GL_TRIANGLES); //рисуем треугольник
	glColor3f(1,0,0);  glVertex3f(0,5,1); //первая вершина
	glColor3f(0,1,0);  glVertex3f(1,4,1); //вторая вершина
	glColor3f(0,1,0);  glVertex3f(-1,4,1); //третья вершина
	glEnd;*)

  (*
  glBegin(GL_TRIANGLES); //рисуем треугольник
	 glVertex3f(0,5,1); //первая вершина
	 glVertex3f(1,4,1); //вторая вершина
	 glVertex3f(-1,4,1); //третья вершина
	glEnd;
  *)
  (*
  glBegin(GL_QUADS); //рисуем квадрат
	glColor3f(1,0,0);  glVertex3f(Laplas.body[0].xS,Laplas.body[0].yS,Laplas.body[0].zS); //первая вершина
	glColor3f(0,1,0);  glVertex3f(Laplas.body[0].xS,Laplas.body[0].yE,Laplas.body[0].zS); //вторая вершина
	glColor3f(0,1,1);  glVertex3f(Laplas.body[0].xE,Laplas.body[0].yE,Laplas.body[0].zS); //третья вершина
	glColor3f(0,0,1);  glVertex3f(Laplas.body[0].xE,Laplas.body[0].yS,Laplas.body[0].zS); //четвёртая вершина
	glEnd;*)

  //glTranslatef(0.0,0.0,-3.0);
  (*
  glBegin(GL_QUADS); //рисуем квадрат
	   glColor3f(1,0,0);  glVertex3f(-1.0,-1.0,0.0); //первая вершина
	   glColor3f(0,1,0);  glVertex3f(1.0,-1.0,0.0); //вторая вершина
	   glColor3f(0,1,1);  glVertex3f(1.0,1.0,0.0); //третья вершина
	   glColor3f(0,0,1);  glVertex3f(-1.0,1.0,0.0); //четвёртая вершина
	glEnd;
  *)

  if ((not(bvisiblepic))and (rgview.ItemIndex<>2)) then
  begin
     // На дне мы нарисуем огромный квадрат.
     raddit:=5000.2*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS));

        // Если это делать и при rgview.ItemIndex=2 то мы получим чёрный чёрный фон.
        glpushMatrix;
          glTranslatef(0,0,-6.2*((Hscale/5.0))*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
          glBegin(GL_QUADS); //рисуем квадрат
             // Цвет белый ! glColor3f(1,1,1);
             // Белым цветом против часовой стрелки.
	           glColor3f(1,1,1);
             glNormal3f(0.0,0.0,1.0);
             glVertex3f(-raddit,-raddit,0.0); // первая вершина
	           glColor3f(1,1,1);
             glNormal3f(0.0,0.0,1.0);
             glVertex3f(raddit,-raddit,0.0); // вторая вершина
	           glColor3f(1,1,1);
             glNormal3f(0.0,0.0,1.0);
             glVertex3f(raddit,raddit,0.0); // третья вершина
	           glColor3f(1,1,1);
             glNormal3f(0.0,0.0,1.0);
             glVertex3f(-raddit,raddit,0.0); // четвёртая вершина
	        glEnd;
        glPopmatrix;
 end
 else
 begin
     raddit:=5000.2*sqrt(sqr(zmaxpic-zminpic)+sqr(ymaxpic-yminpic)+sqr(xmaxpic-xminpic));

        // Если это делать и при rgview.ItemIndex=2 то мы получим чёрный чёрный фон.
        glpushMatrix;
          glTranslatef(0,0,-6.2*((Hscale/5.0))*sqrt(sqr(zmaxpic-zminpic)+sqr(ymaxpic-yminpic)+sqr(xmaxpic-xminpic)));
          glBegin(GL_QUADS); //рисуем квадрат
             // Цвет белый ! glColor3f(1,1,1);
             // Белым цветом против часовой стрелки.
	           glColor3f(1,1,1);
             glNormal3f(0.0,0.0,1.0);
             glVertex3f(-raddit,-raddit,0.0); // первая вершина
	           glColor3f(1,1,1);
             glNormal3f(0.0,0.0,1.0);
             glVertex3f(raddit,-raddit,0.0); // вторая вершина
	           glColor3f(1,1,1);
             glNormal3f(0.0,0.0,1.0);
             glVertex3f(raddit,raddit,0.0); // третья вершина
	           glColor3f(1,1,1);
             glNormal3f(0.0,0.0,1.0);
             glVertex3f(-raddit,raddit,0.0); // четвёртая вершина
	        glEnd;
        glPopmatrix;
 end;


  case rgview.ItemIndex of
  0 : // Обычная стандартная прорисовка всех линий (это то что было раньше)
  begin

   if (bvisiblepic) then
   begin
     //  Прорисовка расчётной сетки и если изометрия то трёхмерной геометрии
     // считанной из tecplot файла информации.
      // Прорисовка остальных блоков.


     // Корректировка цветовой шкалы  06.09.2019
     // Вычисляем границы изменения локально для каждой текущей картинки.
     //if (cbbview.ItemIndex>0) then
     //begin
         tmin:=1.0e30;
         tmax:=-1.0e30;
     //end;
     if (icurrentpic>0) then
     begin
        for j:=0 to epic-1 do
        begin
           case cbbview.ItemIndex of
            1 : // XY
                begin
                   if ((risopic>=zpic[elmpic[j].i1-1])and(risopic<=zpic[elmpic[j].i5-1])) then
                   begin
                      if (temppicpotent[icurrentpic-1][elmpic[j].i1-1]>tmax) then
                      begin
                         tmax:=temppicpotent[icurrentpic-1][elmpic[j].i1-1];
                      end;
                      if (temppicpotent[icurrentpic-1][elmpic[j].i1-1]<tmin) then
                      begin
                         tmin:=temppicpotent[icurrentpic-1][elmpic[j].i1-1];
                      end;
                      if (temppicpotent[icurrentpic-1][elmpic[j].i2-1]>tmax) then
                      begin
                         tmax:=temppicpotent[icurrentpic-1][elmpic[j].i2-1];
                      end;
                      if (temppicpotent[icurrentpic-1][elmpic[j].i2-1]<tmin) then
                      begin
                         tmin:=temppicpotent[icurrentpic-1][elmpic[j].i2-1];
                      end;
                      if (temppicpotent[icurrentpic-1][elmpic[j].i3-1]>tmax) then
                      begin
                         tmax:=temppicpotent[icurrentpic-1][elmpic[j].i3-1];
                      end;
                      if (temppicpotent[icurrentpic-1][elmpic[j].i3-1]<tmin) then
                      begin
                         tmin:=temppicpotent[icurrentpic-1][elmpic[j].i3-1];
                      end;
                      if (temppicpotent[icurrentpic-1][elmpic[j].i4-1]>tmax) then
                      begin
                         tmax:=temppicpotent[icurrentpic-1][elmpic[j].i4-1];
                      end;
                      if (temppicpotent[icurrentpic-1][elmpic[j].i4-1]<tmin) then
                      begin
                         tmin:=temppicpotent[icurrentpic-1][elmpic[j].i4-1];
                      end;
                   end;
                end;
             2 : // XZ
                 begin
                    if ((risopic>=ypic[elmpic[j].i1-1])and(risopic<=ypic[elmpic[j].i4-1])) then
                    begin

                       if (temppicpotent[icurrentpic-1][elmpic[j].i1-1]>tmax) then
                       begin
                          tmax:=temppicpotent[icurrentpic-1][elmpic[j].i1-1];
                       end;
                       if (temppicpotent[icurrentpic-1][elmpic[j].i1-1]<tmin) then
                       begin
                          tmin:=temppicpotent[icurrentpic-1][elmpic[j].i1-1];
                       end;
                       if (temppicpotent[icurrentpic-1][elmpic[j].i2-1]>tmax) then
                       begin
                          tmax:=temppicpotent[icurrentpic-1][elmpic[j].i2-1];
                       end;
                       if (temppicpotent[icurrentpic-1][elmpic[j].i2-1]<tmin) then
                       begin
                          tmin:=temppicpotent[icurrentpic-1][elmpic[j].i2-1];
                       end;
                       if (temppicpotent[icurrentpic-1][elmpic[j].i6-1]>tmax) then
                       begin
                          tmax:=temppicpotent[icurrentpic-1][elmpic[j].i6-1];
                       end;
                       if (temppicpotent[icurrentpic-1][elmpic[j].i6-1]<tmin) then
                       begin
                          tmin:=temppicpotent[icurrentpic-1][elmpic[j].i6-1];
                       end;
                       if (temppicpotent[icurrentpic-1][elmpic[j].i5-1]>tmax) then
                       begin
                          tmax:=temppicpotent[icurrentpic-1][elmpic[j].i5-1];
                       end;
                       if (temppicpotent[icurrentpic-1][elmpic[j].i5-1]<tmin) then
                       begin
                          tmin:=temppicpotent[icurrentpic-1][elmpic[j].i5-1];
                       end;
                    end;
                 end;
             3 : // YZ
                 begin
                     if ((risopic>=xpic[elmpic[j].i1-1])and(risopic<=xpic[elmpic[j].i2-1])) then
                     begin
                        if (temppicpotent[icurrentpic-1][elmpic[j].i2-1]>tmax) then
                        begin
                           tmax:=temppicpotent[icurrentpic-1][elmpic[j].i2-1];
                        end;
                        if (temppicpotent[icurrentpic-1][elmpic[j].i2-1]<tmin) then
                        begin
                           tmin:=temppicpotent[icurrentpic-1][elmpic[j].i2-1];
                        end;
                        if (temppicpotent[icurrentpic-1][elmpic[j].i3-1]>tmax) then
                        begin
                           tmax:=temppicpotent[icurrentpic-1][elmpic[j].i3-1];
                        end;
                        if (temppicpotent[icurrentpic-1][elmpic[j].i3-1]<tmin) then
                        begin
                           tmin:=temppicpotent[icurrentpic-1][elmpic[j].i3-1];
                        end;
                        if (temppicpotent[icurrentpic-1][elmpic[j].i7-1]>tmax) then
                        begin
                           tmax:=temppicpotent[icurrentpic-1][elmpic[j].i7-1];
                        end;
                        if (temppicpotent[icurrentpic-1][elmpic[j].i7-1]<tmin) then
                        begin
                           tmin:=temppicpotent[icurrentpic-1][elmpic[j].i7-1];
                        end;
                        if (temppicpotent[icurrentpic-1][elmpic[j].i6-1]>tmax) then
                        begin
                           tmax:=temppicpotent[icurrentpic-1][elmpic[j].i6-1];
                        end;
                        if (temppicpotent[icurrentpic-1][elmpic[j].i6-1]<tmin) then
                        begin
                           tmin:=temppicpotent[icurrentpic-1][elmpic[j].i6-1];
                        end;
                     end;
                 end;
           end; // case
        end;
     end;



     if ((icurrentpic-1>=3)and(icurrentpic-1<=6)) then
     begin
        // десятичный логарифм модуля плотности теплового потока.
        // Поджимаем немного границы изменения по опыту.
        // Для большей наглядности картинки
       tmin:=tmin+0.0;
       tmax:=tmax-0.0;
     end;

     if (cbbview.ItemIndex>0) then
     begin
        if (icurrentpic>0) then
        begin
           minimumpic[icurrentpic-1]:=tmin;
           maximumpic[icurrentpic-1]:=tmax;



            LabelTitle.Caption:=temppicname[icurrentpic];
            for i := 1 to 9 do
              begin
                 case i of
                    1 : begin
                       LabelShcala9.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     2 : begin
                       LabelShcala8.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     3 : begin
                       LabelShcala7.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     4 : begin
                       LabelShcala6.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     5 : begin
                       LabelShcala5.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     6 : begin
                       LabelShcala4.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     7 : begin
                       LabelShcala3.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     8 : begin
                       LabelShcala2.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                     9 : begin
                       LabelShcala1.Caption:=FormatFloat('0.000',minimumpic[icurrentpic-1]+(i-1)*((maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])/8));
                    end;
                 end;
              end;


        end;
     end;

     for j:=0 to epic-1 do
     begin


            case cbbview.ItemIndex of
             0 : // all
             begin
                // 23.05.2020  только внешние грани!!!

                // Нельзя рисовать все грани подряд. Это чрезмерная
                // нагрузка на движок OpenGL.
                // Надо Отобрать только внешние грани составляющие
                // модель и рисовать только их.
                // TODO код изъят 06.09.2019.


                glpushMatrix;
                //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                //glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                //glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                glTranslatef(0,0,-Hscale*sqrt(sqr(zmaxpic-zminpic)+sqr(ymaxpic-yminpic)+sqr(xmaxpic-xminpic)));
                glTranslatef(0.5*(xminpic+xmaxpic),0.5*(yminpic+ymaxpic),0.5*(zminpic+zmaxpic));

                //-->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                //--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                // Вращательное движение в 3D имеет три степени свободы.
                glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                //glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                glTranslatef(-0.5*(xminpic+xmaxpic),-0.5*(yminpic+ymaxpic),-0.5*(zminpic+zmaxpic));


                glColor3f(0.0,0.0,0.0);

                if (binvisible_face_detect(0.0,0.0,-1.0)) then
                               begin

                // XY bottom
                 if ((ipa_count[elmpic[j].i1-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i2-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i3-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i4-1]<=bVisibleCount)) then
                  begin
                      if (icurrentpic=0) then
                            begin
                               // Prism

                                  glBegin(GL_LINE_LOOP);
                                    glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                                    glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                                    glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                                    glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                                  glEnd;

                            end
                              else
                            begin


                                glBegin(GL_QUADS);

                                icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i1-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,0.0,-1.0);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);

                                  icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i4-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,0.0,-1.0);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i3-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,0.0,-1.0);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);


                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i2-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,0.0,-1.0);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);

                                glEnd;

                                glColor3f(0.0,0.0,0.0);
                            end;

                            glLineWidth(4);

                            if (CheckLine(ipa_count[elmpic[j].i1-1],
                                    ipa_count[elmpic[j].i2-1])) then
                            begin
                              glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                              glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i3-1],
                                    ipa_count[elmpic[j].i2-1]))  then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                               glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i3-1],
                                    ipa_count[elmpic[j].i4-1]))  then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                               glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i1-1],
                                    ipa_count[elmpic[j].i4-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                               glEnd;
                            end;

                            glLineWidth(1);

                  end;
                  end;

                  if (binvisible_face_detect(0.0,0.0,1.0)) then
                               begin
                     // XY Top
                  if ((ipa_count[elmpic[j].i5-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i6-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i7-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i8-1]<=bVisibleCount)) then
                  begin
                      if (icurrentpic=0) then
                            begin
                               // Prism

                                  glBegin(GL_LINE_LOOP);
                                      glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                                      glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                                      glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                                      glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                                  glEnd;

                            end
                              else
                            begin


                                glBegin(GL_QUADS);

                                icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i5-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,0.0,1.0);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);

                                  icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i6-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,0.0,1.0);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i7-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,0.0,1.0);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);


                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i8-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,0.0,1.0);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);

                                glEnd;

                                glColor3f(0.0,0.0,0.0);
                            end;

                            glLineWidth(4);

                            if (CheckLine(ipa_count[elmpic[j].i5-1],
                                    ipa_count[elmpic[j].i6-1])) then
                            begin
                              glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                              glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i6-1],
                                    ipa_count[elmpic[j].i7-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                               glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i7-1],
                                    ipa_count[elmpic[j].i8-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                               glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i8-1],
                                    ipa_count[elmpic[j].i5-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                               glEnd;
                            end;

                            glLineWidth(1);

                  end;
                  end;

                   if (binvisible_face_detect(0.0,-1.0,0.0)) then
                            begin
                  // XZ SSIDE min Y
                  if ((ipa_count[elmpic[j].i1-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i2-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i6-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i5-1]<=bVisibleCount)) then
                  begin
                     if (icurrentpic=0) then
                         begin
                            // Prism

                               glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                               glEnd;

                         end
                         else
                         begin
                             glBegin(GL_QUADS);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i1-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,1.0,0.01);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);

                                  icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i2-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,1.0,0.01);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i6-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,1.0,0.01);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);


                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i5-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,1.0,0.01);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);

                                glEnd;

                                glColor3f(0.0,0.0,0.0);

                         end;

                         glLineWidth(4);

                          if (CheckLine(ipa_count[elmpic[j].i1-1],
                                    ipa_count[elmpic[j].i2-1])) then
                            begin
                              glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                              glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i2-1],
                                    ipa_count[elmpic[j].i6-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                               glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i6-1],
                                    ipa_count[elmpic[j].i5-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                               glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i5-1],
                                    ipa_count[elmpic[j].i1-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                               glEnd;
                            end;

                             glLineWidth(1);
                  end;
                  end;

                   if (binvisible_face_detect(0.0,1.0,0.0)) then
                            begin
                   // XZ SSIDE max Y
                  if ((ipa_count[elmpic[j].i4-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i3-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i7-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i8-1]<=bVisibleCount)) then
                  begin
                     if (icurrentpic=0) then
                         begin
                         // Prism

                                glBegin(GL_LINE_LOOP);
                                   glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                                   glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                                   glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                                   glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                                glEnd;

                         end
                         else
                         begin
                             glBegin(GL_QUADS);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i4-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,1.0,0.01);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);

                                  icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i8-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,1.0,0.01);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i7-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,1.0,0.01);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);


                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i3-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,1.0,0.01);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);

                                glEnd;

                                glColor3f(0.0,0.0,0.0);

                         end;

                         glLineWidth(4);

                          if (CheckLine(ipa_count[elmpic[j].i4-1],
                                    ipa_count[elmpic[j].i3-1])) then
                            begin
                              glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                              glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i3-1],
                                    ipa_count[elmpic[j].i7-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                               glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i7-1],
                                    ipa_count[elmpic[j].i8-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                               glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i8-1],
                                    ipa_count[elmpic[j].i4-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                               glEnd;
                            end;

                           glLineWidth(1);
                  end;
                  end;

                   if (binvisible_face_detect(1.0,0.0,0.0)) then
                            begin
                   // YZ SSIDE max X
                  if ((ipa_count[elmpic[j].i2-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i3-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i7-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i6-1]<=bVisibleCount)) then
                  begin
                      if (icurrentpic=0) then
                         begin
                            // Prism

                               glBegin(GL_LINE_LOOP);
                                 glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                                 glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                                 glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                                 glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                               glEnd;
                         end
                         else
                         begin
                            glBegin(GL_QUADS);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i2-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(1.0,0.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);

                                  icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i3-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(1.0,0.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i7-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(1.0,0.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);


                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i6-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(1.0,0.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);

                                glEnd;

                                glColor3f(0.0,0.0,0.0);
                         end;

                         glLineWidth(4);

                          if (CheckLine(ipa_count[elmpic[j].i2-1],
                                    ipa_count[elmpic[j].i3-1])) then
                            begin
                              glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                              glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i3-1],
                                    ipa_count[elmpic[j].i7-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                               glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i7-1],
                                    ipa_count[elmpic[j].i6-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                               glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i6-1],
                                    ipa_count[elmpic[j].i2-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                               glEnd;
                            end;

                            glLineWidth(1);

                  end;
                  end;

                  if (binvisible_face_detect(-1.0,0.0,0.0)) then
                            begin
                  // YZ SSIDE min X
                  if ((ipa_count[elmpic[j].i1-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i4-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i8-1]<=bVisibleCount) and
                 (ipa_count[elmpic[j].i5-1]<=bVisibleCount)) then
                  begin
                      if (icurrentpic=0) then
                         begin
                            // Prism

                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                                glEnd;
                         end
                         else
                         begin
                            glBegin(GL_QUADS);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i1-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(1.0,0.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);

                                  icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i5-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(1.0,0.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i8-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(1.0,0.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);


                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i4-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(1.0,0.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);

                                glEnd;

                                glColor3f(0.0,0.0,0.0);
                         end;

                         glLineWidth(4);

                          if (CheckLine(ipa_count[elmpic[j].i1-1],
                                    ipa_count[elmpic[j].i4-1])) then
                            begin
                              glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                              glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i8-1],
                                    ipa_count[elmpic[j].i4-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                               glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i8-1],
                                    ipa_count[elmpic[j].i5-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                               glEnd;
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i1-1],
                                    ipa_count[elmpic[j].i5-1])) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                               glEnd;
                            end;

                             glLineWidth(1);
                  end;
                  end;

                glPopmatrix;

             end;

             1 : // XY
                   begin


                        if ((risopic>=zpic[elmpic[j].i1-1])and(risopic<=zpic[elmpic[j].i5-1])) then
                        begin
                            glpushMatrix;
	                          //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                            //glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                            //glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                             glTranslatef(0,0,-Hscale*sqrt(sqr(zmaxpic-zminpic)+sqr(ymaxpic-yminpic)+sqr(xmaxpic-xminpic)));
                             glTranslatef(0.5*(xminpic+xmaxpic),0.5*(yminpic+ymaxpic),0.5*(zminpic+zmaxpic));

                            //-->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                            //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                            //--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                            // Вращательное движение в 3D имеет три степени свободы.
                            glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                            glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                            glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                            glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                            //glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                             glTranslatef(-0.5*(xminpic+xmaxpic),-0.5*(yminpic+ymaxpic),-0.5*(zminpic+zmaxpic));


                            glColor3f(0.0,0.0,0.0);

                            if (icurrentpic=0) then
                            begin
                               // Prism
                               glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                               glEnd;
                            end
                              else
                            begin


                                glBegin(GL_QUADS);

                                icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i1-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,0.0,1.0);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);

                                  icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i2-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,0.0,1.0);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i3-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,0.0,1.0);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);


                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i4-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,0.0,1.0);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);

                                glEnd;

                                glColor3f(0.0,0.0,0.0);
                            end;

                           glPopmatrix;
                        end;

                 end;
              2 : // XZ
                 begin

                       if ((risopic>=ypic[elmpic[j].i1-1])and(risopic<=ypic[elmpic[j].i4-1])) then
                       begin
                          glpushMatrix;
	                       // glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                         //glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                         //glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                          glTranslatef(0,0,-Hscale*sqrt(sqr(zmaxpic-zminpic)+sqr(ymaxpic-yminpic)+sqr(xmaxpic-xminpic)));
                          glTranslatef(0.5*(xminpic+xmaxpic),0.5*(yminpic+ymaxpic),0.5*(zminpic+zmaxpic));

                         //---> glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                         //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                         //---->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                         // Вращательное движение в 3D имеет три степени свободы.
                         glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                         glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                         glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                         glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                         //glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                          glTranslatef(-0.5*(xminpic+xmaxpic),-0.5*(yminpic+ymaxpic),-0.5*(zminpic+zmaxpic));


                         glColor3f(0.0,0.0,0.0);


                          if (icurrentpic=0) then
                            begin
                         // Prism
                         glBegin(GL_LINE_LOOP);
                             glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                             glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                             glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                             glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                         glEnd;
                         end
                         else
                         begin
                             glBegin(GL_QUADS);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i1-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,1.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);

                                  icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i2-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,1.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i6-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,1.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);


                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i5-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(0.0,1.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);

                                glEnd;

                                glColor3f(0.0,0.0,0.0);

                         end;

                         glPopmatrix;
                       end;

                 end;
              3 : // YZ
                 begin


                       if ((risopic>=xpic[elmpic[j].i1-1])and(risopic<=xpic[elmpic[j].i2-1])) then
                       begin
                          glpushMatrix;
	                       // glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                         //glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                         //glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                          glTranslatef(0,0,-Hscale*sqrt(sqr(zmaxpic-zminpic)+sqr(ymaxpic-yminpic)+sqr(xmaxpic-xminpic)));
                          glTranslatef(0.5*(xminpic+xmaxpic),0.5*(yminpic+ymaxpic),0.5*(zminpic+zmaxpic));

                         //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                         //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                         //---->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                         // Вращательное движение в 3D имеет три степени свободы.
                         glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                         glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                         glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                         glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                         //glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                          glTranslatef(-0.5*(xminpic+xmaxpic),-0.5*(yminpic+ymaxpic),-0.5*(zminpic+zmaxpic));


                         glColor3f(0.0,0.0,0.0);


                         if (icurrentpic=0) then
                         begin
                            // Prism
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                              glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                              glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                              glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                            glEnd;
                         end
                         else
                         begin
                            glBegin(GL_QUADS);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i2-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(1.0,0.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);

                                  icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i3-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(1.0,0.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);

                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i7-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(1.0,0.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);


                                   icol:=round(1020*((temppicpotent[icurrentpic-1][elmpic[j].i6-1]-minimumpic[icurrentpic-1])/(maximumpic[icurrentpic-1]-minimumpic[icurrentpic-1])));
                                if ((0<=icol) and (icol<=255)) then
                                begin // Синий голубой
                                   glColor3f(0.0,(icol)/255.0,1.0);
                                end
                                else if ((256<=icol) and (icol<=510)) then
                                begin
                                   //голубой - зелёный
                                   glColor3f(0,1.0,(255.0-(icol-255.0))/255.0);
                                end
                                else if ((511<=icol) and (icol<=765)) then
                                begin
                                   // зелёный - желтый
                                   glColor3f((icol-510)/255.0,1.0,0.0);
                                end
                                else if ((766<= icol) and (icol<=1020)) then
                                begin
                                   // Жёлтый - красный
                                   glColor3f(1.0,(255-(icol-765))/255.0,0.0);
                                end;
                                  glNormal3f(1.0,0.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);

                                glEnd;

                                glColor3f(0.0,0.0,0.0);
                         end;

                         glPopmatrix;
                       end;
                 end;
            end;
     end;
   end
    else
   begin

     // Подсвечивание выделенного в
     // дереве элемента красным цветом.

     bsel:=false;
     for i:=0 to MainTreeView.Items.Count-1 do
     begin
        if (MainTreeView.Items.Item[i].Selected) then
        begin
           bsel:=true;  // по крайней мере один элемент в дереве выделен
        end;
     end;

     if (breadfinish and bsel) then
     begin
        // Мы прорисовываем геометрию в любое время кроме времени
        // в течение которого осуществляется построение модели

        // Выделение цветом выделенного в дереве элемента
        s:=MainTreeView.Selected.Text;
        if (length(s)<>0) then
        begin
           // символ ch может принимать значения : c, b, s, w, u, e-exit
           ch:='e';
           bcontinue:=true;
           // по всем блокам
           for i:=0 to (lb-1) do
           begin
              if (bcontinue and (length(body[i].name) = length(s)) and (Pos(body[i].name,s)=1)) then
              begin
                 // найден блок :
                 bcontinue:=false;
                 itekpaint:=i;
                 if (i=0) then
                 begin
                    ch:='c';
                 end
                  else
                 begin
                    ch:='b';
                 end;
              end;
           end;
           if (ch='e') then
           begin
              // по всем источникам
              for i:=0 to (ls-1) do
              begin
                 if (bcontinue and (length(source[i].name) = length(s)) and (Pos(source[i].name,s)=1)) then
                 begin
                    // найден источник
                    bcontinue:=false;
                    ch:='s';
                    itekpaint:=i;
                 end;
              end;
           end;
           if (ch='e') then
           begin
              // по всем твёрдым стенкам
              for i:=0 to (lw-1) do
              begin
                 if (bcontinue and (length(wall[i].name) = length(s)) and (Pos(wall[i].name,s)=1)) then
                 begin
                    // найдена твёрдая стенка.
                    bcontinue:=false;
                    itekpaint:=i;
                    ch:='w';
                 end;
              end;
           end;
           if (ch='e') then
           begin
              // по всем объединениям
              for i:=0 to (lu-1) do
              begin
                 if (bcontinue and (length(myassembles[i].name) = length(s)) and (Pos(myassembles[i].name,s)=1)) then
                 begin
                    bcontinue:=false;
                    ch:='u'; // двойной щелчек по объединению
                    itekpaint:=myassembles[i].identifire; // идентификатор объединения
                    // внимание : обязательно должна быть справедлива связь itek=identifire=i+1;
                    // т.е. номер объединения в списке должен быть на единицу меньше его идентификатора.
                 end;
              end;
           end;


        end;

     end;


       // прорисовка источников тепла
       // зелёным цветом.
        for j:=0 to (ls-1) do
        begin // проход по всем источникам тепла
           with source[j] do
           begin
              if (source[j].bvisible) then
              begin
                 glpushMatrix;
	               // glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                 glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                 glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                 //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                 //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                 //-->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                 // Вращательное движение в 3D имеет три степени свободы.
                 glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                 glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                 glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                 glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                 glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                 if ((ch='s') and (itekpaint=j)) then
                 begin
                    // Красный
                    glLineWidth(4.0);
                    glColor3f(1,0,0);
                 end
                 else
                 begin
                    glLineWidth(1);
                    glColor3f(0,1,0);
                 end;
                 //  GL_LINE_LOOP
                 //  GL_LINE_LOOP
                 case iPlane of
                   1 : // XY
                      begin
                         glBegin(GL_LINE_LOOP);
                           glVertex3f(xE, yE, zE);
                           glVertex3f(xS, yE, zE);
                           glVertex3f(xS, yS, zE);
                           glVertex3f(xE, yS, zE);
                         glEnd;
                      end;
                   2 : // XZ
                      begin
                         glBegin(GL_LINE_LOOP);
                           glVertex3f(xE, yE, zE);
                           glVertex3f(xS, yE, zE);
                           glVertex3f(xS, yE, zS);
                           glVertex3f(xE, yE, zS);
                         glEnd;
                      end;
                   3 : // YZ
                      begin
                          glBegin(GL_LINE_LOOP);
                           glVertex3f(xE, yE, zE);
                           glVertex3f(xE, yS, zE);
                           glVertex3f(xE, yS, zS);
                           glVertex3f(xE, yE, zS);
                         glEnd;
                      end;
                 end;

                 glLineWidth(1);

                 glPopmatrix;
              end;
           end;
        end;

      (*
      // Прорисовка кабинета синим цветом.
     glpushMatrix;
	   glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
     with Laplas.body[0] do
     begin
        glColor3f(0,0,1);
        glBegin(GL_LINE_LOOP);
          glVertex3f(xE, yE, zE);
          glVertex3f(xS, yE, zE);
          glVertex3f(xS, yS, zE);
          glVertex3f(xE, yS, zE);
        glEnd;

        glBegin(GL_LINE_LOOP);
             glVertex3f(xE, yE, zS);
             glVertex3f(xE, yS, zS);
             glVertex3f(xS, yS, zS);
             glVertex3f(xS, yE, zS);
           glEnd;

        glBegin(GL_LINE_LOOP);
             glVertex3f(xS, yE, zE);
             glVertex3f(xS, yE, zS);
             glVertex3f(xS, yS, zS);
             glVertex3f(xS, yS, zE);
           glEnd;

        glBegin(GL_LINE_LOOP);
             glVertex3f(xE, yE, zE);
             glVertex3f(xE, yS, zE);
             glVertex3f(xE, yS, zS);
             glVertex3f(xE, yE, zS);
           glEnd;

        glBegin(GL_LINE_LOOP);
             glVertex3f(xS, yE, zS);
             glVertex3f(xS, yE, zE);
             glVertex3f(xE, yE, zE);
             glVertex3f(xE, yE, zS);
           glEnd;

        glBegin(GL_LINE_LOOP);
             glVertex3f(xS, yS, zS);
             glVertex3f(xE, yS, zS);
             glVertex3f(xE, yS, zE);
             glVertex3f(xS, yS, zE);
           glEnd;
     end;

     glPopmatrix;
     *)

     // Прорисовка остальных блоков.
     for j:=0 to Laplas.lb-1 do
     begin
        with (Laplas.body[j]) do
        begin
           if (bvisible) then
           begin

            case cbbview.ItemIndex of
             0 : // all
             begin
                glpushMatrix;
	              //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                //-->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                //---->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                // Вращательное движение в 3D имеет три степени свободы.
                glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                 if ((ch='b') and (itekpaint=j)) then
                 begin
                    glLineWidth(4.0);
                    glColor3f(1.0,0.0,0.0);
                 end
                  else
                 begin
                    //glLineWidth(1.0);
                    glLineWidth(body[j].BodyLineWidth);
                    //glColor3f(0.0,0.0,0.0);
                    glColor3f(body[j].redcolor,body[j].greencolor,body[j].bluecolor);
                 end;

                 if (j=0) then
                 begin
                    // кабинет.
                    glColor3f(0.0,0.0,1.0); // синий цвет.
                 end;

                if (igeometry_type=0) then
                begin
                   // Prism
                   //  GL_LINE_LOOP
                   if (binvisible_face_detect(0.0,0.0,1.0)) then
                   begin
                   glBegin(GL_LINE_LOOP);
                      glVertex3f(xE, yE, zE);
                      glVertex3f(xS, yE, zE);
                      glVertex3f(xS, yS, zE);
                      glVertex3f(xE, yS, zE);
                   glEnd;
                   end;

                   if (binvisible_face_detect(0.0,0.0,-1.0)) then
                   begin
                   glBegin(GL_LINE_LOOP);
                     glVertex3f(xE, yE, zS);
                     glVertex3f(xE, yS, zS);
                     glVertex3f(xS, yS, zS);
                     glVertex3f(xS, yE, zS);
                   glEnd;
                   end;

                   if (binvisible_face_detect(-1.0,0.0,0.0)) then
                   begin
                   glBegin(GL_LINE_LOOP);
                     glVertex3f(xS, yE, zE);
                     glVertex3f(xS, yE, zS);
                     glVertex3f(xS, yS, zS);
                     glVertex3f(xS, yS, zE);
                   glEnd;
                   end;

                   if (binvisible_face_detect(1.0,0.0,0.0)) then
                   begin
                   glBegin(GL_LINE_LOOP);
                     glVertex3f(xE, yE, zE);
                     glVertex3f(xE, yS, zE);
                     glVertex3f(xE, yS, zS);
                     glVertex3f(xE, yE, zS);
                   glEnd;
                   end;

                   if (binvisible_face_detect(0.0,1.0,0.0)) then
                   begin
                   glBegin(GL_LINE_LOOP);
                     glVertex3f(xS, yE, zS);
                     glVertex3f(xS, yE, zE);
                     glVertex3f(xE, yE, zE);
                     glVertex3f(xE, yE, zS);
                   glEnd;
                   end;

                   if (binvisible_face_detect(0.0,-1.0,0.0)) then
                   begin
                    glBegin(GL_LINE_LOOP);
                     glVertex3f(xS, yS, zS);
                     glVertex3f(xE, yS, zS);
                     glVertex3f(xE, yS, zE);
                     glVertex3f(xS, yS, zE);
                   glEnd;
                   end;
                end;

                 if (igeometry_type=2) then
                 begin
                    // Polygon
                    case iPlane_obj2 of
                      1 : begin
                             // XY
                             for j3 := 0 to nsizei-2 do
                             begin
                                 // GL_LINE_LOOP
                                glBegin(GL_LINE_LOOP);
                                   glVertex3f(xi[j3],yi[j3],zi[j3]);
                                   glVertex3f(xi[j3+1],yi[j3+1],zi[j3+1]);
                                   glVertex3f(xi[j3+1],yi[j3+1],zi[j3+1]+hi[j3+1]);
                                   glVertex3f(xi[j3],yi[j3],zi[j3]+hi[j3]);
                                glEnd;
                             end;
                             glBegin(GL_LINE_LOOP);
                                   glVertex3f(xi[nsizei-1],yi[nsizei-1],zi[nsizei-1]);
                                   glVertex3f(xi[0],yi[0],zi[0]);
                                   glVertex3f(xi[0],yi[0],zi[0]+hi[0]);
                                   glVertex3f(xi[nsizei-1],yi[nsizei-1],zi[nsizei-1]+hi[nsizei-1]);
                              glEnd;
                          end;
                      2 : begin
                             // XZ
                             for j3 := 0 to nsizei-2 do
                             begin
                                glBegin(GL_LINE_LOOP);
                                   glVertex3f(xi[j3],yi[j3],zi[j3]);
                                   glVertex3f(xi[j3+1],yi[j3+1],zi[j3+1]);
                                   glVertex3f(xi[j3+1],yi[j3+1]+hi[j3+1],zi[j3+1]);
                                   glVertex3f(xi[j3],yi[j3]+hi[j3],zi[j3]);
                                glEnd;
                             end;
                             glBegin(GL_LINE_LOOP);
                                   glVertex3f(xi[nsizei-1],yi[nsizei-1],zi[nsizei-1]);
                                   glVertex3f(xi[0],yi[0],zi[0]);
                                   glVertex3f(xi[0],yi[0]+hi[0],zi[0]);
                                   glVertex3f(xi[nsizei-1],yi[nsizei-1]+hi[nsizei-1],zi[nsizei-1]);
                              glEnd;
                          end;
                      3 : begin
                             // YZ
                             for j3 := 0 to nsizei-2 do
                             begin
                                glBegin(GL_LINE_LOOP);
                                   glVertex3f(xi[j3],yi[j3],zi[j3]);
                                   glVertex3f(xi[j3+1],yi[j3+1],zi[j3+1]);
                                   glVertex3f(xi[j3+1]+hi[j3+1],yi[j3+1],zi[j3+1]);
                                   glVertex3f(xi[j3]+hi[j3],yi[j3],zi[j3]);
                                glEnd;
                             end;
                             glBegin(GL_LINE_LOOP);
                                   glVertex3f(xi[nsizei-1],yi[nsizei-1],zi[nsizei-1]);
                                   glVertex3f(xi[0],yi[0],zi[0]);
                                   glVertex3f(xi[0]+hi[0],yi[0],zi[0]);
                                   glVertex3f(xi[nsizei-1]+hi[nsizei-1],yi[nsizei-1],zi[nsizei-1]);
                              glEnd;
                          end;
                      end;
                 end;

                 if (igeometry_type=1) then
                 begin
                    // Cylinder
                    case iPlane of
                      1 : begin
                             // XY
                             glBegin(GL_LINE_LOOP);
                                 for i33 := 0 to 29 do
                                 begin
                                     angle33:=2.0*3.1415926*i33/29.0;
                                     dx33:=R_out_cyl*cos(angle33);
                                     dy33:=R_out_cyl*sin(angle33);
                                     glVertex3f(xC+dx33, yC+dy33, zC);
                                 end;
                             glEnd;
                             if (R_out_cyl2<=0.0) then
                             begin
                                glBegin(GL_LINE_LOOP);
                                   for i33 := 0 to 29 do
                                   begin
                                      angle33:=2.0*3.1415926*i33/29.0;
                                     dx33:=R_out_cyl*cos(angle33);
                                     dy33:=R_out_cyl*sin(angle33);
                                     glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                   end;
                                glEnd;
                             end
                              else
                             begin
                                glBegin(GL_LINE_LOOP);
                                   for i33 := 0 to 29 do
                                   begin
                                      angle33:=2.0*3.1415926*i33/29.0;
                                     dx33:=R_out_cyl2*cos(angle33);
                                     dy33:=R_out_cyl2*sin(angle33);
                                     glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                   end;
                                glEnd;
                             end;

                             if (R_in_cyl>1.0e-20) then
                             begin
                                glBegin(GL_LINE_LOOP);
                                 for i33 := 0 to 29 do
                                 begin
                                     angle33:=2.0*3.1415926*i33/29.0;
                                     dx33:=R_in_cyl*cos(angle33);
                                     dy33:=R_in_cyl*sin(angle33);
                                     glVertex3f(xC+dx33, yC+dy33, zC);
                                 end;
                                 glEnd;

                                 if (R_in_cyl2<=0.0) then
                                 begin
                                    glBegin(GL_LINE_LOOP);
                                    for i33 := 0 to 29 do
                                    begin
                                       angle33:=2.0*3.1415926*i33/29.0;
                                       dx33:=R_in_cyl*cos(angle33);
                                       dy33:=R_in_cyl*sin(angle33);
                                       glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                    end;
                                    glEnd;
                                 end
                                 else
                                 begin
                                    glBegin(GL_LINE_LOOP);
                                    for i33 := 0 to 29 do
                                    begin
                                       angle33:=2.0*3.1415926*i33/29.0;
                                       dx33:=R_in_cyl2*cos(angle33);
                                       dy33:=R_in_cyl2*sin(angle33);
                                       glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                    end;
                                    glEnd;
                                 end;
                             end;

                              glBegin(GL_LINE_LOOP);
                                  angle33:=2.0*3.1415926*0.125;
                                  dx33:=R_out_cyl*cos(angle33);
                                  dy33:=R_out_cyl*sin(angle33);
                                  glVertex3f(xC+dx33, yC+dy33, zC);
                                  if (R_out_cyl2<=0.0) then
                                  begin
                                     glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                  end
                                  else
                                  begin
                                     dx33:=R_out_cyl2*cos(angle33);
                                     dy33:=R_out_cyl2*sin(angle33);
                                     glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                  end;
                              glEnd;
                               glBegin(GL_LINE_LOOP);
                                  angle33:=2.0*3.1415926*0.375;
                                  dx33:=R_out_cyl*cos(angle33);
                                  dy33:=R_out_cyl*sin(angle33);
                                  glVertex3f(xC+dx33, yC+dy33, zC);
                                   if (R_out_cyl2<=0.0) then
                                  begin
                                     glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                  end
                                  else
                                  begin
                                     dx33:=R_out_cyl2*cos(angle33);
                                     dy33:=R_out_cyl2*sin(angle33);
                                     glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                  end;
                              glEnd;
                               glBegin(GL_LINE_LOOP);
                                  angle33:=2.0*3.1415926*0.625;
                                  dx33:=R_out_cyl*cos(angle33);
                                  dy33:=R_out_cyl*sin(angle33);
                                  glVertex3f(xC+dx33, yC+dy33, zC);
                                  if (R_out_cyl2<=0.0) then
                                  begin
                                     glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                  end
                                  else
                                  begin
                                     dx33:=R_out_cyl2*cos(angle33);
                                     dy33:=R_out_cyl2*sin(angle33);
                                     glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                  end;
                              glEnd;
                               glBegin(GL_LINE_LOOP);
                                  angle33:=2.0*3.1415926*0.875;
                                  dx33:=R_out_cyl*cos(angle33);
                                  dy33:=R_out_cyl*sin(angle33);
                                  glVertex3f(xC+dx33, yC+dy33, zC);
                                  if (R_out_cyl2<=0.0) then
                                  begin
                                     glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                  end
                                  else
                                  begin
                                     dx33:=R_out_cyl2*cos(angle33);
                                     dy33:=R_out_cyl2*sin(angle33);
                                     glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                  end;
                              glEnd;

                               if (R_in_cyl>1.0e-20) then
                               begin
                                  glBegin(GL_LINE_LOOP);
                                    angle33:=2.0*3.1415926*0.125;
                                    dx33:=R_in_cyl*cos(angle33);
                                    dy33:=R_in_cyl*sin(angle33);
                                    glVertex3f(xC+dx33, yC+dy33, zC);
                                    if (R_in_cyl2<=0.0) then
                                    begin
                                       glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                    end
                                    else
                                    begin
                                       dx33:=R_in_cyl2*cos(angle33);
                                       dy33:=R_in_cyl2*sin(angle33);
                                       glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                    end;
                                  glEnd;
                                  glBegin(GL_LINE_LOOP);
                                     angle33:=2.0*3.1415926*0.375;
                                     dx33:=R_in_cyl*cos(angle33);
                                     dy33:=R_in_cyl*sin(angle33);
                                     glVertex3f(xC+dx33, yC+dy33, zC);
                                     if (R_in_cyl2<=0.0) then
                                     begin
                                        glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                     end
                                     else
                                     begin
                                        dx33:=R_in_cyl2*cos(angle33);
                                        dy33:=R_in_cyl2*sin(angle33);
                                        glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                     end;
                                  glEnd;
                                  glBegin(GL_LINE_LOOP);
                                    angle33:=2.0*3.1415926*0.625;
                                    dx33:=R_in_cyl*cos(angle33);
                                    dy33:=R_in_cyl*sin(angle33);
                                    glVertex3f(xC+dx33, yC+dy33, zC);
                                     if (R_in_cyl2<=0.0) then
                                     begin
                                        glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                      end
                                     else
                                     begin
                                        dx33:=R_in_cyl2*cos(angle33);
                                        dy33:=R_in_cyl2*sin(angle33);
                                        glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                     end;
                                  glEnd;
                                  glBegin(GL_LINE_LOOP);
                                     angle33:=2.0*3.1415926*0.875;
                                     dx33:=R_in_cyl*cos(angle33);
                                     dy33:=R_in_cyl*sin(angle33);
                                     glVertex3f(xC+dx33, yC+dy33, zC);
                                      if (R_in_cyl2<=0.0) then
                                     begin
                                        glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                     end
                                       else
                                     begin
                                        dx33:=R_in_cyl2*cos(angle33);
                                        dy33:=R_in_cyl2*sin(angle33);
                                        glVertex3f(xC+dx33, yC+dy33, zC+Hcyl);
                                     end;
                                   glEnd;
                               end;
                          end;
                      2 : begin
                             // XZ
                             glBegin(GL_LINE_LOOP);
                                 for i33 := 0 to 29 do
                                 begin
                                     angle33:=2.0*3.1415926*i33/29.0;
                                     dx33:=R_out_cyl*cos(angle33);
                                     dy33:=R_out_cyl*sin(angle33);
                                     glVertex3f(xC+dx33, yC, zC+dy33);
                                 end;
                             glEnd;
                             if (R_out_cyl2<=0.0) then
                             begin
                             glBegin(GL_LINE_LOOP);
                                 for i33 := 0 to 29 do
                                 begin
                                     angle33:=2.0*3.1415926*i33/29.0;
                                     dx33:=R_out_cyl*cos(angle33);
                                     dy33:=R_out_cyl*sin(angle33);
                                     glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                 end;
                             glEnd;
                             end
                             else
                             begin
                                 glBegin(GL_LINE_LOOP);
                                 for i33 := 0 to 29 do
                                 begin
                                     angle33:=2.0*3.1415926*i33/29.0;
                                     dx33:=R_out_cyl2*cos(angle33);
                                     dy33:=R_out_cyl2*sin(angle33);
                                     glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                 end;
                                glEnd;
                             end;

                             if (R_in_cyl>1.0e-20) then
                             begin
                                glBegin(GL_LINE_LOOP);
                                 for i33 := 0 to 29 do
                                 begin
                                     angle33:=2.0*3.1415926*i33/29.0;
                                     dx33:=R_in_cyl*cos(angle33);
                                     dy33:=R_in_cyl*sin(angle33);
                                     glVertex3f(xC+dx33, yC, zC+dy33);
                                 end;
                                glEnd;
                                if (R_in_cyl2<=0.0) then
                                begin
                                   glBegin(GL_LINE_LOOP);
                                   for i33 := 0 to 29 do
                                   begin
                                      angle33:=2.0*3.1415926*i33/29.0;
                                      dx33:=R_in_cyl*cos(angle33);
                                      dy33:=R_in_cyl*sin(angle33);
                                      glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                   end;
                                   glEnd;
                                 end
                                 else
                                 begin
                                    glBegin(GL_LINE_LOOP);
                                    for i33 := 0 to 29 do
                                    begin
                                       angle33:=2.0*3.1415926*i33/29.0;
                                       dx33:=R_in_cyl2*cos(angle33);
                                       dy33:=R_in_cyl2*sin(angle33);
                                       glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                    end;
                                    glEnd;
                                 end;
                             end;

                             glBegin(GL_LINE_LOOP);
                                  angle33:=2.0*3.1415926*0.125;
                                  dx33:=R_out_cyl*cos(angle33);
                                  dy33:=R_out_cyl*sin(angle33);
                                  glVertex3f(xC+dx33, yC, zC+dy33);
                                  if (R_out_cyl2<=0.0) then
                                  begin
                                     glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                  end
                                   else
                                  begin
                                      dx33:=R_out_cyl2*cos(angle33);
                                      dy33:=R_out_cyl2*sin(angle33);
                                      glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                  end;
                              glEnd;
                               glBegin(GL_LINE_LOOP);
                                  angle33:=2.0*3.1415926*0.375;
                                  dx33:=R_out_cyl*cos(angle33);
                                  dy33:=R_out_cyl*sin(angle33);
                                  glVertex3f(xC+dx33, yC, zC+dy33);
                                  if (R_out_cyl2<=0.0) then
                             begin
                                  glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                   end
                                   else
                                  begin
                                     dx33:=R_out_cyl2*cos(angle33);
                                     dy33:=R_out_cyl2*sin(angle33);
                                      glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                  end;
                              glEnd;
                               glBegin(GL_LINE_LOOP);
                                  angle33:=2.0*3.1415926*0.625;
                                  dx33:=R_out_cyl*cos(angle33);
                                  dy33:=R_out_cyl*sin(angle33);
                                  glVertex3f(xC+dx33, yC, zC+dy33);
                                  if (R_out_cyl2<=0.0) then
                                  begin
                                     glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                   end
                                   else
                                  begin
                                     dx33:=R_out_cyl2*cos(angle33);
                                     dy33:=R_out_cyl2*sin(angle33);
                                     glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                  end;
                              glEnd;
                               glBegin(GL_LINE_LOOP);
                                  angle33:=2.0*3.1415926*0.875;
                                  dx33:=R_out_cyl*cos(angle33);
                                  dy33:=R_out_cyl*sin(angle33);
                                  glVertex3f(xC+dx33, yC, zC+dy33);
                                   if (R_out_cyl2<=0.0) then
                                   begin
                                      glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                   end
                                   else
                                  begin
                                     dx33:=R_out_cyl2*cos(angle33);
                                     dy33:=R_out_cyl2*sin(angle33);
                                     glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                  end;
                              glEnd;

                              if (R_in_cyl>1.0e-20) then
                               begin
                                  glBegin(GL_LINE_LOOP);
                                    angle33:=2.0*3.1415926*0.125;
                                    dx33:=R_in_cyl*cos(angle33);
                                    dy33:=R_in_cyl*sin(angle33);
                                    glVertex3f(xC+dx33, yC, zC+dy33);
                                    if (R_in_cyl2<=0.0) then
                                    begin
                                      glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                    end
                                     else
                                    begin
                                       dx33:=R_in_cyl2*cos(angle33);
                                       dy33:=R_in_cyl2*sin(angle33);
                                       glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                    end;
                                  glEnd;
                                  glBegin(GL_LINE_LOOP);
                                    angle33:=2.0*3.1415926*0.375;
                                    dx33:=R_in_cyl*cos(angle33);
                                    dy33:=R_in_cyl*sin(angle33);
                                    glVertex3f(xC+dx33, yC, zC+dy33);
                                    if (R_in_cyl2<=0.0) then
                                    begin
                                       glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                     end
                                     else
                                    begin
                                       dx33:=R_in_cyl2*cos(angle33);
                                       dy33:=R_in_cyl2*sin(angle33);
                                       glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                    end;
                                  glEnd;
                                  glBegin(GL_LINE_LOOP);
                                    angle33:=2.0*3.1415926*0.625;
                                    dx33:=R_in_cyl*cos(angle33);
                                    dy33:=R_in_cyl*sin(angle33);
                                    glVertex3f(xC+dx33, yC, zC+dy33);
                                     if (R_in_cyl2<=0.0) then
                                    begin
                                       glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                    end
                                     else
                                    begin
                                        dx33:=R_in_cyl2*cos(angle33);
                                        dy33:=R_in_cyl2*sin(angle33);
                                        glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                    end;
                                  glEnd;
                                  glBegin(GL_LINE_LOOP);
                                    angle33:=2.0*3.1415926*0.875;
                                    dx33:=R_in_cyl*cos(angle33);
                                    dy33:=R_in_cyl*sin(angle33);
                                    glVertex3f(xC+dx33, yC, zC+dy33);
                                     if (R_in_cyl2<=0.0) then
                                    begin
                                       glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                     end
                                     else
                                    begin
                                       dx33:=R_in_cyl2*cos(angle33);
                                       dy33:=R_in_cyl2*sin(angle33);
                                       glVertex3f(xC+dx33, yC+Hcyl, zC+dy33);
                                    end;
                                  glEnd;
                               end;

                          end;
                      3 : begin
                             // YZ
                             glBegin(GL_LINE_LOOP);
                                 for i33 := 0 to 29 do
                                 begin
                                     angle33:=2.0*3.1415926*i33/29.0;
                                     dx33:=R_out_cyl*cos(angle33);
                                     dy33:=R_out_cyl*sin(angle33);
                                     glVertex3f(xC, yC+dx33, zC+dy33);
                                 end;
                             glEnd;
                             if (R_out_cyl2<=0.0) then
                             begin
                             glBegin(GL_LINE_LOOP);
                                  for i33 := 0 to 29 do
                                 begin
                                     angle33:=2.0*3.1415926*i33/29.0;
                                     dx33:=R_out_cyl*cos(angle33);
                                     dy33:=R_out_cyl*sin(angle33);
                                     glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                 end;
                             glEnd;
                             end
                             else
                             begin
                                glBegin(GL_LINE_LOOP);
                                  for i33 := 0 to 29 do
                                 begin
                                     angle33:=2.0*3.1415926*i33/29.0;
                                     dx33:=R_out_cyl2*cos(angle33);
                                     dy33:=R_out_cyl2*sin(angle33);
                                     glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                 end;
                                glEnd;
                             end;
                             if (R_in_cyl>1.0e-20) then
                             begin
                                glBegin(GL_LINE_LOOP);
                                   for i33 := 0 to 29 do
                                   begin
                                      angle33:=2.0*3.1415926*i33/29.0;
                                      dx33:=R_in_cyl*cos(angle33);
                                      dy33:=R_in_cyl*sin(angle33);
                                      glVertex3f(xC, yC+dx33, zC+dy33);
                                   end;
                                glEnd;
                                if (R_in_cyl2<=0.0) then
                                begin
                                   glBegin(GL_LINE_LOOP);
                                     for i33 := 0 to 29 do
                                     begin
                                        angle33:=2.0*3.1415926*i33/29.0;
                                        dx33:=R_in_cyl*cos(angle33);
                                        dy33:=R_in_cyl*sin(angle33);
                                        glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                     end;
                                   glEnd;
                                 end
                                 else
                                 begin
                                   glBegin(GL_LINE_LOOP);
                                   for i33 := 0 to 29 do
                                   begin
                                      angle33:=2.0*3.1415926*i33/29.0;
                                      dx33:=R_in_cyl2*cos(angle33);
                                      dy33:=R_in_cyl2*sin(angle33);
                                      glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                   end;
                                   glEnd;
                                 end;
                             end;

                              glBegin(GL_LINE_LOOP);
                                  angle33:=2.0*3.1415926*0.125;
                                  dx33:=R_out_cyl*cos(angle33);
                                  dy33:=R_out_cyl*sin(angle33);
                                  glVertex3f(xC, yC+dx33, zC+dy33);
                                  if (R_out_cyl2<=0.0) then
                                  begin
                                     glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                  end
                                  else
                                  begin
                                     dx33:=R_out_cyl*cos(angle33);
                                     dy33:=R_out_cyl*sin(angle33);
                                     glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                  end;
                              glEnd;
                               glBegin(GL_LINE_LOOP);
                                  angle33:=2.0*3.1415926*0.375;
                                  dx33:=R_out_cyl*cos(angle33);
                                  dy33:=R_out_cyl*sin(angle33);
                                  glVertex3f(xC, yC+dx33, zC+dy33);
                                  if (R_out_cyl2<=0.0) then
                                  begin
                                     glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                  end
                                  else
                                  begin
                                     dx33:=R_out_cyl*cos(angle33);
                                     dy33:=R_out_cyl*sin(angle33);
                                     glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                  end;
                              glEnd;
                               glBegin(GL_LINE_LOOP);
                                  angle33:=2.0*3.1415926*0.625;
                                  dx33:=R_out_cyl*cos(angle33);
                                  dy33:=R_out_cyl*sin(angle33);
                                  glVertex3f(xC, yC+dx33, zC+dy33);
                                   if (R_out_cyl2<=0.0) then
                                  begin
                                     glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                  end
                                  else
                                  begin
                                      dx33:=R_out_cyl*cos(angle33);
                                      dy33:=R_out_cyl*sin(angle33);
                                      glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                  end;
                              glEnd;
                               glBegin(GL_LINE_LOOP);
                                  angle33:=2.0*3.1415926*0.875;
                                  dx33:=R_out_cyl*cos(angle33);
                                  dy33:=R_out_cyl*sin(angle33);
                                  glVertex3f(xC, yC+dx33, zC+dy33);
                                   if (R_out_cyl2<=0.0) then
                                  begin
                                     glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                  end
                                  else
                                  begin
                                     dx33:=R_out_cyl2*cos(angle33);
                                     dy33:=R_out_cyl2*sin(angle33);
                                     glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                  end;
                              glEnd;

                              if (R_in_cyl>1.0e-20) then
                              begin
                                  glBegin(GL_LINE_LOOP);
                                     angle33:=2.0*3.1415926*0.125;
                                     dx33:=R_in_cyl*cos(angle33);
                                     dy33:=R_in_cyl*sin(angle33);
                                     glVertex3f(xC, yC+dx33, zC+dy33);
                                     if (R_in_cyl2<=0.0) then
                                     begin
                                        glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                     end
                                      else
                                     begin
                                       dx33:=R_in_cyl2*cos(angle33);
                                       dy33:=R_in_cyl2*sin(angle33);
                                       glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                     end;
                                  glEnd;
                                  glBegin(GL_LINE_LOOP);
                                     angle33:=2.0*3.1415926*0.375;
                                     dx33:=R_in_cyl*cos(angle33);
                                     dy33:=R_in_cyl*sin(angle33);
                                     glVertex3f(xC, yC+dx33, zC+dy33);
                                     if (R_in_cyl2<=0.0) then
                                     begin
                                        glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                     end
                                      else
                                     begin
                                       dx33:=R_in_cyl2*cos(angle33);
                                       dy33:=R_in_cyl2*sin(angle33);
                                       glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                     end;
                                  glEnd;
                                  glBegin(GL_LINE_LOOP);
                                     angle33:=2.0*3.1415926*0.625;
                                     dx33:=R_in_cyl*cos(angle33);
                                     dy33:=R_in_cyl*sin(angle33);
                                     glVertex3f(xC, yC+dx33, zC+dy33);
                                   if (R_in_cyl2<=0.0) then
                                   begin
                                     glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                  end
                                  else
                                 begin
                                   dx33:=R_in_cyl2*cos(angle33);
                                   dy33:=R_in_cyl2*sin(angle33);
                                   glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                 end;
                                  glEnd;
                                  glBegin(GL_LINE_LOOP);
                                     angle33:=2.0*3.1415926*0.875;
                                     dx33:=R_in_cyl*cos(angle33);
                                     dy33:=R_in_cyl*sin(angle33);
                                     glVertex3f(xC, yC+dx33, zC+dy33);
                                     if (R_in_cyl2<=0.0) then
                                     begin
                                        glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                     end
                                      else
                                     begin
                                        dx33:=R_in_cyl2*cos(angle33);
                                        dy33:=R_in_cyl2*sin(angle33);
                                        glVertex3f(xC+Hcyl, yC+dx33, zC+dy33);
                                     end;
                                  glEnd;
                              end;
                          end;
                    end;
                 end;

                 glLineWidth(1);

                glPopmatrix;
             end;

             1 : // XY
                   begin

                     striso:=Trim(edtvalue.Text);
                     for iisoscan:=1 to length(striso) do
                     begin
                        if (FormatSettings.DecimalSeparator=',') then
                        begin
                           if (striso[iisoscan]='.') then striso[iisoscan]:=',';
                        end;
                        if (FormatSettings.DecimalSeparator='.') then
                        begin
                           if (striso[iisoscan]=',') then striso[iisoscan]:='.';
                        end;
                     end;
                     edtvalue.Text:=striso;

                     sforval:='';
                    sforval:=StringReplace(edtvalue.Text,',','.',[rfReplaceAll]);
                    val(sforval,c,code);
                     //val(edtvalue.Text,c,code);
                     if (code=0) then
                     begin
                        riso:=StrToFloat(edtvalue.Text);
                        //if ((riso>=zS)and(riso<=zE)) then
                        //begin
                        if (if_visible_now(riso,zS,zE)) then
                        begin
                            glpushMatrix;
	                          //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                            glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                            glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                            //-->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                            //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                            //--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                            // Вращательное движение в 3D имеет три степени свободы.
                            glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                            glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                            glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                            glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                            glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                             if ((ch='b') and (itekpaint=j)) then
                             begin
                                glLineWidth(4.0);
                                glColor3f(1.0,0.0,0.0);
                             end
                              else
                             begin
                                //glLineWidth(1.0);
                                glLineWidth(BodyLineWidth);
                                //glColor3f(0.0,0.0,0.0);
                                glColor3f(redcolor,greencolor,bluecolor);
                             end;

                             if (j=0) then
                             begin
                                // кабинет.
                                glColor3f(0.0,0.0,1.0); // синий цвет.
                             end;


                             if (igeometry_type=0) then
                             begin
                                // Prism
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xE, yE, riso);
                                  glVertex3f(xS, yE, riso);
                                  glVertex3f(xS, yS, riso);
                                  glVertex3f(xE, yS, riso);
                                glEnd;
                             end;
                             if (igeometry_type=2) then
                             begin
                                // XY
                                case iPlane_obj2 of
                                   1 : begin
                                          // XY
                                          for j3 := 0 to nsizei-2 do
                                          begin
                                             glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[j3], yi[j3], riso);
                                                 glVertex3f(xi[j3+1], yi[j3+1], riso);
                                             glEnd;
                                          end;
                                          glBegin(GL_LINE_LOOP);
                                              glVertex3f(xi[nsizei-1], yi[nsizei-1], riso);
                                              glVertex3f(xi[0], yi[0], riso);
                                          glEnd;
                                       end;
                                   2 : begin
                                          // XZ
                                          // Упрощенный показ при котором показываются все линии геометрии полигона.
                                          for j3 := 0 to nsizei-2 do
                                          begin
                                             glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[j3], yi[j3], zi[j3]);
                                                 glVertex3f(xi[j3], yi[j3]+hi[j3], zi[j3]);
                                                 glVertex3f(xi[j3+1], yi[j3+1]+hi[j3+1], zi[j3+1]);
                                                 glVertex3f(xi[j3+1], yi[j3+1], zi[j3+1]);
                                             glEnd;
                                          end;
                                          glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[nsizei-1], yi[nsizei-1], zi[nsizei-1]);
                                                 glVertex3f(xi[nsizei-1], yi[nsizei-1]+hi[nsizei-1], zi[nsizei-1]);
                                                 glVertex3f(xi[0], yi[0]+hi[0], zi[0]);
                                                 glVertex3f(xi[0], yi[0], zi[0]);
                                             glEnd;
                                       end;
                                   3 : begin
                                          // YZ
                                          // Упрощенный показ при котором показываются все линии геометрии полигона.
                                           for j3 := 0 to nsizei-2 do
                                          begin
                                             glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[j3], yi[j3], zi[j3]);
                                                 glVertex3f(xi[j3]+hi[j3], yi[j3], zi[j3]);
                                                 glVertex3f(xi[j3+1]+hi[j3+1], yi[j3+1], zi[j3+1]);
                                                 glVertex3f(xi[j3+1], yi[j3+1], zi[j3+1]);
                                             glEnd;
                                          end;
                                             glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[nsizei-1], yi[nsizei-1], zi[nsizei-1]);
                                                 glVertex3f(xi[nsizei-1]+hi[nsizei-1], yi[nsizei-1], zi[nsizei-1]);
                                                 glVertex3f(xi[0]+hi[0], yi[0], zi[0]);
                                                 glVertex3f(xi[0], yi[0], zi[0]);
                                             glEnd;
                                       end;
                                end;
                             end;
                             if (igeometry_type=1) then
                             begin
                                // Cylinder
                                case iPlane of
                                   1 : begin
                                          // XY
                                           glBegin(GL_LINE_LOOP);
                                             for i33 := 0 to 29 do
                                             begin
                                                angle33:=2.0*3.1415926*i33/29.0;
                                                dx33:=R_out_cyl*cos(angle33);
                                                dy33:=R_out_cyl*sin(angle33);
                                                glVertex3f(xC+dx33, yC+dy33, riso);
                                             end;
                                           glEnd;

                                           if (R_in_cyl>1.0e-20) then
                                           begin
                                              glBegin(GL_LINE_LOOP);
                                              for i33 := 0 to 29 do
                                              begin
                                                 angle33:=2.0*3.1415926*i33/29.0;
                                                 dx33:=R_in_cyl*cos(angle33);
                                                 dy33:=R_in_cyl*sin(angle33);
                                                 glVertex3f(xC+dx33, yC+dy33, riso);
                                              end;
                                              glEnd;
                                           end;
                                       end;
                                   2 : begin
                                          // XZ
                                           glBegin(GL_LINE_LOOP);
                                             glVertex3f(xE, yE, riso);
                                             glVertex3f(xS, yE, riso);
                                             glVertex3f(xS, yS, riso);
                                             glVertex3f(xE, yS, riso);
                                           glEnd;

                                           if (R_in_cyl>1.0e-20) then
                                           begin
                                               glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xC+R_in_cyl, yC+Hcyl, riso);
                                                 glVertex3f(xC-R_in_cyl, yC+Hcyl, riso);
                                                 glVertex3f(xC-R_in_cyl, yC, riso);
                                                 glVertex3f(xC+R_in_cyl, yC, riso);
                                               glEnd;
                                           end;
                                       end;
                                   3 : begin
                                          // YZ
                                           glBegin(GL_LINE_LOOP);
                                             glVertex3f(xE, yE, riso);
                                             glVertex3f(xS, yE, riso);
                                             glVertex3f(xS, yS, riso);
                                             glVertex3f(xE, yS, riso);
                                           glEnd;

                                           if (R_in_cyl>1.0e-20) then
                                           begin
                                              glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xC+Hcyl, yC+R_in_cyl, riso);
                                                 glVertex3f(xC, yC+R_in_cyl, riso);
                                                 glVertex3f(xC, yC-R_in_cyl, riso);
                                                 glVertex3f(xC+Hcyl, yC-R_in_cyl, riso);
                                              glEnd;
                                           end;


                                       end;
                                end;
                             end;
                             glLineWidth(1.0);

                           glPopmatrix;
                        end;
                    end
                     else
                    begin
                       ShowMessage('Error! Incorrect iso value...');
                       edtvalue.Text:='0.0';
                    end;
                 end;
              2 : // XZ
                 begin

                   striso:=Trim(edtvalue.Text);
                     for iisoscan:=1 to length(striso) do
                     begin
                        if (FormatSettings.DecimalSeparator=',') then
                        begin
                           if (striso[iisoscan]='.') then striso[iisoscan]:=',';
                        end;
                        if (FormatSettings.DecimalSeparator='.') then
                        begin
                           if (striso[iisoscan]=',') then striso[iisoscan]:='.';
                        end;
                     end;
                     edtvalue.Text:=striso;

                      sforval:='';
                    sforval:=StringReplace(edtvalue.Text,',','.',[rfReplaceAll]);
                    val(sforval,c,code);
                    //val(edtvalue.Text,c,code);
                    if (code=0) then
                    begin
                       riso:=StrToFloat(edtvalue.Text);
                       //if ((riso>=yS)and(riso<=yE)) then
                       //begin
                       if (if_visible_now(riso,yS,yE)) then
                       begin
                          glpushMatrix;
	                       // glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                         glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                         glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                         //---> glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                         //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                         //---->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                         // Вращательное движение в 3D имеет три степени свободы.
                         glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                         glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                         glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                         glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                         glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                          if ((ch='b') and (itekpaint=j)) then
                          begin
                             glLineWidth(4.0);
                             glColor3f(1.0,0.0,0.0);
                          end
                           else
                          begin
                              //glLineWidth(1.0);
                              glLineWidth(BodyLineWidth);
                              //glColor3f(0.0,0.0,0.0);
                              glColor3f(redcolor,greencolor,bluecolor);
                          end;

                          if (j=0) then
                          begin
                             // кабинет.
                             glColor3f(0.0,0.0,1.0); // синий цвет.
                          end;

                           if (igeometry_type=0) then
                           begin
                               // Prism
                               glBegin(GL_LINE_LOOP);
                                 glVertex3f(xE, riso, zE);
                                 glVertex3f(xS, riso, zE);
                                 glVertex3f(xS, riso, zS);
                                 glVertex3f(xE, riso, zS);
                               glEnd;
                           end;

                           if (igeometry_type=2) then
                             begin
                                // XZ
                                case iPlane_obj2 of
                                   1 : begin
                                          // XY
                                          // Упрощенный показ при котором показываются все линии геометрии полигона.
                                          for j3 := 0 to nsizei-2 do
                                          begin
                                             glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[j3], yi[j3], zi[j3]);
                                                 glVertex3f(xi[j3], yi[j3], zi[j3]+hi[j3]);
                                                 glVertex3f(xi[j3+1], yi[j3+1], zi[j3+1]+hi[j3+1]);
                                                 glVertex3f(xi[j3+1], yi[j3+1], zi[j3+1]);
                                             glEnd;
                                          end;
                                          glBegin(GL_LINE_LOOP);
                                              glVertex3f(xi[nsizei-1], yi[nsizei-1], zi[nsizei-1]);
                                              glVertex3f(xi[nsizei-1], yi[nsizei-1], zi[nsizei-1]+hi[nsizei-1]);
                                              glVertex3f(xi[0], yi[0], zi[0]+hi[0]);
                                              glVertex3f(xi[0], yi[0], zi[0]);
                                          glEnd;
                                       end;
                                   2 : begin
                                          // XZ
                                          for j3 := 0 to nsizei-2 do
                                          begin
                                             glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[j3], riso, zi[j3]);
                                                 glVertex3f(xi[j3+1], riso, zi[j3+1]);
                                             glEnd;
                                          end;
                                          glBegin(GL_LINE_LOOP);
                                              glVertex3f(xi[nsizei-1], riso, zi[nsizei-1]);
                                              glVertex3f(xi[0], riso, zi[0]);
                                          glEnd;
                                       end;
                                   3 : begin
                                          // YZ
                                          // Упрощенный показ при котором показываются все линии геометрии полигона.
                                          for j3 := 0 to nsizei-2 do
                                          begin
                                             glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[j3], yi[j3], zi[j3]);
                                                 glVertex3f(xi[j3]+hi[j3], yi[j3], zi[j3]);
                                                 glVertex3f(xi[j3+1]+hi[j3+1], yi[j3+1], zi[j3+1]);
                                                 glVertex3f(xi[j3+1], yi[j3+1], zi[j3+1]);
                                             glEnd;
                                          end;
                                          glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[nsizei-1], yi[nsizei-1], zi[nsizei-1]);
                                                 glVertex3f(xi[nsizei-1]+hi[nsizei-1], yi[nsizei-1], zi[nsizei-1]);
                                                 glVertex3f(xi[0]+hi[0], yi[0], zi[0]);
                                                 glVertex3f(xi[0], yi[0], zi[0]);
                                             glEnd;
                                       end;
                                end;
                             end;

                           if (igeometry_type=1) then
                           begin
                              // Cylinder
                              case iPlane of
                                 1 : begin
                                        // XY
                                        glBegin(GL_LINE_LOOP);
                                           glVertex3f(xE, riso, zE);
                                           glVertex3f(xS, riso, zE);
                                           glVertex3f(xS, riso, zS);
                                           glVertex3f(xE, riso, zS);
                                        glEnd;
                                        if (R_in_cyl>1.0e-20) then
                                        begin
                                           glBegin(GL_LINE_LOOP);
                                              glVertex3f(xC+R_in_cyl, riso, zC+Hcyl);
                                              glVertex3f(xC-R_in_cyl, riso, zC+Hcyl);
                                              glVertex3f(xC-R_in_cyl, riso, zC);
                                              glVertex3f(xC+R_in_cyl, riso, zC);
                                           glEnd;
                                        end;

                                     end;
                                 2 : begin
                                        // XZ
                                        glBegin(GL_LINE_LOOP);
                                          for i33 := 0 to 29 do
                                          begin
                                             angle33:=2.0*3.1415926*i33/29.0;
                                             dx33:=R_out_cyl*cos(angle33);
                                             dy33:=R_out_cyl*sin(angle33);
                                             glVertex3f(xC+dx33, riso, zC+dy33);
                                          end;
                                        glEnd;
                                       if (R_in_cyl>1.0e-20) then
                                       begin
                                          glBegin(GL_LINE_LOOP);
                                          for i33 := 0 to 29 do
                                          begin
                                             angle33:=2.0*3.1415926*i33/29.0;
                                             dx33:=R_in_cyl*cos(angle33);
                                             dy33:=R_in_cyl*sin(angle33);
                                             glVertex3f(xC+dx33, riso, zC+dy33);
                                          end;
                                          glEnd;
                                       end;
                                     end;
                                 3 : begin
                                        // YZ
                                        glBegin(GL_LINE_LOOP);
                                           glVertex3f(xE, riso, zE);
                                           glVertex3f(xS, riso, zE);
                                           glVertex3f(xS, riso, zS);
                                           glVertex3f(xE, riso, zS);
                                        glEnd;

                                         if (R_in_cyl>1.0e-20) then
                                        begin
                                           // TODO
                                           glBegin(GL_LINE_LOOP);
                                              glVertex3f(xC+Hcyl, riso, zC+R_in_cyl);
                                              glVertex3f(xC, riso, zC+R_in_cyl);
                                              glVertex3f(xC, riso, zC-R_in_cyl);
                                              glVertex3f(xC+Hcyl, riso, zC-R_in_cyl);
                                           glEnd;
                                        end;

                                     end;
                              end;
                           end;

                           glLineWidth(1.0);

                         glPopmatrix;
                       end;
                    end
                     else
                    begin
                       ShowMessage('Error! Incorrect iso value...');
                       edtvalue.Text:='0.0';
                    end;
                 end;
              3 : // YZ
                 begin

                    striso:=Trim(edtvalue.Text);
                     for iisoscan:=1 to length(striso) do
                     begin
                        if (FormatSettings.DecimalSeparator=',') then
                        begin
                           if (striso[iisoscan]='.') then striso[iisoscan]:=',';
                        end;
                        if (FormatSettings.DecimalSeparator='.') then
                        begin
                           if (striso[iisoscan]=',') then striso[iisoscan]:='.';
                        end;
                     end;
                     edtvalue.Text:=striso;

                      sforval:='';
                    sforval:=StringReplace(edtvalue.Text,',','.',[rfReplaceAll]);
                    val(sforval,c,code);
                    //val(edtvalue.Text,c,code);
                    if (code=0) then
                    begin
                       riso:=StrToFloat(edtvalue.Text);
                       //if ((riso>=xS)and(riso<=xE)) then
                       //begin
                       if (if_visible_now(riso,xS,xE)) then
                       begin
                          glpushMatrix;
	                       // glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                         glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                         glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                         //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                         //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                         //---->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                         // Вращательное движение в 3D имеет три степени свободы.
                         glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                         glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                         glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                         glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                         glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                          if ((ch='b') and (itekpaint=j)) then
                          begin
                             glLineWidth(4.0);
                             glColor3f(1.0,0.0,0.0);
                          end
                           else
                          begin
                             //glLineWidth(1.0);
                              glLineWidth(BodyLineWidth);
                              //glColor3f(0.0,0.0,0.0);
                              glColor3f(redcolor,greencolor,bluecolor);
                          end;

                          if (j=0) then
                          begin
                             // кабинет.
                             glColor3f(0.0,0.0,1.0); // синий цвет.
                          end;

                           if (igeometry_type=0) then
                           begin
                               // Prism
                               glBegin(GL_LINE_LOOP);
                                 glVertex3f(riso, yE, zE);
                                 glVertex3f(riso, yS, zE);
                                 glVertex3f(riso, yS, zS);
                                 glVertex3f(riso, yE, zS);
                               glEnd;
                           end;

                           if (igeometry_type=2) then
                             begin
                                // YZ
                                case iPlane_obj2 of
                                   1 : begin
                                          // XY
                                          // Упрощенный показ при котором показываются все линии геометрии полигона.
                                          for j3 := 0 to nsizei-2 do
                                          begin
                                             glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[j3], yi[j3], zi[j3]);
                                                 glVertex3f(xi[j3], yi[j3], zi[j3]+hi[j3]);
                                                 glVertex3f(xi[j3+1], yi[j3+1], zi[j3+1]+hi[j3+1]);
                                                 glVertex3f(xi[j3+1], yi[j3+1], zi[j3+1]);
                                             glEnd;
                                          end;
                                          glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[nsizei-1], yi[nsizei-1], zi[nsizei-1]);
                                                 glVertex3f(xi[nsizei-1], yi[nsizei-1], zi[nsizei-1]+hi[nsizei-1]);
                                                 glVertex3f(xi[0], yi[0], zi[0]+hi[0]);
                                                 glVertex3f(xi[0], yi[0], zi[0]);
                                             glEnd;
                                       end;
                                   2 : begin
                                          // XZ
                                          // Упрощенный показ при котором показываются все линии геометрии полигона.
                                          for j3 := 0 to nsizei-2 do
                                          begin
                                             glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[j3], yi[j3], zi[j3]);
                                                 glVertex3f(xi[j3], yi[j3]+hi[j3], zi[j3]);
                                                 glVertex3f(xi[j3+1], yi[j3+1]+hi[j3+1], zi[j3+1]);
                                                 glVertex3f(xi[j3+1], yi[j3+1], zi[j3+1]);
                                             glEnd;
                                          end;
                                          glBegin(GL_LINE_LOOP);
                                                 glVertex3f(xi[nsizei-1], yi[nsizei-1], zi[nsizei-1]);
                                                 glVertex3f(xi[nsizei-1], yi[nsizei-1]+hi[nsizei-1], zi[nsizei-1]);
                                                 glVertex3f(xi[0], yi[0]+hi[0], zi[0]);
                                                 glVertex3f(xi[0], yi[0], zi[0]);
                                             glEnd;
                                       end;
                                   3 : begin
                                          // YZ
                                          for j3 := 0 to nsizei-2 do
                                          begin
                                             glBegin(GL_LINE_LOOP);
                                                 glVertex3f( riso, yi[j3], zi[j3]);
                                                 glVertex3f(riso, yi[j3+1], zi[j3+1]);
                                             glEnd;
                                          end;
                                          glBegin(GL_LINE_LOOP);
                                             glVertex3f( riso, yi[nsizei-1], zi[nsizei-1]);
                                             glVertex3f(riso, yi[0], zi[0]);
                                          glEnd;
                                       end;
                                end;
                             end;

                           if (igeometry_type=1) then
                           begin
                              // Cylinder
                              case iPlane of
                                1 : begin
                                       // XY
                                       glBegin(GL_LINE_LOOP);
                                         glVertex3f(riso, yE, zE);
                                         glVertex3f(riso, yS, zE);
                                         glVertex3f(riso, yS, zS);
                                         glVertex3f(riso, yE, zS);
                                       glEnd;
                                        if (R_in_cyl>1.0e-20) then
                                       begin
                                          glBegin(GL_LINE_LOOP);
                                            glVertex3f(riso, yC+R_in_cyl, zC+Hcyl);
                                            glVertex3f(riso, yC-R_in_cyl, zC+Hcyl);
                                            glVertex3f(riso, yC-R_in_cyl, zC);
                                            glVertex3f(riso, yC+R_in_cyl, zC);
                                          glEnd;
                                       end;
                                    end;
                                2 : begin
                                       // XZ
                                       glBegin(GL_LINE_LOOP);
                                         glVertex3f(riso, yE, zE);
                                         glVertex3f(riso, yS, zE);
                                         glVertex3f(riso, yS, zS);
                                         glVertex3f(riso, yE, zS);
                                       glEnd;
                                        if (R_in_cyl>1.0e-20) then
                                       begin
                                          glBegin(GL_LINE_LOOP);
                                            glVertex3f(riso, yC+Hcyl, zC+R_in_cyl);
                                            glVertex3f(riso, yC, zC+R_in_cyl);
                                            glVertex3f(riso, yC, zC-R_in_cyl);
                                            glVertex3f(riso, yC+Hcyl, zC-R_in_cyl);
                                          glEnd;
                                       end;
                                    end;
                                3 : begin
                                       // YZ
                                       glBegin(GL_LINE_LOOP);
                                          for i33 := 0 to 29 do
                                          begin
                                             angle33:=2.0*3.1415926*i33/29.0;
                                             dx33:=R_out_cyl*cos(angle33);
                                             dy33:=R_out_cyl*sin(angle33);
                                             glVertex3f(riso, yC+dx33, zC+dy33);
                                          end;
                                       glEnd;
                                       if (R_in_cyl>1.0e-20) then
                                       begin
                                          glBegin(GL_LINE_LOOP);
                                            for i33 := 0 to 29 do
                                            begin
                                               angle33:=2.0*3.1415926*i33/29.0;
                                               dx33:=R_in_cyl*cos(angle33);
                                               dy33:=R_in_cyl*sin(angle33);
                                               glVertex3f(riso, yC+dx33, zC+dy33);
                                            end;
                                          glEnd;
                                       end;
                                    end;
                              end;
                           end;

                           glLineWidth(1.0);
                         glPopmatrix;
                       end;
                    end
                     else
                    begin
                       ShowMessage('Error! Incorrect iso value...');
                       if (FormatSettings.DecimalSeparator='.') then
                       begin
                          edtvalue.Text:='0.0';
                       end;
                       if (FormatSettings.DecimalSeparator=',') then
                       begin
                          edtvalue.Text:='0,0';
                       end;
                    end;
                 end;
            end;

           end;
        end;
     end;

     // Прорисовка остальных элементов.
     for j:=0 to (lw-1) do
     begin // проход по всем твёрдым стенкам
        with wall[j] do
        begin
           if (wall[j].bvisible) then
           begin

              glpushMatrix;
	            //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
              glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
              glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
              //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
              //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
              ///--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
              // Вращательное движение в 3D имеет три степени свободы.
              glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
              glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
              glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
              glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
              glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

              if ((ch='w') and (itekpaint=j)) then
              begin
                 glLineWidth(4.0);
                 glColor3f(1.0,0.0,0.0);
              end
               else
              begin
                 glLineWidth(1.0);
                 glColor3f(0.0,1.0,0.0);  // Синий.
                 if (bsymmetry or bpressure or bopening) then glColor3f(1.0,1.0,0.0); // жёлтый
                 if ((abs(Vx)>epsilon) or (abs(Vy)>epsilon) or (abs(Vz)>epsilon)) then
                    glColor3f(1.0,0.0,1.0); // Пурпурный.
              end;



              case iPlane of
                  1 : // XY
                    begin
                        glBegin(GL_LINE_LOOP);
                           glVertex3f(xE, yE, zE);
                           glVertex3f(xS, yE, zE);
                           glVertex3f(xS, yS, zE);
                           glVertex3f(xE, yS, zE);
                         glEnd;
                      end;
                   2 : // XZ
                      begin
                         glBegin(GL_LINE_LOOP);
                           glVertex3f(xE, yE, zE);
                           glVertex3f(xS, yE, zE);
                           glVertex3f(xS, yE, zS);
                           glVertex3f(xE, yE, zS);
                         glEnd;
                      end;
                   3 : // YZ
                      begin
                          glBegin(GL_LINE_LOOP);
                           glVertex3f(xE, yE, zE);
                           glVertex3f(xE, yS, zE);
                           glVertex3f(xE, yS, zS);
                           glVertex3f(xE, yE, zS);
                         glEnd;
                      end;
              end;

              glLineWidth(1.0);

              glPopmatrix;

           end;
        end;
     end;



     end;

  end;
  1 : // Работающий  Z буффер (удаление невидимых линий).
  begin
     // рисование шести сторон куба

     // Не менять порядок обхода линиями периметра граней.
     // Это важно.
     // Для каждого блока мы обходим все его грани в последовательности
     // (TOP, BOTTOM, WEST, EAST, NORTH, SOUSH).
     // Обработка каждой грани заключается в том
     // что прорисовываем её цветом фона при включённом Z-буфере,
     // а потом рисуем окоймляющие её линии которые немного выступают наружу от
     // периметра грани, конкретно на 1%.

     (* //Этот вариант закоментирован ка слишком медленный для
     //  Рендеринга 10 марта 2015 года.
     // константа dopusk не используется, вместо неё используется фиксированная величина 0.01.
     for j:=0 to Length(blockgraphics)-1 do
     // проблема в размерности.
    //for j:=0 to 100 do // скорость приемлема
     begin
        with (blockgraphics[j]) do
        begin

           glpushMatrix;
	         glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));

           glColor3f(1,1,1);
           glBegin(GL_QUADS);
             glVertex3f(xE, yE, zE);
             glVertex3f(xS, yE, zE);
             glVertex3f(xS, yS, zE);
             glVertex3f(xE, yS, zE);
           glEnd;

           glColor3f(0,0,0);
           (*
           glBegin(GL_LINE_LOOP);
             glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(zE-zS));
             glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(zE-zS));
             glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(zE-zS));
             glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(zE-zS));
           glEnd;
           *)(*

           // *** zE ***
           if (zE_xE2xS) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(zE-zS));
                  glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(zE-zS));
              glEnd;
           end;

           if (zE_yE2yS) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(zE-zS));
                  glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(zE-zS));
              glEnd;
           end;

           if (zE_xS2xE) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(zE-zS));
                  glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(zE-zS));
              glEnd;
           end;

           if (zE_yS2yE) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(zE-zS));
                  glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(zE-zS));
              glEnd;
           end;

           glColor3f(1,1,1);
           glBegin(GL_QUADS);
             glVertex3f(xE, yE, zS);
             glVertex3f(xE, yS, zS);
             glVertex3f(xS, yS, zS);
             glVertex3f(xS, yE, zS);
           glEnd;

           glColor3f(0,0,0);

           (*
           glBegin(GL_LINE_LOOP);
             glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
             glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
             glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
             glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
           glEnd;
           *)(*

            // *** zS ***
            if (zS_yE2yS) then
            begin
               glBegin(GL_LINE_LOOP);
                   glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
                   glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
               glEnd;
            end;

            if (zS_xE2xS) then
            begin
               glBegin(GL_LINE_LOOP);
                   glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
                   glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
               glEnd;
            end;

            if (zS_yS2yE) then
            begin
               glBegin(GL_LINE_LOOP);
                   glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
                   glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
               glEnd;
            end;

            if (zS_xS2xE) then
            begin
               glBegin(GL_LINE_LOOP);
                   glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
                   glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
               glEnd;
            end;


           glColor3f(1,1,1);
           glBegin(GL_QUADS);
             glVertex3f(xS, yE, zE);
             glVertex3f(xS, yE, zS);
             glVertex3f(xS, yS, zS);
             glVertex3f(xS, yS, zE);
           glEnd;

           glColor3f(0,0,0);
           (*
           glBegin(GL_LINE_LOOP);
             glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(zE-zS));
             glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
             glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
             glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(zE-zS));
           glEnd;
            *) (*
           // *** xS ***



           if (xS_zE2zS) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(zE-zS));
                  glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
              glEnd;
           end;

           if (xS_yE2yS) then
           begin
              glBegin(GL_LINE_LOOP);
                 glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
                 glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
              glEnd;
           end;

           if (xS_zS2zE) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
                  glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(zE-zS));
              glEnd;
           end;

           if (xS_yS2yE) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(zE-zS));
                  glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(zE-zS));
              glEnd;
           end;


           glColor3f(1,1,1);
           glBegin(GL_QUADS);
             glVertex3f(xE, yE, zE);
             glVertex3f(xE, yS, zE);
             glVertex3f(xE, yS, zS);
             glVertex3f(xE, yE, zS);
           glEnd;

           glColor3f(0,0,0);
           (*
           glBegin(GL_LINE_LOOP);
             glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(zE-zS));
             glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
             glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
             glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(zE-zS));
           glEnd;
           *)  (*

           // *** xE ***

           if (xE_zE2zS) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(zE-zS));
                  glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
              glEnd;
           end;

           if (xE_yE2yS) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
                  glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
              glEnd;
           end;

           if (xE_zS2zE) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
                  glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(zE-zS));
              glEnd;
           end;

           if (xE_yS2yE) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(zE-zS));
                  glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(zE-zS));
              glEnd;
           end;


           glColor3f(1,1,1);
           glBegin(GL_QUADS);
             glVertex3f(xS, yE, zS);
             glVertex3f(xS, yE, zE);
             glVertex3f(xE, yE, zE);
             glVertex3f(xE, yE, zS);
           glEnd;

           glColor3f(0,0,0);
           (*
           glBegin(GL_LINE_LOOP);
             glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
             glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(yE-yS));
             glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(yE-yS));
             glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
           glEnd;
           *) (*


           // *** yE ***

           if (yE_zS2zE) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
                  glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(yE-yS));
              glEnd;
           end;

            if (yE_xS2xE) then
           begin
              glBegin(GL_LINE_LOOP);
                 glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(yE-yS));
                 glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(yE-yS));
              glEnd;
           end;

            if (yE_zE2zS) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zE+0.01*(yE-yS));
                  glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
              glEnd;
           end;

            if (yE_xE2xS) then
           begin
              glBegin(GL_LINE_LOOP);
                 glVertex3f(xE+0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
                 glVertex3f(xS-0.01*(xE-xS), yE+0.01*(yE-yS), zS-0.01*(zE-zS));
              glEnd;
           end;

           glColor3f(1,1,1);
           glBegin(GL_QUADS);
             glVertex3f(xS, yS, zS);
             glVertex3f(xE, yS, zS);
             glVertex3f(xE, yS, zE);
             glVertex3f(xS, yS, zE);
           glEnd;

           glColor3f(0,0,0);

           (*
           glBegin(GL_LINE_LOOP);
             glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
             glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
             glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(yE-yS));
             glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(yE-yS));
           glEnd;
           *) (*

           // *** yS ***

           if (yS_xS2xE) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
                  glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
              glEnd;
           end;

           if (yS_zS2zE) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
                  glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(yE-yS));
              glEnd;
           end;

           if (yS_xE2xS) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xE+0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(yE-yS));
                  glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(yE-yS));
              glEnd;
           end;

           if (yS_zE2zS) then
           begin
              glBegin(GL_LINE_LOOP);
                  glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zE+0.01*(yE-yS));
                  glVertex3f(xS-0.01*(xE-xS), yS-0.01*(yE-yS), zS-0.01*(zE-zS));
              glEnd;
           end;

           glPopmatrix;



        end;

     end;*)




     median_size:=0.0;
     for j:=0 to Length(blockgraphics)-1 do
     begin
        with (blockgraphics[j]) do
        begin
           median_size:=median_size+(abs(xE-xS)+abs(yE-yS)+abs(zE-zS))/3.0;
        end;
     end;
     median_size:=median_size/Length(blockgraphics);
     median_size:=0.0;// отключение отступов.
    // median_size:=1.0;
     // Теперь значение median_size лучше подходит для того чтобы леч в основу визуализации каркасной модели.
     //glDisable(GL_CULL_FACE);
      //glFrontFace(GL_CW);
      //glFrontFace(GL_СCW);
     // glClear (GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
     // glEnable(GL_DEPTH_TEST);

    // glMatrixMode(GL_PROJECTION);
	  // glLoadIdentity();
	   //glFrustum (-1, 1, -1, 1, 3, 15);
	   //glMatrixMode(GL_MODELVIEW);
	  // glLoadIdentity();

	   //glTranslatef(0.0, 0.0, -9.0);

	   //glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

     // 10 марта 2015 предложен более быстрый вариант
     // для рендеринга, который прорисовывает
     // только одинарные грани без пары, потому что
     // парные грани (общие для двух блоков невидны).
     // for j:=Length(vg)-1 downto 0 do

     for j := length(blockgraphics)-1 downto 0 do
     begin
        (*
        MainMemo.Lines.Add(IntToStr(blockgraphics[0].igeometry_type)+' '+
        IntToStr(blockgraphics[1].igeometry_type)+' '+
        IntToStr(blockgraphics[2].igeometry_type)+' '+
        IntToStr(blockgraphics[3].igeometry_type)+' '+
        IntToStr(blockgraphics[4].igeometry_type)+' '+
        IntToStr(blockgraphics[5].igeometry_type)+' '+
        IntToStr(blockgraphics[6].igeometry_type)+' '+
        IntToStr(blockgraphics[7].igeometry_type)+' '+
        IntToStr(blockgraphics[8].igeometry_type)+' ');
        *)

        //with (blockgraphics[j]) do
        if (blockgraphics[j].igeometry_type<>2) then
        begin

           // сначала прорисовываем непрозрачные объекты.
           // if (transparency>0.95) then
           begin
              glpushMatrix;
	            //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
              glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
              glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
              //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
              //  glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
              //--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
              // Вращательное движение в 3D имеет три степени свободы.
              glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
              glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
              glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
              glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
              glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
              (*
              // С заливкой
              glColor3f(1,1,1);  // Цвет фона.
              if (start_on) then
              begin
                 // xS, yS, zS
                 case iPlane of
                  1 : begin
                         // XY zS
                         glBegin(GL_QUADS);
                            glVertex3f(xE, yE, zS);
                            glVertex3f(xE, yS, zS);
                            glVertex3f(xS, yS, zS);
                            glVertex3f(xS, yE, zS);
                         glEnd;
                      end;
                  2 : begin
                         // XZ yS
                          glBegin(GL_QUADS);
                            glVertex3f(xS, yS, zS);
                            glVertex3f(xE, yS, zS);
                            glVertex3f(xE, yS, zE);
                            glVertex3f(xS, yS, zE);
                          glEnd;
                      end;
                  3 : begin
                         // YZ xS
                         glBegin(GL_QUADS);
                           glVertex3f(xS, yE, zE);
                           glVertex3f(xS, yE, zS);
                           glVertex3f(xS, yS, zS);
                           glVertex3f(xS, yS, zE);
                         glEnd;
                      end;
                 end;
              end
              else
              begin
                 // xE, yE, zE
                 case iPlane of
                  1 : begin
                         // XY zE
                         glBegin(GL_QUADS);
                           glVertex3f(xE, yE, zE);
                           glVertex3f(xS, yE, zE);
                           glVertex3f(xS, yS, zE);
                           glVertex3f(xE, yS, zE);
                         glEnd;
                      end;
                  2 : begin
                         // XZ yE
                          glBegin(GL_QUADS);
                            glVertex3f(xS, yE, zS);
                            glVertex3f(xS, yE, zE);
                            glVertex3f(xE, yE, zE);
                            glVertex3f(xE, yE, zS);
                          glEnd;
                      end;
                  3 : begin
                         // YZ xE
                          glBegin(GL_QUADS);
                            glVertex3f(xE, yE, zE);
                            glVertex3f(xE, yS, zE);
                            glVertex3f(xE, yS, zS);
                            glVertex3f(xE, yE, zS);
                          glEnd;
                      end;
                 end;
              end;

              glColor3f(0,0,0);  // Чёрные линии.

               if (start_on) then
              begin
                 // xS, yS, zS
                 case iPlane of
                  1 : begin
                         // XY zS
                          // *** zS ***
                         if (zS_yE2yS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*(xE-xS), yE+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                              glVertex3f(xE+dopusk*(xE-xS), yS-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (zS_xE2xS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*(xE-xS), yS-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                               glVertex3f(xS-dopusk*(xE-xS), yS-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (zS_yS2yE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xS-dopusk*(xE-xS), yS-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                               glVertex3f(xS-dopusk*(xE-xS), yE+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (zS_xS2xE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xS-dopusk*(xE-xS), yE+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                               glVertex3f(xE+dopusk*(xE-xS), yE+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                            glEnd;
                         end;
                      end;
                  2 : begin
                         // XZ yS

                          // *** yS ***

                          if (yS_xS2xE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*(xE-xS), yS-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                                glVertex3f(xE+dopusk*(xE-xS), yS-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                             glEnd;
                          end;

                          if (yS_zS2zE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*(xE-xS), yS-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                               glVertex3f(xE+dopusk*(xE-xS), yS-dopusk*(yE-yS), zE+dopusk*(yE-yS));
                             glEnd;
                          end;

                          if (yS_xE2xS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*(xE-xS), yS-dopusk*(yE-yS), zE+dopusk*(yE-yS));
                               glVertex3f(xS-dopusk*(xE-xS), yS-dopusk*(yE-yS), zE+dopusk*(yE-yS));
                             glEnd;
                          end;

                          if (yS_zE2zS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*(xE-xS), yS-dopusk*(yE-yS), zE+dopusk*(yE-yS));
                                glVertex3f(xS-dopusk*(xE-xS), yS-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                             glEnd;
                          end;

                      end;
                  3 : begin
                         // YZ xS

                          // *** xS ***



                          if (xS_zE2zS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                               glVertex3f(xS-dopusk*(xE-xS), yE+dopusk*(yE-yS), zE+dopusk*(zE-zS));
                               glVertex3f(xS-dopusk*(xE-xS), yE+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                             glEnd;
                          end;

                          if (xS_yE2yS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*(xE-xS), yE+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                                glVertex3f(xS-dopusk*(xE-xS), yS-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                             glEnd;
                          end;

                          if (xS_zS2zE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*(xE-xS), yS-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                                glVertex3f(xS-dopusk*(xE-xS), yS-dopusk*(yE-yS), zE+dopusk*(zE-zS));
                             glEnd;
                          end;

                          if (xS_yS2yE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*(xE-xS), yS-dopusk*(yE-yS), zE+dopusk*(zE-zS));
                                glVertex3f(xS-dopusk*(xE-xS), yE+dopusk*(yE-yS), zE+dopusk*(zE-zS));
                             glEnd;
                          end;


                      end;
                 end;
              end
              else
              begin
                 // xE, yE, zE
                 case iPlane of
                  1 : begin
                         // XY zE

                         // *** zE ***
                         if (zE_xE2xS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*(xE-xS), yE+dopusk*(yE-yS), zE+dopusk*(zE-zS));
                              glVertex3f(xS-dopusk*(xE-xS), yE+dopusk*(yE-yS), zE+dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (zE_yE2yS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xS-dopusk*(xE-xS), yE+dopusk*(yE-yS), zE+dopusk*(zE-zS));
                              glVertex3f(xS-dopusk*(xE-xS), yS-dopusk*(yE-yS), zE+dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (zE_xS2xE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xS-dopusk*(xE-xS), yS-dopusk*(yE-yS), zE+dopusk*(zE-zS));
                               glVertex3f(xE+dopusk*(xE-xS), yS-dopusk*(yE-yS), zE+dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (zE_yS2yE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*(xE-xS), yS-dopusk*(yE-yS), zE+dopusk*(zE-zS));
                               glVertex3f(xE+dopusk*(xE-xS), yE+dopusk*(yE-yS), zE+dopusk*(zE-zS));
                            glEnd;
                         end;

                      end;
                  2 : begin
                         // XZ yE

                         // *** yE ***

                         if (yE_zS2zE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xS-dopusk*(xE-xS), yE+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                              glVertex3f(xS-dopusk*(xE-xS), yE+dopusk*(yE-yS), zE+dopusk*(yE-yS));
                            glEnd;
                         end;

                         if (yE_xS2xE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xS-dopusk*(xE-xS), yE+dopusk*(yE-yS), zE+dopusk*(yE-yS));
                              glVertex3f(xE+dopusk*(xE-xS), yE+dopusk*(yE-yS), zE+dopusk*(yE-yS));
                            glEnd;
                         end;

                         if (yE_zE2zS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*(xE-xS), yE+dopusk*(yE-yS), zE+dopusk*(yE-yS));
                               glVertex3f(xE+dopusk*(xE-xS), yE+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (yE_xE2xS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*(xE-xS), yE+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                               glVertex3f(xS-dopusk*(xE-xS), yE+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                            glEnd;
                         end;
                      end;
                  3 : begin
                         // YZ xE

                         // *** xE ***

                         if (xE_zE2zS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*(xE-xS), yE+dopusk*(yE-yS), zE+dopusk*(zE-zS));
                              glVertex3f(xE+dopusk*(xE-xS), yE+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (xE_yE2yS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*(xE-xS), yE+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                              glVertex3f(xE+dopusk*(xE-xS), yS-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (xE_zS2zE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*(xE-xS), yS-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                               glVertex3f(xE+dopusk*(xE-xS), yS-dopusk*(yE-yS), zE+dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (xE_yS2yE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*(xE-xS), yS-dopusk*(yE-yS), zE+dopusk*(zE-zS));
                              glVertex3f(xE+dopusk*(xE-xS), yE+dopusk*(yE-yS), zE+dopusk*(zE-zS));
                            glEnd;
                         end;

                      end;
                 end;
              end;

              // Для прорисовки контуров отверстий.
              if (start_on) then
              begin
                 // xS, yS, zS
                 case iPlane of
                  1 : begin
                         // XY zS
                          // *** zS ***
                         if (zS_yE2yS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE-dopusk*(xE-xS), yE-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                              glVertex3f(xE-dopusk*(xE-xS), yS+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (zS_xE2xS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE-dopusk*(xE-xS), yS+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                               glVertex3f(xS+dopusk*(xE-xS), yS+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (zS_yS2yE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xS+dopusk*(xE-xS), yS+dopusk*(yE-yS), zS-dopusk*(zE-zS));
                               glVertex3f(xS+dopusk*(xE-xS), yE-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (zS_xS2xE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xS+dopusk*(xE-xS), yE-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                               glVertex3f(xE-dopusk*(xE-xS), yE-dopusk*(yE-yS), zS-dopusk*(zE-zS));
                            glEnd;
                         end;
                      end;
                  2 : begin
                         // XZ yS

                          // *** yS ***

                          if (yS_xS2xE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS+dopusk*(xE-xS), yS-dopusk*(yE-yS), zS+dopusk*(zE-zS));
                                glVertex3f(xE-dopusk*(xE-xS), yS-dopusk*(yE-yS), zS+dopusk*(zE-zS));
                             glEnd;
                          end;

                          if (yS_zS2zE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                               glVertex3f(xE-dopusk*(xE-xS), yS-dopusk*(yE-yS), zS+dopusk*(zE-zS));
                               glVertex3f(xE-dopusk*(xE-xS), yS-dopusk*(yE-yS), zE-dopusk*(yE-yS));
                             glEnd;
                          end;

                          if (yS_xE2xS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                               glVertex3f(xE-dopusk*(xE-xS), yS-dopusk*(yE-yS), zE-dopusk*(yE-yS));
                               glVertex3f(xS+dopusk*(xE-xS), yS-dopusk*(yE-yS), zE-dopusk*(yE-yS));
                             glEnd;
                          end;

                          if (yS_zE2zS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS+dopusk*(xE-xS), yS-dopusk*(yE-yS), zE-dopusk*(yE-yS));
                                glVertex3f(xS+dopusk*(xE-xS), yS-dopusk*(yE-yS), zS+dopusk*(zE-zS));
                             glEnd;
                          end;

                      end;
                  3 : begin
                         // YZ xS

                          // *** xS ***



                          if (xS_zE2zS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                               glVertex3f(xS-dopusk*(xE-xS), yE-dopusk*(yE-yS), zE-dopusk*(zE-zS));
                               glVertex3f(xS-dopusk*(xE-xS), yE-dopusk*(yE-yS), zS+dopusk*(zE-zS));
                             glEnd;
                          end;

                          if (xS_yE2yS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*(xE-xS), yE-dopusk*(yE-yS), zS+dopusk*(zE-zS));
                                glVertex3f(xS-dopusk*(xE-xS), yS+dopusk*(yE-yS), zS+dopusk*(zE-zS));
                             glEnd;
                          end;

                          if (xS_zS2zE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*(xE-xS), yS+dopusk*(yE-yS), zS+dopusk*(zE-zS));
                                glVertex3f(xS-dopusk*(xE-xS), yS+dopusk*(yE-yS), zE-dopusk*(zE-zS));
                             glEnd;
                          end;

                          if (xS_yS2yE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*(xE-xS), yS+dopusk*(yE-yS), zE-dopusk*(zE-zS));
                                glVertex3f(xS-dopusk*(xE-xS), yE-dopusk*(yE-yS), zE-dopusk*(zE-zS));
                             glEnd;
                          end;


                      end;
                 end;
              end
              else
              begin
                 // xE, yE, zE
                 case iPlane of
                  1 : begin
                         // XY zE

                         // *** zE ***
                         if (zE_xE2xS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE-dopusk*(xE-xS), yE-dopusk*(yE-yS), zE+dopusk*(zE-zS));
                              glVertex3f(xS+dopusk*(xE-xS), yE-dopusk*(yE-yS), zE+dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (zE_yE2yS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xS+dopusk*(xE-xS), yE-dopusk*(yE-yS), zE+dopusk*(zE-zS));
                              glVertex3f(xS+dopusk*(xE-xS), yS+dopusk*(yE-yS), zE+dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (zE_xS2xE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xS+dopusk*(xE-xS), yS+dopusk*(yE-yS), zE+dopusk*(zE-zS));
                               glVertex3f(xE-dopusk*(xE-xS), yS+dopusk*(yE-yS), zE+dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (zE_yS2yE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE-dopusk*(xE-xS), yS+dopusk*(yE-yS), zE+dopusk*(zE-zS));
                               glVertex3f(xE-dopusk*(xE-xS), yE-dopusk*(yE-yS), zE+dopusk*(zE-zS));
                            glEnd;
                         end;

                      end;
                  2 : begin
                         // XZ yE

                         // *** yE ***

                         if (yE_zS2zE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xS+dopusk*(xE-xS), yE+dopusk*(yE-yS), zS+dopusk*(zE-zS));
                              glVertex3f(xS+dopusk*(xE-xS), yE+dopusk*(yE-yS), zE-dopusk*(yE-yS));
                            glEnd;
                         end;

                         if (yE_xS2xE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xS+dopusk*(xE-xS), yE+dopusk*(yE-yS), zE-dopusk*(yE-yS));
                              glVertex3f(xE-dopusk*(xE-xS), yE+dopusk*(yE-yS), zE-dopusk*(yE-yS));
                            glEnd;
                         end;

                         if (yE_zE2zS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE-dopusk*(xE-xS), yE+dopusk*(yE-yS), zE-dopusk*(yE-yS));
                               glVertex3f(xE-dopusk*(xE-xS), yE+dopusk*(yE-yS), zS+dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (yE_xE2xS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE-dopusk*(xE-xS), yE+dopusk*(yE-yS), zS+dopusk*(zE-zS));
                               glVertex3f(xS+dopusk*(xE-xS), yE+dopusk*(yE-yS), zS+dopusk*(zE-zS));
                            glEnd;
                         end;
                      end;
                  3 : begin
                         // YZ xE

                         // *** xE ***

                         if (xE_zE2zS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*(xE-xS), yE-dopusk*(yE-yS), zE-dopusk*(zE-zS));
                              glVertex3f(xE+dopusk*(xE-xS), yE-dopusk*(yE-yS), zS+dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (xE_yE2yS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*(xE-xS), yE-dopusk*(yE-yS), zS+dopusk*(zE-zS));
                              glVertex3f(xE+dopusk*(xE-xS), yS+dopusk*(yE-yS), zS+dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (xE_zS2zE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*(xE-xS), yS+dopusk*(yE-yS), zS+dopusk*(zE-zS));
                               glVertex3f(xE+dopusk*(xE-xS), yS+dopusk*(yE-yS), zE-dopusk*(zE-zS));
                            glEnd;
                         end;

                         if (xE_yS2yE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*(xE-xS), yS+dopusk*(yE-yS), zE-dopusk*(zE-zS));
                              glVertex3f(xE+dopusk*(xE-xS), yE-dopusk*(yE-yS), zE-dopusk*(zE-zS));
                            glEnd;
                         end;

                      end;
                 end;
              end;
              *)



               // С заливкой
              glColor3f(1,1,1);  // Цвет фона белый.
              with (blockgraphics[j]) do
              begin
              // XY zS
              if (binvisible_face_detect(0.0,0.0,-1.0)) then
              begin
                 glBegin(GL_QUADS);
                    //glNormal3f(0.0,0.0,-1.0);
                    glVertex3f(xE, yE, zS);
                    //glNormal3f(0.0,0.0,-1.0);
                    glVertex3f(xE, yS, zS);
                    //glNormal3f(0.0,0.0,-1.0);
                    glVertex3f(xS, yS, zS);
                    // glNormal3f(0.0,0.0,-1.0);
                    glVertex3f(xS, yE, zS);
                 glEnd;
              end;

              // XZ yS
              if (binvisible_face_detect(0.0,-1.0,0.0)) then
              begin
                 glBegin(GL_QUADS);
                    //glNormal3f(0.0,-1.0,0.0);
                    glVertex3f(xS, yS, zS);
                    //glNormal3f(0.0,-1.0,0.0);
                    glVertex3f(xE, yS, zS);
                    //glNormal3f(0.0,-1.0,0.0);
                    glVertex3f(xE, yS, zE);
                    // glNormal3f(0.0,-1.0,0.0);
                    glVertex3f(xS, yS, zE);
                 glEnd;
              end;

              // YZ xS
              if (binvisible_face_detect(-1.0,0.0,0.0)) then
              begin
                 glBegin(GL_QUADS);
                     //glNormal3f(-1.0,0.0,0.0);
                     glVertex3f(xS, yE, zE);
                     //glNormal3f(-1.0,0.0,0.0);
                     glVertex3f(xS, yE, zS);
                     //glNormal3f(-1.0,0.0,0.0);
                     glVertex3f(xS, yS, zS);
                     // glNormal3f(-1.0,0.0,0.0);
                     glVertex3f(xS, yS, zE);
                  glEnd;
               end;


               // xE, yE, zE

               // XY zE
               if (binvisible_face_detect(0.0,0.0,1.0)) then
               begin
                  glBegin(GL_QUADS);
                    // glNormal3f(0.0,0.0,1.0);
                    glVertex3f(xE, yE, zE);
                    // glNormal3f(0.0,0.0,1.0);
                    glVertex3f(xS, yE, zE);
                    //glNormal3f(0.0,0.0,1.0);
                    glVertex3f(xS, yS, zE);
                    //glNormal3f(0.0,0.0,1.0);
                    glVertex3f(xE, yS, zE);
                  glEnd;
               end;

               // XZ yE
               if (binvisible_face_detect(0.0,1.0,0.0)) then
               begin
                  glBegin(GL_QUADS);
                    //glNormal3f(0.0,1.0,0.0);
                    glVertex3f(xE, yE, zE);
                    //glNormal3f(0.0,1.0,0.0);
                    glVertex3f(xE, yE, zS);
                    //glNormal3f(0.0,1.0,0.0);
                    glVertex3f(xS, yE, zS);
                    // glNormal3f(0.0,1.0,0.0);
                    glVertex3f(xS, yE, zE);
                  glEnd;
               end;

               // YZ xE
               if (binvisible_face_detect(1.0,0.0,0.0)) then
               begin
                  glBegin(GL_QUADS);
                    //glNormal3f(1.0,0.0,0.0);
                    glVertex3f(xE, yE, zE);
                    //glNormal3f(1.0,0.0,0.0);
                    glVertex3f(xE, yS, zE);
                    //glNormal3f(1.0,0.0,0.0);
                    glVertex3f(xE, yS, zS);
                    // glNormal3f(1.0,0.0,0.0);
                    glVertex3f(xE, yE, zS);
                  glEnd;
               end;
              end;

              glPopMatrix();
           end;
        end;
     end;



     for j:=1 to Laplas.lb-1 do
     begin
        with (Laplas.body[j]) do
        begin
           if (bvisible) then
           begin

            case cbbview.ItemIndex of
             0 : // all
             begin
                glpushMatrix;
	              //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                //-->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                //---->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                // Вращательное движение в 3D имеет три степени свободы.
                glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                 if (True) then
                 begin
                    //glLineWidth(1.0);
                    glLineWidth(ComboBoxlineWidth.ItemIndex+1.0);
                    glColor3f(0.0,0.0,0.0);// черный цвет
                 end
                  else
                 begin
                 //if ((ch='b') and (itekpaint=j)) then
                 //begin
                    //glLineWidth(4.0);
                    //glColor3f(1.0,0.0,0.0);
                 //end
                  //else
                 //begin
                    //glLineWidth(1.0);
                    //glLineWidth(body[j].BodyLineWidth);
                    glLineWidth(3.0);
                    if (itype=2) then
                    begin
                       // HOLLOW
                       glLineWidth(6.0);
                    end;
                    //glColor3f(0.0,0.0,0.0);
                    glColor3f(body[j].redcolor,body[j].greencolor,body[j].bluecolor);

                 //end;
                 end;


                 xE1:=xE;
                 xS1:=xS;
                 yE1:=yE;
                 yS1:=yS;
                 zE1:=zE;
                 zS1:=zS;

                 //if (j=0) then
                 //begin
                    // кабинет.
                   // glColor3f(0.0,0.0,1.0); // синий цвет.
                 //end;

                if (igeometry_type=0) then //PRISM
                begin
                   if (itype<>2) then
                   begin
                      // Prism
                      // SOLID or FLUID

                      // рисуем на dopusk больший объём.
                      if ((abs(xE-xS)>=abs(yE-yS))and(abs(xE-xS)>=abs(zE-zS))) then
                      begin
                         xE1:=xE1+dopusk1*abs(xE-xS);
                         xS1:=xS1-dopusk1*abs(xE-xS);
                      end
                      else
                      begin
                         xE1:=xE1+dopusk2*abs(xE-xS);
                         xS1:=xS1-dopusk2*abs(xE-xS);
                      end;
                      if ((abs(yE-yS)>=abs(xE-xS))and(abs(yE-yS)>=abs(zE-zS))) then
                      begin
                         yE1:=yE1+dopusk1*abs(yE-yS);
                         yS1:=yS1-dopusk1*abs(yE-yS);
                      end
                      else
                      begin
                         yE1:=yE1+dopusk2*abs(yE-yS);
                         yS1:=yS1-dopusk2*abs(yE-yS);
                      end;
                      if ((abs(zE-zS)>=abs(xE-xS))and(abs(zE-zS)>=abs(yE-yS))) then
                      begin
                         zE1:=zE1+dopusk1*abs(zE-zS);
                         zS1:=zS1-dopusk1*abs(zE-zS);
                      end
                      else
                      begin
                         zE1:=zE1+dopusk2*abs(zE-zS);
                         zS1:=zS1-dopusk2*abs(zE-zS);
                      end;

                      //  GL_LINE_LOOP
                      if (binvisible_face_detect(0.0,0.0,1.0)) then
                      begin
                         glBegin(GL_LINE_LOOP);
                           glVertex3f(xE1, yE1, zE1);
                           glVertex3f(xS1, yE1, zE1);
                           glVertex3f(xS1, yS1, zE1);
                           glVertex3f(xE1, yS1, zE1);
                         glEnd;
                      end;

                      if (binvisible_face_detect(0.0,0.0,-1.0)) then
                      begin
                         glBegin(GL_LINE_LOOP);
                           glVertex3f(xE1, yE1, zS1);
                           glVertex3f(xE1, yS1, zS1);
                           glVertex3f(xS1, yS1, zS1);
                           glVertex3f(xS1, yE1, zS1);
                         glEnd;
                      end;

                      if (binvisible_face_detect(-1.0,0.0,0.0)) then
                      begin
                         glBegin(GL_LINE_LOOP);
                           glVertex3f(xS1, yE1, zE1);
                           glVertex3f(xS1, yE1, zS1);
                           glVertex3f(xS1, yS1, zS1);
                           glVertex3f(xS1, yS1, zE1);
                         glEnd;
                      end;

                      if (binvisible_face_detect(1.0,0.0,0.0)) then
                      begin
                         glBegin(GL_LINE_LOOP);
                           glVertex3f(xE1, yE1, zE1);
                           glVertex3f(xE1, yS1, zE1);
                           glVertex3f(xE1, yS1, zS1);
                           glVertex3f(xE1, yE1, zS1);
                         glEnd;
                      end;

                      if (binvisible_face_detect(0.0,1.0,0.0)) then
                      begin
                         glBegin(GL_LINE_LOOP);
                           glVertex3f(xS1, yE1, zS1);
                           glVertex3f(xS1, yE1, zE1);
                           glVertex3f(xE1, yE1, zE1);
                           glVertex3f(xE1, yE1, zS1);
                         glEnd;
                      end;

                      if (binvisible_face_detect(0.0,-1.0,0.0)) then
                      begin
                         glBegin(GL_LINE_LOOP);
                           glVertex3f(xS1, yS1, zS1);
                           glVertex3f(xE1, yS1, zS1);
                           glVertex3f(xE1, yS1, zE1);
                           glVertex3f(xS1, yS1, zE1);
                         glEnd;
                      end;


                         glPopMatrix();

                   end
                    else
                   begin
                      // Prism HOLLOW
                      //  GL_LINE_LOOP

                      // рисуем на dopusk меньший объём.
                      if ((abs(xE-xS)>=abs(yE-yS))and(abs(xE-xS)>=abs(zE-zS))) then
                      begin
                         xE1:=xE1-dopusk1*abs(xE-xS);
                         xS1:=xS1+dopusk1*abs(xE-xS);
                      end
                      else
                      begin
                         xE1:=xE1-dopusk2*abs(xE-xS);
                         xS1:=xS1+dopusk2*abs(xE-xS);
                      end;
                      if ((abs(yE-yS)>=abs(xE-xS))and(abs(yE-yS)>=abs(zE-zS))) then
                      begin
                         yE1:=yE1-dopusk1*abs(yE-yS);
                         yS1:=yS1+dopusk1*abs(yE-yS);
                      end
                      else
                      begin
                         yE1:=yE1-dopusk2*abs(yE-yS);
                         yS1:=yS1+dopusk2*abs(yE-yS);
                      end;
                      if ((abs(zE-zS)>=abs(xE-xS))and(abs(zE-zS)>=abs(yE-yS))) then
                      begin
                         zE1:=zE1-dopusk1*abs(zE-zS);
                         zS1:=zS1+dopusk1*abs(zE-zS);
                      end
                      else
                      begin
                         zE1:=zE1-dopusk2*abs(zE-zS);
                         zS1:=zS1+dopusk2*abs(zE-zS);
                      end;


                      glBegin(GL_LINE_LOOP);
                        glVertex3f(xE1, yE1, zE1);
                        glVertex3f(xS1, yE1, zE1);
                        glVertex3f(xS1, yS1, zE1);
                        glVertex3f(xE1, yS1, zE1);
                      glEnd;

                      glBegin(GL_LINE_LOOP);
                        glVertex3f(xE1, yE1, zS1);
                        glVertex3f(xE1, yS1, zS1);
                        glVertex3f(xS1, yS1, zS1);
                        glVertex3f(xS1, yE1, zS1);
                      glEnd;

                      glBegin(GL_LINE_LOOP);
                        glVertex3f(xS1, yE1, zE1);
                        glVertex3f(xS1, yE1, zS1);
                        glVertex3f(xS1, yS1, zS1);
                        glVertex3f(xS1, yS1, zE1);
                      glEnd;

                      glBegin(GL_LINE_LOOP);
                        glVertex3f(xE1, yE1, zE1);
                        glVertex3f(xE1, yS1, zE1);
                        glVertex3f(xE1, yS1, zS1);
                        glVertex3f(xE1, yE1, zS1);
                      glEnd;

                      glBegin(GL_LINE_LOOP);
                        glVertex3f(xS1, yE1, zS1);
                        glVertex3f(xS1, yE1, zE1);
                        glVertex3f(xE1, yE1, zE1);
                        glVertex3f(xE1, yE1, zS1);
                      glEnd;

                      glBegin(GL_LINE_LOOP);
                        glVertex3f(xS1, yS1, zS1);
                        glVertex3f(xE1, yS1, zS1);
                        glVertex3f(xE1, yS1, zE1);
                        glVertex3f(xS1, yS1, zE1);
                      glEnd;


                      glPopMatrix();

                   end;
                end;

                glLineWidth(body[j].BodyLineWidth);
             end;
            end;
           end;
        end;
     end;
    (*
       for j:=Length(vg)-1 downto 0 do
     begin

        with (vg[j]) do
        begin

           // сначала прорисовываем непрозрачные объекты.
           // if (transparency>0.95) then
           begin
              glpushMatrix;
	            //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
              glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
              glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
              //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
              //  glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
              //--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
              // Вращательное движение в 3D имеет три степени свободы.
              glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
              glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
              glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
              glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
              glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));


              glLineWidth(4.0);
              glColor3f(0,0,0);  // Чёрные линии.

              // if (start_on) then
              //begin
                 // xS, yS, zS
                // case iPlane of
                 // 1 : begin

                         // XY zS
                         // *** zS ***
                         if (zS_yE2yS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*median_size, yE+dopusk*median_size, zS-dopusk*median_size);
                              glVertex3f(xE+dopusk*median_size, yS-dopusk*median_size, zS-dopusk*median_size);
                            glEnd;
                         end;

                         if (zS_xE2xS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*median_size, yS-dopusk*median_size, zS-dopusk*median_size);
                               glVertex3f(xS-dopusk*median_size, yS-dopusk*median_size, zS-dopusk*median_size);
                            glEnd;
                         end;

                         if (zS_yS2yE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xS-dopusk*median_size, yS-dopusk*median_size, zS-dopusk*median_size);
                               glVertex3f(xS-dopusk*median_size, yE+dopusk*median_size, zS-dopusk*median_size);
                            glEnd;
                         end;

                         if (zS_xS2xE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xS-dopusk*median_size, yE+dopusk*median_size, zS-dopusk*median_size);
                               glVertex3f(xE+dopusk*median_size, yE+dopusk*median_size, zS-dopusk*median_size);
                            glEnd;
                         end;
                    //  end;
                 // 2 : begin
                         // XZ yS

                          // *** yS ***

                          if (yS_xS2xE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*median_size, yS-dopusk*median_size, zS-dopusk*median_size);
                                glVertex3f(xE+dopusk*median_size, yS-dopusk*median_size, zS-dopusk*median_size);
                             glEnd;
                          end;

                          if (yS_zS2zE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*median_size, yS-dopusk*median_size, zS-dopusk*median_size);
                               glVertex3f(xE+dopusk*median_size, yS-dopusk*median_size, zE+dopusk*median_size);
                             glEnd;
                          end;

                          if (yS_xE2xS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*median_size, yS-dopusk*median_size, zE+dopusk*median_size);
                               glVertex3f(xS-dopusk*median_size, yS-dopusk*median_size, zE+dopusk*median_size);
                             glEnd;
                          end;

                          if (yS_zE2zS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*median_size, yS-dopusk*median_size, zE+dopusk*median_size);
                                glVertex3f(xS-dopusk*median_size, yS-dopusk*median_size, zS-dopusk*median_size);
                             glEnd;
                          end;

                     // end;
                 // 3 : begin
                         // YZ xS

                          // *** xS ***



                          if (xS_zE2zS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                               glVertex3f(xS-dopusk*median_size, yE+dopusk*median_size, zE+dopusk*median_size);
                               glVertex3f(xS-dopusk*median_size, yE+dopusk*median_size, zS-dopusk*median_size);
                             glEnd;
                          end;

                          if (xS_yE2yS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*median_size, yE+dopusk*median_size, zS-dopusk*median_size);
                                glVertex3f(xS-dopusk*median_size, yS-dopusk*median_size, zS-dopusk*median_size);
                             glEnd;
                          end;

                          if (xS_zS2zE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*median_size, yS-dopusk*median_size, zS-dopusk*median_size);
                                glVertex3f(xS-dopusk*median_size, yS-dopusk*median_size, zE+dopusk*median_size);
                             glEnd;
                          end;

                          if (xS_yS2yE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*median_size, yS-dopusk*median_size, zE+dopusk*median_size);
                                glVertex3f(xS-dopusk*median_size, yE+dopusk*median_size, zE+dopusk*median_size);
                             glEnd;
                          end;


                     // end;
                 //end;
             // end
             // else
             // begin
                 // xE, yE, zE
                // case iPlane of
                //  1 : begin
                         // XY zE

                         // *** zE ***
                         if (zE_xE2xS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*median_size, yE+dopusk*median_size, zE+dopusk*median_size);
                              glVertex3f(xS-dopusk*median_size, yE+dopusk*median_size, zE+dopusk*median_size);
                            glEnd;
                         end;

                         if (zE_yE2yS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xS-dopusk*median_size, yE+dopusk*median_size, zE+dopusk*median_size);
                              glVertex3f(xS-dopusk*median_size, yS-dopusk*median_size, zE+dopusk*median_size);
                            glEnd;
                         end;

                         if (zE_xS2xE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xS-dopusk*median_size, yS-dopusk*median_size, zE+dopusk*median_size);
                               glVertex3f(xE+dopusk*median_size, yS-dopusk*median_size, zE+dopusk*median_size);
                            glEnd;
                         end;

                         if (zE_yS2yE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*median_size, yS-dopusk*median_size, zE+dopusk*median_size);
                               glVertex3f(xE+dopusk*median_size, yE+dopusk*median_size, zE+dopusk*median_size);
                            glEnd;
                         end;

                    //  end;
                  //2 : begin
                         // XZ yE

                         // *** yE ***

                         if (yE_zS2zE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xS-dopusk*median_size, yE+dopusk*median_size, zS-dopusk*median_size);
                              glVertex3f(xS-dopusk*median_size, yE+dopusk*median_size, zE+dopusk*median_size);
                            glEnd;
                         end;

                         if (yE_xS2xE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xS-dopusk*median_size, yE+dopusk*median_size, zE+dopusk*median_size);
                              glVertex3f(xE+dopusk*median_size, yE+dopusk*median_size, zE+dopusk*median_size);
                            glEnd;
                         end;

                         if (yE_zE2zS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*median_size, yE+dopusk*median_size, zE+dopusk*median_size);
                               glVertex3f(xE+dopusk*median_size, yE+dopusk*median_size, zS-dopusk*median_size);
                            glEnd;
                         end;

                         if (yE_xE2xS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*median_size, yE+dopusk*median_size, zS-dopusk*median_size);
                               glVertex3f(xS-dopusk*median_size, yE+dopusk*median_size, zS-dopusk*median_size);
                            glEnd;
                         end;
                     // end;
                 // 3 : begin
                         // YZ xE

                         // *** xE ***

                         if (xE_zE2zS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*median_size, yE+dopusk*median_size, zE+dopusk*median_size);
                              glVertex3f(xE+dopusk*median_size, yE+dopusk*median_size, zS-dopusk*median_size);
                            glEnd;
                         end;

                         if (xE_yE2yS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*median_size, yE+dopusk*median_size, zS-dopusk*median_size);
                              glVertex3f(xE+dopusk*median_size, yS-dopusk*median_size, zS-dopusk*median_size);
                            glEnd;
                         end;

                         if (xE_zS2zE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*median_size, yS-dopusk*median_size, zS-dopusk*median_size);
                               glVertex3f(xE+dopusk*median_size, yS-dopusk*median_size, zE+dopusk*median_size);
                            glEnd;
                         end;

                         if (xE_yS2yE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*median_size, yS-dopusk*median_size, zE+dopusk*median_size);
                              glVertex3f(xE+dopusk*median_size, yE+dopusk*median_size, zE+dopusk*median_size);
                            glEnd;
                         end;

                     // end;
                // end;
              //end;

              // Для прорисовки контуров отверстий.
             // if (start_on) then
             // begin
                 // xS, yS, zS
               //  case iPlane of
                 // 1 : begin
                         // XY zS
                          // *** zS ***
                         if (zS_yE2yS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE-dopusk*median_size, yE-dopusk*median_size, zS-dopusk*median_size);
                              glVertex3f(xE-dopusk*median_size, yS+dopusk*median_size, zS-dopusk*median_size);
                            glEnd;
                         end;

                         if (zS_xE2xS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE-dopusk*median_size, yS+dopusk*median_size, zS-dopusk*median_size);
                               glVertex3f(xS+dopusk*median_size, yS+dopusk*median_size, zS-dopusk*median_size);
                            glEnd;
                         end;

                         if (zS_yS2yE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xS+dopusk*median_size, yS+dopusk*median_size, zS-dopusk*median_size);
                               glVertex3f(xS+dopusk*median_size, yE-dopusk*median_size, zS-dopusk*median_size);
                            glEnd;
                         end;

                         if (zS_xS2xE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xS+dopusk*median_size, yE-dopusk*median_size, zS-dopusk*median_size);
                               glVertex3f(xE-dopusk*median_size, yE-dopusk*median_size, zS-dopusk*median_size);
                            glEnd;
                         end;
                     // end;
                  //2 : begin
                         // XZ yS

                          // *** yS ***

                          if (yS_xS2xE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS+dopusk*median_size, yS-dopusk*median_size, zS+dopusk*median_size);
                                glVertex3f(xE-dopusk*median_size, yS-dopusk*median_size, zS+dopusk*median_size);
                             glEnd;
                          end;

                          if (yS_zS2zE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                               glVertex3f(xE-dopusk*median_size, yS-dopusk*median_size, zS+dopusk*median_size);
                               glVertex3f(xE-dopusk*median_size, yS-dopusk*median_size, zE-dopusk*median_size);
                             glEnd;
                          end;

                          if (yS_xE2xS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                               glVertex3f(xE-dopusk*median_size, yS-dopusk*median_size, zE-dopusk*median_size);
                               glVertex3f(xS+dopusk*median_size, yS-dopusk*median_size, zE-dopusk*median_size);
                             glEnd;
                          end;

                          if (yS_zE2zS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS+dopusk*median_size, yS-dopusk*median_size, zE-dopusk*median_size);
                                glVertex3f(xS+dopusk*median_size, yS-dopusk*median_size, zS+dopusk*median_size);
                             glEnd;
                          end;

                    //  end;
                 // 3 : begin
                         // YZ xS

                          // *** xS ***



                          if (xS_zE2zS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                               glVertex3f(xS-dopusk*median_size, yE-dopusk*median_size, zE-dopusk*median_size);
                               glVertex3f(xS-dopusk*median_size, yE-dopusk*median_size, zS+dopusk*median_size);
                             glEnd;
                          end;

                          if (xS_yE2yS) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*median_size, yE-dopusk*median_size, zS+dopusk*median_size);
                                glVertex3f(xS-dopusk*median_size, yS+dopusk*median_size, zS+dopusk*median_size);
                             glEnd;
                          end;

                          if (xS_zS2zE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*median_size, yS+dopusk*median_size, zS+dopusk*median_size);
                                glVertex3f(xS-dopusk*median_size, yS+dopusk*median_size, zE-dopusk*median_size);
                             glEnd;
                          end;

                          if (xS_yS2yE) then
                          begin
                             glBegin(GL_LINE_LOOP);
                                glVertex3f(xS-dopusk*median_size, yS+dopusk*median_size, zE-dopusk*median_size);
                                glVertex3f(xS-dopusk*median_size, yE-dopusk*median_size, zE-dopusk*median_size);
                             glEnd;
                          end;


                   //   end;
                // end;
             // end
             // else
            //  begin
                 // xE, yE, zE
               //  case iPlane of
               //   1 : begin
                         // XY zE

                         // *** zE ***
                         if (zE_xE2xS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE-dopusk*median_size, yE-dopusk*median_size, zE+dopusk*median_size);
                              glVertex3f(xS+dopusk*median_size, yE-dopusk*median_size, zE+dopusk*median_size);
                            glEnd;
                         end;

                         if (zE_yE2yS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xS+dopusk*median_size, yE-dopusk*median_size, zE+dopusk*median_size);
                              glVertex3f(xS+dopusk*median_size, yS+dopusk*median_size, zE+dopusk*median_size);
                            glEnd;
                         end;

                         if (zE_xS2xE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xS+dopusk*median_size, yS+dopusk*median_size, zE+dopusk*median_size);
                               glVertex3f(xE-dopusk*median_size, yS+dopusk*median_size, zE+dopusk*median_size);
                            glEnd;
                         end;

                         if (zE_yS2yE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE-dopusk*median_size, yS+dopusk*median_size, zE+dopusk*median_size);
                               glVertex3f(xE-dopusk*median_size, yE-dopusk*median_size, zE+dopusk*median_size);
                            glEnd;
                         end;

                  //    end;
                 // 2 : begin
                         // XZ yE

                         // *** yE ***

                         if (yE_zS2zE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xS+dopusk*median_size, yE+dopusk*median_size, zS+dopusk*median_size);
                              glVertex3f(xS+dopusk*median_size, yE+dopusk*median_size, zE-dopusk*median_size);
                            glEnd;
                         end;

                         if (yE_xS2xE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xS+dopusk*median_size, yE+dopusk*median_size, zE-dopusk*median_size);
                              glVertex3f(xE-dopusk*median_size, yE+dopusk*median_size, zE-dopusk*median_size);
                            glEnd;
                         end;

                         if (yE_zE2zS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE-dopusk*median_size, yE+dopusk*median_size, zE-dopusk*median_size);
                               glVertex3f(xE-dopusk*median_size, yE+dopusk*median_size, zS+dopusk*median_size);
                            glEnd;
                         end;

                         if (yE_xE2xS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE-dopusk*median_size, yE+dopusk*median_size, zS+dopusk*median_size);
                               glVertex3f(xS+dopusk*median_size, yE+dopusk*median_size, zS+dopusk*median_size);
                            glEnd;
                         end;
                   //   end;
                 // 3 : begin
                         // YZ xE

                         // *** xE ***

                         if (xE_zE2zS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*median_size, yE-dopusk*median_size, zE-dopusk*median_size);
                              glVertex3f(xE+dopusk*median_size, yE-dopusk*median_size, zS+dopusk*median_size);
                            glEnd;
                         end;

                         if (xE_yE2yS) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*median_size, yE-dopusk*median_size, zS+dopusk*median_size);
                              glVertex3f(xE+dopusk*median_size, yS+dopusk*median_size, zS+dopusk*median_size);
                            glEnd;
                         end;

                         if (xE_zS2zE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                               glVertex3f(xE+dopusk*median_size, yS+dopusk*median_size, zS+dopusk*median_size);
                               glVertex3f(xE+dopusk*median_size, yS+dopusk*median_size, zE-dopusk*median_size);
                            glEnd;
                         end;

                         if (xE_yS2yE) then
                         begin
                            glBegin(GL_LINE_LOOP);
                              glVertex3f(xE+dopusk*median_size, yS+dopusk*median_size, zE-dopusk*median_size);
                              glVertex3f(xE+dopusk*median_size, yE-dopusk*median_size, zE-dopusk*median_size);
                            glEnd;
                         end;

                    //  end;
                // end;
             // end;

              glLineWidth(1.0);
              //glDisable(GL_CULL_FACE);
              glColor3f(1,1,1);  // Цвет фона белый.
              glPopmatrix;
           end;

        end;
     end;
     *)

  end;
  2 : // Режим заливки с освещением и с прозрачностью.
   begin


     // также должен работать режим прозрачности при его активации.
     (*
     for j:=Length(blockgraphics)-1 downto 0 do
     begin
        with (blockgraphics[j]) do
        begin
           // расстояние от камеры до центра объета.
           key:=Sqrt(Sqr(Oxc+R1*cos(Bet)*cos(Alf)-0.5*(xS+xE))+sqr(Oyc+R1*cos(Bet)*sin(Alf)-0.5*(yS+yE))+sqr(Ozc+R1*sin(Bet)-0.5*(zS+zE)));
        end;
     end;


     //BubbleSort; // сортировка по возрастанию удалённости от камеры.
     QuickSort(0,Length(blockgraphics)-1); // быстрая сортировка.


     for j:=Length(blockgraphics)-1 downto 0 do
     begin
        with (blockgraphics[j]) do
        begin
           glpushMatrix;
	         glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));

           // С заливкой
	         DrawSolidBody(xS,xE,yS,yE,zS,zE,redcolor,greencolor,bluecolor,transparency);  // Параллелепипед.

           glPopmatrix;
        end;
     end;
       *)

     (*
     // Обработка граней.
     for j:=Length(vg)-1 downto 0 do
     begin
        with (vg[j]) do
        begin
           // расстояние от камеры до центра объета.
           key:=Sqrt(Sqr(Oxc+R1*cos(Bet)*cos(Alf)-xc)+sqr(Oyc+R1*cos(Bet)*sin(Alf)-yc)+sqr(Ozc+R1*sin(Bet)-zc));
        end;
     end;
     *)

      // сортировка по возрастанию удалённости от камеры.
      // сортировку делать нельзя т.к. с ней время рендеринга возрастает недопустимо.
     //QuickSort2(0,Length(blockgraphics)-1); // быстрая сортировка.

     (*// закоментировано 23,05,2020
     rdivision:=3.0;//20.0;
     idivision:=round(rdivision);

     for j:=Length(vg)-1 downto 0 do
     begin

        with (vg[j]) do
        begin

           // сначала прорисовываем непрозрачные объекты.
           if (transparency>0.95) then
           begin
              if (chksmooter.Checked=true) then
              begin


                 case iPlane of
                   1 : // XY
                      begin
                         hx:=(abs(xE-xS))/rdivision;
                         hy:=(abs(yE-yS))/rdivision;
                         for ihx:=1 to idivision do
                         begin
                            for ihy:=1 to idivision do
                            begin
                               glpushMatrix;
	                             //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                               glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                               glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                               //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                               //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                               //---->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                               // Вращательное движение в 3D имеет три степени свободы.
                               glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                               glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                               glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                               glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                               glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                               // С заливкой
	                             DrawSolidGran(iPlane,xc,yc,zc, xS+(ihx-1)*hx,xS+ihx*hx,yS+(ihy-1)*hy,yS+ihy*hy,zS,zE,redcolor,greencolor,bluecolor,1.0);  // Параллелепипед.
                               glPopmatrix;
                            end;
                         end;
                      end;
                   2 : // XZ
                      begin
                         hx:=(abs(xE-xS))/rdivision;
                         hy:=(abs(zE-zS))/rdivision;
                         for ihx:=1 to idivision do
                         begin
                            for ihy:=1 to idivision do
                            begin
                               glpushMatrix;
	                             //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                               glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                               glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                               //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                               //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                               //--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                               // Вращательное движение в 3D имеет три степени свободы.
                               glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                               glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                               glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                               glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                               glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                               // С заливкой
	                             DrawSolidGran(iPlane,xc,yc,zc, xS+(ihx-1)*hx,xS+ihx*hx,yS,yE,zS+(ihy-1)*hy,zS+ihy*hy,redcolor,greencolor,bluecolor,1.0);  // Параллелепипед.
                               glColor3f(1,1,1);  // Цвет фона белый.
                               glPopmatrix;
                            end;
                         end;
                      end;
                   3 : // YZ
                      begin
                         hx:=(abs(yE-yS))/rdivision;
                         hy:=(abs(zE-zS))/rdivision;
                         for ihx:=1 to idivision do
                         begin
                            for ihy:=1 to idivision do
                            begin
                               glpushMatrix;
	                             //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                               glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                               glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                               //---->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                               //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                               //---->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                               // Вращательное движение в 3D имеет три степени свободы.
                               glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                               glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                               glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                               glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                               glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                               // С заливкой
	                             DrawSolidGran(iPlane, xc,yc,zc, xS,xE, yS+(ihx-1)*hx,yS+ihx*hx, zS+(ihy-1)*hy,zS+ihy*hy,redcolor,greencolor,bluecolor,1.0);  // Параллелепипед.
                               glColor3f(1,1,1);  // Цвет фона белый.
                               glPopmatrix;
                            end;
                         end;
                      end;
                 end;
              end
              else
              begin
                 glpushMatrix;
	               //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                 glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                 glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                 //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                 //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                 //--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                 // Вращательное движение в 3D имеет три степени свободы.
                 glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                 glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                 glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                 glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                 glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                 // С заливкой
	               DrawSolidGran(iPlane,xc,yc,zc, xS,xE,yS,yE,zS,zE,redcolor,greencolor,bluecolor,1.0);  // Параллелепипед.
                glColor3f(1,1,1);  // Цвет фона белый.
                 glPopmatrix;

              end;
           end;

        end;
     end;

     *)
     // теперь рисуем только прозрачные объекты отсортированные по глубине.
     (*  // закоментировано 23,05,2020
     // включаем смешивание.
     glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);

     // устанавливаем запрет на изменение значений в буфере глубины.
     glDepthMask(false);

     // рисуем истинно прозрачные объекты.
     for j:=Length(vg)-1 downto 0 do
     begin

        with (vg[j]) do
        begin
           if (transparency<0.95) then
           begin
              if (chksmooter.Checked=true) then
                 begin


                    case iPlane of
                       1 : // XY
                           begin
                              hx:=(abs(xE-xS))/rdivision;
                              hy:=(abs(yE-yS))/rdivision;
                              for ihx:=1 to idivision do
                              begin
                                 for ihy:=1 to idivision do
                                 begin
                                    glpushMatrix;
	                                  //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                                    glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                                    glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                                    //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                                    //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                                    //--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                                    // Вращательное движение в 3D имеет три степени свободы.
                                    glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                                    glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                                    glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                                    glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                                    glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                                    // С заливкой
	                                  DrawSolidGran(iPlane,xc,yc,zc, xS+(ihx-1)*hx,xS+ihx*hx,yS+(ihy-1)*hy,yS+ihy*hy,zS,zE,redcolor,greencolor,bluecolor,1.0);  // Параллелепипед.
                                    glColor3f(1,1,1);  // Цвет фона белый.
                                    glPopmatrix;
                                 end;
                              end;
                           end;
                       2 : // XZ
                           begin
                              hx:=(abs(xE-xS))/rdivision;
                              hy:=(abs(zE-zS))/rdivision;
                              for ihx:=1 to idivision do
                              begin
                                 for ihy:=1 to idivision do
                                 begin
                                    glpushMatrix;
	                                  //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                                    glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                                    glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                                    //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                                    //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                                    //--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                                    // Вращательное движение в 3D имеет три степени свободы.
                                    glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                                    glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                                    glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                                    glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                                    glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                                    // С заливкой
	                                  DrawSolidGran(iPlane,xc,yc,zc, xS+(ihx-1)*hx,xS+ihx*hx,yS,yE,zS+(ihy-1)*hy,zS+ihy*hy,redcolor,greencolor,bluecolor,1.0);  // Параллелепипед.
                                    glColor3f(1,1,1);  // Цвет фона белый.
                                    glPopmatrix;
                                 end;
                              end;
                           end;
                       3 : // YZ
                           begin
                              hx:=(abs(yE-yS))/rdivision;
                              hy:=(abs(zE-zS))/rdivision;
                              for ihx:=1 to idivision do
                              begin
                                 for ihy:=1 to idivision do
                                 begin
                                    glpushMatrix;
	                                  //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                                    glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                                    glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                                    //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                                    //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                                    //--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                                    // Вращательное движение в 3D имеет три степени свободы.
                                    glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                                    glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                                    glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                                    glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                                    glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                                    // С заливкой
	                                  DrawSolidGran(iPlane, xc,yc,zc, xS,xE, yS+(ihx-1)*hx,yS+ihx*hx, zS+(ihy-1)*hy,zS+ihy*hy,redcolor,greencolor,bluecolor,1.0);  // Параллелепипед.
                                    glColor3f(1,1,1);  // Цвет фона белый.
                                    glPopmatrix;
                                 end;
                              end;
                           end;
                    end;
                 end
                 else
                 begin
                    glpushMatrix;
	                  //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
                    glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
                    glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
                    //-->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
                    // glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
                    //-->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
                    // Вращательное движение в 3D имеет три степени свободы.
                    glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
                    glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
                    glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
                    glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
                    glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));

                    // С заливкой
	                  DrawSolidGran(iPlane,xc,yc,zc, xS,xE,yS,yE,zS,zE,redcolor,greencolor,bluecolor,transparency);  // Параллелепипед.
                    glColor3f(1,1,1);  // Цвет фона белый.
                    glPopmatrix;
              end;
           end;
        end;
     end;

     // Снимаем запреты:
     glDepthMask(true);
     // выключаем смешивание :
     glDisable(GL_BLEND);
     *)

     // Делаем всего один раз вне цикла!!!!.

     glpushMatrix;
     //glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
     //glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
     //glTranslatef(0.5*(Laplas.body[0].xS+Laplas.body[0].xE),0.5*(Laplas.body[0].yS+Laplas.body[0].yE),0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
       glTranslatef(0,0,-Hscale*sqrt(sqr(zmaxpic-zminpic)+sqr(ymaxpic-yminpic)+sqr(xmaxpic-xminpic)));
       glTranslatef(0.5*(xminpic+xmaxpic),0.5*(yminpic+ymaxpic),0.5*(zminpic+zmaxpic));

     //-->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
     //glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
     //--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
     // Вращательное движение в 3D имеет три степени свободы.
     //glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
     glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
     glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
     //glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
     //glTranslatef(-0.5*(Laplas.body[0].xS+Laplas.body[0].xE),-0.5*(Laplas.body[0].yS+Laplas.body[0].yE),-0.5*(Laplas.body[0].zS+Laplas.body[0].zE));
     glTranslatef(-0.5*(xminpic+xmaxpic),-0.5*(yminpic+ymaxpic),-0.5*(zminpic+zmaxpic));

     //glLineWidth(ComboBoxlineWidth.ItemIndex+1);
     glLineWidth(3);
     //glLineWidth(1);

      for j:=0 to epic-1 do
      begin
              //todo***

            case cbbview.ItemIndex of
             0 : // all
             begin
                // 23.05.2020  только внешние грани!!!

                // Нельзя рисовать все грани подряд. Это чрезмерная
                // нагрузка на движок OpenGL.
                // Надо Отобрать только внешние грани составляющие
                // модель и рисовать только их.
                // TODO код изъят 06.09.2019.





                //glColor3f(0.0,0.0,0.0);

                 // All
               if (bvisible_granq[6][j]) then
               begin


                      // XY bottom
                  if (bvisible_granq[4][j]) then
                  begin

                     if (binvisible_face_detectq(0.0,0.0,-1.0)) then
                     begin

                    //glColor3f(0.84,0.84,0.84);



                        glBegin(GL_QUADS);
                           glColor3f(1.0,1.0,1.0);
                           glNormal3f(0.0,0.0,-1.0);
                           glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                           //glColor3f(1.0,1.0,1.0);
                           glNormal3f(0.0,0.0,-1.0);
                           glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                           //glColor3f(1.0,1.0,1.0);
                           glNormal3f(0.0,0.0,-1.0);
                           glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                           //glColor3f(1.0,1.0,1.0);
                           glNormal3f(0.0,0.0,-1.0);
                           glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                           glColor3f(0.0,0.0,0.0);
                         glEnd();


                           //glLineWidth(ComboBoxlineWidth.ItemIndex+1);


                            if (CheckLine(ipa_count[elmpic[j].i1-1],
                                ipa_count[elmpic[j].i2-1])
                                ) then
                            begin
                              glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                              glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i3-1],
                                ipa_count[elmpic[j].i2-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                               glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i3-1],
                                ipa_count[elmpic[j].i4-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                               glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i1-1],
                                ipa_count[elmpic[j].i4-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                               glEnd();
                            end;

                            //glLineWidth(1);
                            glColor3f(1.0,1.0,1.0);
                            //glLineWidth(1);

                    end;
                  end;


                     // XY Top
                    if (bvisible_granq[5][j]) then
                    begin

                    if (binvisible_face_detectq(0.0,0.0,1.0)) then
                    begin

                    //glColor3f(0.84,0.84,0.84);


                         glBegin(GL_QUADS);
                           glColor3f(1.0,1.0,1.0);
                            glNormal3f(0.0,0.0,1.0);
                                      glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                                      //glColor3f(1.0,1.0,1.0);
                             glNormal3f(0.0,0.0,1.0);
                                      glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                                     //glColor3f(1.0,1.0,1.0);
                             glNormal3f(0.0,0.0,1.0);
                                      glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                                      //glColor3f(1.0,1.0,1.0);
                             glNormal3f(0.0,0.0,1.0);
                                      glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                                      glColor3f(0.0,0.0,0.0);
                                  glEnd();


                      ///glLineWidth(ComboBoxlineWidth.ItemIndex+1);


                            if (CheckLine(ipa_count[elmpic[j].i5-1],
                                ipa_count[elmpic[j].i6-1])
                                ) then
                            begin
                              glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                              glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i6-1],
                                ipa_count[elmpic[j].i7-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                               glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i7-1],
                                ipa_count[elmpic[j].i8-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                               glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i5-1],
                                ipa_count[elmpic[j].i8-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                               glEnd();
                            end;

                           // glLineWidth(1);
                           glColor3f(1.0,1.0,1.0);
                           //glLineWidth(1);

                    end;
                  end;


                  // XZ SSIDE min Y
                 if (bvisible_granq[2][j]) then
                 begin

                     if (binvisible_face_detectq(0.0,-1.0,0.0)) then
                     begin

                    //glColor3f(0.84,0.84,0.84);

                                glBegin(GL_QUADS);
                                   glColor3f(1.0,1.0,1.0);
                                  glNormal3f(0.0,-1.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                                  //glColor3f(1.0,1.0,1.0);
                                  glNormal3f(0.0,-1.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                                  //glColor3f(1.0,1.0,1.0);
                                  glNormal3f(0.0,-1.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                                  //glColor3f(1.0,1.0,1.0);
                                  glNormal3f(0.0,-1.0,0.0);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                                  glColor3f(0.0,0.0,0.0);
                               glEnd();


                          //glLineWidth(ComboBoxlineWidth.ItemIndex+1);


                          if (CheckLine(ipa_count[elmpic[j].i1-1],
                                ipa_count[elmpic[j].i2-1])
                                ) then
                            begin
                              glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                              glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i2-1],
                                ipa_count[elmpic[j].i6-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                               glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i6-1],
                                ipa_count[elmpic[j].i5-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                               glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i1-1],
                                ipa_count[elmpic[j].i5-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                               glEnd();
                            end;

                             //glLineWidth(1);
                             glColor3f(1.0,1.0,1.0);
                             //glLineWidth(1);
                    end;
                  end;


                 // XZ SSIDE max Y
                 if (bvisible_granq[3][j]) then
                 begin

                    if (binvisible_face_detectq(0.0,1.0,0.0)) then
                    begin

                    //glColor3f(0.84,0.84,0.84);

                      glBegin(GL_QUADS);
                      glColor3f(1.0,1.0,1.0);
                      glNormal3f(0.0,1.0,0.0);
                                   glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                                 // glColor3f(1.0,1.0,1.0);
                      glNormal3f(0.0,1.0,0.0);
                                   glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                                  //glColor3f(1.0,1.0,1.0);
                       glNormal3f(0.0,1.0,0.0);
                                   glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                                  //glColor3f(1.0,1.0,1.0);
                       glNormal3f(0.0,1.0,0.0);
                                   glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                                    glColor3f(0.0,0.0,0.0);
                                glEnd();


                           //glLineWidth(ComboBoxlineWidth.ItemIndex+1);


                          if (CheckLine(ipa_count[elmpic[j].i3-1],
                                ipa_count[elmpic[j].i4-1])
                                ) then
                            begin
                              glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                              glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i3-1],
                                ipa_count[elmpic[j].i7-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                               glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i7-1],
                                ipa_count[elmpic[j].i8-1])
                                )then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                               glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i8-1],
                                ipa_count[elmpic[j].i4-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                               glEnd();
                            end;

                          // glLineWidth(1);
                          glColor3f(1.0,1.0,1.0);
                         // glLineWidth(1);
                    end;
                  end;


                   // YZ SSIDE max X
                 if (bvisible_granq[0][j]) then
                 begin

                    if (binvisible_face_detectq(1.0,0.0,0.0)) then
                    begin

                    //glColor3f(0.84,0.84,0.84);


                    glBegin(GL_QUADS);
                                 glColor3f(1.0,1.0,1.0);
                    glNormal3f(1.0,0.0,0.0);
                                 glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                                //glColor3f(1.0,1.0,1.0);
                    glNormal3f(1.0,0.0,0.0);
                                 glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                                 //glColor3f(1.0,1.0,1.0);
                    glNormal3f(1.0,0.0,0.0);
                                 glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                                 //glColor3f(1.0,1.0,1.0);
                    glNormal3f(1.0,0.0,0.0);
                                 glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                              glColor3f(0.0,0.0,0.0);
                               glEnd();


                          //glLineWidth(ComboBoxlineWidth.ItemIndex+1);


                          if (CheckLine(ipa_count[elmpic[j].i3-1],
                                ipa_count[elmpic[j].i2-1])
                                ) then
                            begin
                              glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                              glEnd();
                            end;

                            if(CheckLine(ipa_count[elmpic[j].i3-1],
                                ipa_count[elmpic[j].i7-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i3-1], ypic[elmpic[j].i3-1], zpic[elmpic[j].i3-1]);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                               glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i7-1],
                                ipa_count[elmpic[j].i6-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i7-1], ypic[elmpic[j].i7-1], zpic[elmpic[j].i7-1]);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                               glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i6-1],
                                ipa_count[elmpic[j].i2-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i6-1], ypic[elmpic[j].i6-1], zpic[elmpic[j].i6-1]);
                                  glVertex3f(xpic[elmpic[j].i2-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                               glEnd();
                            end;

                            //glLineWidth(1);
                            glColor3f(1.0,1.0,1.0);
                           // glLineWidth(1);

                    end;
                  end;


                  // YZ SSIDE min X
                 if (bvisible_granq[1][j]) then
                 begin

                     if (binvisible_face_detectq(-1.0,0.0,0.0)) then
                     begin

                           //glColor3f(0.84,0.84,0.84);


                           glBegin(GL_QUADS);
                               glColor3f(1.0,1.0,1.0);
                               glNormal3f(-1.0,0.0,0.0);
                               glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i2-1], zpic[elmpic[j].i2-1]);
                               //glColor3f(1.0,1.0,1.0);
                               glNormal3f(-1.0,0.0,0.0);
                               glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                               //glColor3f(1.0,1.0,1.0);
                               glNormal3f(-1.0,0.0,0.0);
                               glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                               //glColor3f(1.0,1.0,1.0);
                               glNormal3f(-1.0,0.0,0.0);
                               glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                               glColor3f(0.0,0.0,0.0);
                            glEnd();



                          //glLineWidth(ComboBoxlineWidth.ItemIndex+1);

                          if (CheckLine(ipa_count[elmpic[j].i1-1],
                                ipa_count[elmpic[j].i4-1])
                                ) then
                            begin
                              glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                              glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i4-1],
                                ipa_count[elmpic[j].i8-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i4-1], ypic[elmpic[j].i4-1], zpic[elmpic[j].i4-1]);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                               glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i5-1],
                                ipa_count[elmpic[j].i8-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i8-1], ypic[elmpic[j].i8-1], zpic[elmpic[j].i8-1]);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                               glEnd();
                            end;

                            if (CheckLine(ipa_count[elmpic[j].i1-1],
                                ipa_count[elmpic[j].i5-1])
                                ) then
                            begin
                                glBegin(GL_LINE_LOOP);
                                  glVertex3f(xpic[elmpic[j].i5-1], ypic[elmpic[j].i5-1], zpic[elmpic[j].i5-1]);
                                  glVertex3f(xpic[elmpic[j].i1-1], ypic[elmpic[j].i1-1], zpic[elmpic[j].i1-1]);
                               glEnd();
                            end;

                             //glLineWidth(1);
                             glColor3f(1.0,1.0,1.0);
                            // glLineWidth(1);
                    end;
                  end;

               end;


             end;
          end;
      end;

      glPopmatrix;

    end;
  end;

  (*
  for j:=1 to Laplas.lb-1 do
  begin
     with (Laplas.body[j]) do
     begin
        if ((bvisible) and (itype<>2)) then
        begin
            // Только не hollow block.

            glpushMatrix;
	          glTranslatef(0,0,-Hscale*(Laplas.body[0].zE-Laplas.body[0].zS));
            if (Laplas.chkfill.Checked) then
            begin
               // С заливкой
	             DrawSolidBody(xS,xE,yS,yE,zS,zE);  // Параллелепипед.
            end
            else
            begin
               // Простая каркасная модель.
               DrawWireBody(xS,xE,yS,yE,zS,zE);
            end;
            glPopmatrix;

        end;
     end;
  end;
  *)


  (*
  glpushMatrix;
	glTranslatef(-5,0,0);
	glutSolidCube(1);      //Куб
	glPopmatrix;

	glpushMatrix;
	glTranslatef(5,0,0);
	glutSolidSphere(2,20,20);  //Сфера
	glPopmatrix;

	glpushMatrix;
	glTranslatef(0,0,-20);
	glutSolidTorus(1,2,20,20);  //Тор
  glPopmatrix;



	glpushMatrix;
	glTranslatef(0,-5,0);
	glutSolidDodecahedron();   //Додекаэдр
	glPopmatrix;

	glpushMatrix;
	glTranslatef(0,0,2);
	glutSolidCone(2,3,10,10);   //Конус
	glPopmatrix;

  *)

   SetLength(arr_ax,3);
   arr_ax[0]:= 0.2*abs(body[0].xE-body[0].xS);
   arr_ax[1]:= 0.2*abs(body[0].yE-body[0].yS);
   arr_ax[2]:= 0.2*abs(body[0].zE-body[0].zS);

   // Находим медиану. Сначала сортируем по возрастанию, а потом берем среднее значение.
   for i := 0 to 1 do
   begin
      for j := 0 to 1-i do
      begin
         if (arr_ax[j]>arr_ax[j+1]) then
         begin
            ax:=arr_ax[j];
            arr_ax[j]:=arr_ax[j+1];
            arr_ax[j+1]:=ax;
         end;
      end;
   end;
   ax:=arr_ax[1]; // Выбираем медиану.

   // Выбираем наибольшее значение.
   //ax:=0.15*abs(body[0].xE-body[0].xS);
   //if (0.15*abs(body[0].yE-body[0].yS)>ax) then
   //begin
     // ax:=0.15*abs(body[0].yE-body[0].yS);
   //end;
   //if (0.15*abs(body[0].zE-body[0].zS)>ax) then
   //begin
     // ax:=0.15*abs(body[0].zE-body[0].zS);
   //end;

   SetLength(arr_ax,0);

   //if (rgview.ItemIndex=2) then
   //begin
     // glDisable(GL_LIGHTING);
   //end;
   glpushMatrix;
   glTranslatef(0,0,-Hscale*sqrt(sqr(Laplas.body[0].zE-Laplas.body[0].zS)+sqr(Laplas.body[0].yE-Laplas.body[0].yS)+sqr(Laplas.body[0].xE-Laplas.body[0].xS)));
  // glTranslatef(-0.5*abs(Laplas.body[0].xE-Laplas.body[0].xS),-0.5*abs(Laplas.body[0].yE-Laplas.body[0].yS),-0.5*abs(Laplas.body[0].zE-Laplas.body[0].zS));
   //--->glRotatef(180.0*Alf/3.141,0.0,0.0,1.0); // z
   // glRotatef(180.0*Bet/3.141,1.0,0.0,0.0); // x
   //--->glRotatef(180.0*Bet/3.141,0.7071,0.7071,0.0); // x && y
   // Вращательное движение в 3D имеет три степени свободы.
   glRotatef(180.0*Gam0/3.141,0.0,0.0,1.0); // z apriory
   glRotatef(180.0*Alf/3.141,1.0,0.0,0.0); // x
   glRotatef(180.0*Bet/3.141,0.0,1.0,0.0); // y
   glRotatef(180.0*Gam/3.141,0.0,0.0,1.0); // z
  // glTranslatef(0.5*abs(Laplas.body[0].xE-Laplas.body[0].xS),0.5*abs(Laplas.body[0].yE-Laplas.body[0].yS),0.5*abs(Laplas.body[0].zE-Laplas.body[0].zS));


   if (CheckBoxSystemCoordinat.Checked) then
   begin
      // Рисуем декартову прямоугольную систему координат
      // только в том случае если этого хочет пользователь.
      glBegin(GL_LINES);
        glLineWidth(2.0);
        glColor3f(1.0,0.0,0.0);
        glVertex3f(0.0,0.0,0.0);  // red x
        glVertex3f(ax,0.0,0.0);
        glColor3f(0.0,1.0,0.0);
        glVertex3f(0.0,0.0,0.0);
        glVertex3f(0.0,ax,0.0);   // green y
        glColor3f(0.0,0.0,1.0);
        glVertex3f(0.0,0.0,0.0);
        glVertex3f(0.0,0.0,ax);   // blue z
        glLineWidth(1.0);
        glColor3f(1,1,1);  // Цвет фона белый.
      glEnd;
   end;
 

   glPopmatrix;
   if (rgview.ItemIndex=2) then
   begin



       if (CheckBoxOnLitht.Checked=true) then
       begin
          glDisable(GL_LIGHT0);
       end;
       if (ChkOnLitht1.Checked=true) then
       begin
         glDisable(GL_LIGHT1);
       end;
       glDisable(GL_LIGHTING);
       glDisable(GL_COLOR_MATERIAL);


   end;



   SwapBuffers(DC); // эта команда выводит содержимого буфера на экран, если вы забудете написать эту //команду, то у вас ничего выводится, не будет.
end;

procedure TLaplas.rgviewClick(Sender: TObject);
begin
    // Полигон может быть нарисован единтвенным цветом (GL_FLAT)
    // или с оттенками (GL_SMOOTH).
   // по умолчанию шадинг стоит GL_SMOOTH.
   // шадинг устанавливается командой :
   //glShadeModel(GL_FLAT);

   (*
  // смена вида прорисовки.
   case rgview.ItemIndex of
   0 : // обычная стандартная прорисовка линиями (та которая была изначально).
   begin
      glDisable(GL_LIGHT0);//выключаем источник света №0
      glDisable(GL_LIGHTING); // выключаем освещение.
   end;
   1 : // режим прорисовки с удалением невидимых линий.
   begin
      glDisable(GL_LIGHT0);//выключаем источник света №0
      glDisable(GL_LIGHTING); // выключаем освещение.
   end;
   2 : // Режим заливки с простейшей моделью освещения.
   begin
      // включить источник света.
      // если не освещать то объект будет закрашен сплошным белым цветом.
      glEnable(GL_LIGHTING); //включаем освещение
      glEnable(GL_LIGHT0); //включаем источник света №0
   end;
  end;
  *)


    // 23.02.2018
  if (rgview.ItemIndex>0) then
  begin
     (*
     if (rgview.ItemIndex=2) then
     begin
        glEnable(GL_COLOR_MATERIAL);
       // glEnable(GL_BLEND);
       // glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
     end
     else
     begin
        glDisable(GL_COLOR_MATERIAL);
       // glDisable(GL_BLEND);
     end;
     *)

    //glEnable(GL_DEPTH_TEST); //включить тест глубины : включаем проверку разрешения фигур (впереди стоящая закрывает фигуру за ней)
    // glDepthFunc(GL_LEQUAL); //тип проверки

     //--->glEnable ( GL_CULL_FACE );  //показывать только передние грани
     //--->glCullFace  ( GL_BACK );

     //glPolygonMode (GL_FRONT_AND_BACK, GL_FILL); // закраска сторон !!!
     //--->glPolygonMode (GL_FRONT, GL_FILL);

  end
  else
  begin
     //glDisable(GL_COLOR_MATERIAL); // выключает цвет материала.
     //glDisable(GL_BLEND);
     //--->glDisable(GL_CULL_FACE);  // отключаем избирательный показ граней.
    // glDisable(GL_DEPTH_TEST);  // отключаем тест глубины.

    if (not(bvisiblepic)) then
    begin
       //--->glPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
       // показать передние и задние стороны полигона линиями
    end
    else
    begin
       if ((icurrentpic=0)or(ComboBoxVisibleVariable.ItemIndex=nvalpic+1)) then
       begin
         // Расчётная сетка или геометрия.
         //--->glPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
         // показать передние и задние стороны полигона линиями
       end
        else
       begin
          //--->glPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
       end;
    end;
  end;

  if (rgview.ItemIndex=2) then
  begin
    on_visible_karkas();
  end
  else
  begin
     off_visible_karkas();
  end;

 // Application.OnIdle:=IdleHandler;
  
  // не надо здесь делать Ready Paint т.к. его надо делать лишь при
  // изменении пользователем текущей геометрии - добавлении или удалении блока.
  // Включено 9 августа 2016.
  ReadyPaint;
  Render;
end;


// Задаёт набор уравнений для решения.
procedure TLaplas.Setting1Click(Sender: TObject);
var
    i : Integer;
begin
    // Определяет набор уравнений для решения.

   // Инициализация вызываемой формы
   case egddata.itemper of
     0 : begin
            EGDForm.ComboBoxTemperature.ItemIndex:=0;
         end;
     1 : begin // Метод контрольного объёма.
            EGDForm.ComboBoxTemperature.ItemIndex:=1;
         end;
     2 : begin // Метод крнечных элементов.
            EGDForm.ComboBoxTemperature.ItemIndex:=2;
         end;
     3 : begin // Метод крнечных элементов.
            EGDForm.ComboBoxTemperature.ItemIndex:=3;// network_T
         end;
   end;
   case egddata.iStaticStructural of
     0 : begin
            EGDForm.CheckBoxStaticStructural.Checked:=false;
         end;
     1 : begin
            EGDForm.CheckBoxStaticStructural.Checked:=true;
         end;
   end;
   //EGDForm.CBMaxFluidDomain.ItemIndex:=egddata.imaxflD;
   if (egddata.imaxflD=0) then
   begin
      EGDForm.GBCFlZ.Visible:=false;
   end
   else
   begin
      EGDForm.GBCFlZ.Visible:=true;

      //EGDForm.CBIdCurFLzone.Clear;
      //for i:=0 to egddata.imaxflD-1 do
      //begin
        // EGDForm.CBIdCurFLzone.Items.Append(IntToStr(i+1));
      //end;
      //EGDForm.CBIdCurFLzone.ItemIndex:=0; // устанавливаем первую FLUID зону

      //EGDForm.EditXC.Text:=FloatToStr(egddata.myflmod[0].xc);
      //EGDForm.EditYC.Text:=FloatToStr(egddata.myflmod[0].yc);
      //EGDForm.EditZC.Text:=FloatToStr(egddata.myflmod[0].zc);

      if (egddata.myflmod[0].iflow=1) then
      begin
         EGDForm.CBFlow.Checked:=true;
         EGDForm.GBGravity.Visible:=true;
      end
       else
      begin
         EGDForm.CBFlow.Checked:=false;
         EGDForm.GBGravity.Visible:=false;
      end;

      EGDForm.RadioGroupFlowRegime.ItemIndex:=egddata.myflmod[0].iflowregime;

      if (egddata.myflmod[0].iflow=1) then
      begin

         EGDForm.RadioGroupFlowRegime.Visible:=true;

         // показ окошка выбора модели турбулентности
         if (egddata.myflmod[0].iflowregime=0) then
         begin
            EGDForm.GroupBoxTurbulentModel.Visible:=false;
         end
          else
         begin
            EGDForm.GroupBoxTurbulentModel.Visible:=true;
            EGDForm.ComboBoxturbulentmodel.ItemIndex:=egddata.myflmod[0].iturbmodel;
            case egddata.myflmod[0].iturbmodel of
             0 :  begin
                     // ZEM
                     EGDForm.BEditTurb.Visible:=false;
                  end;
             1 :  begin
                     // Smagorinsky
                     EGDForm.BEditTurb.Visible:=true;
                  end;
             2 : begin
                    // RNG (LES)
                    EGDForm.BEditTurb.Visible:=false;
                 end;
             3 : begin
                    // Spalart - Allmares (RANS)
                    EGDForm.BEditTurb.Visible:=false;
                 end;
             4 : begin
                    // K - Omega SST (RANS)
                    EGDForm.BEditTurb.Visible:=false;
                 end;
             5 : begin
                    // Standart K-Epsilon (RANS)
                    EGDForm.BEditTurb.Visible:=false;
                 end;
             6 : begin
                    // Модель Ментора Лантгрии (RANS) [2009]
                    EGDForm.BEditTurb.Visible:=false;
                 end;
            end;
         end;
      end
       else
      begin
         EGDForm.RadioGroupFlowRegime.Visible:=false;
         EGDForm.GroupBoxTurbulentModel.Visible:=false;
      end;
   end;

    // Задаёт силу тяжести
   // инициализация :
   EGDForm.Egx.Text:=FloatToStr(Laplas.gx);
   EGDForm.Egy.Text:=FloatToStr(Laplas.gy);
   EGDForm.Egz.Text:=FloatToStr(Laplas.gz);

   if (bREALESEversion) then
   begin
      // МАНИФЕСТ СТАБИЛЬНОСТИ
      // ДЛЯ ПОЛЬЗОВАТЕЛЯ 04.08.2019

      // Мы полностью отключаем все
      // недоработанные функциональные
      // возможности из интерфейса программы.


       // Среди моделей турбулентности оставляем только
      // Zero Equation Turbulence Model.
      //EGDForm.ComboBoxturbulentmodel.Items.Clear;
      //EGDForm.ComboBoxturbulentmodel.Items.Add('Zero Equation Model (RANS)');
      //EGDForm.ComboBoxturbulentmodel.ItemIndex:=0;
      // Полностью отключаем механику из интерфейса
      // т.к. она так и не заработала на мсмент
      // 4 августа 2019 года.
      EGDForm.CheckBoxStaticStructural.Visible:=true;
      //EGDForm.CheckBoxStaticStructural.Checked:=false;
   end;
   EGDForm.CBFlowClick(Sender);

   EGDForm.ShowModal;  // вызов формы для редактирования свойств
end;

// Вызывает настройки солвера.
// скрывал лишнюю информацию
// для пользователя 17.09.2019
procedure TLaplas.Settings1Click(Sender: TObject);
begin
   // Делаем видимой по умолчанию форму в которой
   // можно выбрать алгоритм решения СЛАУ
   // для температуры МКО и для гидродинамики.
   FormSetting.ComboBoxSolverSetting.Visible:=true;

   if (egddata.itemper<>2) then
   begin
      if (egddata.iStaticStructural=1) then
      begin
         // Механика
         FormSetting.GroupBox2.Visible:=true;
      end
      else
      begin
         // точно не механика.
         // none, МКО или графовый метод.
         FormSetting.GroupBox2.Visible:=false;
      end;
   end
   else
   begin
      // Метод Конечных Элементов (МКЭ).
      FormSetting.GroupBox2.Visible:=true;
   end;
   if (egddata.myflmod[0].iflow=1) then
   begin
      // Гидродинамический расчёт.

      FormSetting.Height:=566;
      FormSetting.PanelSolverSetting.Visible:=true;

      //if (MeshForm.CheckBoxALICE.Checked) then
      //begin
         // закоментировано 04.01.2021
         // АЛИС сетка
         //FormSetting.ComboBoxFlowSchemePrefix.Visible:=true;
         //FormSetting.ComboBoxFlowScheme.Visible:=false;
         //FormSetting.ComboBoxSchemeTemperature.Visible:=false;
         //FormSetting.ComboBoxFlowSchemePrefix.ItemIndex:=1; // Upwind
         //FormSetting.ComboBoxFlowScheme.ItemIndex:=0; // Upwind
         //FormSetting.ComboBoxSchemeTemperature.ItemIndex:=0; // Upwind
         //FormSetting.Label1.Visible:=false;
         //FormSetting.Label2.Visible:=false;
      //end
      //else
      //begin
         // Структурированная сетка.
         FormSetting.ComboBoxFlowSchemePrefix.Visible:=true;
         FormSetting.ComboBoxFlowScheme.Visible:=true;
         FormSetting.ComboBoxSchemeTemperature.Visible:=true;
         FormSetting.Label1.Visible:=true;
         FormSetting.Label2.Visible:=true;
      //end;
   end
   else
   begin
      FormSetting.PanelSolverSetting.Visible:=true;
      if (egddata.itemper<>2) then
      begin
         // MKO Temperature solver or none solution Temperature
         // or NetWork T Solver.
         FormSetting.Height:=566;
      end
      else
      begin
         // Finite Element Temperature Solver is active
         if (egddata.myflmod[0].iflow=0) then
         begin
            // Мы решаем температуру вторым температурным солвером
            // На основе метода конечных элементов и мы скрыли
            // выбор способа решения СЛАУ для температуры на основе
            // мко дискретизации.
            FormSetting.ComboBoxSolverSetting.Visible:=false;
         end;
         FormSetting.Height:=566;
      end;
       //if (MeshForm.CheckBoxALICE.Checked) then
      //begin
         // закоментировано 04.01.2021
         // АЛИС сетка
         //FormSetting.ComboBoxFlowSchemePrefix.Visible:=false;
        // FormSetting.ComboBoxFlowScheme.Visible:=false;
         //FormSetting.ComboBoxSchemeTemperature.Visible:=false;
         //FormSetting.ComboBoxFlowSchemePrefix.ItemIndex:=1; // Upwind
         //FormSetting.ComboBoxFlowScheme.ItemIndex:=0; // Upwind
         //FormSetting.ComboBoxSchemeTemperature.ItemIndex:=0; // Upwind
         //FormSetting.Label1.Visible:=false;
         //FormSetting.Label2.Visible:=false;
      //end
      //else
      //begin
         // Структурированная сетка.
         FormSetting.ComboBoxFlowSchemePrefix.Visible:=false;
         FormSetting.ComboBoxFlowScheme.Visible:=false;
         FormSetting.ComboBoxSchemeTemperature.Visible:=true;
         FormSetting.ComboBoxFlowSchemePrefix.ItemIndex:=1; // Upwind
         FormSetting.ComboBoxFlowScheme.ItemIndex:=0; // Upwind
         FormSetting.Label1.Visible:=false;
         FormSetting.Label2.Visible:=true;
      //end;
   end;
   FormSetting.ComboBoxSolverSettingChange(Sender);
   FormSetting.ShowModal;
end;

procedure TLaplas.btnimageClick(Sender: TObject);
var
  filename : string; // имя записываемого файла
  dwloc : HWND;
  dcloc : HDC;
  bmp : TBitmap;
  ileft, itop : Integer;

begin
   // записывает файл картинки с геометрией задачи

   filename:='';
   if not InputQuery('Input name file', 'Please, enter name writing file',filename)
   then exit;

   Render; // обязательная перерисовка

   // Данный код устарел.
   // Он был пригоден для реализации графики без использования OpenGL.
   // Поэтому 27 февраля 2015 он будет заменён на код учитывающий то,
   // что графика реализована на OpenGL.

   (*
   Bitmap := TBitmap.Create;
  try
    Bitmap.Width := pnlPaint.Width;
    Bitmap.Height:= pnlPaint.Height;
    Dest := Rect(0, 0, Bitmap.Width, Bitmap.Height);
    Source := Rect(MainPanel.Left+pnlPaint.Left, pnlPaint.Top, MainPanel.Left+pnlPaint.Left+pnlPaint.Width, pnlPaint.Top+pnlPaint.Height);

    Bitmap.Canvas.CopyRect(Dest, Canvas, Source);
    Bitmap.SaveToFile(filename+'.bmp');
  finally
    Bitmap.Free;
  end;
  *)

    Sleep(500);
   // Делает скриншот всей экранной формы.
   bmp:=TBitmap.Create;
   bmp.Width:=pnlPaint.Width;
   bmp.Height:=pnlPaint.Height;
   dwloc:=GetDesktopWindow;
   dcloc:=GetDC(dwloc);
   // 8 - магическое универсальное число пикселей при котором
   // скриншот рабочего пространства скриншотится без бортиков.
   ileft:=Laplas.Left+MainPanel.Left+pnlPaint.Left+8;
   itop:=Laplas.Top+(Laplas.Height-Laplas.ClientHeight)+pnlPaint.Top-8;
   BitBlt(bmp.Canvas.Handle,0,0,bmp.Width,bmp.Height,dcloc,ileft,itop,SRCCOPY);
   ReleaseDC(dwloc,dcloc);
   bmp.SaveToFile(filename+'.bmp');

   // SwapBuffer делать не надо тут.
end;

// Закрывает приложение.
procedure TLaplas.guiClose2Click(Sender: TObject);
begin
   // Зачем удалять, пусть на диске лежит до следующего запуска солвера.
   //DeleteFile('ALICEFLOW0_07_temp.PLT');
   Close;
end;

procedure TLaplas.SpeedButton1Click(Sender: TObject);
begin
   if (GroupBoxLight.Visible=false) then
   begin
      //GroupBoxLight.Visible:=True;
      GroupBoxMoveObject.Visible:=false;
      GroupBoxVisualizationManagment.Visible:=false;

      if (grpmaterial_litht_prop.Visible=False) then
      begin
         if (grplitht1.Visible=False) then
         begin
            GroupBoxLight.Visible:=True;
         end
         else
         begin
            grplitht1.Visible:=False;
         end;
      end
      else
      begin
         grpmaterial_litht_prop.Visible:=False;
      end;

   end
    else
   begin
      GroupBoxLight.Visible:=False;
   end;
end;



// Считываем картинку из Техплот.
procedure TLaplas.LoadSolutionIDClick(Sender: TObject);
const
 bVisibleCount = 7;
var
   f : TStringList; // переменная типа объект TStringList
   s, sub : string;
   i, istr, ielm, j, istrnow : Integer;
   xa, xb, xc : Real;
begin
    //npic, epic : Integer;
    //xpic, ypic, zpic : array of Real;
    //temppic,lampic,hxpic, hypic, hzpic, hmagpic : array of Real;
    f:=TStringList.Create();
    // читает файл с геометрией и тепловыми полями и сохраняет эту
    // информацию в теле компьютерной программы-визуализатора.
    OpenDialog1.Filter:='Текстовые файлы|*.PLT';
    if (OpenDialog1.Execute and FileExists(OpenDialog1.FileName)) then
    begin
      // Результат успешный - пользователь выбрал файл.
      // Загружаем файл.
      istrnow:=0;
      f.LoadFromFile(OpenDialog1.FileName);

      if (FormatSettings.DecimalSeparator=',') then
      begin
         // заменить все точки в файле на запятые.
         for i:=0 to f.Count-1 do
         begin
            s:=f.Strings[i];
            f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
         end;
      end;


      s:=f.Strings[istrnow];
      inc(istrnow);
       while ((length(s)=0)) do
      begin
         s:=Trim(f.Strings[istrnow]);
         inc(istrnow);
      end;
      sub:=Copy(Trim(s),Pos('"',s)+1,Length(s)-1-Pos('"',s));
      Caption:=sub;

      s:=Trim(f.Strings[istrnow]);
      inc(istrnow);
      while ((length(s)=0)) do
      begin
         s:=Trim(f.Strings[istrnow]);
         inc(istrnow);
      end;

      //ShowMessage(s);
      nvalpic:=0;
      for i := 1 to length(s) do
      begin
          if (s[i]=',') then
          begin
             inc(nvalpic);
          end;
      end;
      // ShowMessage('ok');
      nvalpic:=nvalpic-2;
      icurrentpic:=0; // Mesh
      //ShowMessage(IntToStr(nvalpic));
      SetLength(temppicname,nvalpic+1);
      temppicname[0]:='Mesh';
      SetLength(temppicpotent,nvalpic);
      SetLength(minimumpic,nvalpic);
      SetLength(maximumpic,nvalpic);


      sub:=Copy(Trim(s),Pos('=',s)+1,Length(s)-Pos('=',s));
      s:=Trim(sub);
      sub:=Copy(s,1,Pos(',',s)-1);

      sub:=Copy(Trim(s),Pos(',',s)+1,Length(s));
      s:=Trim(sub);
      sub:=Copy(Trim(s),Pos(',',s)+1,Length(s));
      s:=Trim(sub);
      for j := 1 to nvalpic do
      begin
         sub:=Copy(Trim(s),Pos(',',s)+1,Length(s));
         s:=Trim(sub);
         if (Pos(',',s)<>0) then
         begin
             temppicname[j]:=Trim(Copy(s,1,Pos(',',s)-1));
         end
         else
         begin
            temppicname[j]:=Trim(s);
         end;
        // ShowMessage(temppicname[j]);
      end;

      ComboBoxVisibleVariable.Items.Clear;
      MainMemo.Lines.Add('Load fields:');
      for j := 0 to nvalpic do
      begin
         MainMemo.Lines.Add(temppicname[j]);
         ComboBoxVisibleVariable.Items.Add(temppicname[j]);
      end;
      ComboBoxVisibleVariable.Items.Add('Geom');
      ComboBoxVisibleVariable.ItemIndex:=0;


      s:=Trim(f.Strings[istrnow]);
      inc(istrnow);
       while ((length(s)=0)) do
      begin
         s:=Trim(f.Strings[istrnow]);
         inc(istrnow);
      end;

      sub:=Copy(Trim(s),Pos('N=',s)+2,Length(s)-1-Pos('N=',s));
      s:=Trim(sub);
      sub:=Copy(s,1,Pos(',',s)-1);
      npic:=StrToInt(sub);

      for j := 0 to nvalpic-1 do
        begin
           SetLength(temppicpotent[j],npic);
        end;

      sub:=Copy(Trim(s),Pos('E=',s)+2,Length(s)-1-Pos('E=',s));
      s:=Trim(sub);
      sub:=Copy(s,1,Pos(',',s)-1);
      epic:=StrToInt(sub);

      SetLength(xpic,npic);
      SetLength(ypic,npic);
      SetLength(zpic,npic);
      SetLength(ipa_count,npic);

      for j := 0 to npic-1 do
      begin
         ipa_count[j]:=0; // инициализация
      end;

      // Мы ориентированы на файл с АЛИС сеткой.

     // ShowMessage('ok');
      SetLength(elmpic,epic);

       SetLength(bvisible_granq,7,epic);
      for j := 0 to epic-1 do
      begin
      for i := 0 to 6 do
         begin
            bvisible_granq[i][j]:=false;
         end;
      end;

      istr:=istrnow;
      // Считывание x.
      s:=Trim(f.Strings[istr]);

      for i:=1 to npic do
      begin
            while (Length(Trim(s))=0) do
             begin
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;

          if (Pos(' ',s)=0) then
          begin
              xpic[i-1]:=StrToFloat(s);
              inc(istr);
              s:=Trim(f.Strings[istr]);
              while (Length(Trim(s))=0) do
              begin
                 inc(istr);
                 s:=Trim(f.Strings[istr]);
              end;
          end
          else
          begin
             sub:=Trim(Copy(s,1,Pos(' ',s)-1));
             xpic[i-1]:=StrToFloat(sub);
             s:=Trim(Copy(s,Pos(' ',s)+1,Length(s)));
             while (Length(Trim(s))=0) do
             begin
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;
          end;
      end;
     // ShowMessage('ok');
      // Считывание y.
      for i:=1 to npic do
      begin
             while (Length(Trim(s))=0) do
             begin
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;

          if (Pos(' ',s)=0) then
          begin
              ypic[i-1]:=StrToFloat(s);
              inc(istr);
              s:=Trim(f.Strings[istr]);
              while (Length(Trim(s))=0) do
              begin
                 inc(istr);
                 s:=Trim(f.Strings[istr]);
              end;
          end
          else
          begin
             sub:=Trim(Copy(s,1,Pos(' ',s)-1));
             ypic[i-1]:=StrToFloat(sub);
             s:=Trim(Copy(s,Pos(' ',s)+1,Length(s)));
             while (Length(Trim(s))=0) do
             begin
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;
          end;
      end;
     // ShowMessage('ok');
      // Считывание z.
      for i:=1 to npic do
      begin
          while (Length(Trim(s))=0) do
          begin
             inc(istr);
             s:=Trim(f.Strings[istr]);
          end;

          if (Pos(' ',s)=0) then
          begin
              zpic[i-1]:=StrToFloat(s);
              inc(istr);
              s:=Trim(f.Strings[istr]);
              while (Length(Trim(s))=0) do
              begin
                 inc(istr);
                 s:=Trim(f.Strings[istr]);
              end;
          end
          else
          begin
             sub:=Trim(Copy(s,1,Pos(' ',s)-1));
             zpic[i-1]:=StrToFloat(sub);
             s:=Trim(Copy(s,Pos(' ',s)+1,Length(s)));
             while (Length(Trim(s))=0) do
             begin
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;
          end;
      end;
     // ShowMessage('ok');

      if (ComboBoxlength.ItemIndex=1) then
      begin
         // mm
         for i:=1 to npic do
         begin
            xpic[i-1]:=1000.0*xpic[i-1];
            ypic[i-1]:=1000.0*ypic[i-1];
            zpic[i-1]:=1000.0*zpic[i-1];
         end;
      end;
       if (ComboBoxlength.ItemIndex=2) then
      begin
         // micron
         for i:=1 to npic do
         begin
            xpic[i-1]:=1000000.0*xpic[i-1];
            ypic[i-1]:=1000000.0*ypic[i-1];
            zpic[i-1]:=1000000.0*zpic[i-1];
         end;
      end;


      // Считывание temperature.
      for j := 0 to nvalpic-1 do
      begin

         for i:=1 to npic do
         begin
            while (Length(Trim(s))=0) do
            begin
               inc(istr);
               s:=Trim(f.Strings[istr]);
            end;

            if (Pos(' ',s)=0) then
            begin
               temppicpotent[j][i-1]:=StrToFloat(s);
               inc(istr);
               s:=Trim(f.Strings[istr]);
               while (Length(Trim(s))=0) do
               begin
                  inc(istr);
                  s:=Trim(f.Strings[istr]);
               end;
            end
             else
            begin
               sub:=Trim(Copy(s,1,Pos(' ',s)-1));
               temppicpotent[j][i-1]:=StrToFloat(sub);
               s:=Trim(Copy(s,Pos(' ',s)+1,Length(s)));
               while (Length(Trim(s))=0) do
               begin
                  inc(istr);
                  s:=Trim(f.Strings[istr]);
               end;
            end;
         end;

         // Определение максимального и минимального значения.
         minimumpic[j]:=1.0e30;
         maximumpic[j]:=-1.0e30;
         for i:=1 to npic do
         begin
           if (temppicpotent[j][i-1]<minimumpic[j]) then
           begin
              minimumpic[j]:=temppicpotent[j][i-1];
           end;
           if (temppicpotent[j][i-1]>maximumpic[j]) then
           begin
              maximumpic[j]:=temppicpotent[j][i-1];
           end;

         end;
      end;



      // Считывание конечных элементов.
       ielm:=0;
       for i := 1 to 8*epic do
       begin
          s:=Trim(s);
          if ((Pos(' ',s)=0)and(length(s)>0)) then
          begin
             elmpic[ielm].i8:=StrToInt(Trim(s));
             inc(istr);
             if (istr<f.Count) then
             begin
                s:=Trim(f.Strings[istr]);
             end;
             inc(ielm);
          end
          else
          begin
              if (length(s)>0) then
              begin
              sub:=Trim(Copy(s,1,Pos(' ',s)-1));
              if ((i-1) mod 8 = 0) then
              begin
                 elmpic[ielm].i1:=StrToInt(sub);
              end;
              if ((i-2) mod 8 = 0) then
              begin
                 elmpic[ielm].i2:=StrToInt(sub);
              end;
              if ((i-3) mod 8 = 0) then
              begin
                 elmpic[ielm].i3:=StrToInt(sub);
              end;
              if ((i-4) mod 8 = 0) then
              begin
                 elmpic[ielm].i4:=StrToInt(sub);
              end;
               if ((i-5) mod 8 = 0) then
              begin
                 elmpic[ielm].i5:=StrToInt(sub);
              end;
              if ((i-6) mod 8 = 0) then
              begin
                 elmpic[ielm].i6:=StrToInt(sub);
              end;
              if ((i-7) mod 8 = 0) then
              begin
                 elmpic[ielm].i7:=StrToInt(sub);
              end;
              if ((i-8) mod 8 =0) then
              begin
                 elmpic[ielm].i8:=StrToInt(sub);
                 inc(ielm);
              end;

              s:=Trim(Copy(s,Pos(' ',s)+1,Length(s)));

              if (Length(Trim(s))=0) then
              begin
                inc(istr);
                if (istr<f.Count) then
                begin
                    s:=Trim(f.Strings[istr]);
                    while (length(s)=0) do
                    begin
                       inc(istr);
                       if (istr<f.Count) then
                       begin
                          s:=Trim(f.Strings[istr]);
                       end;
                    end;
                end;
              end;
              end
              else
              begin
              epic:=ielm;
                  break;
              end;
          end;
       end;

       for ielm:=0 to epic-1 do
         begin
           inc(ipa_count[elmpic[ielm].i1-1]);
           inc(ipa_count[elmpic[ielm].i2-1]);
           inc(ipa_count[elmpic[ielm].i3-1]);
           inc(ipa_count[elmpic[ielm].i4-1]);
           inc(ipa_count[elmpic[ielm].i5-1]);
           inc(ipa_count[elmpic[ielm].i6-1]);
           inc(ipa_count[elmpic[ielm].i7-1]);
           inc(ipa_count[elmpic[ielm].i8-1]);
         end;

          for ielm:=0 to epic-1 do
       begin
          // XY bottom 4
          if ((ipa_count[elmpic[ielm].i1-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i2-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i3-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i4-1]<=bVisibleCount)) then
          Begin
             bvisible_granq[4][ielm]:=true;
             bvisible_granq[6][ielm]:=true;
          End;

          // XY Top 5
          if ((ipa_count[elmpic[ielm].i5-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i6-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i7-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i8-1]<=bVisibleCount)) then
          Begin
             bvisible_granq[5][ielm]:=true;
             bvisible_granq[6][ielm]:=true;
          End;

          // XZ SSIDE min Y 2
          if ((ipa_count[elmpic[ielm].i1-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i2-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i6-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i5-1]<=bVisibleCount)) then
          Begin
             bvisible_granq[2][ielm]:=true;
             bvisible_granq[6][ielm]:=true;
          End;

         // XZ SSIDE max Y 3
         if ((ipa_count[elmpic[ielm].i4-1]<=bVisibleCount) and
             (ipa_count[elmpic[ielm].i8-1]<=bVisibleCount) and
             (ipa_count[elmpic[ielm].i7-1]<=bVisibleCount) and
             (ipa_count[elmpic[ielm].i3-1]<=bVisibleCount)) then
         Begin
            bvisible_granq[3][ielm]:=true;
            bvisible_granq[6][ielm]:=true;
         end;

         // YZ SSIDE max X 0
         if ((ipa_count[elmpic[ielm].i2-1]<=bVisibleCount) and
             (ipa_count[elmpic[ielm].i3-1]<=bVisibleCount) and
             (ipa_count[elmpic[ielm].i7-1]<=bVisibleCount) and
             (ipa_count[elmpic[ielm].i6-1]<=bVisibleCount)) then
          Begin
             bvisible_granq[0][ielm]:=true;
             bvisible_granq[6][ielm]:=true;
          end;

          // YZ SSIDE min X 1
          if ((ipa_count[elmpic[ielm].i1-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i5-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i8-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i4-1]<=bVisibleCount)) then
           begin
              bvisible_granq[1][ielm]:=true;
              bvisible_granq[6][ielm]:=true;
           end;

       end;


       // Определение максимума и минимума за одно линейное сканирование.
       xminpic:=1.0e30;
       yminpic:=1.0e30;
       zminpic:=1.0e30;
       xmaxpic:=-1.0e30;
       ymaxpic:=-1.0e30;
       zmaxpic:=-1.0e30;

       for i := 1 to npic do
         begin
           if (xpic[i-1]<xminpic) then
           begin
             xminpic:=xpic[i-1];
           end;
           if (ypic[i-1]<yminpic) then
           begin
             yminpic:=ypic[i-1];
           end;
           if (zpic[i-1]<zminpic) then
           begin
             zminpic:=zpic[i-1];
           end;
            if (xpic[i-1]>xmaxpic) then
           begin
             xmaxpic:=xpic[i-1];
           end;
           if (ypic[i-1]>ymaxpic) then
           begin
             ymaxpic:=ypic[i-1];
           end;
           if (zpic[i-1]>zmaxpic) then
           begin
             zmaxpic:=zpic[i-1];
           end;
         end;

          perspectiveangle:=2.0*180.0*(arctan((0.25)/(Hscale)))/1.57079632679;
   xa:=-7990;
   xb:=7990;
   xc:=0;
   while (abs(perspectiveangle-return_Perspective_angle(xc))>0.01) do
   begin
     if ((perspectiveangle-return_Perspective_angle(xa))*(perspectiveangle-return_Perspective_angle(xc))<0) then
     begin
       xb:=xc;
       xc:=0.5*(xa+xb);
     end
     else
     begin
         xa:=xc;
         xc:=0.5*(xa+xb);
     end;
   end;
    perspectiveangle_counter:=xc;



       // центры двух систем координат совпадают
       //Oxc:=0.0;
       //Oyc:=0.0;
       //Ozc:=0.0;
       Oxc:=0.5*(xminpic+xmaxpic);
       Oyc:=0.5*(yminpic+ymaxpic);
       Ozc:=0.5*(zminpic+zmaxpic);

       f.Free;
       MainMemo.Lines.Add('temperature field is Done.');


       bvisiblepic:=true; // картинка визуализируется.
       bvisiblepicdubl:=true;


    end
    else
    begin
       // Освобождаем оперативную память.
       npic:=0;
       epic:=0;
       SetLength(xpic,npic);
       SetLength(ypic,npic);
       SetLength(zpic,npic);
       SetLength(ipa_count,npic);
       SetLength(bvisible_granq,7,epic);


       // Мы ориентированы на файл с АЛИС сеткой.
       SetLength(temppicpotent,0,npic);


       SetLength(elmpic,epic);

       bvisiblepic:=false; // картинка не визуализируется.
    end;
end;


// Каркасная модель рисуется.
procedure TLaplas.on_visible_karkas();
const
   bVisibleCount = 7;
var
   f : TStringList; // переменная типа объект TStringList
   s, sub : string;
   i, istr, ielm, j, istrnow : Integer;
   xa, xb, xc : Real;
begin
   //npic, epic : Integer;
    //xpic, ypic, zpic : array of Real;
    //temppic,lampic,hxpic, hypic, hzpic, hmagpic : array of Real;
    f:=TStringList.Create();
    // читает файл с геометрией и тепловыми полями и сохраняет эту
    // информацию в теле компьютерной программы-визуализатора.
    OpenDialog1.Filter:='Текстовые файлы|*.PLT';
    if (OpenDialog1.Execute and FileExists(OpenDialog1.FileName)) then
    begin
      // Результат успешный - пользователь выбрал файл.
      // Загружаем файл.
      istrnow:=0;
      f.LoadFromFile(OpenDialog1.FileName);

      if (FormatSettings.DecimalSeparator=',') then
      begin
         // заменить все точки в файле на запятые.
         for i:=0 to f.Count-1 do
         begin
            s:=f.Strings[i];
            f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
         end;
      end;


      s:=f.Strings[istrnow];
      inc(istrnow);
       while ((length(s)=0)) do
      begin
         s:=Trim(f.Strings[istrnow]);
         inc(istrnow);
      end;
      sub:=Copy(Trim(s),Pos('"',s)+1,Length(s)-1-Pos('"',s));
      Caption:=sub;

      s:=Trim(f.Strings[istrnow]);
      inc(istrnow);
      while ((length(s)=0)) do
      begin
         s:=Trim(f.Strings[istrnow]);
         inc(istrnow);
      end;

      //ShowMessage(s);
      nvalpic:=0;
      for i := 1 to length(s) do
      begin
          if (s[i]=',') then
          begin
             inc(nvalpic);
          end;
      end;
      // ShowMessage('ok');
      nvalpic:=nvalpic-2;
      icurrentpic:=0; // Mesh
      //ShowMessage(IntToStr(nvalpic));
      SetLength(temppicname,nvalpic+1);
      temppicname[0]:='Mesh';
      SetLength(temppicpotent,nvalpic);
      SetLength(minimumpic,nvalpic);
      SetLength(maximumpic,nvalpic);


      sub:=Copy(Trim(s),Pos('=',s)+1,Length(s)-Pos('=',s));
      s:=Trim(sub);
      sub:=Copy(s,1,Pos(',',s)-1);

      sub:=Copy(Trim(s),Pos(',',s)+1,Length(s));
      s:=Trim(sub);
      sub:=Copy(Trim(s),Pos(',',s)+1,Length(s));
      s:=Trim(sub);
      for j := 1 to nvalpic do
      begin
         sub:=Copy(Trim(s),Pos(',',s)+1,Length(s));
         s:=Trim(sub);
         if (Pos(',',s)<>0) then
         begin
             temppicname[j]:=Trim(Copy(s,1,Pos(',',s)-1));
         end
         else
         begin
            temppicname[j]:=Trim(s);
         end;
        // ShowMessage(temppicname[j]);
      end;

     // ComboBoxVisibleVariable.Items.Clear;
      MainMemo.Lines.Add('Load geometry:');
      //for j := 0 to nvalpic do
      //begin
        // MainMemo.Lines.Add(temppicname[j]);
         //ComboBoxVisibleVariable.Items.Add(temppicname[j]);
      //end;
      //ComboBoxVisibleVariable.Items.Add('Geom');
      //ComboBoxVisibleVariable.ItemIndex:=0;


      s:=Trim(f.Strings[istrnow]);
      inc(istrnow);
       while ((length(s)=0)) do
      begin
         s:=Trim(f.Strings[istrnow]);
         inc(istrnow);
      end;

      sub:=Copy(Trim(s),Pos('N=',s)+2,Length(s)-1-Pos('N=',s));
      s:=Trim(sub);
      sub:=Copy(s,1,Pos(',',s)-1);
      npic:=StrToInt(sub);

      for j := 0 to nvalpic-1 do
        begin
           SetLength(temppicpotent[j],npic);
        end;

      sub:=Copy(Trim(s),Pos('E=',s)+2,Length(s)-1-Pos('E=',s));
      s:=Trim(sub);
      sub:=Copy(s,1,Pos(',',s)-1);
      epic:=StrToInt(sub);

      SetLength(xpic,npic);
      SetLength(ypic,npic);
      SetLength(zpic,npic);
      SetLength(ipa_count,npic);

      for j := 0 to npic-1 do
      begin
         ipa_count[j]:=0; // инициализация
      end;

      // Мы ориентированы на файл с АЛИС сеткой.

     // ShowMessage('ok');
      SetLength(elmpic,epic);

      SetLength(bvisible_granq,7,epic);
      for j := 0 to epic-1 do
      begin
      for i := 0 to 6 do
         begin
            bvisible_granq[i][j]:=false;
         end;
      end;

      istr:=istrnow;
      // Считывание x.
      s:=Trim(f.Strings[istr]);

      for i:=1 to npic do
      begin
            while (Length(Trim(s))=0) do
             begin
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;

          if (Pos(' ',s)=0) then
          begin
              xpic[i-1]:=StrToFloat(s);
              inc(istr);
              s:=Trim(f.Strings[istr]);
              while (Length(Trim(s))=0) do
              begin
                 inc(istr);
                 s:=Trim(f.Strings[istr]);
              end;
          end
          else
          begin
             sub:=Trim(Copy(s,1,Pos(' ',s)-1));
             xpic[i-1]:=StrToFloat(sub);
             s:=Trim(Copy(s,Pos(' ',s)+1,Length(s)));
             while (Length(Trim(s))=0) do
             begin
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;
          end;
      end;
     // ShowMessage('ok');
      // Считывание y.
      for i:=1 to npic do
      begin
             while (Length(Trim(s))=0) do
             begin
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;

          if (Pos(' ',s)=0) then
          begin
              ypic[i-1]:=StrToFloat(s);
              inc(istr);
              s:=Trim(f.Strings[istr]);
              while (Length(Trim(s))=0) do
              begin
                 inc(istr);
                 s:=Trim(f.Strings[istr]);
              end;
          end
          else
          begin
             sub:=Trim(Copy(s,1,Pos(' ',s)-1));
             ypic[i-1]:=StrToFloat(sub);
             s:=Trim(Copy(s,Pos(' ',s)+1,Length(s)));
             while (Length(Trim(s))=0) do
             begin
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;
          end;
      end;
     // ShowMessage('ok');
      // Считывание z.
      for i:=1 to npic do
      begin
          while (Length(Trim(s))=0) do
          begin
             inc(istr);
             s:=Trim(f.Strings[istr]);
          end;

          if (Pos(' ',s)=0) then
          begin
              zpic[i-1]:=StrToFloat(s);
              inc(istr);
              s:=Trim(f.Strings[istr]);
              while (Length(Trim(s))=0) do
              begin
                 inc(istr);
                 s:=Trim(f.Strings[istr]);
              end;
          end
          else
          begin
             sub:=Trim(Copy(s,1,Pos(' ',s)-1));
             zpic[i-1]:=StrToFloat(sub);
             s:=Trim(Copy(s,Pos(' ',s)+1,Length(s)));
             while (Length(Trim(s))=0) do
             begin
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;
          end;
      end;
     // ShowMessage('ok');

      if (ComboBoxlength.ItemIndex=1) then
      begin
         // mm
         for i:=1 to npic do
         begin
            xpic[i-1]:=1000.0*xpic[i-1];
            ypic[i-1]:=1000.0*ypic[i-1];
            zpic[i-1]:=1000.0*zpic[i-1];
         end;
      end;
       if (ComboBoxlength.ItemIndex=2) then
      begin
         // micron
         for i:=1 to npic do
         begin
            xpic[i-1]:=1000000.0*xpic[i-1];
            ypic[i-1]:=1000000.0*ypic[i-1];
            zpic[i-1]:=1000000.0*zpic[i-1];
         end;
      end;


      // Считывание temperature.
      // При геометрическом считывании это неактивно.
      for j := 0 to nvalpic-1 do
      begin

         for i:=1 to npic do
         begin
            while (Length(Trim(s))=0) do
            begin
               inc(istr);
               s:=Trim(f.Strings[istr]);
            end;

            if (Pos(' ',s)=0) then
            begin
               temppicpotent[j][i-1]:=StrToFloat(s);
               inc(istr);
               s:=Trim(f.Strings[istr]);
               while (Length(Trim(s))=0) do
               begin
                  inc(istr);
                  s:=Trim(f.Strings[istr]);
               end;
            end
             else
            begin
               sub:=Trim(Copy(s,1,Pos(' ',s)-1));
               temppicpotent[j][i-1]:=StrToFloat(sub);
               s:=Trim(Copy(s,Pos(' ',s)+1,Length(s)));
               while (Length(Trim(s))=0) do
               begin
                  inc(istr);
                  s:=Trim(f.Strings[istr]);
               end;
            end;
         end;

         // Определение максимального и минимального значения.
         minimumpic[j]:=1.0e30;
         maximumpic[j]:=-1.0e30;
         for i:=1 to npic do
         begin
           if (temppicpotent[j][i-1]<minimumpic[j]) then
           begin
              minimumpic[j]:=temppicpotent[j][i-1];
           end;
           if (temppicpotent[j][i-1]>maximumpic[j]) then
           begin
              maximumpic[j]:=temppicpotent[j][i-1];
           end;

         end;
      end;



      // Считывание конечных элементов.
       ielm:=0;
       for i := 1 to 8*epic do
       begin
          s:=Trim(s);
          if ((Pos(' ',s)=0)and(length(s)>0)) then
          begin
             elmpic[ielm].i8:=StrToInt(Trim(s));
             inc(istr);
             if (istr<f.Count) then
             begin
                s:=Trim(f.Strings[istr]);
             end;
             inc(ielm);
          end
          else
          begin
              if (length(s)>0) then
              begin
              sub:=Trim(Copy(s,1,Pos(' ',s)-1));
              if ((i-1) mod 8 = 0) then
              begin
                 elmpic[ielm].i1:=StrToInt(sub);
              end;
              if ((i-2) mod 8 = 0) then
              begin
                 elmpic[ielm].i2:=StrToInt(sub);
              end;
              if ((i-3) mod 8 = 0) then
              begin
                 elmpic[ielm].i3:=StrToInt(sub);
              end;
              if ((i-4) mod 8 = 0) then
              begin
                 elmpic[ielm].i4:=StrToInt(sub);
              end;
               if ((i-5) mod 8 = 0) then
              begin
                 elmpic[ielm].i5:=StrToInt(sub);
              end;
              if ((i-6) mod 8 = 0) then
              begin
                 elmpic[ielm].i6:=StrToInt(sub);
              end;
              if ((i-7) mod 8 = 0) then
              begin
                 elmpic[ielm].i7:=StrToInt(sub);
              end;
              if ((i-8) mod 8 =0) then
              begin
                 elmpic[ielm].i8:=StrToInt(sub);
                 inc(ielm);
              end;

              s:=Trim(Copy(s,Pos(' ',s)+1,Length(s)));

              if (Length(Trim(s))=0) then
              begin
                inc(istr);
                if (istr<f.Count) then
                begin
                    s:=Trim(f.Strings[istr]);
                    while (length(s)=0) do
                    begin
                       inc(istr);
                       if (istr<f.Count) then
                       begin
                          s:=Trim(f.Strings[istr]);
                       end;
                    end;
                end;
              end;
              end
              else
              begin
              epic:=ielm;
                  break;
              end;
          end;
       end;

       for ielm:=0 to epic-1 do
         begin
           inc(ipa_count[elmpic[ielm].i1-1]);
           inc(ipa_count[elmpic[ielm].i2-1]);
           inc(ipa_count[elmpic[ielm].i3-1]);
           inc(ipa_count[elmpic[ielm].i4-1]);
           inc(ipa_count[elmpic[ielm].i5-1]);
           inc(ipa_count[elmpic[ielm].i6-1]);
           inc(ipa_count[elmpic[ielm].i7-1]);
           inc(ipa_count[elmpic[ielm].i8-1]);
         end;

       for ielm:=0 to epic-1 do
       begin
          // XY bottom 4
          if ((ipa_count[elmpic[ielm].i1-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i2-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i3-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i4-1]<=bVisibleCount)) then
          Begin
             bvisible_granq[4][ielm]:=true;
             bvisible_granq[6][ielm]:=true;
          End;

          // XY Top 5
          if ((ipa_count[elmpic[ielm].i5-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i6-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i7-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i8-1]<=bVisibleCount)) then
          Begin
             bvisible_granq[5][ielm]:=true;
             bvisible_granq[6][ielm]:=true;
          End;

          // XZ SSIDE min Y 2
          if ((ipa_count[elmpic[ielm].i1-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i2-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i6-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i5-1]<=bVisibleCount)) then
          Begin
             bvisible_granq[2][ielm]:=true;
             bvisible_granq[6][ielm]:=true;
          End;

         // XZ SSIDE max Y 3
         if ((ipa_count[elmpic[ielm].i4-1]<=bVisibleCount) and
             (ipa_count[elmpic[ielm].i8-1]<=bVisibleCount) and
             (ipa_count[elmpic[ielm].i7-1]<=bVisibleCount) and
             (ipa_count[elmpic[ielm].i3-1]<=bVisibleCount)) then
         Begin
            bvisible_granq[3][ielm]:=true;
            bvisible_granq[6][ielm]:=true;
         end;

         // YZ SSIDE max X 0
         if ((ipa_count[elmpic[ielm].i2-1]<=bVisibleCount) and
             (ipa_count[elmpic[ielm].i3-1]<=bVisibleCount) and
             (ipa_count[elmpic[ielm].i7-1]<=bVisibleCount) and
             (ipa_count[elmpic[ielm].i6-1]<=bVisibleCount)) then
          Begin
             bvisible_granq[0][ielm]:=true;
             bvisible_granq[6][ielm]:=true;
          end;

          // YZ SSIDE min X 1
          if ((ipa_count[elmpic[ielm].i1-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i5-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i8-1]<=bVisibleCount) and
              (ipa_count[elmpic[ielm].i4-1]<=bVisibleCount)) then
           begin
              bvisible_granq[1][ielm]:=true;
              bvisible_granq[6][ielm]:=true;
           end;

       end;


       // Определение максимума и минимума за одно линейное сканирование.
       xminpic:=1.0e30;
       yminpic:=1.0e30;
       zminpic:=1.0e30;
       xmaxpic:=-1.0e30;
       ymaxpic:=-1.0e30;
       zmaxpic:=-1.0e30;

       for i := 1 to npic do
         begin
           if (xpic[i-1]<xminpic) then
           begin
             xminpic:=xpic[i-1];
           end;
           if (ypic[i-1]<yminpic) then
           begin
             yminpic:=ypic[i-1];
           end;
           if (zpic[i-1]<zminpic) then
           begin
             zminpic:=zpic[i-1];
           end;
            if (xpic[i-1]>xmaxpic) then
           begin
             xmaxpic:=xpic[i-1];
           end;
           if (ypic[i-1]>ymaxpic) then
           begin
             ymaxpic:=ypic[i-1];
           end;
           if (zpic[i-1]>zmaxpic) then
           begin
             zmaxpic:=zpic[i-1];
           end;
         end;

          perspectiveangle:=2.0*180.0*(arctan((0.25)/(Hscale)))/1.57079632679;
   xa:=-7990;
   xb:=7990;
   xc:=0;
   while (abs(perspectiveangle-return_Perspective_angle(xc))>0.01) do
   begin
     if ((perspectiveangle-return_Perspective_angle(xa))*(perspectiveangle-return_Perspective_angle(xc))<0) then
     begin
       xb:=xc;
       xc:=0.5*(xa+xb);
     end
     else
     begin
         xa:=xc;
         xc:=0.5*(xa+xb);
     end;
   end;
    perspectiveangle_counter:=xc;



       // центры двух систем координат совпадают
       //Oxc:=0.0;
       //Oyc:=0.0;
       //Ozc:=0.0;
       Oxc:=0.5*(xminpic+xmaxpic);
       Oyc:=0.5*(yminpic+ymaxpic);
       Ozc:=0.5*(zminpic+zmaxpic);

       f.Free;
       MainMemo.Lines.Add('Load geometry is Done.');





  end;
end;

// Каркасная модель не рисуется.
procedure TLaplas.off_visible_karkas();
begin
   // Освобождаем оперативную память.
   npic:=0;
   epic:=0;
   SetLength(xpic,npic);
   SetLength(ypic,npic);
   SetLength(zpic,npic);
   SetLength(ipa_count,npic);
   SetLength(bvisible_granq,7,epic); // Хранение для быстрой проверки требуется ли рисовать грань.

   // Мы ориентированы на файл с АЛИС сеткой.

   SetLength(elmpic,epic);

end;

// простейшая статистика о расчётной модели.
procedure TLaplas.Check1Click(Sender: TObject);
var
  ih, ifl, isol, i, ip, iprism, ipoly, icyl : Integer;
  total_power, total_power_s : Real;

begin
   MainMemo.Lines.Add('Already loaded material library: ');
   MainMemo.Lines.Add('SOLID : Al-Duralumin, GaN, SiC4H, Au80Sn20, Cu, MD40, GaAs, Au');
   MainMemo.Lines.Add('SiO2, Si, kovar (Co 17% Ni 29% Fe), Alumina (Polycor) ');
   MainMemo.Lines.Add('Brass (59-1-L), Polyimide (PI), Sapphire (Al2O3), Glue ECHES');
   MainMemo.Lines.Add('BeO, Ag, Diamond, Si3N4, KPT8, Polyurethane_foam');
   MainMemo.Lines.Add('SOLDER_PbSn2Ag2.5, SOLDER_SnAg25Sb10, SOLDER_SnPb36Ag2, GLUE_Ablebond_3230');
   MainMemo.Lines.Add('GLUE_Ablebond_8290, SOLDER_Au88Ge12, kanifoul, Polystyrene_rigid_R12');
   MainMemo.Lines.Add('FR4, Polystyrene_Typical, air_solid');
   MainMemo.Lines.Add('Gas : Dry_Air, Hydrogen_H2, Helium_He, Argon_Ar, Carbon_dioxide');
   MainMemo.Lines.Add('Liquid : Water280K, Water320K, Water360K.');
   MainMemo.Lines.Add('Reopen project, Orthotropy thermal conductivity, change priority blocks is supported.');


   ih:=0;
   ip:=0;
   ifl:=0;
   isol:=0;
   iprism:=0;
   ipoly:=0;
   icyl:=0;
   total_power:=0.0;
   total_power_s:=0.0;

   for i := 1 to lb-1 do
   begin
      // 30.07.2020
      if ((body[i].binternalRadiation=1)and(Laplas.egddata.itemper=3)) then
      begin  // network T solver
         // Вакуумные призмы работают только с методом Контрольного объёма.
         MainMemo.Lines.Add('ERROR!!! Model is incorrect.');
         MainMemo.Lines.Add(body[i].name+' internal Radiation ON.');
         MainMemo.Lines.Add('Temperature solver network T solver.');
         MainMemo.Lines.Add('Please select Temperature solver Control Volume Method.');
         MainMemo.Lines.Add('or turn OFF internal Radiation in body block '+ body[i].name);
         MainMemo.Lines.Add('synopsis: not compatible with user settings.');
      end;
      if ((body[i].binternalRadiation=1)and(Laplas.egddata.itemper=0)) then
      begin // off T solver
         // Вакуумные призмы работают только с методом Контрольного объёма.
         MainMemo.Lines.Add('ERROR!!! Model is incorrect.');
         MainMemo.Lines.Add(body[i].name+' internal Radiation ON.');
         MainMemo.Lines.Add('Temperature solver is none (OFF).');
         MainMemo.Lines.Add('Please select Temperature solver Control Volume Method.');
         MainMemo.Lines.Add('or turn OFF internal Radiation in body block '+ body[i].name);
         MainMemo.Lines.Add('synopsis: not compatible with user settings.');
      end;
      if ((body[i].binternalRadiation=1)and(Laplas.egddata.itemper=2)) then
      begin // Finite Element T solver
         // Вакуумные призмы работают только с методом Контрольного объёма.
         MainMemo.Lines.Add('ERROR!!! Model is incorrect.');
         MainMemo.Lines.Add(body[i].name+' internal Radiation ON.');
         MainMemo.Lines.Add('Temperature solver is Finite Element Method.');
         MainMemo.Lines.Add('Please select Temperature solver Control Volume Method.');
         MainMemo.Lines.Add('or turn OFF internal Radiation in body block '+ body[i].name);
         MainMemo.Lines.Add('synopsis: not compatible with user settings.');
      end;

      if (body[i].igeometry_type=0) then
      begin
         // PRISM
         inc(iprism);
         if ((abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS)*mlength*mlength*mlength<1.0e-40)) then
         begin
            ShowMessage('PRISM body['+IntToStr(i)+'] volume is bad:'+FloatToStr((abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS))));
         end;
      end;
      if (body[i].igeometry_type=1) then
      begin
         // CYLINDER
         inc(icyl);
         if (body[i].Hcyl*3.1415*(body[i].R_out_cyl*body[i].R_out_cyl-body[i].R_in_cyl*body[i].R_in_cyl)<1.0e-40) then
         begin
            ShowMessage('CYLINDER body['+IntToStr(i)+'] volume is bad:'+FloatToStr((abs(body[i].xE-body[i].xS)*abs(body[i].yE-body[i].yS)*abs(body[i].zE-body[i].zS))));
         end;
      end;
       if (body[i].igeometry_type=2) then
      begin
         // POLYGON
         inc(ipoly);
      end;
      if (body[i].itype=1) then
      begin
         // SOLID
        inc(isol);
      end;
      if (body[i].itype=2) then
      begin
         // HOLLOW
        inc(ih);
      end;
      if (body[i].itype=3) then
      begin
         // FLUID
        inc(ifl);
      end;
      if (abs(body[i].arr_power[0])>1.0e-30) then
      begin
        // Количество блоков с заданной тепловой мощностью отличной от нуля.
        inc(ip);
      end;
       total_power:= total_power+body[i].arr_power[0];
   end;
   for i := 0 to ls-1 do
   begin
       total_power_s:= total_power_s+source[i].Power;
   end;



   MainMemo.Lines.Add('Apriory quick model statistics:');
   MainMemo.Lines.Add('number of thermal power blocks lb_p='+IntToStr(ip));
   MainMemo.Lines.Add('number of sources ls='+IntToStr(ls));
   MainMemo.Lines.Add('number of blocks lb='+IntToStr(lb-1));
   MainMemo.Lines.Add('SOLID : ' +IntToStr(isol));
   MainMemo.Lines.Add('HOLLOW : '+IntToStr(ih));
   MainMemo.Lines.Add('FLUID : ' +IntToStr(ifl));
   MainMemo.Lines.Add('*******************************');
   MainMemo.Lines.Add('PRISM : '+IntToStr(iprism));
   MainMemo.Lines.Add('CYLINDER : '+IntToStr(icyl));
   MainMemo.Lines.Add('POLYGON : '+IntToStr(ipoly));
   MainMemo.Lines.Add('*******************************');
   MainMemo.Lines.Add('number of walls lw='+IntToStr(lw));
   MainMemo.Lines.Add('number of units lu='+IntToStr(lu));
   MainMemo.Lines.Add('Blocks integral power ='+FloatToStr(total_power)+' W');
   MainMemo.Lines.Add('Sources integral power ='+FloatToStr(total_power_s)+' W');
   MainMemo.Lines.Add('Full total power ='+FloatToStr(total_power+total_power_s)+' W');

   for i := 1 to lw-1 do
   begin
      if ((wall[i].bopening)and(wall[i].family=3)) then
      begin
         // family
         // 1 изотермическая стенка идеальный теплоотвод.
         // 3 Newton-Richman,
         // 4 Stefan Bolcman.
         MainMemo.Lines.Add('ERROR!!! Model is incorrect.');
         MainMemo.Lines.Add('wall.name='+wall[i].name);
         MainMemo.Lines.Add('wall flow condition bopening.');
         MainMemo.Lines.Add('wall thermal condition  Newton-Richman.');
         MainMemo.Lines.Add('synopsis: incompatible custom wall boundary conditions.');
      end;
       if ((wall[i].bopening)and(wall[i].family=4)) then
      begin
         // family
         // 1 изотермическая стенка идеальный теплоотвод.
         // 3 Newton-Richman,
         // 4 Stefan Bolcman.
         MainMemo.Lines.Add('ERROR!!! Model is incorrect.');
         MainMemo.Lines.Add('wall.name='+wall[i].name);
         MainMemo.Lines.Add('wall flow condition bopening.');
         MainMemo.Lines.Add('wall thermal condition  Stefan Bolcman.');
         MainMemo.Lines.Add('synopsis: incompatible custom wall boundary conditions.');
      end;
      if ((wall[i].bsymmetry)and(wall[i].family=1)) then
      begin
         // family
         // 1 изотермическая стенка идеальный теплоотвод.
         // 3 Newton-Richman,
         // 4 Stefan Bolcman.
         MainMemo.Lines.Add('ERROR!!! Model is incorrect.');
         MainMemo.Lines.Add('wall.name='+wall[i].name);
         MainMemo.Lines.Add('wall flow condition bsymmetry.');
         MainMemo.Lines.Add('wall thermal condition  Dirichlet.');
         MainMemo.Lines.Add('synopsis: incompatible custom wall boundary conditions.');
      end;
       if ((wall[i].bsymmetry)and(wall[i].family=3)) then
      begin
         // family
         // 1 изотермическая стенка идеальный теплоотвод.
         // 3 Newton-Richman,
         // 4 Stefan Bolcman.
         MainMemo.Lines.Add('ERROR!!! Model is incorrect.');
         MainMemo.Lines.Add('wall.name='+wall[i].name);
         MainMemo.Lines.Add('wall flow condition bsymmetry.');
         MainMemo.Lines.Add('wall thermal condition  Newton-Richman.');
         MainMemo.Lines.Add('synopsis: incompatible custom wall boundary conditions.');
      end;
       if ((wall[i].bsymmetry)and(wall[i].family=4)) then
      begin
         // family
         // 1 изотермическая стенка идеальный теплоотвод.
         // 3 Newton-Richman,
         // 4 Stefan Bolcman.
         MainMemo.Lines.Add('ERROR!!! Model is incorrect.');
         MainMemo.Lines.Add('wall.name='+wall[i].name);
         MainMemo.Lines.Add('wall flow condition bsymmetry.');
         MainMemo.Lines.Add('wall thermal condition  Stefan Bolcman.');
         MainMemo.Lines.Add('synopsis: incompatible custom wall boundary conditions.');
      end;
   end;

   // 24.07.2020  Дополнительные предупреждения связанные с пользовательскими несовместимыми
   //  параметрами решателя. Ограничения включенного неконформного сеточного интерфейса
   // mesh_assembles_separately.
    for i := 0 to lu-1 do
   begin
      if (myassembles[i].bmesh_assembles_separately and (EGDForm.CBFlow.Checked=true)) then
      begin
         MainMemo.Lines.Add('ERROR!!! Model is incorrect.');
         MainMemo.Lines.Add(myassembles[i].name +' is active and CFD computation is ON. ERROR!!!');
         MainMemo.Lines.Add('You should be turn OFF '+  myassembles[i].name +' bmesh_assembles_separately must be false');
         MainMemo.Lines.Add('synopsis: not compatible with user settings.');
      end;

       if (myassembles[i].bmesh_assembles_separately and (MeshForm.CheckBoxALICE.Checked=true)) then
      begin
         MainMemo.Lines.Add('ERROR!!! Model is incorrect.');
         MainMemo.Lines.Add(myassembles[i].name +' is active and Adaptive Local Refinement Mesh is ON. ERROR!!!');
         MainMemo.Lines.Add('You should be turn OFF '+  myassembles[i].name +' bmesh_assembles_separately must be false');
         MainMemo.Lines.Add('synopsis: not compatible with user settings.');
      end;

        if (myassembles[i].bmesh_assembles_separately and (EGDForm.ComboBoxTemperature.ItemIndex<>2)) then
      begin
         MainMemo.Lines.Add('ERROR!!! Model is incorrect.');
         MainMemo.Lines.Add(myassembles[i].name +' is active and Temperature solver not equal Finite Element Method. ERROR!!!');
         MainMemo.Lines.Add('You should be turn OFF '+  myassembles[i].name +' bmesh_assembles_separately must be false OR');
         MainMemo.Lines.Add('You should be Temperature solver selected Finite Element Method only.');
         MainMemo.Lines.Add('synopsis: not compatible with user settings.');
      end;
   end;

end;

procedure TLaplas.CheckBoxOnLithtClick(Sender: TObject);
begin
   if (CheckBoxOnLitht.Checked=true) then
   begin
      ButtonLightsApply.Visible:=true;
      CheckBoxPointSources.Visible:=true;
      chkGlobalAmbient.Visible:=true;
   end
   else
   begin
       ButtonLightsApply.Visible:=false;
       CheckBoxPointSources.Visible:=false;
       chkGlobalAmbient.Visible:=false;
   end;
end;

// Вращение или сдвиг, В зависимости от этого редактируем видимость элементов.
procedure TLaplas.CheckBoxrotationClick(Sender: TObject);
begin
    if (CheckBoxrotation.Checked) then
    begin
      EditstepMoveDirectional.Visible:=false;
      LabelstepMoveDirectional.Visible:=false;
    end
    else
    begin
       EditstepMoveDirectional.Visible:=true;
       LabelstepMoveDirectional.Visible:=true;
    end;
end;



procedure TLaplas.ButtonApplyClick(Sender: TObject);
var
  i,j, iob, iobass, iunionid : Integer;
  s, scop : String;
  r, r2 : Real;
  bOk : Boolean;
  xceo, yceo, zceo : Real;
  xbuf, ybuf, zbuf : Real;
begin
   // Двигать объект

   xceo:=0.0;
   yceo:=0.0;
   zceo:=0.0;
   for i := 1 to (lb-1) do
   begin
      xceo:=xceo+body[i].xS+body[i].xE;
      yceo:=yceo+body[i].yS+body[i].yE;
      zceo:=zceo+body[i].zS+body[i].zE;
   end;
   // Мы округляем до целого при поворотах чтобы не было щелей
   // при построении сетки.
   xceo:=round(xceo/(2*(lb-1)));
   yceo:=round(yceo/(2*(lb-1)));
   zceo:=round(zceo/(2*(lb-1)));


   s:=EditstepMoveDirectional.Text;
   bOk:=true;
   r:=FormVariables.my_real_convert(s,bOk);
   if (bOk) then
   begin
      if (CheckBoxMoveallObject.Checked) then
      begin
         // двигаем все объекты.
         case ComboBoxdirectionalmove.ItemIndex of
           0 : begin
                  // X
                  if (CheckBoxrotation.Checked) then
                  begin
                     // Вращение вокруг оси ох.
                      // Блоки.
                      for i := 0 to (lb-1) do
                      begin
                         //  прямая прямоугольная призма.
                         xbuf:=body[i].xS;
                         ybuf:=body[i].yS;
                         zbuf:=body[i].zS;
                         //body[i].yS:=yceo+ (ybuf-yceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //body[i].zS:=zceo - (ybuf-yceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                         body[i].yS:=yceo+(zbuf-zceo);
                         body[i].zS:=zceo - (ybuf-yceo);
                         body[i].syS:=FormatFloat('0.0000000',body[i].yS);
                         body[i].szS:=FormatFloat('0.0000000',body[i].zS);

                         xbuf:=body[i].xE;
                         ybuf:=body[i].yE;
                         zbuf:=body[i].zE;
                        // body[i].yE:=yceo+ (ybuf-yceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //body[i].zE:=zceo - (ybuf-yceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                         body[i].yE:=yceo+ (zbuf-zceo);
                         body[i].zE:=zceo - (ybuf-yceo);
                         body[i].syE:=FormatFloat('0.0000000',body[i].yE);
                         body[i].szE:=FormatFloat('0.0000000',body[i].zE);

                          // Цилиндр
                         xbuf:=body[i].xC;
                         ybuf:=body[i].yC;
                         zbuf:=body[i].zC;
                         //body[i].yC:=yceo+ (ybuf-yceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //body[i].zC:=zceo - (ybuf-yceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                         body[i].yC:=yceo+ (zbuf-zceo);
                         body[i].zC:=zceo - (ybuf-yceo);
                         body[i].syC:=FormatFloat('0.0000000',body[i].yC);
                         body[i].szC:=FormatFloat('0.0000000',body[i].zC);
                         if (body[i].iPlane=1) then
                         begin
                           //XY->XZ
                           body[i].iPlane:=2;

                           if (body[i].yE-body[i].yS>0.0) then
                           begin
                              body[i].Hcyl:=abs(body[i].Hcyl);
                              body[i].sHcyl:=FormatFloat('0.0000000',body[i].Hcyl);
                           end
                           else
                           begin
                              body[i].Hcyl:=-abs(body[i].Hcyl);
                              body[i].sHcyl:=FormatFloat('0.0000000',body[i].Hcyl);
                           end;
                         end
                         else if (body[i].iPlane=2) then
                         begin
                           // XZ->XY
                           body[i].iPlane:=1;


                           if (body[i].zE-body[i].zS>0.0) then
                           begin
                              body[i].Hcyl:=abs(body[i].Hcyl);
                              body[i].sHcyl:=FormatFloat('0.0000000',body[i].Hcyl);
                           end
                           else
                           begin
                              body[i].Hcyl:=-abs(body[i].Hcyl);
                              body[i].sHcyl:=FormatFloat('0.0000000',body[i].Hcyl);
                           end;
                         end;

                         // polygon
                         for j := 0 to body[i].nsizei-1 do
                         begin
                            xbuf:=body[i].xi[j];
                            ybuf:=body[i].yi[j];
                            zbuf:=body[i].zi[j];
                            //body[i].yi[j]:=yceo+ (ybuf-yceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                            //body[i].zi[j]:=zceo - (ybuf-yceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                            body[i].yi[j]:=yceo+ (zbuf-zceo);
                            body[i].zi[j]:=zceo - (ybuf-yceo);

                            if (body[i].iPlane_obj2=1) then
                            begin
                              //XY->XZ
                               if (body[i].yE-body[i].yS>0.0) then
                               begin
                                  body[i].hi[j]:=abs(body[i].hi[j]);
                               end
                               else
                               begin
                                  body[i].hi[j]:=-abs(body[i].hi[j]);
                               end;
                            end;

                            if (body[i].iPlane_obj2=2) then
                            begin
                               // XZ->XY
                               if (body[i].zE-body[i].zS>0.0) then
                               begin
                                  body[i].hi[j]:=abs(body[i].hi[j]);
                               end
                               else
                               begin
                                  body[i].hi[j]:=-abs(body[i].hi[j]);
                               end;
                            end;
                         end;
                         if (body[i].iPlane_obj2=1) then
                         begin
                           //XY->XZ
                           body[i].iPlane_obj2:=2;
                         end
                         else if (body[i].iPlane_obj2=2) then
                         begin
                           // XZ->XY
                          body[i].iPlane_obj2:=1;
                         end;

                      end;
                      // источники тепла
                      for i := 0 to (ls-1) do
                      begin
                         xbuf:=source[i].xS;
                         ybuf:=source[i].yS;
                         zbuf:=source[i].zS;
                         //source[i].yS:=yceo+ (ybuf-yceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //source[i].zS:=zceo - (ybuf-yceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                         source[i].yS:=yceo+ (zbuf-zceo);
                         source[i].zS:=zceo - (ybuf-yceo);
                         source[i].syS:=FormatFloat('0.0000000',source[i].yS);
                         source[i].szS:=FormatFloat('0.0000000',source[i].zS);

                         xbuf:=source[i].xE;
                         ybuf:=source[i].yE;
                         zbuf:=source[i].zE;
                         //source[i].yE:=yceo+ (ybuf-yceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //source[i].zE:=zceo - (ybuf-yceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                         source[i].yE:=yceo+ (zbuf-zceo);
                         source[i].zE:=zceo - (ybuf-yceo);
                         source[i].syE:=FormatFloat('0.0000000',source[i].yE);
                         source[i].szE:=FormatFloat('0.0000000',source[i].zE);

                          // 1 - XY, 2 - XZ, 3 -YZ
                         case source[i].iPlane of
                            1: begin
                              source[i].iPlane:=2; // XZ
                            end;
                            2 : begin
                              source[i].iPlane:=1; // XY
                            end;
                         end;
                      end;

                      // стенки
                      for i := 0 to (lw-1) do
                      begin

                         xbuf:=wall[i].xS;
                         ybuf:=wall[i].yS;
                         zbuf:=wall[i].zS;
                         //wall[i].yS:=yceo+ (ybuf-yceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //wall[i].zS:=zceo - (ybuf-yceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                         wall[i].yS:=yceo+ (zbuf-zceo);
                         wall[i].zS:=zceo - (ybuf-yceo);
                         wall[i].syS:=FormatFloat('0.0000000',wall[i].yS);
                         wall[i].szS:=FormatFloat('0.0000000',wall[i].zS);

                         xbuf:=wall[i].xE;
                         ybuf:=wall[i].yE;
                         zbuf:=wall[i].zE;
                         // wall[i].yE:=yceo+ (ybuf-yceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //wall[i].zE:=zceo - (ybuf-yceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                         wall[i].yE:=yceo+ (zbuf-zceo);
                         wall[i].zE:=zceo - (ybuf-yceo);
                         wall[i].syE:=FormatFloat('0.0000000',wall[i].yE);
                         wall[i].szE:=FormatFloat('0.0000000',wall[i].zE);

                         // 1 - XY, 2 - XZ, 3 -YZ
                         case wall[i].iPlane of
                            1: begin
                              wall[i].iPlane:=2; // XZ
                            end;
                            2 : begin
                              wall[i].iPlane:=1; // XY
                            end;
                         end;


                         wall[i].cabinet_depend:=0;
                         (*
                         case wall[i].cabinet_depend of
                         1 : begin
                              // minX
                         end;
                         2 : begin
                              // maxX
                         end;
                         3 : begin
                              // minY
                              //-> maxZ
                              wall[i].cabinet_depend:=6;
                         end;
                         4 : begin
                              // maxY
                              //->minZ
                              wall[i].cabinet_depend:=5;
                         end;
                         5 : begin
                              // minZ
                              //-> minY
                              wall[i].cabinet_depend:=3;
                         end;
                         6 : begin
                              // maxZ
                              //-> maxY
                              wall[i].cabinet_depend:=4;
                         end;
                         end;
                         *)
                      end;

                   end
                  else
                  begin
                     // преобразование сдвига

                  // Блоки.
                  for i := 1 to (lb-1) do
                  begin
                     // прямая прямоугольная призма.
                     body[i].xS:=body[i].xS+r;
                     body[i].xE:=body[i].xE+r;
                     body[i].sxS:=FormatFloat('0.0000000',body[i].xS);
                     body[i].sxE:=FormatFloat('0.0000000',body[i].xE);
                     // Цилиндр
                     body[i].xC:=body[i].xC+r;
                     body[i].sxC:=FormatFloat('0.000',body[i].xC);
                     // polygon
                     for j := 0 to body[i].nsizei-1 do
                     begin
                        body[i].xi[j]:=body[i].xi[j]+r;
                     end;
                  end;
                  // источники тепла
                  for i := 0 to (ls-1) do
                  begin
                     source[i].xS:=source[i].xS+r;
                     source[i].xE:=source[i].xE+r;
                     source[i].sxS:=FormatFloat('0.0000000',source[i].xS);
                     source[i].sxE:=FormatFloat('0.0000000',source[i].xE);
                  end;
                  // стенки
                   for i := 0 to (lw-1) do
                  begin
                     wall[i].xS:=wall[i].xS+r;
                     wall[i].xE:=wall[i].xE+r;
                     wall[i].sxS:=FormatFloat('0.0000000',wall[i].xS);
                     wall[i].sxE:=FormatFloat('0.0000000',wall[i].xE);
                  end;
                  end;
               end;
           1 : begin
                  // Y
                  if (CheckBoxrotation.Checked) then
                  begin
                     // Вращение вокруг оси оY.
                      // Блоки.
                      for i := 0 to (lb-1) do
                      begin
                         //  прямая прямоугольная призма.
                         xbuf:=body[i].xS;
                         ybuf:=body[i].yS;
                         zbuf:=body[i].zS;
                        //body[i].xS:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                        // body[i].zS:=zceo - (xbuf-xceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                         body[i].xS:=xceo+ (zbuf-zceo);
                         body[i].zS:=zceo - (xbuf-xceo);
                         body[i].sxS:=FormatFloat('0.0000000',body[i].xS);
                         body[i].szS:=FormatFloat('0.0000000',body[i].zS);

                         xbuf:=body[i].xE;
                         ybuf:=body[i].yE;
                         zbuf:=body[i].zE;
                         //body[i].xE:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //body[i].zE:=zceo - (xbuf-xceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                          body[i].xE:=xceo+ (zbuf-zceo);
                         body[i].zE:=zceo - (xbuf-xceo);
                         body[i].sxE:=FormatFloat('0.0000000',body[i].xE);
                         body[i].szE:=FormatFloat('0.0000000',body[i].zE);

                          // Цилиндр
                         xbuf:=body[i].xC;
                         ybuf:=body[i].yC;
                         zbuf:=body[i].zC;
                         //body[i].xC:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //body[i].zC:=zceo - (xbuf-xceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                         body[i].xC:=xceo+ (zbuf-zceo);
                         body[i].zC:=zceo - (xbuf-xceo);
                         body[i].sxC:=FormatFloat('0.0000000',body[i].xC);
                         body[i].szC:=FormatFloat('0.0000000',body[i].zC);
                         if (body[i].iPlane=3) then
                         begin
                           //YZ->XY
                           body[i].iPlane:=1;

                            if (body[i].zE-body[i].zS>0.0) then
                           begin
                              body[i].Hcyl:=abs(body[i].Hcyl);
                              body[i].sHcyl:=FormatFloat('0.0000000',body[i].Hcyl);
                           end
                           else
                           begin
                              body[i].Hcyl:=-abs(body[i].Hcyl);
                              body[i].sHcyl:=FormatFloat('0.0000000',body[i].Hcyl);
                           end;
                         end
                         else if (body[i].iPlane=1) then
                         begin
                           // XY->YZ
                           body[i].iPlane:=3;

                           if (body[i].xE-body[i].xS>0.0) then
                           begin
                              body[i].Hcyl:=abs(body[i].Hcyl);
                              body[i].sHcyl:=FormatFloat('0.0000000',body[i].Hcyl);
                           end
                           else
                           begin
                              body[i].Hcyl:=-abs(body[i].Hcyl);
                              body[i].sHcyl:=FormatFloat('0.0000000',body[i].Hcyl);
                           end;
                         end;

                          // polygon
                         for j := 0 to body[i].nsizei-1 do
                         begin
                            xbuf:=body[i].xi[j];
                            ybuf:=body[i].yi[j];
                            zbuf:=body[i].zi[j];
                           // body[i].xi[j]:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                           // body[i].zi[j]:=zceo - (xbuf-xceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                            body[i].xi[j]:=xceo+ (zbuf-zceo);
                            body[i].zi[j]:=zceo - (xbuf-xceo);
                            if (body[i].iPlane_obj2=3) then
                            begin
                               //YZ->XY
                               if (body[i].zE-body[i].zS>0.0) then
                               begin
                                  body[i].hi[j]:=abs(body[i].hi[j]);
                               end
                               else
                               begin
                                  body[i].hi[j]:=-abs(body[i].hi[j]);
                               end;
                            end;

                            if (body[i].iPlane_obj2=1) then
                            begin
                               // XY->YZ
                               if (body[i].xE-body[i].xS>0.0) then
                               begin
                                  body[i].hi[j]:=abs(body[i].hi[j]);
                               end
                               else
                               begin
                                  body[i].hi[j]:=-abs(body[i].hi[j]);
                               end;
                            end;
                         end;
                         if (body[i].iPlane_obj2=3) then
                         begin
                           //YZ->XY
                           body[i].iPlane_obj2:=1;
                         end
                         else if (body[i].iPlane_obj2=1) then
                         begin
                            // XY->YZ
                          body[i].iPlane_obj2:=3;
                         end;

                      end;
                      // источники тепла
                      for i := 0 to (ls-1) do
                      begin
                         xbuf:=source[i].xS;
                         ybuf:=source[i].yS;
                         zbuf:=source[i].zS;
                         //source[i].xS:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //source[i].zS:=zceo - (xbuf-xceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                         source[i].xS:=xceo+ (zbuf-zceo);
                         source[i].zS:=zceo - (xbuf-xceo);
                         source[i].sxS:=FormatFloat('0.0000000',source[i].xS);
                         source[i].szS:=FormatFloat('0.0000000',source[i].zS);

                         xbuf:=source[i].xE;
                         ybuf:=source[i].yE;
                         zbuf:=source[i].zE;
                         //source[i].xE:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //source[i].zE:=zceo - (xbuf-xceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                          source[i].xE:=xceo+ (zbuf-zceo);
                         source[i].zE:=zceo - (xbuf-xceo);
                         source[i].sxE:=FormatFloat('0.0000000',source[i].xE);
                         source[i].szE:=FormatFloat('0.0000000',source[i].zE);

                           // 1 - XY, 2 - XZ, 3 -YZ
                         case source[i].iPlane of
                            1: begin
                              source[i].iPlane:=3; // YZ
                            end;
                            3 : begin
                              source[i].iPlane:=1; // XY
                            end;
                         end;

                      end;

                      // стенки
                      for i := 0 to (lw-1) do
                      begin
                         xbuf:=wall[i].xS;
                         ybuf:=wall[i].yS;
                         zbuf:=wall[i].zS;
                         //wall[i].xS:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //wall[i].zS:=zceo - (xbuf-xceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                         wall[i].xS:=xceo+ (zbuf-zceo);
                         wall[i].zS:=zceo - (xbuf-xceo);
                         wall[i].sxS:=FormatFloat('0.0000000',wall[i].xS);
                         wall[i].szS:=FormatFloat('0.0000000',wall[i].zS);

                         xbuf:=wall[i].xE;
                         ybuf:=wall[i].yE;
                         zbuf:=wall[i].zE;
                         //wall[i].xE:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(zbuf-zceo)*sin(3.141*90/180);
                         //wall[i].zE:=zceo - (xbuf-xceo)*sin(3.141*90/180)+(zbuf-zceo)*cos(3.141*90/180);
                         wall[i].xE:=xceo+ (zbuf-zceo);
                         wall[i].zE:=zceo - (xbuf-xceo);
                         wall[i].sxE:=FormatFloat('0.0000000',wall[i].xE);
                         wall[i].szE:=FormatFloat('0.0000000',wall[i].zE);

                          // 1 - XY, 2 - XZ, 3 -YZ
                         case wall[i].iPlane of
                            1: begin
                              wall[i].iPlane:=3; // YZ
                            end;
                            3 : begin
                              wall[i].iPlane:=1; // XY
                            end;
                         end;

                          wall[i].cabinet_depend:=0;
                         (*
                          case wall[i].cabinet_depend of
                         1 : begin
                              // minX
                              //-> minZ
                              wall[i].cabinet_depend:=5;
                         end;
                         2 : begin
                              // maxX
                              //-> maxZ
                              wall[i].cabinet_depend:=6;
                         end;
                         3 : begin
                              // minY

                         end;
                         4 : begin
                              // maxY

                         end;
                         5 : begin
                              // minZ
                              //-> maxX
                              wall[i].cabinet_depend:=2;
                         end;
                         6 : begin
                              // maxZ
                              //-> minX
                              wall[i].cabinet_depend:=1;
                         end;
                         end;
                         *)
                      end;

                   end
                  else
                  begin
                  // Сдвиг перемещение.

                  // Блоки.
                  for i := 1 to (lb-1) do
                  begin
                     // прямая прямоугольная призма.
                     body[i].yS:=body[i].yS+r;
                     body[i].yE:=body[i].yE+r;
                     body[i].syS:=FormatFloat('0.0000000',body[i].yS);
                     body[i].syE:=FormatFloat('0.0000000',body[i].yE);
                     // Цилиндр
                     body[i].yC:=body[i].yC+r;
                     body[i].syC:=FormatFloat('0.000',body[i].yC);
                     // polygon
                     for j := 0 to body[i].nsizei-1 do
                     begin
                        body[i].yi[j]:=body[i].yi[j]+r;
                     end;
                  end;
                  // источники тепла
                  for i := 0 to (ls-1) do
                  begin
                     source[i].yS:=source[i].yS+r;
                     source[i].yE:=source[i].yE+r;
                     source[i].syS:=FormatFloat('0.0000000',source[i].yS);
                     source[i].syE:=FormatFloat('0.0000000',source[i].yE);
                  end;
                  // стенки
                   for i := 0 to (lw-1) do
                  begin
                     wall[i].yS:=wall[i].yS+r;
                     wall[i].yE:=wall[i].yE+r;
                     wall[i].syS:=FormatFloat('0.0000000',wall[i].yS);
                     wall[i].syE:=FormatFloat('0.0000000',wall[i].yE);
                  end;
                  end;
               end;
           2 : begin
                 // Z
                 if (CheckBoxrotation.Checked) then
                  begin
                     // Вращение вокруг оси оZ.
                      // Блоки.
                      for i := 0 to (lb-1) do
                      begin
                         //  прямая прямоугольная призма.
                         xbuf:=body[i].xS;
                         ybuf:=body[i].yS;
                         zbuf:=body[i].zS;
                         //body[i].xS:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(ybuf-yceo)*sin(3.141*90/180);
                         //body[i].yS:=yceo - (xbuf-xceo)*sin(3.141*90/180)+(ybuf-yceo)*cos(3.141*90/180);
                         body[i].xS:=xceo+ (ybuf-yceo);
                         body[i].yS:=yceo - (xbuf-xceo);
                         body[i].sxS:=FormatFloat('0.0000000',body[i].xS);
                         body[i].syS:=FormatFloat('0.0000000',body[i].yS);

                         xbuf:=body[i].xE;
                         ybuf:=body[i].yE;
                         zbuf:=body[i].zE;
                         //body[i].xE:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(ybuf-yceo)*sin(3.141*90/180);
                         //body[i].yE:=yceo - (xbuf-xceo)*sin(3.141*90/180)+(ybuf-yceo)*cos(3.141*90/180);
                          body[i].xE:=xceo+ (ybuf-yceo);
                         body[i].yE:=yceo - (xbuf-xceo);
                         body[i].sxE:=FormatFloat('0.0000000',body[i].xE);
                         body[i].syE:=FormatFloat('0.0000000',body[i].yE);

                          // Цилиндр
                         xbuf:=body[i].xC;
                         ybuf:=body[i].yC;
                         zbuf:=body[i].zC;
                         //body[i].xC:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(ybuf-yceo)*sin(3.141*90/180);
                         //body[i].yC:=yceo - (xbuf-xceo)*sin(3.141*90/180)+(ybuf-yceo)*cos(3.141*90/180);
                         body[i].xC:=xceo+ (ybuf-yceo);
                         body[i].yC:=yceo - (xbuf-xceo);
                         body[i].sxC:=FormatFloat('0.0000000',body[i].xC);
                         body[i].syC:=FormatFloat('0.0000000',body[i].yC);
                         if (body[i].iPlane=2) then
                         begin
                           //XZ->YZ
                           body[i].iPlane:=3;

                           if (body[i].xE-body[i].xS>0.0) then
                           begin
                              body[i].Hcyl:=abs(body[i].Hcyl);
                              body[i].sHcyl:=FormatFloat('0.0000000',body[i].Hcyl);
                           end
                           else
                           begin
                              body[i].Hcyl:=-abs(body[i].Hcyl);
                              body[i].sHcyl:=FormatFloat('0.0000000',body[i].Hcyl);
                           end;
                         end
                         else if (body[i].iPlane=3) then
                         begin
                           // YZ->XZ
                           body[i].iPlane:=2;

                            if (body[i].yE-body[i].yS>0.0) then
                           begin
                              body[i].Hcyl:=abs(body[i].Hcyl);
                              body[i].sHcyl:=FormatFloat('0.0000000',body[i].Hcyl);
                           end
                           else
                           begin
                              body[i].Hcyl:=-abs(body[i].Hcyl);
                              body[i].sHcyl:=FormatFloat('0.0000000',body[i].Hcyl);
                           end;
                         end;

                          // polygon
                         for j := 0 to body[i].nsizei-1 do
                         begin
                            xbuf:=body[i].xi[j];
                            ybuf:=body[i].yi[j];
                            zbuf:=body[i].zi[j];
                            //body[i].xi[j]:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(ybuf-yceo)*sin(3.141*90/180);
                            //body[i].yi[j]:=yceo - (xbuf-xceo)*sin(3.141*90/180)+(ybuf-yceo)*cos(3.141*90/180);
                            body[i].xi[j]:=xceo+ (ybuf-yceo);
                            body[i].yi[j]:=yceo - (xbuf-xceo);
                            if (body[i].iPlane_obj2=2) then
                            begin
                               //XZ->YZ
                               if (body[i].xE-body[i].xS>0.0) then
                               begin
                                  body[i].hi[j]:=abs(body[i].hi[j]);
                               end
                               else
                               begin
                                  body[i].hi[j]:=-abs(body[i].hi[j]);
                               end;
                            end;

                            if (body[i].iPlane_obj2=3) then
                            begin
                                // YZ->XZ
                               if (body[i].yE-body[i].yS>0.0) then
                               begin
                                  body[i].hi[j]:=abs(body[i].hi[j]);
                               end
                               else
                               begin
                                  body[i].hi[j]:=-abs(body[i].hi[j]);
                               end;
                            end;
                         end;
                         if (body[i].iPlane_obj2=2) then
                         begin
                            //XZ->YZ
                            body[i].iPlane_obj2:=3;
                         end
                         else if (body[i].iPlane_obj2=3) then
                         begin
                            // YZ->XZ
                            body[i].iPlane_obj2:=2;
                         end;

                      end;
                      // источники тепла
                      for i := 0 to (ls-1) do
                      begin
                         xbuf:=source[i].xS;
                         ybuf:=source[i].yS;
                         zbuf:=source[i].zS;
                         //source[i].xS:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(ybuf-yceo)*sin(3.141*90/180);
                         //source[i].yS:=yceo - (xbuf-xceo)*sin(3.141*90/180)+(ybuf-yceo)*cos(3.141*90/180);
                          source[i].xS:=xceo+ (ybuf-yceo);
                         source[i].yS:=yceo - (xbuf-xceo);
                         source[i].sxS:=FormatFloat('0.0000000',source[i].xS);
                         source[i].syS:=FormatFloat('0.0000000',source[i].yS);

                         xbuf:=source[i].xE;
                         ybuf:=source[i].yE;
                         zbuf:=source[i].zE;
                         //source[i].xE:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(ybuf-yceo)*sin(3.141*90/180);
                         //source[i].yE:=yceo - (xbuf-xceo)*sin(3.141*90/180)+(ybuf-yceo)*cos(3.141*90/180);
                         source[i].xE:=xceo+ (ybuf-yceo);
                         source[i].yE:=yceo - (xbuf-xceo);
                         source[i].sxE:=FormatFloat('0.0000000',source[i].xE);
                         source[i].syE:=FormatFloat('0.0000000',source[i].yE);

                         // 1 - XY, 2 - XZ, 3 -YZ
                         case source[i].iPlane of
                            2: begin
                              source[i].iPlane:=3; // YZ
                            end;
                            3 : begin
                              source[i].iPlane:=2; // XZ
                            end;
                         end;

                      end;

                      // стенки
                      for i := 0 to (lw-1) do
                      begin
                         xbuf:=wall[i].xS;
                         ybuf:=wall[i].yS;
                         zbuf:=wall[i].zS;
                         //wall[i].xS:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(ybuf-yceo)*sin(3.141*90/180);
                         //wall[i].yS:=yceo - (xbuf-xceo)*sin(3.141*90/180)+(ybuf-yceo)*cos(3.141*90/180);
                          wall[i].xS:=xceo+ (ybuf-yceo);
                         wall[i].yS:=yceo - (xbuf-xceo);
                         wall[i].sxS:=FormatFloat('0.0000000',wall[i].xS);
                         wall[i].syS:=FormatFloat('0.0000000',wall[i].yS);

                         xbuf:=wall[i].xE;
                         ybuf:=wall[i].yE;
                         zbuf:=wall[i].zE;
                         //wall[i].xE:=xceo+ (xbuf-xceo)*cos(3.141*90/180)+(ybuf-yceo)*sin(3.141*90/180);
                         //wall[i].yE:=yceo - (xbuf-xceo)*sin(3.141*90/180)+(ybuf-yceo)*cos(3.141*90/180);
                         wall[i].xE:=xceo+ (ybuf-yceo);
                         wall[i].yE:=yceo - (xbuf-xceo);
                         wall[i].sxE:=FormatFloat('0.0000000',wall[i].xE);
                         wall[i].syE:=FormatFloat('0.0000000',wall[i].yE);

                          // 1 - XY, 2 - XZ, 3 -YZ
                         case wall[i].iPlane of
                            2: begin
                              wall[i].iPlane:=3; // YZ
                            end;
                            3 : begin
                              wall[i].iPlane:=2; // XZ
                            end;
                         end;

                          wall[i].cabinet_depend:=0;
                         (*
                          case wall[i].cabinet_depend of
                         1 : begin
                              // minX
                              //-> maxY
                              wall[i].cabinet_depend:=4;
                         end;
                         2 : begin
                              // maxX
                              //-> minY
                              wall[i].cabinet_depend:=3;
                         end;
                         3 : begin
                              // minY
                              //->minX
                              wall[i].cabinet_depend:=1;
                         end;
                         4 : begin
                              // maxY
                              //->maxX
                              wall[i].cabinet_depend:=2;
                         end;
                         5 : begin
                              // minZ
                         end;
                         6 : begin
                              // maxZ
                         end;
                         end;
                         *)
                      end;

                   end
                  else
                  begin
                  // Сдвиг перемещение.


                  // Блоки.
                  for i := 1 to (lb-1) do
                  begin
                     // прямая прямоугольная призма.
                     body[i].zS:=body[i].zS+r;
                     body[i].zE:=body[i].zE+r;
                     body[i].szS:=FormatFloat('0.0000000',body[i].zS);
                     body[i].szE:=FormatFloat('0.0000000',body[i].zE);
                     // Цилиндр
                     body[i].zC:=body[i].zC+r;
                     body[i].szC:=FormatFloat('0.0000000',body[i].zC);
                     // polygon
                     for j := 0 to body[i].nsizei-1 do
                     begin
                        body[i].zi[j]:=body[i].zi[j]+r;
                     end;
                  end;
                  // источники тепла
                  for i := 0 to (ls-1) do
                  begin
                     source[i].zS:=source[i].zS+r;
                     source[i].zE:=source[i].zE+r;
                     source[i].szS:=FormatFloat('0.0000000',source[i].zS);
                     source[i].szE:=FormatFloat('0.0000000',source[i].zE);
                  end;
                  // стенки
                   for i := 0 to (lw-1) do
                  begin
                     wall[i].zS:=wall[i].zS+r;
                     wall[i].zE:=wall[i].zE+r;
                     wall[i].szS:=FormatFloat('0.0000000',wall[i].zS);
                     wall[i].szE:=FormatFloat('0.0000000',wall[i].zE);
                  end;
                  end;
               end;
         end;
     end
      else
     begin
        // Двигаем отдельный объект выделенный в дереве.
        // копированию подвергается только один объект,
        // имя данного объекта выделено в дереве.
        scop:=MainTreeView.Selected.Text;

          // по всем блокам
      iob:=-1;
      for i:=1 to (lb-1) do
      begin
         if ( (length(body[i].name) = length(scop)) and (Pos(body[i].name,scop)=1)) then
         begin
            iob:=i; // номер копируемого блока
         end;
      end;
      if (iob>-1) then
      begin
          case ComboBoxdirectionalmove.ItemIndex of
           0 : begin
                  // X
                  // прямая прямоугольная призма.
                     body[iob].xS:=body[iob].xS+r;
                     body[iob].xE:=body[iob].xE+r;
                     body[iob].sxS:=FormatFloat('0.0000000',body[iob].xS);
                     body[iob].sxE:=FormatFloat('0.0000000',body[iob].xE);
                     // Цилиндр
                     body[iob].xC:=body[iob].xC+r;
                     body[iob].sxC:=FormatFloat('0.0000000',body[iob].xC);
                     // polygon
                     for j := 0 to body[iob].nsizei-1 do
                     begin
                        body[iob].xi[j]:=body[iob].xi[j]+r;
                     end;
               end;
           1 : begin
                  // Y
                  // прямая прямоугольная призма.
                     body[iob].yS:=body[iob].yS+r;
                     body[iob].yE:=body[iob].yE+r;
                     body[iob].syS:=FormatFloat('0.0000000',body[iob].yS);
                     body[iob].syE:=FormatFloat('0.0000000',body[iob].yE);
                     // Цилиндр
                     body[iob].yC:=body[iob].yC+r;
                     body[iob].syC:=FormatFloat('0.0000000',body[iob].yC);
                     // polygon
                     for j := 0 to body[iob].nsizei-1 do
                     begin
                        body[iob].yi[j]:=body[iob].yi[j]+r;
                     end;
               end;
           2 : begin
                  // Z
                  // прямая прямоугольная призма.
                     body[iob].zS:=body[iob].zS+r;
                     body[iob].zE:=body[iob].zE+r;
                     body[iob].szS:=FormatFloat('0.0000000',body[iob].zS);
                     body[iob].szE:=FormatFloat('0.0000000',body[iob].zE);
                     // Цилиндр
                     body[iob].zC:=body[iob].zC+r;
                     body[iob].szC:=FormatFloat('0.0000000',body[iob].zC);
                     // polygon
                     for j := 0 to body[iob].nsizei-1 do
                     begin
                        body[iob].zi[j]:=body[iob].zi[j]+r;
                     end;
               end;
          end;
      end;

      // по всем источникам
      iob:=-1;
      for i:=0 to (ls-1) do
      begin
         if ( (length(source[i].name) = length(scop)) and (Pos(source[i].name,scop)=1)) then
         begin
            iob:=i; // номер копируемого  источника
         end;
      end;
      if (iob>-1) then
      begin
          case ComboBoxdirectionalmove.ItemIndex of
           0 : begin
                  // X
                  source[iob].xS:=source[iob].xS+r;
                  source[iob].xE:=source[iob].xE+r;
                  source[iob].sxS:=FormatFloat('0.0000000',source[iob].xS);
                  source[iob].sxE:=FormatFloat('0.0000000',source[iob].xE);
               end;
           1 : begin
                  // Y
                  source[iob].yS:=source[iob].yS+r;
                  source[iob].yE:=source[iob].yE+r;
                  source[iob].syS:=FormatFloat('0.0000000',source[iob].yS);
                  source[iob].syE:=FormatFloat('0.0000000',source[iob].yE);
               end;
           2 : begin
                  // Z
                  source[iob].zS:=source[iob].zS+r;
                  source[iob].zE:=source[iob].zE+r;
                  source[iob].szS:=FormatFloat('0.0000000',source[iob].zS);
                  source[iob].szE:=FormatFloat('0.0000000',source[iob].zE);
               end;
          end;
      end;

      // по всем стенкам
      iob:=-1;
      for i:=0 to (lw-1) do
      begin
         if ( (length(wall[i].name) = length(scop)) and (Pos(wall[i].name,scop)=1)) then
         begin
            if (wall[i].cabinet_depend=0) then
            begin
               iob:=i; // номер копируемой стенки
            end;
         end;
      end;
      if (iob>-1) then
      begin
         case ComboBoxdirectionalmove.ItemIndex of
           0 : begin
                  // X
                  wall[iob].xS:=wall[iob].xS+r;
                  wall[iob].xE:=wall[iob].xE+r;
                  wall[iob].sxS:=FormatFloat('0.0000000',wall[iob].xS);
                  wall[iob].sxE:=FormatFloat('0.0000000',wall[iob].xE);
               end;
           1 : begin
                  // Y
                  wall[iob].yS:=wall[iob].yS+r;
                  wall[iob].yE:=wall[iob].yE+r;
                  wall[iob].syS:=FormatFloat('0.0000000',wall[iob].yS);
                  wall[iob].syE:=FormatFloat('0.0000000',wall[iob].yE);
               end;
           2 : begin
                  // Z
                  wall[iob].zS:=wall[iob].zS+r;
                  wall[iob].zE:=wall[iob].zE+r;
                  wall[iob].szS:=FormatFloat('0.0000000',wall[iob].zS);
                  wall[iob].szE:=FormatFloat('0.0000000',wall[iob].zE);
               end;
          end;
      end;

      // По всем объединениям.
      iobass:=-1;
      for i:=0 to (lu-1) do
      begin
         if ( (length(myassembles[i].name) = length(scop)) and (Pos(myassembles[i].name,scop)=1)) then
         begin
            iobass:=i; // номер копируемого асемблеса
         end;
      end;
      if (iobass>-1) then
      begin
         iunionid:=myassembles[iobass].identifire;

         // Без рекурсивного многоуровневого проникновения вглюбь ассемблеса.

         // Создаём копии блоков принадлежащих юниону iunionid.
         for iob:=1 to lb-1 do
         begin
            if (body[iob].iunion=iunionid) then
            begin
               if (iob>-1) then
               begin
                  case ComboBoxdirectionalmove.ItemIndex of
                   0 : begin
                          // X
                          // прямая прямоугольная призма.
                          body[iob].xS:=body[iob].xS+r;
                          body[iob].xE:=body[iob].xE+r;
                          body[iob].sxS:=FormatFloat('0.0000000',body[iob].xS);
                          body[iob].sxE:=FormatFloat('0.0000000',body[iob].xE);
                          // Цилиндр
                          body[iob].xC:=body[iob].xC+r;
                          body[iob].sxC:=FormatFloat('0.0000000',body[iob].xC);
                          // polygon
                          for j := 0 to body[iob].nsizei-1 do
                          begin
                             body[iob].xi[j]:=body[iob].xi[j]+r;
                          end;
                       end;
                   1 : begin
                          // Y
                          // прямая прямоугольная призма.
                          body[iob].yS:=body[iob].yS+r;
                          body[iob].yE:=body[iob].yE+r;
                          body[iob].syS:=FormatFloat('0.0000000',body[iob].yS);
                          body[iob].syE:=FormatFloat('0.0000000',body[iob].yE);
                          // Цилиндр
                          body[iob].yC:=body[iob].yC+r;
                          body[iob].syC:=FormatFloat('0.0000000',body[iob].yC);
                          // polygon
                          for j := 0 to body[iob].nsizei-1 do
                          begin
                             body[iob].yi[j]:=body[iob].yi[j]+r;
                          end;
                       end;
                   2 : begin
                          // Z
                          // прямая прямоугольная призма.
                          body[iob].zS:=body[iob].zS+r;
                          body[iob].zE:=body[iob].zE+r;
                          body[iob].szS:=FormatFloat('0.0000000',body[iob].zS);
                          body[iob].szE:=FormatFloat('0.0000000',body[iob].zE);
                          // Цилиндр
                          body[iob].zC:=body[iob].zC+r;
                          body[iob].szC:=FormatFloat('0.0000000',body[iob].zC);
                          // polygon
                          for j := 0 to body[iob].nsizei-1 do
                          begin
                             body[iob].zi[j]:=body[iob].zi[j]+r;
                          end;
                       end;
                     end;

               end;
            end;
         end;

         // Создаём копии источников тепла принадлежащих юниону iunionid.
         for iob:=0 to ls-1 do
         begin
            if (source[iob].iunion=iunionid) then
            begin
               if (iob>-1) then
               begin

                  case ComboBoxdirectionalmove.ItemIndex of
                   0 : begin
                          // X
                          source[iob].xS:=source[iob].xS+r;
                          source[iob].xE:=source[iob].xE+r;
                          source[iob].sxS:=FormatFloat('0.0000000',source[iob].xS);
                          source[iob].sxE:=FormatFloat('0.0000000',source[iob].xE);
                       end;
                   1 : begin
                          // Y
                          source[iob].yS:=source[iob].yS+r;
                          source[iob].yE:=source[iob].yE+r;
                          source[iob].syS:=FormatFloat('0.0000000',source[iob].yS);
                          source[iob].syE:=FormatFloat('0.0000000',source[iob].yE);
                       end;
                   2 : begin
                         // Z
                         source[iob].zS:=source[iob].zS+r;
                         source[iob].zE:=source[iob].zE+r;
                         source[iob].szS:=FormatFloat('0.0000000',source[iob].zS);
                         source[iob].szE:=FormatFloat('0.0000000',source[iob].zE);
                       end;
                  end;
               end;
            end;
         end;

       // Создаём копии стенок принадлежащих юниону iunionid.
       for iob:=0 to lw-1 do
       begin
          if (wall[iob].iunion=iunionid) then
          begin
              if (iob>-1) then
              begin
                  case ComboBoxdirectionalmove.ItemIndex of
                    0 : begin
                           // X
                           wall[iob].xS:=wall[iob].xS+r;
                           wall[iob].xE:=wall[iob].xE+r;
                           wall[iob].sxS:=FormatFloat('0.0000000',wall[iob].xS);
                           wall[iob].sxE:=FormatFloat('0.0000000',wall[iob].xE);
                        end;
                    1 : begin
                           // Y
                           wall[iob].yS:=wall[iob].yS+r;
                           wall[iob].yE:=wall[iob].yE+r;
                           wall[iob].syS:=FormatFloat('0.0000000',wall[iob].yS);
                           wall[iob].syE:=FormatFloat('0.0000000',wall[iob].yE);
                        end;
                    2 : begin
                           // Z
                           wall[iob].zS:=wall[iob].zS+r;
                           wall[iob].zE:=wall[iob].zE+r;
                           wall[iob].szS:=FormatFloat('0.0000000',wall[iob].zS);
                           wall[iob].szE:=FormatFloat('0.0000000',wall[iob].zE);
                        end;
                  end;
              end;
          end;
       end;


      end;



     end;
   end
   else
   begin
     // Ошибка ввода величины смещения.
     EditstepMoveDirectional.Text:='0';
   end;
end;

// Преобразует исходный файл для программы tecxplot, так чтобы показать только то, что
// интересует пользователя.
procedure TLaplas.ButtonApplyVisualizationManagmentClick(Sender: TObject);
//var
   //f,f2 : TStringList; // переменная типа объект TStringList
   //s, sub : string;
   //i, istr, ielm, j, istrnow : Int64;
   //xa, xb, xc : Real;
   //nvalpic_loc, icurrentpic_loc, npic_loc, epic_loc, imarker_loc : Int64;
   //xpic_loc, ypic_loc, zpic_loc : array of Real;
   //istr_loc, iE_patch : Int64;
   //elmpic_loc : array of telmpic;
   //ravg, rmin, rmax : Real;
begin
   bVisualization_Management_now:=true;
   RunSolution1Click(Sender);

   MainMemo.Lines.Add('ALICEFlow0_07_Visualisation_Magement succsefully written. Ok.');

   (*
   // Преобразователь визуализации.
   //npic, epic : Integer;
    //xpic, ypic, zpic : array of Real;
    //temppic,lampic,hxpic, hypic, hzpic, hmagpic : array of Real;
    f:=TStringList.Create();
    f2:=TStringList.Create();
    // читает файл с геометрией и тепловыми полями и сохраняет эту
    // информацию в теле компьютерной программы-визуализатора.
    OpenDialog1.Filter:='Текстовые файлы|*.PLT';
    if (OpenDialog1.Execute and FileExists(OpenDialog1.FileName)) then
    begin
      // Результат успешный - пользователь выбрал файл.
      // Загружаем файл.
      istrnow:=0;
      f.LoadFromFile(OpenDialog1.FileName);

      if (FormatSettings.DecimalSeparator=',') then
      begin
         // заменить все точки в файле на запятые.
         for i:=0 to f.Count-1 do
         begin
            s:=f.Strings[i];
            f.Strings[i]:=StringReplace(s,'.',',',[rfReplaceAll]);
         end;
      end;


      s:=f.Strings[istrnow];
      inc(istrnow);
       while ((length(s)=0)) do
      begin
         s:=Trim(f.Strings[istrnow]);
         f2.Add(f.Strings[istrnow]);
         //f2.Strings[istrnow]:=f.Strings[istrnow];
         inc(istrnow);
      end;
      sub:=Copy(Trim(s),Pos('"',s)+1,Length(s)-1-Pos('"',s));
      Caption:=sub;

      s:=Trim(f.Strings[istrnow]);
      f2.Add(f.Strings[istrnow]);
      //f2.Strings[istrnow]:=f.Strings[istrnow];
      inc(istrnow);
      while ((length(s)=0)) do
      begin
         s:=Trim(f.Strings[istrnow]);
         f2.Add(f.Strings[istrnow]);
         //f2.Strings[istrnow]:=f.Strings[istrnow];
         inc(istrnow);
      end;

      //ShowMessage(s);
      nvalpic_loc:=0;
      for i := 1 to length(s) do
      begin
          if (s[i]=',') then
          begin
             inc(nvalpic_loc);
          end;
      end;
      // ShowMessage('ok');
      nvalpic_loc:=nvalpic_loc-2;
      icurrentpic_loc:=0; // Mesh
      //ShowMessage(IntToStr(nvalpic));
     // SetLength(temppicname,nvalpic+1);
      //temppicname[0]:='Mesh';
      //SetLength(temppicpotent,nvalpic);
      //SetLength(minimumpic,nvalpic);
      //SetLength(maximumpic,nvalpic);

       (*
      sub:=Copy(Trim(s),Pos('=',s)+1,Length(s)-Pos('=',s));
      s:=Trim(sub);
      sub:=Copy(s,1,Pos(',',s)-1);

      sub:=Copy(Trim(s),Pos(',',s)+1,Length(s));
      s:=Trim(sub);
      sub:=Copy(Trim(s),Pos(',',s)+1,Length(s));
      s:=Trim(sub);
      for j := 1 to nvalpic do
      begin
         sub:=Copy(Trim(s),Pos(',',s)+1,Length(s));
         s:=Trim(sub);
         if (Pos(',',s)<>0) then
         begin
             temppicname[j]:=Trim(Copy(s,1,Pos(',',s)-1));
         end
         else
         begin
            temppicname[j]:=Trim(s);
         end;
        // ShowMessage(temppicname[j]);
      end;

      ComboBoxVisibleVariable.Items.Clear;
      MainMemo.Lines.Add('Load fields:');
      for j := 0 to nvalpic do
      begin
         MainMemo.Lines.Add(temppicname[j]);
         ComboBoxVisibleVariable.Items.Add(temppicname[j]);
      end;
      ComboBoxVisibleVariable.Items.Add('Geom');
      ComboBoxVisibleVariable.ItemIndex:=0;
      *)
       (*
      s:=Trim(f.Strings[istrnow]);
      f2.Add(f.Strings[istrnow]);
      //f2.Strings[istrnow]:=f.Strings[istrnow];
      inc(istrnow);
       while ((length(s)=0)) do
      begin
         s:=Trim(f.Strings[istrnow]);
         f2.Add(f.Strings[istrnow]);
         //f2.Strings[istrnow]:=f.Strings[istrnow];
         inc(istrnow);
      end;

      imarker_loc:= istrnow-1;// Строка которая будет модифицирована т.к. E будет другим.

      sub:=Copy(Trim(s),Pos('N=',s)+2,Length(s)-1-Pos('N=',s));
      s:=Trim(sub);
      sub:=Copy(s,1,Pos(',',s)-1);
      npic_loc:=StrToInt64(sub);

      (*
      for j := 0 to nvalpic_loc-1 do
        begin
           SetLength(temppicpotent[j],npic);
        end;
        *)
       (*
      sub:=Copy(Trim(s),Pos('E=',s)+2,Length(s)-1-Pos('E=',s));
      s:=Trim(sub);
      sub:=Copy(s,1,Pos(',',s)-1);
      epic_loc:=StrToInt64(sub);

      SetLength(xpic_loc,npic_loc);
      SetLength(ypic_loc,npic_loc);
      SetLength(zpic_loc,npic_loc);

      // Мы ориентированы на файл с АЛИС сеткой.

     // ShowMessage('ok');
      SetLength(elmpic_loc,epic_loc);

      istr:=istrnow;
      // Считывание x.
      s:=Trim(f.Strings[istr]);

      for i:=1 to npic_loc do
      begin
            if (Length(Trim(s))=0) then
             begin
               f2.Add(f.Strings[istr]);
               //f2.Strings[istr]:=f.Strings[istr];
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;

          if (Pos(' ',s)=0) then
          begin
              xpic_loc[i-1]:=StrToFloat(s);
              f2.Add(f.Strings[istr]);
              //f2.Strings[istr]:=f.Strings[istr];
              inc(istr);
              s:=Trim(f.Strings[istr]);
          end
          else
          begin
             sub:=Copy(s,1,Pos(' ',s)-1);
             xpic_loc[i-1]:=StrToFloat(sub);
             s:=Copy(s,Pos(' ',s)+1,Length(s));
             if (Length(Trim(s))=0) then
             begin
              // f2.Strings[istr]:=f.Strings[istr];
               f2.Add(f.Strings[istr]);
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;
          end;
      end;
     // ShowMessage('ok');
      // Считывание y.
      for i:=1 to npic_loc do
      begin
          if (Length(Trim(s))=0) then
             begin
               //f2.Strings[istr]:=f.Strings[istr];
               f2.Add(f.Strings[istr]);
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;

          if (Pos(' ',s)=0) then
          begin
              ypic_loc[i-1]:=StrToFloat(s);
              //f2.Strings[istr]:=f.Strings[istr];
              f2.Add(f.Strings[istr]);
              inc(istr);
              s:=Trim(f.Strings[istr]);
          end
          else
          begin
             sub:=Copy(s,1,Pos(' ',s)-1);
             ypic_loc[i-1]:=StrToFloat(sub);
             s:=Copy(s,Pos(' ',s)+1,Length(s));
             if (Length(Trim(s))=0) then
             begin
               //f2.Strings[istr]:=f.Strings[istr];
               f2.Add(f.Strings[istr]);
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;
          end;
      end;
     // ShowMessage('ok');
      // Считывание z.
      for i:=1 to npic_loc do
      begin
          if (Length(Trim(s))=0) then
             begin
               //f2.Strings[istr]:=f.Strings[istr];
               f2.Add(f.Strings[istr]);
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;

          if (Pos(' ',s)=0) then
          begin
              zpic_loc[i-1]:=StrToFloat(s);
              //f2.Strings[istr]:=f.Strings[istr];
              f2.Add(f.Strings[istr]);
              inc(istr);
              s:=Trim(f.Strings[istr]);
          end
          else
          begin
             sub:=Copy(s,1,Pos(' ',s)-1);
             zpic_loc[i-1]:=StrToFloat(sub);
             s:=Copy(s,Pos(' ',s)+1,Length(s));
             if (Length(Trim(s))=0) then
             begin
               //f2.Strings[istr]:=f.Strings[istr];
               f2.Add(f.Strings[istr]);
               inc(istr);
               s:=Trim(f.Strings[istr]);
             end;
          end;
      end;
     // ShowMessage('ok');

      if (ComboBoxlength.ItemIndex=1) then
      begin
         // mm
         for i:=1 to npic_loc do
         begin
            xpic_loc[i-1]:=1000.0*xpic_loc[i-1];
            ypic_loc[i-1]:=1000.0*ypic_loc[i-1];
            zpic_loc[i-1]:=1000.0*zpic_loc[i-1];
         end;
      end;

       if (ComboBoxlength.ItemIndex=2) then
      begin
         // micron
         for i:=1 to npic_loc do
         begin
            xpic_loc[i-1]:=1000000.0*xpic_loc[i-1];
            ypic_loc[i-1]:=1000000.0*ypic_loc[i-1];
            zpic_loc[i-1]:=1000000.0*zpic_loc[i-1];
         end;
      end;


      // Считывание temperature.
      for j := 0 to nvalpic_loc-1 do
      begin

         for i:=1 to npic_loc do
         begin
            if (Length(Trim(s))=0) then
            begin
               //f2.Strings[istr]:=f.Strings[istr];
               f2.Add(f.Strings[istr]);
               inc(istr);
               s:=Trim(f.Strings[istr]);
            end;

            if (Pos(' ',s)=0) then
            begin
               //temppicpotent[j][i-1]:=StrToFloat(s);
               //f2.Strings[istr]:=f.Strings[istr];
               f2.Add(f.Strings[istr]);
               inc(istr);
               s:=Trim(f.Strings[istr]);
            end
             else
            begin
               sub:=Copy(s,1,Pos(' ',s)-1);
               //temppicpotent[j][i-1]:=StrToFloat(sub);
               s:=Copy(s,Pos(' ',s)+1,Length(s));
               if (Length(Trim(s))=0) then
               begin
                  //f2.Strings[istr]:=f.Strings[istr];
                  f2.Add(f.Strings[istr]);
                  inc(istr);
                  s:=Trim(f.Strings[istr]);
               end;
            end;
         end;

         (*
         // Определение максимального и минимального значения.
         minimumpic[j]:=1.0e30;
         maximumpic[j]:=-1.0e30;
         for i:=1 to npic do
         begin
           if (temppicpotent[j][i-1]<minimumpic[j]) then
           begin
              minimumpic[j]:=temppicpotent[j][i-1];
           end;
           if (temppicpotent[j][i-1]>maximumpic[j]) then
           begin
              maximumpic[j]:=temppicpotent[j][i-1];
           end;

         end;
         *) (*
      end;

      rmin:=StrToFloat(Editminimum.Text);
      rmax:=StrToFloat(Editmaximum.Text);
      iE_patch:=0;

       istr_loc:=istr;

      // Считывание конечных элементов.
       ielm:=0;
       for i := 1 to 8*epic_loc do
       begin
          if (Pos(' ',s)=0) then
          begin
             elmpic_loc[ielm].i8:=StrToInt64(Trim(s));

             case ComboBoxdirectional.ItemIndex of
                 0 : begin
                     // X
                     ravg:=0.125*(xpic_loc[elmpic_loc[ielm].i1-1]+xpic_loc[elmpic_loc[ielm].i2-1]+xpic_loc[elmpic_loc[ielm].i3-1]+xpic_loc[elmpic_loc[ielm].i4-1]+xpic_loc[elmpic_loc[ielm].i5-1]+xpic_loc[elmpic_loc[ielm].i6-1]+xpic_loc[elmpic_loc[ielm].i7-1]+xpic_loc[elmpic_loc[ielm].i8-1]);
                     if ((ravg>rmin)and(ravg<rmax)) then
                     begin
                         //f2.Strings[istr_loc]:=f.Strings[istr];
                         f2.Add(f.Strings[istr]);
                         inc(istr_loc);
                         inc(iE_patch);
                     end;
                 end;
                 1 : begin
                     // Y
                     ravg:=0.125*(ypic_loc[elmpic_loc[ielm].i1-1]+ypic_loc[elmpic_loc[ielm].i2-1]+ypic_loc[elmpic_loc[ielm].i3-1]+ypic_loc[elmpic_loc[ielm].i4-1]+ypic_loc[elmpic_loc[ielm].i5-1]+ypic_loc[elmpic_loc[ielm].i6-1]+ypic_loc[elmpic_loc[ielm].i7-1]+ypic_loc[elmpic_loc[ielm].i8-1]);
                      if ((ravg>rmin)and(ravg<rmax)) then
                     begin
                         //f2.Strings[istr_loc]:=f.Strings[istr];
                         f2.Add(f.Strings[istr]);
                         inc(istr_loc);
                         inc(iE_patch);
                     end;
                 end;
                 2 : begin
                     // Z
                     ravg:=0.125*(zpic_loc[elmpic_loc[ielm].i1-1]+zpic_loc[elmpic_loc[ielm].i2-1]+zpic_loc[elmpic_loc[ielm].i3-1]+zpic_loc[elmpic_loc[ielm].i4-1]+zpic_loc[elmpic_loc[ielm].i5-1]+zpic_loc[elmpic_loc[ielm].i6-1]+zpic_loc[elmpic_loc[ielm].i7-1]+zpic_loc[elmpic_loc[ielm].i8-1]);
                      if ((ravg>rmin)and(ravg<rmax)) then
                     begin
                         //f2.Strings[istr_loc]:=f.Strings[istr];
                         f2.Add(f.Strings[istr]);
                         inc(istr_loc);
                         inc(iE_patch);
                     end;
                 end;
              end;

             inc(istr);
             if (istr<f.Count) then
             begin
                s:=Trim(f.Strings[istr]);
             end;
             inc(ielm);
          end
          else
          begin
              sub:=Copy(s,1,Pos(' ',s)-1);
              if ((i-1) mod 8 = 0) then
              begin
                 elmpic_loc[ielm].i1:=StrToInt64(sub);
              end;
              if ((i-2) mod 8 = 0) then
              begin
                 elmpic_loc[ielm].i2:=StrToInt64(sub);
              end;
              if ((i-3) mod 8 = 0) then
              begin
                 elmpic_loc[ielm].i3:=StrToInt64(sub);
              end;
              if ((i-4) mod 8 = 0) then
              begin
                 elmpic_loc[ielm].i4:=StrToInt64(sub);
              end;
               if ((i-5) mod 8 = 0) then
              begin
                 elmpic_loc[ielm].i5:=StrToInt64(sub);
              end;
              if ((i-6) mod 8 = 0) then
              begin
                 elmpic_loc[ielm].i6:=StrToInt64(sub);
              end;
              if ((i-7) mod 8 = 0) then
              begin
                 elmpic_loc[ielm].i7:=StrToInt64(sub);
              end;
              if ((i-8) mod 8 =0) then
              begin
                 elmpic_loc[ielm].i8:=StrToInt64(sub);
                 inc(ielm);
              end;

              s:=Trim(Copy(s,Pos(' ',s)+1,Length(s)));

              if (Length(Trim(s))=0) then
              begin

              case ComboBoxdirectional.ItemIndex of
                 0 : begin
                     // X
                     ravg:=0.125*(xpic_loc[elmpic_loc[ielm-1].i1-1]+xpic_loc[elmpic_loc[ielm-1].i2-1]+xpic_loc[elmpic_loc[ielm-1].i3-1]+xpic_loc[elmpic_loc[ielm-1].i4-1]+xpic_loc[elmpic_loc[ielm-1].i5-1]+xpic_loc[elmpic_loc[ielm-1].i6-1]+xpic_loc[elmpic_loc[ielm-1].i7-1]+xpic_loc[elmpic_loc[ielm-1].i8-1]);
                     if ((ravg>rmin)and(ravg<rmax)) then
                     begin
                         //f2.Strings[istr_loc]:=f.Strings[istr];
                         f2.Add(f.Strings[istr]);
                         inc(istr_loc);
                         inc(iE_patch);
                     end;
                 end;
                 1 : begin
                     // Y
                     ravg:=0.125*(ypic_loc[elmpic_loc[ielm-1].i1-1]+ypic_loc[elmpic_loc[ielm-1].i2-1]+ypic_loc[elmpic_loc[ielm-1].i3-1]+ypic_loc[elmpic_loc[ielm-1].i4-1]+ypic_loc[elmpic_loc[ielm-1].i5-1]+ypic_loc[elmpic_loc[ielm-1].i6-1]+ypic_loc[elmpic_loc[ielm-1].i7-1]+ypic_loc[elmpic_loc[ielm-1].i8-1]);
                      if ((ravg>rmin)and(ravg<rmax)) then
                     begin
                         //f2.Strings[istr_loc]:=f.Strings[istr];
                         f2.Add(f.Strings[istr]);
                         inc(istr_loc);
                         inc(iE_patch);
                     end;
                 end;
                 2 : begin
                     // Z
                     ravg:=0.125*(zpic_loc[elmpic_loc[ielm-1].i1-1]+zpic_loc[elmpic_loc[ielm-1].i2-1]+zpic_loc[elmpic_loc[ielm-1].i3-1]+zpic_loc[elmpic_loc[ielm-1].i4-1]+zpic_loc[elmpic_loc[ielm-1].i5-1]+zpic_loc[elmpic_loc[ielm-1].i6-1]+zpic_loc[elmpic_loc[ielm-1].i7-1]+zpic_loc[elmpic_loc[ielm-1].i8-1]);
                      if ((ravg>rmin)and(ravg<rmax)) then
                     begin
                         //f2.Strings[istr_loc]:=f.Strings[istr];
                         f2.Add(f.Strings[istr]);
                         inc(istr_loc);
                         inc(iE_patch);
                     end;
                 end;
              end;


                inc(istr);
                if (istr<f.Count) then
                begin
                    s:=Trim(f.Strings[istr]);
                end;
              end;

          end;
       end;

       // Определение максимума и минимума за одно линейное сканирование.
       (*
       xminpic:=1.0e30;
       yminpic:=1.0e30;
       zminpic:=1.0e30;
       xmaxpic:=-1.0e30;
       ymaxpic:=-1.0e30;
       zmaxpic:=-1.0e30;

       for i := 1 to npic do
         begin
           if (xpic[i-1]<xminpic) then
           begin
             xminpic:=xpic[i-1];
           end;
           if (ypic[i-1]<yminpic) then
           begin
             yminpic:=ypic[i-1];
           end;
           if (zpic[i-1]<zminpic) then
           begin
             zminpic:=zpic[i-1];
           end;
            if (xpic[i-1]>xmaxpic) then
           begin
             xmaxpic:=xpic[i-1];
           end;
           if (ypic[i-1]>ymaxpic) then
           begin
             ymaxpic:=ypic[i-1];
           end;
           if (zpic[i-1]>zmaxpic) then
           begin
             zmaxpic:=zpic[i-1];
           end;
         end;

          perspectiveangle:=2.0*180.0*(arctan((0.25)/(Hscale)))/1.57079632679;
   xa:=-7990;
   xb:=7990;
   xc:=0;
   while (abs(perspectiveangle-return_Perspective_angle(xc))>0.01) do
   begin
     if ((perspectiveangle-return_Perspective_angle(xa))*(perspectiveangle-return_Perspective_angle(xc))<0) then
     begin
       xb:=xc;
       xc:=0.5*(xa+xb);
     end
     else
     begin
         xa:=xc;
         xc:=0.5*(xa+xb);
     end;
   end;
    perspectiveangle_counter:=xc;



       // центры двух систем координат совпадают
       //Oxc:=0.0;
       //Oyc:=0.0;
       //Ozc:=0.0;
   Oxc:=0.5*(xminpic+xmaxpic);
   Oyc:=0.5*(yminpic+ymaxpic);
   Ozc:=0.5*(zminpic+zmaxpic);

       f.Free;
       MainMemo.Lines.Add('temperature field is Done.');

       bvisiblepic:=true; // картинка визуализируется.
       bvisiblepicdubl:=true;
       *)  (*

       // Изменяем количество элементов в модели.
        f2.Strings[imarker_loc-1]:='ZONE T="Rampant", N='+IntToStr(npic_loc)+', E='+IntToStr(iE_patch)+', ET=BRICK, F=FEBLOCK';
        f2.SaveToFile('ALICEFlow0_07_Visualisation_Magement');
        f.Free;
        f2.Free;

       // Освобождение оперативной памяти.
       SetLength(xpic_loc,0);
       SetLength(ypic_loc,0);
       SetLength(zpic_loc,0);
       SetLength(elmpic_loc,0);
        MainMemo.Lines.Add('ALICEFlow0_07_Visualisation_Magement succsefully written. Ok.');


    end
    else
    begin
       // Освобождаем оперативную память.
       npic:=0;
       epic:=0;
       SetLength(xpic,npic);
       SetLength(ypic,npic);
       SetLength(zpic,npic);

       // Мы ориентированы на файл с АЛИС сеткой.
       SetLength(temppicpotent,0,npic);


       SetLength(elmpic,epic);

       bvisiblepic:=false; // картинка не визуализируется.
    end;
    *)

end;

procedure TLaplas.ButtonLightsApplyClick(Sender: TObject);
var
 s : String;
begin
   if (FormatSettings.DecimalSeparator='.') then
   begin
      s:=Editdopusk.Text;
      Editdopusk.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
       s:=Editdopusk2.Text;
      Editdopusk2.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));

      s:=Editmatt.Text;
      Editmatt.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
      s:=Editmr.Text;
      Editmr.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));

      s:=EditLamb0.Text;
      EditLamb0.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
      s:=EditSpecularL.Text;
      EditSpecularL.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
      s:=EditLdifuse.Text;
      EditLdifuse.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));




      s:=Editangle.Text;
     Editangle.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
       s:=Editexponent.Text;
     Editexponent.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));

      s:=EditX.Text;
     EditX.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
       s:=EditY.Text;
     EditY.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
   end;

   if (FormatSettings.DecimalSeparator=',') then
   begin
      s:=Editdopusk.Text;
      Editdopusk.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
      s:=Editdopusk2.Text;
      Editdopusk2.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));

      s:=Editmatt.Text;
      Editmatt.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
      s:=Editmr.Text;
      Editmr.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));

      s:=EditLamb0.Text;
     EditLamb0.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
      s:=EditSpecularL.Text;
     EditSpecularL.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
      s:=EditLdifuse.Text;
     EditLdifuse.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));




     s:=Editangle.Text;
     Editangle.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
       s:=Editexponent.Text;
     Editexponent.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));

      s:=EditX.Text;
     EditX.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
       s:=EditY.Text;
     EditY.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
   end;

   dopusk_gl1:=abs(StrToFloat(Editdopusk.Text));
   dopusk_gl2:=abs(StrToFloat(Editdopusk2.Text));
   matt:=abs(StrToFloat(Editmatt.Text));
   mr:=abs(StrToFloat(Editmr.Text));


   lamb:=abs(StrToFloat(EditLamb0.Text));
   lspec:=abs(StrToFloat(EditSpecularL.Text));
   ldiff:=abs(StrToFloat(EditLdifuse.Text));
   lithtangle:=abs(StrToFloat(Editangle.Text));
   lithtexponent:=abs(StrToFloat(Editexponent.Text));
   mldx:=StrToFloat(EditX.Text);
   mldy:=StrToFloat(Edity.Text);
end;

procedure TLaplas.ButtonMoveObjectCloseClick(Sender: TObject);
begin
   GroupBoxMoveObject.Visible:=false;
   cbbViewChange(Sender);
end;

// Переходим на панель со свойствами материала.
procedure TLaplas.btnMaterialClick(Sender: TObject);
begin
   GroupBoxLight.Visible:=False;
   grpmaterial_litht_prop.Visible:=True;
   grplitht1.Visible:=False;
end;

procedure TLaplas.btnreturnlight0Click(Sender: TObject);
begin
   grpmaterial_litht_prop.Visible:=False;
   GroupBoxLight.Visible:=True;
   grplitht1.Visible:=False;
end;

procedure TLaplas.btnApplayMatClick(Sender: TObject);
var
    s : string;
begin
    if (FormatSettings.DecimalSeparator='.') then
   begin
      s:=Edtamb.Text;
      Edtamb.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
       s:=EdtSpec.Text;
     EdtSpec.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
       s:=EdtEmis.Text;
     EdtEmis.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
      s:=Edtambmat.Text;
     Edtambmat.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
      s:=Edtdiffmat.Text;
     Edtdiffmat.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
   end;

   if (FormatSettings.DecimalSeparator=',') then
   begin
      s:=Edtamb.Text;
      Edtamb.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
       s:=EdtSpec.Text;
     EdtSpec.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
       s:=EdtEmis.Text;
     EdtEmis.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
      s:=Edtambmat.Text;
     Edtambmat.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
      s:=Edtdiffmat.Text;
     Edtdiffmat.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
   end;

   // Ввод свойств материала для модели освещения.
   glamb0:=abs(StrToFloat(Edtamb.Text));
   remis:=abs(StrToFloat(EdtEmis.Text));
   rspec:=abs(StrToFloat(EdtSpec.Text));
   rblick:=abs(StrToInt(Edtblick.Text));
   if (rblick>128) then rblick:=128;
    matdiff:=abs(StrToFloat(Edtdiffmat.Text));
   matamb:=abs(StrToFloat(Edtambmat.Text));
end;



procedure TLaplas.btnLight1Click(Sender: TObject);
begin
   GroupBoxLight.Visible:=False;
   grpmaterial_litht_prop.Visible:=False;
   grplitht1.Visible:=True;
end;

procedure TLaplas.btnreturnLight1Click(Sender: TObject);
begin
   GroupBoxLight.Visible:=True;
   grpmaterial_litht_prop.Visible:=False;
   grplitht1.Visible:=False;
end;

procedure TLaplas.BitBtnMoveClick(Sender: TObject);
begin
   //делаем видимой форму для операции MoveObject
   GroupBoxMoveObject.Visible:=true;
   GroupBoxVisualizationManagment.Visible:=false;
   // Делаем невидимыми параметры визуализации.
   GroupBoxLight.Visible:=False;
   grplitht1.Visible:=False;
   grpmaterial_litht_prop.Visible:=False;
   edtvalue.Visible:=False; // не предлагаем изо сечения.
   ComboBoxplaneViewSelect.Visible:=false;
   lblvalue.Visible:=False;
end;

procedure TLaplas.BitBtnScale_to_fitClick(Sender: TObject);
var
  xmin, xmax : Real;
  ymin, ymax : Real;
  zmin, zmax : Real;
  i : Integer;
  xa,xb,xc : Real;  // для метода дихтомии.
begin
   // Поиск центра.
   xmin:=1.0e30;
   ymin:=1.0e30;
   zmin:=1.0e30;
   xmax:=-1.0e30;
   ymax:=-1.0e30;
   zmax:=-1.0e30;
   if (bvisiblepic) then
   begin
      // Размеры геометрии заранее считанного файла.
      xmin:=xminpic;
      xmax:=xmaxpic;
      ymin:=yminpic;
      ymax:=ymaxpic;
      zmin:=zminpic;
      zmax:=zmaxpic;
   end
    else
   begin
   for i := 0 to lb-1 do
     begin
        if (body[i].xS<xmin) then
        begin
          xmin:=body[i].xS;
        end;
        if (body[i].yS<ymin) then
        begin
          ymin:=body[i].yS;
        end;
        if (body[i].zS<zmin) then
        begin
          zmin:=body[i].zS;
        end;
         if (body[i].xE>xmax) then
        begin
          xmax:=body[i].xE;
        end;
        if (body[i].yE>ymax) then
        begin
          ymax:=body[i].yE;
        end;
        if (body[i].zE>zmax) then
        begin
          zmax:=body[i].zE;
        end;
     end;
     for i := 0 to ls-1 do
     begin
        if (source[i].xS<xmin) then
        begin
          xmin:=source[i].xS;
        end;
        if (source[i].yS<ymin) then
        begin
          ymin:=source[i].yS;
        end;
        if (source[i].zS<zmin) then
        begin
          zmin:=source[i].zS;
        end;
         if (source[i].xE>xmax) then
        begin
          xmax:=source[i].xE;
        end;
        if (source[i].yE>ymax) then
        begin
          ymax:=source[i].yE;
        end;
        if (source[i].zE>zmax) then
        begin
          zmax:=source[i].zE;
        end;
     end;
     for i := 0 to lw-1 do
     begin
        if (wall[i].xS<xmin) then
        begin
          xmin:=wall[i].xS;
        end;
        if (wall[i].yS<ymin) then
        begin
          ymin:=wall[i].yS;
        end;
        if (wall[i].zS<zmin) then
        begin
          zmin:=wall[i].zS;
        end;
         if (wall[i].xE>xmax) then
        begin
          xmax:=wall[i].xE;
        end;
        if (wall[i].yE>ymax) then
        begin
          ymax:=wall[i].yE;
        end;
        if (wall[i].zE>zmax) then
        begin
          zmax:=wall[i].zE;
        end;
     end;
   end;
   // Масштабирование
   // Возвращение в исходный вид если визуализация глюканула.
   // perspectiveangle:=45.0;

   // Высота
   //Hscale*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS))
   // полуоснование
   //  0.25*sqrt(sqr(body[0].zE-body[0].zS)+sqr(body[0].yE-body[0].yS)+sqr(body[0].xE-body[0].xS))
   perspectiveangle:=2.0*180.0*(arctan((0.25)/(Hscale)))/1.57079632679;
   xa:=-7990;
   xb:=7990;
   xc:=0;
   while (abs(perspectiveangle-return_Perspective_angle(xc))>0.01) do
   begin
     if ((perspectiveangle-return_Perspective_angle(xa))*
     (perspectiveangle-return_Perspective_angle(xc))<0) then
     begin
        xb:=xc;
     end
     else
     begin
        xa:=xc;
     end;
     xc:=0.5*(xa+xb);
   end;
   perspectiveangle_counter:=xc;



   // центры двух систем координат совпадают
   //Oxc:=0.0;
   //Oyc:=0.0;
   //Ozc:=0.0;
   Oxc:=0.5*(xmin+xmax);
   Oyc:=0.5*(ymin+ymax);
   Ozc:=0.5*(zmin+zmax);
end;

// Включает  режим экономии электроэнергии и ресурса акумулятора.
procedure TLaplas.BitBtn1Click(Sender: TObject);
begin
   ecology_btn:=not(ecology_btn);
   if (ecology_btn) then
   begin
      // энергосбережение выключено.
      BitBtn1.Caption:='off';
   end
   else
   begin
      // режим экономии энергии и ресурса акумулятора.

      // энергосбережение включено.
      BitBtn1.Caption:='Eco';
   end;
end;

// Вызывает генератор сетки (Структурированной или АЛИС).
procedure TLaplas.BitBtn2Click(Sender: TObject);
begin
    // Вызов только сеточного генератора отдельно.
    bonly_mesh_gen_call:=true;
    RunSolution1Click(Sender);
end;

// Экспортирует в программу tecplot геометрию модели.
// Эта функция запрограммирована специально для написания отчётов,
// статей и плакатов.
procedure TLaplas.BitBtnVisibleTecplot360Click(Sender: TObject);
const
   epsilon = 1.0e-23;
var
  xpos, ypos, zpos : array of Real;
  i,j,i9, im, iE : Integer;
  x1,y1,z1 : Real;
  bfound : Boolean;
  filename : string; // имя записываемого файла
  f : TStringList; // переменная типа объект TStringList
  s : String; // текущая рабочая строка
  i0, i1, i2, i3, i4, i5, i6, i7 : Integer;
  bmirrorduplicatemaxx : Boolean;
  ilb_new : Integer;
  zazor : Real;
  bvisible_source : Boolean; // Визуализировать ли источники тепла.

begin

   bmirrorduplicatemaxx:=false;


   ilb_new:=lb;

   bvisible_source:=true; // false не визализируем.


   if ((ls>0)and(bvisible_source)) then
   begin



   // Источники тепла визуализируются прямоугольными
   // параллелепипедами по размеру источников тепла.
   ilb_new:=ilb_new+ls+1;
   SetLength(body,ilb_new);
   for i := lb to lb+ls do
   begin
      body[i].bvisible:=true;
      case source[i-lb].iPlane of
          1 : begin
                 // XY
                 body[i].xS:=source[i-lb].xS;
                 body[i].xE:=source[i-lb].xE;
                 body[i].yS:=source[i-lb].yS;
                 body[i].yE:=source[i-lb].yE;
                 zazor:=abs(body[i].xE-body[i].xS);
                 if (abs(body[i].yE-body[i].yS)<zazor) then
                 begin
                    zazor:=abs(body[i].yE-body[i].yS);
                 end;
                 zazor:=0.1*zazor;
                 body[i].zS:=source[i-lb].zS-zazor;
                 body[i].zE:=source[i-lb].zS+zazor;
              end;
          2 : begin
                 // XZ
                 body[i].xS:=source[i-lb].xS;
                 body[i].xE:=source[i-lb].xE;
                 body[i].zS:=source[i-lb].zS;
                 body[i].zE:=source[i-lb].zE;
                 zazor:=abs(body[i].xE-body[i].xS);
                 if (abs(body[i].zE-body[i].zS)<zazor) then
                 begin
                    zazor:=abs(body[i].zE-body[i].zS);
                 end;
                 zazor:=0.1*zazor;
                 body[i].yS:=source[i-lb].yS-zazor;
                 body[i].yE:=source[i-lb].yS+zazor;
              end;
          3 : begin
                 // YZ
                 body[i].zS:=source[i-lb].zS;
                 body[i].zE:=source[i-lb].zE;
                 body[i].yS:=source[i-lb].yS;
                 body[i].yE:=source[i-lb].yE;
                 zazor:=abs(body[i].zE-body[i].zS);
                 if (abs(body[i].yE-body[i].yS)<zazor) then
                 begin
                    zazor:=abs(body[i].yE-body[i].yS);
                 end;
                 zazor:=0.1*zazor;
                 body[i].xS:=source[i-lb].xS-zazor;
                 body[i].xE:=source[i-lb].xS+zazor;
              end;
      end;
   end;

   end
   else
   begin
     ilb_new:=lb;
   end;

   // Экспортирует в программу tecplot геометрию модели.
   im:=0;
   iE:=0;
   SetLength(xpos,im+1);
   SetLength(ypos,im+1);
   SetLength(zpos,im+1);

   im:=0;
   for i := 1 to ilb_new-1 do
   begin
       if (body[i].bvisible) then
        begin

       inc(iE);
       x1:=body[i].xS;
       y1:=body[i].yS;
       z1:=body[i].zS;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             bfound:=true;
          end;
       end;
       if (not(bfound)) then
       begin
          xpos[im]:=x1;
          ypos[im]:=y1;
          zpos[im]:=z1;
          inc(im);
          SetLength(xpos,im+1);
          SetLength(ypos,im+1);
          SetLength(zpos,im+1);
       end;

       x1:=body[i].xE;
       y1:=body[i].yS;
       z1:=body[i].zS;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             bfound:=true;
          end;
       end;
       if (not(bfound)) then
       begin
          xpos[im]:=x1;
          ypos[im]:=y1;
          zpos[im]:=z1;
          inc(im);
          SetLength(xpos,im+1);
          SetLength(ypos,im+1);
          SetLength(zpos,im+1);
       end;

       x1:=body[i].xE;
       y1:=body[i].yE;
       z1:=body[i].zS;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             bfound:=true;
          end;
       end;
       if (not(bfound)) then
       begin
          xpos[im]:=x1;
          ypos[im]:=y1;
          zpos[im]:=z1;
          inc(im);
          SetLength(xpos,im+1);
          SetLength(ypos,im+1);
          SetLength(zpos,im+1);
       end;

       x1:=body[i].xS;
       y1:=body[i].yE;
       z1:=body[i].zS;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             bfound:=true;
          end;
       end;
       if (not(bfound)) then
       begin
          xpos[im]:=x1;
          ypos[im]:=y1;
          zpos[im]:=z1;
          inc(im);
          SetLength(xpos,im+1);
          SetLength(ypos,im+1);
          SetLength(zpos,im+1);
       end;


        x1:=body[i].xS;
       y1:=body[i].yS;
       z1:=body[i].zE;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             bfound:=true;
          end;
       end;
       if (not(bfound)) then
       begin
          xpos[im]:=x1;
          ypos[im]:=y1;
          zpos[im]:=z1;
          inc(im);
          SetLength(xpos,im+1);
          SetLength(ypos,im+1);
          SetLength(zpos,im+1);
       end;

       x1:=body[i].xE;
       y1:=body[i].yS;
       z1:=body[i].zE;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             bfound:=true;
          end;
       end;
       if (not(bfound)) then
       begin
          xpos[im]:=x1;
          ypos[im]:=y1;
          zpos[im]:=z1;
          inc(im);
          SetLength(xpos,im+1);
          SetLength(ypos,im+1);
          SetLength(zpos,im+1);
       end;

       x1:=body[i].xE;
       y1:=body[i].yE;
       z1:=body[i].zE;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             bfound:=true;
          end;
       end;
       if (not(bfound)) then
       begin
          xpos[im]:=x1;
          ypos[im]:=y1;
          zpos[im]:=z1;
          inc(im);
          SetLength(xpos,im+1);
          SetLength(ypos,im+1);
          SetLength(zpos,im+1);
       end;

       x1:=body[i].xS;
       y1:=body[i].yE;
       z1:=body[i].zE;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             bfound:=true;
          end;
       end;
       if (not(bfound)) then
       begin
          xpos[im]:=x1;
          ypos[im]:=y1;
          zpos[im]:=z1;
          inc(im);
          SetLength(xpos,im+1);
          SetLength(ypos,im+1);
          SetLength(zpos,im+1);
       end;
   end;
   end;

   // записывает файл с геометрией задачи
   filename:='';
   if not InputQuery('Input name file', 'Please, enter name writing file',filename)
   then exit;

   f:=TStringList.Create();

   f.Add('TITLE = "ALICEFLOW0_24_PAPER_PLOT"');
   f.Add('VARIABLES = x, y, z');
   if (bmirrorduplicatemaxx) then
   begin
       f.Add('ZONE T="Rampant", N='+IntToStr(2*im)+', E='+IntToStr(2*iE)+', ET=BRICK, F=FEBLOCK');
   end
   else
   begin
      f.Add('ZONE T="Rampant", N='+IntToStr(im)+', E='+IntToStr(iE)+', ET=BRICK, F=FEBLOCK');
   end;
   f.Add(' ');

   s:='';
   for i := 0 to im-1 do
   begin
      s:=s+FloatToStr(xpos[i])+' ';
      if (i mod 10 = 0) then
      begin
         f.Add(s);
         s:='';
      end;
   end;
   f.Add(s);


   if (bmirrorduplicatemaxx) then
   begin
      s:='';
      for i := 0 to im-1 do
      begin
         s:=s+FloatToStr(xpos[i]+2*(body[0].xE-xpos[i]))+' ';
         if (i mod 10 = 0) then
         begin
            f.Add(s);
            s:='';
         end;
      end;
      f.Add(s);

   end;

   f.Add(' ');

   s:='';
   for i := 0 to im-1 do
   begin
      s:=s+FloatToStr(ypos[i])+' ';
      if (i mod 10 = 0) then
      begin
         f.Add(s);
         s:='';
      end;
   end;
   f.Add(s);


   if (bmirrorduplicatemaxx) then
   begin
      s:='';
      for i := 0 to im-1 do
      begin
         s:=s+FloatToStr(ypos[i])+' ';
         if (i mod 10 = 0) then
         begin
            f.Add(s);
            s:='';
         end;
      end;
      f.Add(s);

   end;

    f.Add(' ');

   s:='';
   for i := 0 to im-1 do
   begin
      s:=s+FloatToStr(zpos[i])+' ';
      if (i mod 10 = 0) then
      begin
         f.Add(s);
         s:='';
      end;
   end;
   f.Add(s);

   if (bmirrorduplicatemaxx) then
   begin
       s:='';
       for i := 0 to im-1 do
       begin
          s:=s+FloatToStr(zpos[i])+' ';
          if (i mod 10 = 0) then
          begin
             f.Add(s);
             s:='';
          end;
       end;
       f.Add(s);

   end;

   f.Add(' ');

    for i := 1 to ilb_new-1 do
   begin
    if (body[i].bvisible) then
        begin
       inc(iE);
       x1:=body[i].xS;
       y1:=body[i].yS;
       z1:=body[i].zS;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i0:=j+1;
             bfound:=true;
          end;
       end;


       x1:=body[i].xE;
       y1:=body[i].yS;
       z1:=body[i].zS;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i1:=j+1;
             bfound:=true;
          end;
       end;


       x1:=body[i].xE;
       y1:=body[i].yE;
       z1:=body[i].zS;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i2:=j+1;
             bfound:=true;
          end;
       end;


       x1:=body[i].xS;
       y1:=body[i].yE;
       z1:=body[i].zS;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i3:=j+1;
             bfound:=true;
          end;
       end;



        x1:=body[i].xS;
       y1:=body[i].yS;
       z1:=body[i].zE;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i4:=j+1;
             bfound:=true;
          end;
       end;


       x1:=body[i].xE;
       y1:=body[i].yS;
       z1:=body[i].zE;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i5:=j+1;
             bfound:=true;
          end;
       end;


       x1:=body[i].xE;
       y1:=body[i].yE;
       z1:=body[i].zE;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i6:=j+1;
             bfound:=true;
          end;
       end;


       x1:=body[i].xS;
       y1:=body[i].yE;
       z1:=body[i].zE;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i7:=j+1;
             bfound:=true;
          end;
       end;

        f.Add(IntToStr(i0)+' '+IntToStr(i1)+' '+IntToStr(i2)+' '+IntToStr(i3)+' '+IntToStr(i4)+' '+IntToStr(i5)+' '+IntToStr(i6)+' '+IntToStr(i7));
   end;
   end;

   if (bmirrorduplicatemaxx) then
   begin
       for i := 1 to ilb_new-1 do
   begin
    if (body[i].bvisible) then
        begin
       inc(iE);
       x1:=body[i].xS;
       y1:=body[i].yS;
       z1:=body[i].zS;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i0:=j+1+im;
             bfound:=true;
          end;
       end;


       x1:=body[i].xE;
       y1:=body[i].yS;
       z1:=body[i].zS;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i1:=j+1+im;
             bfound:=true;
          end;
       end;


       x1:=body[i].xE;
       y1:=body[i].yE;
       z1:=body[i].zS;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i2:=j+1+im;
             bfound:=true;
          end;
       end;


       x1:=body[i].xS;
       y1:=body[i].yE;
       z1:=body[i].zS;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i3:=j+1+im;
             bfound:=true;
          end;
       end;



        x1:=body[i].xS;
       y1:=body[i].yS;
       z1:=body[i].zE;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i4:=j+1+im;
             bfound:=true;
          end;
       end;


       x1:=body[i].xE;
       y1:=body[i].yS;
       z1:=body[i].zE;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i5:=j+1+im;
             bfound:=true;
          end;
       end;


       x1:=body[i].xE;
       y1:=body[i].yE;
       z1:=body[i].zE;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i6:=j+1+im;
             bfound:=true;
          end;
       end;


       x1:=body[i].xS;
       y1:=body[i].yE;
       z1:=body[i].zE;
       bfound:=false;
       for j := 0 to im-1 do
       begin
          if ((abs(xpos[j]-x1)<epsilon)and(abs(ypos[j]-y1)<epsilon)and(abs(zpos[j]-z1)<epsilon)) then
          begin
             i7:=j+1+im;
             bfound:=true;
          end;
       end;

        f.Add(IntToStr(i0)+' '+IntToStr(i1)+' '+IntToStr(i2)+' '+IntToStr(i3)+' '+IntToStr(i4)+' '+IntToStr(i5)+' '+IntToStr(i6)+' '+IntToStr(i7));
   end;

   end;




   end;

   SetLength(body,lb);

      // Дело в том что компилятор языка СИ понимает только точку
   // в качестве разделителя целой и дробной части, поэтому
   // если в системе windows установлена запятая в качестве разделителя
   // целой и дробной части то Delphi печатает все свои данные с разделителем запятая,
   // которая при передаче в си файл должна стать точкой.
   if (FormatSettings.DecimalSeparator=',') then
   begin
      // заменить все запятые в файле на точки.
      for i:=3 to f.Count-1 do
      begin
         s:=f.Strings[i];
         f.Strings[i]:=StringReplace(s,',','.',[rfReplaceAll]);
      end;
   end;

   f.SaveToFile(filename+'.PLT'); // сохранение результата
   f.Free;
   MainMemo.Lines.Add('File '+filename+'.PLT  successfully written.');

    if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe')) then
              begin
                 s:= 'C:\Program Files\Tecplot\Tecplot 360 EX 2017 R2\bin\tec360.exe '+filename+'.PLT';
                 WinExec(PAnsiChar(s),SW_SHOWNORMAL);
              end
         else
        begin
   if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe')) then
              begin
                 s:= 'C:\Program Files (x86)\Tecplot\Tec360 2009\bin\tec360.exe '+filename+'.PLT';
                 WinExec(PAnsiChar(s),SW_SHOWNORMAL);
              end
         else
        begin
           if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe')) then
           begin
              s:='C:\Program Files\Tecplot\Tecplot 360 EX 2014 R1\bin\tec360.exe '+filename+'.PLT';
              WinExec(PAnsiChar(s),SW_SHOWNORMAL);
           end
            else
           begin
                 if (FileExists('C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe')) then
                 begin
                    s:= 'C:\Program Files\Tecplot\Tecplot 360 EX 2015 R2\bin\tec360.exe '+filename+'.PLT';
                    WinExec(PAnsiChar(s),SW_SHOWNORMAL);
                 end
               else
              begin
                 if (FileExists('C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe')) then
                 begin
                    s:='C:\Program Files (x86)\Tecplot\Tec360 2008\bin\tec360.exe '+filename+'.PLT';
                    WinExec(PAnsiChar(s),SW_SHOWNORMAL);
                 end
                  else
                 begin
                    Laplas.MainMemo.Lines.Add('Tecplot 2008 or 2009 or 2014 or 2015 unfound.');
                 end;
              end;
           end;
        end;
        end;



end;

procedure TLaplas.btnApplayLight1Click(Sender: TObject);
var
   s : string;
begin
   // Считывание параметров для LIGHT1
   if (FormatSettings.DecimalSeparator='.') then
   begin
      s:=Edtmatt1.Text;
      Edtmatt1.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
      s:=Edtmr1.Text;
      Edtmr1.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));

      s:=EdtLamb1.Text;
      EdtLamb1.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
      s:=EdtSpecularLight1.Text;
      EdtSpecularLight1.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
      s:=Edtdifuse1.Text;
      Edtdifuse1.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));

      s:=Edtangle1.Text;
      Edtangle1.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
      s:=Edtexponent1.Text;
      Edtexponent1.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));

      s:=EdtX1.Text;
      EdtX1.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
      s:=EdtY1.Text;
      EdtY1.Text:=Trim(StringReplace(s,',','.',[rfReplaceAll]));
   end;

   if (FormatSettings.DecimalSeparator=',') then
   begin
      s:=Edtmatt1.Text;
      Edtmatt1.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
      s:=Edtmr1.Text;
      Edtmr1.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));

      s:=EdtLamb1.Text;
      EdtLamb1.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
      s:=EdtSpecularLight1.Text;
      EdtSpecularLight1.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
      s:=Edtdifuse1.Text;
      Edtdifuse1.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));

      s:=Edtangle1.Text;
      Edtangle1.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
      s:=Edtexponent1.Text;
      Edtexponent1.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));

      s:=EdtX1.Text;
      EdtX1.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
      s:=EdtY1.Text;
      EdtY1.Text:=Trim(StringReplace(s,'.',',',[rfReplaceAll]));
   end;


   matt1:=abs(StrToFloat(Edtmatt1.Text));
   mr1:=abs(StrToFloat(Edtmr1.Text));


   lamb1:=abs(StrToFloat(EdtLamb1.Text));
   lspec1:=abs(StrToFloat(EdtSpecularLight1.Text));
   ldiff1:=abs(StrToFloat(Edtdifuse1.Text));
   lithtangle1:=abs(StrToFloat(Edtangle1.Text));
   lithtexponent1:=abs(StrToFloat(Edtexponent1.Text));
   mldx1:=StrToFloat(EdtX1.Text);
   mldy1:=StrToFloat(EdtY1.Text);
end;



procedure TLaplas.import1Click(Sender: TObject);
begin
    bperenapravlenie_na_import:=true;
    // импортирование геометрической модели или слияние моделей в одну
    read1Click(Sender);
    bperenapravlenie_na_import:=false;
end;


end.
