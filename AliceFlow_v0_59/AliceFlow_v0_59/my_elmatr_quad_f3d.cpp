// Файл my_elmatr_quad_f.c 
// сборка матрицы для обобщённого
// уравнения конвекции-диффузии на 
// совмещённой сетке.

#pragma once
#ifndef MY_ELMATR_QUAD_F3D_C
#define MY_ELMATR_QUAD_F3D_C 1


#include "my_interpolate_v0_07.cpp" // формулы для интерполяции.

// аппроксимация конвективного члена A(|P|)
#include "my_approx_convective.c" // по умолчанию номер BULG

#include "my_approx_convective2.c" // аппроксимация конвективного и диффузионного члена

// Схема пятого порядка для конвекции weno5 (13-14).01.2021.
#include "weno5.cpp"


const unsigned char distsheme = 100; // константа перехода от старой схемы к новой


#include "greengauss.c" // вычисление градиента величины

#include "avtosave.c" // автосохранение и возобновление счёта.

#include "rhie_chow.cpp" // поправка Рхи-Чоу 1983 г.

// Проверка узла на существование.
//CHECK_NODE_FOR_EXISTENCE
bool CHECK_NODE_FOR_EXISTENCE(integer iP) {
	if ((iP != NON_EXISTENT_NODE) && (iP >= 0)) return true;
	return false;
} // CHECK_NODE

#include "SpallartAllmares.cpp" // RANS Спалларт Аллмарес [1992].
#include "MenterSST.cpp" // RANS SST Ментер [1993].
#include "Standart_KE.cpp" // RANS Двухслойная модель на основе стандартной k-epsilon модели турбулентности [2001].


  // revised 22.11.2019
bool check_nvtx_order1(integer iP, int** nvtx,
	TOCHKA* pa)
{
	bool border1 = false;// порядок нарушен

	typedef struct TIsortCheck {
		TOCHKA_FLOAT pa;
		integer key;

		TIsortCheck() {
			//TOCHKA pa;
			key=-1;
		}
	} IsortCheck;

	IsortCheck* array1 = new IsortCheck[8];
	for (integer i_1 = 0; i_1 < 8; i_1++) {
		array1[i_1].key = i_1;
		array1[i_1].pa.x = (float)(pa[nvtx[i_1][iP] - 1].x);
		array1[i_1].pa.y = (float)(pa[nvtx[i_1][iP] - 1].y);
		array1[i_1].pa.z = (float)(pa[nvtx[i_1][iP] - 1].z);
	}
	// Пузырьковая сортировка
	// сортировка по z
	for (integer j_1 = 1; j_1 <= 7; j_1++) {
		bool bF = false;
		for (integer i_1 = 7; i_1 >= j_1; i_1--) {
			if ((array1[i_1 - 1].pa.z > array1[i_1].pa.z)) {
				// swap
				IsortCheck  buf;
				buf = array1[i_1 - 1];
				array1[i_1 - 1] = array1[i_1];
				array1[i_1] = buf;
				bF = true;
			}
		}
		if (bF) break;
	}
	// Пузырьковая сортировка
	// сортировка по y нижней части
	for (integer j_1 = 1; j_1 <= 3; j_1++) {
		bool bF = false;
		for (integer i_1 = 3; i_1 >= j_1; i_1--) {
			if ((array1[i_1 - 1].pa.y > array1[i_1].pa.y)) {
				// swap
				IsortCheck  buf;
				buf = array1[i_1 - 1];
				array1[i_1 - 1] = array1[i_1];
				array1[i_1] = buf;
				bF = true;
			}
		}
		if (bF) break;
	}
	// Пузырьковая сортировка
	// сортировка по y верхней части
	for (integer j_1 = 5; j_1 <= 7; j_1++) {
		bool bF = false;
		for (integer i_1 = 7; i_1 >= j_1; i_1--) {
			if ((array1[i_1 - 1].pa.y > array1[i_1].pa.y)) {
				// swap
				IsortCheck  buf;
				buf = array1[i_1 - 1];
				array1[i_1 - 1] = array1[i_1];
				array1[i_1] = buf;
				bF = true;
			}
		}
		if (bF) break;
	}
	if (array1[0].pa.x > array1[1].pa.x) {
		IsortCheck  buf;
		buf = array1[0];
		array1[0] = array1[1];
		array1[1] = buf;
	}
	if (array1[2].pa.x > array1[3].pa.x) {
		IsortCheck  buf;
		buf = array1[2];
		array1[2] = array1[3];
		array1[3] = buf;
	}
	if (array1[4].pa.x > array1[5].pa.x) {
		IsortCheck  buf;
		buf = array1[4];
		array1[4] = array1[5];
		array1[5] = buf;
	}
	if (array1[6].pa.x > array1[7].pa.x) {
		IsortCheck  buf;
		buf = array1[6];
		array1[6] = array1[7];
		array1[7] = buf;
	}
	// проверка
	bool bflag = true;
	for (integer i_1 = 0; i_1 < 7; i_1++) if (array1[i_1 + 1].key < array1[i_1].key) {
		// Проверяет начальную гипотезу о порядке нумерации в nvtx.
		//printf("ERROR !!! order in Thermal_Structural_assemble in node iP=%lld\n", iP);
		//system("pause");
		bflag = false;
	}
	if (bflag) {
		// нумерация
		// min z
		// 2 3     3 4
		// 0 1 или 1 2
		// max z
		// 6 7     7 8
		// 4 5 или 5 6
		if (0) {
			printf("numeration: \n");
			printf(" 2 3   6 7  \n");
			printf(" 0 1   4 5  \n");
			printf("____________\n");
		}
		border1 = true;
	}

	delete[]  array1;
	return border1;
} // check_nvtx_order1

  // revised 22.11.2019
bool check_nvtx_order2(integer iP, int** nvtx,
	TOCHKA* pa)
{
	bool border2 = false;// порядок нарушен

	typedef struct TIsortCheck {
		TOCHKA_FLOAT pa;
		integer key;

		TIsortCheck() {
			//TOCHKA pa;
			key=-1;
		}
	} IsortCheck;

	IsortCheck* array1 = new IsortCheck[8];
	for (integer i_1 = 0; i_1 < 8; i_1++) {
		array1[i_1].key = i_1;
		array1[i_1].pa.x = (float)(pa[nvtx[i_1][iP] - 1].x);
		array1[i_1].pa.y = (float)(pa[nvtx[i_1][iP] - 1].y);
		array1[i_1].pa.z = (float)(pa[nvtx[i_1][iP] - 1].z);
	}
	// Пузырьковая сортировка
	// сортировка по z
	for (integer j_1 = 1; j_1 <= 7; j_1++) {
		bool bF = false;
		for (integer i_1 = 7; i_1 >= j_1; i_1--) {
			if ((array1[i_1-1].pa.z>array1[i_1].pa.z)) {
				// swap
				IsortCheck  buf;
				buf = array1[i_1-1];
				array1[i_1-1] = array1[i_1];
				array1[i_1] = buf;
				bF = true;
			}
		}
		if (bF) break;
	}
	// Пузырьковая сортировка
	// сортировка по y нижней части
	for (integer j_1 = 1; j_1 <= 3; j_1++) {
		bool bF = false;
		for (integer i_1 = 3; i_1 >= j_1; i_1--) {
			if ((array1[i_1-1].pa.y>array1[i_1].pa.y)) {
				// swap
				IsortCheck  buf;
				buf = array1[i_1-1];
				array1[i_1-1] = array1[i_1];
				array1[i_1] = buf;
				bF = true;
			}
		}
		if (bF) break;
	}
	// Пузырьковая сортировка
	// сортировка по y верхней части
	for (integer j_1 = 5; j_1 <= 7; j_1++) {
		bool bF = false;
		for (integer i_1 = 7; i_1 >= j_1; i_1--) {
			if ((array1[i_1-1].pa.y>array1[i_1].pa.y)) {
				// swap
				IsortCheck  buf;
				buf = array1[i_1-1];
				array1[i_1-1] = array1[i_1];
				array1[i_1] = buf;
				bF = true;
			}
		}
		if (bF) break;
	}
	if (array1[0].pa.x > array1[1].pa.x) {
		IsortCheck  buf;
		buf = array1[0];
		array1[0] = array1[1];
		array1[1] = buf;
	}
	if (array1[3].pa.x > array1[2].pa.x) {
		IsortCheck  buf;
		buf = array1[2];
		array1[2] = array1[3];
		array1[3] = buf;
	}
	if (array1[4].pa.x > array1[5].pa.x) {
		IsortCheck  buf;
		buf = array1[4];
		array1[4] = array1[5];
		array1[5] = buf;
	}
	if (array1[7].pa.x > array1[6].pa.x) {
		IsortCheck  buf;
		buf = array1[6];
		array1[6] = array1[7];
		array1[7] = buf;
	}
	// проверка
	bool bflag = true;
	for (integer i_1 = 0; i_1 < 7; i_1++) if (array1[i_1 + 1].key < array1[i_1].key) {
		// Проверяет начальную гипотезу о порядке нумерации в nvtx.
		//printf("ERROR !!! order in Thermal_Structural_assemble in node iP=%lld\n", iP);
		//system("pause");
		bflag = false;
	}
	if (bflag) {
		// нумерация
		// min z
		// 2 3     3 4
		// 0 1 или 1 2
		// max z
		// 6 7     7 8
		// 4 5 или 5 6
		if (0) {
			printf("numeration: \n");
			printf(" 3 2   7 6  \n");
			printf(" 0 1   4 5  \n");
			printf("____________\n");
		}
		border2 = true;
	}

	delete[]  array1;

	return border2;

} // check_nvtx_order2


// Вычисление первой производной величины в точности в центре грани КО
doublereal DFDXiP(doublereal* potent, integer iP, integer G,
	int*** neighbors_for_the_internal_node, integer maxelm,
	         int** nvtx, TOCHKA* pa, bool &bborder) {

	bborder=false; // по умолчанию строго внутренний узел вдали от границ.

	integer iG, iGG, ibackG;
	bool bG=false, bbackG=false, bGG=false;
	TOCHKA pointP;
	doublereal x1, x2, x3, x4, f1, f2, f3, f4, xg;
	doublereal dx=0.0, dy=0.0, dz=0.0;
	volume3D(iP, nvtx, pa, dx, dy, dz);
	doublereal dx1=0.0, dy1=0.0, dz1=0.0;
	doublereal DFDXgran=0.0;

	
	// parabola_MNK, line_MNK, cubic_parabola
	ORDER_INTERPOLATION imetod=parabola_MNK;

	switch (G) {
	case E_SIDE:  iG=neighbors_for_the_internal_node[E_SIDE][0][iP];
		      if (iG>=maxelm) bG=true;
			  if (bG) {
				  bGG=true;
			  }
			  else {
				  iGG=neighbors_for_the_internal_node[E_SIDE][0][iG];
				  if (iGG>=maxelm) bGG=true;
			  }
			  ibackG=neighbors_for_the_internal_node[W_SIDE][0][iP];
			  if (ibackG>=maxelm) bbackG=true;

			  if (!bG && !bGG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.x;
				  center_cord3D(ibackG,nvtx,pa,pointP,W_SIDE);
				  x1=pointP.x;
				  center_cord3D(iG,nvtx,pa,pointP,E_SIDE);
				  x3=pointP.x;
				  center_cord3D(iGG,nvtx,pa,pointP,EE_SIDE);
				  x4=pointP.x;
				  xg=x2+0.5*dx;
				  f1=potent[ibackG];
				  f2=potent[iP];
				  f3=potent[iG];
				  f4=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				  bborder=false;
			  }

			  if (!bG && bGG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.x;
				  center_cord3D(ibackG,nvtx,pa,pointP,W_SIDE);
				  x1=pointP.x;
				  center_cord3D(iG,nvtx,pa,pointP,E_SIDE);
				  x3=pointP.x;
				  volume3D(iG, nvtx, pa, dx1, dy1, dz1);
				  x4=pointP.x+0.5*dx1;
				  xg=x2+0.5*dx;
				  f1=potent[ibackG];
				  f2=potent[iP];
				  f3=potent[iG];
				  f4=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				  bborder=true;
			  }

			  if (!bG && !bGG && bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.x;
				  volume3D(iP, nvtx, pa, dx1, dy1, dz1);
				  x1=x2-0.5*dx1;
				  center_cord3D(iG,nvtx,pa,pointP,E_SIDE);
				  x3=pointP.x;
				  center_cord3D(iGG,nvtx,pa,pointP,EE_SIDE);
				  x4=pointP.x;
				  xg=x2+0.5*dx;
				  f1=potent[ibackG];
				  f2=potent[iP];
				  f3=potent[iG];
				  f4=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				  bborder=true;
			  }

			  if (bG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.x;
				  center_cord3D(ibackG,nvtx,pa,pointP,W_SIDE);
				  x1=pointP.x;
				  xg=x3=x2+0.5*dx;
				  f1=potent[ibackG];
				  f2=potent[iP];
				  f3=potent[iG];

				  DFDXgran=DFDXg2(x1, x2, x3, xg, f1, f2, f3);
				  bborder=true;
			  }

		    break;
		case N_SIDE:  iG=neighbors_for_the_internal_node[N_SIDE][0][iP];
		      if (iG>=maxelm) bG=true;
			  if (bG) {
				  bGG=true;
			  }
			  else {
				  iGG=neighbors_for_the_internal_node[N_SIDE][0][iG];
				  if (iGG>=maxelm) bGG=true;
			  }
			  ibackG=neighbors_for_the_internal_node[S_SIDE][0][iP];
			  if (ibackG>=maxelm) bbackG=true;

			  if (!bG && !bGG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.y;
				  center_cord3D(ibackG,nvtx,pa,pointP,S_SIDE);
				  x1=pointP.y;
				  center_cord3D(iG,nvtx,pa,pointP,N_SIDE);
				  x3=pointP.y;
				  center_cord3D(iGG,nvtx,pa,pointP,NN_SIDE);
				  x4=pointP.y;
				  xg=x2+0.5*dy;
				  f1=potent[ibackG];
				  f2=potent[iP];
				  f3=potent[iG];
				  f4=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=false;
			  }

			  if (!bG && bGG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.y;
				  center_cord3D(ibackG,nvtx,pa,pointP,S_SIDE);
				  x1=pointP.y;
				  center_cord3D(iG,nvtx,pa,pointP,N_SIDE);
				  x3=pointP.y;
				  volume3D(iG, nvtx, pa, dx1, dy1, dz1);
				  x4=pointP.y+0.5*dy1;
				  xg=x2+0.5*dy;
				  f1=potent[ibackG];
				  f2=potent[iP];
				  f3=potent[iG];
				  f4=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				  bborder=true;
			  }

			  if (!bG && !bGG && bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.y;
				  volume3D(iP, nvtx, pa, dx1, dy1, dz1);
				  x1=x2-0.5*dy1;
				  center_cord3D(iG,nvtx,pa,pointP,N_SIDE);
				  x3=pointP.y;
				  center_cord3D(iGG,nvtx,pa,pointP,NN_SIDE);
				  x4=pointP.y;
				  xg=x2+0.5*dy;
				  f1=potent[ibackG];
				  f2=potent[iP];
				  f3=potent[iG];
				  f4=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				  bborder=true;
			  }

			  if (bG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.y;
				  center_cord3D(ibackG,nvtx,pa,pointP,S_SIDE);
				  x1=pointP.y;
				  xg=x3=x2+0.5*dy;
				  f1=potent[ibackG];
				  f2=potent[iP];
				  f3=potent[iG];

				  DFDXgran=DFDXg2(x1, x2, x3, xg, f1, f2, f3);
				  bborder=true;
			  }

		    break;
	 	 
		case T_SIDE:   iG=neighbors_for_the_internal_node[T_SIDE][0][iP];
		      if (iG>=maxelm) bG=true;
			  if (bG) {
				  bGG=true;
			  }
			  else {
				  iGG=neighbors_for_the_internal_node[T_SIDE][0][iG];
				  if (iGG>=maxelm) bGG=true;
			  }
			  ibackG=neighbors_for_the_internal_node[B_SIDE][0][iP];
			  if (ibackG>=maxelm) bbackG=true;

			  if (!bG && !bGG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.z;
				  center_cord3D(ibackG,nvtx,pa,pointP,B_SIDE);
				  x1=pointP.z;
				  center_cord3D(iG,nvtx,pa,pointP,T_SIDE);
				  x3=pointP.z;
				  center_cord3D(iGG,nvtx,pa,pointP,TT_SIDE);
				  x4=pointP.z;
				  xg=x2+0.5*dz;
				  f1=potent[ibackG];
				  f2=potent[iP];
				  f3=potent[iG];
				  f4=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=false;
			  }

			  if (!bG && bGG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.z;
				  center_cord3D(ibackG,nvtx,pa,pointP,B_SIDE);
				  x1=pointP.z;
				  center_cord3D(iG,nvtx,pa,pointP,T_SIDE);
				  x3=pointP.z;
				  volume3D(iG, nvtx, pa, dx1, dy1, dz1);
				  x4=pointP.z+0.5*dz1;
				  xg=x2+0.5*dz;
				  f1=potent[ibackG];
				  f2=potent[iP];
				  f3=potent[iG];
				  f4=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=true;
			  }

			  if (!bG && !bGG && bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.z;
				  volume3D(iP, nvtx, pa, dx1, dy1, dz1);
				  x1=x2-0.5*dz1;
				  center_cord3D(iG,nvtx,pa,pointP,T_SIDE);
				  x3=pointP.z;
				  center_cord3D(iGG,nvtx,pa,pointP,TT_SIDE);
				  x4=pointP.z;
				  xg=x2+0.5*dz;
				  f1=potent[ibackG];
				  f2=potent[iP];
				  f3=potent[iG];
				  f4=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=true;
			  }

			  if (bG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.z;
				  center_cord3D(ibackG,nvtx,pa,pointP,B_SIDE);
				  x1=pointP.z;
				  xg=x3=x2+0.5*dz;
				  f1=potent[ibackG];
				  f2=potent[iP];
				  f3=potent[iG];

				  DFDXgran=DFDXg2(x1, x2, x3, xg, f1, f2, f3);
				   bborder=true;
			  }

		    break;

		case W_SIDE:  iG=neighbors_for_the_internal_node[W_SIDE][0][iP];
		      if (iG>=maxelm) bG=true;
			  if (bG) {
				  bGG=true;
			  }
			  else {
				  iGG=neighbors_for_the_internal_node[W_SIDE][0][iG];
				  if (iGG>=maxelm) bGG=true;
			  }
			  ibackG=neighbors_for_the_internal_node[E_SIDE][0][iP];
			  if (ibackG>=maxelm) bbackG=true;

			  if (!bG && !bGG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x3=pointP.x;
				  center_cord3D(ibackG,nvtx,pa,pointP,E_SIDE);
				  x4=pointP.x;
				  center_cord3D(iG,nvtx,pa,pointP,W_SIDE);
				  x2=pointP.x;
				  center_cord3D(iGG,nvtx,pa,pointP,WW_SIDE);
				  x1=pointP.x;
				  xg=x3-0.5*dx;
				  f4=potent[ibackG];
				  f3=potent[iP];
				  f2=potent[iG];
				  f1=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=false;
			  }

			  if (!bG && bGG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x3=pointP.x;
				  center_cord3D(ibackG,nvtx,pa,pointP,E_SIDE);
				  x4=pointP.x;
				  center_cord3D(iG,nvtx,pa,pointP,W_SIDE);
				  x2=pointP.x;
				  volume3D(iG, nvtx, pa, dx1, dy1, dz1);
				  x1=pointP.x-0.5*dx1;
				  xg=x3-0.5*dx;
				  f4=potent[ibackG];
				  f3=potent[iP];
				  f2=potent[iG];
				  f1=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=true;
			  }

			  if (!bG && !bGG && bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x3=pointP.x;
				  volume3D(iP, nvtx, pa, dx1, dy1, dz1);
				  x4=x3+0.5*dx1;
				  center_cord3D(iG,nvtx,pa,pointP,W_SIDE);
				  x2=pointP.x;
				  center_cord3D(iGG,nvtx,pa,pointP,WW_SIDE);
				  x1=pointP.x;
				  xg=x3-0.5*dx;
				  f4=potent[ibackG];
				  f3=potent[iP];
				  f2=potent[iG];
				  f1=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=true;
			  }

			  if (bG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.x;
				  center_cord3D(ibackG,nvtx,pa,pointP,E_SIDE);
				  x3=pointP.x;
				  xg=x1=x2-0.5*dx;
				  f3=potent[ibackG];
				  f2=potent[iP];
				  f1=potent[iG];

				  DFDXgran=DFDXg2(x1, x2, x3, xg, f1, f2, f3);
				   bborder=true;
			  }

		    break;

		case S_SIDE:  iG=neighbors_for_the_internal_node[S_SIDE][0][iP];
		      if (iG>=maxelm) bG=true;
			  if (bG) {
				  bGG=true;
			  }
			  else {
				  iGG=neighbors_for_the_internal_node[S_SIDE][0][iG];
				  if (iGG>=maxelm) bGG=true;
			  }
			  ibackG=neighbors_for_the_internal_node[N_SIDE][0][iP];
			  if (ibackG>=maxelm) bbackG=true;

			  if (!bG && !bGG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x3=pointP.y;
				  center_cord3D(ibackG,nvtx,pa,pointP,N_SIDE);
				  x4=pointP.y;
				  center_cord3D(iG,nvtx,pa,pointP,S_SIDE);
				  x2=pointP.y;
				  center_cord3D(iGG,nvtx,pa,pointP,SS_SIDE);
				  x1=pointP.y;
				  xg=x3-0.5*dy;
				  f4=potent[ibackG];
				  f3=potent[iP];
				  f2=potent[iG];
				  f1=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=false;
			  }

			  if (!bG && bGG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x3=pointP.y;
				  center_cord3D(ibackG,nvtx,pa,pointP,N_SIDE);
				  x4=pointP.y;
				  center_cord3D(iG,nvtx,pa,pointP,S_SIDE);
				  x2=pointP.y;
				  volume3D(iG, nvtx, pa, dx1, dy1, dz1);
				  x1=pointP.y-0.5*dy1;
				  xg=x3-0.5*dy;
				  f4=potent[ibackG];
				  f3=potent[iP];
				  f2=potent[iG];
				  f1=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=true;
			  }

			  if (!bG && !bGG && bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x3=pointP.y;
				  volume3D(iP, nvtx, pa, dx1, dy1, dz1);
				  x4=x3+0.5*dy1;
				  center_cord3D(iG,nvtx,pa,pointP,S_SIDE);
				  x2=pointP.y;
				  center_cord3D(iGG,nvtx,pa,pointP,SS_SIDE);
				  x1=pointP.y;
				  xg=x3-0.5*dy;
				  f4=potent[ibackG];
				  f3=potent[iP];
				  f2=potent[iG];
				  f1=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=true;
			  }

			  if (bG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.y;
				  center_cord3D(ibackG,nvtx,pa,pointP,N_SIDE);
				  x3=pointP.y;
				  xg=x1=x2-0.5*dy;
				  f3=potent[ibackG];
				  f2=potent[iP];
				  f1=potent[iG];

				  DFDXgran=DFDXg2(x1, x2, x3, xg, f1, f2, f3);
				   bborder=true;
			  }

		    break;

			case B_SIDE:  iG=neighbors_for_the_internal_node[B_SIDE][0][iP];
		      if (iG>=maxelm) bG=true;
			  if (bG) {
				  bGG=true;
			  }
			  else {
				  iGG=neighbors_for_the_internal_node[B_SIDE][0][iG];
				  if (iGG>=maxelm) bGG=true;
			  }
			  ibackG=neighbors_for_the_internal_node[T_SIDE][0][iP];
			  if (ibackG>=maxelm) bbackG=true;

			  if (!bG && !bGG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x3=pointP.z;
				  center_cord3D(ibackG,nvtx,pa,pointP,T_SIDE);
				  x4=pointP.z;
				  center_cord3D(iG,nvtx,pa,pointP,B_SIDE);
				  x2=pointP.z;
				  center_cord3D(iGG,nvtx,pa,pointP,BB_SIDE);
				  x1=pointP.z;
				  xg=x3-0.5*dz;
				  f4=potent[ibackG];
				  f3=potent[iP];
				  f2=potent[iG];
				  f1=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=false;
			  }

			  if (!bG && bGG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x3=pointP.z;
				  center_cord3D(ibackG,nvtx,pa,pointP,T_SIDE);
				  x4=pointP.z;
				  center_cord3D(iG,nvtx,pa,pointP,B_SIDE);
				  x2=pointP.z;
				  volume3D(iG, nvtx, pa, dx1, dy1, dz1);
				  x1=pointP.z-0.5*dz1;
				  xg=x3-0.5*dz;
				  f4=potent[ibackG];
				  f3=potent[iP];
				  f2=potent[iG];
				  f1=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=true;
			  }

			  if (!bG && !bGG && bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x3=pointP.z;
				  volume3D(iP, nvtx, pa, dx1, dy1, dz1);
				  x4=x3+0.5*dz1;
				  center_cord3D(iG,nvtx,pa,pointP,B_SIDE);
				  x2=pointP.z;
				  center_cord3D(iGG,nvtx,pa,pointP,BB_SIDE);
				  x1=pointP.z;
				  xg=x3-0.5*dz;
				  f4=potent[ibackG];
				  f3=potent[iP];
				  f2=potent[iG];
				  f1=potent[iGG];

				  DFDXgran=DFDXg(x1, x2, x3, x4, xg, f1, f2, f3, f4, imetod);
				   bborder=true;
			  }

			  if (bG && !bbackG) {
				  center_cord3D(iP,nvtx,pa,pointP,100);
				  x2=pointP.z;
				  center_cord3D(ibackG,nvtx,pa,pointP,T_SIDE);
				  x3=pointP.z;
				  xg=x1=x2-0.5*dz;
				  f3=potent[ibackG];
				  f2=potent[iP];
				  f1=potent[iG];

				  DFDXgran=DFDXg2(x1, x2, x3, xg, f1, f2, f3);
				   bborder=true;
			  }

		    break;


	} // end switch


	return DFDXgran;

} // DFDXiP

// учёт граничных условий для скорости
void my_elmatr_quad_F3D_bound(integer inumber, integer maxelm, 
							  bool bDirichlet, BOUND* border_neighbor, integer ls, integer lw,
							  WALL* w, integer iVar, equation3D_bon* &slb, doublereal dbeta,
							  TOCHKA* pa, int** nvtx, float** prop_b, float** prop,
							  doublereal** potent, VISCOSITY_MODEL iflowregime
							  ) {

     // iVar - компонента скорости для которой задаётся граничное условие.

     // bDirichlet   осуществляется сборка только граничных условий Дирихле.
     // bDirichlet == false осуществляется сборка только однородных условий Неймана.

     // inumber - номер граничного КО.
	 // inumber изменяется от 0..maxbound-1

    /*
	for (integer i=0; i<lw; i++) {
		if (w[i].bsymmetry) {
		  printf("symmetry \n");
		}
		if (w[i].bpressure) {
		  printf("bpressure \n");
		}
	}
	getchar(); // debug;
	*/

	// Алгоритм.
	/* 1. Условие дирихле. Это обязательно стенка. не условие симметрии и не выходная граница bpressure.
       2. Условие дирихле. это источник тепла или твёрдая стенка. 	
	*/
	if (0&&(bDirichlet)) {
		// Диагностика для отладки.
		
		if (bDirichlet && (border_neighbor[inumber].MCB < (ls + lw)) && (border_neighbor[inumber].MCB >= ls)) {
			printf("define Dirichlet bon con:");
			std::cout << "MCB " << border_neighbor[inumber].MCB << " ls" << ls << " lw" << lw << "\n";
			bool b1 = true;
			if (w[border_neighbor[inumber].MCB - ls].bsymmetry) {
				std::cout << "bsymmetry\n";
				b1 = false;
			}
			else {
				std::cout << "NOT bsymmetry\n";
			}
			if (w[border_neighbor[inumber].MCB - ls].bpressure) {
				std::cout << "bpessure\n";
				b1 = false;
			}
			else {
				std::cout << "NOT bpressure\n";
			}
			if (w[border_neighbor[inumber].MCB - ls].bopening) {
				std::cout << "bopening\n";
				b1 = false;
			}
			else {
				std::cout << "NOT bopening\n";
			}
			if (b1) {
				std::cout << "Vx=" << w[border_neighbor[inumber].MCB - ls].Vx << std::endl;
				std::cout << "Vy=" << w[border_neighbor[inumber].MCB - ls].Vy << std::endl;
				std::cout << "Vz=" << w[border_neighbor[inumber].MCB - ls].Vz << std::endl;
			}
			system("PAUSE");
		}
		
	}

     // Сначала запишем граничные условия Дирихле
	//if (bDirichlet && (border_neighbor[inumber].MCB<(ls + lw)) && (border_neighbor[inumber].MCB >= ls) && (!w[border_neighbor[inumber].MCB - ls].bopening) && (!w[border_neighbor[inumber].MCB - ls].bsymmetry) && (!w[border_neighbor[inumber].MCB - ls].bpressure)) {
	if (bDirichlet && (border_neighbor[inumber].MCB<(ls + lw)) && (border_neighbor[inumber].MCB >= ls)  && (!w[border_neighbor[inumber].MCB - ls].bsymmetry) && (!w[border_neighbor[inumber].MCB - ls].bpressure)) {

		//printf("define bon con:");
		//std::cout << "MCB " << border_neighbor[inumber].MCB << " ls" << ls << " lw" << lw << "\n";
		//system("PAUSE");

		// граничное условие Дирихле
		// Задана скорость на границе
        // Это не граница симметрии и не выходная граница.

		slb[inumber].aw=1.0;
		slb[inumber].ai=0.0;

		if (w[border_neighbor[inumber].MCB - ls].bopening) {
			switch (border_neighbor[inumber].Norm) {
			case E_SIDE:  case W_SIDE:
				switch (iVar) {
				case VELOCITY_X_COMPONENT: slb[inumber].b = potent[VXCOR][maxelm+inumber]; break;
				case VELOCITY_Y_COMPONENT: slb[inumber].b = 0.0; break;
				case VELOCITY_Z_COMPONENT: slb[inumber].b = 0.0; break;
				}
				break;
			case N_SIDE: case S_SIDE:
				switch (iVar) {
				case VELOCITY_X_COMPONENT: slb[inumber].b = 0.0; break;
				case VELOCITY_Y_COMPONENT: slb[inumber].b = potent[VYCOR][maxelm + inumber]; break;
				case VELOCITY_Z_COMPONENT: slb[inumber].b = 0.0; break;
				}
				break;
			case T_SIDE: case B_SIDE:
				switch (iVar) {
				case VELOCITY_X_COMPONENT: slb[inumber].b = 0.0; break;
				case VELOCITY_Y_COMPONENT: slb[inumber].b = 0.0; break;
				case VELOCITY_Z_COMPONENT: slb[inumber].b = potent[VZCOR][maxelm + inumber];  break;
				}
				break;
			}
		}
		else {

			// этот случай соответствует входной границе потока,
			// когда на входной границе задана нормальная скорость.
			// При этом тангенсальные скорости к входной границе могут быть не равны нулю,
			// в общем задаются три компоненты скорости !.
			switch (iVar) {
			case VELOCITY_X_COMPONENT: slb[inumber].b = w[border_neighbor[inumber].MCB - ls].Vx;
				//printf("boundary condition  VX[%lld] =%e\n", inumber, slb[inumber].b);
				//system("PAUSE"); 
				break;
			case VELOCITY_Y_COMPONENT: slb[inumber].b = w[border_neighbor[inumber].MCB - ls].Vy; break;
			case VELOCITY_Z_COMPONENT: slb[inumber].b = w[border_neighbor[inumber].MCB - ls].Vz; break;
			}
		}

		

		slb[inumber].iI= NON_EXISTENT_NODE; // не присутствует в матрице
		slb[inumber].iW=border_neighbor[inumber].iB;
#if doubleintprecision == 1
		//printf("%lld, soseddb=%lld\n",inumber, border_neighbor[inumber].iB); getchar(); // debug
#else
		//printf("%d, soseddb=%d\n",inumber, border_neighbor[inumber].iB); getchar(); // debug
#endif
		

		// Это условие Дирихле:
		// только диагональный элемент 
		// не равен нулю.
		slb[inumber].iW1= NON_EXISTENT_NODE;
        slb[inumber].iW2= NON_EXISTENT_NODE;
        slb[inumber].iW3= NON_EXISTENT_NODE;
        slb[inumber].iW4= NON_EXISTENT_NODE;
	}
	else if (bDirichlet && ( (border_neighbor[inumber].MCB==(ls+lw)) ||(border_neighbor[inumber].MCB<ls)) ) { // 
		// источник тоже является твёрдой стенкой.
		// либо твёрдая стенка. твёрдая стенка распознаётся по условию (border_neighbor[inumber].MCB==(ls+lw)).

        // граничное условие Дирихле
		// Задана условие прилипания на твёрдой стенке.

		slb[inumber].aw=1.0;
		slb[inumber].ai=0.0;
		slb[inumber].b=0.0; // нулевая скорость.
		slb[inumber].iI= NON_EXISTENT_NODE; // не присутствует в матрице
		slb[inumber].iW=border_neighbor[inumber].iB;

		// Это условие Дирихле:
		// только диагональный элемент 
		// не равен нулю.
		slb[inumber].iW1= NON_EXISTENT_NODE;
        slb[inumber].iW2= NON_EXISTENT_NODE;
        slb[inumber].iW3= NON_EXISTENT_NODE;
        slb[inumber].iW4= NON_EXISTENT_NODE;
	}
	else if ((border_neighbor[inumber].MCB<(ls+lw)) && (border_neighbor[inumber].MCB>=ls) && (w[border_neighbor[inumber].MCB-ls].bsymmetry)) {
		// Условие симметрии на границе:
		// Если на границе стоит граничное условие с условиями симметрии, то
		// нормальная скорость к границе равна нулю, а нормальная производная
		// к границе от касательных компонент скорости тоже равна нулю.

		// bNei - стоит ли для данной компоненты скорости 
		// однородное условие Неймана ?
		bool bNei=false;

		switch (iVar) {
			case VELOCITY_X_COMPONENT: // определим внутреннюю нормаль к границе
				      switch (border_neighbor[inumber].Norm) {
			             case E_SIDE: bNei=false; break;
						 case W_SIDE: bNei=false; break;
						 case N_SIDE: bNei=true; break;
						 case S_SIDE: bNei=true; break;
						 case T_SIDE:  bNei=true; break;
						 case B_SIDE: bNei=true; break;
					  }
				      break;
			case VELOCITY_Y_COMPONENT: switch (border_neighbor[inumber].Norm) {
			             case E_SIDE: bNei=true; break;
						 case W_SIDE: bNei=true; break;
						 case N_SIDE: bNei=false; break;
						 case S_SIDE: bNei=false; break;
						 case T_SIDE:  bNei=true; break;
						 case B_SIDE: bNei=true; break;
					  }
				      break;
			case VELOCITY_Z_COMPONENT: switch (border_neighbor[inumber].Norm) {
			             case E_SIDE: bNei=true; break;
						 case W_SIDE: bNei=true; break;
						 case N_SIDE: bNei=true; break;
						 case S_SIDE: bNei=true; break;
						 case T_SIDE:  bNei=false; break;
						 case B_SIDE: bNei=false; break;
					  }
				      break;
		}

		if (bDirichlet && (!bNei)) {
			// граничное условие Дирихле

		    slb[inumber].aw=1.0;
		    slb[inumber].ai=0.0;
		    slb[inumber].b=0.0;
		    slb[inumber].iI= NON_EXISTENT_NODE; // не присутствует в матрице
		    slb[inumber].iW=border_neighbor[inumber].iB;

		    // Это условие Дирихле:
		    // только диагональный элемент 
		    // не равен нулю.
		    slb[inumber].iW1= NON_EXISTENT_NODE;
            slb[inumber].iW2= NON_EXISTENT_NODE;
            slb[inumber].iW3= NON_EXISTENT_NODE;
            slb[inumber].iW4= NON_EXISTENT_NODE;
		}
		else if ((!bDirichlet) && bNei) {
			// однородное условие Неймана:

			// Пояснение. Т.к. уравнение для компоненты скорости
			// совпадает с уравнением теплопроводности с точностью
			// до искомой функции и коэффициентов в уравнении, то
			// граничные условия для уравнения теплопроводности
			// переносятся на уравнение для компоненты скорости, с точностью 
			// до коэффициентов в уравнении.
            
			doublereal dl, deltal, dS; // геометрические параметры
	        doublereal mui; // динамическая вязкость на грани КО
	        doublereal fiplus; // учёт неравномерности сетки
			integer iVar_id=iVar;
			switch (iVar) {
				case VELOCITY_X_COMPONENT: iVar_id=VXCOR; break;
				case VELOCITY_Y_COMPONENT: iVar_id=VYCOR; break;
				case VELOCITY_Z_COMPONENT: iVar_id=VZCOR; break;
			}
			doublereal muB, muI, muII; // динамическая вязкость

			// внутренняя нормаль.
	        switch (border_neighbor[inumber].Norm) {
		       case E_SIDE: 
			        dl = pa[nvtx[1][border_neighbor[inumber].iI]-1].x-pa[nvtx[0][border_neighbor[inumber].iI]-1].x;
                    //dS=pa[nvtx[2][border_neighbor[inumber].iI]-1].y-pa[nvtx[1][border_neighbor[inumber].iI]-1].y; 
					//dS*=(pa[nvtx[4][border_neighbor[inumber].iI]-1].z-pa[nvtx[0][border_neighbor[inumber].iI]-1].z); // площадь грани
					dS = border_neighbor[inumber].dS; // Площадь грани 26.09.2016.

					// Молекулярная динамическая вязкость
					muB=prop_b[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iB-maxelm];
					muI=prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iI];
					muII=prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iII];
					// Добавляем турбулентную динамическую вязкость согласно
					// гипотезе Буссинеска.
					if ((iflowregime== VISCOSITY_MODEL::ZEROEQMOD)||
						(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES)||
						(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST)||
						(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
					   muB+=fmax(0.0,potent[MUT][border_neighbor[inumber].iB]);
					   muI+= fmax(0.0, potent[MUT][border_neighbor[inumber].iI]);
					   muII+= fmax(0.0, potent[MUT][border_neighbor[inumber].iII]);
					}

					slb[inumber].ai=2.0*dbeta*muB*dS/dl;
					slb[inumber].iI=border_neighbor[inumber].iI;
					slb[inumber].aw=slb[inumber].ai;
					slb[inumber].iW=border_neighbor[inumber].iB;

					if (border_neighbor[inumber].iII > -1) {

						deltal = 0.5 * (pa[nvtx[1][border_neighbor[inumber].iII] - 1].x + pa[nvtx[0][border_neighbor[inumber].iII] - 1].x);
						deltal -= 0.5 * (pa[nvtx[1][border_neighbor[inumber].iI] - 1].x + pa[nvtx[0][border_neighbor[inumber].iI] - 1].x);
						fiplus = 0.5 * dl / deltal;

						mui = (muI * muII) / ((1.0 - fiplus) * muI + fiplus * muII); // динамическая вязкость проверено.

						// правая часть
						slb[inumber].b = (dbeta - 1.0) * mui * dS * (potent[iVar_id][border_neighbor[inumber].iI] - potent[iVar_id][border_neighbor[inumber].iII]) / deltal;
					}
					else {
						slb[inumber].b = 0.0;
					}
					break;
				case N_SIDE: 
			        dl = pa[nvtx[2][border_neighbor[inumber].iI]-1].y-pa[nvtx[0][border_neighbor[inumber].iI]-1].y;
                    //dS=pa[nvtx[1][border_neighbor[inumber].iI]-1].x-pa[nvtx[0][border_neighbor[inumber].iI]-1].x; 
					//dS*=(pa[nvtx[4][border_neighbor[inumber].iI]-1].z-pa[nvtx[0][border_neighbor[inumber].iI]-1].z); // площадь грани
					dS = border_neighbor[inumber].dS; // Площадь грани 26.09.2016.


					// Молекулярная динамическая вязкость
					muB=prop_b[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iB-maxelm];
					muI=prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iI];
					muII=prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iII];
					// Добавляем турбулентную динамическую вязкость согласно
					// гипотезе Буссинеска.
					if ((iflowregime== VISCOSITY_MODEL::ZEROEQMOD) ||
						(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
						(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
						(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
					    muB+= fmax(0.0, potent[MUT][border_neighbor[inumber].iB]);
					    muI+= fmax(0.0, potent[MUT][border_neighbor[inumber].iI]);
					    muII+= fmax(0.0, potent[MUT][border_neighbor[inumber].iII]);
					}

					slb[inumber].ai=2.0*dbeta*muB*dS/dl;
					slb[inumber].iI=border_neighbor[inumber].iI;
					slb[inumber].aw=slb[inumber].ai;
					slb[inumber].iW=border_neighbor[inumber].iB;

					if (border_neighbor[inumber].iII > -1) {

						deltal = 0.5 * (pa[nvtx[2][border_neighbor[inumber].iII] - 1].y + pa[nvtx[0][border_neighbor[inumber].iII] - 1].y);
						deltal -= 0.5 * (pa[nvtx[2][border_neighbor[inumber].iI] - 1].y + pa[nvtx[0][border_neighbor[inumber].iI] - 1].y);
						fiplus = 0.5 * dl / deltal;

						mui = (muI * muII) / ((1.0 - fiplus) * muI + fiplus * muII); // динамическая вязкость проверено.

						// правая часть
						slb[inumber].b = (dbeta - 1.0) * mui * dS * (potent[iVar_id][border_neighbor[inumber].iI] - potent[iVar_id][border_neighbor[inumber].iII]) / deltal;
					}
					else {
						slb[inumber].b = 0.0;
					}
					break;

			   case T_SIDE:  
			        dl = pa[nvtx[4][border_neighbor[inumber].iI]-1].z-pa[nvtx[0][border_neighbor[inumber].iI]-1].z;
                    //dS=pa[nvtx[1][border_neighbor[inumber].iI]-1].x-pa[nvtx[0][border_neighbor[inumber].iI]-1].x; 
					//dS*=(pa[nvtx[2][border_neighbor[inumber].iI]-1].y-pa[nvtx[0][border_neighbor[inumber].iI]-1].y); // площадь грани
					dS = border_neighbor[inumber].dS; // Площадь грани 26.09.2016.

					// Молекулярная динамическая вязкость
					muB=prop_b[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iB-maxelm];
					muI=prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iI];
					muII=prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iII];
					// Добавляем турбулентную динамическую вязкость согласно
					// гипотезе Буссинеска.
					if ((iflowregime== VISCOSITY_MODEL::ZEROEQMOD) ||
						(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
						(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
						(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
					    muB+= fmax(0.0, potent[MUT][border_neighbor[inumber].iB]);
					    muI+= fmax(0.0, potent[MUT][border_neighbor[inumber].iI]);
					    muII+= fmax(0.0, potent[MUT][border_neighbor[inumber].iII]);
					}

					slb[inumber].ai=2.0*dbeta*muB*dS/dl;
					slb[inumber].iI=border_neighbor[inumber].iI;
					slb[inumber].aw=slb[inumber].ai;
					slb[inumber].iW=border_neighbor[inumber].iB;


					if (border_neighbor[inumber].iII > -1) {

						deltal = 0.5 * (pa[nvtx[4][border_neighbor[inumber].iII] - 1].z + pa[nvtx[0][border_neighbor[inumber].iII] - 1].z);
						deltal -= 0.5 * (pa[nvtx[4][border_neighbor[inumber].iI] - 1].z + pa[nvtx[0][border_neighbor[inumber].iI] - 1].z);
						fiplus = 0.5 * dl / deltal;

						mui = (muI * muII) / ((1.0 - fiplus) * muI + fiplus * muII); // динамическая вязкость проверено.

						// правая часть
						slb[inumber].b = (dbeta - 1.0) * mui * dS * (potent[iVar_id][border_neighbor[inumber].iI] - potent[iVar_id][border_neighbor[inumber].iII]) / deltal;
					}
					else {
						slb[inumber].b = 0.0;
					}

					break;

			case W_SIDE: 
			        dl = pa[nvtx[1][border_neighbor[inumber].iI]-1].x-pa[nvtx[0][border_neighbor[inumber].iI]-1].x;
                    //dS=pa[nvtx[2][border_neighbor[inumber].iI]-1].y-pa[nvtx[1][border_neighbor[inumber].iI]-1].y; 
					//dS*=(pa[nvtx[4][border_neighbor[inumber].iI]-1].z-pa[nvtx[0][border_neighbor[inumber].iI]-1].z); // площадь грани
					dS = border_neighbor[inumber].dS; // Площадь грани 26.09.2016.


					// Молекулярная динамическая вязкость
					muB=prop_b[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iB-maxelm];
					muI=prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iI];
					muII=prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iII];
					// Добавляем турбулентную динамическую вязкость согласно
					// гипотезе Буссинеска.
					if ((iflowregime== VISCOSITY_MODEL::ZEROEQMOD) ||
						(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
						(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
						(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
					   muB+= fmax(0.0, potent[MUT][border_neighbor[inumber].iB]);
					   muI+= fmax(0.0, potent[MUT][border_neighbor[inumber].iI]);
					   muII+= fmax(0.0, potent[MUT][border_neighbor[inumber].iII]);
					}

					slb[inumber].ai=2.0*dbeta*muB*dS/dl;
					slb[inumber].iI=border_neighbor[inumber].iI;
					slb[inumber].aw=slb[inumber].ai;
					slb[inumber].iW=border_neighbor[inumber].iB;

					if (border_neighbor[inumber].iII > -1) {

						deltal = -0.5 * (pa[nvtx[1][border_neighbor[inumber].iII] - 1].x + pa[nvtx[0][border_neighbor[inumber].iII] - 1].x);
						deltal += 0.5 * (pa[nvtx[1][border_neighbor[inumber].iI] - 1].x + pa[nvtx[0][border_neighbor[inumber].iI] - 1].x);
						fiplus = 0.5 * dl / deltal;

						mui = (muI * muII) / ((1.0 - fiplus) * muI + fiplus * muII); // динамическая вязкость проверено.

						// правая часть
						// ВНИМАНИЕ !!! Если будет нефизичное решение при dbeta > 1 то возможно нужно поменять местами I и II!!!!
						slb[inumber].b = (dbeta - 1.0) * mui * dS * (potent[iVar_id][border_neighbor[inumber].iI] - potent[iVar_id][border_neighbor[inumber].iII]) / deltal;
					}
					else {
						slb[inumber].b = 0.0;
					}
					break;

           case S_SIDE: 
			        dl = pa[nvtx[2][border_neighbor[inumber].iI]-1].y-pa[nvtx[0][border_neighbor[inumber].iI]-1].y;
                    //dS=pa[nvtx[1][border_neighbor[inumber].iI]-1].x-pa[nvtx[0][border_neighbor[inumber].iI]-1].x; 
					//dS*=(pa[nvtx[4][border_neighbor[inumber].iI]-1].z-pa[nvtx[0][border_neighbor[inumber].iI]-1].z); // площадь грани
					dS = border_neighbor[inumber].dS; // Площадь грани 26.09.2016.


					// Молекулярная динамическая вязкость
					muB=prop_b[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iB-maxelm];
					muI=prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iI];
					muII=prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iII];
					// Добавляем турбулентную динамическую вязкость согласно
					// гипотезе Буссинеска.
					if ((iflowregime== VISCOSITY_MODEL::ZEROEQMOD) ||
						(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
						(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
						(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
					    muB+= fmax(0.0, potent[MUT][border_neighbor[inumber].iB]);
					    muI+= fmax(0.0, potent[MUT][border_neighbor[inumber].iI]);
					    muII+= fmax(0.0, potent[MUT][border_neighbor[inumber].iII]);
					}

					slb[inumber].ai=2.0*dbeta*muB*dS/dl;
					slb[inumber].iI=border_neighbor[inumber].iI;
					slb[inumber].aw=slb[inumber].ai;
					slb[inumber].iW=border_neighbor[inumber].iB;

					if (border_neighbor[inumber].iII > -1) {
						deltal = -0.5 * (pa[nvtx[2][border_neighbor[inumber].iII] - 1].y + pa[nvtx[0][border_neighbor[inumber].iII] - 1].y);
						deltal += 0.5 * (pa[nvtx[2][border_neighbor[inumber].iI] - 1].y + pa[nvtx[0][border_neighbor[inumber].iI] - 1].y);
						fiplus = 0.5 * dl / deltal;

						mui = (muI * muII) / ((1.0 - fiplus) * muI + fiplus * muII); // динамическая вязкость проверено.

						// правая часть
						slb[inumber].b = (dbeta - 1.0) * mui * dS * (potent[iVar_id][border_neighbor[inumber].iI] - potent[iVar_id][border_neighbor[inumber].iII]) / deltal;
					}
					else {
						slb[inumber].b = 0.0;
					}
					break;

			case B_SIDE: 
			        dl = pa[nvtx[4][border_neighbor[inumber].iI]-1].z-pa[nvtx[0][border_neighbor[inumber].iI]-1].z;
                    //dS=pa[nvtx[1][border_neighbor[inumber].iI]-1].x-pa[nvtx[0][border_neighbor[inumber].iI]-1].x; 
					//dS*=(pa[nvtx[2][border_neighbor[inumber].iI]-1].y-pa[nvtx[0][border_neighbor[inumber].iI]-1].y); // площадь грани
					dS = border_neighbor[inumber].dS; // Площадь грани 26.09.2016.


					// Молекулярная динамическая вязкость
					muB=prop_b[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iB-maxelm];
					muI=prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iI];
					muII=prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iII];
					// Добавляем турбулентную динамическую вязкость согласно
					// гипотезе Буссинеска.
					if ((iflowregime== VISCOSITY_MODEL::ZEROEQMOD) ||
						(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
						(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
						(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
					    muB+= fmax(0.0, potent[MUT][border_neighbor[inumber].iB]);
					    muI+= fmax(0.0, potent[MUT][border_neighbor[inumber].iI]);
				    	muII+= fmax(0.0, potent[MUT][border_neighbor[inumber].iII]);
					}

					slb[inumber].ai=2.0*dbeta*muB*dS/dl;
					slb[inumber].iI=border_neighbor[inumber].iI;
					slb[inumber].aw=slb[inumber].ai;
					slb[inumber].iW=border_neighbor[inumber].iB;

					if (border_neighbor[inumber].iII > -1) {

						deltal = -0.5 * (pa[nvtx[4][border_neighbor[inumber].iII] - 1].z + pa[nvtx[0][border_neighbor[inumber].iII] - 1].z);
						deltal += 0.5 * (pa[nvtx[4][border_neighbor[inumber].iI] - 1].z + pa[nvtx[0][border_neighbor[inumber].iI] - 1].z);
						fiplus = 0.5 * dl / deltal;

						mui = (muI * muII) / ((1.0 - fiplus) * muI + fiplus * muII); // динамическая вязкость проверено.

						// правая часть
						slb[inumber].b = (dbeta - 1.0) * mui * dS * (potent[iVar_id][border_neighbor[inumber].iI] - potent[iVar_id][border_neighbor[inumber].iII]) / deltal;
					}
					else {
						slb[inumber].b = 0.0;
					}
					break;
	        } // end switch

            integer j,l,xitem,k;
	        // сортировка по возрастанию
	        for (j=0; j<5; j++) {
	 		    k=j; xitem=border_neighbor[inumber].iW[j];
			    for (l=j+1; l<6; l++) {
				    if (border_neighbor[inumber].iW[l] < xitem) {
					    k=l; xitem=border_neighbor[inumber].iW[k];
				    }
			    }
                border_neighbor[inumber].iW[k]=border_neighbor[inumber].iW[j];
			    border_neighbor[inumber].iW[j]=xitem;
		    }

            j=0; l=0;
		    while (border_neighbor[inumber].iW[j]==(NON_EXISTENT_NODE)) j++;

		    if (j<6) { slb[inumber].iW1=border_neighbor[inumber].iW[j++]; l++; }
		    if (j<6) { slb[inumber].iW2=border_neighbor[inumber].iW[j++]; l++; }
		    if (j<6) { slb[inumber].iW3=border_neighbor[inumber].iW[j++]; l++; }
		    if (j<6) { slb[inumber].iW4=border_neighbor[inumber].iW[j++]; l++; } 

		    switch (l) {
			   case 0: slb[inumber].iW1= NON_EXISTENT_NODE;
		                slb[inumber].iW2= NON_EXISTENT_NODE;
		                slb[inumber].iW3= NON_EXISTENT_NODE;
		                slb[inumber].iW4= NON_EXISTENT_NODE;
		                break;
			   case 1: slb[inumber].iW2= NON_EXISTENT_NODE;
		                slb[inumber].iW3= NON_EXISTENT_NODE;
		                slb[inumber].iW4= NON_EXISTENT_NODE;
		    		    break;
			   case 2: slb[inumber].iW3= NON_EXISTENT_NODE;
		                slb[inumber].iW4= NON_EXISTENT_NODE;
					    break;
			   case 3: slb[inumber].iW4= NON_EXISTENT_NODE;
					    break;
		    }

		    // Наложения исключения в случае совпадения узла iI с диагональным 
		    // элементом узла для котторого стоит условие Дирихле не требуется. 
		    // т.к. узлы iI строго внутренние для которых iI < maxelm, а диагональный 
		    // элемент с условием Дирихле стоит в позициях >= maxelm поэтому они не
		    // пересекаются.
            
		}

	}
	else if ((border_neighbor[inumber].MCB<(ls + lw)) && (border_neighbor[inumber].MCB >= ls) && ((w[border_neighbor[inumber].MCB - ls].bpressure) /*|| ((w[border_neighbor[inumber].MCB - ls].bopening))*/)) {
		    
		    bool bmassbal=false; // если true то используется массовый баланс предложенный на сайте Гаврилова Андрея.

		    if ((!bDirichlet)&&(!bmassbal)) {
		    // для любой компоненты скорости стоит условие Неймана:
            // Пояснение. Т.к. уравнение для компоненты скорости
			// совпадает с уравнением теплопроводности с точностью
			// до искомой функции и коэффициентов в уравнении, то
			// граничные условия для уравнения теплопроводности
			// переносятся на уравнение для компоненты скорости, с точностью 
			// до коэффициентов в уравнении.
            
			doublereal dl, deltal, dS; // геометрические параметры
	        doublereal mui; // динамическая вязкость на грани КО
	        doublereal fiplus; // учёт неравномерности сетки

			integer iVar_id=iVar;
			switch (iVar) {
				case VELOCITY_X_COMPONENT: iVar_id=VXCOR; break;
				case VELOCITY_Y_COMPONENT: iVar_id=VYCOR; break;
				case VELOCITY_Z_COMPONENT: iVar_id=VZCOR; break;
			}

			doublereal muB, muI, muII; // динамическая вязкость

			if (b_on_adaptive_local_refinement_mesh) {
				slb[inumber].ai = 1;
				slb[inumber].iI = border_neighbor[inumber].iI;
				slb[inumber].aw = 1;
				slb[inumber].iW = border_neighbor[inumber].iB;
				//printf("iI=%lld iW=%lld\n", border_neighbor[inumber].iI, border_neighbor[inumber].iB);
				//getchar();
				// правая часть
				slb[inumber].b = 0.0;
			}
			else {

				switch (border_neighbor[inumber].Norm) {
				case E_SIDE:

					dl = pa[nvtx[1][border_neighbor[inumber].iI] - 1].x - pa[nvtx[0][border_neighbor[inumber].iI] - 1].x;
					//dS=pa[nvtx[2][border_neighbor[inumber].iI]-1].y-pa[nvtx[1][border_neighbor[inumber].iI]-1].y; 
					//dS*=(pa[nvtx[4][border_neighbor[inumber].iI]-1].z-pa[nvtx[0][border_neighbor[inumber].iI]-1].z); // площадь грани
					dS = border_neighbor[inumber].dS; // Площадь грани 26.09.2016.

					// Молекулярная динамическая вязкость
					muB = prop_b[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iB - maxelm];
					muI = prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iI];
					muII = prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iII];
					// Добавляем турбулентную динамическую вязкость согласно
					// гипотезе Буссинеска.
					if ((iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
						(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
						(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
						(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
						muB += fmax(0.0, potent[MUT][border_neighbor[inumber].iB]);
						muI += fmax(0.0, potent[MUT][border_neighbor[inumber].iI]);
						muII += fmax(0.0, potent[MUT][border_neighbor[inumber].iII]);
					}

					slb[inumber].ai = 2.0*dbeta*muB*dS / dl;
					slb[inumber].iI = border_neighbor[inumber].iI;
					slb[inumber].aw = slb[inumber].ai;
					slb[inumber].iW = border_neighbor[inumber].iB;

					if (border_neighbor[inumber].iII > -1) {

						deltal = 0.5 * (pa[nvtx[1][border_neighbor[inumber].iII] - 1].x + pa[nvtx[0][border_neighbor[inumber].iII] - 1].x);
						deltal -= 0.5 * (pa[nvtx[1][border_neighbor[inumber].iI] - 1].x + pa[nvtx[0][border_neighbor[inumber].iI] - 1].x);
						fiplus = 0.5 * dl / deltal;

						mui = (muI * muII) / ((1.0 - fiplus) * muI + fiplus * muII); // динамическая вязкость проверено.

						// правая часть
						slb[inumber].b = (dbeta - 1.0) * mui * dS * (potent[iVar_id][border_neighbor[inumber].iI] - potent[iVar_id][border_neighbor[inumber].iII]) / deltal;
					}
					else {
						slb[inumber].b = 0.0;
					}

					break;
				case N_SIDE:
					dl = pa[nvtx[2][border_neighbor[inumber].iI] - 1].y - pa[nvtx[0][border_neighbor[inumber].iI] - 1].y;
					//dS=pa[nvtx[1][border_neighbor[inumber].iI]-1].x-pa[nvtx[0][border_neighbor[inumber].iI]-1].x; 
					//dS*=(pa[nvtx[4][border_neighbor[inumber].iI]-1].z-pa[nvtx[0][border_neighbor[inumber].iI]-1].z); // площадь грани
					dS = border_neighbor[inumber].dS; // Площадь грани 26.09.2016.


					// Молекулярная динамическая вязкость
					muB = prop_b[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iB - maxelm];
					muI = prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iI];
					muII = prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iII];
					// Добавляем турбулентную динамическую вязкость согласно
					// гипотезе Буссинеска.
					if ((iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
						(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
						(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
						(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
						muB += fmax(0.0, potent[MUT][border_neighbor[inumber].iB]);
						muI += fmax(0.0, potent[MUT][border_neighbor[inumber].iI]);
						muII += fmax(0.0, potent[MUT][border_neighbor[inumber].iII]);
					}

					slb[inumber].ai = 2.0*dbeta*muB*dS / dl;
					slb[inumber].iI = border_neighbor[inumber].iI;
					slb[inumber].aw = slb[inumber].ai;
					slb[inumber].iW = border_neighbor[inumber].iB;

					if (border_neighbor[inumber].iII > -1) {

						deltal = 0.5 * (pa[nvtx[2][border_neighbor[inumber].iII] - 1].y + pa[nvtx[0][border_neighbor[inumber].iII] - 1].y);
						deltal -= 0.5 * (pa[nvtx[2][border_neighbor[inumber].iI] - 1].y + pa[nvtx[0][border_neighbor[inumber].iI] - 1].y);
						fiplus = 0.5 * dl / deltal;

						mui = (muI * muII) / ((1.0 - fiplus) * muI + fiplus * muII); // динамическая вязкость

						// правая часть
						slb[inumber].b = (dbeta - 1.0) * mui * dS * (potent[iVar_id][border_neighbor[inumber].iI] - potent[iVar_id][border_neighbor[inumber].iII]) / deltal;
					}
					else {
						slb[inumber].b = 0.0;
					}
					break;

				case T_SIDE:
					dl = pa[nvtx[4][border_neighbor[inumber].iI] - 1].z - pa[nvtx[0][border_neighbor[inumber].iI] - 1].z;
					//dS=pa[nvtx[1][border_neighbor[inumber].iI]-1].x-pa[nvtx[0][border_neighbor[inumber].iI]-1].x; 
					//dS*=(pa[nvtx[2][border_neighbor[inumber].iI]-1].y-pa[nvtx[0][border_neighbor[inumber].iI]-1].y); // площадь грани
					dS = border_neighbor[inumber].dS; // Площадь грани 26.09.2016.


					// Молекулярная динамическая вязкость
					muB = prop_b[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iB - maxelm];
					muI = prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iI];
					muII = prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iII];
					// Добавляем турбулентную динамическую вязкость согласно
					// гипотезе Буссинеска.
					if ((iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
						(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
						(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
						(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
						muB += fmax(0.0, potent[MUT][border_neighbor[inumber].iB]);
						muI += fmax(0.0, potent[MUT][border_neighbor[inumber].iI]);
						muII += fmax(0.0, potent[MUT][border_neighbor[inumber].iII]);
					}

					slb[inumber].ai = 2.0*dbeta*muB*dS / dl;
					slb[inumber].iI = border_neighbor[inumber].iI;
					slb[inumber].aw = slb[inumber].ai;
					slb[inumber].iW = border_neighbor[inumber].iB;


					if (border_neighbor[inumber].iII > -1) {

						deltal = 0.5 * (pa[nvtx[4][border_neighbor[inumber].iII] - 1].z + pa[nvtx[0][border_neighbor[inumber].iII] - 1].z);
						deltal -= 0.5 * (pa[nvtx[4][border_neighbor[inumber].iI] - 1].z + pa[nvtx[0][border_neighbor[inumber].iI] - 1].z);
						fiplus = 0.5 * dl / deltal;

						mui = (muI * muII) / ((1.0 - fiplus) * muI + fiplus * muII); // динамическая вязкость проверено.

						// правая часть
						slb[inumber].b = (dbeta - 1.0) * mui * dS * (potent[iVar_id][border_neighbor[inumber].iI] - potent[iVar_id][border_neighbor[inumber].iII]) / deltal;
					}
					else {
						slb[inumber].b = 0.0;
					}
					break;

				case W_SIDE:
					dl = pa[nvtx[1][border_neighbor[inumber].iI] - 1].x - pa[nvtx[0][border_neighbor[inumber].iI] - 1].x;
					//dS=pa[nvtx[2][border_neighbor[inumber].iI]-1].y-pa[nvtx[1][border_neighbor[inumber].iI]-1].y; 
					//dS*=(pa[nvtx[4][border_neighbor[inumber].iI]-1].z-pa[nvtx[0][border_neighbor[inumber].iI]-1].z); // площадь грани
					dS = border_neighbor[inumber].dS; // Площадь грани 26.09.2016.

					// Молекулярная динамическая вязкость
					muB = prop_b[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iB - maxelm];
					muI = prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iI];
					muII = prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iII];
					// Добавляем турбулентную динамическую вязкость согласно
					// гипотезе Буссинеска.
					if ((iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
						(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
						(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
						(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
						muB += fmax(0.0, potent[MUT][border_neighbor[inumber].iB]);
						muI += fmax(0.0, potent[MUT][border_neighbor[inumber].iI]);
						muII += fmax(0.0, potent[MUT][border_neighbor[inumber].iII]);
					}

					slb[inumber].ai = 2.0*dbeta*muB*dS / dl;
					slb[inumber].iI = border_neighbor[inumber].iI;
					slb[inumber].aw = slb[inumber].ai;
					slb[inumber].iW = border_neighbor[inumber].iB;

					if (border_neighbor[inumber].iII > -1) {

						deltal = -0.5 * (pa[nvtx[1][border_neighbor[inumber].iII] - 1].x + pa[nvtx[0][border_neighbor[inumber].iII] - 1].x);
						deltal += 0.5 * (pa[nvtx[1][border_neighbor[inumber].iI] - 1].x + pa[nvtx[0][border_neighbor[inumber].iI] - 1].x);
						fiplus = 0.5 * dl / deltal;

						mui = (muI * muII) / ((1.0 - fiplus) * muI + fiplus * muII); // динамическая вязкость проверено.

						// правая часть
						// ВНИМАНИЕ !!! Если будет нефизичное решение при dbeta > 1 то возможно нужно поменять местами I и II!!!!
						slb[inumber].b = (dbeta - 1.0) * mui * dS * (potent[iVar_id][border_neighbor[inumber].iI] - potent[iVar_id][border_neighbor[inumber].iII]) / deltal;
					}
					else {
						slb[inumber].b = 0.0;
					}
					break;

				case S_SIDE:
					dl = pa[nvtx[2][border_neighbor[inumber].iI] - 1].y - pa[nvtx[0][border_neighbor[inumber].iI] - 1].y;
					//dS=pa[nvtx[1][border_neighbor[inumber].iI]-1].x-pa[nvtx[0][border_neighbor[inumber].iI]-1].x; 
					//dS*=(pa[nvtx[4][border_neighbor[inumber].iI]-1].z-pa[nvtx[0][border_neighbor[inumber].iI]-1].z); // площадь грани
					dS = border_neighbor[inumber].dS; // Площадь грани 26.09.2016.


					// Молекулярная динамическая вязкость
					muB = prop_b[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iB - maxelm];
					muI = prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iI];
					muII = prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iII];
					// Добавляем турбулентную динамическую вязкость согласно
					// гипотезе Буссинеска.
					if ((iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
						(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
						(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
						(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
						muB += fmax(0.0, potent[MUT][border_neighbor[inumber].iB]);
						muI += fmax(0.0, potent[MUT][border_neighbor[inumber].iI]);
						muII += fmax(0.0, potent[MUT][border_neighbor[inumber].iII]);
					}

					slb[inumber].ai = 2.0*dbeta*muB*dS / dl;
					slb[inumber].iI = border_neighbor[inumber].iI;
					slb[inumber].aw = slb[inumber].ai;
					slb[inumber].iW = border_neighbor[inumber].iB;

					if (border_neighbor[inumber].iII > -1) {

						deltal = -0.5 * (pa[nvtx[2][border_neighbor[inumber].iII] - 1].y + pa[nvtx[0][border_neighbor[inumber].iII] - 1].y);
						deltal += 0.5 * (pa[nvtx[2][border_neighbor[inumber].iI] - 1].y + pa[nvtx[0][border_neighbor[inumber].iI] - 1].y);
						fiplus = 0.5 * dl / deltal;

						mui = (muI * muII) / ((1.0 - fiplus) * muI + fiplus * muII); // динамическая вязкость проверено.

						// правая часть
						slb[inumber].b = (dbeta - 1.0) * mui * dS * (potent[iVar_id][border_neighbor[inumber].iI] - potent[iVar_id][border_neighbor[inumber].iII]) / deltal;

					}
					else {
						slb[inumber].b = 0.0;

					}
					break;

				case B_SIDE:
					dl = pa[nvtx[4][border_neighbor[inumber].iI] - 1].z - pa[nvtx[0][border_neighbor[inumber].iI] - 1].z;
					//dS=pa[nvtx[1][border_neighbor[inumber].iI]-1].x-pa[nvtx[0][border_neighbor[inumber].iI]-1].x; 
					//dS*=(pa[nvtx[2][border_neighbor[inumber].iI]-1].y-pa[nvtx[0][border_neighbor[inumber].iI]-1].y); // площадь грани
					dS = border_neighbor[inumber].dS; // Площадь грани 26.09.2016.


					// Молекулярная динамическая вязкость
					muB = prop_b[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iB - maxelm];
					muI = prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iI];
					muII = prop[MU_DYNAMIC_VISCOSITY][border_neighbor[inumber].iII];
					// Добавляем турбулентную динамическую вязкость согласно
					// гипотезе Буссинеска.
					if ((iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
						(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
						(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
						(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
						muB += fmax(0.0, potent[MUT][border_neighbor[inumber].iB]);
						muI += fmax(0.0, potent[MUT][border_neighbor[inumber].iI]);
						muII += fmax(0.0, potent[MUT][border_neighbor[inumber].iII]);
					}

					slb[inumber].ai = 2.0*dbeta*muB*dS / dl;
					slb[inumber].iI = border_neighbor[inumber].iI;
					slb[inumber].aw = slb[inumber].ai;
					slb[inumber].iW = border_neighbor[inumber].iB;

					if (border_neighbor[inumber].iII > -1) {

						deltal = -0.5 * (pa[nvtx[4][border_neighbor[inumber].iII] - 1].z + pa[nvtx[0][border_neighbor[inumber].iII] - 1].z);
						deltal += 0.5 * (pa[nvtx[4][border_neighbor[inumber].iI] - 1].z + pa[nvtx[0][border_neighbor[inumber].iI] - 1].z);
						fiplus = 0.5 * dl / deltal;

						mui = (muI * muII) / ((1.0 - fiplus) * muI + fiplus * muII); // динамическая вязкость проверено.

						// правая часть
						slb[inumber].b = (dbeta - 1.0) * mui * dS * (potent[iVar_id][border_neighbor[inumber].iI] - potent[iVar_id][border_neighbor[inumber].iII]) / deltal;
					}
					else {
						slb[inumber].b = 0.0;
					}
					break;
				} // end switch
			}

            integer j,l,xitem,k;
	        // сортировка по возрастанию
	        for (j=0; j<5; j++) {
	 		    k=j; xitem=border_neighbor[inumber].iW[j];
			    for (l=j+1; l<6; l++) {
				    if (border_neighbor[inumber].iW[l] < xitem) {
					    k=l; xitem=border_neighbor[inumber].iW[k];
				    }
			    }
                border_neighbor[inumber].iW[k]=border_neighbor[inumber].iW[j];
			    border_neighbor[inumber].iW[j]=xitem;
		    }

            j=0; l=0;
		    while (border_neighbor[inumber].iW[j]==(NON_EXISTENT_NODE)) j++;

		    if (j<6) { slb[inumber].iW1=border_neighbor[inumber].iW[j++]; l++; }
		    if (j<6) { slb[inumber].iW2=border_neighbor[inumber].iW[j++]; l++; }
		    if (j<6) { slb[inumber].iW3=border_neighbor[inumber].iW[j++]; l++; }
		    if (j<6) { slb[inumber].iW4=border_neighbor[inumber].iW[j++]; l++; } 

		    switch (l) {
			   case 0: slb[inumber].iW1= NON_EXISTENT_NODE;
		                slb[inumber].iW2= NON_EXISTENT_NODE;
		                slb[inumber].iW3= NON_EXISTENT_NODE;
		                slb[inumber].iW4= NON_EXISTENT_NODE;
		                break;
			   case 1: slb[inumber].iW2= NON_EXISTENT_NODE;
		                slb[inumber].iW3= NON_EXISTENT_NODE;
		                slb[inumber].iW4= NON_EXISTENT_NODE;
		    		    break;
			   case 2: slb[inumber].iW3= NON_EXISTENT_NODE;
		                slb[inumber].iW4= NON_EXISTENT_NODE;
					    break;
			   case 3: slb[inumber].iW4= NON_EXISTENT_NODE;
					    break;
		    }

		    // Наложения исключения в случае совпадения узла iI с диагональным 
		    // элементом узла для котторого стоит условие Дирихле не требуется. 
		    // т.к. узлы iI строго внутренние для которых iI < maxelm, а диагональный 
		    // элемент с условием Дирихле стоит в позициях >= maxelm поэтому они не
		    // пересекаются.
			}

			if ((bDirichlet)&&(bmassbal)) {
				// Гаврилов Андрей предлагает поставить по скорости условие Дирихле на выходной границе,
				// так чтобы массовый расход на выходной границе был равен заданному.

                // граничное условие Дирихле
		        // Задано условие равенства скорости удовлетворяющей уравнению неразрывности.

				

		        slb[inumber].aw=1.0;
		        slb[inumber].ai=0.0;

				// сканируем внутреннюю нормаль.
				switch (border_neighbor[inumber].Norm) {
				  case E_SIDE: switch (iVar) {
				             case VELOCITY_X_COMPONENT:  slb[inumber].b=potent[VXCOR][border_neighbor[inumber].iB]; break; //<--
							 case VELOCITY_Y_COMPONENT: slb[inumber].b=potent[VYCOR][border_neighbor[inumber].iB]; break; // разрешаем касательную скорость на выходной границе.
							 case VELOCITY_Z_COMPONENT: slb[inumber].b=potent[VZCOR][border_neighbor[inumber].iB]; break;
				             default: slb[inumber].b=0.0; // запрещаем касательную скорость к выходной границе.

								       break;	         
						   }
						   break;
				  case W_SIDE: switch (iVar) {
				             case VELOCITY_X_COMPONENT:  slb[inumber].b=potent[VXCOR][border_neighbor[inumber].iB]; break; // <--
                             case VELOCITY_Y_COMPONENT: slb[inumber].b=potent[VYCOR][border_neighbor[inumber].iB]; break;
							 case VELOCITY_Z_COMPONENT: slb[inumber].b=potent[VZCOR][border_neighbor[inumber].iB]; break;
				             default: slb[inumber].b=0.0; 
								 break;	         
						   }
					       break;
				  case N_SIDE: switch (iVar) {
					         case VELOCITY_X_COMPONENT:  slb[inumber].b=potent[VXCOR][border_neighbor[inumber].iB]; break;
				             case VELOCITY_Y_COMPONENT:  slb[inumber].b=potent[VYCOR][border_neighbor[inumber].iB]; break; // <--
                             case VELOCITY_Z_COMPONENT: slb[inumber].b=potent[VZCOR][border_neighbor[inumber].iB]; break;
				             default: slb[inumber].b=0.0; break;	         
						   }
					       break;
				  case S_SIDE: switch (iVar) {
					         case VELOCITY_X_COMPONENT:  slb[inumber].b=potent[VXCOR][border_neighbor[inumber].iB]; break;
				             case VELOCITY_Y_COMPONENT:  slb[inumber].b=potent[VYCOR][border_neighbor[inumber].iB]; break; //<--
                             case VELOCITY_Z_COMPONENT: slb[inumber].b=potent[VZCOR][border_neighbor[inumber].iB]; break;
				             default: slb[inumber].b=0.0; break;	         
						   }
						   /*
						   printf("mass ball S ok.\n");
						   printf("vell==%e\n",slb[inumber].b);
				                       getchar();
									   */
					       break;
				  case T_SIDE:  switch (iVar) {
					         case VELOCITY_X_COMPONENT:  slb[inumber].b=potent[VXCOR][border_neighbor[inumber].iB]; break;
				             case VELOCITY_Y_COMPONENT:  slb[inumber].b=potent[VYCOR][border_neighbor[inumber].iB]; break;
				             case VELOCITY_Z_COMPONENT:  slb[inumber].b=potent[VZCOR][border_neighbor[inumber].iB]; break; // <--
				             default: slb[inumber].b=0.0;
								      break;	         
						   }
					       break;
				  case B_SIDE: switch (iVar) {
					         case VELOCITY_X_COMPONENT:  slb[inumber].b=potent[VXCOR][border_neighbor[inumber].iB]; break;
				             case VELOCITY_Y_COMPONENT:  slb[inumber].b=potent[VYCOR][border_neighbor[inumber].iB]; break;
				             case VELOCITY_Z_COMPONENT:  slb[inumber].b=potent[VZCOR][border_neighbor[inumber].iB]; break; // <--
				             default: slb[inumber].b=0.0;
								      break;	         
						   }
					       break;
				}
		        
		        slb[inumber].iI= NON_EXISTENT_NODE; // не присутствует в матрице
		        slb[inumber].iW=border_neighbor[inumber].iB;

		        // Это условие Дирихле:
		        // только диагональный элемент 
		        // не равен нулю.
		        slb[inumber].iW1= NON_EXISTENT_NODE;
                slb[inumber].iW2= NON_EXISTENT_NODE;
                slb[inumber].iW3= NON_EXISTENT_NODE;
                slb[inumber].iW4= NON_EXISTENT_NODE;
			}
	}

} // my_elmatr_quad_F3D_bound

// Учитывает действие перепада давления на контрольный объём
// pterm - pressure term (source). 15.11.2015
void pterm(integer iP, equation3D** &sl,
	doublereal** potent, integer iVar,
	integer maxelm, int** nvtx, TOCHKA* pa, doublereal** &sumanb) 
{
	if (b_on_adaptive_local_refinement_mesh) {
		// Линейная реконструкция давления в ячейке.

		// вычисление размеров текущего контрольного объёма:
		doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контрольного объёма
		volume3D(iP, nvtx, pa, dx, dy, dz);

		switch (iVar) {
		case VELOCITY_X_COMPONENT: sl[iVar][iP].b -= potent[GRADXPRESS][iP] * dx * dy * dz;
			break;
		case VELOCITY_Y_COMPONENT: sl[iVar][iP].b -= potent[GRADYPRESS][iP] * dx * dy * dz;
			break;
		case VELOCITY_Z_COMPONENT: sl[iVar][iP].b -= potent[GRADZPRESS][iP] * dx * dy * dz;
			break;
		}

	}
	else {
		// Standart interpolation Pressure Fluent Theory Guide
		// В даный момент работает только на структурированной сетке.


		// вычисление размеров текущего контрольного объёма:
		doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контрольного объёма
		volume3D(iP, nvtx, pa, dx, dy, dz);



		doublereal Pforward, Pbackward;
		switch (iVar) {
		case VELOCITY_X_COMPONENT:
			Pforward = ((potent[PRESS][iP]/ sumanb[iVar][iP])+
				(potent[PRESS][sl[iVar][iP].iE]/ sumanb[iVar][sl[iVar][iP].iE]))
				/ ((1.0/ sumanb[iVar][iP])+(1.0/ sumanb[iVar][sl[iVar][iP].iE]));
			Pbackward = ((potent[PRESS][iP] / sumanb[iVar][iP]) +
				(potent[PRESS][sl[iVar][iP].iW] / sumanb[iVar][sl[iVar][iP].iW]))
				/ ((1.0 / sumanb[iVar][iP]) + (1.0 / sumanb[iVar][sl[iVar][iP].iW]));
			sl[iVar][iP].b -= (Pforward- Pbackward) * dy * dz;
			break;
		case VELOCITY_Y_COMPONENT:
			Pforward = ((potent[PRESS][iP] / sumanb[iVar][iP]) +
				(potent[PRESS][sl[iVar][iP].iN] / sumanb[iVar][sl[iVar][iP].iN]))
				/ ((1.0 / sumanb[iVar][iP]) + (1.0 / sumanb[iVar][sl[iVar][iP].iN]));
			Pbackward = ((potent[PRESS][iP] / sumanb[iVar][iP]) +
				(potent[PRESS][sl[iVar][iP].iS] / sumanb[iVar][sl[iVar][iP].iS]))
				/ ((1.0 / sumanb[iVar][iP]) + (1.0 / sumanb[iVar][sl[iVar][iP].iS]));
			sl[iVar][iP].b -= (Pforward - Pbackward) * dx * dz;
			break;
		case VELOCITY_Z_COMPONENT:
			Pforward = ((potent[PRESS][iP] / sumanb[iVar][iP]) +
				(potent[PRESS][sl[iVar][iP].iT] / sumanb[iVar][sl[iVar][iP].iT]))
				/ ((1.0 / sumanb[iVar][iP]) + (1.0 / sumanb[iVar][sl[iVar][iP].iT]));
			Pbackward = ((potent[PRESS][iP] / sumanb[iVar][iP]) +
				(potent[PRESS][sl[iVar][iP].iB] / sumanb[iVar][sl[iVar][iP].iB]))
				/ ((1.0 / sumanb[iVar][iP]) + (1.0 / sumanb[iVar][sl[iVar][iP].iB]));
			sl[iVar][iP].b -= (Pforward - Pbackward) * dx * dy;
			break;
		}
	}
} // pterm


// для схемы высокого порядка точности на АЛИС сетке.

void getPoleField_interpolate_na_nvtx(doublereal* &interpolate_component, int &maxnod, int &maxelm,
	TOCHKA*& pa, int**& nvtx, FLOW*& fglobal, TEMPER& t, integer idVar)
{

	// idVar == VXCOR для x компоненты скорости.

	doublereal* vol = new doublereal[maxnod];

#pragma omp parallel for
	for (integer i = 0; i < maxnod; i++) {

		interpolate_component[i] = 0.0;
		vol[i] = 0.0;
	}

	//const integer iRECONSTRUCTION_METHOD = 3;

	// линейная реконструкция, НО по расширенному шаблону.
	// Расширенный шаблон содержит больше опорных точек интерполяции, 
	// поэтому в теории реконструкция должна быть более точная.

	// Метод линейного порядка.
	doublereal min_x = 1e60;
	doublereal min_y = 1e60;
	doublereal min_z = 1e60;
	doublereal max_x = -1e60;
	doublereal max_y = -1e60;
	doublereal max_z = -1e60;

	for (integer i = 0; i < maxnod; i++) {
		if (pa[i].x < min_x) {
			min_x = pa[i].x;
		}
		if (pa[i].y < min_y) {
			min_y = pa[i].y;
		}
		if (pa[i].z < min_z) {
			min_z = pa[i].z;
		}
		if (pa[i].x > max_x) {
			max_x = pa[i].x;
		}
		if (pa[i].y > max_y) {
			max_y = pa[i].y;
		}
		if (pa[i].z > max_z) {
			max_z = pa[i].z;
		}
	}

	doublereal min_x1 = min_x;
	doublereal min_y1 = min_y;
	doublereal min_z1 = min_z;
	//min_x *= 1.2;
	//min_y *= 1.2;
	//min_z *= 1.2;

	// 05.07.2017

	min_x = 1.05 * fabs(max_x - min_x);
	if (min_x < 1.0e-30) {
		min_x = 1.05 * fabs(max_x);
	}
	min_y = 1.05 * fabs(max_y - min_y);
	if (min_y < 1.0e-30) {
		min_y = 1.05 * fabs(max_y);
	}
	min_z = 1.05 * fabs(max_z - min_z);
	if (min_z < 1.0e-30) {
		min_z = 1.05 * fabs(max_z);
	}

	/*
	if (min_x < 1.0e-30) {
		printf("error!!! negative min_x MNK!\n");
		printf("min_x=%e max_x=%e\n", min_x, max_x);
	}
	if (min_y < 1.0e-30) {
		printf("error!!! negative min_y MNK!\n");
		printf("min_y=%e max_y=%e\n", min_y, max_y);
	}
	if (min_z < 1.0e-30) {
		printf("error!!! negative min_z MNK!\n");
		printf("min_z=%e max_z=%e\n", min_z, max_z);
	}
	*/




	//*******************START***************************
	/*
	FILE* fp_4_stub = NULL;
	doublereal* dstub = nullptr;
	// 2 ноября 2016. машинное эпсилон.
	//doublereal eps_mashine = 1.0e-44; // float
	doublereal eps_mashine = 1.0e-308; // double

	bool bptr_rule_namespace_of_hydrodynamic_variables_loc = true; // potent относится к гидродинамике (true) или теплопередаче(false).
	SECOND_ORDER_QUADRATIC_RECONSTRUCT(fp_4_stub, maxnod, maxelm, pa, nvtx, vol, interpolate_component, min_x, min_y, min_z, 
		fglobal[0].potent[idVar], t, eps_mashine,
		bptr_rule_namespace_of_hydrodynamic_variables_loc, dstub, dstub, dstub, true);
		*/

	delete[] vol;

}

// собирает одно уравнение матрицы СЛАУ для обобщенного уравнения 
// конвекции - диффузии, для определённого внутреннего контрольного объёма.
// Для прямоугольной трёхмерной шестигранной Hex сетки.
// Эта сборка применяется только для компонент скорости.
void my_elmatr_quad_F3D(int iP, BOUND* border_neighbor, int lw, int ls,
	                    equation3D** &sl, equation3D_bon** &slb, doublereal** diag_coef,
						integer iVar, bool btimedep, doublereal tauparam, int* ptr,
					    int** nvtx, doublereal** potent, doublereal* potent_temper,
						TOCHKA* pa, float** prop, float** prop_b, integer maxelm, 
						int*** neighbors_for_the_internal_node, doublereal* alpha, 
	                    doublereal dgx, doublereal dgy, doublereal dgz,
						doublereal dbeta, integer ishconvection, bool bBussineskApproach, doublereal temp_ref,
						bool bfirst_start, doublereal RCh, VISCOSITY_MODEL iflowregime,
						doublereal* speedoldtimestep, doublereal* toldtimestep, 
						BLOCK* b, int lb, TPROP* matlist, doublereal** &mf,
	                    bool bVERYStable, doublereal &sumanb,
	                    integer *ilevel_alice, TOCHKA* &center_coord_loc, TOCHKA* &volume_loc,
	                    integer maxbound) {
	// 31 марта 2012 года из функции удалён большой закомментированный фрагмент кода связанный с поправкой Рхи-Чоу.
	// Его можно найти в предыдущих backup`ах программы AliceFlow_v0_07 (и ранее v0_06).

	// speedoldtimestep - компонента скорости, соответствующая iVar, с предыдущего шага по времени,
	// toldtimestep - температура с предыдущего шага по времени.
	// mf - запомненный массовый поток с предыдущей итерации удовлетворяющий поправке Рхи-Чоу.

	// Если bVERYStable равно true то мы не используем метод отложенной коррекции а используем только противопоточную схему первого порядка.
	// Также если bVERYStable==true мы неучитываем явный вклад в тензор касательных напряжений согласно обощённому закону Ньютона.

    // btimedep==false - стационарный, иначе (true) нестационарный
	// tauparam - шаг по времени.
	// посмотреть что будет если ap0 положить равным нулю и ввести нижнюю релаксацию обычным образом.
    // нижняя релаксация уже введена обычным образом !
	// Следующие строки коментария проясняют ситуацию.
	// Итак можно либо вводить нижнюю релаксацию обычным образом (1 ый вариант) как у Патанкара, модифицируя 
	// диагональный коэффициент матрицы ap->ap/alpha и правую часть b->b+ap*Vn-1*(1-alpha)/alpha, 
	// либо отказаться от первого варианта и воспоьзоваться вторым вариантом с введением псевдо времени
	// tau=rho*dx*dy*dz*alpha/ap/(1.0-alpha), apzero=rho*dx*dy*dz/tau;  Заметим что apzero==0.0 при alpha==1.0 что соответствует здравому смыслу.
	// Итак либо первый вариант либо второй и никак иначе.
	// Если здесь выставить imitation_time=true то нужно отключить нижнюю релаксацию при сборки матрицы и в полилинейном методе.
	// Надеюсь вышенаписанный текст разъясняет ситуацию относительно использования параметра imitation_time.
	// Ссылка Гаврилов Андрей sigma flow.
	// Варианты 1 и 2 это две алгебраически эквивалентные формы записи одного и тогоже. Поэтому можно использовать либо 1 либо 2, но
	// ни в коем случае не оба подхода сразу.
    const bool imitation_time=false; // false - псевдо время не используется, true - используется
	/*
	   Просматривая ряд публикаций, главная из которых статья Вабищевича, можно установить
	   что в уравнение для импульса интерполяцию Рхи-Чоу вводить не нужно. Т.к. уравнение для
	   импульса следуя Вабищевичу остаётся таким же каким и раньше, а поправка Рхи-Чоу вводится
	   только в уравнение для поправки давления.
	   Остаётся проверить как это согласуется с англоязычными статьями и как это проявляет себя на 
	   реальных задачах при запуске программы.

	   Основываясь на опыте Гаврилова Андрея (комплекс sigma flow) поправку Рхи-Чоу
	   требуется вводить и в уравнения для скорости а также для температуры. Иначе 
	   поток не будет удовлетворять уравнению неразрывности.

	   Собственное наблюдение состоит в том что по видимому для граничных 
	   КО монотонизирующую поправку Рхи-Чоу применять не следует. Её применение в
	   граничных КО вызывает расходимость солвера. Поэтому требуется положить 
	   bRhieChowi=true;
       bRhieChowb=false;

	   По поводу уменьшения вклада поправки Рхи-Чоу. Судя по публикациям Гаврилова Андрея и Вабищевича
	   RCh стоит всегда брать равным 1.0. По видимому это значение (1.0) также связано с требованием
	   удовлетворить уравнение неразрывности.
	*/

	int iprefix_Scheme = iprefix_Scheme_Flow;



    // iP - номер внутреннего контрольного объёма
	// iP изменяется от 0 до maxelm-1.
	int iE, iN, iT, iW, iS, iB; // номера соседних контрольных объёмов
	iE=neighbors_for_the_internal_node[E_SIDE][0][iP]; iN=neighbors_for_the_internal_node[N_SIDE][0][iP]; iT=neighbors_for_the_internal_node[T_SIDE][0][iP];
	iW=neighbors_for_the_internal_node[W_SIDE][0][iP]; iS=neighbors_for_the_internal_node[S_SIDE][0][iP]; iB=neighbors_for_the_internal_node[B_SIDE][0][iP];
	sl[iVar][iP].iE=iE; sl[iVar][iP].iN=iN; sl[iVar][iP].iT=iT;
	sl[iVar][iP].iS=iS; sl[iVar][iP].iW=iW; sl[iVar][iP].iB=iB;
	sl[iVar][iP].iP = iP;
	
	// 26.09.2016 Добавок для АЛИС сетки.
	int iE2 = -1, iN2 = -1, iT2 = -1, iW2 = -1, iS2 = -1, iB2 = -1; // номера соседних контрольных объёмов
	int iE3 = -1, iN3 = -1, iT3 = -1, iW3 = -1, iS3 = -1, iB3 = -1; // номера соседних контрольных объёмов
	int iE4 = -1, iN4 = -1, iT4 = -1, iW4 = -1, iS4 = -1, iB4 = -1; // номера соседних контрольных объёмов

    // NON_EXISTENT_NODE если не используется и [0..maxelm+maxbound-1] если используется.
	if (b_on_adaptive_local_refinement_mesh) {

		iE2 = neighbors_for_the_internal_node[E_SIDE][1][iP]; iN2 = neighbors_for_the_internal_node[N_SIDE][1][iP]; iT2 = neighbors_for_the_internal_node[T_SIDE][1][iP];
		iW2 = neighbors_for_the_internal_node[W_SIDE][1][iP]; iS2 = neighbors_for_the_internal_node[S_SIDE][1][iP]; iB2 = neighbors_for_the_internal_node[B_SIDE][1][iP];
		iE3 = neighbors_for_the_internal_node[E_SIDE][2][iP]; iN3 = neighbors_for_the_internal_node[N_SIDE][2][iP]; iT3 = neighbors_for_the_internal_node[T_SIDE][2][iP];
		iW3 = neighbors_for_the_internal_node[W_SIDE][2][iP]; iS3 = neighbors_for_the_internal_node[S_SIDE][2][iP]; iB3 = neighbors_for_the_internal_node[B_SIDE][2][iP];
		iE4 = neighbors_for_the_internal_node[E_SIDE][3][iP]; iN4 = neighbors_for_the_internal_node[N_SIDE][3][iP]; iT4 = neighbors_for_the_internal_node[T_SIDE][3][iP];
		iW4 = neighbors_for_the_internal_node[W_SIDE][3][iP]; iS4 = neighbors_for_the_internal_node[S_SIDE][3][iP]; iB4 = neighbors_for_the_internal_node[B_SIDE][3][iP];
	}

	sl[iVar][iP].iE2 = iE2; sl[iVar][iP].iN2 = iN2; sl[iVar][iP].iT2 = iT2;
	sl[iVar][iP].iS2 = iS2; sl[iVar][iP].iW2 = iW2; sl[iVar][iP].iB2 = iB2;

	sl[iVar][iP].iE3 = iE3; sl[iVar][iP].iN3 = iN3; sl[iVar][iP].iT3 = iT3;
	sl[iVar][iP].iS3 = iS3; sl[iVar][iP].iW3 = iW3; sl[iVar][iP].iB3 = iB3;

	sl[iVar][iP].iE4 = iE4; sl[iVar][iP].iN4 = iN4; sl[iVar][iP].iT4 = iT4;
	sl[iVar][iP].iS4 = iS4; sl[iVar][iP].iW4 = iW4; sl[iVar][iP].iB4 = iB4;

	// Инициализирующее обнуление.
	sl[iVar][iP].ae = 0.0;
	sl[iVar][iP].aw = 0.0;
	sl[iVar][iP].an = 0.0;
	sl[iVar][iP].as = 0.0;
	sl[iVar][iP].at = 0.0;
	sl[iVar][iP].ab = 0.0;

	sl[iVar][iP].ae2 = 0.0;
	sl[iVar][iP].aw2 = 0.0;
	sl[iVar][iP].an2 = 0.0;
	sl[iVar][iP].as2 = 0.0;
	sl[iVar][iP].at2 = 0.0;
	sl[iVar][iP].ab2 = 0.0;

	sl[iVar][iP].ae3 = 0.0;
	sl[iVar][iP].aw3 = 0.0;
	sl[iVar][iP].an3 = 0.0;
	sl[iVar][iP].as3 = 0.0;
	sl[iVar][iP].at3 = 0.0;
	sl[iVar][iP].ab3 = 0.0;

	sl[iVar][iP].ae4 = 0.0;
	sl[iVar][iP].aw4 = 0.0;
	sl[iVar][iP].an4 = 0.0;
	sl[iVar][iP].as4 = 0.0;
	sl[iVar][iP].at4 = 0.0;
	sl[iVar][iP].ab4 = 0.0;


	// Признак присутствия связи.
	// От булевых флагов можно избавиться в целях экономии памяти ЭВМ.
	sl[iVar][iP].bE2 = false; sl[iVar][iP].bW2 = false; sl[iVar][iP].bS2 = false;
	sl[iVar][iP].bN2 = false; sl[iVar][iP].bB2 = false; sl[iVar][iP].bT2 = false;

	sl[iVar][iP].bE3 = false; sl[iVar][iP].bW3 = false; sl[iVar][iP].bS3 = false;
	sl[iVar][iP].bN3 = false; sl[iVar][iP].bB3 = false; sl[iVar][iP].bT3 = false;

	sl[iVar][iP].bE4 = false; sl[iVar][iP].bW4 = false; sl[iVar][iP].bS4 = false;
	sl[iVar][iP].bN4 = false; sl[iVar][iP].bB4 = false; sl[iVar][iP].bT4 = false;

	if (CHECK_NODE_FOR_EXISTENCE(iE2)) sl[iVar][iP].bE2 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iW2)) sl[iVar][iP].bW2 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iN2)) sl[iVar][iP].bN2 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iS2)) sl[iVar][iP].bS2 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iT2)) sl[iVar][iP].bT2 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iB2)) sl[iVar][iP].bB2 = true;

	if (CHECK_NODE_FOR_EXISTENCE(iE3)) sl[iVar][iP].bE3 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iW3)) sl[iVar][iP].bW3 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iN3)) sl[iVar][iP].bN3 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iS3)) sl[iVar][iP].bS3 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iT3)) sl[iVar][iP].bT3 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iB3)) sl[iVar][iP].bB3 = true;

	if (CHECK_NODE_FOR_EXISTENCE(iE4)) sl[iVar][iP].bE4 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iW4)) sl[iVar][iP].bW4 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iN4)) sl[iVar][iP].bN4 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iS4)) sl[iVar][iP].bS4 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iT4)) sl[iVar][iP].bT4 = true;
	if (CHECK_NODE_FOR_EXISTENCE(iB4)) sl[iVar][iP].bB4 = true;

	// Внутренний КО.	

	// Если с одной из сторон стоит граница расчётной области
	// то соответствующая переменная равна true
	bool bE=false, bN=false, bT=false, bW=false, bS=false, bB=false;
    
	if ((iE>=maxelm) && (iE < maxelm + maxbound)) bE=true;
	if ((iN>=maxelm) && (iN < maxelm + maxbound)) bN=true;
	if ((iT>=maxelm) && (iT < maxelm + maxbound)) bT=true;
    if ((iW>=maxelm) && (iW < maxelm + maxbound)) bW=true;
	if ((iS>=maxelm) && (iS < maxelm + maxbound)) bS=true;
	if ((iB>=maxelm) && (iB < maxelm + maxbound)) bB=true;

	bool bE2 = false, bN2 = false, bT2 = false, bW2 = false, bS2 = false, bB2 = false;

	if ((iE2 >= maxelm) && (iE2 < maxelm + maxbound)) bE2 = true;
	if ((iN2 >= maxelm) && (iN2 < maxelm + maxbound)) bN2 = true;
	if ((iT2 >= maxelm) && (iT2 < maxelm + maxbound)) bT2 = true;
	if ((iW2 >= maxelm) && (iW2 < maxelm + maxbound)) bW2 = true;
	if ((iS2 >= maxelm) && (iS2 < maxelm + maxbound)) bS2 = true;
	if ((iB2 >= maxelm) && (iB2 < maxelm + maxbound)) bB2 = true;

	bool bE3 = false, bN3 = false, bT3 = false, bW3 = false, bS3 = false, bB3 = false;

	if ((iE3 >= maxelm) && (iE3 < maxelm + maxbound)) bE3 = true;
	if ((iN3 >= maxelm) && (iN3 < maxelm + maxbound)) bN3 = true;
	if ((iT3 >= maxelm) && (iT3 < maxelm + maxbound)) bT3 = true;
	if ((iW3 >= maxelm) && (iW3 < maxelm + maxbound)) bW3 = true;
	if ((iS3 >= maxelm) && (iS3 < maxelm + maxbound)) bS3 = true;
	if ((iB3 >= maxelm) && (iB3 < maxelm + maxbound)) bB3 = true;

	bool bE4 = false, bN4 = false, bT4 = false, bW4 = false, bS4 = false, bB4 = false;

	if ((iE4 >= maxelm) && (iE4 < maxelm + maxbound)) bE4 = true;
	if ((iN4 >= maxelm) && (iN4 < maxelm + maxbound)) bN4 = true;
	if ((iT4 >= maxelm) && (iT4 < maxelm + maxbound)) bT4 = true;
	if ((iW4 >= maxelm) && (iW4 < maxelm + maxbound)) bW4 = true;
	if ((iS4 >= maxelm) && (iS4 < maxelm + maxbound)) bS4 = true;
	if ((iB4 >= maxelm) && (iB4 < maxelm + maxbound)) bB4 = true;
		
	// вычисление размеров текущего контрольного объёма:
	doublereal dx=0.0, dy=0.0, dz=0.0;// объём текущего контрольного объёма
	//volume3D(iP, nvtx, pa, dx, dy, dz);

	TOCHKA pvol = volume_loc[iP];
	dx = pvol.x;
	dy = pvol.y;
	dz = pvol.z;

	   
	//printf("%.2f %.2f\n",dx,dy); // debug GOOD
	//getchar();

	doublereal dxe=0.5*dx, dxw=0.5*dx, dyn=0.5*dy, dys=0.5*dy, dzt=0.5*dz, dzb=0.5*dz;
    // т.к. известна нумерация вершин куба, то здесь она используется
	// x - direction
	if (CHECK_NODE_FOR_EXISTENCE(iE)) {
		if (!bE) {
			dxe = 0.5*(pa[nvtx[1][iE] - 1].x + pa[nvtx[0][iE] - 1].x);
			dxe -= 0.5*(pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
		}
	}
	if (CHECK_NODE_FOR_EXISTENCE(iW)) {
		if (!bW) {
			dxw = 0.5*(pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
			dxw -= 0.5*(pa[nvtx[1][iW] - 1].x + pa[nvtx[0][iW] - 1].x);
		}
	}
    // y - direction
	if (CHECK_NODE_FOR_EXISTENCE(iN)) {
		if (!bN) {
			dyn = 0.5*(pa[nvtx[2][iN] - 1].y + pa[nvtx[0][iN] - 1].y);
			dyn -= 0.5*(pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
		}
	}
	if (CHECK_NODE_FOR_EXISTENCE(iS)) {
		if (!bS) {
			dys = 0.5*(pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
			dys -= 0.5*(pa[nvtx[2][iS] - 1].y + pa[nvtx[0][iS] - 1].y);
		}
	}
    // z - direction
	if (CHECK_NODE_FOR_EXISTENCE(iT)) {
		if (!bT) {
			dzt = 0.5*(pa[nvtx[4][iT] - 1].z + pa[nvtx[0][iT] - 1].z);
			dzt -= 0.5*(pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
		}
	}
	if (CHECK_NODE_FOR_EXISTENCE(iB)) {
		if (!bB) {
			dzb = 0.5*(pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
			dzb -= 0.5*(pa[nvtx[4][iB] - 1].z + pa[nvtx[0][iB] - 1].z);
		}
	}


	doublereal dxe2 = 0.5*dx, dxw2 = 0.5*dx, dyn2 = 0.5*dy, dys2 = 0.5*dy, dzt2 = 0.5*dz, dzb2 = 0.5*dz;
	doublereal dxe3 = 0.5*dx, dxw3 = 0.5*dx, dyn3 = 0.5*dy, dys3 = 0.5*dy, dzt3 = 0.5*dz, dzb3 = 0.5*dz;
	doublereal dxe4 = 0.5*dx, dxw4 = 0.5*dx, dyn4 = 0.5*dy, dys4 = 0.5*dy, dzt4 = 0.5*dz, dzb4 = 0.5*dz;

	if (b_on_adaptive_local_refinement_mesh) {

		// т.к. известна нумерация вершин куба, то здесь она используется
		// x - direction
		if (CHECK_NODE_FOR_EXISTENCE(iE2)) {
			if (!bE2) {
				dxe2 = 0.5 * (pa[nvtx[1][iE2] - 1].x + pa[nvtx[0][iE2] - 1].x);
				dxe2 -= 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
			}
		}
		if (CHECK_NODE_FOR_EXISTENCE(iW2)) {
			if (!bW2) {
				dxw2 = 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
				dxw2 -= 0.5 * (pa[nvtx[1][iW2] - 1].x + pa[nvtx[0][iW2] - 1].x);
			}
		}
		// y - direction
		if (CHECK_NODE_FOR_EXISTENCE(iN2)) {
			if (!bN2) {
				dyn2 = 0.5 * (pa[nvtx[2][iN2] - 1].y + pa[nvtx[0][iN2] - 1].y);
				dyn2 -= 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
			}
		}
		if (CHECK_NODE_FOR_EXISTENCE(iS2)) {
			if (!bS2) {
				dys2 = 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
				dys2 -= 0.5 * (pa[nvtx[2][iS2] - 1].y + pa[nvtx[0][iS2] - 1].y);
			}
		}
		// z - direction
		if (CHECK_NODE_FOR_EXISTENCE(iT2)) {
			if (!bT2) {
				dzt2 = 0.5 * (pa[nvtx[4][iT2] - 1].z + pa[nvtx[0][iT2] - 1].z);
				dzt2 -= 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
			}
		}
		if (CHECK_NODE_FOR_EXISTENCE(iB2)) {
			if (!bB2) {
				dzb2 = 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
				dzb2 -= 0.5 * (pa[nvtx[4][iB2] - 1].z + pa[nvtx[0][iB2] - 1].z);
			}
		}

		// т.к. известна нумерация вершин куба, то здесь она используется
		// x - direction
		if (CHECK_NODE_FOR_EXISTENCE(iE3)) {
			if (!bE3) {
				dxe3 = 0.5 * (pa[nvtx[1][iE3] - 1].x + pa[nvtx[0][iE3] - 1].x);
				dxe3 -= 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
			}
		}
		if (CHECK_NODE_FOR_EXISTENCE(iW3)) {
			if (!bW3) {
				dxw3 = 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
				dxw3 -= 0.5 * (pa[nvtx[1][iW3] - 1].x + pa[nvtx[0][iW3] - 1].x);
			}
		}
		// y - direction
		if (CHECK_NODE_FOR_EXISTENCE(iN3)) {
			if (!bN3) {
				dyn3 = 0.5 * (pa[nvtx[2][iN3] - 1].y + pa[nvtx[0][iN3] - 1].y);
				dyn3 -= 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
			}
		}
		if (CHECK_NODE_FOR_EXISTENCE(iS3)) {
			if (!bS3) {
				dys3 = 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
				dys3 -= 0.5 * (pa[nvtx[2][iS3] - 1].y + pa[nvtx[0][iS3] - 1].y);
			}
		}
		// z - direction
		if (CHECK_NODE_FOR_EXISTENCE(iT3)) {
			if (!bT3) {
				dzt3 = 0.5 * (pa[nvtx[4][iT3] - 1].z + pa[nvtx[0][iT3] - 1].z);
				dzt3 -= 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
			}
		}
		if (CHECK_NODE_FOR_EXISTENCE(iB3)) {
			if (!bB3) {
				dzb3 = 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
				dzb3 -= 0.5 * (pa[nvtx[4][iB3] - 1].z + pa[nvtx[0][iB3] - 1].z);
			}
		}

		// т.к. известна нумерация вершин куба, то здесь она используется
		// x - direction
		if (CHECK_NODE_FOR_EXISTENCE(iE4)) {
			if (!bE4) {
				dxe4 = 0.5 * (pa[nvtx[1][iE4] - 1].x + pa[nvtx[0][iE4] - 1].x);
				dxe4 -= 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
			}
		}
		if (CHECK_NODE_FOR_EXISTENCE(iW4)) {
			if (!bW4) {
				dxw4 = 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
				dxw4 -= 0.5 * (pa[nvtx[1][iW4] - 1].x + pa[nvtx[0][iW4] - 1].x);
			}
		}
		// y - direction
		if (CHECK_NODE_FOR_EXISTENCE(iN4)) {
			if (!bN4) {
				dyn4 = 0.5 * (pa[nvtx[2][iN4] - 1].y + pa[nvtx[0][iN4] - 1].y);
				dyn4 -= 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
			}
		}
		if (CHECK_NODE_FOR_EXISTENCE(iS4)) {
			if (!bS4) {
				dys4 = 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
				dys4 -= 0.5 * (pa[nvtx[2][iS4] - 1].y + pa[nvtx[0][iS4] - 1].y);
			}
		}
		// z - direction
		if (CHECK_NODE_FOR_EXISTENCE(iT4)) {
			if (!bT4) {
				dzt4 = 0.5 * (pa[nvtx[4][iT4] - 1].z + pa[nvtx[0][iT4] - 1].z);
				dzt4 -= 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
			}
		}
		if (CHECK_NODE_FOR_EXISTENCE(iB4)) {
			if (!bB4) {
				dzb4 = 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
				dzb4 -= 0.5 * (pa[nvtx[4][iB4] - 1].z + pa[nvtx[0][iB4] - 1].z);
			}
		}

	}

	// Учёт неравномерности расчётной сетки:
	doublereal feplus, fwplus, fnplus, fsplus, ftplus, fbplus;
	// x-direction
	feplus=0.5*dx/dxe;
	fwplus=0.5*dx/dxw;
	// y-direction
	fnplus=0.5*dy/dyn;
	fsplus=0.5*dy/dys;
	// z-direction
	ftplus=0.5*dz/dzt;
	fbplus=0.5*dz/dzb;

	doublereal feplus2, fwplus2, fnplus2, fsplus2, ftplus2, fbplus2;
	doublereal feplus3, fwplus3, fnplus3, fsplus3, ftplus3, fbplus3;
	doublereal feplus4, fwplus4, fnplus4, fsplus4, ftplus4, fbplus4;

	if (b_on_adaptive_local_refinement_mesh) {

		// x-direction
		feplus2 = 0.5 * dx / dxe2;
		fwplus2 = 0.5 * dx / dxw2;
		// y-direction
		fnplus2 = 0.5 * dy / dyn2;
		fsplus2 = 0.5 * dy / dys2;
		// z-direction
		ftplus2 = 0.5 * dz / dzt2;
		fbplus2 = 0.5 * dz / dzb2;
		
		// x-direction
		feplus3 = 0.5 * dx / dxe3;
		fwplus3 = 0.5 * dx / dxw3;
		// y-direction
		fnplus3 = 0.5 * dy / dyn3;
		fsplus3 = 0.5 * dy / dys3;
		// z-direction
		ftplus3 = 0.5 * dz / dzt3;
		fbplus3 = 0.5 * dz / dzb3;
		
		// x-direction
		feplus4 = 0.5 * dx / dxe4;
		fwplus4 = 0.5 * dx / dxw4;
		// y-direction
		fnplus4 = 0.5 * dy / dyn4;
		fsplus4 = 0.5 * dy / dys4;
		// z-direction
		ftplus4 = 0.5 * dz / dzt4;
		fbplus4 = 0.5 * dz / dzb4;

	}

	//printf("%e %e %e %e %e %e\n",feplus, fwplus, fnplus, fsplus, ftplus, fbplus);
	//getchar();

	// плотность на грани КО аппроксимируется средним гармоническим	
	doublereal rP, rE=0.0, rN=0.0, rT=0.0, rW=0.0, rS=0.0, rB=0.0;
    rP=prop[RHO][iP];
	if (iE > -1) {
		if (!bE) rE = prop[RHO][iE]; else rE = prop_b[RHO][iE - maxelm];
	}
	if (iN > -1) {
		if (!bN) rN = prop[RHO][iN]; else rN = prop_b[RHO][iN - maxelm];
	}
	if (iT > -1) {
		if (!bT) rT = prop[RHO][iT]; else rT = prop_b[RHO][iT - maxelm];
	}
	if (iW > -1) {
		if (!bW) rW = prop[RHO][iW]; else rW = prop_b[RHO][iW - maxelm];
	}
	if (iS > -1) {
		if (!bS) rS = prop[RHO][iS]; else rS = prop_b[RHO][iS - maxelm];
	}
	if (iB > -1) {
		if (!bB) rB = prop[RHO][iB]; else rB = prop_b[RHO][iB - maxelm];
	}

	doublereal  rE2 = 0.0, rN2 = 0.0, rT2 = 0.0, rW2 = 0.0, rS2 = 0.0, rB2 = 0.0;
	doublereal  rE3 = 0.0, rN3 = 0.0, rT3 = 0.0, rW3 = 0.0, rS3 = 0.0, rB3 = 0.0;
	doublereal  rE4 = 0.0, rN4 = 0.0, rT4 = 0.0, rW4 = 0.0, rS4 = 0.0, rB4 = 0.0;

	if (b_on_adaptive_local_refinement_mesh) {

		if (iE2 > -1) {
			if (!bE2) rE2 = prop[RHO][iE2]; else rE2 = prop_b[RHO][iE2 - maxelm];
		}
		if (iN2 > -1) {
			if (!bN2) rN2 = prop[RHO][iN2]; else rN2 = prop_b[RHO][iN2 - maxelm];
		}
		if (iT2 > -1) {
			if (!bT2) rT2 = prop[RHO][iT2]; else rT2 = prop_b[RHO][iT2 - maxelm];
		}
		if (iW2 > -1) {
			if (!bW2) rW2 = prop[RHO][iW2]; else rW2 = prop_b[RHO][iW2 - maxelm];
		}
		if (iS2 > -1) {
			if (!bS2) rS2 = prop[RHO][iS2]; else rS2 = prop_b[RHO][iS2 - maxelm];
		}
		if (iB2 > -1) {
			if (!bB2) rB2 = prop[RHO][iB2]; else rB2 = prop_b[RHO][iB2 - maxelm];
		}
		
		if (iE3 > -1) {
			if (!bE3) rE3 = prop[RHO][iE3]; else rE3 = prop_b[RHO][iE3 - maxelm];
		}
		if (iN3 > -1) {
			if (!bN3) rN3 = prop[RHO][iN3]; else rN3 = prop_b[RHO][iN3 - maxelm];
		}
		if (iT3 > -1) {
			if (!bT3) rT3 = prop[RHO][iT3]; else rT3 = prop_b[RHO][iT3 - maxelm];
		}
		if (iW3 > -1) {
			if (!bW3) rW3 = prop[RHO][iW3]; else rW3 = prop_b[RHO][iW3 - maxelm];
		}
		if (iS3 > -1) {
			if (!bS3) rS3 = prop[RHO][iS3]; else rS3 = prop_b[RHO][iS3 - maxelm];
		}
		if (iB3 > -1) {
			if (!bB3) rB3 = prop[RHO][iB3]; else rB3 = prop_b[RHO][iB3 - maxelm];
		}
		
		if (iE4 > -1) {
			if (!bE4) rE4 = prop[RHO][iE4]; else rE4 = prop_b[RHO][iE4 - maxelm];
		}
		if (iN4 > -1) {
			if (!bN4) rN4 = prop[RHO][iN4]; else rN4 = prop_b[RHO][iN4 - maxelm];
		}
		if (iT4 > -1) {
			if (!bT4) rT4 = prop[RHO][iT4]; else rT4 = prop_b[RHO][iT4 - maxelm];
		}
		if (iW4 > -1) {
			if (!bW4) rW4 = prop[RHO][iW4]; else rW4 = prop_b[RHO][iW4 - maxelm];
		}
		if (iS4 > -1) {
			if (!bS4) rS4 = prop[RHO][iS4]; else rS4 = prop_b[RHO][iS4 - maxelm];
		}
		if (iB4 > -1) {
			if (!bB4) rB4 = prop[RHO][iB4]; else rB4 = prop_b[RHO][iB4 - maxelm];
		}

	}
	/*
	doublereal rhoe, rhow, rhon, rhos, rhot, rhob;
	// Значение плотности  на грани КО:  
	rhoe=rE*rP/(feplus*rE+(1.0-feplus)*rP);  // проверено.
	rhow=rW*rP/(fwplus*rW+(1.0-fwplus)*rP);
	rhon=rN*rP/(fnplus*rN+(1.0-fnplus)*rP);
	rhos=rS*rP/(fsplus*rS+(1.0-fsplus)*rP);
    rhot=rT*rP/(ftplus*rT+(1.0-ftplus)*rP);
	rhob=rB*rP/(fbplus*rB+(1.0-fbplus)*rP);

	
	doublereal rhoe2, rhow2, rhon2, rhos2, rhot2, rhob2;
	doublereal rhoe3, rhow3, rhon3, rhos3, rhot3, rhob3;
	doublereal rhoe4, rhow4, rhon4, rhos4, rhot4, rhob4;

	rhoe2 = rE2 * rP / (feplus2*rE2 + (1.0 - feplus2)*rP);
	rhow2 = rW2 * rP / (fwplus2*rW2 + (1.0 - fwplus2)*rP);
	rhon2 = rN2 * rP / (fnplus2*rN2 + (1.0 - fnplus2)*rP);
	rhos2 = rS2 * rP / (fsplus2*rS2 + (1.0 - fsplus2)*rP);
	rhot2 = rT2 * rP / (ftplus2*rT2 + (1.0 - ftplus2)*rP);
	rhob2 = rB2 * rP / (fbplus2*rB2 + (1.0 - fbplus2)*rP);

	rhoe3 = rE3 * rP / (feplus3*rE3 + (1.0 - feplus3)*rP);
	rhow3 = rW3 * rP / (fwplus3*rW3 + (1.0 - fwplus3)*rP);
	rhon3 = rN3 * rP / (fnplus3*rN3 + (1.0 - fnplus3)*rP);
	rhos3 = rS3 * rP / (fsplus3*rS3 + (1.0 - fsplus3)*rP);
	rhot3 = rT3 * rP / (ftplus3*rT3 + (1.0 - ftplus3)*rP);
	rhob3 = rB3 * rP / (fbplus3*rB3 + (1.0 - fbplus3)*rP);

	rhoe4 = rE4 * rP / (feplus4*rE4 + (1.0 - feplus4)*rP);
	rhow4 = rW4 * rP / (fwplus4*rW4 + (1.0 - fwplus4)*rP);
	rhon4 = rN4 * rP / (fnplus4*rN4 + (1.0 - fnplus4)*rP);
	rhos4 = rS4 * rP / (fsplus4*rS4 + (1.0 - fsplus4)*rP);
	rhot4 = rT4 * rP / (ftplus4*rT4 + (1.0 - ftplus4)*rP);
	rhob4 = rB4 * rP / (fbplus4*rB4 + (1.0 - fbplus4)*rP);
	*/
	doublereal rhoe = 0.0, rhow = 0.0, rhon = 0.0, rhos = 0.0, rhot = 0.0, rhob = 0.0;
	// интерполяция плотности сделана так, чтобы выполнялись 
	// предельные соотношения.
	if (iE > -1) {
		if (!bE) rhoe = rE * rP / (feplus*rE + (1.0 - feplus)*rP); else rhoe = rE; // проверено !
	}
	if (iW > -1) {
		if (!bW) rhow = rW * rP / (fwplus*rW + (1.0 - fwplus)*rP); else rhow = rW;
	}
	if (iN > -1) {
		if (!bN) rhon = rN * rP / (fnplus*rN + (1.0 - fnplus)*rP); else rhon = rN;
	}
	if (iS > -1) {
		if (!bS) rhos = rS * rP / (fsplus*rS + (1.0 - fsplus)*rP); else rhos = rS;
	}
	if (iT > -1) {
		if (!bT) rhot = rT * rP / (ftplus*rT + (1.0 - ftplus)*rP); else rhot = rT;
	}
	if (iB > -1) {
		if (!bB) rhob = rB * rP / (fbplus*rB + (1.0 - fbplus)*rP); else rhob = rB;
	}

	/*
	doublereal rhoe2 = 0.0, rhow2 = 0.0, rhon2 = 0.0, rhos2 = 0.0, rhot2 = 0.0, rhob2 = 0.0;
	doublereal rhoe3 = 0.0, rhow3 = 0.0, rhon3 = 0.0, rhos3 = 0.0, rhot3 = 0.0, rhob3 = 0.0;
	doublereal rhoe4 = 0.0, rhow4 = 0.0, rhon4 = 0.0, rhos4 = 0.0, rhot4 = 0.0, rhob4 = 0.0;

	if (iE2 > -1) {
		if (!bE2)  rhoe2 = rE2 * rP / (feplus2*rE2 + (1.0 - feplus2)*rP); else rhoe2 = rE2; // проверено !
	}
	if (iW2 > -1) {
		if (!bW2)  rhow2 = rW2 * rP / (fwplus2*rW2 + (1.0 - fwplus2)*rP); else rhow2 = rW2;
	}
	if (iN2 > -1) {
		if (!bN2) rhon2 = rN2 * rP / (fnplus2*rN2 + (1.0 - fnplus2)*rP); else rhon2 = rN2;
	}
	if (iS2 > -1) {
		if (!bS2)  rhos2 = rS2 * rP / (fsplus2*rS2 + (1.0 - fsplus2)*rP); else rhos2 = rS2;
	}
	if (iT2 > -1) {
		if (!bT2)  rhot2 = rT2 * rP / (ftplus2*rT2 + (1.0 - ftplus2)*rP); else rhot2 = rT2;
	}
	if (iB2 > -1) {
		if (!bB2) rhob2 = rB2 * rP / (fbplus2*rB2 + (1.0 - fbplus2)*rP); else rhob2 = rB2;
	}

	if (iE3 > -1) {
		if (!bE3) rhoe3 = rE3 * rP / (feplus3*rE3 + (1.0 - feplus3)*rP); else rhoe3 = rE3;
	}
	if (iW3 > -1) {
		if (!bW3) rhow3 = rW3 * rP / (fwplus3*rW3 + (1.0 - fwplus3)*rP); else rhow3 = rW3;
	}
	if (iN3 > -1) {
		if (!bN3) rhon3 = rN3 * rP / (fnplus3*rN3 + (1.0 - fnplus3)*rP); else rhon3 = rN3;
	}
	if (iS3 > -1) {
		if (!bS3) rhos3 = rS3 * rP / (fsplus3*rS3 + (1.0 - fsplus3)*rP); else rhos3 = rS3;
	}
	if (iT3 > -1) {
		if (!bT3) rhot3 = rT3 * rP / (ftplus3*rT3 + (1.0 - ftplus3)*rP); else rhot3 = rT3;
	}
	if (iB3 > -1) {
		if (!bB3) rhob3 = rB3 * rP / (fbplus3*rB3 + (1.0 - fbplus3)*rP); else rhob3 = rB3;
	}

	if (iE4 > -1) {
		if (!bE4) rhoe4 = rE4 * rP / (feplus4*rE4 + (1.0 - feplus4)*rP); else rhoe4 = rE4;
	}
	if (iW4 > -1) {
		if (!bW4) rhow4 = rW4 * rP / (fwplus4*rW4 + (1.0 - fwplus4)*rP); else rhow4 = rW4;
	}
	if (iN4 > -1) {
		if (!bN4) rhon4 = rN4 * rP / (fnplus4*rN4 + (1.0 - fnplus4)*rP); else rhon4 = rN4;
	}
	if (iS4 > -1) {
		if (!bS4) rhos4 = rS4 * rP / (fsplus4*rS4 + (1.0 - fsplus4)*rP); else rhos4 = rS4;
	}
	if (iT4 > -1) {
		if (!bT4) rhot4 = rT4 * rP / (ftplus4*rT4 + (1.0 - ftplus4)*rP); else rhot4 = rT4;
	}
	if (iB4 > -1) {
		if (!bB4) rhob4 = rB4 * rP / (fbplus4*rB4 + (1.0 - fbplus4)*rP); else rhob4 = rB4;
	}
	*/



	/*
	   Особенности реализации:
	   По видимому интерполяция Рхи-Чоу скорости на грани КО
	   должна быть применена и в уравнениях для компонент скорости. 
	   Она действительно должна быть применена для вычисления потоков на грани контрольного объёма
	   в уравнениях сохранения импульса, теплопроводности и турбулентных характеристик т.к. её применение 
	   гарантирует что потоки будут удовлетворять уравнению неразрывности. Если для вычисления потоков не 
	   применять интерполяцию Рхи-Чоу то хотя шахматных осцилляций и не возникнет (речь идёт о неприменении 
	   только в уравнении сохранения импульса и теплопроводности. для поправки давления применять обязательно
	   следует иначе возникнут шахматные осцилляции) но потоки массы не будут удовлетворять уравнению неразрывности
	   и следовательно решение будет неверным.
	   Особенностью реализации интерполяции является то что она запоминается, а
	   не вычисляется каждый раз. Она вычисляется после процедуры корректировки скорости один раз на основе
	   скорректированной скорости и давления. При вычислении требуются диагональные коэффициенты в
	   уравнениях для компонент скорости. Они берутся с прошлой итерации алгоритма 
	   SIMPLE (на момент непосредственного вычисления потоков коэффициенты берутся с текущей итерации, но
	   дело в том что потом мы на следующей итерации используем вычисленные ранее потоки массы (которые были запомнены в памяти)
	   и поэтому говорим что диагональные коэффициенты беруться с предыдущей итерации). 
	   требуется всеобъемлющая проверка... 
	   Особенно должна обрабатываться первая итерация, т.к. на ней диагональные коэффициенты
	   для всех точек ещё не посчитаны. Поэтому предлагается включать интерполяцию Рхи-Чоу только
	   со второй итерации алгоритма SIMPLE. На первой итерации стационарного солвера используется
	   массовый поток полученный простой линейной интерполяцией скорости.
	*/

    
	// конвективный поток через грань КО.
    // с предыдущей итерации с учётом нестационарности удовлетворяющий 
    // добавлению монотонизирующей поправки Рхи-Чоу.
	doublereal Fe=0.0, Fw=0.0, Fn=0.0, Fs=0.0, Ft=0.0, Fb=0.0;
	

	// Для АЛИС сетки.
	doublereal Fe1 = 0.0, Fe2 = 0.0, Fe3 = 0.0, Fe4 = 0.0;
	doublereal Fw1 = 0.0, Fw2 = 0.0, Fw3 = 0.0, Fw4 = 0.0;
	doublereal Fn1 = 0.0, Fn2 = 0.0, Fn3 = 0.0, Fn4 = 0.0;
	doublereal Fs1 = 0.0, Fs2 = 0.0, Fs3 = 0.0, Fs4 = 0.0;
	doublereal Ft1 = 0.0, Ft2 = 0.0, Ft3 = 0.0, Ft4 = 0.0;
	doublereal Fb1 = 0.0, Fb2 = 0.0, Fb3 = 0.0, Fb4 = 0.0;

	// Массовый поток запоминается а не вычисляется, 
	// это должно плодотворно сказаться на скорости сборки матрицы СЛАУ.
	if (!b_on_adaptive_local_refinement_mesh) {
		if (Fe != Fe) {
			printf("Fe=%e\n", Fe);
		}
		Fe = mf[iP][E_SIDE];
		if (Fe != Fe) {
			printf("Fe=%e\n",Fe);
			system("pause");
		}
		Fn = mf[iP][N_SIDE];
		Ft = mf[iP][T_SIDE];
		Fw = mf[iP][W_SIDE];
		Fs = mf[iP][S_SIDE];
		Fb = mf[iP][B_SIDE];
	}
	else {
		// поток на АЛИС. 24.11.2018

		if (iE > -1) {
			if (bE) {
				// граничный узел.
				Fe = mf[iP][E_SIDE]*(border_neighbor[iE - maxelm].dS/(dy*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iE]]) {
					Fe = mf[iP][E_SIDE];
				}
				else {
					
					Fe = mf[iE][W_SIDE];

				}
			}
		}

		if (iW > -1) {
			if (bW) {
				// граничный узел.
				Fw = mf[iP][W_SIDE] * (border_neighbor[iW - maxelm].dS / (dy*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iW]]) {
					Fw = mf[iP][W_SIDE];
				}
				else {

					Fw = mf[iW][E_SIDE];

				}
			}
		}
		
		if (iN > -1) {
			if (bN) {
				// граничный узел.
				Fn = mf[iP][N_SIDE] * (border_neighbor[iN - maxelm].dS / (dx*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iN]]) {
					Fn = mf[iP][N_SIDE];
				}
				else {

					Fn = mf[iN][S_SIDE];

				}
			}
		}

		if (iS > -1) {
			if (bS) {
				// граничный узел.
				Fs = mf[iP][S_SIDE] * (border_neighbor[iS - maxelm].dS / (dx*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iS]]) {
					Fs = mf[iP][S_SIDE];
				}
				else {

					Fs = mf[iS][N_SIDE];

				}
			}
		}

		if (iT > -1) {
			if (bT) {
				// граничный узел.
				Ft = mf[iP][T_SIDE] * (border_neighbor[iT - maxelm].dS / (dx*dy));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iT]]) {
					Ft = mf[iP][T_SIDE];
				}
				else {

					Ft = mf[iT][B_SIDE];

				}
			}
		}

		if (iB > -1) {
			if (bB) {
				// граничный узел.
				Fb = mf[iP][B_SIDE] * (border_neighbor[iB - maxelm].dS / (dx*dy));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iB]]) {
					Fb = mf[iP][B_SIDE];
				}
				else {

					Fb = mf[iB][T_SIDE];

				}
			}
		}

		if (iE2 > -1) {
			if (bE2) {
				// граничный узел.
				Fe2 = mf[iP][E_SIDE] * (border_neighbor[iE2 - maxelm].dS / (dy*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iE2]]) {
					Fe2 = mf[iP][E_SIDE];
				}
				else {

					Fe2 = mf[iE2][W_SIDE];

				}
			}
		}

		if (iW2 > -1) {
			if (bW2) {
				// граничный узел.
				Fw2 = mf[iP][W_SIDE] * (border_neighbor[iW2 - maxelm].dS / (dy*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iW2]]) {
					Fw = mf[iP][W_SIDE];
				}
				else {

					Fw = mf[iW2][E_SIDE];

				}
			}
		}

		if (iN2 > -1) {
			if (bN2) {
				// граничный узел.
				Fn2 = mf[iP][N_SIDE] * (border_neighbor[iN2 - maxelm].dS / (dx*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iN2]]) {
					Fn2 = mf[iP][N_SIDE];
				}
				else {

					Fn2 = mf[iN2][S_SIDE];

				}
			}
		}

		if (iS2 > -1) {
			if (bS2) {
				// граничный узел.
				Fs2 = mf[iP][S_SIDE] * (border_neighbor[iS2 - maxelm].dS / (dx*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iS2]]) {
					Fs2 = mf[iP][S_SIDE];
				}
				else {

					Fs2 = mf[iS2][N_SIDE];

				}
			}
		}

		if (iT2 > -1) {
			if (bT2) {
				// граничный узел.
				Ft2 = mf[iP][T_SIDE] * (border_neighbor[iT2 - maxelm].dS / (dx*dy));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iT2]]) {
					Ft2 = mf[iP][T_SIDE];
				}
				else {

					Ft2 = mf[iT2][B_SIDE];

				}
			}
		}

		if (iB2 > -1) {
			if (bB2) {
				// граничный узел.
				Fb2 = mf[iP][B_SIDE] * (border_neighbor[iB2 - maxelm].dS / (dx*dy));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iB2]]) {
					Fb2 = mf[iP][B_SIDE];
				}
				else {

					Fb2 = mf[iB2][T_SIDE];

				}
			}
		}


		if (iE3 > -1) {
			if (bE3) {
				// граничный узел.
				Fe3 = mf[iP][E_SIDE] * (border_neighbor[iE3 - maxelm].dS / (dy*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iE3]]) {
					Fe3 = mf[iP][E_SIDE];
				}
				else {

					Fe3 = mf[iE3][W_SIDE];

				}
			}
		}

		if (iW3 > -1) {
			if (bW3) {
				// граничный узел.
				Fw3 = mf[iP][W_SIDE] * (border_neighbor[iW3 - maxelm].dS / (dy*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iW3]]) {
					Fw3 = mf[iP][W_SIDE];
				}
				else {

					Fw3 = mf[iW3][E_SIDE];

				}
			}
		}

		if (iN3 > -1) {
			if (bN3) {
				// граничный узел.
				Fn3 = mf[iP][N_SIDE] * (border_neighbor[iN3 - maxelm].dS / (dx*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iN3]]) {
					Fn3 = mf[iP][N_SIDE];
				}
				else {

					Fn3 = mf[iN3][S_SIDE];

				}
			}
		}

		if (iS3 > -1) {
			if (bS3) {
				// граничный узел.
				Fs3 = mf[iP][S_SIDE] * (border_neighbor[iS3 - maxelm].dS / (dx*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iS3]]) {
					Fs3 = mf[iP][S_SIDE];
				}
				else {

					Fs3 = mf[iS3][N_SIDE];

				}
			}
		}

		if (iT3 > -1) {
			if (bT3) {
				// граничный узел.
				Ft3 = mf[iP][T_SIDE] * (border_neighbor[iT3 - maxelm].dS / (dx*dy));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iT3]]) {
					Ft3 = mf[iP][T_SIDE];
				}
				else {

					Ft3 = mf[iT3][B_SIDE];

				}
			}
		}

		if (iB3 > -1) {
			if (bB3) {
				// граничный узел.
				Fb3 = mf[iP][B_SIDE] * (border_neighbor[iB3 - maxelm].dS / (dx*dy));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iB3]]) {
					Fb3 = mf[iP][B_SIDE];
				}
				else {

					Fb3 = mf[iB3][T_SIDE];

				}
			}
		}

		if (iE4 > -1) {
			if (bE4) {
				// граничный узел.
				Fe4 = mf[iP][E_SIDE] * (border_neighbor[iE4 - maxelm].dS / (dy*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iE4]]) {
					Fe4 = mf[iP][E_SIDE];
				}
				else {

					Fe4 = mf[iE4][W_SIDE];

				}
			}
		}

		if (iW4 > -1) {
			if (bW4) {
				// граничный узел.
				Fw4 = mf[iP][W_SIDE] * (border_neighbor[iW4 - maxelm].dS / (dy*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iW4]]) {
					Fw4 = mf[iP][W_SIDE];
				}
				else {

					Fw4 = mf[iW4][E_SIDE];

				}
			}
		}

		if (iN4 > -1) {
			if (bN4) {
				// граничный узел.
				Fn4 = mf[iP][N_SIDE] * (border_neighbor[iN4 - maxelm].dS / (dx*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iN4]]) {
					Fn4 = mf[iP][N_SIDE];
				}
				else {

					Fn4 = mf[iN4][S_SIDE];

				}
			}
		}

		if (iS4 > -1) {
			if (bS4) {
				// граничный узел.
				Fs4 = mf[iP][S_SIDE] * (border_neighbor[iS4 - maxelm].dS / (dx*dz));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iS4]]) {
					Fs4 = mf[iP][S_SIDE];
				}
				else {

					Fs4 = mf[iS4][N_SIDE];

				}
			}
		}

		if (iT4 > -1) {
			if (bT4) {
				// граничный узел.
				Ft4 = mf[iP][T_SIDE] * (border_neighbor[iT4 - maxelm].dS / (dx*dy));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iT4]]) {
					Ft4 = mf[iP][T_SIDE];
				}
				else {

					Ft4 = mf[iT4][B_SIDE];

				}
			}
		}

		if (iB4 > -1) {
			if (bB4) {
				// граничный узел.
				Fb4 = mf[iP][B_SIDE] * (border_neighbor[iB4 - maxelm].dS / (dx*dy));
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iB4]]) {
					Fb4 = mf[iP][B_SIDE];
				}
				else {

					Fb4 = mf[iB4][T_SIDE];

				}
			}
		}



	}
	


	doublereal eps=1e-37; // для отделения вещественного нуля.

	
	// Давление в соседних узлах понадобится для вычисления источникового члена:
    doublereal kP;
	kP = potent[PRESS][iP];

	doublereal kW=kP, kE = kP, kS = kP, kN = kP, kB = kP, kT = kP;

    
	if (iW > -1) {
		kW = potent[PRESS][iW]; // включая граничный узел при необходимости
	}
	if (iE > -1) {
		kE = potent[PRESS][iE];
	}
	if (iS > -1) {
		kS = potent[PRESS][iS];
	}
	if (iN > -1) {
		kN = potent[PRESS][iN];
	}
	if (iB > -1) {
		kB = potent[PRESS][iB];
	}
	if (iT > -1) {
		kT = potent[PRESS][iT];
	}

	doublereal kW2 = kP, kE2 = kP, kS2 = kP, kN2 = kP, kB2 = kP, kT2 = kP;
	doublereal kW3 = kP, kE3 = kP, kS3 = kP, kN3 = kP, kB3 = kP, kT3 = kP;
	doublereal kW4 = kP, kE4 = kP, kS4 = kP, kN4 = kP, kB4 = kP, kT4 = kP;

	if (b_on_adaptive_local_refinement_mesh) {

		if (iW2 > -1) {
			kW2 = potent[PRESS][iW2]; // включая граничный узел при необходимости
		}
		if (iE2 > -1) {
			kE2 = potent[PRESS][iE2];
		}
		if (iS2 > -1) {
			kS2 = potent[PRESS][iS2];
		}
		if (iN2 > -1) {
			kN2 = potent[PRESS][iN2];
		}
		if (iB2 > -1) {
			kB2 = potent[PRESS][iB2];
		}
		if (iT2 > -1) {
			kT2 = potent[PRESS][iT2];
		}

		if (iW3 > -1) {
			kW3 = potent[PRESS][iW3]; // включая граничный узел при необходимости
		}
		if (iE3 > -1) {
			kE3 = potent[PRESS][iE3];
		}
		if (iS3 > -1) {
			kS3 = potent[PRESS][iS3];
		}
		if (iN3 > -1) {
			kN3 = potent[PRESS][iN3];
		}
		if (iB3 > -1) {
			kB3 = potent[PRESS][iB3];
		}
		if (iT3 > -1) {
			kT3 = potent[PRESS][iT3];
		}

		if (iW4 > -1) {
			kW4 = potent[PRESS][iW4]; // включая граничный узел при необходимости
		}
		if (iE4 > -1) {
			kE4 = potent[PRESS][iE4];
		}
		if (iS4 > -1) {
			kS4 = potent[PRESS][iS4];
		}
		if (iN4 > -1) {
			kN4 = potent[PRESS][iN4];
		}
		if (iB4 > -1) {
			kB4 = potent[PRESS][iB4];
		}
		if (iT4 > -1) {
			kT4 = potent[PRESS][iT4];
		}
	}

	// коэффициенты диффузии:
	doublereal  GP, GE, GW, GN, GS, GT, GB;
	doublereal  GE2, GW2, GN2, GS2, GT2, GB2;
	doublereal  GE3, GW3, GN3, GS3, GT3, GB3;
	doublereal  GE4, GW4, GN4, GS4, GT4, GB4;
	
	// Вычисление молекулярной диффузии:
    GP=prop[MU_DYNAMIC_VISCOSITY][iP]; // в центре внутреннего КО.
	if (iE > -1) {
		if (!bE) GE = prop[MU_DYNAMIC_VISCOSITY][iE]; else GE = prop_b[MU_DYNAMIC_VISCOSITY][iE - maxelm];
	}
	if (iN > -1) {
		if (!bN) GN = prop[MU_DYNAMIC_VISCOSITY][iN]; else GN = prop_b[MU_DYNAMIC_VISCOSITY][iN - maxelm];
	}
	if (iT > -1) {
		if (!bT) GT = prop[MU_DYNAMIC_VISCOSITY][iT]; else GT = prop_b[MU_DYNAMIC_VISCOSITY][iT - maxelm];
	}
	if (iW > -1) {
		if (!bW) GW = prop[MU_DYNAMIC_VISCOSITY][iW]; else GW = prop_b[MU_DYNAMIC_VISCOSITY][iW - maxelm];
	}
	if (iS > -1) {
		if (!bS) GS = prop[MU_DYNAMIC_VISCOSITY][iS]; else GS = prop_b[MU_DYNAMIC_VISCOSITY][iS - maxelm];
	}
	if (iB > -1) {
		if (!bB) GB = prop[MU_DYNAMIC_VISCOSITY][iB]; else GB = prop_b[MU_DYNAMIC_VISCOSITY][iB - maxelm];
	}

	if (b_on_adaptive_local_refinement_mesh) {

		if (iE2 > -1) {
			if (!bE2) GE2 = prop[MU_DYNAMIC_VISCOSITY][iE2]; else GE2 = prop_b[MU_DYNAMIC_VISCOSITY][iE2 - maxelm];
		}
		if (iN2 > -1) {
			if (!bN2) GN2 = prop[MU_DYNAMIC_VISCOSITY][iN2]; else GN2 = prop_b[MU_DYNAMIC_VISCOSITY][iN2 - maxelm];
		}
		if (iT2 > -1) {
			if (!bT2) GT2 = prop[MU_DYNAMIC_VISCOSITY][iT2]; else GT2 = prop_b[MU_DYNAMIC_VISCOSITY][iT2 - maxelm];
		}
		if (iW2 > -1) {
			if (!bW2) GW2 = prop[MU_DYNAMIC_VISCOSITY][iW2]; else GW2 = prop_b[MU_DYNAMIC_VISCOSITY][iW2 - maxelm];
		}
		if (iS2 > -1) {
			if (!bS2) GS2 = prop[MU_DYNAMIC_VISCOSITY][iS2]; else GS2 = prop_b[MU_DYNAMIC_VISCOSITY][iS2 - maxelm];
		}
		if (iB2 > -1) {
			if (!bB2) GB2 = prop[MU_DYNAMIC_VISCOSITY][iB2]; else GB2 = prop_b[MU_DYNAMIC_VISCOSITY][iB2 - maxelm];
		}

		if (iE3 > -1) {
			if (!bE3) GE3 = prop[MU_DYNAMIC_VISCOSITY][iE3]; else GE3 = prop_b[MU_DYNAMIC_VISCOSITY][iE3 - maxelm];
		}
		if (iN3 > -1) {
			if (!bN3) GN3 = prop[MU_DYNAMIC_VISCOSITY][iN3]; else GN3 = prop_b[MU_DYNAMIC_VISCOSITY][iN3 - maxelm];
		}
		if (iT3 > -1) {
			if (!bT3) GT3 = prop[MU_DYNAMIC_VISCOSITY][iT3]; else GT3 = prop_b[MU_DYNAMIC_VISCOSITY][iT3 - maxelm];
		}
		if (iW3 > -1) {
			if (!bW3) GW3 = prop[MU_DYNAMIC_VISCOSITY][iW3]; else GW3 = prop_b[MU_DYNAMIC_VISCOSITY][iW3 - maxelm];
		}
		if (iS3 > -1) {
			if (!bS3) GS3 = prop[MU_DYNAMIC_VISCOSITY][iS3]; else GS3 = prop_b[MU_DYNAMIC_VISCOSITY][iS3 - maxelm];
		}
		if (iB3 > -1) {
			if (!bB3) GB3 = prop[MU_DYNAMIC_VISCOSITY][iB3]; else GB3 = prop_b[MU_DYNAMIC_VISCOSITY][iB3 - maxelm];
		}

		if (iE4 > -1) {
			if (!bE4) GE4 = prop[MU_DYNAMIC_VISCOSITY][iE4]; else GE4 = prop_b[MU_DYNAMIC_VISCOSITY][iE4 - maxelm];
		}
		if (iN4 > -1) {
			if (!bN4) GN4 = prop[MU_DYNAMIC_VISCOSITY][iN4]; else GN4 = prop_b[MU_DYNAMIC_VISCOSITY][iN4 - maxelm];
		}
		if (iT4 > -1) {
			if (!bT4) GT4 = prop[MU_DYNAMIC_VISCOSITY][iT4]; else GT4 = prop_b[MU_DYNAMIC_VISCOSITY][iT4 - maxelm];
		}
		if (iW4 > -1) {
			if (!bW4) GW4 = prop[MU_DYNAMIC_VISCOSITY][iW4]; else GW4 = prop_b[MU_DYNAMIC_VISCOSITY][iW4 - maxelm];
		}
		if (iS4 > -1) {
			if (!bS4) GS4 = prop[MU_DYNAMIC_VISCOSITY][iS4]; else GS4 = prop_b[MU_DYNAMIC_VISCOSITY][iS4 - maxelm];
		}
		if (iB4 > -1) {
			if (!bB4) GB4 = prop[MU_DYNAMIC_VISCOSITY][iB4]; else GB4 = prop_b[MU_DYNAMIC_VISCOSITY][iB4 - maxelm];
		}
	}

	// Добавление турбулентной диффузии:
	if ((iflowregime== VISCOSITY_MODEL::ZEROEQMOD) ||
		(iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
		(iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
		(iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
		// Предполагается что справедлива 
		// гипотеза Буссинеска.
		GP+= fmax(0.0, potent[MUT][iP]);
		if (iE > -1) {
			GE += fmax(0.0,potent[MUT][iE]);
		}
		if (iN > -1) {
			GN += fmax(0.0, potent[MUT][iN]);
		}
		if (iT > -1) {
			GT += fmax(0.0, potent[MUT][iT]);
		}
		if (iW > -1) {
			GW += fmax(0.0, potent[MUT][iW]);
		}
		if (iS > -1) {
			GS += fmax(0.0, potent[MUT][iS]);
		}
		if (iB > -1) {
			GB += fmax(0.0, potent[MUT][iB]);
		}

		if (b_on_adaptive_local_refinement_mesh) {

			if (iE2 > -1) {
				GE2 += fmax(0.0, potent[MUT][iE2]);
			}
			if (iN2 > -1) {
				GN2 += fmax(0.0, potent[MUT][iN2]);
			}
			if (iT2 > -1) {
				GT2 += fmax(0.0, potent[MUT][iT2]);
			}
			if (iW2 > -1) {
				GW2 += fmax(0.0, potent[MUT][iW2]);
			}
			if (iS2 > -1) {
				GS2 += fmax(0.0, potent[MUT][iS2]);
			}
			if (iB2 > -1) {
				GB2 += fmax(0.0, potent[MUT][iB2]);
			}

			if (iE3 > -1) {
				GE3 += fmax(0.0, potent[MUT][iE3]);
			}
			if (iN3 > -1) {
				GN3 += fmax(0.0, potent[MUT][iN3]);
			}
			if (iT3 > -1) {
				GT3 += fmax(0.0, potent[MUT][iT3]);
			}
			if (iW3 > -1) {
				GW3 += fmax(0.0, potent[MUT][iW3]);
			}
			if (iS3 > -1) {
				GS3 += fmax(0.0, potent[MUT][iS3]);
			}
			if (iB3 > -1) {
				GB3 += fmax(0.0, potent[MUT][iB3]);
			}

			if (iE4 > -1) {
				GE4 += fmax(0.0, potent[MUT][iE4]);
			}
			if (iN4 > -1) {
				GN4 += fmax(0.0, potent[MUT][iN4]);
			}
			if (iT4 > -1) {
				GT4 += fmax(0.0, potent[MUT][iT4]);
			}
			if (iW4 > -1) {
				GW4 += fmax(0.0, potent[MUT][iW4]);
			}
			if (iS4 > -1) {
				GS4 += fmax(0.0, potent[MUT][iS4]);
			}
			if (iB4 > -1) {
				GB4 += fmax(0.0, potent[MUT][iB4]);
			}
		}
	}


	doublereal Ge=GP, Gw = GP, Gn = GP, Gs = GP, Gt = GP, Gb = GP;
    // Значение коэффициента диффузии на грани КО.
	if (iE > -1) {
		Ge = GE * GP / (feplus*GE + (1 - feplus)*GP); // проверено.
	}
	if (iW > -1) {
		Gw = GW * GP / (fwplus*GW + (1 - fwplus)*GP);
	}
	if (iN > -1) {
		Gn = GN * GP / (fnplus*GN + (1 - fnplus)*GP);
	}
	if (iS > -1) {
		Gs = GS * GP / (fsplus*GS + (1 - fsplus)*GP);
	}
	if (iT > -1) {
		Gt = GT * GP / (ftplus*GT + (1 - ftplus)*GP);
	}
	if (iB > -1) {
		Gb = GB * GP / (fbplus*GB + (1 - fbplus)*GP);
	}

	doublereal Ge2 = GP, Gw2 = GP, Gn2 = GP, Gs2 = GP, Gt2 = GP, Gb2 = GP;
	doublereal Ge3 = GP, Gw3 = GP, Gn3 = GP, Gs3 = GP, Gt3 = GP, Gb3 = GP;
	doublereal Ge4 = GP, Gw4 = GP, Gn4 = GP, Gs4 = GP, Gt4 = GP, Gb4 = GP;

	if (b_on_adaptive_local_refinement_mesh) {

		// Значение коэффициента диффузии на грани КО.
		if (iE2 > -1) {
			Ge2 = GE2 * GP / (feplus2 * GE2 + (1 - feplus2) * GP); // проверено.
		}
		if (iW2 > -1) {
			Gw2 = GW2 * GP / (fwplus2 * GW2 + (1 - fwplus2) * GP);
		}
		if (iN2 > -1) {
			Gn2 = GN2 * GP / (fnplus2 * GN2 + (1 - fnplus2) * GP);
		}
		if (iS2 > -1) {
			Gs2 = GS2 * GP / (fsplus2 * GS2 + (1 - fsplus2) * GP);
		}
		if (iT2 > -1) {
			Gt2 = GT2 * GP / (ftplus2 * GT2 + (1 - ftplus2) * GP);
		}
		if (iB2 > -1) {
			Gb2 = GB2 * GP / (fbplus2 * GB2 + (1 - fbplus2) * GP);
		}


		
		// Значение коэффициента диффузии на грани КО.
		if (iE3 > -1) {
			Ge3 = GE3 * GP / (feplus3 * GE3 + (1 - feplus3) * GP); // проверено.
		}
		if (iW3 > -1) {
			Gw3 = GW3 * GP / (fwplus3 * GW3 + (1 - fwplus3) * GP);
		}
		if (iN3 > -1) {
			Gn3 = GN3 * GP / (fnplus3 * GN3 + (1 - fnplus3) * GP);
		}
		if (iS3 > -1) {
			Gs3 = GS3 * GP / (fsplus3 * GS3 + (1 - fsplus3) * GP);
		}
		if (iT3 > -1) {
			Gt3 = GT3 * GP / (ftplus3 * GT3 + (1 - ftplus3) * GP);
		}
		if (iB3 > -1) {
			Gb3 = GB3 * GP / (fbplus3 * GB3 + (1 - fbplus3) * GP);
		}

		
		// Значение коэффициента диффузии на грани КО.
		if (iE4 > -1) {
			Ge4 = GE4 * GP / (feplus4 * GE4 + (1 - feplus4) * GP); // проверено.
		}
		if (iW4 > -1) {
			Gw4 = GW4 * GP / (fwplus4 * GW4 + (1 - fwplus4) * GP);
		}
		if (iN4 > -1) {
			Gn4 = GN4 * GP / (fnplus4 * GN4 + (1 - fnplus4) * GP);
		}
		if (iS4 > -1) {
			Gs4 = GS4 * GP / (fsplus4 * GS4 + (1 - fsplus4) * GP);
		}
		if (iT4 > -1) {
			Gt4 = GT4 * GP / (ftplus4 * GT4 + (1 - ftplus4) * GP);
		}
		if (iB4 > -1) {
			Gb4 = GB4 * GP / (fbplus4 * GB4 + (1 - fbplus4) * GP);
		}

	}

	const doublereal ZeroDiffusion = 0.0;// 1.0e-30;
	// Диффузионная составляющая потока:
	doublereal De= ZeroDiffusion, Dw= ZeroDiffusion, Dn= ZeroDiffusion, Ds= ZeroDiffusion, Dt= ZeroDiffusion, Db= ZeroDiffusion; // инициализация
	if (iE > -1) {
		if (bE) {
			// граничный узел.
			De = Ge * border_neighbor[iE - maxelm].dS / dxe;
		}
		else {
			if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iE]]) {
				De = Ge * dy*dz / dxe;
			}
			else {
				// вычисление размеров соседнего контрольного объёма:
				doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
				//volume3D(iE, nvtx, pa, dx_loc, dy_loc, dz_loc);
				TOCHKA pvol_loc = volume_loc[iE];
				dx_loc = pvol_loc.x;
				dy_loc = pvol_loc.y;
				dz_loc = pvol_loc.z;

				De = Ge * dy_loc*dz_loc / dxe;
			}
		}
		
	}
	if (iW > -1) {
		if (bW) {
			// граничный узел
			Dw = Gw * border_neighbor[iW - maxelm].dS / dxw;
		}
		else {
			if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iW]]) {
				Dw = Gw * dy*dz / dxw;
			}
			else {
				// вычисление размеров соседнего контрольного объёма:
				doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
				//volume3D(iW, nvtx, pa, dx_loc, dy_loc, dz_loc);
				TOCHKA pvol_loc = volume_loc[iW];
				dx_loc = pvol_loc.x;
				dy_loc = pvol_loc.y;
				dz_loc = pvol_loc.z;

				Dw = Gw * dy_loc*dz_loc / dxw;
			}
		}
		
	}
	if (iN > -1) {
		if (bN) {
			// граничный узел.
			Dn = Gn * border_neighbor[iN - maxelm].dS / dyn;
		}
		else {
			if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iN]]) {
				Dn = Gn * dx*dz / dyn;
			}
			else {
				// вычисление размеров соседнего контрольного объёма:
				doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
				//volume3D(iN, nvtx, pa, dx_loc, dy_loc, dz_loc);
				TOCHKA pvol_loc = volume_loc[iN];
				dx_loc = pvol_loc.x;
				dy_loc = pvol_loc.y;
				dz_loc = pvol_loc.z;

				Dn = Gn * dx_loc*dz_loc / dyn;
			}
		}
	}
	if (iS > -1) {
		if (bS) {
			// граничный узел
			Ds = Gs * border_neighbor[iS - maxelm].dS / dys;
		}
		else {
			if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iS]]) {
				Ds = Gs * dx*dz / dys;
			}
			else {
				// вычисление размеров соседнего контрольного объёма:
				doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
				//volume3D(iS, nvtx, pa, dx_loc, dy_loc, dz_loc);
				TOCHKA pvol_loc = volume_loc[iS];
				dx_loc = pvol_loc.x;
				dy_loc = pvol_loc.y;
				dz_loc = pvol_loc.z;

				Ds = Gs * dx_loc*dz_loc / dys;
			}
		}		
	}
	if (iT > -1) {
		if (bT) {
			// граничный узел.
			Dt = Gt * border_neighbor[iT - maxelm].dS / dzt;
		}
		else {
			if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iT]]) {
				Dt = Gt * dx*dy / dzt;
			}
			else {
				// вычисление размеров соседнего контрольного объёма:
				doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
				//volume3D(iT, nvtx, pa, dx_loc, dy_loc, dz_loc);
				TOCHKA pvol_loc = volume_loc[iT];
				dx_loc = pvol_loc.x;
				dy_loc = pvol_loc.y;
				dz_loc = pvol_loc.z;

				Dt = Gt * dx_loc*dy_loc / dzt;
			}
		}

		
	}
	if (iB > -1) {
		if (bB) {
			// граничный узел
			Db = Gb * border_neighbor[iB - maxelm].dS / dzb;
		}
		else {
			if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iB]]) {
				Db = Gb * dx*dy / dzb;
			}
			else {
				// вычисление размеров соседнего контрольного объёма:
				doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
				//volume3D(iB, nvtx, pa, dx_loc, dy_loc, dz_loc);
				TOCHKA pvol_loc = volume_loc[iB];
				dx_loc = pvol_loc.x;
				dy_loc = pvol_loc.y;
				dz_loc = pvol_loc.z;

				Db = Gb * dx_loc*dy_loc / dzb;
			}
		}

		
	}

	// Диффузионная составляющая потока:
	doublereal De2 = ZeroDiffusion, Dw2 = ZeroDiffusion, Dn2 = ZeroDiffusion, Ds2 = ZeroDiffusion, Dt2 = ZeroDiffusion, Db2 = ZeroDiffusion; // инициализация
	doublereal De3 = ZeroDiffusion, Dw3 = ZeroDiffusion, Dn3 = ZeroDiffusion, Ds3 = ZeroDiffusion, Dt3 = ZeroDiffusion, Db3 = ZeroDiffusion; // инициализация
	doublereal De4 = ZeroDiffusion, Dw4 = ZeroDiffusion, Dn4 = ZeroDiffusion, Ds4 = ZeroDiffusion, Dt4 = ZeroDiffusion, Db4 = ZeroDiffusion; // инициализация

	if (b_on_adaptive_local_refinement_mesh) {

		if (iE2 > -1) {
			if (bE2) {
				// граничный узел.
				De2 = Ge2 * border_neighbor[iE2 - maxelm].dS / dxe2;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iE2]]) {
					De2 = Ge2 * dy * dz / dxe2;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iE2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iE2];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					De2 = Ge2 * dy_loc * dz_loc / dxe2;
				}
			}

		}
		if (iW2 > -1) {
			if (bW2) {
				// граничный узел
				Dw2 = Gw2 * border_neighbor[iW2 - maxelm].dS / dxw2;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iW2]]) {
					Dw2 = Gw2 * dy * dz / dxw2;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iW2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iW2];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Dw2 = Gw2 * dy_loc * dz_loc / dxw2;
				}
			}

		}
		if (iN2 > -1) {
			if (bN2) {
				// граничный узел.
				Dn2 = Gn2 * border_neighbor[iN2 - maxelm].dS / dyn2;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iN2]]) {
					Dn2 = Gn2 * dx * dz / dyn2;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iN2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iN2];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Dn2 = Gn2 * dx_loc * dz_loc / dyn2;
				}
			}
		}
		if (iS2 > -1) {
			if (bS2) {
				// граничный узел
				Ds2 = Gs2 * border_neighbor[iS2 - maxelm].dS / dys2;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iS2]]) {
					Ds2 = Gs2 * dx * dz / dys2;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iS2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iS2];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Ds2 = Gs2 * dx_loc * dz_loc / dys2;
				}
			}
		}
		if (iT2 > -1) {
			if (bT2) {
				// граничный узел.
				Dt2 = Gt2 * border_neighbor[iT2 - maxelm].dS / dzt2;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iT2]]) {
					Dt2 = Gt2 * dx * dy / dzt2;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iT2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iT2];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Dt2 = Gt2 * dx_loc * dy_loc / dzt2;
				}
			}


		}
		if (iB2 > -1) {
			if (bB2) {
				// граничный узел
				Db2 = Gb2 * border_neighbor[iB2 - maxelm].dS / dzb2;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iB2]]) {
					Db2 = Gb2 * dx * dy / dzb2;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iB2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iB2];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Db2 = Gb2 * dx_loc * dy_loc / dzb2;
				}
			}


		}

		// Диффузионная составляющая потока:
		
		if (iE3 > -1) {
			if (bE3) {
				// граничный узел.
				De3 = Ge3 * border_neighbor[iE3 - maxelm].dS / dxe3;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iE3]]) {
					De3 = Ge3 * dy * dz / dxe3;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iE3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iE3];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					De3 = Ge3 * dy_loc * dz_loc / dxe3;
				}
			}

		}
		if (iW3 > -1) {
			if (bW3) {
				// граничный узел
				Dw3 = Gw3 * border_neighbor[iW3 - maxelm].dS / dxw3;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iW3]]) {
					Dw3 = Gw3 * dy * dz / dxw3;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iW3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iW3];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Dw3 = Gw3 * dy_loc * dz_loc / dxw3;
				}
			}

		}
		if (iN3 > -1) {
			if (bN3) {
				// граничный узел.
				Dn3 = Gn3 * border_neighbor[iN3 - maxelm].dS / dyn3;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iN3]]) {
					Dn3 = Gn3 * dx * dz / dyn3;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iN3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iN3];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Dn3 = Gn3 * dx_loc * dz_loc / dyn3;
				}
			}
		}
		if (iS3 > -1) {
			if (bS3) {
				// граничный узел
				Ds3 = Gs3 * border_neighbor[iS3 - maxelm].dS / dys3;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iS3]]) {
					Ds3 = Gs3 * dx * dz / dys3;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iS3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iS3];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Ds3 = Gs3 * dx_loc * dz_loc / dys3;
				}
			}
		}
		if (iT3 > -1) {
			if (bT3) {
				// граничный узел.
				Dt3 = Gt3 * border_neighbor[iT3 - maxelm].dS / dzt3;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iT3]]) {
					Dt3 = Gt3 * dx * dy / dzt3;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iT3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iT3];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Dt3 = Gt3 * dx_loc * dy_loc / dzt3;
				}
			}


		}
		if (iB3 > -1) {
			if (bB3) {
				// граничный узел
				Db3 = Gb3 * border_neighbor[iB3 - maxelm].dS / dzb3;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iB3]]) {
					Db3 = Gb3 * dx * dy / dzb3;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iB3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iB3];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Db3 = Gb3 * dx_loc * dy_loc / dzb3;
				}
			}


		}

		// Диффузионная составляющая потока:
		
		if (iE4 > -1) {
			if (bE4) {
				// граничный узел.
				De4 = Ge4 * border_neighbor[iE4 - maxelm].dS / dxe4;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iE4]]) {
					De4 = Ge4 * dy * dz / dxe4;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iE4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iE4];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					De4 = Ge4 * dy_loc * dz_loc / dxe4;
				}
			}

		}
		if (iW4 > -1) {
			if (bW4) {
				// граничный узел
				Dw4 = Gw4 * border_neighbor[iW4 - maxelm].dS / dxw4;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iW4]]) {
					Dw4 = Gw4 * dy * dz / dxw4;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iW4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iW4];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Dw4 = Gw4 * dy_loc * dz_loc / dxw4;
				}
			}

		}
		if (iN4 > -1) {
			if (bN4) {
				// граничный узел.
				Dn4 = Gn4 * border_neighbor[iN4 - maxelm].dS / dyn4;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iN4]]) {
					Dn4 = Gn4 * dx * dz / dyn4;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iN4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iN4];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Dn4 = Gn4 * dx_loc * dz_loc / dyn4;
				}
			}
		}
		if (iS4 > -1) {
			if (bS4) {
				// граничный узел
				Ds4 = Gs4 * border_neighbor[iS4 - maxelm].dS / dys4;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iS4]]) {
					Ds4 = Gs4 * dx * dz / dys4;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iS4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iS4];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Ds4 = Gs4 * dx_loc * dz_loc / dys4;
				}
			}
		}
		if (iT4 > -1) {
			if (bT4) {
				// граничный узел.
				Dt4 = Gt4 * border_neighbor[iT4 - maxelm].dS / dzt4;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iT4]]) {
					Dt4 = Gt4 * dx * dy / dzt4;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iT4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iT4];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Dt4 = Gt4 * dx_loc * dy_loc / dzt4;
				}
			}


		}
		if (iB4 > -1) {
			if (bB4) {
				// граничный узел
				Db4 = Gb4 * border_neighbor[iB4 - maxelm].dS / dzb4;
			}
			else {
				if (ilevel_alice[ptr[iP]] >= ilevel_alice[ptr[iB4]]) {
					Db4 = Gb4 * dx * dy / dzb4;
				}
				else {
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					//volume3D(iB4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					TOCHKA pvol_loc = volume_loc[iB4];
					dx_loc = pvol_loc.x;
					dy_loc = pvol_loc.y;
					dz_loc = pvol_loc.z;

					Db4 = Gb4 * dx_loc * dy_loc / dzb4;
				}
			}


		}

	}

	// Числа Пекле:
	doublereal Pe=0.0, Pw = 0.0, Pn = 0.0, Ps = 0.0, Pt = 0.0, Pb = 0.0;
	if (iE > -1) {
		Pe = (Fe) / De;
	}
	if (iW > -1) {
		Pw = -(Fw) / Dw;
	}
	if (iN > -1) {
		Pn = (Fn) / Dn;
	}
	if (iS > -1) {
		Ps = -(Fs) / Ds;
	}
	if (iT > -1) {
		Pt = (Ft) / Dt;
	}
	if (iB > -1) {
		Pb = -(Fb) / Db;
	}

	// Числа Пекле:
	doublereal Pe2 = 0.0, Pw2 = 0.0, Pn2 = 0.0, Ps2 = 0.0, Pt2 = 0.0, Pb2 = 0.0;
	doublereal Pe3 = 0.0, Pw3 = 0.0, Pn3 = 0.0, Ps3 = 0.0, Pt3 = 0.0, Pb3 = 0.0;
	doublereal Pe4 = 0.0, Pw4 = 0.0, Pn4 = 0.0, Ps4 = 0.0, Pt4 = 0.0, Pb4 = 0.0;

	if (b_on_adaptive_local_refinement_mesh) {

		if (iE2 > -1) {
			Pe2 = (Fe2) / De2;
		}
		if (iW2 > -1) {
			Pw2 = -(Fw2) / Dw2;
		}
		if (iN2 > -1) {
			Pn2 = (Fn2) / Dn2;
		}
		if (iS2 > -1) {
			Ps2 = -(Fs2) / Ds2;
		}
		if (iT2 > -1) {
			Pt2 = (Ft2) / Dt2;
		}
		if (iB2 > -1) {
			Pb2 = -(Fb2) / Db2;
		}

		// Числа Пекле:
		
		if (iE3 > -1) {
			Pe3 = (Fe3) / De3;
		}
		if (iW3 > -1) {
			Pw3 = -(Fw3) / Dw3;
		}
		if (iN3 > -1) {
			Pn3 = (Fn3) / Dn3;
		}
		if (iS3 > -1) {
			Ps3 = -(Fs3) / Ds3;
		}
		if (iT3 > -1) {
			Pt3 = (Ft3) / Dt3;
		}
		if (iB3 > -1) {
			Pb3 = -(Fb3) / Db3;
		}

		// Числа Пекле:
		
		if (iE4 > -1) {
			Pe4 = (Fe4) / De4;
		}
		if (iW4 > -1) {
			Pw4 = -(Fw4) / Dw4;
		}
		if (iN4 > -1) {
			Pn4 = (Fn4) / Dn4;
		}
		if (iS4 > -1) {
			Ps4 = -(Fs4) / Ds4;
		}
		if (iT4 > -1) {
			Pt4 = (Ft4) / Dt4;
		}
		if (iB4 > -1) {
			Pb4 = -(Fb4) / Db4;
		}

	}

	// Учёт аппроксимации высокого порядка на границе:
	if (iE > -1) {
		if (!bE) {
			if (bW) De *= dbeta;
		}
		else De *= dbeta;
	}

	if (iW > -1) {
		if (!bW) {
			if (bE) Dw *= dbeta;
		}
		else Dw *= dbeta;
	}

	if (iN > -1) {
		if (!bN) {
			if (bS) Dn *= dbeta;
		}
		else Dn *= dbeta;
	}

	if (iS > -1) {
		if (!bS) {
			if (bN) Ds *= dbeta;
		}
		else Ds *= dbeta;
	}

	if (iT > -1) {
		if (!bT) {
			if (bB) Dt *= dbeta;
		}
		else Dt *= dbeta;
	}

	if (iB > -1) {
		if (!bB) {
			if (bT) Db *= dbeta;
		}
		else Db *= dbeta;
	}

	if (b_on_adaptive_local_refinement_mesh) {

		// Учёт аппроксимации высокого порядка на границе:
		if (iE2 > -1) {
			if (!bE2) {
				if (bW2) De2 *= dbeta;
			}
			else De2 *= dbeta;
		}

		if (iW2 > -1) {
			if (!bW2) {
				if (bE2) Dw2 *= dbeta;
			}
			else Dw2 *= dbeta;
		}

		if (iN2 > -1) {
			if (!bN2) {
				if (bS2) Dn2 *= dbeta;
			}
			else Dn2 *= dbeta;
		}

		if (iS2 > -1) {
			if (!bS2) {
				if (bN2) Ds2 *= dbeta;
			}
			else Ds2 *= dbeta;
		}

		if (iT2 > -1) {
			if (!bT2) {
				if (bB2) Dt2 *= dbeta;
			}
			else Dt2 *= dbeta;
		}

		if (iB2 > -1) {
			if (!bB2) {
				if (bT2) Db2 *= dbeta;
			}
			else Db2 *= dbeta;
		}

		// Учёт аппроксимации высокого порядка на границе:
		if (iE3 > -1) {
			if (!bE3) {
				if (bW3) De3 *= dbeta;
			}
			else De3 *= dbeta;
		}

		if (iW3 > -1) {
			if (!bW3) {
				if (bE3) Dw3 *= dbeta;
			}
			else Dw3 *= dbeta;
		}

		if (iN3 > -1) {
			if (!bN3) {
				if (bS3) Dn3 *= dbeta;
			}
			else Dn3 *= dbeta;
		}

		if (iS3 > -1) {
			if (!bS3) {
				if (bN3) Ds3 *= dbeta;
			}
			else Ds3 *= dbeta;
		}

		if (iT3 > -1) {
			if (!bT3) {
				if (bB3) Dt3 *= dbeta;
			}
			else Dt3 *= dbeta;
		}

		if (iB3 > -1) {
			if (!bB3) {
				if (bT3) Db3 *= dbeta;
			}
			else Db3 *= dbeta;
		}

		// Учёт аппроксимации высокого порядка на границе:
		if (iE4 > -1) {
			if (!bE4) {
				if (bW4) De4 *= dbeta;
			}
			else De4 *= dbeta;
		}

		if (iW4 > -1) {
			if (!bW4) {
				if (bE4) Dw4 *= dbeta;
			}
			else Dw4 *= dbeta;
		}

		if (iN4 > -1) {
			if (!bN4) {
				if (bS4) Dn4 *= dbeta;
			}
			else Dn4 *= dbeta;
		}

		if (iS4 > -1) {
			if (!bS4) {
				if (bN4) Ds4 *= dbeta;
			}
			else Ds4 *= dbeta;
		}

		if (iT4 > -1) {
			if (!bT4) {
				if (bB4) Dt4 *= dbeta;
			}
			else Dt4 *= dbeta;
		}

		if (iB4 > -1) {
			if (!bB4) {
				if (bT4) Db4 *= dbeta;
			}
			else Db4 *= dbeta;
		}

	}

	// Добавка в правую часть при использовании схемы Леонарда QUICK
	// в силу использования метода отложенной коррекции.
	// addition to the right side QUICK Leonard.
	doublereal attrs=0.0;

	if (b_on_adaptive_local_refinement_mesh) {

		// Инициализирующее обнуление.
		sl[iVar][iP].ae = 0.0;
		sl[iVar][iP].aw = 0.0;
		sl[iVar][iP].an = 0.0;
		sl[iVar][iP].as = 0.0;
		sl[iVar][iP].at = 0.0;
		sl[iVar][iP].ab = 0.0;

		sl[iVar][iP].ae2 = 0.0;
		sl[iVar][iP].aw2 = 0.0;
		sl[iVar][iP].an2 = 0.0;
		sl[iVar][iP].as2 = 0.0;
		sl[iVar][iP].at2 = 0.0;
		sl[iVar][iP].ab2 = 0.0;

		sl[iVar][iP].ae3 = 0.0;
		sl[iVar][iP].aw3 = 0.0;
		sl[iVar][iP].an3 = 0.0;
		sl[iVar][iP].as3 = 0.0;
		sl[iVar][iP].at3 = 0.0;
		sl[iVar][iP].ab3 = 0.0;

		sl[iVar][iP].ae4 = 0.0;
		sl[iVar][iP].aw4 = 0.0;
		sl[iVar][iP].an4 = 0.0;
		sl[iVar][iP].as4 = 0.0;
		sl[iVar][iP].at4 = 0.0;
		sl[iVar][iP].ab4 = 0.0;
		
	}

	// +1 Знаки реверсированы.
	// -1 - значит ap = summa anb.
	doublereal sign_flux = -1.0;

	if (ishconvection < distsheme) {

		if (1) {
			// Оставил как единственно верное и рекомендованное в литературе 7.05.2017. 
			if (b_on_adaptive_local_refinement_mesh) {
				// Вычисление коэффициентов дискретного аналога:
				sl[iVar][iP].ae = De * ApproxConvective(fabs(Pe), iprefix_Scheme) + fmax(-(Fe), 0);
				sl[iVar][iP].aw = Dw * ApproxConvective(fabs(Pw), iprefix_Scheme) + fmax(Fw, 0);
				sl[iVar][iP].an = Dn * ApproxConvective(fabs(Pn), iprefix_Scheme) + fmax(-(Fn), 0);
				sl[iVar][iP].as = Ds * ApproxConvective(fabs(Ps), iprefix_Scheme) + fmax(Fs, 0);
				sl[iVar][iP].at = Dt * ApproxConvective(fabs(Pt), iprefix_Scheme) + fmax(-(Ft), 0);
				sl[iVar][iP].ab = Db * ApproxConvective(fabs(Pb), iprefix_Scheme) + fmax(Fb, 0);

				// Вычисление коэффициентов дискретного аналога:
				sl[iVar][iP].ae2 = De2 * ApproxConvective(fabs(Pe2), iprefix_Scheme) + fmax(-(Fe2), 0);
				sl[iVar][iP].aw2 = Dw2 * ApproxConvective(fabs(Pw2), iprefix_Scheme) + fmax(Fw2, 0);
				sl[iVar][iP].an2 = Dn2 * ApproxConvective(fabs(Pn2), iprefix_Scheme) + fmax(-(Fn2), 0);
				sl[iVar][iP].as2 = Ds2 * ApproxConvective(fabs(Ps2), iprefix_Scheme) + fmax(Fs2, 0);
				sl[iVar][iP].at2 = Dt2 * ApproxConvective(fabs(Pt2), iprefix_Scheme) + fmax(-(Ft2), 0);
				sl[iVar][iP].ab2 = Db2 * ApproxConvective(fabs(Pb2), iprefix_Scheme) + fmax(Fb2, 0);

				// Вычисление коэффициентов дискретного аналога:
				sl[iVar][iP].ae3 = De3 * ApproxConvective(fabs(Pe3), iprefix_Scheme) + fmax(-(Fe3), 0);
				sl[iVar][iP].aw3 = Dw3 * ApproxConvective(fabs(Pw3), iprefix_Scheme) + fmax(Fw3, 0);
				sl[iVar][iP].an3 = Dn3 * ApproxConvective(fabs(Pn3), iprefix_Scheme) + fmax(-(Fn3), 0);
				sl[iVar][iP].as3 = Ds3 * ApproxConvective(fabs(Ps3), iprefix_Scheme) + fmax(Fs3, 0);
				sl[iVar][iP].at3 = Dt3 * ApproxConvective(fabs(Pt3), iprefix_Scheme) + fmax(-(Ft3), 0);
				sl[iVar][iP].ab3 = Db3 * ApproxConvective(fabs(Pb3), iprefix_Scheme) + fmax(Fb3, 0);

				// Вычисление коэффициентов дискретного аналога:
				sl[iVar][iP].ae4 = De4 * ApproxConvective(fabs(Pe4), iprefix_Scheme) + fmax(-(Fe4), 0);
				sl[iVar][iP].aw4 = Dw4 * ApproxConvective(fabs(Pw4), iprefix_Scheme) + fmax(Fw4, 0);
				sl[iVar][iP].an4 = Dn4 * ApproxConvective(fabs(Pn4), iprefix_Scheme) + fmax(-(Fn4), 0);
				sl[iVar][iP].as4 = Ds4 * ApproxConvective(fabs(Ps4), iprefix_Scheme) + fmax(Fs4, 0);
				sl[iVar][iP].at4 = Dt4 * ApproxConvective(fabs(Pt4), iprefix_Scheme) + fmax(-(Ft4), 0);
				sl[iVar][iP].ab4 = Db4 * ApproxConvective(fabs(Pb4), iprefix_Scheme) + fmax(Fb4, 0);

			}
			else {
				// 25 07 2015
				// Вычисление коэффициентов дискретного аналога:
				sl[iVar][iP].ae = De * ApproxConvective(fabs(Pe), iprefix_Scheme) + fmax(-(Fe), 0);
				sl[iVar][iP].aw = Dw * ApproxConvective(fabs(Pw), iprefix_Scheme) + fmax(Fw, 0);
				sl[iVar][iP].an = Dn * ApproxConvective(fabs(Pn), iprefix_Scheme) + fmax(-(Fn), 0);
				sl[iVar][iP].as = Ds * ApproxConvective(fabs(Ps), iprefix_Scheme) + fmax(Fs, 0);
				sl[iVar][iP].at = Dt * ApproxConvective(fabs(Pt), iprefix_Scheme) + fmax(-(Ft), 0);
				sl[iVar][iP].ab = Db * ApproxConvective(fabs(Pb), iprefix_Scheme) + fmax(Fb, 0);
				//sl[iVar][iP].ap=sl[iVar][iP].ae+sl[iVar][iP].aw+sl[iVar][iP].an+sl[iVar][iP].as+sl[iVar][iP].at+sl[iVar][iP].ab;
			}
		}
		else
		{
			// написано на замену вышезакомментированного 25 июля 2015.
			if (!bE) {
				sl[iVar][iP].ae = De*ApproxConvective(fabs(Pe), iprefix_Scheme) + fmax(-(Fe), 0);
			}
			else {
				integer inumber = iE - maxelm;
				if (border_neighbor[inumber].MCB == (ls + lw)) {
					// условие по умолчанию: твёрдая стенка.
					// усиление влияния нуля на границе, нам же нужно влияние стенки.
					sl[iVar][iP].ae = De*ApproxConvective(fabs(Pe), iprefix_Scheme) + fabs(Fe);
				}
				else {
					sl[iVar][iP].ae = De*ApproxConvective(fabs(Pe), iprefix_Scheme) + fmax(-(Fe), 0);
				}
			}
			if (!bW) {
				sl[iVar][iP].aw = Dw*ApproxConvective(fabs(Pw), iprefix_Scheme) + fmax(Fw, 0);
			}
			else {
				integer inumber = iW - maxelm;
				if (border_neighbor[inumber].MCB == (ls + lw)) {
					// условие по умолчанию: твёрдая стенка.
					// усиление влияния нуля на границе, нам же нужно влияние стенки.
					sl[iVar][iP].aw = Dw*ApproxConvective(fabs(Pw), iprefix_Scheme) + fabs(Fw);
				}
				else {
					sl[iVar][iP].aw = Dw*ApproxConvective(fabs(Pw), iprefix_Scheme) + fmax(Fw, 0);
				}
			}
			if (!bN) {
				sl[iVar][iP].an = Dn*ApproxConvective(fabs(Pn), iprefix_Scheme) + fmax(-(Fn), 0);
			}
			else {
				integer inumber = iN - maxelm;
				if (border_neighbor[inumber].MCB == (ls + lw)) {
					// условие по умолчанию: твёрдая стенка.
					// усиление влияния нуля на границе, нам же нужно влияние стенки.
					sl[iVar][iP].an = Dn*ApproxConvective(fabs(Pn), iprefix_Scheme) + fabs(Fn);
				}
				else {
					sl[iVar][iP].an = Dn*ApproxConvective(fabs(Pn), iprefix_Scheme) + fmax(-(Fn), 0);
				}
			}
			if (!bS) {
				sl[iVar][iP].as = Ds*ApproxConvective(fabs(Ps), iprefix_Scheme) + fmax(Fs, 0);
			}
			else {
				integer inumber = iS - maxelm;
				if (border_neighbor[inumber].MCB == (ls + lw)) {
					// условие по умолчанию: твёрдая стенка.
					// усиление влияния нуля на границе, нам же нужно влияние стенки.
					sl[iVar][iP].as = Ds*ApproxConvective(fabs(Ps), iprefix_Scheme) + fabs(Fs);
				}
				else {
					sl[iVar][iP].as = Ds*ApproxConvective(fabs(Ps), iprefix_Scheme) + fmax(Fs, 0);
				}
			}
			if (!bT) {
				sl[iVar][iP].at = Dt*ApproxConvective(fabs(Pt), iprefix_Scheme) + fmax(-(Ft), 0);
			}
			else {
				integer inumber = iT - maxelm;
				if (border_neighbor[inumber].MCB == (ls + lw)) {
					// условие по умолчанию: твёрдая стенка.
					// усиление влияния нуля на границе, нам же нужно влияние стенки.
					sl[iVar][iP].at = Dt*ApproxConvective(fabs(Pt), iprefix_Scheme) + fabs(Ft);
				}
				else {
					sl[iVar][iP].at = Dt*ApproxConvective(fabs(Pt), iprefix_Scheme) + fmax(-(Ft), 0);
				}
			}
			if (!bB) {
				sl[iVar][iP].ab = Db*ApproxConvective(fabs(Pb), iprefix_Scheme) + fmax(Fb, 0);
			}
			else
			{
				integer inumber = iB - maxelm;
				if (border_neighbor[inumber].MCB == (ls + lw)) {
					// условие по умолчанию: твёрдая стенка.
					// усиление влияния нуля на границе, нам же нужно влияние стенки.
					sl[iVar][iP].ab = Db*ApproxConvective(fabs(Pb), iprefix_Scheme) + fabs(Fb);
				}
				else {
					sl[iVar][iP].ab = Db*ApproxConvective(fabs(Pb), iprefix_Scheme) + fmax(Fb, 0);
				}
			}

			if (b_on_adaptive_local_refinement_mesh) {

				if (!bE2) {
					sl[iVar][iP].ae2 = De2 * ApproxConvective(fabs(Pe2), iprefix_Scheme) + fmax(-(Fe2), 0);
				}
				else {
					integer inumber = iE2 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].ae2 = De2 * ApproxConvective(fabs(Pe2), iprefix_Scheme) + fabs(Fe2);
					}
					else {
						sl[iVar][iP].ae2 = De2 * ApproxConvective(fabs(Pe2), iprefix_Scheme) + fmax(-(Fe2), 0);
					}
				}
				if (!bW2) {
					sl[iVar][iP].aw2 = Dw2 * ApproxConvective(fabs(Pw2), iprefix_Scheme) + fmax(Fw2, 0);
				}
				else {
					integer inumber = iW2 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].aw2 = Dw2 * ApproxConvective(fabs(Pw2), iprefix_Scheme) + fabs(Fw2);
					}
					else {
						sl[iVar][iP].aw2 = Dw2 * ApproxConvective(fabs(Pw2), iprefix_Scheme) + fmax(Fw2, 0);
					}
				}
				if (!bN2) {
					sl[iVar][iP].an2 = Dn2 * ApproxConvective(fabs(Pn2), iprefix_Scheme) + fmax(-(Fn2), 0);
				}
				else {
					integer inumber = iN2 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].an2 = Dn2 * ApproxConvective(fabs(Pn2), iprefix_Scheme) + fabs(Fn2);
					}
					else {
						sl[iVar][iP].an2 = Dn2 * ApproxConvective(fabs(Pn2), iprefix_Scheme) + fmax(-(Fn2), 0);
					}
				}
				if (!bS2) {
					sl[iVar][iP].as2 = Ds2 * ApproxConvective(fabs(Ps2), iprefix_Scheme) + fmax(Fs2, 0);
				}
				else {
					integer inumber = iS2 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].as2 = Ds2 * ApproxConvective(fabs(Ps2), iprefix_Scheme) + fabs(Fs2);
					}
					else {
						sl[iVar][iP].as2 = Ds2 * ApproxConvective(fabs(Ps2), iprefix_Scheme) + fmax(Fs2, 0);
					}
				}
				if (!bT2) {
					sl[iVar][iP].at2 = Dt2 * ApproxConvective(fabs(Pt2), iprefix_Scheme) + fmax(-(Ft2), 0);
				}
				else {
					integer inumber = iT2 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].at2 = Dt2 * ApproxConvective(fabs(Pt2), iprefix_Scheme) + fabs(Ft2);
					}
					else {
						sl[iVar][iP].at2 = Dt2 * ApproxConvective(fabs(Pt2), iprefix_Scheme) + fmax(-(Ft2), 0);
					}
				}
				if (!bB2) {
					sl[iVar][iP].ab2 = Db2 * ApproxConvective(fabs(Pb2), iprefix_Scheme) + fmax(Fb2, 0);
				}
				else
				{
					integer inumber = iB2 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].ab2 = Db2 * ApproxConvective(fabs(Pb2), iprefix_Scheme) + fabs(Fb2);
					}
					else {
						sl[iVar][iP].ab2 = Db2 * ApproxConvective(fabs(Pb2), iprefix_Scheme) + fmax(Fb2, 0);
					}
				}

				if (!bE3) {
					sl[iVar][iP].ae3 = De3 * ApproxConvective(fabs(Pe3), iprefix_Scheme) + fmax(-(Fe3), 0);
				}
				else {
					integer inumber = iE3 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].ae3 = De3 * ApproxConvective(fabs(Pe3), iprefix_Scheme) + fabs(Fe3);
					}
					else {
						sl[iVar][iP].ae3 = De3 * ApproxConvective(fabs(Pe3), iprefix_Scheme) + fmax(-(Fe3), 0);
					}
				}
				if (!bW3) {
					sl[iVar][iP].aw3 = Dw3 * ApproxConvective(fabs(Pw3), iprefix_Scheme) + fmax(Fw3, 0);
				}
				else {
					integer inumber = iW3 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].aw3 = Dw3 * ApproxConvective(fabs(Pw3), iprefix_Scheme) + fabs(Fw3);
					}
					else {
						sl[iVar][iP].aw3 = Dw3 * ApproxConvective(fabs(Pw3), iprefix_Scheme) + fmax(Fw3, 0);
					}
				}
				if (!bN3) {
					sl[iVar][iP].an3 = Dn3 * ApproxConvective(fabs(Pn3), iprefix_Scheme) + fmax(-(Fn3), 0);
				}
				else {
					integer inumber = iN3 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].an3 = Dn3 * ApproxConvective(fabs(Pn3), iprefix_Scheme) + fabs(Fn3);
					}
					else {
						sl[iVar][iP].an3 = Dn3 * ApproxConvective(fabs(Pn3), iprefix_Scheme) + fmax(-(Fn3), 0);
					}
				}
				if (!bS3) {
					sl[iVar][iP].as3 = Ds3 * ApproxConvective(fabs(Ps3), iprefix_Scheme) + fmax(Fs3, 0);
				}
				else {
					integer inumber = iS3 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].as3 = Ds3 * ApproxConvective(fabs(Ps3), iprefix_Scheme) + fabs(Fs3);
					}
					else {
						sl[iVar][iP].as3 = Ds3 * ApproxConvective(fabs(Ps3), iprefix_Scheme) + fmax(Fs3, 0);
					}
				}
				if (!bT3) {
					sl[iVar][iP].at3 = Dt3 * ApproxConvective(fabs(Pt3), iprefix_Scheme) + fmax(-(Ft3), 0);
				}
				else {
					integer inumber = iT3 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].at3 = Dt3 * ApproxConvective(fabs(Pt3), iprefix_Scheme) + fabs(Ft3);
					}
					else {
						sl[iVar][iP].at3 = Dt3 * ApproxConvective(fabs(Pt3), iprefix_Scheme) + fmax(-(Ft3), 0);
					}
				}
				if (!bB3) {
					sl[iVar][iP].ab3 = Db3 * ApproxConvective(fabs(Pb3), iprefix_Scheme) + fmax(Fb3, 0);
				}
				else
				{
					integer inumber = iB3 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].ab3 = Db3 * ApproxConvective(fabs(Pb3), iprefix_Scheme) + fabs(Fb3);
					}
					else {
						sl[iVar][iP].ab3 = Db3 * ApproxConvective(fabs(Pb3), iprefix_Scheme) + fmax(Fb3, 0);
					}
				}

				if (!bE4) {
					sl[iVar][iP].ae4 = De4 * ApproxConvective(fabs(Pe4), iprefix_Scheme) + fmax(-(Fe4), 0);
				}
				else {
					integer inumber = iE4 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].ae4 = De4 * ApproxConvective(fabs(Pe4), iprefix_Scheme) + fabs(Fe4);
					}
					else {
						sl[iVar][iP].ae4 = De4 * ApproxConvective(fabs(Pe4), iprefix_Scheme) + fmax(-(Fe4), 0);
					}
				}
				if (!bW4) {
					sl[iVar][iP].aw4 = Dw4 * ApproxConvective(fabs(Pw4), iprefix_Scheme) + fmax(Fw4, 0);
				}
				else {
					integer inumber = iW4 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].aw4 = Dw4 * ApproxConvective(fabs(Pw4), iprefix_Scheme) + fabs(Fw4);
					}
					else {
						sl[iVar][iP].aw4 = Dw4 * ApproxConvective(fabs(Pw4), iprefix_Scheme) + fmax(Fw4, 0);
					}
				}
				if (!bN4) {
					sl[iVar][iP].an4 = Dn4 * ApproxConvective(fabs(Pn4), iprefix_Scheme) + fmax(-(Fn4), 0);
				}
				else {
					integer inumber = iN4 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].an4 = Dn4 * ApproxConvective(fabs(Pn4), iprefix_Scheme) + fabs(Fn4);
					}
					else {
						sl[iVar][iP].an4 = Dn4 * ApproxConvective(fabs(Pn4), iprefix_Scheme) + fmax(-(Fn4), 0);
					}
				}
				if (!bS4) {
					sl[iVar][iP].as4 = Ds4 * ApproxConvective(fabs(Ps4), iprefix_Scheme) + fmax(Fs4, 0);
				}
				else {
					integer inumber = iS4 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].as4 = Ds4 * ApproxConvective(fabs(Ps4), iprefix_Scheme) + fabs(Fs4);
					}
					else {
						sl[iVar][iP].as4 = Ds4 * ApproxConvective(fabs(Ps4), iprefix_Scheme) + fmax(Fs4, 0);
					}
				}
				if (!bT4) {
					sl[iVar][iP].at4 = Dt4 * ApproxConvective(fabs(Pt4), iprefix_Scheme) + fmax(-(Ft4), 0);
				}
				else {
					integer inumber = iT4 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].at4 = Dt4 * ApproxConvective(fabs(Pt4), iprefix_Scheme) + fabs(Ft4);
					}
					else {
						sl[iVar][iP].at4 = Dt4 * ApproxConvective(fabs(Pt4), iprefix_Scheme) + fmax(-(Ft4), 0);
					}
				}
				if (!bB4) {
					sl[iVar][iP].ab4 = Db4 * ApproxConvective(fabs(Pb4), iprefix_Scheme) + fmax(Fb4, 0);
				}
				else
				{
					integer inumber = iB4 - maxelm;
					if (border_neighbor[inumber].MCB == (ls + lw)) {
						// условие по умолчанию: твёрдая стенка.
						// усиление влияния нуля на границе, нам же нужно влияние стенки.
						sl[iVar][iP].ab4 = Db4 * ApproxConvective(fabs(Pb4), iprefix_Scheme) + fabs(Fb4);
					}
					else {
						sl[iVar][iP].ab4 = Db4 * ApproxConvective(fabs(Pb4), iprefix_Scheme) + fmax(Fb4, 0);
					}
				}
			}
		}
        
		

	    // Вернул как единственно верное и описанное в литературе. 7.05.2017.
		//sl[iVar][iP].ap=sl[iVar][iP].ae+sl[iVar][iP].aw+sl[iVar][iP].an+sl[iVar][iP].as+sl[iVar][iP].at+sl[iVar][iP].ab;
		// Моя наработка:
		// ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).
		if (b_on_adaptive_local_refinement_mesh) {
			// АЛИС 
			
			sl[iVar][iP].ap = De * ApproxConvective(fabs(Pe), iprefix_Scheme) + fmax(+(sign_flux*Fe), 0);
			sl[iVar][iP].ap += Dw * ApproxConvective(fabs(Pw), iprefix_Scheme) + fmax(-(sign_flux * Fw), 0);
			sl[iVar][iP].ap += Dn * ApproxConvective(fabs(Pn), iprefix_Scheme) + fmax(+(sign_flux * Fn), 0);
			sl[iVar][iP].ap += Ds * ApproxConvective(fabs(Ps), iprefix_Scheme) + fmax(-(sign_flux * Fs), 0);
			sl[iVar][iP].ap += Dt * ApproxConvective(fabs(Pt), iprefix_Scheme) + fmax(+(sign_flux * Ft), 0);
			sl[iVar][iP].ap += Db * ApproxConvective(fabs(Pb), iprefix_Scheme) + fmax(-(sign_flux * Fb), 0);

			sl[iVar][iP].ap += De2 * ApproxConvective(fabs(Pe2), iprefix_Scheme) + fmax(+(sign_flux * Fe2), 0);
			sl[iVar][iP].ap += Dw2 * ApproxConvective(fabs(Pw2), iprefix_Scheme) + fmax(-(sign_flux * Fw2), 0);
			sl[iVar][iP].ap += Dn2 * ApproxConvective(fabs(Pn2), iprefix_Scheme) + fmax(+(sign_flux * Fn2), 0);
			sl[iVar][iP].ap += Ds2 * ApproxConvective(fabs(Ps2), iprefix_Scheme) + fmax(-(sign_flux * Fs2), 0);
			sl[iVar][iP].ap += Dt2 * ApproxConvective(fabs(Pt2), iprefix_Scheme) + fmax(+(sign_flux * Ft2), 0);
			sl[iVar][iP].ap += Db2 * ApproxConvective(fabs(Pb2), iprefix_Scheme) + fmax(-(sign_flux * Fb2), 0);

			sl[iVar][iP].ap += De3 * ApproxConvective(fabs(Pe3), iprefix_Scheme) + fmax(+(sign_flux * Fe3), 0);
			sl[iVar][iP].ap += Dw3 * ApproxConvective(fabs(Pw3), iprefix_Scheme) + fmax(-(sign_flux * Fw3), 0);
			sl[iVar][iP].ap += Dn3 * ApproxConvective(fabs(Pn3), iprefix_Scheme) + fmax(+(sign_flux * Fn3), 0);
			sl[iVar][iP].ap += Ds3 * ApproxConvective(fabs(Ps3), iprefix_Scheme) + fmax(-(sign_flux * Fs3), 0);
			sl[iVar][iP].ap += Dt3 * ApproxConvective(fabs(Pt3), iprefix_Scheme) + fmax(+(sign_flux * Ft3), 0);
			sl[iVar][iP].ap += Db3 * ApproxConvective(fabs(Pb3), iprefix_Scheme) + fmax(-(sign_flux * Fb3), 0);

			sl[iVar][iP].ap += De4 * ApproxConvective(fabs(Pe4), iprefix_Scheme) + fmax(+(sign_flux * Fe4), 0);
			sl[iVar][iP].ap += Dw4 * ApproxConvective(fabs(Pw4), iprefix_Scheme) + fmax(-(sign_flux * Fw4), 0);
			sl[iVar][iP].ap += Dn4 * ApproxConvective(fabs(Pn4), iprefix_Scheme) + fmax(+(sign_flux * Fn4), 0);
			sl[iVar][iP].ap += Ds4 * ApproxConvective(fabs(Ps4), iprefix_Scheme) + fmax(-(sign_flux * Fs4), 0);
			sl[iVar][iP].ap += Dt4 * ApproxConvective(fabs(Pt4), iprefix_Scheme) + fmax(+(sign_flux * Ft4), 0);
			sl[iVar][iP].ap += Db4 * ApproxConvective(fabs(Pb4), iprefix_Scheme) + fmax(-(sign_flux * Fb4), 0);
			/*
			sl[iVar][iP].ap = sl[iVar][iP].ae +  sl[iVar][iP].aw + sl[iVar][iP].an + sl[iVar][iP].as + sl[iVar][iP].at + sl[iVar][iP].ab;
			if (b_on_adaptive_local_refinement_mesh) {
				sl[iVar][iP].ap += sl[iVar][iP].ae2 + sl[iVar][iP].aw2 + sl[iVar][iP].an2 + sl[iVar][iP].as2 + sl[iVar][iP].at2 + sl[iVar][iP].ab2;
				sl[iVar][iP].ap += sl[iVar][iP].ae3 + sl[iVar][iP].aw3 + sl[iVar][iP].an3 + sl[iVar][iP].as3 + sl[iVar][iP].at3 + sl[iVar][iP].ab3;
				sl[iVar][iP].ap += sl[iVar][iP].ae4 + sl[iVar][iP].aw4 + sl[iVar][iP].an4 + sl[iVar][iP].as4 + sl[iVar][iP].at4 + sl[iVar][iP].ab4;
			}
			*/
		}
		else {
			sl[iVar][iP].ap  = De * ApproxConvective(fabs(Pe), iprefix_Scheme) + fmax(+(sign_flux * Fe), 0);
			sl[iVar][iP].ap += Dw * ApproxConvective(fabs(Pw), iprefix_Scheme) + fmax(-(sign_flux * Fw), 0);
			sl[iVar][iP].ap += Dn * ApproxConvective(fabs(Pn), iprefix_Scheme) + fmax(+(sign_flux * Fn), 0);
			sl[iVar][iP].ap += Ds * ApproxConvective(fabs(Ps), iprefix_Scheme) + fmax(-(sign_flux * Fs), 0);
			sl[iVar][iP].ap += Dt * ApproxConvective(fabs(Pt), iprefix_Scheme) + fmax(+(sign_flux * Ft), 0);
			sl[iVar][iP].ap += Db * ApproxConvective(fabs(Pb), iprefix_Scheme) + fmax(-(sign_flux * Fb), 0);
		}

		// 13 августа 2016
		// Это ошибочно. Это нигде не написано в литературе. Да конечно это усиливает диагональное преобладание, НО
		// распределения получаются хоть и похожие, но не удовлетворяющие при более тщательном рассмотрении физическому смыслу задачи.
		//sl[iVar][iP].ap = fabs(sl[iVar][iP].ae) + fabs(sl[iVar][iP].aw) + fabs(sl[iVar][iP].an) + fabs(sl[iVar][iP].as) + fabs(sl[iVar][iP].at) + fabs(sl[iVar][iP].ab);
		

		
		if (sl[iVar][iP].ap<1.0e-36) {
			printf("Zero diagonal coefficient in internal volume in my_elmatr_quad_F3D.\n");
#if doubleintprecision == 1
			printf("ap=%e iP=%d\n", sl[iVar][iP].ap, iP);
#else
			printf("ap=%e iP=%d\n", sl[iVar][iP].ap, iP);
#endif
			if (b_on_adaptive_local_refinement_mesh) {
				printf("ae=%e aw=%e an=%e as=%e at=%e ab=%e\n", sl[iVar][iP].ae, sl[iVar][iP].aw, sl[iVar][iP].an, sl[iVar][iP].as, sl[iVar][iP].at, sl[iVar][iP].ab);
				printf("ae2=%e aw2=%e an2=%e as2=%e at2=%e ab2=%e\n", sl[iVar][iP].ae2, sl[iVar][iP].aw2, sl[iVar][iP].an2, sl[iVar][iP].as2, sl[iVar][iP].at2, sl[iVar][iP].ab2);
				printf("ae3=%e aw3=%e an3=%e as3=%e at3=%e ab3=%e\n", sl[iVar][iP].ae3, sl[iVar][iP].aw3, sl[iVar][iP].an3, sl[iVar][iP].as3, sl[iVar][iP].at3, sl[iVar][iP].ab3);
				printf("ae4=%e aw4=%e an4=%e as4=%e at4=%e ab4=%e\n", sl[iVar][iP].ae4, sl[iVar][iP].aw4, sl[iVar][iP].an4, sl[iVar][iP].as4, sl[iVar][iP].at4, sl[iVar][iP].ab4);
			}
			else {
				printf("ae=%e aw=%e an=%e as=%e at=%e ab=%e\n", sl[iVar][iP].ae, sl[iVar][iP].aw, sl[iVar][iP].an, sl[iVar][iP].as, sl[iVar][iP].at, sl[iVar][iP].ab);
			}
			system("pause");

			// Это особая ячейка из которой всё вытекает
			// Т.е. на данном этапе имеем нулевой диагональный элемент.
			// Наверно нужно добавить Диффузии иначе нельзя будет вычислить псевдовремя, оно будет бесконечным.
			// Но диффузию мы всё-таки ограничим применив схему Булгакова.
            sl[iVar][iP].ae=De*ApproxConvective(fabs(Pe),BULG);//+fmax(-(Fe),0); 
	        sl[iVar][iP].aw=Dw*ApproxConvective(fabs(Pw),BULG);//+fmax(Fw,0); 
	        sl[iVar][iP].an=Dn*ApproxConvective(fabs(Pn),BULG);//+fmax(-(Fn),0); 
	        sl[iVar][iP].as=Ds*ApproxConvective(fabs(Ps),BULG);//+fmax(Fs,0); 
            sl[iVar][iP].at=Dt*ApproxConvective(fabs(Pt),BULG);//+fmax(-(Ft),0); 
	        sl[iVar][iP].ab=Db*ApproxConvective(fabs(Pb),BULG);//+fmax(Fb,0); 
			if (b_on_adaptive_local_refinement_mesh) {
				sl[iVar][iP].ae2 = De2 * ApproxConvective(fabs(Pe2), BULG);//+fmax(-(Fe2),0); 
				sl[iVar][iP].aw2 = Dw2 * ApproxConvective(fabs(Pw2), BULG);//+fmax(Fw2,0); 
				sl[iVar][iP].an2 = Dn2 * ApproxConvective(fabs(Pn2), BULG);//+fmax(-(Fn2),0); 
				sl[iVar][iP].as2 = Ds2 * ApproxConvective(fabs(Ps2), BULG);//+fmax(Fs2,0); 
				sl[iVar][iP].at2 = Dt2 * ApproxConvective(fabs(Pt2), BULG);//+fmax(-(Ft2),0); 
				sl[iVar][iP].ab2 = Db2 * ApproxConvective(fabs(Pb2), BULG);//+fmax(Fb2,0); 

				sl[iVar][iP].ae3 = De3 * ApproxConvective(fabs(Pe3), BULG);//+fmax(-(Fe3),0); 
				sl[iVar][iP].aw3 = Dw3 * ApproxConvective(fabs(Pw3), BULG);//+fmax(Fw3,0); 
				sl[iVar][iP].an3 = Dn3 * ApproxConvective(fabs(Pn3), BULG);//+fmax(-(Fn3),0); 
				sl[iVar][iP].as3 = Ds3 * ApproxConvective(fabs(Ps3), BULG);//+fmax(Fs3,0); 
				sl[iVar][iP].at3 = Dt3 * ApproxConvective(fabs(Pt3), BULG);//+fmax(-(Ft3),0); 
				sl[iVar][iP].ab3 = Db3 * ApproxConvective(fabs(Pb3), BULG);//+fmax(Fb3,0); 

				sl[iVar][iP].ae4 = De4 * ApproxConvective(fabs(Pe4), BULG);//+fmax(-(Fe4),0); 
				sl[iVar][iP].aw4 = Dw4 * ApproxConvective(fabs(Pw4), BULG);//+fmax(Fw4,0); 
				sl[iVar][iP].an4 = Dn4 * ApproxConvective(fabs(Pn4), BULG);//+fmax(-(Fn4),0); 
				sl[iVar][iP].as4 = Ds4 * ApproxConvective(fabs(Ps4), BULG);//+fmax(Fs4,0); 
				sl[iVar][iP].at4 = Dt4 * ApproxConvective(fabs(Pt4), BULG);//+fmax(-(Ft4),0); 
				sl[iVar][iP].ab4 = Db4 * ApproxConvective(fabs(Pb4), BULG);//+fmax(Fb4,0); 
			}
		    sl[iVar][iP].ap=sl[iVar][iP].ae+sl[iVar][iP].aw+sl[iVar][iP].an+sl[iVar][iP].as+sl[iVar][iP].at+sl[iVar][iP].ab;
			if (b_on_adaptive_local_refinement_mesh) {
				sl[iVar][iP].ap += sl[iVar][iP].ae2 + sl[iVar][iP].aw2 + sl[iVar][iP].an2 + sl[iVar][iP].as2 + sl[iVar][iP].at2 + sl[iVar][iP].ab2;
				sl[iVar][iP].ap += sl[iVar][iP].ae3 + sl[iVar][iP].aw3 + sl[iVar][iP].an3 + sl[iVar][iP].as3 + sl[iVar][iP].at3 + sl[iVar][iP].ab3;
				sl[iVar][iP].ap += sl[iVar][iP].ae4 + sl[iVar][iP].aw4 + sl[iVar][iP].an4 + sl[iVar][iP].as4 + sl[iVar][iP].at4 + sl[iVar][iP].ab4;
			}
		}
		

		// Вернул как единственно верное и описанное в литературе. 7.05.2017.
		//sumanb=sl[iVar][iP].ae+sl[iVar][iP].aw+sl[iVar][iP].an+sl[iVar][iP].as+sl[iVar][iP].at+sl[iVar][iP].ab;
		// Моя наработка:
		// ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).
		
		sumanb =  De*ApproxConvective(fabs(Pe), iprefix_Scheme) + fmax(+(sign_flux * Fe), 0);
		sumanb += Dw*ApproxConvective(fabs(Pw), iprefix_Scheme) + fmax(-(sign_flux * Fw), 0);
		sumanb += Dn*ApproxConvective(fabs(Pn), iprefix_Scheme) + fmax(+(sign_flux * Fn), 0);
		sumanb += Ds*ApproxConvective(fabs(Ps), iprefix_Scheme) + fmax(-(sign_flux * Fs), 0);
		sumanb += Dt*ApproxConvective(fabs(Pt), iprefix_Scheme) + fmax(+(sign_flux * Ft), 0);
		sumanb += Db*ApproxConvective(fabs(Pb), iprefix_Scheme) + fmax(-(sign_flux * Fb), 0);
		if (b_on_adaptive_local_refinement_mesh) {
			sumanb += De2 * ApproxConvective(fabs(Pe2), iprefix_Scheme) + fmax(+(sign_flux * Fe2), 0);
			sumanb += Dw2 * ApproxConvective(fabs(Pw2), iprefix_Scheme) + fmax(-(sign_flux * Fw2), 0);
			sumanb += Dn2 * ApproxConvective(fabs(Pn2), iprefix_Scheme) + fmax(+(sign_flux * Fn2), 0);
			sumanb += Ds2 * ApproxConvective(fabs(Ps2), iprefix_Scheme) + fmax(-(sign_flux * Fs2), 0);
			sumanb += Dt2 * ApproxConvective(fabs(Pt2), iprefix_Scheme) + fmax(+(sign_flux * Ft2), 0);
			sumanb += Db2 * ApproxConvective(fabs(Pb2), iprefix_Scheme) + fmax(-(sign_flux * Fb2), 0);

			sumanb += De3 * ApproxConvective(fabs(Pe3), iprefix_Scheme) + fmax(+(sign_flux * Fe3), 0);
			sumanb += Dw3 * ApproxConvective(fabs(Pw3), iprefix_Scheme) + fmax(-(sign_flux * Fw3), 0);
			sumanb += Dn3 * ApproxConvective(fabs(Pn3), iprefix_Scheme) + fmax(+(sign_flux * Fn3), 0);
			sumanb += Ds3 * ApproxConvective(fabs(Ps3), iprefix_Scheme) + fmax(-(sign_flux * Fs3), 0);
			sumanb += Dt3 * ApproxConvective(fabs(Pt3), iprefix_Scheme) + fmax(+(sign_flux * Ft3), 0);
			sumanb += Db3 * ApproxConvective(fabs(Pb3), iprefix_Scheme) + fmax(-(sign_flux * Fb3), 0);

			sumanb += De4 * ApproxConvective(fabs(Pe4), iprefix_Scheme) + fmax(+(sign_flux * Fe4), 0);
			sumanb += Dw4 * ApproxConvective(fabs(Pw4), iprefix_Scheme) + fmax(-(sign_flux * Fw4), 0);
			sumanb += Dn4 * ApproxConvective(fabs(Pn4), iprefix_Scheme) + fmax(+(sign_flux * Fn4), 0);
			sumanb += Ds4 * ApproxConvective(fabs(Ps4), iprefix_Scheme) + fmax(-(sign_flux * Fs4), 0);
			sumanb += Dt4 * ApproxConvective(fabs(Pt4), iprefix_Scheme) + fmax(+(sign_flux * Ft4), 0);
			sumanb += Db4 * ApproxConvective(fabs(Pb4), iprefix_Scheme) + fmax(-(sign_flux * Fb4), 0);
		}
		
		//13 августа 2016.
		//sumanb = fabs(sl[iVar][iP].ae) + fabs(sl[iVar][iP].aw) + fabs(sl[iVar][iP].an) + fabs(sl[iVar][iP].as) + fabs(sl[iVar][iP].at) + fabs(sl[iVar][iP].ab);
		/*sumanb = sl[iVar][iP].ae + sl[iVar][iP].aw + sl[iVar][iP].an + sl[iVar][iP].as + sl[iVar][iP].at + sl[iVar][iP].ab;
		if (b_on_adaptive_local_refinement_mesh) {
			sumanb += sl[iVar][iP].ae2 + sl[iVar][iP].aw2 + sl[iVar][iP].an2 + sl[iVar][iP].as2 + sl[iVar][iP].at2 + sl[iVar][iP].ab2;
			sumanb += sl[iVar][iP].ae3 + sl[iVar][iP].aw3 + sl[iVar][iP].an3 + sl[iVar][iP].as3 + sl[iVar][iP].at3 + sl[iVar][iP].ab3;
			sumanb += sl[iVar][iP].ae4 + sl[iVar][iP].aw4 + sl[iVar][iP].an4 + sl[iVar][iP].as4 + sl[iVar][iP].at4 + sl[iVar][iP].ab4;
		}*/

	}
	  else if (ishconvection < QUICK)
	{

		if (b_on_adaptive_local_refinement_mesh) {

			// Вычисление коэффициентов дискретного аналога:
			sl[iVar][iP].ae = -(Fe)*fC(Pe, ishconvection, true, feplus) + De * fD(Pe, ishconvection, true, feplus);
			sl[iVar][iP].aw = (Fw)*fC(Pw, ishconvection, true, fwplus) + Dw * fD(Pw, ishconvection, true, fwplus);
			sl[iVar][iP].an = -(Fn)*fC(Pn, ishconvection, true, fnplus) + Dn * fD(Pn, ishconvection, true, fnplus);
			sl[iVar][iP].as = (Fs)*fC(Ps, ishconvection, true, fsplus) + Ds * fD(Ps, ishconvection, true, fsplus);
			sl[iVar][iP].at = -(Ft)*fC(Pt, ishconvection, true, ftplus) + Dt * fD(Pt, ishconvection, true, ftplus);
			sl[iVar][iP].ab = (Fb)*fC(Pb, ishconvection, true, fbplus) + Db * fD(Pb, ishconvection, true, fbplus);

			// Вычисление коэффициентов дискретного аналога:
			sl[iVar][iP].ae2 = -(Fe2)*fC(Pe2, ishconvection, true, feplus2) + De2 * fD(Pe2, ishconvection, true, feplus2);
			sl[iVar][iP].aw2 = (Fw2)*fC(Pw2, ishconvection, true, fwplus2) + Dw2 * fD(Pw2, ishconvection, true, fwplus2);
			sl[iVar][iP].an2 = -(Fn2)*fC(Pn2, ishconvection, true, fnplus2) + Dn2 * fD(Pn2, ishconvection, true, fnplus2);
			sl[iVar][iP].as2 = (Fs2)*fC(Ps2, ishconvection, true, fsplus2) + Ds2 * fD(Ps2, ishconvection, true, fsplus2);
			sl[iVar][iP].at2 = -(Ft2)*fC(Pt2, ishconvection, true, ftplus2) + Dt2 * fD(Pt2, ishconvection, true, ftplus2);
			sl[iVar][iP].ab2 = (Fb2)*fC(Pb2, ishconvection, true, fbplus2) + Db2 * fD(Pb2, ishconvection, true, fbplus2);

			sl[iVar][iP].ae3 = -(Fe3)*fC(Pe3, ishconvection, true, feplus3) + De3 * fD(Pe3, ishconvection, true, feplus3);
			sl[iVar][iP].aw3 = (Fw3)*fC(Pw3, ishconvection, true, fwplus3) + Dw3 * fD(Pw3, ishconvection, true, fwplus3);
			sl[iVar][iP].an3 = -(Fn3)*fC(Pn3, ishconvection, true, fnplus3) + Dn3 * fD(Pn3, ishconvection, true, fnplus3);
			sl[iVar][iP].as3 = (Fs3)*fC(Ps3, ishconvection, true, fsplus3) + Ds3 * fD(Ps3, ishconvection, true, fsplus3);
			sl[iVar][iP].at3 = -(Ft3)*fC(Pt3, ishconvection, true, ftplus3) + Dt3 * fD(Pt3, ishconvection, true, ftplus3);
			sl[iVar][iP].ab3 = (Fb3)*fC(Pb3, ishconvection, true, fbplus3) + Db3 * fD(Pb3, ishconvection, true, fbplus3);

			sl[iVar][iP].ae4 = -(Fe4)*fC(Pe4, ishconvection, true, feplus4) + De4 * fD(Pe4, ishconvection, true, feplus4);
			sl[iVar][iP].aw4 = (Fw4)*fC(Pw4, ishconvection, true, fwplus4) + Dw4 * fD(Pw4, ishconvection, true, fwplus4);
			sl[iVar][iP].an4 = -(Fn4)*fC(Pn4, ishconvection, true, fnplus4) + Dn4 * fD(Pn4, ishconvection, true, fnplus4);
			sl[iVar][iP].as4 = (Fs4)*fC(Ps4, ishconvection, true, fsplus4) + Ds4 * fD(Ps4, ishconvection, true, fsplus4);
			sl[iVar][iP].at4 = -(Ft4)*fC(Pt4, ishconvection, true, ftplus4) + Dt4 * fD(Pt4, ishconvection, true, ftplus4);
			sl[iVar][iP].ab4 = (Fb4)*fC(Pb4, ishconvection, true, fbplus4) + Db4 * fD(Pb4, ishconvection, true, fbplus4);

			// 08.05.2017.
			// Моя наработка:
			// ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).

			sl[iVar][iP].ap = +(Fe)*fC(Pe, ishconvection, true, feplus) + De * fD(Pe, ishconvection, true, feplus);
			sl[iVar][iP].ap += -(Fw)*fC(Pw, ishconvection, true, fwplus) + Dw * fD(Pw, ishconvection, true, fwplus);
			sl[iVar][iP].ap += +(Fn)*fC(Pn, ishconvection, true, fnplus) + Dn * fD(Pn, ishconvection, true, fnplus);
			sl[iVar][iP].ap += -(Fs)*fC(Ps, ishconvection, true, fsplus) + Ds * fD(Ps, ishconvection, true, fsplus);
			sl[iVar][iP].ap += +(Ft)*fC(Pt, ishconvection, true, ftplus) + Dt * fD(Pt, ishconvection, true, ftplus);
			sl[iVar][iP].ap += -(Fb)*fC(Pb, ishconvection, true, fbplus) + Db * fD(Pb, ishconvection, true, fbplus);

			sl[iVar][iP].ap += +(Fe2)*fC(Pe2, ishconvection, true, feplus2) + De2 * fD(Pe2, ishconvection, true, feplus2);
			sl[iVar][iP].ap += -(Fw2)*fC(Pw2, ishconvection, true, fwplus2) + Dw2 * fD(Pw2, ishconvection, true, fwplus2);
			sl[iVar][iP].ap += +(Fn2)*fC(Pn2, ishconvection, true, fnplus2) + Dn2 * fD(Pn2, ishconvection, true, fnplus2);
			sl[iVar][iP].ap += -(Fs2)*fC(Ps2, ishconvection, true, fsplus2) + Ds2 * fD(Ps2, ishconvection, true, fsplus2);
			sl[iVar][iP].ap += +(Ft2)*fC(Pt2, ishconvection, true, ftplus2) + Dt2 * fD(Pt2, ishconvection, true, ftplus2);
			sl[iVar][iP].ap += -(Fb2)*fC(Pb2, ishconvection, true, fbplus2) + Db2 * fD(Pb2, ishconvection, true, fbplus2);

			sl[iVar][iP].ap += +(Fe3)*fC(Pe3, ishconvection, true, feplus3) + De3 * fD(Pe3, ishconvection, true, feplus3);
			sl[iVar][iP].ap += -(Fw3)*fC(Pw3, ishconvection, true, fwplus3) + Dw3 * fD(Pw3, ishconvection, true, fwplus3);
			sl[iVar][iP].ap += +(Fn3)*fC(Pn3, ishconvection, true, fnplus3) + Dn3 * fD(Pn3, ishconvection, true, fnplus3);
			sl[iVar][iP].ap += -(Fs3)*fC(Ps3, ishconvection, true, fsplus3) + Ds3 * fD(Ps3, ishconvection, true, fsplus3);
			sl[iVar][iP].ap += +(Ft3)*fC(Pt3, ishconvection, true, ftplus3) + Dt3 * fD(Pt3, ishconvection, true, ftplus3);
			sl[iVar][iP].ap += -(Fb3)*fC(Pb3, ishconvection, true, fbplus3) + Db3 * fD(Pb3, ishconvection, true, fbplus3);

			sl[iVar][iP].ap += +(Fe4)*fC(Pe4, ishconvection, true, feplus4) + De4 * fD(Pe4, ishconvection, true, feplus4);
			sl[iVar][iP].ap += -(Fw4)*fC(Pw4, ishconvection, true, fwplus4) + Dw4 * fD(Pw4, ishconvection, true, fwplus4);
			sl[iVar][iP].ap += +(Fn4)*fC(Pn4, ishconvection, true, fnplus4) + Dn4 * fD(Pn4, ishconvection, true, fnplus4);
			sl[iVar][iP].ap += -(Fs4)*fC(Ps4, ishconvection, true, fsplus4) + Ds4 * fD(Ps4, ishconvection, true, fsplus4);
			sl[iVar][iP].ap += +(Ft4)*fC(Pt4, ishconvection, true, ftplus4) + Dt4 * fD(Pt4, ishconvection, true, ftplus4);
			sl[iVar][iP].ap += -(Fb4)*fC(Pb4, ishconvection, true, fbplus4) + Db4 * fD(Pb4, ishconvection, true, fbplus4);

			sumanb = +(Fe)*fC(Pe, ishconvection, true, feplus) + De * fD(Pe, ishconvection, true, feplus);
			sumanb += -(Fw)*fC(Pw, ishconvection, true, fwplus) + Dw * fD(Pw, ishconvection, true, fwplus);
			sumanb += +(Fn)*fC(Pn, ishconvection, true, fnplus) + Dn * fD(Pn, ishconvection, true, fnplus);
			sumanb += -(Fs)*fC(Ps, ishconvection, true, fsplus) + Ds * fD(Ps, ishconvection, true, fsplus);
			sumanb += +(Ft)*fC(Pt, ishconvection, true, ftplus) + Dt * fD(Pt, ishconvection, true, ftplus);
			sumanb += -(Fb)*fC(Pb, ishconvection, true, fbplus) + Db * fD(Pb, ishconvection, true, fbplus);

			sumanb += +(Fe2)*fC(Pe2, ishconvection, true, feplus2) + De2 * fD(Pe2, ishconvection, true, feplus2);
			sumanb += -(Fw2)*fC(Pw2, ishconvection, true, fwplus2) + Dw2 * fD(Pw2, ishconvection, true, fwplus2);
			sumanb += +(Fn2)*fC(Pn2, ishconvection, true, fnplus2) + Dn2 * fD(Pn2, ishconvection, true, fnplus2);
			sumanb += -(Fs2)*fC(Ps2, ishconvection, true, fsplus2) + Ds2 * fD(Ps2, ishconvection, true, fsplus2);
			sumanb += +(Ft2)*fC(Pt2, ishconvection, true, ftplus2) + Dt2 * fD(Pt2, ishconvection, true, ftplus2);
			sumanb += -(Fb2)*fC(Pb2, ishconvection, true, fbplus2) + Db2 * fD(Pb2, ishconvection, true, fbplus2);

			sumanb += +(Fe3)*fC(Pe3, ishconvection, true, feplus3) + De3 * fD(Pe3, ishconvection, true, feplus3);
			sumanb += -(Fw3)*fC(Pw3, ishconvection, true, fwplus3) + Dw3 * fD(Pw3, ishconvection, true, fwplus3);
			sumanb += +(Fn3)*fC(Pn3, ishconvection, true, fnplus3) + Dn3 * fD(Pn3, ishconvection, true, fnplus3);
			sumanb += -(Fs3)*fC(Ps3, ishconvection, true, fsplus3) + Ds3 * fD(Ps3, ishconvection, true, fsplus3);
			sumanb += +(Ft3)*fC(Pt3, ishconvection, true, ftplus3) + Dt3 * fD(Pt3, ishconvection, true, ftplus3);
			sumanb += -(Fb3)*fC(Pb3, ishconvection, true, fbplus3) + Db3 * fD(Pb3, ishconvection, true, fbplus3);

			sumanb += +(Fe4)*fC(Pe4, ishconvection, true, feplus4) + De4 * fD(Pe4, ishconvection, true, feplus4);
			sumanb += -(Fw4)*fC(Pw4, ishconvection, true, fwplus4) + Dw4 * fD(Pw4, ishconvection, true, fwplus4);
			sumanb += +(Fn4)*fC(Pn4, ishconvection, true, fnplus4) + Dn4 * fD(Pn4, ishconvection, true, fnplus4);
			sumanb += -(Fs4)*fC(Ps4, ishconvection, true, fsplus4) + Ds4 * fD(Ps4, ishconvection, true, fsplus4);
			sumanb += +(Ft4)*fC(Pt4, ishconvection, true, ftplus4) + Dt4 * fD(Pt4, ishconvection, true, ftplus4);
			sumanb += -(Fb4)*fC(Pb4, ishconvection, true, fbplus4) + Db4 * fD(Pb4, ishconvection, true, fbplus4);

		}
		else {

			// Вычисление коэффициентов дискретного аналога:
			sl[iVar][iP].ae = -(Fe)*fC(Pe, ishconvection, true, feplus) + De * fD(Pe, ishconvection, true, feplus);
			sl[iVar][iP].aw = (Fw)*fC(Pw, ishconvection, true, fwplus) + Dw * fD(Pw, ishconvection, true, fwplus);
			sl[iVar][iP].an = -(Fn)*fC(Pn, ishconvection, true, fnplus) + Dn * fD(Pn, ishconvection, true, fnplus);
			sl[iVar][iP].as = (Fs)*fC(Ps, ishconvection, true, fsplus) + Ds * fD(Ps, ishconvection, true, fsplus);
			sl[iVar][iP].at = -(Ft)*fC(Pt, ishconvection, true, ftplus) + Dt * fD(Pt, ishconvection, true, ftplus);
			sl[iVar][iP].ab = (Fb)*fC(Pb, ishconvection, true, fbplus) + Db * fD(Pb, ishconvection, true, fbplus);
			//sl[iVar][iP].ap=sl[iVar][iP].ae+sl[iVar][iP].aw+sl[iVar][iP].an+sl[iVar][iP].as+sl[iVar][iP].at+sl[iVar][iP].ab;

			// Вернул как единственно верное и описанное в литературе. 7.05.2017.
			//sumanb=sl[iVar][iP].ae+sl[iVar][iP].aw+sl[iVar][iP].an+sl[iVar][iP].as+sl[iVar][iP].at+sl[iVar][iP].ab;
			//13 августа 2016.
			//sumanb = fabs(sl[iVar][iP].ae) + fabs(sl[iVar][iP].aw) + fabs(sl[iVar][iP].an) + fabs(sl[iVar][iP].as) + fabs(sl[iVar][iP].at) + fabs(sl[iVar][iP].ab);

			// 08.05.2017.
			// Моя наработка:
			// ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).

			sl[iVar][iP].ap = +(Fe)*fC(Pe, ishconvection, true, feplus) + De * fD(Pe, ishconvection, true, feplus);
			sl[iVar][iP].ap += -(Fw)*fC(Pw, ishconvection, true, fwplus) + Dw * fD(Pw, ishconvection, true, fwplus);
			sl[iVar][iP].ap += +(Fn)*fC(Pn, ishconvection, true, fnplus) + Dn * fD(Pn, ishconvection, true, fnplus);
			sl[iVar][iP].ap += -(Fs)*fC(Ps, ishconvection, true, fsplus) + Ds * fD(Ps, ishconvection, true, fsplus);
			sl[iVar][iP].ap += +(Ft)*fC(Pt, ishconvection, true, ftplus) + Dt * fD(Pt, ishconvection, true, ftplus);
			sl[iVar][iP].ap += -(Fb)*fC(Pb, ishconvection, true, fbplus) + Db * fD(Pb, ishconvection, true, fbplus);

			sumanb = +(Fe)*fC(Pe, ishconvection, true, feplus) + De * fD(Pe, ishconvection, true, feplus);
			sumanb += -(Fw)*fC(Pw, ishconvection, true, fwplus) + Dw * fD(Pw, ishconvection, true, fwplus);
			sumanb += +(Fn)*fC(Pn, ishconvection, true, fnplus) + Dn * fD(Pn, ishconvection, true, fnplus);
			sumanb += -(Fs)*fC(Ps, ishconvection, true, fsplus) + Ds * fD(Ps, ishconvection, true, fsplus);
			sumanb += +(Ft)*fC(Pt, ishconvection, true, ftplus) + Dt * fD(Pt, ishconvection, true, ftplus);
			sumanb += -(Fb)*fC(Pb, ishconvection, true, fbplus) + Db * fD(Pb, ishconvection, true, fbplus);
		}
	}
	  else if (ishconvection >= QUICK)
	{
		// В 3D пространстве данная схема расщепляется на три одномерных схемы.
		// Схема Леонарда имеет второй порядок и реализуется с помощью механизма отложенной коррекции.
		integer iVarCOR=VXCOR;
		switch (iVar) {
		  case VELOCITY_X_COMPONENT: iVarCOR=VXCOR; break; // VXCOR
		  case VELOCITY_Y_COMPONENT: iVarCOR=VYCOR; break; // VYCOR
		  case VELOCITY_Z_COMPONENT: iVarCOR=VZCOR; break; // VZCOR
		  default: 
			  printf("Error ! This feature is not available. \n");
			  printf("exeption in my_elmatr_quad_f3D.c: iVar != Vx || Vy || Vz.\n");
			  printf("Please, press any key to exit...\n");
			  //getchar();
			  system("pause");
			  exit(0);
			  break;
		}

		TOCHKA pointP;
		//center_cord3D(iP,nvtx,pa,pointP,100);
		pointP = center_coord_loc[iP];

		// X - direction
		doublereal positionxP = pointP.x, positionxE = pointP.x, positionxW = pointP.x, positionxEE = pointP.x, positionxWW = pointP.x, positionxe = pointP.x, positionxw = pointP.x;
		doublereal SpeedP=0.0, SpeedE=0.0, SpeedW=0.0, SpeedEE=0.0, SpeedWW=0.0, SpeedN=0.0, SpeedS=0.0;
		doublereal SpeedNN=0.0, SpeedSS=0.0, SpeedT=0.0, SpeedB=0.0, SpeedTT=0.0, SpeedBB=0.0;
		doublereal Speede=0.0, Speedw=0.0, Speedn=0.0, Speeds=0.0, Speedt=0.0, Speedb=0.0;
		// Y - direction
		doublereal positionyP = pointP.y, positionyN = pointP.y, positionyS = pointP.y, positionyNN = pointP.y, positionySS = pointP.y, positionyn = pointP.y, positionys = pointP.y;
		// Z - direction
		doublereal positionzP = pointP.z, positionzT = pointP.z, positionzB = pointP.z, positionzTT = pointP.z, positionzBB = pointP.z, positionzt = pointP.z, positionzb = pointP.z;

		doublereal SpeedE2 = 0.0, SpeedW2 = 0.0, SpeedEE2 = 0.0, SpeedWW2 = 0.0, SpeedN2 = 0.0, SpeedS2 = 0.0;
		doublereal SpeedNN2 = 0.0, SpeedSS2 = 0.0, SpeedT2 = 0.0, SpeedB2 = 0.0, SpeedTT2 = 0.0, SpeedBB2 = 0.0;
		doublereal Speede2 = 0.0, Speedw2 = 0.0, Speedn2 = 0.0, Speeds2 = 0.0, Speedt2 = 0.0, Speedb2 = 0.0;

		doublereal  SpeedE3 = 0.0, SpeedW3 = 0.0, SpeedEE3 = 0.0, SpeedWW3 = 0.0, SpeedN3 = 0.0, SpeedS3 = 0.0;
		doublereal SpeedNN3 = 0.0, SpeedSS3 = 0.0, SpeedT3 = 0.0, SpeedB3 = 0.0, SpeedTT3 = 0.0, SpeedBB3 = 0.0;
		doublereal Speede3 = 0.0, Speedw3 = 0.0, Speedn3 = 0.0, Speeds3 = 0.0, Speedt3 = 0.0, Speedb3 = 0.0;

		doublereal SpeedE4 = 0.0, SpeedW4 = 0.0, SpeedEE4 = 0.0, SpeedWW4 = 0.0, SpeedN4 = 0.0, SpeedS4 = 0.0;
		doublereal SpeedNN4 = 0.0, SpeedSS4 = 0.0, SpeedT4 = 0.0, SpeedB4 = 0.0, SpeedTT4 = 0.0, SpeedBB4 = 0.0;
		doublereal Speede4 = 0.0, Speedw4 = 0.0, Speedn4 = 0.0, Speeds4 = 0.0, Speedt4 = 0.0, Speedb4 = 0.0;

		

		// X - direction
		doublereal  positionxE2= pointP.x, positionxW2 = pointP.x, positionxEE2 = pointP.x, positionxWW2 = pointP.x, positionxe2 = pointP.x, positionxw2 = pointP.x;
		// Y - direction
		doublereal  positionyN2= pointP.y, positionyS2 = pointP.y, positionyNN2 = pointP.y, positionySS2 = pointP.y, positionyn2 = pointP.y, positionys2 = pointP.y;
		// Z - direction
		doublereal  positionzT2 = pointP.z, positionzB2 = pointP.z, positionzTT2 = pointP.z, positionzBB2 = pointP.z, positionzt2 = pointP.z, positionzb2 = pointP.z;

		// X - direction
		doublereal  positionxE3 = pointP.x, positionxW3 = pointP.x, positionxEE3 = pointP.x, positionxWW3 = pointP.x, positionxe3 = pointP.x, positionxw3 = pointP.x;
		// Y - direction
		doublereal  positionyN3 = pointP.y, positionyS3 = pointP.y, positionyNN3 = pointP.y, positionySS3 = pointP.y, positionyn3 = pointP.y, positionys3 = pointP.y;
		// Z - direction
		doublereal  positionzT3 = pointP.z, positionzB3 = pointP.z, positionzTT3 = pointP.z, positionzBB3 = pointP.z, positionzt3 = pointP.z, positionzb3 = pointP.z;

		// X - direction
		doublereal  positionxE4 = pointP.x, positionxW4 = pointP.x, positionxEE4 = pointP.x, positionxWW4 = pointP.x, positionxe4 = pointP.x, positionxw4 = pointP.x;
		// Y - direction
		doublereal  positionyN4 = pointP.y, positionyS4 = pointP.y, positionyNN4 = pointP.y, positionySS4 = pointP.y, positionyn4 = pointP.y, positionys4 = pointP.y;
		// Z - direction
		doublereal  positionzT4 = pointP.z, positionzB4 = pointP.z, positionzTT4 = pointP.z, positionzBB4 = pointP.z, positionzt4 = pointP.z, positionzb4 = pointP.z;

		

		positionxP=pointP.x; positionyP=pointP.y; positionzP=pointP.z;
		SpeedP=potent[iVarCOR][iP];
		// X - direction
		if ((!bE)&&(iE > -1)) {
			SpeedE=potent[iVarCOR][iE];
			//center_cord3D(iE,nvtx,pa,pointP,E_SIDE);
			pointP = center_coord_loc[iE];

			positionxE=pointP.x;
			positionxe=positionxP+0.5*dx;

			integer iEE=neighbors_for_the_internal_node[E_SIDE][0][iE];
			if (iEE < 0) {
				iEE = neighbors_for_the_internal_node[E_SIDE][1][iE];
			}
			if (iEE < 0) {
				iEE = neighbors_for_the_internal_node[E_SIDE][2][iE];
			}
			if (iEE < 0) {
				iEE = neighbors_for_the_internal_node[E_SIDE][3][iE];
			}

			if ((iEE>=0)&&(iEE < maxelm)) {
				// внутренний узел
				SpeedEE=potent[iVarCOR][iEE];
				//center_cord3D(iEE,nvtx,pa,pointP,EE_SIDE);
				pointP = center_coord_loc[iEE];
				positionxEE=pointP.x;
			}
			else
			{
				// граничный узел
				if ((iEE >= maxelm) && (iEE < maxelm + maxbound)) {
					SpeedEE = potent[iVarCOR][iEE];
				}
				else {
					SpeedEE = SpeedE;
				}
				//volume3D(iE, nvtx, pa, pointP.x, pointP.y, pointP.z);
				pointP = volume_loc[iE];
				
				positionxEE=positionxE+0.5*pointP.x;
			}
		}
		else {
			// это граничный узел
			SpeedE=potent[iVarCOR][iE];
			SpeedEE=potent[iVarCOR][iE]; 
			positionxe=positionxP+0.5*dx;
            positionxE=positionxP+0.5*dx;
			positionxEE=positionxP+dx; // этого узла не существует !
		}

		if ((!bW)&&(iW > -1)) {
			//center_cord3D(iW,nvtx,pa,pointP,W_SIDE);
			pointP = center_coord_loc[iW];
			positionxW=pointP.x;
			positionxw=positionxP-0.5*dx;
			SpeedW=potent[iVarCOR][iW];

			integer iWW=neighbors_for_the_internal_node[W_SIDE][0][iW];
			if (iWW < 0) {
				iWW = neighbors_for_the_internal_node[W_SIDE][1][iW];
			}
			if (iWW < 0) {
				iWW = neighbors_for_the_internal_node[W_SIDE][2][iW];
			}
			if (iWW < 0) {
				iWW = neighbors_for_the_internal_node[W_SIDE][3][iW];
			}

			if ((iWW >= 0) && (iWW < maxelm)) {
				// внутренний узел
				SpeedWW=potent[iVarCOR][iWW];
				//center_cord3D(iWW,nvtx,pa,pointP,WW_SIDE);
				pointP = center_coord_loc[iWW];
				positionxWW=pointP.x;
			}
			else
			{
				// граничный узел
				if ((iWW >= maxelm) && (iWW < maxelm + maxbound)) {
					SpeedWW = potent[iVarCOR][iWW];
				}
				else {
					SpeedWW = SpeedW;
				}
				//volume3D(iW, nvtx, pa, pointP.x, pointP.y, pointP.z);
				pointP = volume_loc[iW];

				positionxWW=positionxW-0.5*pointP.x;
			}
		}
		else {
			// это граничный узел
			SpeedW=potent[iVarCOR][iW]; // Attantion !! Debug
			SpeedWW=potent[iVarCOR][iW]; 
			//printf("SpeedW==%e\n",SpeedW); getchar();
			positionxw=positionxP-0.5*dx;
            positionxW=positionxP-0.5*dx;
			positionxWW=positionxP-dx; // этого узла не существует !
		}

		// Y - direction
		if ((!bN)&&(iN > -1)) {
			SpeedN=potent[iVarCOR][iN];
			//center_cord3D(iN,nvtx,pa,pointP,N_SIDE);
			pointP = center_coord_loc[iN];
			positionyN=pointP.y;
			positionyn=positionxP+0.5*dy;

			integer iNN=neighbors_for_the_internal_node[N_SIDE][0][iN];
			if (iNN < 0) {
				iNN = neighbors_for_the_internal_node[N_SIDE][1][iN];
			}
			if (iNN < 0) {
				iNN = neighbors_for_the_internal_node[N_SIDE][2][iN];
			}
			if (iNN < 0) {
				iNN = neighbors_for_the_internal_node[N_SIDE][3][iN];
			}

			if ((iNN >= 0) && (iNN < maxelm)) {
				// внутренний узел
				SpeedNN=potent[iVarCOR][iNN];
				//center_cord3D(iNN,nvtx,pa,pointP,NN_SIDE);
				pointP = center_coord_loc[iNN];
				positionyNN=pointP.y;
			}
			else
			{
				// граничный узел
				if ((iNN >= maxelm) && (iNN < maxelm + maxbound)) {
					SpeedNN = potent[iVarCOR][iNN];
				}
				else {
					SpeedNN = SpeedN;
				}
				//volume3D(iN, nvtx, pa, pointP.x, pointP.y, pointP.z);
				pointP = volume_loc[iN];

				positionyNN=positionyN+0.5*pointP.y;
			}
		}
		else {
			// это граничный узел
			SpeedN=potent[iVarCOR][iN];
			SpeedNN=potent[iVarCOR][iN]; 
			positionyn=positionyP+0.5*dy;
            positionyN=positionyP+0.5*dy;
			positionyNN=positionyP+dy; // этого узла не существует !
		}

		if ((!bS) && (iS > -1)) {
			SpeedS=potent[iVarCOR][iS];
			//center_cord3D(iS,nvtx,pa,pointP,S_SIDE);
			pointP = center_coord_loc[iS];
			positionyS=pointP.y;
			positionys=positionyP-0.5*dy;

			integer iSS=neighbors_for_the_internal_node[S_SIDE][0][iS];
			if (iSS < 0) {
				iSS = neighbors_for_the_internal_node[S_SIDE][1][iS];
			}
			if (iSS < 0) {
				iSS = neighbors_for_the_internal_node[S_SIDE][2][iS];
			}
			if (iSS < 0) {
				iSS = neighbors_for_the_internal_node[S_SIDE][3][iS];
			}

			if ((iSS >= 0) && (iSS < maxelm)) {
				// внутренний узел
				SpeedSS=potent[iVarCOR][iSS];
				//center_cord3D(iSS,nvtx,pa,pointP,SS_SIDE);
				pointP = center_coord_loc[iSS];
				positionySS=pointP.y;
			}
			else
			{
				// граничный узел
				if ((iSS >= maxelm) && (iSS < maxelm + maxbound)) {
					SpeedSS = potent[iVarCOR][iSS];
				}
				else {
					SpeedSS = SpeedS;
				}
				//volume3D(iS, nvtx, pa, pointP.x, pointP.y, pointP.z);
				pointP = volume_loc[iS];

				positionySS=positionyS-0.5*pointP.y;
			}
		}
		else {
			// это граничный узел
			SpeedS=potent[iVarCOR][iS]; // ATTANTION !!!!
			SpeedSS=potent[iVarCOR][iS]; // нулевая скорость внутри твёрдого тела.
			positionys=positionyP-0.5*dy;
            positionyS=positionyP-0.5*dy;
			positionySS=positionyP-dy; // этого узла не существует !
		}

		// Z - direction
		if ((!bT)&&(iT > -1)) {
			SpeedT=potent[iVarCOR][iT];
			//center_cord3D(iT,nvtx,pa,pointP,T_SIDE);
			pointP = center_coord_loc[iT];
			positionzT=pointP.z;
			positionzt=positionzP+0.5*dz;

			integer iTT=neighbors_for_the_internal_node[T_SIDE][0][iT];
			if (iTT < 0) {
				iTT = neighbors_for_the_internal_node[T_SIDE][1][iT];
			}
			if (iTT < 0) {
				iTT = neighbors_for_the_internal_node[T_SIDE][2][iT];
			}
			if (iTT < 0) {
				iTT = neighbors_for_the_internal_node[T_SIDE][3][iT];
			}

			if ((iTT >= 0) && (iTT < maxelm)) {
				// внутренний узел
				SpeedTT=potent[iVarCOR][iTT];
				//center_cord3D(iTT,nvtx,pa,pointP,TT_SIDE);
				pointP = center_coord_loc[iTT];
				positionzTT=pointP.z;
			}
			else
			{
				// граничный узел
				if ((iTT >= maxelm) && (iTT < maxelm + maxbound)) {

					SpeedTT = potent[iVarCOR][iTT];
				}
				else {
					SpeedTT = SpeedT;
				}
				//volume3D(iT, nvtx, pa, pointP.x, pointP.y, pointP.z);
				pointP = volume_loc[iT];

				positionzTT=positionzT+0.5*pointP.z;
			}
		}
		else {
			// это граничный узел
			SpeedT=potent[iVarCOR][iT];
			SpeedTT=potent[iVarCOR][iT]; // скорость внутри твёрдого тела
			positionzt=positionzP+0.5*dz;
            positionzT=positionzP+0.5*dz;
			positionzTT=positionzP+dz; // этого узла не существует !
		}

		if ((!bB)&& (iB > -1)) {
			SpeedB=potent[iVarCOR][iB];
			//center_cord3D(iB,nvtx,pa,pointP,B_SIDE);
			pointP = center_coord_loc[iB];
			positionzB=pointP.z;
			positionzb=positionzP-0.5*dz;

			integer iBB=neighbors_for_the_internal_node[B_SIDE][0][iB];
			if (iBB < 0) {
				iBB = neighbors_for_the_internal_node[B_SIDE][1][iB];
			}
			if (iBB < 0) {
				iBB = neighbors_for_the_internal_node[B_SIDE][2][iB];
			}
			if (iBB < 0) {
				iBB = neighbors_for_the_internal_node[B_SIDE][3][iB];
			}

			if ((iBB >= 0) && (iBB < maxelm)) {
				// внутренний узел
				SpeedBB=potent[iVarCOR][iBB];
				//center_cord3D(iBB,nvtx,pa,pointP,BB_SIDE);
				pointP = center_coord_loc[iBB];
				positionzBB=pointP.z;
			}
			else
			{
				// граничный узел
				if ((iBB >= maxelm) && (iBB < maxelm + maxbound)) {
					SpeedBB = potent[iVarCOR][iBB];
				}
				else {
					SpeedBB = SpeedB;
				}
				//volume3D(iB, nvtx, pa, pointP.x, pointP.y, pointP.z);
				pointP = volume_loc[iB];

				positionzBB=positionzB-0.5*pointP.z;
			}
		}
		else {
			// это граничный узел
			SpeedB=potent[iVarCOR][iB];
			SpeedBB=potent[iVarCOR][iB]; // скорость внутри твёрдого тела
			positionzb=positionzP-0.5*dz;
            positionzB=positionzP-0.5*dz;
			positionzBB=positionzP-dz; // этого узла не существует !
		}

		if (b_on_adaptive_local_refinement_mesh)
		{

			// X - direction
			if ((!bE2)&&(iE2 > -1)) {
				SpeedE2 = potent[iVarCOR][iE2];
				//center_cord3D(iE,nvtx,pa,pointP,E_SIDE);
				pointP = center_coord_loc[iE2];

				positionxE2 = pointP.x;
				positionxe2 = positionxP + 0.5 * dx;

				integer iEE2 = neighbors_for_the_internal_node[E_SIDE][0][iE2];
				if (iEE2 < 0) {
					iEE2 = neighbors_for_the_internal_node[E_SIDE][1][iE2];
				}
				if (iEE2 < 0) {
					iEE2 = neighbors_for_the_internal_node[E_SIDE][2][iE2];
				}
				if (iEE2 < 0) {
					iEE2 = neighbors_for_the_internal_node[E_SIDE][3][iE2];
				}
				if ((iEE2 >= 0) && (iEE2 < maxelm)) {
					// внутренний узел
					SpeedEE2 = potent[iVarCOR][iEE2];
					//center_cord3D(iEE2,nvtx,pa,pointP,EE_SIDE);
					pointP = center_coord_loc[iEE2];
					positionxEE2 = pointP.x;
				}
				else
				{
					// граничный узел
					if ((iEE2 >= maxelm) && (iEE2 < maxelm + maxbound)) {
					    SpeedEE2 = potent[iVarCOR][iEE2];
					}
					else {
						SpeedEE2 = SpeedE2;
						//std::cout << "iEE2 =" << iEE2 << " maxelm=" << maxelm << " maxbound=" << maxbound << std::endl;
						//getchar();
					}
					//volume3D(iE, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iE2];

					positionxEE2 = positionxE2 + 0.5 * pointP.x;
				}
			}
			else {
				// это граничный узел
				if (iE2 > -1) {
					SpeedE2 = potent[iVarCOR][iE2];
					SpeedEE2 = potent[iVarCOR][iE2];
				}
				else {
					SpeedE2 = potent[iVarCOR][iE];
					SpeedEE2 = potent[iVarCOR][iE];
				}
				positionxe2 = positionxP + 0.5 * dx;
				positionxE2 = positionxP + 0.5 * dx;
				positionxEE2 = positionxP + dx; // этого узла не существует !
			}

			if ((!bW2)&&((iW2 > -1))) {
				//center_cord3D(iW,nvtx,pa,pointP,W_SIDE);
				pointP = center_coord_loc[iW2];
				positionxW2 = pointP.x;
				positionxw2 = positionxP - 0.5 * dx;
				SpeedW2 = potent[iVarCOR][iW2];

				integer iWW2 = neighbors_for_the_internal_node[W_SIDE][0][iW2];
				if (iWW2 < 0) {
					iWW2 = neighbors_for_the_internal_node[W_SIDE][1][iW2];
				}
				if (iWW2 < 0) {
					iWW2 = neighbors_for_the_internal_node[W_SIDE][2][iW2];
				}
				if (iWW2 < 0) {
					iWW2 = neighbors_for_the_internal_node[W_SIDE][3][iW2];
				}

				if ((iWW2 >= 0) && (iWW2 < maxelm)) {
					// внутренний узел
					SpeedWW2 = potent[iVarCOR][iWW2];
					//center_cord3D(iWW2,nvtx,pa,pointP,WW_SIDE);
					pointP = center_coord_loc[iWW2];
					positionxWW2 = pointP.x;
				}
				else
				{
					// граничный узел
					if ((iWW2 >= maxelm) && (iWW2 < maxelm + maxbound)) {
						SpeedWW2 = potent[iVarCOR][iWW2];
					}
					else {

						SpeedWW2 = SpeedW2;
						//std::cout << "iWW2 =" << iWW2 << " maxelm=" << maxelm << " maxbound=" << maxbound << std::endl;
						//getchar();
					}
					//volume3D(iW2, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iW2];

					positionxWW2 = positionxW2 - 0.5 * pointP.x;
				}
			}
			else {
				// это граничный узел
				if (iW2 > -1) {
					SpeedW2 = potent[iVarCOR][iW2]; 
					SpeedWW2 = potent[iVarCOR][iW2];
				}
				else {
					SpeedW2 = potent[iVarCOR][iW]; 
					SpeedWW2 = potent[iVarCOR][iW];
				}
				//printf("SpeedW2==%e\n",SpeedW2); getchar();
				positionxw2 = positionxP - 0.5 * dx;
				positionxW2 = positionxP - 0.5 * dx;
				positionxWW2 = positionxP - dx; // этого узла не существует !
			}

			// Y - direction
			if ((!bN2)&&(iN2 > -1)) {
				SpeedN2 = potent[iVarCOR][iN2];
				//center_cord3D(iN2,nvtx,pa,pointP,N_SIDE);
				pointP = center_coord_loc[iN2];
				positionyN2 = pointP.y;
				positionyn2 = positionxP + 0.5 * dy;

				integer iNN2 = neighbors_for_the_internal_node[N_SIDE][0][iN2];
				if (iNN2 < 0) {
					iNN2 = neighbors_for_the_internal_node[N_SIDE][1][iN2];
				}
				if (iNN2 < 0) {
					iNN2 = neighbors_for_the_internal_node[N_SIDE][2][iN2];
				}
				if (iNN2 < 0) {
					iNN2 = neighbors_for_the_internal_node[N_SIDE][3][iN2];
				}


				if ((iNN2 >= 0) && (iNN2 < maxelm)) {
					// внутренний узел
					SpeedNN2 = potent[iVarCOR][iNN2];
					//center_cord3D(iNN2,nvtx,pa,pointP,NN_SIDE);
					pointP = center_coord_loc[iNN2];
					positionyNN2 = pointP.y;
				}
				else
				{
					// граничный узел
					if ((iNN2 >= maxelm) && (iNN2 < maxelm + maxbound)) {
						SpeedNN2 = potent[iVarCOR][iNN2];
					}
					else {
						SpeedNN2 = SpeedN2;
					}
					//volume3D(iN2, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iN2];

					positionyNN2 = positionyN2 + 0.5 * pointP.y;
				}
			}
			else {
				// это граничный узел
				if (iN2 > -1) {
					SpeedN2 = potent[iVarCOR][iN2];
					SpeedNN2 = potent[iVarCOR][iN2];
				}
				else {
					SpeedN2 = potent[iVarCOR][iN];
					SpeedNN2 = potent[iVarCOR][iN];
				}
				positionyn2 = positionyP + 0.5 * dy;
				positionyN2 = positionyP + 0.5 * dy;
				positionyNN2 = positionyP + dy; // этого узла не существует !
			}

			if ((!bS2)&&(iS2 > -1)) {
				SpeedS2 = potent[iVarCOR][iS2];
				//center_cord3D(iS2,nvtx,pa,pointP,S_SIDE);
				pointP = center_coord_loc[iS2];
				positionyS2 = pointP.y;
				positionys2 = positionyP - 0.5 * dy;

				integer iSS2 = neighbors_for_the_internal_node[S_SIDE][0][iS2];
				if (iSS2 < 0) {
					iSS2 = neighbors_for_the_internal_node[S_SIDE][1][iS2];
				}
				if (iSS2 < 0) {
					iSS2 = neighbors_for_the_internal_node[S_SIDE][2][iS2];
				}
				if (iSS2 < 0) {
					iSS2 = neighbors_for_the_internal_node[S_SIDE][3][iS2];
				}

				if ((iSS2 >= 0) && (iSS2 < maxelm)) {
					// внутренний узел
					SpeedSS2 = potent[iVarCOR][iSS2];
					//center_cord3D(iSS2,nvtx,pa,pointP,SS_SIDE);
					pointP = center_coord_loc[iSS2];
					positionySS2 = pointP.y;
				}
				else
				{
					// граничный узел
					if ((iSS2 >= maxelm) && (iSS2 < maxelm + maxbound)) {
						SpeedSS2 = potent[iVarCOR][iSS2];
					}
					else {
						SpeedSS2 = SpeedS2;
					}
					//volume3D(iS2, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iS2];

					positionySS2 = positionyS2 - 0.5 * pointP.y;
				}
			}
			else {
				// это граничный узел
				if (iS2 > -1) {
					SpeedS2 = potent[iVarCOR][iS2]; // ATTANTION !!!!
					SpeedSS2 = potent[iVarCOR][iS2]; // нулевая скорость внутри твёрдого тела.
				}
				else {
					SpeedS2 = potent[iVarCOR][iS]; // ATTANTION !!!!
					SpeedSS2 = potent[iVarCOR][iS]; // нулевая скорость внутри твёрдого тела.
				}
				positionys2 = positionyP - 0.5 * dy;
				positionyS2 = positionyP - 0.5 * dy;
				positionySS2 = positionyP - dy; // этого узла не существует !
			}

			// Z - direction
			if ((!bT2)&&(iT2 > -1)) {
				SpeedT2 = potent[iVarCOR][iT2];
				//center_cord3D(iT2,nvtx,pa,pointP,T_SIDE);
				pointP = center_coord_loc[iT2];
				positionzT2 = pointP.z;
				positionzt2 = positionzP + 0.5 * dz;

				integer iTT2 = neighbors_for_the_internal_node[T_SIDE][0][iT2];
				if (iTT2 < 0) {
					iTT2 = neighbors_for_the_internal_node[T_SIDE][1][iT2];
				}
				if (iTT2 < 0) {
					iTT2 = neighbors_for_the_internal_node[T_SIDE][2][iT2];
				}
				if (iTT2 < 0) {
					iTT2 = neighbors_for_the_internal_node[T_SIDE][3][iT2];
				}


				if ((iTT2 >= 0) && (iTT2 < maxelm)) {
					// внутренний узел
					SpeedTT2 = potent[iVarCOR][iTT2];
					//center_cord3D(iTT2,nvtx,pa,pointP,TT_SIDE);
					pointP = center_coord_loc[iTT2];
					positionzTT2 = pointP.z;
				}
				else
				{
					// граничный узел
					if ((iTT2 >= maxelm) && (iTT2 < maxelm + maxbound)) {
						SpeedTT2 = potent[iVarCOR][iTT2];
					}
					else {
						SpeedTT2 = SpeedT2;
					}
					//volume3D(iT2, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iT2];

					positionzTT2 = positionzT2 + 0.5 * pointP.z;
				}
			}
			else {
				// это граничный узел
				if (iT2 > -1) {
					SpeedT2 = potent[iVarCOR][iT2];
					SpeedTT2 = potent[iVarCOR][iT2]; // скорость внутри твёрдого тела
				}
				else {
					SpeedT2 = potent[iVarCOR][iT];
					SpeedTT2 = potent[iVarCOR][iT]; // скорость внутри твёрдого тела
				}
				positionzt2 = positionzP + 0.5 * dz;
				positionzT2 = positionzP + 0.5 * dz;
				positionzTT2 = positionzP + dz; // этого узла не существует !
			}

			if ((!bB2)&&(iB2 > -1)) {
				SpeedB2 = potent[iVarCOR][iB2];
				//center_cord3D(iB2,nvtx,pa,pointP,B_SIDE);
				pointP = center_coord_loc[iB2];
				positionzB2 = pointP.z;
				positionzb2 = positionzP - 0.5 * dz;

				integer iBB2 = neighbors_for_the_internal_node[B_SIDE][0][iB2];
				if (iBB2 < 0) {
					iBB2 = neighbors_for_the_internal_node[B_SIDE][1][iB2];
				}
				if (iBB2 < 0) {
					iBB2 = neighbors_for_the_internal_node[B_SIDE][2][iB2];
				}
				if (iBB2 < 0) {
					iBB2 = neighbors_for_the_internal_node[B_SIDE][3][iB2];
				}

				if ((iBB2 >= 0) && (iBB2 < maxelm)) {
					// внутренний узел
					SpeedBB2 = potent[iVarCOR][iBB2];
					//center_cord3D(iBB2,nvtx,pa,pointP,BB_SIDE);
					pointP = center_coord_loc[iBB2];
					positionzBB2 = pointP.z;
				}
				else
				{
					// граничный узел
					if ((iBB2 >= maxelm) && (iBB2 < maxelm + maxbound)) {
						SpeedBB2 = potent[iVarCOR][iBB2];
					}
					else {
						SpeedBB2 = SpeedB2;
					}
					//volume3D(iB2, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iB2];

					positionzBB2 = positionzB2 - 0.5 * pointP.z;
				}
			}
			else {
				// это граничный узел
				if (iB2 > -1) {
					SpeedB2 = potent[iVarCOR][iB2];
					SpeedBB2 = potent[iVarCOR][iB2]; // скорость внутри твёрдого тела
				}
				else {
					SpeedB2 = potent[iVarCOR][iB];
					SpeedBB2 = potent[iVarCOR][iB]; // скорость внутри твёрдого тела
				}
				positionzb2 = positionzP - 0.5 * dz;
				positionzB2 = positionzP - 0.5 * dz;
				positionzBB2 = positionzP - dz; // этого узла не существует !
			}


			// X - direction
			if ((!bE3)&&(iE3 > -1)) {
				SpeedE3 = potent[iVarCOR][iE3];
				//center_cord3D(iE3,nvtx,pa,pointP,E_SIDE);
				pointP = center_coord_loc[iE3];

				positionxE3 = pointP.x;
				positionxe3 = positionxP + 0.5 * dx;

				integer iEE3 = neighbors_for_the_internal_node[E_SIDE][0][iE3];
				if (iEE3 < 0) {
					iEE3 = neighbors_for_the_internal_node[E_SIDE][1][iE3];
				}
				if (iEE3 < 0) {
					iEE3 = neighbors_for_the_internal_node[E_SIDE][2][iE3];
				}
				if (iEE3 < 0) {
					iEE3 = neighbors_for_the_internal_node[E_SIDE][3][iE3];
				}

				if ((iEE3 >= 0) && (iEE3 < maxelm)) {
					// внутренний узел
					SpeedEE3 = potent[iVarCOR][iEE3];
					//center_cord3D(iEE3,nvtx,pa,pointP,EE_SIDE);
					pointP = center_coord_loc[iEE3];
					positionxEE3 = pointP.x;
				}
				else
				{
					// граничный узел
					if ((iEE3 >= maxelm) && (iEE3 < maxelm + maxbound)) {
						SpeedEE3 = potent[iVarCOR][iEE3];
					}
					else {
						SpeedEE3 = SpeedE3;
					}
					//volume3D(iE3, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iE3];

					positionxEE3 = positionxE3 + 0.5 * pointP.x;
				}
			}
			else {
				// это граничный узел
				if (iE3 > -1) {
					SpeedE3 = potent[iVarCOR][iE3];
					SpeedEE3 = potent[iVarCOR][iE3];
				}
				else {
					SpeedE3 = potent[iVarCOR][iE];
					SpeedEE3 = potent[iVarCOR][iE];
				}
				positionxe3 = positionxP + 0.5 * dx;
				positionxE3 = positionxP + 0.5 * dx;
				positionxEE3 = positionxP + dx; // этого узла не существует !
			}

			if ((!bW3)&&(iW3 > -1)) {
				//center_cord3D(iW3,nvtx,pa,pointP,W_SIDE);
				pointP = center_coord_loc[iW3];
				positionxW3 = pointP.x;
				positionxw3 = positionxP - 0.5 * dx;
				SpeedW3 = potent[iVarCOR][iW3];

				integer iWW3 = neighbors_for_the_internal_node[W_SIDE][0][iW3];
				if (iWW3 < 0) {
					iWW3 = neighbors_for_the_internal_node[W_SIDE][1][iW3];
				}
				if (iWW3 < 0) {
					iWW3 = neighbors_for_the_internal_node[W_SIDE][2][iW3];
				}
				if (iWW3 < 0) {
					iWW3 = neighbors_for_the_internal_node[W_SIDE][3][iW3];
				}

				if ((iWW3 >= 0) && (iWW3 < maxelm)) {
					// внутренний узел
					SpeedWW3 = potent[iVarCOR][iWW3];
					//center_cord3D(iWW3,nvtx,pa,pointP,WW_SIDE);
					pointP = center_coord_loc[iWW3];
					positionxWW3 = pointP.x;
				}
				else
				{
					// граничный узел
					if ((iWW3 >= maxelm) && (iWW3 < maxelm + maxbound)) {
					    SpeedWW3 = potent[iVarCOR][iWW3];
					}
					else {
						SpeedWW3 = SpeedW3;
						//std::cout << "iWW3 =" << iWW3 << " maxelm=" << maxelm << " maxbound=" << maxbound << std::endl;
						//getchar();
					}
					//volume3D(iW3, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iW3];

					positionxWW3 = positionxW3 - 0.5 * pointP.x;
				}
			}
			else {
				// это граничный узел
				if (iW3 > -1) {
					SpeedW3 = potent[iVarCOR][iW3]; // Attantion !! Debug
					SpeedWW3 = potent[iVarCOR][iW3];
				}
				else {
					SpeedW3 = potent[iVarCOR][iW]; // Attantion !! Debug
					SpeedWW3 = potent[iVarCOR][iW];
				}
				//printf("SpeedW3==%e\n",SpeedW3); getchar();
				positionxw3 = positionxP - 0.5 * dx;
				positionxW3 = positionxP - 0.5 * dx;
				positionxWW3 = positionxP - dx; // этого узла не существует !
			}

			// Y - direction
			if ((!bN3)&&(iN3 > -1)) {
				SpeedN3 = potent[iVarCOR][iN3];
				//center_cord3D(iN3,nvtx,pa,pointP,N_SIDE);
				pointP = center_coord_loc[iN3];
				positionyN3 = pointP.y;
				positionyn3 = positionxP + 0.5 * dy;

				integer iNN3 = neighbors_for_the_internal_node[N_SIDE][0][iN3];
				if (iNN3 < 0) {
					iNN3 = neighbors_for_the_internal_node[N_SIDE][1][iN3];
				}
				if (iNN3 < 0) {
					iNN3 = neighbors_for_the_internal_node[N_SIDE][2][iN3];
				}
				if (iNN3 < 0) {
					iNN3 = neighbors_for_the_internal_node[N_SIDE][3][iN3];
				}

				if ((iNN3 >= 0) && (iNN3 < maxelm)) {
					// внутренний узел
					SpeedNN3 = potent[iVarCOR][iNN3];
					//center_cord3D(iNN3,nvtx,pa,pointP,NN_SIDE);
					pointP = center_coord_loc[iNN3];
					positionyNN3 = pointP.y;
				}
				else
				{
					// граничный узел
					if ((iNN3 >= maxelm) && (iNN3 < maxelm + maxbound)) {
						SpeedNN3 = potent[iVarCOR][iNN3];
					}
					else {
						SpeedNN3 = SpeedN3;
					}
					//volume3D(iN3, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iN3];

					positionyNN3 = positionyN3 + 0.5 * pointP.y;
				}
			}
			else {
				// это граничный узел
				if (iN3 > -1) {
					SpeedN3 = potent[iVarCOR][iN3];
					SpeedNN3 = potent[iVarCOR][iN3];
				}
				else {
					SpeedN3 = potent[iVarCOR][iN];
					SpeedNN3 = potent[iVarCOR][iN];
				}
				positionyn3 = positionyP + 0.5 * dy;
				positionyN3 = positionyP + 0.5 * dy;
				positionyNN3 = positionyP + dy; // этого узла не существует !
			}

			if ((!bS3)&&(iS3 > -1)) {
				SpeedS3 = potent[iVarCOR][iS3];
				//center_cord3D(iS3,nvtx,pa,pointP,S_SIDE);
				pointP = center_coord_loc[iS3];
				positionyS3 = pointP.y;
				positionys3 = positionyP - 0.5 * dy;

				integer iSS3 = neighbors_for_the_internal_node[S_SIDE][0][iS3];
				if (iSS3 < 0) {
					iSS3 = neighbors_for_the_internal_node[S_SIDE][1][iS3];
				}
				if (iSS3 < 0) {
					iSS3 = neighbors_for_the_internal_node[S_SIDE][2][iS3];
				}
				if (iSS3 < 0) {
					iSS3 = neighbors_for_the_internal_node[S_SIDE][3][iS3];
				}

				if ((iSS3 >= 0) && (iSS3 < maxelm)) {
					// внутренний узел
					SpeedSS3 = potent[iVarCOR][iSS3];
					//center_cord3D(iSS3,nvtx,pa,pointP,SS_SIDE);
					pointP = center_coord_loc[iSS3];
					positionySS3 = pointP.y;
				}
				else
				{
					// граничный узел
					if ((iSS3 >= maxelm) && (iSS3 < maxelm + maxbound)) {
						SpeedSS3 = potent[iVarCOR][iSS3];
					}
					else {
						SpeedSS3 = SpeedS3;
					}
					//volume3D(iS3, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iS3];

					positionySS3 = positionyS3 - 0.5 * pointP.y;
				}
			}
			else {
				// это граничный узел
				if (iS3 > -1) {
					SpeedS3 = potent[iVarCOR][iS3]; // ATTANTION !!!!
					SpeedSS3 = potent[iVarCOR][iS3]; // нулевая скорость внутри твёрдого тела.
				}
				else {
					SpeedS3 = potent[iVarCOR][iS]; // ATTANTION !!!!
					SpeedSS3 = potent[iVarCOR][iS]; // нулевая скорость внутри твёрдого тела.
				}
				positionys3 = positionyP - 0.5 * dy;
				positionyS3 = positionyP - 0.5 * dy;
				positionySS3 = positionyP - dy; // этого узла не существует !
			}

			// Z - direction
			if ((!bT3)&&(iT3 > -1)) {
				SpeedT3 = potent[iVarCOR][iT3];
				//center_cord3D(iT3,nvtx,pa,pointP,T_SIDE);
				pointP = center_coord_loc[iT3];
				positionzT3 = pointP.z;
				positionzt3 = positionzP + 0.5 * dz;

				integer iTT3 = neighbors_for_the_internal_node[T_SIDE][0][iT3];
				if (iTT3 < 0) {
					iTT3 = neighbors_for_the_internal_node[T_SIDE][1][iT3];
				}
				if (iTT3 < 0) {
					iTT3 = neighbors_for_the_internal_node[T_SIDE][2][iT3];
				}
				if (iTT3 < 0) {
					iTT3 = neighbors_for_the_internal_node[T_SIDE][3][iT3];
				}

				if ((iTT3 >= 0) && (iTT3 < maxelm)) {
					// внутренний узел
					SpeedTT3 = potent[iVarCOR][iTT3];
					//center_cord3D(iTT3,nvtx,pa,pointP,TT_SIDE);
					pointP = center_coord_loc[iTT3];
					positionzTT3 = pointP.z;
				}
				else
				{
					// граничный узел
					if ((iTT3 >= maxelm) && (iTT3 < maxelm + maxbound)) {
						SpeedTT3 = potent[iVarCOR][iTT3];
					}
					else {
						SpeedTT3 = SpeedT3;
					}
					//volume3D(iT3, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iT3];

					positionzTT3 = positionzT3 + 0.5 * pointP.z;
				}
			}
			else {
				// это граничный узел
				if (iT3 > -1) {
					SpeedT3 = potent[iVarCOR][iT3];
					SpeedTT3 = potent[iVarCOR][iT3]; // скорость внутри твёрдого тела
				}
				else {
					SpeedT3 = potent[iVarCOR][iT];
					SpeedTT3 = potent[iVarCOR][iT]; // скорость внутри твёрдого тела
				}
				positionzt3 = positionzP + 0.5 * dz;
				positionzT3 = positionzP + 0.5 * dz;
				positionzTT3 = positionzP + dz; // этого узла не существует !
			}

			if ((!bB3)&&(iB3 > -1)) {
				SpeedB3 = potent[iVarCOR][iB3];
				//center_cord3D(iB3,nvtx,pa,pointP,B_SIDE);
				pointP = center_coord_loc[iB3];
				positionzB3 = pointP.z;
				positionzb3 = positionzP - 0.5 * dz;

				integer iBB3 = neighbors_for_the_internal_node[B_SIDE][0][iB3];
				if (iBB3 < 0) {
					iBB3 = neighbors_for_the_internal_node[B_SIDE][1][iB3];
				}
				if (iBB3 < 0) {
					iBB3 = neighbors_for_the_internal_node[B_SIDE][2][iB3];
				}
				if (iBB3 < 0) {
					iBB3 = neighbors_for_the_internal_node[B_SIDE][3][iB3];
				}

				if ((iBB3 >= 0) && (iBB3 < maxelm)) {
					// внутренний узел
					SpeedBB3 = potent[iVarCOR][iBB3];
					//center_cord3D(iBB3,nvtx,pa,pointP,BB_SIDE);
					pointP = center_coord_loc[iBB3];
					positionzBB3 = pointP.z;
				}
				else
				{
					// граничный узел
					if ((iBB3 >= maxelm) && (iBB3 < maxelm + maxbound)) {
						SpeedBB3 = potent[iVarCOR][iBB3];
					}
					else {
						SpeedBB3 = SpeedB3;
					}
					//volume3D(iB3, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iB3];

					positionzBB3 = positionzB3 - 0.5 * pointP.z;
				}
			}
			else {
				// это граничный узел
				if (iB3 > -1) {
					SpeedB3 = potent[iVarCOR][iB3];
					SpeedBB3 = potent[iVarCOR][iB3]; // скорость внутри твёрдого тела
				}
				else {
					SpeedB3 = potent[iVarCOR][iB];
					SpeedBB3 = potent[iVarCOR][iB]; // скорость внутри твёрдого тела
				}
				positionzb3 = positionzP - 0.5 * dz;
				positionzB3 = positionzP - 0.5 * dz;
				positionzBB3 = positionzP - dz; // этого узла не существует !
			}

			// X - direction
			if ((!bE4)&&(iE4 > -1)) {
				SpeedE4 = potent[iVarCOR][iE4];
				//center_cord3D(iE4,nvtx,pa,pointP,E_SIDE);
				pointP = center_coord_loc[iE4];

				positionxE4 = pointP.x;
				positionxe4 = positionxP + 0.5 * dx;

				integer iEE4 = neighbors_for_the_internal_node[E_SIDE][0][iE4];
				if (iEE4 < 0) {
					iEE4 = neighbors_for_the_internal_node[E_SIDE][1][iE4];
				}
				if (iEE4 < 0) {
					iEE4 = neighbors_for_the_internal_node[E_SIDE][2][iE4];
				}
				if (iEE4 < 0) {
					iEE4 = neighbors_for_the_internal_node[E_SIDE][3][iE4];
				}

				if ((iEE4 >= 0) && (iEE4 < maxelm)) {
					// внутренний узел
					SpeedEE4 = potent[iVarCOR][iEE4];
					//center_cord3D(iEE4,nvtx,pa,pointP,EE_SIDE);
					pointP = center_coord_loc[iEE4];
					positionxEE4 = pointP.x;
				}
				else
				{
					// граничный узел
					if ((iEE4 >= maxelm) && (iEE4 < maxelm + maxbound)) {
						SpeedEE4 = potent[iVarCOR][iEE4];
					}
					else {
						SpeedEE4 = SpeedE4;
					}
					//volume3D(iE4, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iE4];

					positionxEE4 = positionxE4 + 0.5 * pointP.x;
				}
			}
			else {
				// это граничный узел
				if (iE4 > -1) {
					SpeedE4 = potent[iVarCOR][iE4];
					SpeedEE4 = potent[iVarCOR][iE4];
				}
				else {
					SpeedE4 = potent[iVarCOR][iE];
					SpeedEE4 = potent[iVarCOR][iE];
				}
				positionxe4 = positionxP + 0.5 * dx;
				positionxE4 = positionxP + 0.5 * dx;
				positionxEE4 = positionxP + dx; // этого узла не существует !
			}

			if ((!bW4)&&(iW4 > -1)) {
				//center_cord3D(iW4,nvtx,pa,pointP,W_SIDE);
				pointP = center_coord_loc[iW4];
				positionxW4 = pointP.x;
				positionxw4 = positionxP - 0.5 * dx;
				SpeedW4 = potent[iVarCOR][iW4];

				integer iWW4 = neighbors_for_the_internal_node[W_SIDE][0][iW4];
				if (iWW4 < 0) {
					iWW4 = neighbors_for_the_internal_node[W_SIDE][1][iW4];
				}
				if (iWW4 < 0) {
					iWW4 = neighbors_for_the_internal_node[W_SIDE][2][iW4];
				}
				if (iWW4 < 0) {
					iWW4 = neighbors_for_the_internal_node[W_SIDE][3][iW4];
				}

				if ((iWW4 >= 0) && (iWW4 < maxelm)) {
					// внутренний узел
					SpeedWW4 = potent[iVarCOR][iWW4];
					//center_cord3D(iWW4,nvtx,pa,pointP,WW_SIDE);
					pointP = center_coord_loc[iWW4];
					positionxWW4 = pointP.x;
				}
				else
				{
					// граничный узел
					if ((iWW4 >= maxelm) && (iWW4 < maxelm + maxbound)) {
					    SpeedWW4 = potent[iVarCOR][iWW4];
					}
					else {
						SpeedWW4 = SpeedW4;
						//std::cout << "iWW4 =" << iWW4 << " maxelm=" << maxelm << " maxbound=" << maxbound << std::endl;
						//getchar();
					}
					//volume3D(iW4, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iW4];

					positionxWW4 = positionxW4 - 0.5 * pointP.x;
				}
			}
			else {
				// это граничный узел
				if (iW4 > -1) {
					SpeedW4 = potent[iVarCOR][iW4]; // Attantion !! Debug
					SpeedWW4 = potent[iVarCOR][iW4];
				}
				else {
					SpeedW4 = potent[iVarCOR][iW]; // Attantion !! Debug
					SpeedWW4 = potent[iVarCOR][iW];
				}
				//printf("SpeedW4==%e\n",SpeedW4); getchar();
				positionxw4 = positionxP - 0.5 * dx;
				positionxW4 = positionxP - 0.5 * dx;
				positionxWW4 = positionxP - dx; // этого узла не существует !
			}

			// Y - direction
			if ((!bN4)&&(iN4 > -1)) {
				SpeedN4 = potent[iVarCOR][iN4];
				//center_cord3D(iN4,nvtx,pa,pointP,N_SIDE);
				pointP = center_coord_loc[iN4];
				positionyN4 = pointP.y;
				positionyn4 = positionxP + 0.5 * dy;

				integer iNN4 = neighbors_for_the_internal_node[N_SIDE][0][iN4];
				if (iNN4 < 0) {
					iNN4 = neighbors_for_the_internal_node[N_SIDE][1][iN4];
				}
				if (iNN4 < 0) {
					iNN4 = neighbors_for_the_internal_node[N_SIDE][2][iN4];
				}
				if (iNN4 < 0) {
					iNN4 = neighbors_for_the_internal_node[N_SIDE][3][iN4];
				}

				if ((iNN4 >= 0) && (iNN4 < maxelm)) {
					// внутренний узел
					SpeedNN4 = potent[iVarCOR][iNN4];
					//center_cord3D(iNN4,nvtx,pa,pointP,NN_SIDE);
					pointP = center_coord_loc[iNN4];
					positionyNN4 = pointP.y;
				}
				else
				{
					// граничный узел
					if ((iNN4 >= maxelm) && (iNN4 < maxelm + maxbound)) {
						SpeedNN4 = potent[iVarCOR][iNN4];
					}
					else {
						SpeedNN4 = SpeedN4;
					}
					//volume3D(iN4, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iN4];

					positionyNN4 = positionyN4 + 0.5 * pointP.y;
				}
			}
			else {
				// это граничный узел
				if (iN4 > -1) {
					SpeedN4 = potent[iVarCOR][iN4];
					SpeedNN4 = potent[iVarCOR][iN4];
				}
				else {
					SpeedN4 = potent[iVarCOR][iN];
					SpeedNN4 = potent[iVarCOR][iN];
				}
				positionyn4 = positionyP + 0.5 * dy;
				positionyN4 = positionyP + 0.5 * dy;
				positionyNN4 = positionyP + dy; // этого узла не существует !
			}

			if ((!bS4)&&(iS4 > -1)) {
				SpeedS4 = potent[iVarCOR][iS4];
				//center_cord3D(iS4,nvtx,pa,pointP,S_SIDE);
				pointP = center_coord_loc[iS4];
				positionyS4 = pointP.y;
				positionys4 = positionyP - 0.5 * dy;

				integer iSS4 = neighbors_for_the_internal_node[S_SIDE][0][iS4];
				if (iSS4 < 0) {
					iSS4 = neighbors_for_the_internal_node[S_SIDE][1][iS4];
				}
				if (iSS4 < 0) {
					iSS4 = neighbors_for_the_internal_node[S_SIDE][2][iS4];
				}
				if (iSS4 < 0) {
					iSS4 = neighbors_for_the_internal_node[S_SIDE][3][iS4];
				}

				if ((iSS4 >= 0) && (iSS4 < maxelm)) {
					// внутренний узел
					SpeedSS4 = potent[iVarCOR][iSS4];
					//center_cord3D(iSS4,nvtx,pa,pointP,SS_SIDE);
					pointP = center_coord_loc[iSS4];
					positionySS4 = pointP.y;
				}
				else
				{
					// граничный узел
					if ((iSS4 >= maxelm) && (iSS4 < maxelm + maxbound)) {
						SpeedSS4 = potent[iVarCOR][iSS4];
					}
					else {
						SpeedSS4 = SpeedS4;
					}
					//volume3D(iS4, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iS4];

					positionySS4 = positionyS4 - 0.5 * pointP.y;
				}
			}
			else {
				// это граничный узел
				if (iS4 > -1) {
					SpeedS4 = potent[iVarCOR][iS4]; // ATTANTION !!!!
					SpeedSS4 = potent[iVarCOR][iS4]; // нулевая скорость внутри твёрдого тела.
				}
				else {
					SpeedS4 = potent[iVarCOR][iS]; // ATTANTION !!!!
					SpeedSS4 = potent[iVarCOR][iS]; // нулевая скорость внутри твёрдого тела.
				}
				positionys4 = positionyP - 0.5 * dy;
				positionyS4 = positionyP - 0.5 * dy;
				positionySS4 = positionyP - dy; // этого узла не существует !
			}

			// Z - direction
			if ((!bT4)&&(iT4 > -1)) {
				SpeedT4 = potent[iVarCOR][iT4];
				//center_cord3D(iT4,nvtx,pa,pointP,T_SIDE);
				pointP = center_coord_loc[iT4];
				positionzT4 = pointP.z;
				positionzt4 = positionzP + 0.5 * dz;

				integer iTT4 = neighbors_for_the_internal_node[T_SIDE][0][iT4];
				if (iTT4 < 0) {
					iTT4 = neighbors_for_the_internal_node[T_SIDE][1][iT4];
				}
				if (iTT4 < 0) {
					iTT4 = neighbors_for_the_internal_node[T_SIDE][2][iT4];
				}
				if (iTT4 < 0) {
					iTT4 = neighbors_for_the_internal_node[T_SIDE][3][iT4];
				}

				if ((iTT4 >= 0) && (iTT4 < maxelm)) {
					// внутренний узел
					SpeedTT4 = potent[iVarCOR][iTT4];
					//center_cord3D(iTT4,nvtx,pa,pointP,TT_SIDE);
					pointP = center_coord_loc[iTT4];
					positionzTT4 = pointP.z;
				}
				else
				{
					// граничный узел
					if ((iTT4 >= maxelm) && (iTT4 < maxelm + maxbound)) {
						SpeedTT4 = potent[iVarCOR][iTT4];
					}
					else {
						SpeedTT4 = SpeedT4;
					}
					//volume3D(iT4, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iT4];

					positionzTT4 = positionzT4 + 0.5 * pointP.z;
				}
			}
			else {
				// это граничный узел
				if (iT4 > -1) {
					SpeedT4 = potent[iVarCOR][iT4];
					SpeedTT4 = potent[iVarCOR][iT4]; // скорость внутри твёрдого тела
				}
				else {
					SpeedT4 = potent[iVarCOR][iT];
					SpeedTT4 = potent[iVarCOR][iT]; // скорость внутри твёрдого тела
				}
				positionzt4 = positionzP + 0.5 * dz;
				positionzT4 = positionzP + 0.5 * dz;
				positionzTT4 = positionzP + dz; // этого узла не существует !
			}

			if ((!bB4)&&(iB4 > -1)) {
				SpeedB4 = potent[iVarCOR][iB4];
				//center_cord3D(iB4,nvtx,pa,pointP,B_SIDE);
				pointP = center_coord_loc[iB4];
				positionzB4 = pointP.z;
				positionzb4 = positionzP - 0.5 * dz;

				integer iBB4 = neighbors_for_the_internal_node[B_SIDE][0][iB4];
				if (iBB4 < 0) {
					iBB4 = neighbors_for_the_internal_node[B_SIDE][1][iB4];
				}
				if (iBB4 < 0) {
					iBB4 = neighbors_for_the_internal_node[B_SIDE][2][iB4];
				}
				if (iBB4 < 0) {
					iBB4 = neighbors_for_the_internal_node[B_SIDE][3][iB4];
				}

				if ((iBB4 >= 0) && (iBB4 < maxelm)) {
					// внутренний узел
					SpeedBB4 = potent[iVarCOR][iBB4];
					//center_cord3D(iBB4,nvtx,pa,pointP,BB_SIDE);
					pointP = center_coord_loc[iBB4];
					positionzBB4 = pointP.z;
				}
				else
				{
					// граничный узел
					if ((iBB4 >= maxelm) && (iBB4 < maxelm + maxbound)) {
						SpeedBB4 = potent[iVarCOR][iBB4];
					}
					else {
						SpeedBB4 = SpeedB4;
					}
					//volume3D(iB4, nvtx, pa, pointP.x, pointP.y, pointP.z);
					pointP = volume_loc[iB4];

					positionzBB4 = positionzB4 - 0.5 * pointP.z;
				}
			}
			else {
				// это граничный узел
				if (iB4 > -1) {
					SpeedB4 = potent[iVarCOR][iB4];
					SpeedBB4 = potent[iVarCOR][iB4]; // скорость внутри твёрдого тела
				}
				else {
					SpeedB4 = potent[iVarCOR][iB];
					SpeedBB4 = potent[iVarCOR][iB]; // скорость внутри твёрдого тела
				}
				positionzb4 = positionzP - 0.5 * dz;
				positionzB4 = positionzP - 0.5 * dz;
				positionzBB4 = positionzP - dz; // этого узла не существует !
			}

		}


		if ((ishconvection >= QUICK) && (ishconvection <= FROMM)) {
             // данные схемы заимствованы из программы Б. Сполдинга PHOENICS.
			// идентификатор ishconvection должен принимать значения от схемы QUICK (включительно) и строго до схемы UNEVENQUICK (не включая последнюю).

		     // X - direction
		     Speede=cell_face_value_global(ishconvection, (Fe), SpeedW, SpeedP, SpeedE, SpeedEE); 
		     Speedw=cell_face_value_global(ishconvection, (Fw), SpeedWW, SpeedW, SpeedP, SpeedE); 
		     // Y - direction
		     Speedn=cell_face_value_global(ishconvection, (Fn), SpeedS, SpeedP, SpeedN, SpeedNN); 
		     Speeds=cell_face_value_global(ishconvection, (Fs), SpeedSS, SpeedS, SpeedP, SpeedN); 
		     // Z - direction
		     Speedt=cell_face_value_global(ishconvection, (Ft), SpeedB, SpeedP, SpeedT, SpeedTT); 
		     Speedb=cell_face_value_global(ishconvection, (Fb), SpeedBB, SpeedB, SpeedP, SpeedT); 

			 if (b_on_adaptive_local_refinement_mesh) {

				 // X - direction
				 Speede2 = cell_face_value_global(ishconvection, (Fe2), SpeedW2, SpeedP, SpeedE2, SpeedEE2);
				 Speedw2 = cell_face_value_global(ishconvection, (Fw2), SpeedWW2, SpeedW2, SpeedP, SpeedE2);
				 // Y - direction
				 Speedn2 = cell_face_value_global(ishconvection, (Fn2), SpeedS2, SpeedP, SpeedN2, SpeedNN2);
				 Speeds2 = cell_face_value_global(ishconvection, (Fs2), SpeedSS2, SpeedS2, SpeedP, SpeedN2);
				 // Z - direction
				 Speedt2 = cell_face_value_global(ishconvection, (Ft2), SpeedB2, SpeedP, SpeedT2, SpeedTT2);
				 Speedb2 = cell_face_value_global(ishconvection, (Fb2), SpeedBB2, SpeedB2, SpeedP, SpeedT2);


				 // X - direction
				 Speede3 = cell_face_value_global(ishconvection, (Fe3), SpeedW3, SpeedP, SpeedE3, SpeedEE3);
				 Speedw3 = cell_face_value_global(ishconvection, (Fw3), SpeedWW3, SpeedW3, SpeedP, SpeedE3);
				 // Y - direction
				 Speedn3 = cell_face_value_global(ishconvection, (Fn3), SpeedS3, SpeedP, SpeedN3, SpeedNN3);
				 Speeds3 = cell_face_value_global(ishconvection, (Fs3), SpeedSS3, SpeedS3, SpeedP, SpeedN3);
				 // Z - direction
				 Speedt3 = cell_face_value_global(ishconvection, (Ft3), SpeedB3, SpeedP, SpeedT3, SpeedTT3);
				 Speedb3 = cell_face_value_global(ishconvection, (Fb3), SpeedBB3, SpeedB3, SpeedP, SpeedT3);


				 // X - direction
				 Speede4 = cell_face_value_global(ishconvection, (Fe4), SpeedW4, SpeedP, SpeedE4, SpeedEE4);
				 Speedw4 = cell_face_value_global(ishconvection, (Fw4), SpeedWW4, SpeedW4, SpeedP, SpeedE4);
				 // Y - direction
				 Speedn4 = cell_face_value_global(ishconvection, (Fn4), SpeedS4, SpeedP, SpeedN4, SpeedNN4);
				 Speeds4 = cell_face_value_global(ishconvection, (Fs4), SpeedSS4, SpeedS4, SpeedP, SpeedN4);
				 // Z - direction
				 Speedt4 = cell_face_value_global(ishconvection, (Ft4), SpeedB4, SpeedP, SpeedT4, SpeedTT4);
				 Speedb4 = cell_face_value_global(ishconvection, (Fb4), SpeedBB4, SpeedB4, SpeedP, SpeedT4);

			 }
		     
		}

		if (ishconvection >= UNEVENQUICK) {
		

           /*
		   // закомментированный фрагмент относится к одной устаревшей реализации схемы QUICK на неравномерной сетке.
		   // Реализация была заимствована из статьи: ...
		   // В данный момент данная реализация не используется.
		   //doublereal gamma1E, gamma2E, gamma1W, gamma2W, delta1E, delta2E, delta1W, delta2W;
		   //doublereal gamma1N, gamma2N, gamma1S, gamma2S, delta1N, delta2N, delta1S, delta2S;
		   //doublereal gamma1T, gamma2T, gamma1B, gamma2B, delta1T, delta2T, delta1B, delta2B;
		   // X - direction
		   // gamma
		   //gamma1E=((positionxe-positionxE)*(positionxe-positionxP))/((positionxW-positionxE)*(positionxW-positionxP));
		   //gamma2E=((positionxe-positionxP)*(positionxe-positionxW))/((positionxE-positionxP)*(positionxE-positionxW));
		   //gamma1W=((positionxw-positionxP)*(positionxw-positionxW))/((positionxWW-positionxP)*(positionxWW-positionxW));
		   //gamma2W=((positionxw-positionxW)*(positionxw-positionxWW))/((positionxP-positionxW)*(positionxP-positionxWW));
		   // delta
		   //delta1E=((positionxe-positionxEE)*(positionxe-positionxE))/((positionxP-positionxEE)*(positionxP-positionxE));
		   //delta2E=((positionxe-positionxE)*(positionxe-positionxP))/((positionxEE-positionxE)*(positionxEE-positionxP));
		   //delta1W=((positionxw-positionxE)*(positionxw-positionxP))/((positionxW-positionxE)*(positionxW-positionxP));
		   //delta2W=((positionxw-positionxP)*(positionxw-positionxW))/((positionxE-positionxP)*(positionxE-positionxW));
		   // Y - direction
		   // gamma
		   //gamma1N=((positionyn-positionyN)*(positionyn-positionyP))/((positionyS-positionyN)*(positionyS-positionyP));
		   //gamma2N=((positionyn-positionyP)*(positionyn-positionyS))/((positionyN-positionyP)*(positionyN-positionyS));
		   //gamma1S=((positionys-positionyP)*(positionys-positionyS))/((positionySS-positionyP)*(positionySS-positionyS));
		   //gamma2S=((positionys-positionyS)*(positionys-positionySS))/((positionyP-positionyS)*(positionyP-positionySS));
		   // delta
		   //delta1N=((positionyn-positionyNN)*(positionyn-positionyN))/((positionyP-positionyNN)*(positionyP-positionyN));
		   //delta2N=((positionyn-positionyN)*(positionyn-positionyP))/((positionyNN-positionyN)*(positionyNN-positionyP));
		   //delta1S=((positionys-positionyN)*(positionys-positionyP))/((positionyS-positionyN)*(positionyS-positionyP));
		   //delta2S=((positionys-positionyP)*(positionys-positionyS))/((positionyN-positionyP)*(positionyN-positionyS));
		   // Z - direction
		   // gamma
		   //gamma1T=((positionzt-positionzT)*(positionzt-positionzP))/((positionzB-positionzT)*(positionzB-positionzP));
		   //gamma2T=((positionzt-positionzP)*(positionzt-positionzB))/((positionzT-positionzP)*(positionzT-positionzB));
		   //gamma1B=((positionzb-positionzP)*(positionzb-positionzB))/((positionzBB-positionzP)*(positionzBB-positionzB));
		   //gamma2B=((positionzb-positionzB)*(positionzb-positionzBB))/((positionzP-positionzB)*(positionzP-positionzBB));
		   // delta
		   //delta1T=((positionzt-positionzTT)*(positionzt-positionzT))/((positionzP-positionzTT)*(positionzP-positionzT));
		   //delta2T=((positionzt-positionzT)*(positionzt-positionzP))/((positionzTT-positionzT)*(positionzTT-positionzP));
		   //delta1B=((positionzb-positionzT)*(positionzb-positionzP))/((positionzB-positionzT)*(positionzB-positionzP));
		   //delta2B=((positionzb-positionzP)*(positionzb-positionzB))/((positionzT-positionzP)*(positionzT-positionzB));	
		   */
		

		

		   // Вычисление искомой величины на грани КО
		   // используется схема Леонарда QUICK.
		   /* таблица соответствия:
	        *  A	B	C	D	e	+/-
            *  W	P	E	-	e	+
	        *  -	P	E	EE  e   -
	        *  WW   W	P	-	w	+
	        *  -	W	P	E	w	-
	        *  S	P	N	-	n	+
	        *  -	P	N	NN  n	-
	        *  SS   S	P	-	s	+
	        *  -	S	P	N	s	-
	        *  B	P	T	-	t	+
	        *  -	P	T	TT  t	-
	        *  BB   B	P	-	b	+
	        *  -	B	P	T	b	-
	        */
		
			if (ishconvection == UNEVENQUICK) {
				// X - direction
		        Speede=workQUICK(dx, 2.0*(positionxE-positionxe), positionxW, positionxP, positionxE, positionxEE, SpeedW, SpeedP, SpeedE, SpeedEE, (Fe)); 
		        Speedw=workQUICK(2.0*(positionxw-positionxW), dx, positionxWW, positionxW, positionxP, positionxE, SpeedWW, SpeedW, SpeedP, SpeedE, (Fw)); 
		        // Y - direction
		        Speedn=workQUICK(dy, 2.0*(positionyN-positionyn), positionyS, positionyP, positionyN, positionyNN, SpeedS, SpeedP, SpeedN, SpeedNN, (Fn)); 
		        Speeds=workQUICK(2.0*(positionys-positionyS), dy, positionySS, positionyS, positionyP, positionyN, SpeedSS, SpeedS, SpeedP, SpeedN, (Fs)); 
		        // Z - direction
		        Speedt=workQUICK(dz, 2.0*(positionzT-positionzt), positionzB, positionzP, positionzT, positionzTT, SpeedB, SpeedP, SpeedT, SpeedTT, (Ft)); 
		        Speedb=workQUICK(2.0*(positionzb-positionzB), dz, positionzBB, positionzB, positionzP, positionzT, SpeedBB, SpeedB, SpeedP, SpeedT, (Fb)); 


				if (b_on_adaptive_local_refinement_mesh) {

					// X - direction
					Speede2 = workQUICK(dx, 2.0 * (positionxE2 - positionxe2), positionxW2, positionxP, positionxE2, positionxEE2, SpeedW2, SpeedP, SpeedE2, SpeedEE2, (Fe2));
					Speedw2 = workQUICK(2.0 * (positionxw2 - positionxW2), dx, positionxWW2, positionxW2, positionxP, positionxE2, SpeedWW2, SpeedW2, SpeedP, SpeedE2, (Fw2));
					// Y - direction
					Speedn2 = workQUICK(dy, 2.0 * (positionyN2 - positionyn2), positionyS2, positionyP, positionyN2, positionyNN2, SpeedS2, SpeedP, SpeedN2, SpeedNN2, (Fn2));
					Speeds2 = workQUICK(2.0 * (positionys2 - positionyS2), dy, positionySS2, positionyS2, positionyP, positionyN2, SpeedSS2, SpeedS2, SpeedP, SpeedN2, (Fs2));
					// Z - direction
					Speedt2 = workQUICK(dz, 2.0 * (positionzT2 - positionzt2), positionzB2, positionzP, positionzT2, positionzTT2, SpeedB2, SpeedP, SpeedT2, SpeedTT2, (Ft2));
					Speedb2 = workQUICK(2.0 * (positionzb2 - positionzB2), dz, positionzBB2, positionzB2, positionzP, positionzT2, SpeedBB2, SpeedB2, SpeedP, SpeedT2, (Fb2));


					// X - direction
					Speede3 = workQUICK(dx, 2.0 * (positionxE3 - positionxe3), positionxW3, positionxP, positionxE3, positionxEE3, SpeedW3, SpeedP, SpeedE3, SpeedEE3, (Fe3));
					Speedw3 = workQUICK(2.0 * (positionxw3 - positionxW3), dx, positionxWW3, positionxW3, positionxP, positionxE3, SpeedWW3, SpeedW3, SpeedP, SpeedE3, (Fw3));
					// Y - direction
					Speedn3 = workQUICK(dy, 2.0 * (positionyN3 - positionyn3), positionyS3, positionyP, positionyN3, positionyNN3, SpeedS3, SpeedP, SpeedN3, SpeedNN3, (Fn3));
					Speeds3 = workQUICK(2.0 * (positionys3 - positionyS3), dy, positionySS3, positionyS3, positionyP, positionyN3, SpeedSS3, SpeedS3, SpeedP, SpeedN3, (Fs3));
					// Z - direction
					Speedt3 = workQUICK(dz, 2.0 * (positionzT3 - positionzt3), positionzB3, positionzP, positionzT3, positionzTT3, SpeedB3, SpeedP, SpeedT3, SpeedTT3, (Ft3));
					Speedb3 = workQUICK(2.0 * (positionzb3 - positionzB3), dz, positionzBB3, positionzB3, positionzP, positionzT3, SpeedBB3, SpeedB3, SpeedP, SpeedT3, (Fb3));


					// X - direction
					Speede4 = workQUICK(dx, 2.0 * (positionxE4 - positionxe4), positionxW4, positionxP, positionxE4, positionxEE4, SpeedW4, SpeedP, SpeedE4, SpeedEE4, (Fe4));
					Speedw4 = workQUICK(2.0 * (positionxw4 - positionxW4), dx, positionxWW4, positionxW4, positionxP, positionxE4, SpeedWW4, SpeedW4, SpeedP, SpeedE4, (Fw4));
					// Y - direction
					Speedn4 = workQUICK(dy, 2.0 * (positionyN4 - positionyn4), positionyS4, positionyP, positionyN4, positionyNN4, SpeedS4, SpeedP, SpeedN4, SpeedNN4, (Fn4));
					Speeds4 = workQUICK(2.0 * (positionys4 - positionyS4), dy, positionySS4, positionyS4, positionyP, positionyN4, SpeedSS4, SpeedS4, SpeedP, SpeedN4, (Fs4));
					// Z - direction
					Speedt4 = workQUICK(dz, 2.0 * (positionzT4 - positionzt4), positionzB4, positionzP, positionzT4, positionzTT4, SpeedB4, SpeedP, SpeedT4, SpeedTT4, (Ft4));
					Speedb4 = workQUICK(2.0 * (positionzb4 - positionzB4), dz, positionzBB4, positionzB4, positionzP, positionzT4, SpeedBB4, SpeedB4, SpeedP, SpeedT4, (Fb4));

				}
			}

			if ((ishconvection > UNEVENQUICK) && (ishconvection <= UNEVEN_CUBISTA )) {
				// Пока на данный момент рекомендуется попробовать использовать только первые четыре схемы:
				// 1. UNEVEN_MUSCL, 2. UNEVEN_SOUCUP, 3. UNEVEN_HLPA, 4. UNEVEN_SMART.
				// перечисленные схемы прошли предварительную проверку.

				// X - direction
		        Speede=workKN_VOLKOV( positionxW, positionxP, positionxE, positionxEE, SpeedW, SpeedP, SpeedE, SpeedEE, (Fe), ishconvection); 
		        Speedw=workKN_VOLKOV( positionxWW, positionxW, positionxP, positionxE, SpeedWW, SpeedW, SpeedP, SpeedE, (Fw), ishconvection); 
		        // Y - direction
		        Speedn=workKN_VOLKOV( positionyS, positionyP, positionyN, positionyNN, SpeedS, SpeedP, SpeedN, SpeedNN, (Fn), ishconvection); 
		        Speeds=workKN_VOLKOV( positionySS, positionyS, positionyP, positionyN, SpeedSS, SpeedS, SpeedP, SpeedN, (Fs), ishconvection); 
		        // Z - direction
		        Speedt=workKN_VOLKOV( positionzB, positionzP, positionzT, positionzTT, SpeedB, SpeedP, SpeedT, SpeedTT, (Ft), ishconvection); 
		        Speedb=workKN_VOLKOV( positionzBB, positionzB, positionzP, positionzT, SpeedBB, SpeedB, SpeedP, SpeedT, (Fb), ishconvection); 

				// debug первая итерация особая.
				//printf("%f, %f, %f, %f, %f, %f\n",Speede,Speedw,Speedn,Speeds,Speedt,Speedb);
				//getchar();

				if (b_on_adaptive_local_refinement_mesh) {

					// X - direction
					Speede2 = workKN_VOLKOV(positionxW2, positionxP, positionxE2, positionxEE2, SpeedW2, SpeedP, SpeedE2, SpeedEE2, (Fe2), ishconvection);
					Speedw2 = workKN_VOLKOV(positionxWW2, positionxW2, positionxP, positionxE2, SpeedWW2, SpeedW2, SpeedP, SpeedE2, (Fw2), ishconvection);
					// Y - direction
					Speedn2 = workKN_VOLKOV(positionyS2, positionyP, positionyN2, positionyNN2, SpeedS2, SpeedP, SpeedN2, SpeedNN2, (Fn2), ishconvection);
					Speeds2 = workKN_VOLKOV(positionySS2, positionyS2, positionyP, positionyN2, SpeedSS2, SpeedS2, SpeedP, SpeedN2, (Fs2), ishconvection);
					// Z - direction
					Speedt2 = workKN_VOLKOV(positionzB2, positionzP, positionzT2, positionzTT2, SpeedB2, SpeedP, SpeedT2, SpeedTT2, (Ft2), ishconvection);
					Speedb2 = workKN_VOLKOV(positionzBB2, positionzB2, positionzP, positionzT2, SpeedBB2, SpeedB2, SpeedP, SpeedT2, (Fb2), ishconvection);


					// X - direction
					Speede3 = workKN_VOLKOV(positionxW3, positionxP, positionxE3, positionxEE3, SpeedW3, SpeedP, SpeedE3, SpeedEE3, (Fe3), ishconvection);
					Speedw3 = workKN_VOLKOV(positionxWW3, positionxW3, positionxP, positionxE3, SpeedWW3, SpeedW3, SpeedP, SpeedE3, (Fw3), ishconvection);
					// Y - direction
					Speedn3 = workKN_VOLKOV(positionyS3, positionyP, positionyN3, positionyNN3, SpeedS3, SpeedP, SpeedN3, SpeedNN3, (Fn3), ishconvection);
					Speeds3 = workKN_VOLKOV(positionySS3, positionyS3, positionyP, positionyN3, SpeedSS3, SpeedS3, SpeedP, SpeedN3, (Fs3), ishconvection);
					// Z - direction
					Speedt3 = workKN_VOLKOV(positionzB3, positionzP, positionzT3, positionzTT3, SpeedB3, SpeedP, SpeedT3, SpeedTT3, (Ft3), ishconvection);
					Speedb3 = workKN_VOLKOV(positionzBB3, positionzB3, positionzP, positionzT3, SpeedBB3, SpeedB3, SpeedP, SpeedT3, (Fb3), ishconvection);


					// X - direction
					Speede4 = workKN_VOLKOV(positionxW4, positionxP, positionxE4, positionxEE4, SpeedW4, SpeedP, SpeedE4, SpeedEE4, (Fe4), ishconvection);
					Speedw4 = workKN_VOLKOV(positionxWW4, positionxW4, positionxP, positionxE4, SpeedWW4, SpeedW4, SpeedP, SpeedE4, (Fw4), ishconvection);
					// Y - direction
					Speedn4 = workKN_VOLKOV(positionyS4, positionyP, positionyN4, positionyNN4, SpeedS4, SpeedP, SpeedN4, SpeedNN4, (Fn4), ishconvection);
					Speeds4 = workKN_VOLKOV(positionySS4, positionyS4, positionyP, positionyN4, SpeedSS4, SpeedS4, SpeedP, SpeedN4, (Fs4), ishconvection);
					// Z - direction
					Speedt4 = workKN_VOLKOV(positionzB4, positionzP, positionzT4, positionzTT4, SpeedB4, SpeedP, SpeedT4, SpeedTT4, (Ft4), ishconvection);
					Speedb4 = workKN_VOLKOV(positionzBB4, positionzB4, positionzP, positionzT4, SpeedBB4, SpeedB4, SpeedP, SpeedT4, (Fb4), ishconvection);

				}

			}
		
		} // endif (ishconvection >= UNEVENQUICK)
		
		

		// Ссылка: SIMPLE method for the solution of incompressible flows on non-staggered grids
		// I. Sezai - Eastern Mediterranean University, Mechanical Engineering Department, Mersin 10-Turkey Revised in January, 2011.

		// Вычисление коэффициентов дискретного аналога:
		// Реализуется метод отложенной коррекции:
		// неявно реализуется только противопоточная часть, 
		// а уточняющие члены записываются в правую часть 
		// линейной системы уравнений.
		if (1) {

           /*
	       sl[iVar][iP].ae=De*fD(Pe, EXP2, true, feplus) + fmax(-(Fe),0.0); 
           sl[iVar][iP].aw=Dw*fD(Pw, EXP2, true, fwplus) + fmax((Fw),0.0); 
	       sl[iVar][iP].an=Dn*fD(Pn, EXP2, true, fnplus) + fmax(-(Fn),0.0); 
		   sl[iVar][iP].as=Ds*fD(Ps, EXP2, true, fsplus) + fmax((Fs),0.0); 
           sl[iVar][iP].at=Dt*fD(Pt, EXP2, true, ftplus) + fmax(-(Ft),0.0); 
		   sl[iVar][iP].ab=Db*fD(Pb, EXP2, true, fbplus) + fmax((Fb),0.0);
		   */

			// Оставил как единственно верное и рекомендуемое в литературе 7.05.2017.
			// Нужно просто UDS.
			// так рекомендуют в интернетах.
		   sl[iVar][iP].ae=De * ApproxConvective(fabs(Pe), iprefix_Scheme) + fmax(-(Fe),0.0);
           sl[iVar][iP].aw=Dw * ApproxConvective(fabs(Pw), iprefix_Scheme) + fmax((Fw),0.0);
	       sl[iVar][iP].an=Dn * ApproxConvective(fabs(Pn), iprefix_Scheme) + fmax(-(Fn),0.0);
		   sl[iVar][iP].as=Ds * ApproxConvective(fabs(Ps), iprefix_Scheme) + fmax((Fs),0.0);
           sl[iVar][iP].at=Dt * ApproxConvective(fabs(Pt), iprefix_Scheme) + fmax(-(Ft),0.0);
		   sl[iVar][iP].ab=Db * ApproxConvective(fabs(Pb), iprefix_Scheme) + fmax((Fb),0.0);


		   // 08.05.2017.
		   // Моя наработка:
		   // ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).
		   sl[iVar][iP].ap = De * ApproxConvective(fabs(Pe), iprefix_Scheme) + fmax(+(sign_flux * Fe), 0.0);
		   sl[iVar][iP].ap += Dw * ApproxConvective(fabs(Pw), iprefix_Scheme) + fmax(-(sign_flux * Fw), 0.0);
		   sl[iVar][iP].ap += Dn * ApproxConvective(fabs(Pn), iprefix_Scheme) + fmax(+(sign_flux * Fn), 0.0);
		   sl[iVar][iP].ap += Ds * ApproxConvective(fabs(Ps), iprefix_Scheme) + fmax(-(sign_flux * Fs), 0.0);
		   sl[iVar][iP].ap += Dt * ApproxConvective(fabs(Pt), iprefix_Scheme) + fmax(+(sign_flux * Ft), 0.0);
		   sl[iVar][iP].ap += Db * ApproxConvective(fabs(Pb), iprefix_Scheme) + fmax(-(sign_flux * Fb), 0.0);


		   sumanb = De * ApproxConvective(fabs(Pe), iprefix_Scheme) + fmax(+(sign_flux * Fe), 0.0);
		   sumanb += Dw * ApproxConvective(fabs(Pw), iprefix_Scheme) + fmax(-(sign_flux * Fw), 0.0);
		   sumanb += Dn * ApproxConvective(fabs(Pn), iprefix_Scheme) + fmax(+(sign_flux * Fn), 0.0);
		   sumanb += Ds * ApproxConvective(fabs(Ps), iprefix_Scheme) + fmax(-(sign_flux * Fs), 0.0);
		   sumanb += Dt * ApproxConvective(fabs(Pt), iprefix_Scheme) + fmax(+(sign_flux * Ft), 0.0);
		   sumanb += Db * ApproxConvective(fabs(Pb), iprefix_Scheme) + fmax(-(sign_flux * Fb), 0.0);

		   if (b_on_adaptive_local_refinement_mesh) {

			   // Оставил как единственно верное и рекомендуемое в литературе 7.05.2017.
			// Нужно просто UDS.
			// так рекомендуют в интернетах.
			   sl[iVar][iP].ae2 = De2 * ApproxConvective(fabs(Pe2), iprefix_Scheme) + fmax(-(Fe2), 0.0);
			   sl[iVar][iP].aw2 = Dw2 * ApproxConvective(fabs(Pw2), iprefix_Scheme) + fmax((Fw2), 0.0);
			   sl[iVar][iP].an2 = Dn2 * ApproxConvective(fabs(Pn2), iprefix_Scheme) + fmax(-(Fn2), 0.0);
			   sl[iVar][iP].as2 = Ds2 * ApproxConvective(fabs(Ps2), iprefix_Scheme) + fmax((Fs2), 0.0);
			   sl[iVar][iP].at2 = Dt2 * ApproxConvective(fabs(Pt2), iprefix_Scheme) + fmax(-(Ft2), 0.0);
			   sl[iVar][iP].ab2 = Db2 * ApproxConvective(fabs(Pb2), iprefix_Scheme) + fmax((Fb2), 0.0);


			   // 08.05.2017.
			   // Моя наработка:
			   // ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).
			   sl[iVar][iP].ap += De2 * ApproxConvective(fabs(Pe2), iprefix_Scheme) + fmax(+(sign_flux * Fe2), 0.0);
			   sl[iVar][iP].ap += Dw2 * ApproxConvective(fabs(Pw2), iprefix_Scheme) + fmax(-(sign_flux * Fw2), 0.0);
			   sl[iVar][iP].ap += Dn2 * ApproxConvective(fabs(Pn2), iprefix_Scheme) + fmax(+(sign_flux * Fn2), 0.0);
			   sl[iVar][iP].ap += Ds2 * ApproxConvective(fabs(Ps2), iprefix_Scheme) + fmax(-(sign_flux * Fs2), 0.0);
			   sl[iVar][iP].ap += Dt2 * ApproxConvective(fabs(Pt2), iprefix_Scheme) + fmax(+(sign_flux * Ft2), 0.0);
			   sl[iVar][iP].ap += Db2 * ApproxConvective(fabs(Pb2), iprefix_Scheme) + fmax(-(sign_flux * Fb2), 0.0);


			   sumanb += De2 * ApproxConvective(fabs(Pe2), iprefix_Scheme) + fmax(+(sign_flux * Fe2), 0.0);
			   sumanb += Dw2 * ApproxConvective(fabs(Pw2), iprefix_Scheme) + fmax(-(sign_flux * Fw2), 0.0);
			   sumanb += Dn2 * ApproxConvective(fabs(Pn2), iprefix_Scheme) + fmax(+(sign_flux * Fn2), 0.0);
			   sumanb += Ds2 * ApproxConvective(fabs(Ps2), iprefix_Scheme) + fmax(-(sign_flux * Fs2), 0.0);
			   sumanb += Dt2 * ApproxConvective(fabs(Pt2), iprefix_Scheme) + fmax(+(sign_flux * Ft2), 0.0);
			   sumanb += Db2 * ApproxConvective(fabs(Pb2), iprefix_Scheme) + fmax(-(sign_flux * Fb2), 0.0);



			   // Оставил как единственно верное и рекомендуемое в литературе 7.05.2017.
		  // Нужно просто UDS.
		  // так рекомендуют в интернетах.
			   sl[iVar][iP].ae3 = De3 * ApproxConvective(fabs(Pe3), iprefix_Scheme) + fmax(-(sign_flux * Fe3), 0.0);
			   sl[iVar][iP].aw3 = Dw3 * ApproxConvective(fabs(Pw3), iprefix_Scheme) + fmax((sign_flux * Fw3), 0.0);
			   sl[iVar][iP].an3 = Dn3 * ApproxConvective(fabs(Pn3), iprefix_Scheme) + fmax(-(sign_flux * Fn3), 0.0);
			   sl[iVar][iP].as3 = Ds3 * ApproxConvective(fabs(Ps3), iprefix_Scheme) + fmax((sign_flux * Fs3), 0.0);
			   sl[iVar][iP].at3 = Dt3 * ApproxConvective(fabs(Pt3), iprefix_Scheme) + fmax(-(sign_flux * Ft3), 0.0);
			   sl[iVar][iP].ab3 = Db3 * ApproxConvective(fabs(Pb3), iprefix_Scheme) + fmax((sign_flux * Fb3), 0.0);


			   // 08.05.2017.
			   // Моя наработка:
			   // ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).
			   sl[iVar][iP].ap += De3 * ApproxConvective(fabs(Pe3), iprefix_Scheme) + fmax(+(sign_flux * Fe3), 0.0);
			   sl[iVar][iP].ap += Dw3 * ApproxConvective(fabs(Pw3), iprefix_Scheme) + fmax(-(sign_flux * Fw3), 0.0);
			   sl[iVar][iP].ap += Dn3 * ApproxConvective(fabs(Pn3), iprefix_Scheme) + fmax(+(sign_flux * Fn3), 0.0);
			   sl[iVar][iP].ap += Ds3 * ApproxConvective(fabs(Ps3), iprefix_Scheme) + fmax(-(sign_flux * Fs3), 0.0);
			   sl[iVar][iP].ap += Dt3 * ApproxConvective(fabs(Pt3), iprefix_Scheme) + fmax(+(sign_flux * Ft3), 0.0);
			   sl[iVar][iP].ap += Db3 * ApproxConvective(fabs(Pb3), iprefix_Scheme) + fmax(-(sign_flux * Fb3), 0.0);


			   sumanb += De3 * ApproxConvective(fabs(Pe3), iprefix_Scheme) + fmax(+(sign_flux * Fe3), 0.0);
			   sumanb += Dw3 * ApproxConvective(fabs(Pw3), iprefix_Scheme) + fmax(-(sign_flux * Fw3), 0.0);
			   sumanb += Dn3 * ApproxConvective(fabs(Pn3), iprefix_Scheme) + fmax(+(sign_flux * Fn3), 0.0);
			   sumanb += Ds3 * ApproxConvective(fabs(Ps3), iprefix_Scheme) + fmax(-(sign_flux * Fs3), 0.0);
			   sumanb += Dt3 * ApproxConvective(fabs(Pt3), iprefix_Scheme) + fmax(+(sign_flux * Ft3), 0.0);
			   sumanb += Db3 * ApproxConvective(fabs(Pb3), iprefix_Scheme) + fmax(-(sign_flux * Fb3), 0.0);



			   // Оставил как единственно верное и рекомендуемое в литературе 7.05.2017.
		  // Нужно просто UDS.
		  // так рекомендуют в интернетах.
			   sl[iVar][iP].ae4 = De4 * ApproxConvective(fabs(Pe4), iprefix_Scheme) + fmax(-(sign_flux * Fe4), 0.0);
			   sl[iVar][iP].aw4 = Dw4 * ApproxConvective(fabs(Pw4), iprefix_Scheme) + fmax((sign_flux * Fw4), 0.0);
			   sl[iVar][iP].an4 = Dn4 * ApproxConvective(fabs(Pn4), iprefix_Scheme) + fmax(-(sign_flux * Fn4), 0.0);
			   sl[iVar][iP].as4 = Ds4 * ApproxConvective(fabs(Ps4), iprefix_Scheme) + fmax((sign_flux * Fs4), 0.0);
			   sl[iVar][iP].at4 = Dt4 * ApproxConvective(fabs(Pt4), iprefix_Scheme) + fmax(-(sign_flux * Ft4), 0.0);
			   sl[iVar][iP].ab4 = Db4 * ApproxConvective(fabs(Pb4), iprefix_Scheme) + fmax((sign_flux * Fb4), 0.0);


			   // 08.05.2017.
			   // Моя наработка:
			   // ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).
			   sl[iVar][iP].ap += De4 * ApproxConvective(fabs(Pe4), iprefix_Scheme) + fmax(+(sign_flux * Fe4), 0.0);
			   sl[iVar][iP].ap += Dw4 * ApproxConvective(fabs(Pw4), iprefix_Scheme) + fmax(-(sign_flux * Fw4), 0.0);
			   sl[iVar][iP].ap += Dn4 * ApproxConvective(fabs(Pn4), iprefix_Scheme) + fmax(+(sign_flux * Fn4), 0.0);
			   sl[iVar][iP].ap += Ds4 * ApproxConvective(fabs(Ps4), iprefix_Scheme) + fmax(-(sign_flux * Fs4), 0.0);
			   sl[iVar][iP].ap += Dt4 * ApproxConvective(fabs(Pt4), iprefix_Scheme) + fmax(+(sign_flux * Ft4), 0.0);
			   sl[iVar][iP].ap += Db4 * ApproxConvective(fabs(Pb4), iprefix_Scheme) + fmax(-(sign_flux * Fb4), 0.0);


			   sumanb += De4 * ApproxConvective(fabs(Pe4), iprefix_Scheme) + fmax(+(sign_flux * Fe4), 0.0);
			   sumanb += Dw4 * ApproxConvective(fabs(Pw4), iprefix_Scheme) + fmax(-(sign_flux * Fw4), 0.0);
			   sumanb += Dn4 * ApproxConvective(fabs(Pn4), iprefix_Scheme) + fmax(+(sign_flux * Fn4), 0.0);
			   sumanb += Ds4 * ApproxConvective(fabs(Ps4), iprefix_Scheme) + fmax(-(sign_flux * Fs4), 0.0);
			   sumanb += Dt4 * ApproxConvective(fabs(Pt4), iprefix_Scheme) + fmax(+(sign_flux * Ft4), 0.0);
			   sumanb += Db4 * ApproxConvective(fabs(Pb4), iprefix_Scheme) + fmax(-(sign_flux * Fb4), 0.0);


		   }

		}
		else {

			// 8.05.2017
			// Ни в коем случае не включать эту ветку кода.


			// Так делать нельзя по видимому, решение хоть и получается и даже похожим получается,
			// НО при более тщательном рассмотрении оно не удовлетворяет физическому смыслу.
		   // 30 07 2015
		   // 
		   // Вблизи стенки порядок схемы понижается до UDS.
		   if (!bE) {
			   // строго внутренняя.
			   sl[iVar][iP].ae=De * ApproxConvective(fabs(Pe), iprefix_Scheme) + fmax(-(Fe),0.0);
	       }
		   else {
			   integer inumber=iE-maxelm;
			   if (border_neighbor[inumber].MCB==(ls+lw)) {
				   // условие по умолчанию: твёрдая стенка.
				   // усиление влияния нуля на границе, нам же нужно влияние стенки.
                   sl[iVar][iP].ae=De * ApproxConvective(fabs(Pe), iprefix_Scheme) + fabs(Fe);
			   }
			   else {
				   // Во всех остальных случаях также снижаем порядок до первого.
				   sl[iVar][iP].ae=De * ApproxConvective(fabs(Pe), iprefix_Scheme) + fabs(Fe);
			   }
		   }

		   if (!bW) {
			   // строго внутренняя.
			   sl[iVar][iP].aw=Dw * ApproxConvective(fabs(Pw), iprefix_Scheme) + fmax((Fw),0.0);
		   }
		   else {
               integer inumber=iW-maxelm;
			   if (border_neighbor[inumber].MCB==(ls+lw)) {
				   // условие по умолчанию: твёрдая стенка.
				   // усиление влияния нуля на границе, нам же нужно влияние стенки.
				   sl[iVar][iP].aw=Dw * ApproxConvective(fabs(Pw), iprefix_Scheme) + fabs(Fw);
			   }
			    else {
				   // Во всех остальных случаях также снижаем порядок до первого.
                   sl[iVar][iP].aw=Dw * ApproxConvective(fabs(Pw), iprefix_Scheme) + fabs(Fw);
				}
		   }

		    if (!bN) {
			   // строго внутренняя.
			   sl[iVar][iP].an=Dn * ApproxConvective(fabs(Pn), iprefix_Scheme) + fmax(-(Fn),0.0);
	       }
		   else {
			   integer inumber=iN-maxelm;
			   if (border_neighbor[inumber].MCB==(ls+lw)) {
				   // условие по умолчанию: твёрдая стенка.
				   // усиление влияния нуля на границе, нам же нужно влияние стенки.
                   sl[iVar][iP].an=Dn * ApproxConvective(fabs(Pn), iprefix_Scheme) + fabs(Fn);
			   }
			   else {
				   // Во всех остальных случаях также снижаем порядок до первого.
				   sl[iVar][iP].an=Dn * ApproxConvective(fabs(Pn), iprefix_Scheme) + fabs(Fn);
			   }
		   }

		   if (!bS) {
			   // строго внутренняя.
			   sl[iVar][iP].as=Ds * ApproxConvective(fabs(Ps), iprefix_Scheme) + fmax((Fs),0.0);
		   }
		   else {
               integer inumber=iS-maxelm;
			   if (border_neighbor[inumber].MCB==(ls+lw)) {
				   // условие по умолчанию: твёрдая стенка.
				   // усиление влияния нуля на границе, нам же нужно влияние стенки.
				   sl[iVar][iP].as=Ds * ApproxConvective(fabs(Ps), iprefix_Scheme) + fabs(Fs);
			   }
			    else {
				   // Во всех остальных случаях также снижаем порядок до первого.
                   sl[iVar][iP].as=Ds * ApproxConvective(fabs(Ps), iprefix_Scheme) + fabs(Fs);
				}
		   }

		    if (!bT) {
			   // строго внутренняя.
			   sl[iVar][iP].at=Dt * ApproxConvective(fabs(Pt), iprefix_Scheme) + fmax(-(Ft),0.0);
	       }
		   else {
			   integer inumber=iT-maxelm;
			   if (border_neighbor[inumber].MCB==(ls+lw)) {
				   // условие по умолчанию: твёрдая стенка.
				   // усиление влияния нуля на границе, нам же нужно влияние стенки.
                   sl[iVar][iP].at=Dt * ApproxConvective(fabs(Pt), iprefix_Scheme) + fabs(Ft);
			   }
			   else {
				   // Во всех остальных случаях также снижаем порядок до первого.
				   sl[iVar][iP].at=Dt * ApproxConvective(fabs(Pt), iprefix_Scheme) + fabs(Ft);
			   }
		   }

		   if (!bB) {
			   // строго внутренняя.
			   sl[iVar][iP].ab=Db * ApproxConvective(fabs(Pb), iprefix_Scheme)  + fmax((Fb),0.0);
		   }
		   else {
               integer inumber=iB-maxelm;
			   if (border_neighbor[inumber].MCB==(ls+lw)) {
				   // условие по умолчанию: твёрдая стенка.
				   // усиление влияния нуля на границе, нам же нужно влияние стенки.
				   sl[iVar][iP].ab=Db * ApproxConvective(fabs(Pb), iprefix_Scheme) + fabs(Fb);
			   }
			    else {
				   // Во всех остальных случаях также снижаем порядок до первого.
                   sl[iVar][iP].ab=Db * ApproxConvective(fabs(Pb), iprefix_Scheme) + fabs(Fb);
				}
		   }


		   if (b_on_adaptive_local_refinement_mesh) {

			   // Вблизи стенки порядок схемы понижается до UDS.
			   if (!bE2) {
				   // строго внутренняя.
				   sl[iVar][iP].ae2 = De2 * ApproxConvective(fabs(Pe2), iprefix_Scheme) + fmax(-(Fe2), 0.0);
			   }
			   else {
				   integer inumber = iE2 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].ae2 = De2 * ApproxConvective(fabs(Pe2), iprefix_Scheme) + fabs(Fe2);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].ae2 = De2 * ApproxConvective(fabs(Pe2), iprefix_Scheme) + fabs(Fe2);
				   }
			   }

			   if (!bW2) {
				   // строго внутренняя.
				   sl[iVar][iP].aw2 = Dw2 * ApproxConvective(fabs(Pw2), iprefix_Scheme) + fmax((Fw2), 0.0);
			   }
			   else {
				   integer inumber = iW2 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].aw2 = Dw2 * ApproxConvective(fabs(Pw2), iprefix_Scheme) + fabs(Fw2);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].aw2 = Dw2 * ApproxConvective(fabs(Pw2), iprefix_Scheme) + fabs(Fw2);
				   }
			   }

			   if (!bN2) {
				   // строго внутренняя.
				   sl[iVar][iP].an2 = Dn2 * ApproxConvective(fabs(Pn2), iprefix_Scheme) + fmax(-(Fn2), 0.0);
			   }
			   else {
				   integer inumber = iN2 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].an2 = Dn2 * ApproxConvective(fabs(Pn2), iprefix_Scheme) + fabs(Fn2);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].an2 = Dn2 * ApproxConvective(fabs(Pn2), iprefix_Scheme) + fabs(Fn2);
				   }
			   }

			   if (!bS2) {
				   // строго внутренняя.
				   sl[iVar][iP].as2 = Ds2 * ApproxConvective(fabs(Ps2), iprefix_Scheme) + fmax((Fs2), 0.0);
			   }
			   else {
				   integer inumber = iS2 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].as2 = Ds2 * ApproxConvective(fabs(Ps2), iprefix_Scheme) + fabs(Fs2);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].as2 = Ds2 * ApproxConvective(fabs(Ps2), iprefix_Scheme) + fabs(Fs2);
				   }
			   }

			   if (!bT2) {
				   // строго внутренняя.
				   sl[iVar][iP].at2 = Dt2 * ApproxConvective(fabs(Pt2), iprefix_Scheme) + fmax(-(Ft2), 0.0);
			   }
			   else {
				   integer inumber = iT2 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].at2 = Dt2 * ApproxConvective(fabs(Pt2), iprefix_Scheme) + fabs(Ft2);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].at2 = Dt2 * ApproxConvective(fabs(Pt2), iprefix_Scheme) + fabs(Ft2);
				   }
			   }

			   if (!bB2) {
				   // строго внутренняя.
				   sl[iVar][iP].ab2 = Db2 * ApproxConvective(fabs(Pb2), iprefix_Scheme) + fmax((Fb2), 0.0);
			   }
			   else {
				   integer inumber = iB2 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].ab2 = Db2 * ApproxConvective(fabs(Pb2), iprefix_Scheme) + fabs(Fb2);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].ab2 = Db2 * ApproxConvective(fabs(Pb2), iprefix_Scheme) + fabs(Fb2);
				   }
			   }


			   // Вблизи стенки порядок схемы понижается до UDS.
			   if (!bE3) {
				   // строго внутренняя.
				   sl[iVar][iP].ae3 = De3 * ApproxConvective(fabs(Pe3), iprefix_Scheme) + fmax(-(Fe3), 0.0);
			   }
			   else {
				   integer inumber = iE3 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].ae3 = De3 * ApproxConvective(fabs(Pe3), iprefix_Scheme) + fabs(Fe3);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].ae3 = De3 * ApproxConvective(fabs(Pe3), iprefix_Scheme) + fabs(Fe3);
				   }
			   }

			   if (!bW3) {
				   // строго внутренняя.
				   sl[iVar][iP].aw3 = Dw3 * ApproxConvective(fabs(Pw3), iprefix_Scheme) + fmax((Fw3), 0.0);
			   }
			   else {
				   integer inumber = iW3 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].aw3 = Dw3 * ApproxConvective(fabs(Pw3), iprefix_Scheme) + fabs(Fw3);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].aw3 = Dw3 * ApproxConvective(fabs(Pw3), iprefix_Scheme) + fabs(Fw3);
				   }
			   }

			   if (!bN3) {
				   // строго внутренняя.
				   sl[iVar][iP].an3 = Dn3 * ApproxConvective(fabs(Pn3), iprefix_Scheme) + fmax(-(Fn3), 0.0);
			   }
			   else {
				   integer inumber = iN3 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].an3 = Dn3 * ApproxConvective(fabs(Pn3), iprefix_Scheme) + fabs(Fn3);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].an3 = Dn3 * ApproxConvective(fabs(Pn3), iprefix_Scheme) + fabs(Fn3);
				   }
			   }

			   if (!bS3) {
				   // строго внутренняя.
				   sl[iVar][iP].as3 = Ds3 * ApproxConvective(fabs(Ps3), iprefix_Scheme) + fmax((Fs3), 0.0);
			   }
			   else {
				   integer inumber = iS3 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].as3 = Ds3 * ApproxConvective(fabs(Ps3), iprefix_Scheme) + fabs(Fs3);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].as3 = Ds3 * ApproxConvective(fabs(Ps3), iprefix_Scheme) + fabs(Fs3);
				   }
			   }

			   if (!bT3) {
				   // строго внутренняя.
				   sl[iVar][iP].at3 = Dt3 * ApproxConvective(fabs(Pt3), iprefix_Scheme) + fmax(-(Ft3), 0.0);
			   }
			   else {
				   integer inumber = iT3 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].at3 = Dt3 * ApproxConvective(fabs(Pt3), iprefix_Scheme) + fabs(Ft3);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].at3 = Dt3 * ApproxConvective(fabs(Pt3), iprefix_Scheme) + fabs(Ft3);
				   }
			   }

			   if (!bB3) {
				   // строго внутренняя.
				   sl[iVar][iP].ab3 = Db3 * ApproxConvective(fabs(Pb3), iprefix_Scheme) + fmax((Fb3), 0.0);
			   }
			   else {
				   integer inumber = iB3 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].ab3 = Db3 * ApproxConvective(fabs(Pb3), iprefix_Scheme) + fabs(Fb3);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].ab3 = Db3 * ApproxConvective(fabs(Pb3), iprefix_Scheme) + fabs(Fb3);
				   }
			   }


			   // Вблизи стенки порядок схемы понижается до UDS.
			   if (!bE4) {
				   // строго внутренняя.
				   sl[iVar][iP].ae4 = De4 * ApproxConvective(fabs(Pe4), iprefix_Scheme) + fmax(-(Fe4), 0.0);
			   }
			   else {
				   integer inumber = iE4 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].ae4 = De4 * ApproxConvective(fabs(Pe4), iprefix_Scheme) + fabs(Fe4);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].ae4 = De4 * ApproxConvective(fabs(Pe4), iprefix_Scheme) + fabs(Fe4);
				   }
			   }

			   if (!bW4) {
				   // строго внутренняя.
				   sl[iVar][iP].aw4 = Dw4 * ApproxConvective(fabs(Pw4), iprefix_Scheme) + fmax((Fw4), 0.0);
			   }
			   else {
				   integer inumber = iW4 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].aw4 = Dw4 * ApproxConvective(fabs(Pw4), iprefix_Scheme) + fabs(Fw4);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].aw4 = Dw4 * ApproxConvective(fabs(Pw4), iprefix_Scheme) + fabs(Fw4);
				   }
			   }

			   if (!bN4) {
				   // строго внутренняя.
				   sl[iVar][iP].an4 = Dn4 * ApproxConvective(fabs(Pn4), iprefix_Scheme) + fmax(-(Fn4), 0.0);
			   }
			   else {
				   integer inumber = iN4 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].an4 = Dn4 * ApproxConvective(fabs(Pn4), iprefix_Scheme) + fabs(Fn4);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].an4 = Dn4 * ApproxConvective(fabs(Pn4), iprefix_Scheme) + fabs(Fn4);
				   }
			   }

			   if (!bS4) {
				   // строго внутренняя.
				   sl[iVar][iP].as4 = Ds4 * ApproxConvective(fabs(Ps4), iprefix_Scheme) + fmax((Fs4), 0.0);
			   }
			   else {
				   integer inumber = iS4 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].as4 = Ds4 * ApproxConvective(fabs(Ps4), iprefix_Scheme) + fabs(Fs4);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].as4 = Ds4 * ApproxConvective(fabs(Ps4), iprefix_Scheme) + fabs(Fs4);
				   }
			   }

			   if (!bT4) {
				   // строго внутренняя.
				   sl[iVar][iP].at4 = Dt4 * ApproxConvective(fabs(Pt4), iprefix_Scheme) + fmax(-(Ft4), 0.0);
			   }
			   else {
				   integer inumber = iT4 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].at4 = Dt4 * ApproxConvective(fabs(Pt4), iprefix_Scheme) + fabs(Ft4);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].at4 = Dt4 * ApproxConvective(fabs(Pt4), iprefix_Scheme) + fabs(Ft4);
				   }
			   }

			   if (!bB4) {
				   // строго внутренняя.
				   sl[iVar][iP].ab4 = Db4 * ApproxConvective(fabs(Pb4), iprefix_Scheme) + fmax((Fb4), 0.0);
			   }
			   else {
				   integer inumber = iB4 - maxelm;
				   if (border_neighbor[inumber].MCB == (ls + lw)) {
					   // условие по умолчанию: твёрдая стенка.
					   // усиление влияния нуля на границе, нам же нужно влияние стенки.
					   sl[iVar][iP].ab4 = Db4 * ApproxConvective(fabs(Pb4), iprefix_Scheme) + fabs(Fb4);
				   }
				   else {
					   // Во всех остальных случаях также снижаем порядок до первого.
					   sl[iVar][iP].ab4 = Db4 * ApproxConvective(fabs(Pb4), iprefix_Scheme) + fabs(Fb4);
				   }
			   }



		   }


		   // 7.05.2017 Оставил как единственно верное и рекомендованное в литературе.
		   sl[iVar][iP].ap=sl[iVar][iP].ae+sl[iVar][iP].aw+sl[iVar][iP].an+sl[iVar][iP].as+sl[iVar][iP].at+sl[iVar][iP].ab;

		   sumanb=sl[iVar][iP].ae+sl[iVar][iP].aw+sl[iVar][iP].an+sl[iVar][iP].as+sl[iVar][iP].at+sl[iVar][iP].ab;
		
		   if (b_on_adaptive_local_refinement_mesh) {

			   // 7.05.2017 Оставил как единственно верное и рекомендованное в литературе.
			   sl[iVar][iP].ap += sl[iVar][iP].ae2 + sl[iVar][iP].aw2 + sl[iVar][iP].an2 + sl[iVar][iP].as2 + sl[iVar][iP].at2 + sl[iVar][iP].ab2;

			   sumanb += sl[iVar][iP].ae2 + sl[iVar][iP].aw2 + sl[iVar][iP].an2 + sl[iVar][iP].as2 + sl[iVar][iP].at2 + sl[iVar][iP].ab2;

			   sl[iVar][iP].ap += sl[iVar][iP].ae3 + sl[iVar][iP].aw3 + sl[iVar][iP].an3 + sl[iVar][iP].as3 + sl[iVar][iP].at3 + sl[iVar][iP].ab3;

			   sumanb += sl[iVar][iP].ae3 + sl[iVar][iP].aw3 + sl[iVar][iP].an3 + sl[iVar][iP].as3 + sl[iVar][iP].at3 + sl[iVar][iP].ab3;

			   sl[iVar][iP].ap += sl[iVar][iP].ae4 + sl[iVar][iP].aw4 + sl[iVar][iP].an4 + sl[iVar][iP].as4 + sl[iVar][iP].at4 + sl[iVar][iP].ab4;

			   sumanb += sl[iVar][iP].ae4 + sl[iVar][iP].aw4 + sl[iVar][iP].an4 + sl[iVar][iP].as4 + sl[iVar][iP].at4 + sl[iVar][iP].ab4;


		   }

		}


		// 7.05.2017 Оставил как единственно верное и рекомендованное в литературе.
		//sl[iVar][iP].ap=sl[iVar][iP].ae+sl[iVar][iP].aw+sl[iVar][iP].an+sl[iVar][iP].as+sl[iVar][iP].at+sl[iVar][iP].ab;

		//sumanb=sl[iVar][iP].ae+sl[iVar][iP].aw+sl[iVar][iP].an+sl[iVar][iP].as+sl[iVar][iP].at+sl[iVar][iP].ab;

		//13 августа 2016.
		//sl[iVar][iP].ap = fabs(sl[iVar][iP].ae) + fabs(sl[iVar][iP].aw) + fabs(sl[iVar][iP].an) + fabs(sl[iVar][iP].as) + fabs(sl[iVar][iP].at) + fabs(sl[iVar][iP].ab);
		//sumanb = fabs(sl[iVar][iP].ae) + fabs(sl[iVar][iP].aw) + fabs(sl[iVar][iP].an) + fabs(sl[iVar][iP].as) + fabs(sl[iVar][iP].at) + fabs(sl[iVar][iP].ab);


		if (1) {
		    // Вклад в правую часть (метод отложенной коррекции):
		    // X - direction
		    attrs+=-fmax((Fe),0)*(Speede-SpeedP)+fmax(-(Fe),0)*(Speede-SpeedE);
			if (attrs != attrs) {
				printf("Fe=%e SpeedP=%e Speede=%e SpeedE=%e\n",Fe, SpeedP, Speede, SpeedE);
			}

		    attrs+=-fmax(-(Fw),0)*(Speedw-SpeedP)+fmax((Fw),0)*(Speedw-SpeedW); 
			if (attrs != attrs) {
				printf("Fw=%e SpeedP=%e Speedw=%e SpeedW=%e\n", Fw, SpeedP, Speedw, SpeedW);
			}

		    // Y - direction
		    attrs+=-fmax((Fn),0)*(Speedn-SpeedP)+fmax(-(Fn),0)*(Speedn-SpeedN); 
			if (attrs != attrs) {
				printf("Fn=%e SpeedP=%e Speedn=%e SpeedN=%e\n", Fn, SpeedP, Speedn, SpeedN);
			}

		    attrs+=-fmax(-(Fs),0)*(Speeds-SpeedP)+fmax((Fs),0)*(Speeds-SpeedS); 
			if (attrs != attrs) {
				printf("Fs=%e SpeedP=%e Speeds=%e SpeedS=%e\n", Fs, SpeedP, Speeds, SpeedS);
			}

		    // Z - direction
            attrs+=-fmax((Ft),0)*(Speedt-SpeedP)+fmax(-(Ft),0)*(Speedt-SpeedT); 
			if (attrs != attrs) {
				printf("Ft=%e SpeedP=%e Speedt=%e SpeedT=%e\n", Ft, SpeedP, Speedt, SpeedT);
			}

		    attrs+=-fmax(-(Fb),0)*(Speedb-SpeedP)+fmax((Fb),0)*(Speedb-SpeedB); 
			if (attrs != attrs) {
				printf("Fb=%e SpeedP=%e Speedb=%e SpeedB=%e\n", Fb, SpeedP, Speedb, SpeedB);
			}


			if (b_on_adaptive_local_refinement_mesh) {

				// Вклад в правую часть (метод отложенной коррекции):
		        // X - direction
				attrs += -fmax((Fe2), 0) * (Speede2 - SpeedP) + fmax(-(Fe2), 0) * (Speede2 - SpeedE2);
				if (attrs != attrs) {
					printf("Fe2=%e SpeedP=%e Speede2=%e SpeedE2=%e\n", Fe2, SpeedP, Speede2, SpeedE2);
				}
				attrs += -fmax(-(Fw2), 0) * (Speedw2 - SpeedP) + fmax((Fw2), 0) * (Speedw2 - SpeedW2);
				if (attrs != attrs) {
					printf("Fw2=%e SpeedP=%e Speedw2=%e SpeedW2=%e\n", Fw2, SpeedP, Speedw2, SpeedW2);
				}

				// Y - direction
				attrs += -fmax((Fn2), 0) * (Speedn2 - SpeedP) + fmax(-(Fn2), 0) * (Speedn2 - SpeedN2);
				if (attrs != attrs) {
					printf("Fn2=%e SpeedP=%e Speedn2=%e SpeedN2=%e\n", Fn2, SpeedP, Speedn2, SpeedN2);
				}
				attrs += -fmax(-(Fs2), 0) * (Speeds2 - SpeedP) + fmax((Fs2), 0) * (Speeds2 - SpeedS2);
				if (attrs != attrs) {
					printf("Fs2=%e SpeedP=%e Speeds2=%e SpeedS2=%e\n", Fs2, SpeedP, Speeds2, SpeedS2);
				}
				// Z - direction
				attrs += -fmax((Ft2), 0) * (Speedt2 - SpeedP) + fmax(-(Ft2), 0) * (Speedt2 - SpeedT2);
				if (attrs != attrs) {
					printf("Ft2=%e SpeedP=%e Speedt2=%e SpeedT2=%e\n", Ft2, SpeedP, Speedt2, SpeedT2);
				}
				attrs += -fmax(-(Fb2), 0) * (Speedb2 - SpeedP) + fmax((Fb2), 0) * (Speedb2 - SpeedB2);
				if (attrs != attrs) {
					printf("Fb2=%e SpeedP=%e Speedb2=%e SpeedB2=%e\n", Fb2, SpeedP, Speedb2, SpeedB2);
				}


				// Вклад в правую часть (метод отложенной коррекции):
		        // X - direction
				attrs += -fmax((Fe3), 0) * (Speede3 - SpeedP) + fmax(-(Fe3), 0) * (Speede3 - SpeedE3);
				if (attrs != attrs) {
					printf("Fe3=%e SpeedP=%e Speede3=%e SpeedE3=%e\n", Fe3, SpeedP, Speede3, SpeedE3);
				}
				attrs += -fmax(-(Fw3), 0) * (Speedw3 - SpeedP) + fmax((Fw3), 0) * (Speedw3 - SpeedW3);
				if (attrs != attrs) {
					printf("Fw3=%e SpeedP=%e Speedw3=%e SpeedW3=%e\n", Fw3, SpeedP, Speedw3, SpeedW3);
				}

				// Y - direction
				attrs += -fmax((Fn3), 0) * (Speedn3 - SpeedP) + fmax(-(Fn3), 0) * (Speedn3 - SpeedN3);
				if (attrs != attrs) {
					printf("Fn3=%e SpeedP=%e Speedn3=%e SpeedN3=%e\n", Fn3, SpeedP, Speedn3, SpeedN3);
				}
				attrs += -fmax(-(Fs3), 0) * (Speeds3 - SpeedP) + fmax((Fs3), 0) * (Speeds3 - SpeedS3);
				if (attrs != attrs) {
					printf("Fs3=%e SpeedP=%e Speeds3=%e SpeedS3=%e\n", Fs3, SpeedP, Speeds3, SpeedS3);
				}
				// Z - direction
				attrs += -fmax((Ft3), 0) * (Speedt3 - SpeedP) + fmax(-(Ft3), 0) * (Speedt3 - SpeedT3);
				if (attrs != attrs) {
					printf("Ft3=%e SpeedP=%e Speedt3=%e SpeedT3=%e\n", Ft3, SpeedP, Speedt3, SpeedT3);
				}
				attrs += -fmax(-(Fb3), 0) * (Speedb3 - SpeedP) + fmax((Fb3), 0) * (Speedb3 - SpeedB3);
				if (attrs != attrs) {
					printf("Fb3=%e SpeedP=%e Speedb3=%e SpeedB3=%e\n", Fb3, SpeedP, Speedb3, SpeedB3);
				}


				// Вклад в правую часть (метод отложенной коррекции):
		        // X - direction
				attrs += -fmax((Fe4), 0) * (Speede4 - SpeedP) + fmax(-(Fe4), 0) * (Speede4 - SpeedE4);
				if (attrs != attrs) {
					printf("Fe4=%e SpeedP=%e Speede4=%e SpeedE4=%e\n", Fe4, SpeedP, Speede4, SpeedE4);
				}
				attrs += -fmax(-(Fw4), 0) * (Speedw4 - SpeedP) + fmax((Fw4), 0) * (Speedw4 - SpeedW4);
				if (attrs != attrs) {
					printf("Fw4=%e SpeedP=%e Speedw4=%e SpeedW4=%e\n", Fw4, SpeedP, Speedw4, SpeedW4);
				}

				// Y - direction
				attrs += -fmax((Fn4), 0) * (Speedn4 - SpeedP) + fmax(-(Fn4), 0) * (Speedn4 - SpeedN4);
				if (attrs != attrs) {
					printf("Fn4=%e SpeedP=%e Speedn4=%e SpeedN4=%e\n", Fn4, SpeedP, Speedn4, SpeedN4);
				}
				attrs += -fmax(-(Fs4), 0) * (Speeds4 - SpeedP) + fmax((Fs4), 0) * (Speeds4 - SpeedS4);
				if (attrs != attrs) {
					printf("Fs4=%e SpeedP=%e Speeds4=%e SpeedS4=%e\n", Fs4, SpeedP, Speeds4, SpeedS4);
				}
				// Z - direction
				attrs += -fmax((Ft4), 0) * (Speedt4 - SpeedP) + fmax(-(Ft4), 0) * (Speedt4 - SpeedT4);
				if (attrs != attrs) {
					printf("Ft4=%e SpeedP=%e Speedt4=%e SpeedT4=%e\n", Ft4, SpeedP, Speedt4, SpeedT4);
				}
				attrs += -fmax(-(Fb4), 0) * (Speedb4 - SpeedP) + fmax((Fb4), 0) * (Speedb4 - SpeedB4);
				if (attrs != attrs) {
					printf("Fb4=%e SpeedP=%e Speedb4=%e SpeedB4=%e\n", Fb4, SpeedP, Speedb4, SpeedB4);
				}

			}

		}
		else {
			// Неверно.
		   // 30 07 2015
		   // 
		   // Вблизи стенки порядок схемы понижается до UDS.
			if (!bE) {
				attrs+=-fmax((Fe),0)*(Speede-SpeedP)+fmax(-(Fe),0)*(Speede-SpeedE); 
			}
			if (!bW) {
				attrs+=-fmax(-(Fw),0)*(Speedw-SpeedP)+fmax((Fw),0)*(Speedw-SpeedW);
			}
			if (!bN) {
				attrs+=-fmax((Fn),0)*(Speedn-SpeedP)+fmax(-(Fn),0)*(Speedn-SpeedN);
			}
			if (!bS) {
                attrs+=-fmax(-(Fs),0)*(Speeds-SpeedP)+fmax((Fs),0)*(Speeds-SpeedS);
			}
			if (!bT) {
				attrs+=-fmax((Ft),0)*(Speedt-SpeedP)+fmax(-(Ft),0)*(Speedt-SpeedT);
			}
			if (!bB) {
				attrs+=-fmax(-(Fb),0)*(Speedb-SpeedP)+fmax((Fb),0)*(Speedb-SpeedB); 
			}

			if (b_on_adaptive_local_refinement_mesh) {

				if (!bE2) {
					attrs += -fmax((Fe2), 0) * (Speede2 - SpeedP) + fmax(-(Fe2), 0) * (Speede2 - SpeedE2);
				}
				if (!bW2) {
					attrs += -fmax(-(Fw2), 0) * (Speedw2 - SpeedP) + fmax((Fw2), 0) * (Speedw2 - SpeedW2);
				}
				if (!bN2) {
					attrs += -fmax((Fn2), 0) * (Speedn2 - SpeedP) + fmax(-(Fn2), 0) * (Speedn2 - SpeedN2);
				}
				if (!bS2) {
					attrs += -fmax(-(Fs2), 0) * (Speeds2 - SpeedP) + fmax((Fs2), 0) * (Speeds2 - SpeedS2);
				}
				if (!bT2) {
					attrs += -fmax((Ft2), 0) * (Speedt2 - SpeedP) + fmax(-(Ft2), 0) * (Speedt2 - SpeedT2);
				}
				if (!bB2) {
					attrs += -fmax(-(Fb2), 0) * (Speedb2 - SpeedP) + fmax((Fb2), 0) * (Speedb2 - SpeedB2);
				}


				if (!bE3) {
					attrs += -fmax((Fe3), 0) * (Speede3 - SpeedP) + fmax(-(Fe3), 0) * (Speede3 - SpeedE3);
				}
				if (!bW3) {
					attrs += -fmax(-(Fw3), 0) * (Speedw3 - SpeedP) + fmax((Fw3), 0) * (Speedw3 - SpeedW3);
				}
				if (!bN3) {
					attrs += -fmax((Fn3), 0) * (Speedn3 - SpeedP) + fmax(-(Fn3), 0) * (Speedn3 - SpeedN3);
				}
				if (!bS3) {
					attrs += -fmax(-(Fs3), 0) * (Speeds3 - SpeedP) + fmax((Fs3), 0) * (Speeds3 - SpeedS3);
				}
				if (!bT3) {
					attrs += -fmax((Ft3), 0) * (Speedt3 - SpeedP) + fmax(-(Ft3), 0) * (Speedt3 - SpeedT3);
				}
				if (!bB3) {
					attrs += -fmax(-(Fb3), 0) * (Speedb3 - SpeedP) + fmax((Fb3), 0) * (Speedb3 - SpeedB3);
				}


				if (!bE4) {
					attrs += -fmax((Fe4), 0) * (Speede4 - SpeedP) + fmax(-(Fe4), 0) * (Speede4 - SpeedE4);
				}
				if (!bW4) {
					attrs += -fmax(-(Fw4), 0) * (Speedw4 - SpeedP) + fmax((Fw4), 0) * (Speedw4 - SpeedW4);
				}
				if (!bN4) {
					attrs += -fmax((Fn4), 0) * (Speedn4 - SpeedP) + fmax(-(Fn4), 0) * (Speedn4 - SpeedN4);
				}
				if (!bS4) {
					attrs += -fmax(-(Fs4), 0) * (Speeds4 - SpeedP) + fmax((Fs4), 0) * (Speeds4 - SpeedS4);
				}
				if (!bT4) {
					attrs += -fmax((Ft4), 0) * (Speedt4 - SpeedP) + fmax(-(Ft4), 0) * (Speedt4 - SpeedT4);
				}
				if (!bB4) {
					attrs += -fmax(-(Fb4), 0) * (Speedb4 - SpeedP) + fmax((Fb4), 0) * (Speedb4 - SpeedB4);
				}

			}

		}

		//attrs=0.0; // сброс схемы высокой разрешающей способности (например схемы Леонарда).

	}


	if (0&&(sl[iVar][iP].ap <= 1.0e-9)) {
		sl[iVar][iP].ap = sl[iVar][iP].ae + sl[iVar][iP].aw + sl[iVar][iP].an + sl[iVar][iP].as + sl[iVar][iP].at + sl[iVar][iP].ab;
		sumanb = sl[iVar][iP].ae + sl[iVar][iP].aw + sl[iVar][iP].an + sl[iVar][iP].as + sl[iVar][iP].at + sl[iVar][iP].ab;

		if (b_on_adaptive_local_refinement_mesh) {

			sl[iVar][iP].ap += sl[iVar][iP].ae2 + sl[iVar][iP].aw2 + sl[iVar][iP].an2 + sl[iVar][iP].as2 + sl[iVar][iP].at2 + sl[iVar][iP].ab2;
			sumanb += sl[iVar][iP].ae2 + sl[iVar][iP].aw2 + sl[iVar][iP].an2 + sl[iVar][iP].as2 + sl[iVar][iP].at2 + sl[iVar][iP].ab2;

			sl[iVar][iP].ap += sl[iVar][iP].ae3 + sl[iVar][iP].aw3 + sl[iVar][iP].an3 + sl[iVar][iP].as3 + sl[iVar][iP].at3 + sl[iVar][iP].ab3;
			sumanb += sl[iVar][iP].ae3 + sl[iVar][iP].aw3 + sl[iVar][iP].an3 + sl[iVar][iP].as3 + sl[iVar][iP].at3 + sl[iVar][iP].ab3;

			sl[iVar][iP].ap += sl[iVar][iP].ae4 + sl[iVar][iP].aw4 + sl[iVar][iP].an4 + sl[iVar][iP].as4 + sl[iVar][iP].at4 + sl[iVar][iP].ab4;
			sumanb += sl[iVar][iP].ae4 + sl[iVar][iP].aw4 + sl[iVar][iP].an4 + sl[iVar][iP].as4 + sl[iVar][iP].at4 + sl[iVar][iP].ab4;

		}

	}

	doublereal Folditer=0.0; // скорректированное значение с предыдущей итерации

    doublereal tau, apzero1, apzero0;
	doublereal Fold=0.0; // значение функции с предыдущего временного слоя
	if (btimedep) {
	   // нестационарный
	   tau=tauparam;
	   if (speedoldtimestep != nullptr) {
		   Fold = speedoldtimestep[iP]; // здесь нужно брать компоненту скорости именно с предыдущего шага по времени
	   }
	   else {
		   printf("Fatal error!!! in function my_elmatr_quad_F3D. speedoldtimestep == nullptr in unsteady modelling...");
		   system("PAUSE");
		   exit(1);
	   }
	   switch (iVar) {
	    	// будет релаксировать к скоростям
			// удовлетворяющим уравнению неразрывности.
			case VELOCITY_X_COMPONENT: Folditer=potent[VXCOR][iP]; break;
			case VELOCITY_Y_COMPONENT: Folditer=potent[VYCOR][iP]; break;
			case VELOCITY_Z_COMPONENT: Folditer=potent[VZCOR][iP]; break;
		}
	}
	else {
	   // стационарный

	   // введём псевдовремя:
		// которое согласно Гаврилову Андрею для SIMPLE процедуры вычисляется следующим образом:
		// см. Гаврилов Андрей sigma flow часть 5 формула (Ч5.1.12).
		// см. письмо Гаврилова Андрея.
		if (fabs(alpha[iVar]-1.0)<admission) tau=1e30; // бесконечно большой шаг по времени, что соответствует стационарному решателю.
		else {
			// Первый вариант едиственно правильный с релаксационной точки зрения, т.к. вариант 2. нижней релаксацией не является.
			// здесь оставлен вариант 2 т.к. он совместим с tau которое используется в поправке Рхи-Чоу.

			// 1.
			//tau=rP*dx*dy*dz*alpha[iVar]/((sl[iVar][iP].ae+sl[iVar][iP].aw+sl[iVar][iP].an+sl[iVar][iP].as+sl[iVar][iP].at+sl[iVar][iP].ab)*(1.0-alpha[iVar]));
			// 2.
			if (b_on_adaptive_local_refinement_mesh) {
				tau = rP * dx*dy*dz*alpha[iVar] / ((sl[iVar][iP].ae + sl[iVar][iP].aw + sl[iVar][iP].an + sl[iVar][iP].as + sl[iVar][iP].at + sl[iVar][iP].ab+ sl[iVar][iP].ae2 + sl[iVar][iP].aw2 + sl[iVar][iP].an2 + sl[iVar][iP].as2 + sl[iVar][iP].at2 + sl[iVar][iP].ab2+ sl[iVar][iP].ae3 + sl[iVar][iP].aw3 + sl[iVar][iP].an3 + sl[iVar][iP].as3 + sl[iVar][iP].at3 + sl[iVar][iP].ab3+ sl[iVar][iP].ae4 + sl[iVar][iP].aw4 + sl[iVar][iP].an4 + sl[iVar][iP].as4 + sl[iVar][iP].at4 + sl[iVar][iP].ab4));
			}
			else {
				tau = rP * dx*dy*dz*alpha[iVar] / ((sl[iVar][iP].ae + sl[iVar][iP].aw + sl[iVar][iP].an + sl[iVar][iP].as + sl[iVar][iP].at + sl[iVar][iP].ab));
			}
		}
	   switch (iVar) {
	    	// будет релаксировать к скоростям
			// удовлетворяющим уравнению неразрывности.
			case VELOCITY_X_COMPONENT: Fold=potent[VXCOR][iP]; break;
			case VELOCITY_Y_COMPONENT: Fold=potent[VYCOR][iP]; break;
			case VELOCITY_Z_COMPONENT: Fold=potent[VZCOR][iP]; break;
		}

	   switch (iVar) {
	    	// будет релаксировать к скоростям
			// удовлетворяющим уравнению неразрывности.
			case VELOCITY_X_COMPONENT: Folditer=potent[VXCOR][iP]; break;
			case VELOCITY_Y_COMPONENT: Folditer=potent[VYCOR][iP]; break;
			case VELOCITY_Z_COMPONENT: Folditer=potent[VZCOR][iP]; break;
		}
	    	
	}

	if ((!btimedep) && (!imitation_time)) {
		// Лучше выставить imitation_time=false
		// т.к. нижняя релаксация к скорректированной скорости и так уже присутствует непосредстыенно после сборки матрицы СЛАУ.

		// стационарный и имитация шагов по времени не используется
		apzero1=0.0; // с нового временного слоя
		apzero0=0.0; // с предыдущего временного слоя
	}
	else if (((!btimedep) && (imitation_time) && (fabs(alpha[iVar]-1.0)>admission))) {
		//  стационарный и используется имитация шагов по времени и нижняя релаксация


		// Здесь нужно основываться на температуре с предыдущего итерационного слоя.
		// Но так как данный вариант никогда не используется здесь просто выставлено значение которое первое пришло в голову.
		// Этот вариант не используется т.к. реалаксация обеспечивается после сразу после сборки матрицы а не в этом куске кода
		// с использованием псевдовремени.
		apzero0=apzero1=rP*dx*dy*dz/tau;
		printf("error ispolzuetsq staticionar solver and imitation time step!\n");
		//getchar();
		system("pause");
		exit(0);
	}
	else if (btimedep) {
		// полностью нестационарный.

		apzero0 = apzero1=rP*dx*dy*dz/tau;

		/*
		TOCHKA p;
		center_cord3D(iP,nvtx,pa,p,100);
		integer ib; // номер искомого блока
		in_model_flow(p,ib,b,lb);

		doublereal rho=1.1614;

		if (matlist[b[ib].imatid].blibmat==1) {
			// библиотечный внутрипрограммный вариант.
			// Видимо здесь возможен только FLUID вариант но для общности запишем оба.
			if (b[ib].itype== PHYSICS_TYPE_IN_BODY::SOLID) {
				doublereal cp, lam; // значения не используются но требуются
				my_solid_properties(toldtimestep[ptr[iP]],rho,cp,lam,matlist[b[ib].imatid].ilibident);
			} // SOLID
			if (b[ib].itype== PHYSICS_TYPE_IN_BODY::FLUID) {
				doublereal mu, beta_t, lam, cp; // значения не используются но требуются
				doublereal pressure=potent[PRESS][iP]; // но на самом деле давление требуется с предыдущего временного слоя.
				my_fluid_properties(toldtimestep[ptr[iP]], pressure, rho, cp, lam, mu, beta_t, matlist[b[ib].imatid].ilibident);
			}// FLUID
		}
		else if (matlist[b[ib].imatid].blibmat==0) {
			// материал определённый пользователем:
			rho=matlist[b[ib].imatid].rho;
		}
		apzero0=rho*dx*dy*dz/tau;
		*/
	}
	else {
		apzero1=0.0;
		apzero0=0.0;
	}
  
	// источниковый член
	doublereal dSc=0.0, dSp=0.0, Bp=0.0;
	// Bp - это вклад перепада давления. Обозначение взято из диссертации
	// Кудинова Павла Ивановича.

	// Определяем минимальное значение температуры в расчётной области:
	//integer tavg = 0.0; // Минимальная температура в расчётной области.
	//for (integer i_1 = 0; i_1 < maxelm; i_1++) {
		//if (potent_temper[ptr[i_1]] < tmin) {
		//	tavg += potent_temper[ptr[i_1]];
		//}
	//}
	//tavg = tavg / maxelm;
	// Архимедова сила встлытия на основе tmin всегода противоположно направлена силе тяжести.


    doublereal body_force=0.0; // массовая сила связанная с силой тяжести или всплытия (Архимедовой)
    // для Vx, Vy, Vz вычисляем перепад давления действующий на внутренний контрольный объём
	//doublereal tp1, tp2; // отвечает за перепад давления действующий на контрольный объём.
	// явная часть тензора скоростей деформаций:
	// an explicit part of the tensor strain rate - exptsr
	doublereal exptsr=0.0;
	// учёт явной части тензора скоростей деформаций
	doublereal tsrE=0.0, tsrW=0.0, tsrP=0.0, tsrN=0.0, tsrS=0.0, tsrT=0.0, tsrB=0.0;

	//printf("dgx=%e dgy=%e dgz=%e\n",dgx,dgy,dgz);
	//getchar(); // debug; 


	/*
	// Документация FlowVision.
	Вектор объемной силы должен рассчитываться для каждой ячейки, поэтому при 
	определении вектора необходимо использовать локальные переменные для
	рассматриваемой фазы. На картинке Выше применяется локальная температура воздушной фазы. 
	В качестве «нулевых» значений плотности и температуры при определении объемной силы
	целесообразно использовать начальное значение плотности и температуры, которые в идеале
	должны быть максимально близки к средним величинам в стационарном решении.

	Не забудьте проконтролировать направление вектора объемной силы, соотнесите выбранное
	направление g и навпраление осей глобальной системы координат во FlowVision.

	В примере выше для наглядности производится вычисление абсолютных значений температур.
	Если начальная температура равна нулю (абсолютная соответствует опорной), то операция 
	эта избыточна, т.к. Tref в получившемся выражении можно сократить. Тогда выражение для
	объемной силы примет вид beta*(TEMP0-50) . Где TEMP0 - это фактически изменение температуры
	относительно 50 градусов цельсия (если опорная равна 273).
	*/

	doublereal tp1 = 0.0;
	doublereal tp2 = 0.0;

	switch (iVar) {
		case VELOCITY_X_COMPONENT: 
                  // простая линейная интерполяция:
			      
				  tp1=(1.0-feplus)*kP+feplus*kE;
				  tp2=(1.0-fwplus)*kP+fwplus*kW;

				  Bp+=(tp2-tp1)*dy*dz;
				  

			      // Если жидкость течёт слева направо то мы имеем 
		          // распределение давления убывающее слева направо.
			      // т.е. мы имеем отрицательный градиент давления под 
			      // воздействием которого жидкость движется слева направо.
			      // Ось координат при этом напроавлена слева направо.
			      // Источниковый член должен быть неотрицательным, поэтому мы берём
			      // минус градиент. Эта же ситуация аналогична для осей Oy && Oz. Для 
			      // них тоже нужно брать минус градиент.
				  //Bp-=potent[GRADXPRESS][iP]*dx*dy*dz;
				  if (eqin.fluidinfo[0].iflowregime != FLOW_REGIME::LAMINAR) {
					  if (eqin.fluidinfo[0].iturbmodel == TURBULENT_MODEL::RANS_MENTER_SST) {
						  Bp -= (2.0 / 3.0)*potent[GRADXTURBULENT_KINETIK_ENERGY][iP] * dx*dy*dz;
					  }
					  if (eqin.fluidinfo[0].iturbmodel == TURBULENT_MODEL::RANS_STANDART_K_EPS) {
						  Bp -= (2.0 / 3.0)*potent[GRADXTURBULENT_KINETIK_ENERGY_STD_K_EPS][iP] * dx*dy*dz;
					  }
				  }
				  if (Bp != Bp) {
					  printf("iVar==VX potent[GRADXPRESS][iP]*dx*dy*dz=%e\n", potent[GRADXPRESS][iP] * dx* dy* dz);
					  system("pause");
				  }

				  //printf("%e",(tp2-tp1)*dy*dz);
				  //getchar();
				  // Нужна связь с массивом температур!
				  if (bBussineskApproach) {
					  //printf("debug: rho: %e, beta=%e, dgx=%e, temp_ref=%e",prop[RHO][iP],prop[BETA_T][iP],dgx,temp_ref);
					  //getchar();
					  // Архимедова сила
					   body_force = -prop[RHO][iP] * prop[BETA_T][iP] * dgx*(potent_temper[ptr[iP]] - temp_ref);
					   if (body_force != body_force) {
						   printf("iVar==VX Arhimed body_force is NAN or INF =%e\n", body_force);
						   printf("iP=%d prop[RHO][iP]=%e prop[BETA_T][iP]=%e\n",iP, prop[RHO][iP], prop[BETA_T][iP]);
						   printf("dgx=%e temp_ref=%e potent_temper[ptr[iP]]=%e ptr[iP]=",dgx,temp_ref, potent_temper[ptr[iP]]);
						   std::cout << ptr[iP] << std::endl;
						   system("pause");
					   }
				  }
				  else 
				  {

					  //printf("no bussinesk: rho: %e, beta=%e, dgx=%e, temp_ref=%e",prop[RHO][iP],prop[BETA_T][iP],dgx,temp_ref);
					  //getchar();
					  // сила тяжести
                      body_force=prop[RHO][iP]*dgx;
					  if (body_force != body_force) {
						  printf("iVar==VX Arhimed body_force is NAN or INF =%e\n", body_force);
						  system("pause");
					  }
				  }
                  dSc+=body_force;
				  

				  // учёт явной части тензора скоростей деформаций
				  if (!b_on_adaptive_local_refinement_mesh) {
					  tsrP = potent[GRADXVX][iP] - (2.0 / 3.0)*(potent[GRADXVX][iP] + potent[GRADYVY][iP] + potent[GRADZVZ][iP]); // проверено 10 апреля 2013.
					  tsrE = potent[GRADXVX][iE] - (2.0 / 3.0)*(potent[GRADXVX][iE] + potent[GRADYVY][iE] + potent[GRADZVZ][iE]);
					  tsrW = potent[GRADXVX][iW] - (2.0 / 3.0)*(potent[GRADXVX][iW] + potent[GRADYVY][iW] + potent[GRADZVZ][iW]);
					  exptsr += (Ge*(tsrP*(1.0 - feplus) + tsrE * feplus) - Gw * (tsrP*(1.0 - fwplus) + tsrW * fwplus))*dy*dz;
					  exptsr += (Gn*(potent[GRADYVX][iP] * (1.0 - fnplus) + potent[GRADYVX][iN] * fnplus) - Gs * (potent[GRADYVX][iP] * (1.0 - fsplus) + potent[GRADYVX][iS] * fsplus))*dx*dz;
					  exptsr += (Gt*(potent[GRADZVX][iP] * (1.0 - ftplus) + potent[GRADZVX][iT] * ftplus) - Gb * (potent[GRADZVX][iP] * (1.0 - fbplus) + potent[GRADZVX][iB] * fbplus))*dx*dy;
				  }
				 

				  break;

        case VELOCITY_Y_COMPONENT: 
				  // простая линейная интерполяция:
			      
				  tp1=(1.0-fnplus)*kP+fnplus*kN;
				  tp2=(1.0-fsplus)*kP+fsplus*kS;

				  Bp+=(tp2-tp1)*dx*dz;
				  

				  //Bp-=potent[GRADYPRESS][iP]*dx*dy*dz;
				  if (eqin.fluidinfo[0].iflowregime != FLOW_REGIME::LAMINAR) {
					  if (eqin.fluidinfo[0].iturbmodel == TURBULENT_MODEL::RANS_MENTER_SST) {
						  Bp -= (2.0 / 3.0)*potent[GRADYTURBULENT_KINETIK_ENERGY][iP] * dx*dy*dz;
					  }
					  if (eqin.fluidinfo[0].iturbmodel == TURBULENT_MODEL::RANS_STANDART_K_EPS) {
						  Bp -= (2.0 / 3.0)*potent[GRADYTURBULENT_KINETIK_ENERGY_STD_K_EPS][iP] * dx*dy*dz;
					  }
				  }
				  if (Bp != Bp) {
					  printf("iVar==VY potent[GRADYPRESS][iP]*dx*dy*dz=%e\n", potent[GRADYPRESS][iP] * dx * dy * dz);
					  system("pause");
				  }

				  //printf("%e",(tp2-tp1)*dx*dz);
				  //getchar();
				  // Нужна связь с массивом температур!
				  if (bBussineskApproach) {
					  // Архимедова сила
					  // Проверено нкакого домножения на объём ячейки ненужно.
					  // оно делается много позже.
                      body_force=-prop[RHO][iP]*prop[BETA_T][iP]*dgy*(potent_temper[ptr[iP]]-temp_ref);
					  if (body_force != body_force) {
						  printf("iVar==VY Arhimed body_force is NAN or INF =%e\n", body_force);
						  printf("iP=%d prop[RHO][iP]=%e prop[BETA_T][iP]=%e\n", iP, prop[RHO][iP], prop[BETA_T][iP]);
						  printf("dgy=%e temp_ref=%e potent_temper[ptr[iP]]=%e ptr[iP]=", dgy, temp_ref, potent_temper[ptr[iP]]);
						  std::cout << ptr[iP] << std::endl;
						  system("pause");
					  }
				  }
				  else 
				  {
					  // сила тяжести
                      body_force=prop[RHO][iP]*dgy;
					  if (body_force != body_force) {
						  printf("iVar==VY Arhimed body_force is NAN or INF =%e\n", body_force);
						  system("pause");
					  }
				  }
				 
                  dSc+=body_force;

				  // учёт явной части тензора скоростей деформаций
				  if (!b_on_adaptive_local_refinement_mesh) {
					  tsrP = potent[GRADYVY][iP] - (2.0 / 3.0)*(potent[GRADXVX][iP] + potent[GRADYVY][iP] + potent[GRADZVZ][iP]); // проверено 10 апреля 2013.
					  tsrN = potent[GRADYVY][iN] - (2.0 / 3.0)*(potent[GRADXVX][iN] + potent[GRADYVY][iN] + potent[GRADZVZ][iN]);
					  tsrS = potent[GRADYVY][iS] - (2.0 / 3.0)*(potent[GRADXVX][iS] + potent[GRADYVY][iS] + potent[GRADZVZ][iS]);
					  exptsr += (Gn*(tsrP*(1.0 - fnplus) + tsrN * fnplus) - Gs * (tsrP*(1.0 - fsplus) + tsrS * fsplus))*dx*dz;
					  exptsr += (Ge*(potent[GRADXVY][iP] * (1.0 - feplus) + potent[GRADXVY][iE] * feplus) - Gw * (potent[GRADXVY][iP] * (1.0 - fwplus) + potent[GRADXVY][iW] * fwplus))*dy*dz;
					  exptsr += (Gt*(potent[GRADZVY][iP] * (1.0 - ftplus) + potent[GRADZVY][iT] * ftplus) - Gb * (potent[GRADZVY][iP] * (1.0 - fbplus) + potent[GRADZVY][iB] * fbplus))*dx*dy;
				  }
				 

				  break;

		case VELOCITY_Z_COMPONENT: 
                  // простая линейная интерполяция:
			      
				  tp1=(1.0-ftplus)*kP+ftplus*kT;
				  tp2=(1.0-fbplus)*kP+fbplus*kB;

				  Bp+=(tp2-tp1)*dy*dx;
				  

				  //Bp-=potent[GRADZPRESS][iP]*dx*dy*dz;
				  if (eqin.fluidinfo[0].iflowregime!= FLOW_REGIME::LAMINAR) {
					  if (eqin.fluidinfo[0].iturbmodel == TURBULENT_MODEL::RANS_MENTER_SST) {
						  Bp -= (2.0 / 3.0)*potent[GRADZTURBULENT_KINETIK_ENERGY][iP] * dx*dy*dz;
					  }
					  if (eqin.fluidinfo[0].iturbmodel == TURBULENT_MODEL::RANS_STANDART_K_EPS) {
						  Bp -= (2.0 / 3.0)*potent[GRADZTURBULENT_KINETIK_ENERGY_STD_K_EPS][iP] * dx*dy*dz;
					  }
				  }
				  if (Bp != Bp) {
					  printf("iVar==VZ potent[GRADZPRESS][iP]*dx*dy*dz=%e\n", potent[GRADZPRESS][iP] * dx * dy * dz);
					  system("pause");
				  }

				  //printf("%e",(tp2-tp1)*dy*dx);
				  //getchar();
				  // Нужна связь с массивом температур!
				  if (bBussineskApproach) {
					  // Архимедова сила
                      body_force=-prop[RHO][iP]*prop[BETA_T][iP]*dgz*(potent_temper[ptr[iP]]-temp_ref);
					  if (body_force != body_force) {
						  printf("iVar==VZ Arhimed body_force is NAN or INF =%e\n", body_force);
						  printf("iP=%d prop[RHO][iP]=%e prop[BETA_T][iP]=%e\n", iP, prop[RHO][iP], prop[BETA_T][iP]);
						  printf("dgy=%e temp_ref=%e potent_temper[ptr[iP]]=%e ptr[iP]=", dgz, temp_ref, potent_temper[ptr[iP]]);
						  std::cout << ptr[iP] << std::endl;
						  system("pause");
					  }
				  }
				  else 
				  {
					  // сила тяжести
                      body_force=prop[RHO][iP]*dgz;
					  if (body_force != body_force) {
						  printf("iVar==VZ Arhimed body_force is NAN or INF =%e\n", body_force);
						  system("pause");
					  }
				  }
				  
                  dSc+=body_force;

				  // учёт явной части тензора скоростей деформаций
				  if (!b_on_adaptive_local_refinement_mesh) {
					  tsrP = potent[GRADZVZ][iP] - (2.0 / 3.0)*(potent[GRADXVX][iP] + potent[GRADYVY][iP] + potent[GRADZVZ][iP]);
					  tsrT = potent[GRADZVZ][iT] - (2.0 / 3.0)*(potent[GRADXVX][iT] + potent[GRADYVY][iT] + potent[GRADZVZ][iT]);
					  tsrB = potent[GRADZVZ][iB] - (2.0 / 3.0)*(potent[GRADXVX][iB] + potent[GRADYVY][iB] + potent[GRADZVZ][iB]);
					  exptsr += (Gt*(tsrP*(1.0 - ftplus) + tsrT * ftplus) - Gb * (tsrP*(1.0 - fbplus) + tsrB * fbplus))*dx*dy;
					  exptsr += (Ge*(potent[GRADZVX][iP] * (1.0 - feplus) + potent[GRADZVX][iE] * feplus) - Gw * (potent[GRADZVX][iP] * (1.0 - fwplus) + potent[GRADZVX][iW] * fwplus))*dy*dz; // проверено 10 апреля 2013.
					  exptsr += (Gn*(potent[GRADZVY][iP] * (1.0 - fnplus) + potent[GRADZVY][iN] * fnplus) - Gs * (potent[GRADZVY][iP] * (1.0 - fsplus) + potent[GRADZVY][iS] * fsplus))*dx*dz;
				  }
				
				 

				  break;
	    	default: dSc=0.0; break;
	    }

		// 10.02.2017 вклад тензора скоростей деформаций подходит по размерности.
		
								// ведёт к усилению нижней релаксации.
		// Следующая строка неверна в правую част deltaF вообще никак входить не должна. 
		//sl[iVar][iP].b=Bp+deltaF*Folditer;//Bp+apzero0*Fold+deltaF*Folditer;//+dSc*dx*dy*dz+exptsr+apzero0*Fold;//+attrs;//+deltaF*Folditer; // Внимание ! это всё неверные варианты см. I.Sezai. 
		sl[iVar][iP].b = Bp; // это едиственно правильный вариант.
		if (sl[iVar][iP].b != sl[iVar][iP].b) {
			printf("Bp error NAN or INF  in control volume %d\n", iP);
			system("pause");
		}

	    // под конвективными потоками Fe, Fw, Fn, Fs, Ft, Fb - понимаются итоговые потоки после применения монотонизатора Рхи-Чоу.
		// 02.05.2017
		// Это неверно т.к. приводит к отрицательным диагональным коэффициентам.
		// только этот вариант: deltaF=(Fe-Fw+Fn-Fs+Ft-Fb);
		// единственно верно согласуется с картинками из ANSYS Icepak.
		// Это проявляется на поле давления сразу за обтекаемым тело - там образуется диполь давления.
		//doublereal deltaF=(Fe-Fw+Fn-Fs+Ft-Fb);
		// При точном выполнении уравнения несжимаемости это слагаемое равно нулю.
		// В случае если преобладает истечение или наоборот втечение жидкости в элементарную ячейку (КО)
		// это добавочное слагаемое усиливает диагональное преобладание, на точном выполнении закона сохранения массы 
		// вклад этого слагаемого полностью пропадает.
		// 8.05.2017.
		doublereal deltaF=fabs(Fe-Fw+Fn-Fs+Ft-Fb);
		if (b_on_adaptive_local_refinement_mesh) {
			deltaF = fabs(Fe - Fw + Fn - Fs + Ft - Fb+ Fe2 - Fw2 + Fn2 - Fs2 + Ft2 - Fb2+ Fe3 - Fw3 + Fn3 - Fs3 + Ft3 - Fb3+ Fe4 - Fw4 + Fn4 - Fs4 + Ft4 - Fb4);
		}
		if (deltaF != deltaF) {
			printf("Fe=%e Fw=%e Fn=%e Fs=%e Ft=%e Fb=%e\n",Fe,Fw,Fn,Fs,Ft,Fb);
			printf("Fe2=%e Fw2=%e Fn2=%e Fs2=%e Ft2=%e Fb2=%e\n", Fe2, Fw2, Fn2, Fs2, Ft2, Fb2);
			printf("Fe3=%e Fw3=%e Fn3=%e Fs3=%e Ft3=%e Fb3=%e\n", Fe3, Fw3, Fn3, Fs3, Ft3, Fb3);
			printf("Fe4=%e Fw4=%e Fn4=%e Fs4=%e Ft4=%e Fb4=%e\n", Fe4, Fw4, Fn4, Fs4, Ft4, Fb4);
			printf("ERROR deltaF=%e\n", deltaF);
		}
		// 13 08 2016
		// А это вообще говоря неверно, т.к. его нельзя расщепить по координатным направлениям.
		//doublereal deltaF = fabs(Fe - Fw) + fabs(Fn - Fs) + fabs(Ft - Fb);
		// ну это дивергенция скорости она показывает сколько жидкости истекает из данного объёма за вычетом того что втекает.
		// а модуль берётся просто потому чтобы эта величина была строго положительно. Это связано с тем что диагональный член строго положителен. А единственная цель введения 
		// данного члена deltaF усилить диагональ. При приближении к сходимости deltaF будет всё меньше и меньше и при сошедшемся решении уже не будет оказывать влияния.
		// Мы добавим величину deltaF к диагональному члену матрицы и на первый взгляд  также добавим к правой части deltaF умноженное deltaF*Folditer.
		// Но дело в том что добавление в правую часть значения deltaF*Folditer приводит к несоответствующему физическому смыслу поведению решения, поэтому 
		// так как это сделано у I.Sezai правую часть уравнения лучше вообще не трогать. Т.е. I.Sezai рекомендует вообще ничего не добавлять
		// в правую часть. В итоге мы просто самопроизвольно увеличили диагональный член а это ведёт к нижней релаксации. но нижняя релаксация у нас и так уже присутствует поэтому можно 
		// дополнительно усиливать диагональ здесь (что ведёт к нарушению баланса в уравнении) а можно по всей видимости не трогать deltaF вообще (так предлагает Патанкар).
		// Главное не изменять правую часть уравнения.
		// именно без модуля, см. диполь давления в следе за обтекаемым телом.
		//sumanb+=deltaF;// 0.0 //fmax(0.0,deltaF); // Должен быть именно ноль ненужно ничего здесь добавлять.
		// deltaF - неявный учёт в матрице слау члена b-=Fold*deltaF; Если уравнение неразрывности не выполняется то этот член компенсирует 
		// это невыполнение неразрывности.
		// По видимому если этот член станет отрицательным это может привести к расходимости.
		// Причём расходимость проявляет себя довольно странным образом.
		// Вдруг в коком нибудь из центральных контрольных объёмов или в группе таких объёмов получается очень
		// высокая скорость что приводит к расходимости при решении СЛАУ.
		// Нужно всё оставить именно так как сделано сейчас, см. объяснение выше. Проблемы были потому что было сделано
		// принципиально неправильно. Неправильно: ap+=fmax(0.0,deltaF); причём deltaF бралось без модуля. В общем так делать неверно и нельзя.
		// См. как сделано ниже так и должно быть.
		// Поступим как Патанкар не будем приплетать сюда deltaF т.к. нам очень нужен точный баланс в уравнениях, а deltaF его только нарушит неустранимым способом.
		// deltaF ведёт к дополнительной нижней релаксации, но нижняя релаксация уже определена и равна с коэффициентом alpha==0.7 для скорости.
		// Введение deltaF приведёт к дополнительной нижней релаксации и повидимому изменит реальное alpha, а от alpha зависит псевдовремя и весь алгоритм в целом.
		// уравнения очень чувствительны к выполнению баланса если баланс будет нарушен решение пойдёт в разнос.
		// По видимому если добавлять к диагонали deltaF то deltaF нужно добавлять и к sumanb что это сразу отразилось на псевдовремени.
		if (sl[iVar][iP].ap != sl[iVar][iP].ap) {
			printf("ap!=ap assemble bug. Apriory deltaF. iP=%d ap=%e\n", iP, sl[iVar][iP].ap);
			system("pause");
		}
		//sl[iVar][iP].ap+=deltaF;//-->//sl[iVar][iP].ap+=apzero1+deltaF;//+deltaF; // диагональный элемент матрицы deltaF всегда неотрицательно.  увеличение диагонали 

		sl[iVar][iP].ap += deltaF; // 21.07.2021 - Может отключить вдруг это портит консервативность.
		sumanb += deltaF; // Ну тогда и здесь надо отключить для правоты картины.
		//sl[iVar][iP].b += deltaF * Fold;
			 
	    // По идее добавка к диагонали занижает решение без какой либо компенсации (нет добавки в источниковом члене).
		// Это как бы поглатитеель нескомпенсированный портящий консервативность если она вообще была.

		if (sl[iVar][iP].ap != sl[iVar][iP].ap) {
			printf("ap!=ap assemble bug. Apost deltaF. iP=%d ap=%e\n", iP, sl[iVar][iP].ap);
			system("pause");
		}
								
		
		// по новой информации член Fold*(Fe-Fw+Fn-Fs+Ft-Fb) не влияет на сходимость или конечный результат вычисления.
		// Внимание перепад давления Bp не умножается на объём!!!
		if (!bVERYStable) {
           // sl[iVar][iP].ap+=-dSp*dx*dy*dz;
			//sl[iVar][iP].b+=dSc*dx*dy*dz+exptsr+attrs;
		}

		if (exptsr != exptsr) {
			sl[iVar][iP].b += attrs;// Схема высокой разрешающей способности.
		}
		else {
			//sl[iVar][iP].b += exptsr + attrs; // 21.07.2021 Может отключить exptsr ??? exptsr ни на что не влияет доказано.
			sl[iVar][iP].b += /*exptsr +*/ attrs; // полный закон Ньютона для тензора скоростей деформаций и метод отложенной коррекции для схемы высокой разрешающей способности.
		}
		if (sl[iVar][iP].b != sl[iVar][iP].b) {
			printf("exptsr+attrs error NAN or INF in control volume %d velocity iVar=%lld\n", iP, iVar);
			printf("exptsr=%e attrs=%e\n", exptsr, attrs);
			system("pause");
		}
		
		sl[iVar][iP].b+=dSc*dx*dy*dz; // Архимедова сила всплытия. (тест Валь Девиса, задача Релея-Бенара.)
		if (sl[iVar][iP].b != sl[iVar][iP].b) {
			printf("dSc*dx*dy*dz error NAN or INF in control volume %d\n", iP);
			system("pause");
		}

		if (btimedep) {
			// нестационарный солвер.
			sl[iVar][iP].ap+=apzero1;
			sumanb+=apzero1;
			doublereal b_prev = sl[iVar][iP].b;
			sl[iVar][iP].b+=apzero0*Fold;
			//if (iP == 40) {
				//printf("tau=%e ap=%e ap0=%e Fold=%e bprev=%e bnew=%e\n", tau, sl[iVar][iP].ap, apzero1, Fold, b_prev, sl[iVar][iP].b);
				//getchar();
			//}
		}

		
		
	    // Симметризация матрицы СЛАУ:
		// Граничные узлы обязательно должны собираться в первую очередь.
		// В теории должно получаться эллиптическое уравнение с SPD матрицей.

		// Строка матрицы выглядит примерно следующим образом:
		// -ab ... -as ... -aw ... +ap ... -ae ... -an ... -at == b

		/*

		// Учёт краевых условий Дирихле:
		if ((iE>maxelm) && (slb[iVar][iE-maxelm].iI==(-1))) {
			sl[iVar][iP].b+=sl[iVar][iP].ae*slb[iVar][iE-maxelm].b/slb[iVar][iE-maxelm].aw;
			sl[iVar][iP].ae=0.0;
			sl[iVar][iP].iE=-1;
		}

		if ((iW>maxelm) && (slb[iVar][iW-maxelm].iI==(-1))) {
			sl[iVar][iP].b+=sl[iVar][iP].aw*slb[iVar][iW-maxelm].b/slb[iVar][iW-maxelm].aw;
			sl[iVar][iP].aw=0.0;
			sl[iVar][iP].iW=-1;
		}

		if ((iN>maxelm) && (slb[iVar][iN-maxelm].iI==(-1))) {
			sl[iVar][iP].b+=sl[iVar][iP].an*slb[iVar][iN-maxelm].b/slb[iVar][iN-maxelm].aw;
			sl[iVar][iP].an=0.0;
			sl[iVar][iP].iN=-1;
		}

		if ((iS>maxelm) && (slb[iVar][iS-maxelm].iI==(-1))) {
			sl[iVar][iP].b+=sl[iVar][iP].as*slb[iVar][iS-maxelm].b/slb[iVar][iS-maxelm].aw;
			sl[iVar][iP].as=0.0;
			sl[iVar][iP].iS=-1;
		}

		if ((iT>maxelm) && (slb[iVar][iT-maxelm].iI==(-1))) {
			sl[iVar][iP].b+=sl[iVar][iP].at*slb[iVar][iT-maxelm].b/slb[iVar][iT-maxelm].aw;
			sl[iVar][iP].at=0.0;
			sl[iVar][iP].iT=-1;
		}

		if ((iB>maxelm) && (slb[iVar][iB-maxelm].iI==(-1))) {
			sl[iVar][iP].b+=sl[iVar][iP].ab*slb[iVar][iB-maxelm].b/slb[iVar][iB-maxelm].aw;
			sl[iVar][iP].ab=0.0;
			sl[iVar][iP].iB=-1;
		}

		*/

		if (fabs(sl[iVar][iP].ap) < 1.0e-30) {
			sl[iVar][iP].ap = 1.0;
			switch (iVar) {
			case VELOCITY_X_COMPONENT: sl[iVar][iP].b = potent[VXCOR][iP]; break;
			case VELOCITY_Y_COMPONENT: sl[iVar][iP].b = potent[VYCOR][iP]; break;
			case VELOCITY_Z_COMPONENT: sl[iVar][iP].b = potent[VZCOR][iP]; break;
			}
			if (sl[iVar][iP].b != sl[iVar][iP].b) {
				printf("Zero ap in velocity component.\n");
			}
		}

		

		if (sl[iVar][iP].ap != sl[iVar][iP].ap) {
			printf("ap!=ap assemble bug. iP=%d ap=%e\n",iP, sl[iVar][iP].ap);
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].ae != sl[iVar][iP].ae) {
			printf("ae!=ae assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].aw != sl[iVar][iP].aw) {
			printf("aw!=aw assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].an != sl[iVar][iP].an) {
			printf("an!=an assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].as != sl[iVar][iP].as) {
			printf("as!=as assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].at != sl[iVar][iP].at) {
			printf("at!=at assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].ab != sl[iVar][iP].ab) {
			printf("ab!=ab assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].ae2 != sl[iVar][iP].ae2) {
			printf("ae2!=ae2 assemble bug %e %e\n", sl[iVar][iP].ae2, sl[iVar][iP].ae2);
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].aw2 != sl[iVar][iP].aw2) {
			printf("aw2!=aw2 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].an2 != sl[iVar][iP].an2) {
			printf("an2!=an2 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].as2 != sl[iVar][iP].as2) {
			printf("as2!=as2 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].at2 != sl[iVar][iP].at2) {
			printf("at2!=at2 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].ab2 != sl[iVar][iP].ab2) {
			printf("ab2!=ab2 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].ae3 != sl[iVar][iP].ae3) {
			printf("ae3!=ae3 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].aw3 != sl[iVar][iP].aw3) {
			printf("aw3!=aw3 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].an3 != sl[iVar][iP].an3) {
			printf("an3!=an3 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].as3 != sl[iVar][iP].as3) {
			printf("as3!=as3 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].at3 != sl[iVar][iP].at3) {
			printf("at3!=at3 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].ab3 != sl[iVar][iP].ab3) {
			printf("ab3!=ab3 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].ae4 != sl[iVar][iP].ae4) {
			printf("ae4!=ae4 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].aw4 != sl[iVar][iP].aw4) {
			printf("aw4!=aw4 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].an4 != sl[iVar][iP].an4) {
			printf("an4!=an4 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].as4 != sl[iVar][iP].as4) {
			printf("as4!=as4 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].at4 != sl[iVar][iP].at4) {
			printf("at4!=at4 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}
		if (sl[iVar][iP].ab4 != sl[iVar][iP].ab4) {
			printf("ab4!=ab4 assemble bug\n");
			switch (iVar) {
			case VELOCITY_X_COMPONENT: printf("VX \n"); break;
			case VELOCITY_Y_COMPONENT: printf("VY \n"); break;
			case VELOCITY_Z_COMPONENT: printf("VZ \n"); break;
			}
			system("pause");
		}

} // my_elmatr_quad_F3D


// учёт граничных условий для 
// уравнения теплопроводности
// 25.09.2016 Теперь универсальна и подходит и для АЛИС сетки тоже.
void my_elmatr_quad_T3D_bound(integer inumber, integer maxbound, integer maxelm,
	BOUND* border_neighbor, integer ls, integer lw, WALL* w, SOURCE* s,
	equation3D_bon* &slb, bool bDirichlet, doublereal dbeta,
	int** nvtx, TOCHKA* pa, float** prop, float** prop_b,
	doublereal* potent, doublereal* potent_old, int** ptr, FLOW* &f,
	doublereal poweron_multiplier_sequence) {

	

	bool bsc1 = false;

	// Для opening границы.
	 doublereal tolerance_input = -1.0e-5; // обязательно отрицательная небольшая по модулю величина.
	 // На всей opening границе выставлены условия Дирихле.
	//tolerance_input = -1.0e30;


	// С помощью poweron_multiplier_sequence == 0.0 мощность можно выключить !.
	// bDirichlet   осуществляется сборка только граничных условий Дирихле.
	// bDirichlet == false осуществляется только сборка неоднородных или однородных условий Неймана.
	
	if (qnbc == nullptr) {
		qnbc = new QuickNonlinearBoundaryCondition[maxbound+1];
		iadd_qnbc_maxelm = maxelm;
		// initialization
		for (integer i24 = 0; i24 < maxbound + 1; i24++) {
			qnbc[i24].bactive = false;
			qnbc[i24].bStefanBolcman_q_on = false;
			qnbc[i24].emissivity = 0.0001;
			qnbc[i24].ViewFactor = 1.0;
			qnbc[i24].bNewtonRichman_q_on = false;
			qnbc[i24].film_coefficient = 0.0;
			qnbc[i24].Tamb = 20.0;
			qnbc[i24].dS = 0.0;
		}
	}

	if (bvacuumPrism) {
		breakRUMBAcalc_for_nonlinear_boundary_condition = true;
	}

	/*
	if ((inumber==242-maxelm)||(inumber==245-maxelm)||(inumber==223-maxelm)||(inumber==220-maxelm)) {
	getchar();
	}
	*/

	if (border_neighbor[inumber].MCB == 0) {
		//std::cout << inumber << " ok\n";
		//system("pause");
	}
	

	bool bopening_Neiman_on = false;
	bool bopening_Dirichlet_on = false;
	if ((border_neighbor[inumber].MCB < (ls + lw)) &&
		(border_neighbor[inumber].MCB >= ls) 		
		&& ((w[border_neighbor[inumber].MCB - ls].bopening)||
			((sqrt(w[border_neighbor[inumber].MCB - ls].Vx* w[border_neighbor[inumber].MCB - ls].Vx+
				w[border_neighbor[inumber].MCB - ls].Vy * w[border_neighbor[inumber].MCB - ls].Vy +
				w[border_neighbor[inumber].MCB - ls].Vz * w[border_neighbor[inumber].MCB - ls].Vz)>1.0e-20)&&
				((!w[border_neighbor[inumber].MCB - ls].bopening) &&
				(!w[border_neighbor[inumber].MCB - ls].bpressure) &&
				(!w[border_neighbor[inumber].MCB - ls].bsymmetry))))) {

		if ((w[border_neighbor[inumber].MCB - ls].ifamily == WALL_BOUNDARY_CONDITION::DIRICHLET_FAMILY) ||
			(w[border_neighbor[inumber].MCB - ls].ifamily == WALL_BOUNDARY_CONDITION::NEIMAN_FAMILY)) {

			// opening граница расчётной области. 
			doublereal rsign = 1.0;



			// определение знака величины rsign:
			// внутренняя нормаль на выходной границе расчётной области.
			// Значение скорости теплоносителя будет браться из ближайшей внутренней точки расчётной области,
			// т.к. структура t.ptr передаваемая внутрь данной функции опредлена только для внутренних КО, а не граничных.
			// Мы будем считать, что значение скорости теплоносителя в ближашем к граничному внутреннему узлу есть хорошее приближение
			// для скорости на opening границе.
			if ((ptr != nullptr) && (ptr[1][border_neighbor[inumber].iI] != -1)) {
				switch (border_neighbor[inumber].Norm) {
				case E_SIDE:
					if (f[0].potent[VELOCITY_X_COMPONENT][ptr[0][border_neighbor[inumber].iI]] > tolerance_input) {
						// жидкость втекает внутрь расчётной области через выходную границу.
						rsign = -1.0;
					}
					else rsign = 1.0;
					/*
					if ((!w[border_neighbor[inumber].MCB - ls].bopening) && 
						(!w[border_neighbor[inumber].MCB - ls].bpressure) &&
						(!w[border_neighbor[inumber].MCB - ls].bsymmetry)) {
						if (w[border_neighbor[inumber].MCB - ls].Vx > -fabs(tolerance_input)) {
							// жидкость втекает внутрь расчётной области через выходную границу.
							rsign = -1.0;
						}
						else rsign = 1.0;
					}*/

					break;
				case W_SIDE:
					if (f[0].potent[VELOCITY_X_COMPONENT][ptr[0][border_neighbor[inumber].iI]] < fabs(tolerance_input)) {
						// жидкость втекает внутрь расчётной области через выходную границу.
						rsign = -1.0;
					}
					else rsign = 1.0;
					/*
					if ((!w[border_neighbor[inumber].MCB - ls].bopening) &&
						(!w[border_neighbor[inumber].MCB - ls].bpressure) &&
						(!w[border_neighbor[inumber].MCB - ls].bsymmetry)) {
						if (w[border_neighbor[inumber].MCB - ls].Vx < -fabs(tolerance_input)) {
							// жидкость втекает внутрь расчётной области через выходную границу.
							rsign = -1.0;
						}
						else rsign = 1.0;
					}*/

					break;
				case N_SIDE:
					if (f[0].potent[VELOCITY_Y_COMPONENT][ptr[0][border_neighbor[inumber].iI]] > tolerance_input) {
						// жидкость втекает внутрь расчётной области через выходную границу.
						rsign = -1.0;
					}
					else rsign = 1.0;
					/*
					if ((!w[border_neighbor[inumber].MCB - ls].bopening) &&
						(!w[border_neighbor[inumber].MCB - ls].bpressure) &&
						(!w[border_neighbor[inumber].MCB - ls].bsymmetry)) {
						if (w[border_neighbor[inumber].MCB - ls].Vy > fabs(tolerance_input)) {
							// жидкость втекает внутрь расчётной области через выходную границу.
							rsign = -1.0;
						}
						else rsign = 1.0;
					}*/

					break;
				case S_SIDE:
					if (f[0].potent[VELOCITY_Y_COMPONENT][ptr[0][border_neighbor[inumber].iI]] < fabs(tolerance_input)) {
						// жидкость втекает внутрь расчётной области через выходную границу.
						rsign = -1.0;
					}
					else rsign = 1.0;
					/*
					if ((!w[border_neighbor[inumber].MCB - ls].bopening) &&
						(!w[border_neighbor[inumber].MCB - ls].bpressure) &&
						(!w[border_neighbor[inumber].MCB - ls].bsymmetry)) {
						if (w[border_neighbor[inumber].MCB - ls].Vy < -fabs(tolerance_input)) {
							// жидкость втекает внутрь расчётной области через выходную границу.
							rsign = -1.0;
						}
						else rsign = 1.0;
					}
					*/
					break;
				case T_SIDE:
					if (f[0].potent[VELOCITY_Z_COMPONENT][ptr[0][border_neighbor[inumber].iI]] > tolerance_input) {
						// жидкость втекает внутрь расчётной области через выходную границу.
						rsign = -1.0;
					}
					else rsign = 1.0;
					/*
					if ((!w[border_neighbor[inumber].MCB - ls].bopening) &&
						(!w[border_neighbor[inumber].MCB - ls].bpressure) &&
						(!w[border_neighbor[inumber].MCB - ls].bsymmetry)) {
						if (w[border_neighbor[inumber].MCB - ls].Vz > fabs(tolerance_input)) {
							// жидкость втекает внутрь расчётной области через выходную границу.
							rsign = -1.0;
						}
						else rsign = 1.0;
					}*/

					break;
				case B_SIDE: if (f[0].potent[VELOCITY_Z_COMPONENT][ptr[0][border_neighbor[inumber].iI]] < fabs(tolerance_input)) {
					// жидкость втекает внутрь расчётной области через выходную границу.
					rsign = -1.0;
				}
						   else rsign = 1.0;

					/*
					if ((!w[border_neighbor[inumber].MCB - ls].bopening) &&
						(!w[border_neighbor[inumber].MCB - ls].bpressure) &&
						(!w[border_neighbor[inumber].MCB - ls].bsymmetry)) {
						if (w[border_neighbor[inumber].MCB - ls].Vz < -fabs(tolerance_input)) {
							// жидкость втекает внутрь расчётной области через выходную границу.
							rsign = -1.0;
						}
						else rsign = 1.0;
					}*/

					break;
				} // end switch
			}


			if (rsign >= 0.0) {
				// Жидкость вытекает из расчётной области.
				bopening_Neiman_on = true;
			}
			else {
				bopening_Dirichlet_on = true;
			}

		

		}
		else {
			// На границе opening по температуре стоят условия Ньютона-Рихмана или Стефана-Больцмана.
			// Это недопустимо.
			printf("ERROR!!! Incompatible boundary conditions.\n");
			printf("Flow opening condition. Temperature Stefan-Bolcman or NewTon-Richman condition.\n");
			system("PAUSE");
			exit(1);
		}
	}

	
	if (w[border_neighbor[inumber].MCB - ls].bpressure) {
		// Выходная граница

		// Жидкость вытекает из расчётной области.
		//bopening_Neiman_on = true;
		bopening_Dirichlet_on = true;
	}
	
	/*
	if (iswitchsolveramg_vs_BiCGstab_plus_ILU2 == 0) {
		if ((((border_neighbor[inumber].MCB < (ls + lw)) && (border_neighbor[inumber].MCB >= ls) && (w[border_neighbor[inumber].MCB - ls].ifamily == STEFAN_BOLCMAN_FAMILY)))) {
			breakRUMBAcalc_for_nonlinear_boundary_condition = true;
			//getchar();
		}
	}
	*/

	// inumber - номер граничного КО.
	// inumber изменяется от 0..maxbound-1

	if (bDirichlet && (((border_neighbor[inumber].MCB < (ls + lw)) &&
		(border_neighbor[inumber].MCB >= ls) && (bopening_Dirichlet_on||
		(w[border_neighbor[inumber].MCB - ls].ifamily == WALL_BOUNDARY_CONDITION::DIRICHLET_FAMILY))) ||
		(bBlockStefanBolcman&&(
		(((border_neighbor[inumber].MCB < (ls + lw))
			&& (border_neighbor[inumber].MCB >= ls) && 
			(w[border_neighbor[inumber].MCB - ls].ifamily == WALL_BOUNDARY_CONDITION::STEFAN_BOLCMAN_FAMILY))))))) {

		

		if ((bBlockStefanBolcman && (
			(((border_neighbor[inumber].MCB < (ls + lw)) && (border_neighbor[inumber].MCB >= ls) 
				&& (w[border_neighbor[inumber].MCB - ls].ifamily == WALL_BOUNDARY_CONDITION::STEFAN_BOLCMAN_FAMILY)))))) {
			breakRUMBAcalc_for_nonlinear_boundary_condition = true;
			// Граничное условие Дирихле:
			// Заданная температура на границе.

#if doubleintprecision == 1
			//printf("Dirichlet %lld T=%e\n",inumber, potent[inumber + maxelm]); // debug
#else
			//printf("Dirichlet %d  T=%e\n",inumber, potent[inumber + maxelm]); // debug
#endif
			
			//getchar();

			// температура на границе задана и равна Tamb:
			slb[inumber].aw = 1.0;
			slb[inumber].ai = 0.0;
			//slb[inumber].b = w[border_neighbor[inumber].MCB - ls].Tamb; // Зададим немного завышенную температуру не как в условии Стьефана - Больцмана.
			slb[inumber].b = potent[inumber + maxelm];
			slb[inumber].iI = -1; // не присутствует в матрице
			slb[inumber].iW = border_neighbor[inumber].iB;
		}
		else {
			// Граничное условие Дирихле:
			// Заданная температура на границе.

			

#if doubleintprecision == 1
			//printf("Dirichlet %lld\n",inumber); // debug
#else
			//printf("Dirichlet %d\n",inumber); // debug
#endif
			
			//getchar();

			if (((border_neighbor[inumber].MCB < (ls + lw)) && 
				(border_neighbor[inumber].MCB >= ls) && 
				((bopening_Dirichlet_on)||(w[border_neighbor[inumber].MCB - ls].ifamily == WALL_BOUNDARY_CONDITION::DIRICHLET_FAMILY)))
				||(w[border_neighbor[inumber].MCB - ls].bopening)) {
				// opening граница расчётной области. 
				doublereal rsign = 1.0;

				// определение знака величины rsign:
				// внутренняя нормаль на выходной границе расчётной области.
				// Значение скорости теплоносителя будет браться из ближайшей внутренней точки расчётной области,
				// т.к. структура t.ptr передаваемая внутрь данной функции опредлена только для внутренних КО, а не граничных.
				// Мы будем считать, что значение скорости теплоносителя в ближашем к граничному внутреннему узлу есть хорошее приближение
				// для скорости на opening границе.
				if ((ptr != nullptr) && (ptr[1][border_neighbor[inumber].iI] != -1)) {
					switch (border_neighbor[inumber].Norm) {
					case E_SIDE: if (f[0].potent[VELOCITY_X_COMPONENT][ptr[0][border_neighbor[inumber].iI]] > tolerance_input) {
						// жидкость втекает внутрь расчётной области через выходную границу.
						rsign = -1.0;
					}
							   else rsign = 1.0;
						break;
					case W_SIDE: if (f[0].potent[VELOCITY_X_COMPONENT][ptr[0][border_neighbor[inumber].iI]] < fabs(tolerance_input)) {
						// жидкость втекает внутрь расчётной области через выходную границу.
						rsign = -1.0;
					}
							   else rsign = 1.0;
						break;
					case N_SIDE: if (f[0].potent[VELOCITY_Y_COMPONENT][ptr[0][border_neighbor[inumber].iI]] > tolerance_input) {
						// жидкость втекает внутрь расчётной области через выходную границу.
						rsign = -1.0;
					}
							   else rsign = 1.0;
						break;
					case S_SIDE:if (f[0].potent[VELOCITY_Y_COMPONENT][ptr[0][border_neighbor[inumber].iI]] < fabs(tolerance_input)) {
						// жидкость втекает внутрь расчётной области через выходную границу.
						rsign = -1.0;
					}
							   else rsign = 1.0;
						break;
					case T_SIDE: if (f[0].potent[VELOCITY_Z_COMPONENT][ptr[0][border_neighbor[inumber].iI]] > tolerance_input) {
						// жидкость втекает внутрь расчётной области через выходную границу.
						rsign = -1.0;
					}
							   else rsign = 1.0;
						break;
					case B_SIDE: if (f[0].potent[VELOCITY_Z_COMPONENT][ptr[0][border_neighbor[inumber].iI]] < fabs(tolerance_input)) {
						// жидкость втекает внутрь расчётной области через выходную границу.
						rsign = -1.0;
					}
							   else rsign = 1.0;
						break;
					} // end switch

					//std::cout << rsign << std::endl;

				  // вычисление Температуры на границе расчётной области:
					if (rsign < 0.0) {
						// Жидкость втекает внутрь  расчётной области с заданой температурой.
						// Условия Дирихле для поля температур 
						// при втекании воздуха в расчётную область.
						slb[inumber].aw = 1.0;
						slb[inumber].ai = 0.0;
						if (bopening_Dirichlet_on) {
							if (w[border_neighbor[inumber].MCB - ls].Vx * w[border_neighbor[inumber].MCB - ls].Vx +
								w[border_neighbor[inumber].MCB - ls].Vy * w[border_neighbor[inumber].MCB - ls].Vy +
								w[border_neighbor[inumber].MCB - ls].Vz * w[border_neighbor[inumber].MCB - ls].Vz > 1.0e-30)
							{
								slb[inumber].b = w[border_neighbor[inumber].MCB - ls].Tamb;
							}
							else {
								slb[inumber].b = f[0].OpTemp;
								//std::cout << f[0].OpTemp << std::endl;
							}
						}
						else {
							slb[inumber].b = w[border_neighbor[inumber].MCB - ls].Tamb;
							//std::cout << "inumber="<< inumber <<" incomming Tamb\n";
							//getchar();
						}
						slb[inumber].iI = -1; // не присутствует в матрице
						slb[inumber].iW = border_neighbor[inumber].iB;
						// верно работает.
						//printf("vtekaet Tamb=%e\n", w[border_neighbor[inumber].MCB - ls].Tamb);
						//getchar();
					}
					else if (w[border_neighbor[inumber].MCB - ls].bpressure) {
						// Жидкость вытекает наружу  расчётной области
						// По температуре однородное условие Неймана.
						slb[inumber].aw = 1.0;
						slb[inumber].ai = 1.0;
						slb[inumber].b = 0.0;
						slb[inumber].iI = border_neighbor[inumber].iI; 
						slb[inumber].iW = border_neighbor[inumber].iB;
					}
					else {
						// 20.08.2021 Из за сбоя на естестественной конвекции печь Бриджмена всплытие снизу вверх.
						// температура на границе задана и равна Tamb:
						slb[inumber].aw = 1.0;
						slb[inumber].ai = 0.0;
						slb[inumber].b = w[border_neighbor[inumber].MCB - ls].Tamb;
						slb[inumber].iI = -1; // не присутствует в матрице
						slb[inumber].iW = border_neighbor[inumber].iB;
					}
				}
				else {
					// температура на границе задана и равна Tamb:
					slb[inumber].aw = 1.0;
					slb[inumber].ai = 0.0;
					slb[inumber].b = w[border_neighbor[inumber].MCB - ls].Tamb;
					slb[inumber].iI = -1; // не присутствует в матрице
					slb[inumber].iW = border_neighbor[inumber].iB;
				}
			}
			else {

				// температура на границе задана и равна Tamb:
				slb[inumber].aw = 1.0;
				slb[inumber].ai = 0.0;
				slb[inumber].b = w[border_neighbor[inumber].MCB - ls].Tamb;
				slb[inumber].iI = -1; // не присутствует в матрице
				slb[inumber].iW = border_neighbor[inumber].iB;
			}

		}
		
		//if (border_neighbor[inumber].MCB == 5) {
			///std::cout << "incoming 1` ai= " << slb[inumber].ai << " aw=" << slb[inumber].aw << " b=" << slb[inumber].b << " iI=" << slb[inumber].iI << " iB=" << border_neighbor[inumber].iB << std::endl;
		//}
		

		// Это условие Дирихле:
		// только диагональный элемент
		// не равен нулю.
		slb[inumber].iW1 = -1;
		slb[inumber].iW2 = -1;
		slb[inumber].iW3 = -1;
		slb[inumber].iW4 = -1;
	}
	else if (!bDirichlet && ((border_neighbor[inumber].MCB == (ls + lw)) 
	|| (border_neighbor[inumber].MCB < ls) || bopening_Neiman_on ||
	((border_neighbor[inumber].MCB < (ls + lw)) && (border_neighbor[inumber].MCB >= ls) && 
	(!(bopening_Dirichlet_on ||(w[border_neighbor[inumber].MCB - ls].ifamily == WALL_BOUNDARY_CONDITION::DIRICHLET_FAMILY)))))) {
		// Однородное условие Неймана или неоднородное условие Неймана.
		// Либо условие по умолчанию, либо источник тепла, либо стенка с однородным условием Неймана


		

		doublereal qb = 0.0; // тепловой поток на стенке.
		// Ненулевой тепловой поток может соответствовать только источнику тепла.
		// На стенке WALL может быть задан только нулевой тепловой поток.
		// тепловой поток qb == мощность источника / площадь источника.
		bool bcontinue = true;

		if (!bopening_Neiman_on) {

			// The Stefan - Bolcman condition 23.07.2016.
			if (((border_neighbor[inumber].MCB < (ls + lw)) && 
				(border_neighbor[inumber].MCB >= ls) &&
				(w[border_neighbor[inumber].MCB - ls].ifamily == WALL_BOUNDARY_CONDITION::STEFAN_BOLCMAN_FAMILY))) {

				breakRUMBAcalc_for_nonlinear_boundary_condition = true;

				if (bBlockStefanBolcman) {
					bcontinue = false;
					//printf("bcontinue==false\n");
					//system("PAUSE");
				}
				else {

					doublereal alpha_relax1 = 0.25;
					if (bvacuumPrism) {
						//alpha_relax1 = 8.0*my_amg_manager.theta_Pressure;
					}
					// blocker_Newton_Richman не нужен так как мы получаем однородные условия Неймана на первом прогоне,
					// но температура не успевает сделаться бесконечно большой так как мы делаем всего 5 V - циклов.
					/*
					if (potent[border_neighbor[inumber].iB] > w[border_neighbor[inumber].MCB - ls].Tamb) {
						qb = alpha_relax1 *(-w[border_neighbor[inumber].MCB - ls].emissivity*w[border_neighbor[inumber].MCB - ls].ViewFactor*STEFAN_BOLCMAN_CONST*(( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB]) - ( w[border_neighbor[inumber].MCB - ls].Tamb)*( w[border_neighbor[inumber].MCB - ls].Tamb)*( w[border_neighbor[inumber].MCB - ls].Tamb)*( w[border_neighbor[inumber].MCB - ls].Tamb))) +
							(1.0 - alpha_relax1)*(-w[border_neighbor[inumber].MCB - ls].emissivity*w[border_neighbor[inumber].MCB - ls].ViewFactor*STEFAN_BOLCMAN_CONST*(( potent_old[border_neighbor[inumber].iB])*(potent_old[border_neighbor[inumber].iB])*( potent_old[border_neighbor[inumber].iB])*( potent_old[border_neighbor[inumber].iB]) - (w[border_neighbor[inumber].MCB - ls].Tamb)*( w[border_neighbor[inumber].MCB - ls].Tamb)*( w[border_neighbor[inumber].MCB - ls].Tamb)*(w[border_neighbor[inumber].MCB - ls].Tamb)));
					}
					else {
						//qb = 0.0;
						// Оставим разницу температур в один градус.
						qb = -w[border_neighbor[inumber].MCB - ls].emissivity*w[border_neighbor[inumber].MCB - ls].ViewFactor*STEFAN_BOLCMAN_CONST*((1+ w[border_neighbor[inumber].MCB - ls].Tamb)*(1+ w[border_neighbor[inumber].MCB - ls].Tamb)*(1 + w[border_neighbor[inumber].MCB - ls].Tamb)*(1 + w[border_neighbor[inumber].MCB - ls].Tamb) - (1 + w[border_neighbor[inumber].MCB - ls].Tamb)*(1 + w[border_neighbor[inumber].MCB - ls].Tamb)*(1+ w[border_neighbor[inumber].MCB - ls].Tamb)*(1 + w[border_neighbor[inumber].MCB - ls].Tamb));
					}
					*/
					
					if ((potent[border_neighbor[inumber].iB] < -271.0) && (potent[border_neighbor[inumber].iB] <= w[border_neighbor[inumber].MCB - ls].Tamb))
					{
						// 07.12.2019
						// Защита от опускания температуры ниже абсолютного нуля.
						qb = 0.0;
						//printf("qb zero\n");
						//system("PAUSE");
						// Оставим разницу температур в один градус.
						//qb = -w[border_neighbor[inumber].MCB - ls].emissivity*w[border_neighbor[inumber].MCB - ls].ViewFactor*STEFAN_BOLCMAN_CONST*((274.15 + w[border_neighbor[inumber].MCB - ls].Tamb)*(274.15 + w[border_neighbor[inumber].MCB - ls].Tamb)*(274.15 + w[border_neighbor[inumber].MCB - ls].Tamb)*(274.15 + w[border_neighbor[inumber].MCB - ls].Tamb) - (273.15 + w[border_neighbor[inumber].MCB - ls].Tamb)*(273.15 + w[border_neighbor[inumber].MCB - ls].Tamb)*(273.15 + w[border_neighbor[inumber].MCB - ls].Tamb)*(273.15 + w[border_neighbor[inumber].MCB - ls].Tamb));
					}
					else {

						if (potent[border_neighbor[inumber].iB] < -272.15) {
							potent[border_neighbor[inumber].iB] = -272.15;
						}
						qnbc[inumber].bactive = true;
						qnbc[inumber].bStefanBolcman_q_on = true;
						qnbc[inumber].emissivity = w[border_neighbor[inumber].MCB - ls].emissivity;
						qnbc[inumber].Tamb = w[border_neighbor[inumber].MCB - ls].Tamb;
						qnbc[inumber].ViewFactor = w[border_neighbor[inumber].MCB - ls].ViewFactor;
						bsc1 = true;
						//alpha_relax1 = 1.0;
						qb = alpha_relax1 *(-w[border_neighbor[inumber].MCB - ls].emissivity*w[border_neighbor[inumber].MCB - ls].ViewFactor*STEFAN_BOLCMAN_CONST*
							((273.15 + potent[border_neighbor[inumber].iB])*
							(273.15 + potent[border_neighbor[inumber].iB])*
							(273.15 + potent[border_neighbor[inumber].iB])*
							(273.15 + potent[border_neighbor[inumber].iB]) - 
							(273.15 + w[border_neighbor[inumber].MCB - ls].Tamb)*
							(273.15 + w[border_neighbor[inumber].MCB - ls].Tamb)*
							(273.15 + w[border_neighbor[inumber].MCB - ls].Tamb)*
							(273.15 + w[border_neighbor[inumber].MCB - ls].Tamb))) +
							(1.0 - alpha_relax1)*(-w[border_neighbor[inumber].MCB - ls].emissivity*w[border_neighbor[inumber].MCB - ls].ViewFactor*STEFAN_BOLCMAN_CONST*
							((273.15 + potent_old[border_neighbor[inumber].iB])*
							(273.15 + potent_old[border_neighbor[inumber].iB])*
							(273.15 + potent_old[border_neighbor[inumber].iB])*
							(273.15 + potent_old[border_neighbor[inumber].iB]) -
							(273.15 + w[border_neighbor[inumber].MCB - ls].Tamb)*
							(273.15 + w[border_neighbor[inumber].MCB - ls].Tamb)*
							(273.15 + w[border_neighbor[inumber].MCB - ls].Tamb)*
							(273.15 + w[border_neighbor[inumber].MCB - ls].Tamb)));
						//printf("%e qb=%e\n", potent[border_neighbor[inumber].iB], qb);
						//system("PAUSE");
					}
					
				}
			}

		}
		

		if (bcontinue) {
			
			if (!bopening_Neiman_on) {

				if (((border_neighbor[inumber].MCB < (ls + lw)) && 
					(border_neighbor[inumber].MCB >= ls) &&
					(w[border_neighbor[inumber].MCB - ls].ifamily == WALL_BOUNDARY_CONDITION::NEWTON_RICHMAN_FAMILY))) {
					breakRUMBAcalc_for_nonlinear_boundary_condition = true;


					qnbc[inumber].bactive = true;
					qnbc[inumber].bNewtonRichman_q_on = true;
					qnbc[inumber].film_coefficient = w[border_neighbor[inumber].MCB - ls].film_coefficient;
					qnbc[inumber].Tamb = w[border_neighbor[inumber].MCB - ls].Tamb;
					bsc1 = true;
					// blocker_Newton_Richman не нужен так как мы получаем однородные условия Неймана на первом прогоне,
					// но температура не успевает сделаться бесконечно большой так как мы делаем всего 5 V - циклов. 
					qb = -w[border_neighbor[inumber].MCB - ls].film_coefficient*(potent[border_neighbor[inumber].iB] - w[border_neighbor[inumber].MCB - ls].Tamb);

				}

				// Условие Ньютона-Рихмана. Оно является нелинейным, т.к. значения теплового потока
				// в данном граничном условии зависят от рассчитаной температуры в граничном узле.
				if ((border_neighbor[inumber].MCB == (ls + lw)) && (adiabatic_vs_heat_transfer_coeff == DEFAULT_CABINET_BOUNDARY_CONDITION::NEWTON_RICHMAN_BC)) {
					qnbc[inumber].bactive = true;
					qnbc[inumber].bNewtonRichman_q_on = true;
					qnbc[inumber].film_coefficient = film_coefficient;
					qnbc[inumber].Tamb = operating_temperature_for_film_coeff;
					bsc1 = true;
					// Данное условие обеспечивает ненулевую разницу температур при первом запуске условия Ньютона-Рихмана,
					// Конкретно разница рпавна 20градусов что даст корректную постановку задачи и правильное решении при 
					// условии что процесс нахождения поля температур носит нелинейный характер.
					qb = -film_coefficient*(potent[border_neighbor[inumber].iB] - operating_temperature_for_film_coeff);
					
				}

				// Условие Стефана-Больцмана. Оно является нелинейным, т.к. значения теплового потока
				// в данном граничном условии зависят от рассчитаной температуры в граничном узле.
				if ((border_neighbor[inumber].MCB == (ls + lw)) && (adiabatic_vs_heat_transfer_coeff == DEFAULT_CABINET_BOUNDARY_CONDITION::STEFAN_BOLCMAN_BC)) {
					// border_neighbor[inumber].emissivity хранит значение излучательной способности на границе.

					doublereal alpha_relax1 = 0.25; // Коэффициент нижней релаксации в данном граничном условии.
					if (bvacuumPrism) {
						//alpha_relax1 = 2.0*my_amg_manager.theta_Pressure;
					}
					/*
					if (blocker_Newton_Richman) {
						// Данное условие обеспечивает ненулевую разницу температур при первом запуске условия Стефана-Больцмана,
						// Конкретно разница рпавна 20градусов что даст корректную постановку задачи и правильное решении при
						// условии что процесс нахождения поля температур носит нелинейный характер.
						if (potent[border_neighbor[inumber].iB] > operating_temperature_for_film_coeff) {
							qb = alpha_relax1 *(-border_neighbor[inumber].emissivity*STEFAN_BOLCMAN_CONST*(( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB]) - ( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff))) +
								(1.0 - alpha_relax1)*(-border_neighbor[inumber].emissivity*STEFAN_BOLCMAN_CONST*(( potent_old[border_neighbor[inumber].iB])*( potent_old[border_neighbor[inumber].iB])*( potent_old[border_neighbor[inumber].iB])*( potent_old[border_neighbor[inumber].iB]) - (operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)));
						}
						else {
							qb = 0.0;
						}
					}
					else {
						if (potent[border_neighbor[inumber].iB] > operating_temperature_for_film_coeff) {
							qb = alpha_relax1*(-border_neighbor[inumber].emissivity*STEFAN_BOLCMAN_CONST*(( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB]) - ( operating_temperature_for_film_coeff)*(operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)*(operating_temperature_for_film_coeff))) +
								(1.0 - alpha_relax1)*(-border_neighbor[inumber].emissivity*STEFAN_BOLCMAN_CONST*(( potent_old[border_neighbor[inumber].iB])*( potent_old[border_neighbor[inumber].iB])*( potent_old[border_neighbor[inumber].iB])*(potent_old[border_neighbor[inumber].iB]) - ( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)));
						}
						else {
							qb = 0.0;
						}
					}*/
					if (blocker_Newton_Richman) {
						// Данное условие обеспечивает ненулевую разницу температур при первом запуске условия Стефана-Больцмана,
						// Конкретно разница рпавна 20градусов что даст корректную постановку задачи и правильное решении при 
						// условии что процесс нахождения поля температур носит нелинейный характер.
						if ((potent[border_neighbor[inumber].iB] < -271.0) && (potent[border_neighbor[inumber].iB] <= operating_temperature_for_film_coeff))
						{
							// 07.12.2019
						    // Защита от опускания температуры ниже абсолютного нуля.
							qb = 0.0;
						}
						else {

							if (potent[border_neighbor[inumber].iB] < -272.15) {
								potent[border_neighbor[inumber].iB] = -272.15;
							}
							qnbc[inumber].bactive = true;
							qnbc[inumber].bStefanBolcman_q_on = true;
							qnbc[inumber].emissivity = border_neighbor[inumber].emissivity;
							qnbc[inumber].Tamb = operating_temperature_for_film_coeff;
							qnbc[inumber].ViewFactor = 1.0;
							bsc1 = true;
							qb = alpha_relax1 *(-border_neighbor[inumber].emissivity*STEFAN_BOLCMAN_CONST*
								((273.15 + potent[border_neighbor[inumber].iB])*
								(273.15 + potent[border_neighbor[inumber].iB])*
									(273.15 + potent[border_neighbor[inumber].iB])*
									(273.15 + potent[border_neighbor[inumber].iB]) - 
									(273.15 + operating_temperature_for_film_coeff)*
									(273.15 + operating_temperature_for_film_coeff)*
									(273.15 + operating_temperature_for_film_coeff)*
									(273.15 + operating_temperature_for_film_coeff))) +
								(1.0 - alpha_relax1)*(-border_neighbor[inumber].emissivity*STEFAN_BOLCMAN_CONST*
								((273.15 + potent_old[border_neighbor[inumber].iB])*
									(273.15 + potent_old[border_neighbor[inumber].iB])*
									(273.15 + potent_old[border_neighbor[inumber].iB])*
									(273.15 + potent_old[border_neighbor[inumber].iB]) - 
									(273.15 + operating_temperature_for_film_coeff)*
									(273.15 + operating_temperature_for_film_coeff)*
									(273.15 + operating_temperature_for_film_coeff)*
									(273.15 + operating_temperature_for_film_coeff)));
						}
						
					}
					else {
						if ((potent[border_neighbor[inumber].iB] < -271.0) && (potent[border_neighbor[inumber].iB] <= operating_temperature_for_film_coeff))
						{
							// 07.12.2019
							// Защита от опускания температуры ниже абсолютного нуля.
							qb = 0.0;
						}
						else {

							if (potent[border_neighbor[inumber].iB] < -272.15) {
								potent[border_neighbor[inumber].iB] = -272.15;
							}
							qnbc[inumber].bactive = true;
							qnbc[inumber].bStefanBolcman_q_on = true;
							qnbc[inumber].emissivity = border_neighbor[inumber].emissivity;
							qnbc[inumber].Tamb = operating_temperature_for_film_coeff;
							qnbc[inumber].ViewFactor = 1.0;
							qb = alpha_relax1*(-border_neighbor[inumber].emissivity*STEFAN_BOLCMAN_CONST*
								   ((273.15 + potent[border_neighbor[inumber].iB])*
								    (273.15 + potent[border_neighbor[inumber].iB])*
									(273.15 + potent[border_neighbor[inumber].iB])*
									(273.15 + potent[border_neighbor[inumber].iB]) -
									(273.15 + operating_temperature_for_film_coeff)*
									(273.15 + operating_temperature_for_film_coeff)*
									(273.15 + operating_temperature_for_film_coeff)*
									(273.15 + operating_temperature_for_film_coeff))) +
								(1.0 - alpha_relax1)*(-border_neighbor[inumber].emissivity*STEFAN_BOLCMAN_CONST*
								   ((273.15 + potent_old[border_neighbor[inumber].iB])*
									(273.15 + potent_old[border_neighbor[inumber].iB])*
									(273.15 + potent_old[border_neighbor[inumber].iB])*
									(273.15 + potent_old[border_neighbor[inumber].iB]) -
									(273.15 + operating_temperature_for_film_coeff)*
									(273.15 + operating_temperature_for_film_coeff)*
									(273.15 + operating_temperature_for_film_coeff)*
									(273.15 + operating_temperature_for_film_coeff)));
						}						
					}
				}

				// Условие Ньютона-Рихмана совместно с условием Стефана-Больцмана. Оно является нелинейным, т.к. значения теплового потока
				// в данном граничном условии зависят от рассчитаной температуры в граничном узле.
				if ((border_neighbor[inumber].MCB == (ls + lw)) && (adiabatic_vs_heat_transfer_coeff == DEFAULT_CABINET_BOUNDARY_CONDITION::MIX_CONDITION_BC)) {
					/*
					if (blocker_Newton_Richman) {
						// Данное условие обеспечивает ненулевую разницу температур при первом запуске условия Ньютона-Рихмана,
						// Конкретно разница рпавна 20градусов что даст корректную постановку задачи и правильное решении при
						// условии что процесс нахождения поля температур носит нелинейный характер.
						qb = -film_coefficient*(potent[border_neighbor[inumber].iB] - operating_temperature_for_film_coeff);
						qb = qb - border_neighbor[inumber].emissivity*STEFAN_BOLCMAN_CONST*(( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB]) - ( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)*(operating_temperature_for_film_coeff));

					}
					else {
						qb = -film_coefficient*(potent[border_neighbor[inumber].iB] - operating_temperature_for_film_coeff);
						qb = qb - border_neighbor[inumber].emissivity*STEFAN_BOLCMAN_CONST*(( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB])*( potent[border_neighbor[inumber].iB]) - ( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff)*( operating_temperature_for_film_coeff));
					}
					*/
					
					// Данное условие обеспечивает ненулевую разницу температур при первом запуске условия Ньютона-Рихмана,
					// Конкретно разница рпавна 20градусов что даст корректную постановку задачи и правильное решении при 
					// условии что процесс нахождения поля температур носит нелинейный характер.
					if (potent[border_neighbor[inumber].iB] < -272.15) {
						potent[border_neighbor[inumber].iB] = -272.15;
					}
					qnbc[inumber].bactive = true;
					qnbc[inumber].bStefanBolcman_q_on = true;
					qnbc[inumber].bNewtonRichman_q_on = true;
					qnbc[inumber].emissivity = border_neighbor[inumber].emissivity;
					qnbc[inumber].film_coefficient = film_coefficient;
					qnbc[inumber].Tamb = operating_temperature_for_film_coeff;
					qnbc[inumber].ViewFactor = 1.0;
					bsc1 = true;
					qb = -film_coefficient*(potent[border_neighbor[inumber].iB] - operating_temperature_for_film_coeff);
					qb = qb - border_neighbor[inumber].emissivity*STEFAN_BOLCMAN_CONST*
						((273.15 + potent[border_neighbor[inumber].iB])*
						(273.15 + potent[border_neighbor[inumber].iB])*
							(273.15 + potent[border_neighbor[inumber].iB])*
							(273.15 + potent[border_neighbor[inumber].iB]) - 
							(273.15 + operating_temperature_for_film_coeff)*
							(273.15 + operating_temperature_for_film_coeff)*
							(273.15 + operating_temperature_for_film_coeff)*
							(273.15 + operating_temperature_for_film_coeff));

					
				}

				

				if (bsc1) {
					b_sign_on_nonlinear_bc = true;
				}

			}
			else {

			

				// opening граница через которую воздух покидает расчётную область.
				// Граничное условие является линейным, поставлено однородное условие Неймана по температуре.
				qnbc[inumber].bactive = false;
				qnbc[inumber].bStefanBolcman_q_on = false;
				qnbc[inumber].bNewtonRichman_q_on = false;
				qnbc[inumber].emissivity = 0.001;
				qnbc[inumber].film_coefficient = 0.001;
				qnbc[inumber].Tamb = f[0].OpTemp;
				qnbc[inumber].ViewFactor = 1.0;
				qb = 0.0;
			}

			bool b1 = false;
			if (border_neighbor[inumber].MCB < ls) {
				// нужно только учесть направление (здесь всё верно).
				// qb=poweron_multiplier_sequence*s[border_neighbor[inumber].MCB].power/s[border_neighbor[inumber].MCB].square;
				// b1=true;// отключено.
			}

			

			doublereal dl=0.0, dS=0.0; // геометрические параметры
			//doublereal deltal;
			//doublereal lami; // теплопроводность на грани КО
			//doublereal fiplus; // учёт неравномерности сетки

			doublereal lamB= 0.0, lamI=0.0, lamII=0.0; // теплопроводность
			const doublereal dTurbulentPrandtlNumber = 0.85;

			//printf("qb=%e\n", qb);
			//system("PAUSE");

			// внутренняя нормаль
			switch (border_neighbor[inumber].Norm) {
			case E_SIDE:
				dl = pa[nvtx[1][border_neighbor[inumber].iI] - 1].x - pa[nvtx[0][border_neighbor[inumber].iI] - 1].x;
				//dS = pa[nvtx[2][border_neighbor[inumber].iI] - 1].y - pa[nvtx[1][border_neighbor[inumber].iI] - 1].y;
				//dS *= (pa[nvtx[4][border_neighbor[inumber].iI] - 1].z - pa[nvtx[0][border_neighbor[inumber].iI] - 1].z); // площадь грани
				dS = border_neighbor[inumber].dS; // Площадь грани 25.09.2016.

				// коэффициент теплопроводности
				lamB = prop_b[LAM][border_neighbor[inumber].iB - maxelm];
				lamI = prop[LAM][border_neighbor[inumber].iI];
				if (border_neighbor[inumber].iII >= maxelm) {
					lamII = prop_b[LAM][border_neighbor[inumber].iII - maxelm];
				}
				else {
					if (border_neighbor[inumber].iII < 0) {
						//printf("error acsess %d\n ", border_neighbor[inumber].iII);
						//system("PAUSE");
						lamII = prop[LAM][border_neighbor[inumber].iI];
					}
					else {
						lamII = prop[LAM][border_neighbor[inumber].iII];
					}
				}

				// Ортотропность.
				lamB *= prop[MULT_LAM_X][border_neighbor[inumber].iI];
				lamI *= prop[MULT_LAM_X][border_neighbor[inumber].iI];
				lamII *= prop[MULT_LAM_X][border_neighbor[inumber].iI];


				/*
				if ((ptr!=nullptr) && (ptr[1][border_neighbor[inumber].iI]!=-1)) {
				lamB+=prop_b[HEAT_CAPACITY][border_neighbor[inumber].iB-maxelm]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][f[ptr[1][border_neighbor[inumber].iI]].neighbors_for_the_internal_node[WSIDE][0][ptr[0][border_neighbor[inumber].iI]]]/dTurbulentPrandtlNumber;
				lamI+=prop[HEAT_CAPACITY][border_neighbor[inumber].iI]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][ptr[0][border_neighbor[inumber].iI]]/dTurbulentPrandtlNumber;
				lamII+=prop[HEAT_CAPACITY][border_neighbor[inumber].iII]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][ptr[0][border_neighbor[inumber].iII]]/dTurbulentPrandtlNumber;
				}
				*/

				// экспериментально установлено, что надо делать теплопроводности равными на границе и в ближайшем внутреннем узле,
				// иначе можно получить нереальную температуру. 4 апреля 2013 года.
				// Нереальность проявляется в сильнейшем завышении температуры, причиной этому является неравенство коэффициентов когда источник находится на
				// границе между воздухом и твёрдым телом.
				// Кстати, невыполнение этого условия может негативно сказаться и на гидродинамической составляющей.
				lamB = lamI;


				if (b1) {
					//  среднее гармоническое на грани.
					lamB = conductivity2Dinsource[inumber];
				}

				slb[inumber].ai = 2.0*dbeta*lamB*dS / dl;
				slb[inumber].iI = border_neighbor[inumber].iI;
				slb[inumber].aw = slb[inumber].ai;
				slb[inumber].iW = border_neighbor[inumber].iB;

				//deltal=0.5*(pa[nvtx[1][border_neighbor[inumber].iII]-1].x+pa[nvtx[0][border_neighbor[inumber].iII]-1].x);
				//deltal-=0.5*(pa[nvtx[1][border_neighbor[inumber].iI]-1].x+pa[nvtx[0][border_neighbor[inumber].iI]-1].x);
				//fiplus=0.5*dl/deltal;

				//lami=(lamI*lamII)/((1.0-fiplus)*lamI+fiplus*lamII); // проверено

				// правая часть
				slb[inumber].b = 0;
				//slb[inumber].b=(dbeta-1.0)*lami*dS*(potent[border_neighbor[inumber].iI]-potent[border_neighbor[inumber].iII])/deltal;
				slb[inumber].b += qb*dS;

				break;

			case N_SIDE:
				dl = pa[nvtx[2][border_neighbor[inumber].iI] - 1].y - pa[nvtx[0][border_neighbor[inumber].iI] - 1].y;
				//dS = pa[nvtx[1][border_neighbor[inumber].iI] - 1].x - pa[nvtx[0][border_neighbor[inumber].iI] - 1].x;
				//dS *= (pa[nvtx[4][border_neighbor[inumber].iI] - 1].z - pa[nvtx[0][border_neighbor[inumber].iI] - 1].z); // площадь грани
				dS = border_neighbor[inumber].dS; // Площадь грани 25.09.2016.

				// коэффициент теплопроводности
				lamB = prop_b[LAM][border_neighbor[inumber].iB - maxelm];
				lamI = prop[LAM][border_neighbor[inumber].iI];
				if (border_neighbor[inumber].iII >= maxelm) {
					lamII = prop_b[LAM][border_neighbor[inumber].iII - maxelm];
				}
				else {
					if (border_neighbor[inumber].iII < 0) {
						lamII = prop[LAM][border_neighbor[inumber].iI];
					}
					else {
						lamII = prop[LAM][border_neighbor[inumber].iII];
					}
				}

				// Ортотропность.
				lamB *= prop[MULT_LAM_Y][border_neighbor[inumber].iI];
				lamI *= prop[MULT_LAM_Y][border_neighbor[inumber].iI];
				lamII *= prop[MULT_LAM_Y][border_neighbor[inumber].iI];

				/*
				if ((ptr!=nullptr) && (ptr[1][border_neighbor[inumber].iI]!=-1)) {
				lamB+=prop_b[HEAT_CAPACITY][border_neighbor[inumber].iB-maxelm]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][f[ptr[1][border_neighbor[inumber].iI]].neighbors_for_the_internal_node[SSIDE][0][ptr[0][border_neighbor[inumber].iI]]]/dTurbulentPrandtlNumber;
				lamI+=prop[HEAT_CAPACITY][border_neighbor[inumber].iI]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][ptr[0][border_neighbor[inumber].iI]]/dTurbulentPrandtlNumber;
				lamII+=prop[HEAT_CAPACITY][border_neighbor[inumber].iII]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][ptr[0][border_neighbor[inumber].iII]]/dTurbulentPrandtlNumber;
				}
				*/

				// экспериментально установлено, что надо делать теплопроводности равными на границе и в ближайшем внутреннем узле,
				// иначе можно получить нереальную температуру. 4 апреля 2013 года.
				lamB = lamI;

				if (b1) {
					//  среднее гармоническое на грани.
					lamB = conductivity2Dinsource[inumber];
				}

				slb[inumber].ai = 2.0*dbeta*lamB*dS / dl;
				slb[inumber].iI = border_neighbor[inumber].iI;
				slb[inumber].aw = slb[inumber].ai;
				slb[inumber].iW = border_neighbor[inumber].iB;

				//deltal=0.5*(pa[nvtx[2][border_neighbor[inumber].iII]-1].y+pa[nvtx[0][border_neighbor[inumber].iII]-1].y);
				//deltal-=0.5*(pa[nvtx[2][border_neighbor[inumber].iI]-1].y+pa[nvtx[0][border_neighbor[inumber].iI]-1].y);
				//fiplus=0.5*dl/deltal;

				// lami=(lamI*lamII)/((1.0-fiplus)*lamI+fiplus*lamII); // проверено

				// правая часть
				slb[inumber].b = 0;
				//slb[inumber].b=(dbeta-1.0)*lami*dS*(potent[border_neighbor[inumber].iI]-potent[border_neighbor[inumber].iII])/deltal;
				slb[inumber].b += qb*dS;
				//printf("source=%e\n",qb*dS); getchar(); // debug

				break;

			case T_SIDE: 
				dl = pa[nvtx[4][border_neighbor[inumber].iI] - 1].z - pa[nvtx[0][border_neighbor[inumber].iI] - 1].z;
				//dS = pa[nvtx[1][border_neighbor[inumber].iI] - 1].x - pa[nvtx[0][border_neighbor[inumber].iI] - 1].x;
				//dS *= (pa[nvtx[2][border_neighbor[inumber].iI] - 1].y - pa[nvtx[0][border_neighbor[inumber].iI] - 1].y); // площадь грани
				dS = border_neighbor[inumber].dS; // Площадь грани 25.09.2016.

				// коэффициент теплопроводности
				lamB = prop_b[LAM][border_neighbor[inumber].iB - maxelm];
				lamI = prop[LAM][border_neighbor[inumber].iI];
				if (border_neighbor[inumber].iII >= maxelm) {
					lamII = prop_b[LAM][border_neighbor[inumber].iII - maxelm];
				}
				else {
					if (border_neighbor[inumber].iII < 0) {
						lamII = prop[LAM][border_neighbor[inumber].iI];
					}
					else {
						lamII = prop[LAM][border_neighbor[inumber].iII];
					}
				}

				// Ортотропность.
				lamB *= prop[MULT_LAM_Z][border_neighbor[inumber].iI];
				lamI *= prop[MULT_LAM_Z][border_neighbor[inumber].iI];
				lamII *= prop[MULT_LAM_Z][border_neighbor[inumber].iI];

				/*
				if ((ptr!=nullptr) && (ptr[1][border_neighbor[inumber].iI]!=-1)) {
				lamB+=prop_b[HEAT_CAPACITY][border_neighbor[inumber].iB-maxelm]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][f[ptr[1][border_neighbor[inumber].iI]].neighbors_for_the_internal_node[BSIDE][0][ptr[0][border_neighbor[inumber].iI]]]/dTurbulentPrandtlNumber;
				lamI+=prop[HEAT_CAPACITY][border_neighbor[inumber].iI]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][ptr[0][border_neighbor[inumber].iI]]/dTurbulentPrandtlNumber;
				lamII+=prop[HEAT_CAPACITY][border_neighbor[inumber].iII]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][ptr[0][border_neighbor[inumber].iII]]/dTurbulentPrandtlNumber;
				}
				*/

				// экспериментально установлено, что надо делать теплопроводности равными на границе и в ближайшем внутреннем узле,
				// иначе можно получить нереальную температуру. 4 апреля 2013 года.
				lamB = lamI;

				if (b1) {
					//  среднее гармоническое на грани.
					lamB = conductivity2Dinsource[inumber];
				}

				slb[inumber].ai = 2.0*dbeta*lamB*dS / dl;
				slb[inumber].iI = border_neighbor[inumber].iI;
				slb[inumber].aw = slb[inumber].ai;
				slb[inumber].iW = border_neighbor[inumber].iB;

				//deltal=0.5*(pa[nvtx[4][border_neighbor[inumber].iII]-1].z+pa[nvtx[0][border_neighbor[inumber].iII]-1].z);
				//deltal-=0.5*(pa[nvtx[4][border_neighbor[inumber].iI]-1].z+pa[nvtx[0][border_neighbor[inumber].iI]-1].z);
				//fiplus=0.5*dl/deltal;

				//lami=(lamI*lamII)/((1.0-fiplus)*lamI+fiplus*lamII); // проверено.

				// правая часть
				slb[inumber].b = 0.0;
				//slb[inumber].b=(dbeta-1.0)*lami*dS*(potent[border_neighbor[inumber].iI]-potent[border_neighbor[inumber].iII])/deltal;
				slb[inumber].b += qb*dS;

				break;

			case W_SIDE:
				dl = pa[nvtx[1][border_neighbor[inumber].iI] - 1].x - pa[nvtx[0][border_neighbor[inumber].iI] - 1].x;
				//dS = pa[nvtx[2][border_neighbor[inumber].iI] - 1].y - pa[nvtx[1][border_neighbor[inumber].iI] - 1].y;
				//dS *= (pa[nvtx[4][border_neighbor[inumber].iI] - 1].z - pa[nvtx[0][border_neighbor[inumber].iI] - 1].z); // площадь грани
				dS = border_neighbor[inumber].dS; // Площадь грани 25.09.2016.


				// коэффициент теплопроводности
				lamB = prop_b[LAM][border_neighbor[inumber].iB - maxelm];
				lamI = prop[LAM][border_neighbor[inumber].iI];
				if (border_neighbor[inumber].iII >= maxelm) {
					lamII = prop_b[LAM][border_neighbor[inumber].iII - maxelm];
				}
				else {
					if (border_neighbor[inumber].iII < 0) {
						lamII = prop[LAM][border_neighbor[inumber].iI];
					}
					else {
						lamII = prop[LAM][border_neighbor[inumber].iII];
					}
				}

				// Ортотропность.
				lamB *= prop[MULT_LAM_X][border_neighbor[inumber].iI];
				lamI *= prop[MULT_LAM_X][border_neighbor[inumber].iI];
				lamII *= prop[MULT_LAM_X][border_neighbor[inumber].iI];

				/*
				if ((ptr!=nullptr) && (ptr[1][border_neighbor[inumber].iI]!=-1)) {
				lamB+=prop_b[HEAT_CAPACITY][border_neighbor[inumber].iB-maxelm]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][f[ptr[1][border_neighbor[inumber].iI]].neighbors_for_the_internal_node[ESIDE][0][ptr[0][border_neighbor[inumber].iI]]]/dTurbulentPrandtlNumber;
				lamI+=prop[HEAT_CAPACITY][border_neighbor[inumber].iI]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][ptr[0][border_neighbor[inumber].iI]]/dTurbulentPrandtlNumber;
				lamII+=prop[HEAT_CAPACITY][border_neighbor[inumber].iII]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][ptr[0][border_neighbor[inumber].iII]]/dTurbulentPrandtlNumber;
				}
				*/

				// экспериментально установлено, что надо делать теплопроводности равными на границе и в ближайшем внутреннем узле,
				// иначе можно получить нереальную температуру. 4 апреля 2013 года.
				lamB = lamI;

				if (b1) {
					//  среднее гармоническое на грани.
					lamB = conductivity2Dinsource[inumber];
				}

				slb[inumber].ai = 2.0*dbeta*lamB*dS / dl;
				slb[inumber].iI = border_neighbor[inumber].iI;
				slb[inumber].aw = slb[inumber].ai;
				slb[inumber].iW = border_neighbor[inumber].iB;

				//deltal=-0.5*(pa[nvtx[1][border_neighbor[inumber].iII]-1].x+pa[nvtx[0][border_neighbor[inumber].iII]-1].x);
				//deltal+=0.5*(pa[nvtx[1][border_neighbor[inumber].iI]-1].x+pa[nvtx[0][border_neighbor[inumber].iI]-1].x);
				//fiplus=0.5*dl/deltal;

				//lami=(lamI*lamII)/((1.0-fiplus)*lamI+fiplus*lamII); // проверено.

				// правая часть
				// ВНИМАНИЕ !!! Если будет нефизичное решение при dbeta > 1 то возможно нужно поменять местами I и II!!!!
				slb[inumber].b = 0;
				//slb[inumber].b=(dbeta-1.0)*lami*dS*(potent[border_neighbor[inumber].iI]-potent[border_neighbor[inumber].iII])/deltal;
				slb[inumber].b += qb*dS;


				break;

			case S_SIDE: 
				dl = pa[nvtx[2][border_neighbor[inumber].iI] - 1].y - pa[nvtx[0][border_neighbor[inumber].iI] - 1].y;
				//dS = pa[nvtx[1][border_neighbor[inumber].iI] - 1].x - pa[nvtx[0][border_neighbor[inumber].iI] - 1].x;
				//dS *= (pa[nvtx[4][border_neighbor[inumber].iI] - 1].z - pa[nvtx[0][border_neighbor[inumber].iI] - 1].z); // площадь грани
				dS = border_neighbor[inumber].dS; // Площадь грани 25.09.2016.


				// коэффициент теплопроводности
				lamB = prop_b[LAM][border_neighbor[inumber].iB - maxelm];
				lamI = prop[LAM][border_neighbor[inumber].iI];
				if (border_neighbor[inumber].iII >= maxelm) {
					lamII = prop_b[LAM][border_neighbor[inumber].iII - maxelm];
				}
				else {
					if (border_neighbor[inumber].iII < 0) {
						lamII = prop[LAM][border_neighbor[inumber].iI];
					}
					else {
						lamII = prop[LAM][border_neighbor[inumber].iII];
					}
				}

				// Ортотропность.
				lamB *= prop[MULT_LAM_Y][border_neighbor[inumber].iI];
				lamI *= prop[MULT_LAM_Y][border_neighbor[inumber].iI];
				lamII *= prop[MULT_LAM_Y][border_neighbor[inumber].iI];

				/*
				if ((ptr!=nullptr) && (ptr[1][border_neighbor[inumber].iI]!=-1)) {
				lamB+=prop_b[HEAT_CAPACITY][border_neighbor[inumber].iB-maxelm]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][f[ptr[1][border_neighbor[inumber].iI]].neighbors_for_the_internal_node[NSIDE][0][ptr[0][border_neighbor[inumber].iI]]]/dTurbulentPrandtlNumber;
				lamI+=prop[HEAT_CAPACITY][border_neighbor[inumber].iI]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][ptr[0][border_neighbor[inumber].iI]]/dTurbulentPrandtlNumber;
				lamII+=prop[HEAT_CAPACITY][border_neighbor[inumber].iII]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][ptr[0][border_neighbor[inumber].iII]]/dTurbulentPrandtlNumber;
				}
				*/

				// экспериментально установлено, что надо делать теплопроводности равными на границе и в ближайшем внутреннем узле,
				// иначе можно получить нереальную температуру. 4 апреля 2013 года.
				lamB = lamI;

				if (b1) {
					//  среднее гармоническое на грани.
					lamB = conductivity2Dinsource[inumber];
				}

				slb[inumber].ai = 2.0*dbeta*lamB*dS / dl;
				slb[inumber].iI = border_neighbor[inumber].iI;
				slb[inumber].aw = slb[inumber].ai;
				slb[inumber].iW = border_neighbor[inumber].iB;

				//deltal=-0.5*(pa[nvtx[2][border_neighbor[inumber].iII]-1].y+pa[nvtx[0][border_neighbor[inumber].iII]-1].y);
				//deltal+=0.5*(pa[nvtx[2][border_neighbor[inumber].iI]-1].y+pa[nvtx[0][border_neighbor[inumber].iI]-1].y);
				//fiplus=0.5*dl/deltal;

				//lami=(lamI*lamII)/((1.0-fiplus)*lamI+fiplus*lamII); // проверено.

				// правая часть
				slb[inumber].b = 0;
				//slb[inumber].b=(dbeta-1.0)*lami*dS*(potent[border_neighbor[inumber].iI]-potent[border_neighbor[inumber].iII])/deltal;
				slb[inumber].b += qb*dS;
				//printf("source=%e\n",qb*dS); getchar(); // debug

				break;

			case B_SIDE:
				dl = pa[nvtx[4][border_neighbor[inumber].iI] - 1].z - pa[nvtx[0][border_neighbor[inumber].iI] - 1].z;
				//dS = pa[nvtx[1][border_neighbor[inumber].iI] - 1].x - pa[nvtx[0][border_neighbor[inumber].iI] - 1].x;
				//dS *= (pa[nvtx[2][border_neighbor[inumber].iI] - 1].y - pa[nvtx[0][border_neighbor[inumber].iI] - 1].y); // площадь грани
				dS = border_neighbor[inumber].dS; // Площадь грани 25.09.2016.

				

				// коэффициент теплопроводности
				lamB = prop_b[LAM][border_neighbor[inumber].iB - maxelm];
				lamI = prop[LAM][border_neighbor[inumber].iI];
				if (border_neighbor[inumber].iII >= maxelm) {
					lamII = prop_b[LAM][border_neighbor[inumber].iII-maxelm];
				}
				else {
					if (border_neighbor[inumber].iII < 0) {
						lamII = prop[LAM][border_neighbor[inumber].iI];
					}
					else {
						lamII = prop[LAM][border_neighbor[inumber].iII];
					}
				}

				// Ортотропность.
				lamB *= prop[MULT_LAM_Z][border_neighbor[inumber].iI];
				lamI *= prop[MULT_LAM_Z][border_neighbor[inumber].iI];
				lamII *= prop[MULT_LAM_Z][border_neighbor[inumber].iI];

				/*
				if ((ptr!=nullptr) && (ptr[1][border_neighbor[inumber].iI]!=-1)) {
				//printf("add turbulent conductivity...\n");
				//getchar();
				lamB+=prop_b[HEAT_CAPACITY][border_neighbor[inumber].iB-maxelm]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][f[ptr[1][border_neighbor[inumber].iI]].neighbors_for_the_internal_node[TSIDE][0][ptr[0][border_neighbor[inumber].iI]]]/dTurbulentPrandtlNumber;
				lamI+=prop[HEAT_CAPACITY][border_neighbor[inumber].iI]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][ptr[0][border_neighbor[inumber].iI]]/dTurbulentPrandtlNumber;
				lamII+=prop[HEAT_CAPACITY][border_neighbor[inumber].iII]*f[ptr[1][border_neighbor[inumber].iI]].potent[MUT][ptr[0][border_neighbor[inumber].iII]]/dTurbulentPrandtlNumber;
				}
				*/

				// экспериментально установлено, что надо делать теплопроводности равными на границе и в ближайшем внутреннем узле,
				// иначе можно получить нереальную температуру. 4 апреля 2013 года.
				lamB = lamI;

				if (b1) {
					//  среднее гармоническое на грани.
					lamB = conductivity2Dinsource[inumber];
				}

				slb[inumber].ai = 2.0*dbeta*lamB*dS / dl;
				slb[inumber].iI = border_neighbor[inumber].iI;
				slb[inumber].aw = slb[inumber].ai;
				slb[inumber].iW = border_neighbor[inumber].iB;

				//printf("lamB=%e\n",lamB); // debug
				//getchar();

				//deltal=-0.5*(pa[nvtx[4][border_neighbor[inumber].iII]-1].z+pa[nvtx[0][border_neighbor[inumber].iII]-1].z);
				//deltal+=0.5*(pa[nvtx[4][border_neighbor[inumber].iI]-1].z+pa[nvtx[0][border_neighbor[inumber].iI]-1].z);
				//fiplus=0.5*dl/deltal;

				//lami=(lamI*lamII)/((1.0-fiplus)*lamI+fiplus*lamII); // проверено.
				//printf("fi_plus = %e\n",fiplus); 
				//getchar();

				// правая часть
				slb[inumber].b = 0.0;
				//slb[inumber].b=(dbeta-1.0)*lami*dS*(potent[border_neighbor[inumber].iI]-potent[border_neighbor[inumber].iII])/deltal;
				slb[inumber].b += qb*dS;

				//printf("heat flux = %e\n",qb); 
				//getchar();

				break;

			} // end switch

			if (bsc1) {
				qnbc[inumber].dS = dS;
			}

			

			integer j, l, xitem, k;
			// сортировка по возрастанию
			for (j = 0; j < 5; j++) {
				k = j; xitem = border_neighbor[inumber].iW[j];
				for (l = j + 1; l < 6; l++) {
					if (border_neighbor[inumber].iW[l] < xitem) {
						k = l; xitem = border_neighbor[inumber].iW[k];
					}
				}
				border_neighbor[inumber].iW[k] = border_neighbor[inumber].iW[j];
				border_neighbor[inumber].iW[j] = xitem;
			}

			j = 0; l = 0;
			while ((j < 6)&&(border_neighbor[inumber].iW[j] == (-1))) j++;

			if (j < 6) { slb[inumber].iW1 = border_neighbor[inumber].iW[j++]; l++; }
			if (j < 6) { slb[inumber].iW2 = border_neighbor[inumber].iW[j++]; l++; }
			if (j < 6) { slb[inumber].iW3 = border_neighbor[inumber].iW[j++]; l++; }
			if (j < 6) { slb[inumber].iW4 = border_neighbor[inumber].iW[j++]; l++; }

			switch (l) {
			case 0: slb[inumber].iW1 = -1;
				slb[inumber].iW2 = -1;
				slb[inumber].iW3 = -1;
				slb[inumber].iW4 = -1;
				break;
			case 1: slb[inumber].iW2 = -1;
				slb[inumber].iW3 = -1;
				slb[inumber].iW4 = -1;
				break;
			case 2: slb[inumber].iW3 = -1;
				slb[inumber].iW4 = -1;
				break;
			case 3: slb[inumber].iW4 = -1;
				break;
			}

			// Наложения исключения в случае совпадения узла iI с диагональным 
			// элементом узла для котторого стоит условие Дирихле не требуется. 
			// т.к. узлы iI строго внутренние для которых iI < maxelm, а диагональный 
			// элемент с условием Дирихле стоит в позициях >= maxelm поэтому они не
			// пересекаются.
		}
	
		
		//if (border_neighbor[inumber].MCB == 5) {
			//std::cout << "incoming 2` ai " << slb[inumber].ai << " aw=" << slb[inumber].aw << " b=" << slb[inumber].b << " iI=" << slb[inumber].iI << " iB=" << border_neighbor[inumber].iB << std::endl;
		//}

}



//if (bDirichlet&&(border_neighbor[inumber].MCB == (ls + lw)) &&(slb[inumber].aw>1.0e-30)&&(slb[inumber].ai < 1.0e-30)&&
	//(adiabatic_vs_heat_transfer_coeff == DEFAULT_CABINET_BOUNDARY_CONDITION::ADIABATIC_WALL_BC)) {
	/*slb[inumber].ai = 1.0;
			slb[inumber].aw = 1.0;
			slb[inumber].b = 0.0;

			slb[inumber].iI = border_neighbor[inumber].iI;
			slb[inumber].iW = border_neighbor[inumber].iB;*/

	//if (fabs(slb[inumber].b) > 1.0e-20)
//	{
	//	std::cout << "tochnoe popadanie Dirichlet zero\n";
		//std::cout << "inumber = " << inumber << std::endl;
		//std::cout << "ai=" << slb[inumber].ai << " iI=" << slb[inumber].iI << " aw=" << slb[inumber].aw << " iW=" << slb[inumber].iW << " b=" << slb[inumber].b << std::endl;
		//printf("ai=%e iI=%d aw=%e iW=%d b=%e\n", slb[inumber].ai, slb[inumber].iI, slb[inumber].aw, slb[inumber].iW, slb[inumber].b);
		//std::cout << "border_neighbor[" << inumber << "].MCB ==" << border_neighbor[inumber].MCB << " ls=" << ls << " lw=" << lw << " ls+lw=" << ls + lw << std::endl;
		//printf("border_neighbor[inumber].MCB == %lld ls=%lld lw=%lld ls+lw=%lld\n", border_neighbor[inumber].MCB, ls, lw, ls+lw);
		//system("PAUSE");
	//}
//}
//else if( !bDirichlet && (w[border_neighbor[inumber].MCB - ls].bsymmetry)) {
	//if (fabs(slb[inumber].b) > 1.0e-20) {
		//std::cout << "SYMMETRY\n";
		//std::cout << "inumber = " << inumber << std::endl;
		//std::cout << "w.Tamb" << w[border_neighbor[inumber].MCB - ls].Tamb << std::endl;
		//std::cout << "ai=" << slb[inumber].ai << " iI=" << slb[inumber].iI << " aw=" << slb[inumber].aw << " iW=" << slb[inumber].iW << " b=" << slb[inumber].b << std::endl;
		//printf("ai=%e iI=%d aw=%e iW=%d b=%e\n", slb[inumber].ai, slb[inumber].iI, slb[inumber].aw, slb[inumber].iW, slb[inumber].b);
		//std::cout << "border_neighbor[" << inumber << "].MCB ==" << border_neighbor[inumber].MCB << " ls=" << ls << " lw=" << lw << " ls+lw=" << ls + lw << std::endl;
		//printf("border_neighbor[inumber].MCB == %lld ls=%lld lw=%lld ls+lw=%lld\n", border_neighbor[inumber].MCB, ls, lw, ls+lw);
		//system("PAUSE");
	//}
//}
//else if (bDirichlet&&(border_neighbor[inumber].MCB < (ls + lw)) && 
	//(!w[border_neighbor[inumber].MCB - ls].bsymmetry) &&
	//(!((slb[inumber].b == 26.0) || (slb[inumber].b == 40.0)||((border_neighbor[inumber].MCB==2)&&(slb[inumber].b == 20.0)&&(slb[inumber].iI==-1))))) {
	//std::cout << "Dirichlet\n";
	//std::cout << "w.Tamb" << w[border_neighbor[inumber].MCB - ls].Tamb << std::endl;
	//std::cout << "inumber = " << inumber << std::endl;
	//std::cout << "ai=" << slb[inumber].ai << " iI=" << slb[inumber].iI << " aw=" << slb[inumber].aw << " iW=" << slb[inumber].iW << " b=" << slb[inumber].b << std::endl;
	//printf("ai=%e iI=%d aw=%e iW=%d b=%e\n", slb[inumber].ai, slb[inumber].iI, slb[inumber].aw, slb[inumber].iW, slb[inumber].b);
	//std::cout << "border_neighbor[" << inumber << "].MCB ==" << border_neighbor[inumber].MCB << " ls=" << ls << " lw=" << lw << " ls+lw=" << ls + lw << std::endl;
	//printf("border_neighbor[inumber].MCB == %lld ls=%lld lw=%lld ls+lw=%lld\n", border_neighbor[inumber].MCB, ls, lw, ls+lw);
	//system("PAUSE");
//}

	if ((bDirichlet==false)&&(slb[inumber].iW == -1)) {
		// Прошёл второй запуск а гран условие до сих пор не заполнено.
		printf("ERROR in my_elmatr_quad_T3D_bound !!! \n");
		printf("The boundary condition is not defined by the programmer.\n");
		printf("Please send message kirill7785@mail.ru.\n");
		if (bopening_Dirichlet_on) {
			std::cout << "bopening_Dirichlet_on true\n";
		}
		else {
			std::cout << "bopening_Dirichlet_on false\n";
		}
		if (bopening_Neiman_on) {
			std::cout << "bopening_Neiman_on true\n";
		}
		else {
			std::cout << "bopening_Neiman_on false\n";
		}
		std::cout << "inumber = " << inumber << std::endl;
		std::cout << "ai=" << slb[inumber].ai << " iI=" << slb[inumber].iI << " aw=" << slb[inumber].aw  << " iW=" << slb[inumber].iW  << " b=" << slb[inumber].b  << std::endl;
		//printf("ai=%e iI=%d aw=%e iW=%d b=%e\n", slb[inumber].ai, slb[inumber].iI, slb[inumber].aw, slb[inumber].iW, slb[inumber].b);
		std::cout << "border_neighbor[" << inumber << "].MCB ==" << border_neighbor[inumber].MCB << " ls=" << ls << " lw=" << lw<< " ls+lw="<< ls + lw<< std::endl;
		//printf("border_neighbor[inumber].MCB == %lld ls=%lld lw=%lld ls+lw=%lld\n", border_neighbor[inumber].MCB, ls, lw, ls+lw);
		system("PAUSE");
		exit(1);
	}

} // my_elmatr_quad_T3D_bound

// Вычисляет теплопроводность на источнике как среднее гармоническое.
// 26.09.2016 Теперь работает и на АЛИС сетке.
void conduct2Dsourceconstruct(integer iP, equation3D* &sl, 
	int*** neighbors_for_the_internal_node, integer maxelm,
	BOUND* border_neighbor, integer ls, float** prop)
{
	integer iE1=-1, iN1=-1, iT1=-1, iW1=-1, iS1=-1, iB1=-1; // номера соседних контрольных объёмов
	integer iE2=-1, iN2=-1, iT2=-1, iW2=-1, iS2=-1, iB2=-1;
	integer iE3=-1, iN3=-1, iT3=-1, iW3=-1, iS3=-1, iB3=-1;
	integer iE4=-1, iN4=-1, iT4=-1, iW4=-1, iS4=-1, iB4=-1;


	iE1 = neighbors_for_the_internal_node[E_SIDE][0][iP];
	iN1 = neighbors_for_the_internal_node[N_SIDE][0][iP];
	iT1 = neighbors_for_the_internal_node[T_SIDE][0][iP];
	iW1 = neighbors_for_the_internal_node[W_SIDE][0][iP];
	iS1 = neighbors_for_the_internal_node[S_SIDE][0][iP];
	iB1 = neighbors_for_the_internal_node[B_SIDE][0][iP];

	if (b_on_adaptive_local_refinement_mesh) {

		iE2 = neighbors_for_the_internal_node[E_SIDE][1][iP];
		iN2 = neighbors_for_the_internal_node[N_SIDE][1][iP];
		iT2 = neighbors_for_the_internal_node[T_SIDE][1][iP];
		iW2 = neighbors_for_the_internal_node[W_SIDE][1][iP];
		iS2 = neighbors_for_the_internal_node[S_SIDE][1][iP];
		iB2 = neighbors_for_the_internal_node[B_SIDE][1][iP];

		iE3 = neighbors_for_the_internal_node[E_SIDE][2][iP];
		iN3 = neighbors_for_the_internal_node[N_SIDE][2][iP];
		iT3 = neighbors_for_the_internal_node[T_SIDE][2][iP];
		iW3 = neighbors_for_the_internal_node[W_SIDE][2][iP];
		iS3 = neighbors_for_the_internal_node[S_SIDE][2][iP];
		iB3 = neighbors_for_the_internal_node[B_SIDE][2][iP];

		iE4 = neighbors_for_the_internal_node[E_SIDE][3][iP];
		iN4 = neighbors_for_the_internal_node[N_SIDE][3][iP];
		iT4 = neighbors_for_the_internal_node[T_SIDE][3][iP];
		iW4 = neighbors_for_the_internal_node[W_SIDE][3][iP];
		iS4 = neighbors_for_the_internal_node[S_SIDE][3][iP];
		iB4 = neighbors_for_the_internal_node[B_SIDE][3][iP];

	}

	// Внутренний КО.	

	// Если с одной из сторон стоит граница расчётной области
	// то соответствующая переменная равна true
	bool bE1 = false, bN1 = false, bT1 = false, bW1 = false, bS1 = false, bB1 = false;
	bool bE2 = false, bN2 = false, bT2 = false, bW2 = false, bS2 = false, bB2 = false;
	bool bE3 = false, bN3 = false, bT3 = false, bW3 = false, bS3 = false, bB3 = false;
	bool bE4 = false, bN4 = false, bT4 = false, bW4 = false, bS4 = false, bB4 = false;


	if (iE1 >= maxelm) bE1 = true;
	if (iN1 >= maxelm) bN1 = true;
	if (iT1 >= maxelm) bT1 = true;
	if (iW1 >= maxelm) bW1 = true;
	if (iS1 >= maxelm) bS1 = true;
	if (iB1 >= maxelm) bB1 = true;

	if (iE2 >= maxelm) bE2 = true;
	if (iN2 >= maxelm) bN2 = true;
	if (iT2 >= maxelm) bT2 = true;
	if (iW2 >= maxelm) bW2 = true;
	if (iS2 >= maxelm) bS2 = true;
	if (iB2 >= maxelm) bB2 = true;

	if (iE3 >= maxelm) bE3 = true;
	if (iN3 >= maxelm) bN3 = true;
	if (iT3 >= maxelm) bT3 = true;
	if (iW3 >= maxelm) bW3 = true;
	if (iS3 >= maxelm) bS3 = true;
	if (iB3 >= maxelm) bB3 = true;

	if (iE4 >= maxelm) bE4 = true;
	if (iN4 >= maxelm) bN4 = true;
	if (iT4 >= maxelm) bT4 = true;
	if (iW4 >= maxelm) bW4 = true;
	if (iS4 >= maxelm) bS4 = true;
	if (iB4 >= maxelm) bB4 = true;

	if (bE1) {
		if (border_neighbor[iE1 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iE1 - maxelm] < 0.0) {
				conductivity2Dinsource[iE1 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iE1 - maxelm] = 2.0*conductivity2Dinsource[iE1 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iE1 - maxelm] + prop[LAM][iP]);
			}
		}
	}

	if (bW1) {
		if (border_neighbor[iW1 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iW1 - maxelm] < 0.0) {
				conductivity2Dinsource[iW1 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iW1 - maxelm] = 2.0*conductivity2Dinsource[iW1 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iW1 - maxelm] + prop[LAM][iP]);
			}
		}
	}

	if (bN1) {
		if (border_neighbor[iN1 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iN1 - maxelm] < 0.0) {
				conductivity2Dinsource[iN1 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iN1 - maxelm] = 2.0*conductivity2Dinsource[iN1 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iN1 - maxelm] + prop[LAM][iP]);
			}
		}
	}

	if (bS1) {
		if (border_neighbor[iS1 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iS1 - maxelm] < 0.0) {
				conductivity2Dinsource[iS1 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iS1 - maxelm] = 2.0*conductivity2Dinsource[iS1 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iS1 - maxelm] + prop[LAM][iP]);
			}
		}
	}


	if (bT1) {
		if (border_neighbor[iT1 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iT1 - maxelm] < 0.0) {
				conductivity2Dinsource[iT1 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iT1 - maxelm] = 2.0*conductivity2Dinsource[iT1 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iT1 - maxelm] + prop[LAM][iP]);
				//if (prop[LAM][iP] < conductivity2Dinsource[iT1 - maxelm]) {
					//conductivity2Dinsource[iT1 - maxelm] = prop[LAM][iP];
				//}
			}
		}
	}

	if (bB1) {
		if (border_neighbor[iB1 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iB1 - maxelm] < 0.0) {
				conductivity2Dinsource[iB1 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iB1 - maxelm] = 2.0*conductivity2Dinsource[iB1 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iB1 - maxelm] + prop[LAM][iP]);
				//if (prop[LAM][iP] < conductivity2Dinsource[iB1 - maxelm]) {
					//conductivity2Dinsource[iB1 - maxelm] = prop[LAM][iP];
				//}
			}
		}
	}

	if (bE2) {
		if (border_neighbor[iE2 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iE2 - maxelm] < 0.0) {
				conductivity2Dinsource[iE2 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iE2 - maxelm] = 2.0*conductivity2Dinsource[iE2 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iE2 - maxelm] + prop[LAM][iP]);
			}
		}
	}

	if (bW2) {
		if (border_neighbor[iW2 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iW2 - maxelm] < 0.0) {
				conductivity2Dinsource[iW2 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iW2 - maxelm] = 2.0*conductivity2Dinsource[iW2 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iW2 - maxelm] + prop[LAM][iP]);
			}
		}
	}

	if (bN2) {
		if (border_neighbor[iN2 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iN2 - maxelm] < 0.0) {
				conductivity2Dinsource[iN2 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iN2 - maxelm] = 2.0*conductivity2Dinsource[iN2 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iN2 - maxelm] + prop[LAM][iP]);
			}
		}
	}

	if (bS2) {
		if (border_neighbor[iS2 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iS2 - maxelm] < 0.0) {
				conductivity2Dinsource[iS2 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iS2 - maxelm] = 2.0*conductivity2Dinsource[iS2 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iS2 - maxelm] + prop[LAM][iP]);
			}
		}
	}


	if (bT2) {
		if (border_neighbor[iT2 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iT2 - maxelm] < 0.0) {
				conductivity2Dinsource[iT2 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iT2 - maxelm] = 2.0*conductivity2Dinsource[iT2 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iT2 - maxelm] + prop[LAM][iP]);
				//if (prop[LAM][iP] < conductivity2Dinsource[iT2 - maxelm]) {
				//conductivity2Dinsource[iT2 - maxelm] = prop[LAM][iP];
				//}
			}
		}
	}

	if (bB2) {
		if (border_neighbor[iB2 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iB2 - maxelm] < 0.0) {
				conductivity2Dinsource[iB2 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iB2 - maxelm] = 2.0*conductivity2Dinsource[iB2 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iB2 - maxelm] + prop[LAM][iP]);
				//if (prop[LAM][iP] < conductivity2Dinsource[iB2 - maxelm]) {
				//conductivity2Dinsource[iB2 - maxelm] = prop[LAM][iP];
				//}
			}
		}
	}


	if (bE3) {
		if (border_neighbor[iE3 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iE3 - maxelm] < 0.0) {
				conductivity2Dinsource[iE3 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iE3 - maxelm] = 2.0*conductivity2Dinsource[iE3 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iE3 - maxelm] + prop[LAM][iP]);
			}
		}
	}

	if (bW3) {
		if (border_neighbor[iW3 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iW3 - maxelm] < 0.0) {
				conductivity2Dinsource[iW3 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iW3 - maxelm] = 2.0*conductivity2Dinsource[iW3 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iW3 - maxelm] + prop[LAM][iP]);
			}
		}
	}

	if (bN3) {
		if (border_neighbor[iN3 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iN3 - maxelm] < 0.0) {
				conductivity2Dinsource[iN3 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iN3 - maxelm] = 2.0*conductivity2Dinsource[iN3 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iN3 - maxelm] + prop[LAM][iP]);
			}
		}
	}

	if (bS3) {
		if (border_neighbor[iS3 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iS3 - maxelm] < 0.0) {
				conductivity2Dinsource[iS3 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iS3 - maxelm] = 2.0*conductivity2Dinsource[iS3 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iS3 - maxelm] + prop[LAM][iP]);
			}
		}
	}


	if (bT3) {
		if (border_neighbor[iT3 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iT3 - maxelm] < 0.0) {
				conductivity2Dinsource[iT3 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iT3 - maxelm] = 2.0*conductivity2Dinsource[iT3 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iT3 - maxelm] + prop[LAM][iP]);
				//if (prop[LAM][iP] < conductivity2Dinsource[iT3 - maxelm]) {
				//conductivity2Dinsource[iT3 - maxelm] = prop[LAM][iP];
				//}
			}
		}
	}

	if (bB3) {
		if (border_neighbor[iB3 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iB3 - maxelm] < 0.0) {
				conductivity2Dinsource[iB3 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iB3 - maxelm] = 2.0*conductivity2Dinsource[iB3 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iB3 - maxelm] + prop[LAM][iP]);
				//if (prop[LAM][iP] < conductivity2Dinsource[iB3 - maxelm]) {
				//conductivity2Dinsource[iB3 - maxelm] = prop[LAM][iP];
				//}
			}
		}
	}

	if (bE4) {
		if (border_neighbor[iE4 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iE4 - maxelm] < 0.0) {
				conductivity2Dinsource[iE4 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iE4 - maxelm] = 2.0*conductivity2Dinsource[iE4 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iE4 - maxelm] + prop[LAM][iP]);
			}
		}
	}

	if (bW4) {
		if (border_neighbor[iW4 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iW4 - maxelm] < 0.0) {
				conductivity2Dinsource[iW4 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iW4 - maxelm] = 2.0*conductivity2Dinsource[iW4 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iW4 - maxelm] + prop[LAM][iP]);
			}
		}
	}

	if (bN4) {
		if (border_neighbor[iN4 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iN4 - maxelm] < 0.0) {
				conductivity2Dinsource[iN4 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iN4 - maxelm] = 2.0*conductivity2Dinsource[iN4 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iN4 - maxelm] + prop[LAM][iP]);
			}
		}
	}

	if (bS4) {
		if (border_neighbor[iS4 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iS4 - maxelm] < 0.0) {
				conductivity2Dinsource[iS4 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iS4 - maxelm] = 2.0*conductivity2Dinsource[iS4 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iS4 - maxelm] + prop[LAM][iP]);
			}
		}
	}


	if (bT4) {
		if (border_neighbor[iT4 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iT4 - maxelm] < 0.0) {
				conductivity2Dinsource[iT4 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iT4 - maxelm] = 2.0*conductivity2Dinsource[iT4 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iT4 - maxelm] + prop[LAM][iP]);
				//if (prop[LAM][iP] < conductivity2Dinsource[iT4 - maxelm]) {
				//conductivity2Dinsource[iT4 - maxelm] = prop[LAM][iP];
				//}
			}
		}
	}

	if (bB4) {
		if (border_neighbor[iB4 - maxelm].MCB < ls) {
			if (conductivity2Dinsource[iB4 - maxelm] < 0.0) {
				conductivity2Dinsource[iB4 - maxelm] = prop[LAM][iP];
			}
			else {
				conductivity2Dinsource[iB4 - maxelm] = 2.0*conductivity2Dinsource[iB4 - maxelm] * prop[LAM][iP] / (conductivity2Dinsource[iB4 - maxelm] + prop[LAM][iP]);
				//if (prop[LAM][iP] < conductivity2Dinsource[iB4 - maxelm]) {
				//conductivity2Dinsource[iB4 - maxelm] = prop[LAM][iP];
				//}
			}
		}
	}

} // conduct2Dsourceconstruct


// возвращает значение температуры в точке с координатами (x,y,z).
// для этого использует линейную реконструкцию температуры по способу наименьших квадратов.
// Изменение температуры при этом предполагается линейным, а коэффициенты линейной функции найдены 
// по способу наименьших квадратов.
doublereal mnk(integer iP, integer maxelm, doublereal* potent, int**  nvtx, TOCHKA* pa,
	int*** neighbors_for_the_internal_node, doublereal x, doublereal y, doublereal z)
{
	
	integer inum_now = 1; // iP уже есть.

	integer iE, iN, iT, iW, iS, iB; // номера соседних контрольных объёмов
	iE = neighbors_for_the_internal_node[E_SIDE][0][iP]; iN = neighbors_for_the_internal_node[N_SIDE][0][iP]; iT = neighbors_for_the_internal_node[T_SIDE][0][iP];
	iW = neighbors_for_the_internal_node[W_SIDE][0][iP]; iS = neighbors_for_the_internal_node[S_SIDE][0][iP]; iB = neighbors_for_the_internal_node[B_SIDE][0][iP];

	// 26.09.2016 Добавок для АЛИС сетки.
	integer iE2, iN2, iT2, iW2, iS2, iB2; // номера соседних контрольных объёмов
	integer iE3, iN3, iT3, iW3, iS3, iB3; // номера соседних контрольных объёмов
	integer iE4, iN4, iT4, iW4, iS4, iB4; // номера соседних контрольных объёмов

	// -1 если не используется и [0..maxelm+maxbound-1] если используется.

	iE2 = neighbors_for_the_internal_node[E_SIDE][1][iP]; iN2 = neighbors_for_the_internal_node[N_SIDE][1][iP]; iT2 = neighbors_for_the_internal_node[T_SIDE][1][iP];
	iW2 = neighbors_for_the_internal_node[W_SIDE][1][iP]; iS2 = neighbors_for_the_internal_node[S_SIDE][1][iP]; iB2 = neighbors_for_the_internal_node[B_SIDE][1][iP];
	iE3 = neighbors_for_the_internal_node[E_SIDE][2][iP]; iN3 = neighbors_for_the_internal_node[N_SIDE][2][iP]; iT3 = neighbors_for_the_internal_node[T_SIDE][2][iP];
	iW3 = neighbors_for_the_internal_node[W_SIDE][2][iP]; iS3 = neighbors_for_the_internal_node[S_SIDE][2][iP]; iB3 = neighbors_for_the_internal_node[B_SIDE][2][iP];
	iE4 = neighbors_for_the_internal_node[E_SIDE][3][iP]; iN4 = neighbors_for_the_internal_node[N_SIDE][3][iP]; iT4 = neighbors_for_the_internal_node[T_SIDE][3][iP];
	iW4 = neighbors_for_the_internal_node[W_SIDE][3][iP]; iS4 = neighbors_for_the_internal_node[S_SIDE][3][iP]; iB4 = neighbors_for_the_internal_node[B_SIDE][3][iP];

	if ((iE > -1)&&(iE<maxelm)) inum_now++;
	if ((iW > -1)&&(iW<maxelm)) inum_now++;
	if ((iN > -1)&&(iN<maxelm)) inum_now++;
	if ((iS > -1)&&(iS<maxelm)) inum_now++;
	if ((iT > -1)&&(iT<maxelm)) inum_now++;
	if ((iB > -1)&&(iB<maxelm)) inum_now++;

	if ((iE2 > -1)&&(iE2<maxelm)) inum_now++;
	if ((iW2 > -1)&&(iW2<maxelm)) inum_now++;
	if ((iN2 > -1)&&(iN2<maxelm)) inum_now++;
	if ((iS2 > -1)&&(iS2<maxelm)) inum_now++;
	if ((iT2 > -1)&&(iT2<maxelm)) inum_now++;
	if ((iB2 > -1)&&(iB2<maxelm)) inum_now++;

	if ((iE3 > -1)&&(iE3<maxelm)) inum_now++;
	if ((iW3 > -1)&&(iW3<maxelm)) inum_now++;
	if ((iN3 > -1)&&(iN3<maxelm)) inum_now++;
	if ((iS3 > -1)&&(iS3<maxelm)) inum_now++;
	if ((iT3 > -1)&&(iT3<maxelm)) inum_now++;
	if ((iB3 > -1)&&(iB3<maxelm)) inum_now++;

	if ((iE4 > -1)&&(iE4<maxelm)) inum_now++;
	if ((iW4 > -1)&&(iW4<maxelm)) inum_now++;
	if ((iN4 > -1)&&(iN4<maxelm)) inum_now++;
	if ((iS4 > -1)&&(iS4<maxelm)) inum_now++;
	if ((iT4 > -1)&&(iT4<maxelm)) inum_now++;
	if ((iB4 > -1)&&(iB4<maxelm)) inum_now++;

	TOCHKA* pointerlist = nullptr;
	pointerlist = new TOCHKA[inum_now];

	doublereal* rthdsd_Gauss = nullptr;
	rthdsd_Gauss = new doublereal[inum_now];

	inum_now = 0;
	rthdsd_Gauss[inum_now++] = potent[iP];

	if ((iE > -1)&&(iE<maxelm)) rthdsd_Gauss[inum_now++] = potent[iE];
	if ((iW > -1)&&(iW<maxelm)) rthdsd_Gauss[inum_now++] = potent[iW];
	if ((iN > -1)&&(iN<maxelm)) rthdsd_Gauss[inum_now++] = potent[iN];
	if ((iS > -1)&&(iS<maxelm)) rthdsd_Gauss[inum_now++] = potent[iS];
	if ((iT > -1)&&(iT<maxelm)) rthdsd_Gauss[inum_now++] = potent[iT];
	if ((iB > -1)&&(iB<maxelm)) rthdsd_Gauss[inum_now++] = potent[iB];

	if ((iE2 > -1)&&(iE2<maxelm)) rthdsd_Gauss[inum_now++] = potent[iE2];
	if ((iW2 > -1)&&(iW2<maxelm)) rthdsd_Gauss[inum_now++] = potent[iW2];
	if ((iN2 > -1)&&(iN2<maxelm)) rthdsd_Gauss[inum_now++] = potent[iN2];
	if ((iS2 > -1)&&(iS2<maxelm)) rthdsd_Gauss[inum_now++] = potent[iS2];
	if ((iT2 > -1)&&(iT2<maxelm)) rthdsd_Gauss[inum_now++] = potent[iT2];
	if ((iB2 > -1)&&(iB2<maxelm)) rthdsd_Gauss[inum_now++] = potent[iB2];

	if ((iE3 > -1)&&(iE3<maxelm)) rthdsd_Gauss[inum_now++] = potent[iE3];
	if ((iW3 > -1)&&(iW3<maxelm)) rthdsd_Gauss[inum_now++] = potent[iW3];
	if ((iN3 > -1)&&(iN3<maxelm)) rthdsd_Gauss[inum_now++] = potent[iN3];
	if ((iS3 > -1)&&(iS3<maxelm)) rthdsd_Gauss[inum_now++] = potent[iS3];
	if ((iT3 > -1)&&(iT3<maxelm)) rthdsd_Gauss[inum_now++] = potent[iT3];
	if ((iB3 > -1)&&(iB3<maxelm)) rthdsd_Gauss[inum_now++] = potent[iB3];

	if ((iE4 > -1)&&(iE4<maxelm)) rthdsd_Gauss[inum_now++] = potent[iE4];
	if ((iW4 > -1)&&(iW4<maxelm)) rthdsd_Gauss[inum_now++] = potent[iW4];
	if ((iN4 > -1)&&(iN4<maxelm)) rthdsd_Gauss[inum_now++] = potent[iN4];
	if ((iS4 > -1)&&(iS4<maxelm)) rthdsd_Gauss[inum_now++] = potent[iS4];
	if ((iT4 > -1)&&(iT4<maxelm)) rthdsd_Gauss[inum_now++] = potent[iT4];
	if ((iB4 > -1)&&(iB4<maxelm)) rthdsd_Gauss[inum_now++] = potent[iB4];

	inum_now = 0;
	TOCHKA point0;
	center_cord3D(iP, nvtx, pa, point0, 100);
	pointerlist[inum_now++] = point0;

	if ((iE > -1)&&(iE<maxelm)) {
		center_cord3D(iE, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iW > -1)&&(iW<maxelm)) {
		center_cord3D(iW, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iN > -1)&&(iN<maxelm)) {
		center_cord3D(iN, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iS > -1)&&(iS<maxelm)) {
		center_cord3D(iS, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iT > -1)&&(iT<maxelm)) {
		center_cord3D(iT, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iB > -1)&&(iB<maxelm)) {
		center_cord3D(iB, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}

	if ((iE2 > -1)&&(iE2<maxelm)) {
		center_cord3D(iE2, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iW2 > -1)&&(iW2<maxelm)) {
		center_cord3D(iW2, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iN2 > -1)&&(iN2<maxelm)) {
		center_cord3D(iN2, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iS2 > -1)&&(iS2<maxelm)) {
		center_cord3D(iS2, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iT2 > -1)&&(iT2<maxelm)) {
		center_cord3D(iT2, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iB2 > -1)&&(iB2<maxelm)) {
		center_cord3D(iB2, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}


	if ((iE3 > -1)&&(iE3<maxelm)) {
		center_cord3D(iE3, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iW3 > -1)&&(iW3<maxelm)) {
		center_cord3D(iW3, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iN3 > -1)&&(iN3<maxelm)) {
		center_cord3D(iN3, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iS3 > -1)&&(iS3<maxelm)) {
		center_cord3D(iS3, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iT3 > -1)&&(iT3<maxelm)) {
		center_cord3D(iT3, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iB3 > -1)&&(iB3<maxelm)) {
		center_cord3D(iB3, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}

	if ((iE4 > -1)&&(iE4<maxelm)) {
		center_cord3D(iE4, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iW4 > -1)&&(iW4<maxelm)) {
		center_cord3D(iW4, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iN4 > -1)&&(iN4<maxelm)) {
		center_cord3D(iN4, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iS4 > -1)&&(iS4<maxelm)) {
		center_cord3D(iS4, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iT4 > -1)&&(iT4<maxelm)) {
		center_cord3D(iT4, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}
	if ((iB4 > -1)&&(iB4<maxelm)) {
		center_cord3D(iB4, nvtx, pa, point0, 100);
		pointerlist[inum_now++] = point0;
	}


	// Метод линейного порядка.
	doublereal min_x = 1e60;
	doublereal min_y = 1e60;
	doublereal min_z = 1e60;
	doublereal max_x = -1e60;
	doublereal max_y = -1e60;
	doublereal max_z = -1e60;


	for (integer j = 0; j < inum_now; j++) {
		if (pointerlist[j].x < min_x) min_x = pointerlist[j].x;
		if (pointerlist[j].y < min_y) min_y = pointerlist[j].y;
		if (pointerlist[j].z < min_z) min_z = pointerlist[j].z;

		if (pointerlist[j].x > max_x) max_x = pointerlist[j].x;
		if (pointerlist[j].y > max_y) max_y = pointerlist[j].y;
		if (pointerlist[j].z > max_z) max_z = pointerlist[j].z;
	}

	
	
	
	
	// 05.07.2017

	min_x = 1.05*fabs(max_x - min_x);
	if (min_x < 1.0e-30) {
		min_x = 1.05*fabs(max_x);
	}
	min_y = 1.05*fabs(max_y - min_y);
	if (min_y < 1.0e-30) {
		min_y = 1.05*fabs(max_y);
	}
	min_z = 1.05*fabs(max_z - min_z);
	if (min_z < 1.0e-30) {
		min_z = 1.05*fabs(max_z);
	}


	/*
	if (min_x < 1.0e-30) {
		printf("error!!! negative min_x MNK!\n");
		printf("min_x=%e max_x=%e\n", min_x, max_x);
	}
	if (min_y < 1.0e-30) {
		printf("error!!! negative min_y MNK!\n");
		printf("min_y=%e max_y=%e\n", min_y, max_y);
	}
	if (min_z < 1.0e-30) {
		printf("error!!! negative min_z MNK!\n");
		printf("min_z=%e max_z=%e\n", min_z, max_z);
	}
	*/

	// Для МНК все опорные координаты строго больше нуля.
	for (integer j = 0; j < inum_now; j++) {
		pointerlist[j].x += min_x;
		pointerlist[j].y += min_y;
		pointerlist[j].z += min_z;	
	}

	doublereal** Xmatr = new doublereal*[4];
	for (integer j = 0; j <= 3; j++) {
		Xmatr[j] = new doublereal[4];
	}

	doublereal* bmatr = new doublereal[4];
	doublereal* koefmatr = new doublereal[4];

	for (integer j1 = 0; j1 <= 3; j1++) {
		for (integer j2 = 0; j2 <= 3; j2++) {
			Xmatr[j1][j2] = 0.0;
		}
		bmatr[j1] = 0.0;
		koefmatr[j1] = 0.0;
	}

	for (integer j = 0; j < inum_now; j++) {

		Xmatr[0][0] += 1.0;
		Xmatr[0][1] += pointerlist[j].x;
		Xmatr[0][2] += pointerlist[j].y;
		Xmatr[0][3] += pointerlist[j].z;

		Xmatr[1][0] += pointerlist[j].x;
		Xmatr[1][1] += pointerlist[j].x*pointerlist[j].x;
		Xmatr[1][2] += pointerlist[j].x*pointerlist[j].y;
		Xmatr[1][3] += pointerlist[j].x*pointerlist[j].z;

		Xmatr[2][0] += pointerlist[j].y;
		Xmatr[2][1] += pointerlist[j].y*pointerlist[j].x;
		Xmatr[2][2] += pointerlist[j].y*pointerlist[j].y;
		Xmatr[2][3] += pointerlist[j].y*pointerlist[j].z;

		Xmatr[3][0] += pointerlist[j].z;
		Xmatr[3][1] += pointerlist[j].z*pointerlist[j].x;
		Xmatr[3][2] += pointerlist[j].z*pointerlist[j].y;
		Xmatr[3][3] += pointerlist[j].z*pointerlist[j].z;

		bmatr[0] += rthdsd_Gauss[j];
		bmatr[1] += pointerlist[j].x*rthdsd_Gauss[j];
		bmatr[2] += pointerlist[j].y*rthdsd_Gauss[j];
		bmatr[3] += pointerlist[j].z*rthdsd_Gauss[j];
	}

	if ((fabs(Xmatr[0][0]) < 1.e-30) || (fabs(Xmatr[1][1]) < 1.e-30) || (fabs(Xmatr[2][2]) < 1.e-30) || (fabs(Xmatr[3][3]) < 1.e-30)) {
#if doubleintprecision == 1
		printf("inum_now=%lld\n", inum_now);
#else
		printf("inum_now=%d\n", inum_now);
#endif
		
		system("pause");
	}

	if (pointerlist != nullptr) {
		delete[] pointerlist;
		pointerlist = nullptr;
	}
	if (rthdsd_Gauss != nullptr) {
		delete[] rthdsd_Gauss;
		rthdsd_Gauss = nullptr;
	}


	for (integer j1 = 0; j1 <= 100; j1++) {
		koefmatr[0] = (bmatr[0] - Xmatr[0][1] * koefmatr[1] - Xmatr[0][2] * koefmatr[2] - Xmatr[0][3] * koefmatr[3]) / Xmatr[0][0];
		koefmatr[1] = (bmatr[1] - Xmatr[1][0] * koefmatr[0] - Xmatr[1][2] * koefmatr[2] - Xmatr[1][3] * koefmatr[3]) / Xmatr[1][1];
		koefmatr[2] = (bmatr[2] - Xmatr[2][0] * koefmatr[0] - Xmatr[2][1] * koefmatr[1] - Xmatr[2][3] * koefmatr[3]) / Xmatr[2][2];
		koefmatr[3] = (bmatr[3] - Xmatr[3][0] * koefmatr[0] - Xmatr[3][1] * koefmatr[1] - Xmatr[3][2] * koefmatr[2]) / Xmatr[3][3];
	}

	doublereal retT = 0.0;
	if (koefmatr != nullptr) {
		retT = (koefmatr[0] + koefmatr[1] * (x + min_x) + koefmatr[2] * (y + min_y) + koefmatr[3] * (z + min_z));
	}

	if (Xmatr != nullptr) {
		for (integer j = 0; j <= 3; j++) {
			if (Xmatr[j] != nullptr) {
				delete[] Xmatr[j];
				Xmatr[j] = nullptr;
			}
		}
	}
	if (Xmatr != nullptr) {
		delete[] Xmatr;
		Xmatr = nullptr;
	}
	if (bmatr != nullptr) {
		delete[] bmatr;
		bmatr = nullptr;
	}
	if (koefmatr != nullptr) {
		delete[] koefmatr;
		koefmatr = nullptr;
	}

	return retT;

} // mnk

  // 12.03.2019
void AVERAGE_DIFFUSION(integer iE, integer iE2, integer iE3, integer iE4,
	doublereal &De, doublereal &De2, doublereal &De3, doublereal &De4)
{
	// У кубика 6 сторон. На каждой стороне можен располагаться один, два, три или 4 фейса.
	// В этой функции всем фейсам на стороне присваивается один и тот же коэффициент диффузии
	// равный среднему арифметическому значению.
	// Всем коэффициентам диффузии для данной стороны мы присваиваем одно и тоже среднее значение,
	// как в статье Неявная схема решения нелинейного уравнения теплопроводности на квадратной 
	// адаптивной сетке. Н.Г. Карлыханов, А.В. Уракова.
	doublereal Diffusion = 0.0;
	if ((iE > -1) && (iE2 > -1) && (iE3 > -1) && (iE4 > -1)) {
		Diffusion = 0.25*(De + De2 + De3 + De4);
		De = Diffusion;
		De2 = Diffusion;
		De3 = Diffusion;
		De4 = Diffusion;
	}
	else if ((iE == -1) && (iE2 > -1) && (iE3 > -1) && (iE4 > -1)) {
		Diffusion = (De2 + De3 + De4) / 3.0;
		De2 = Diffusion;
		De3 = Diffusion;
		De4 = Diffusion;
	}
	else if ((iE > -1) && (iE2 == -1) && (iE3 > -1) && (iE4 > -1)) {
		Diffusion = (De + De3 + De4) / 3.0;
		De = Diffusion;
		De3 = Diffusion;
		De4 = Diffusion;
	}
	else if ((iE > -1) && (iE2 > -1) && (iE3 == -1) && (iE4 > -1)) {
		Diffusion = (De + De2 + De4) / 3.0;
		De = Diffusion;
		De2 = Diffusion;
		De4 = Diffusion;
	}
	else if ((iE > -1) && (iE2 > -1) && (iE3 > -1) && (iE4 == -1)) {
		Diffusion = (De + De2 + De3) / 3.0;
		De = Diffusion;
		De2 = Diffusion;
		De3 = Diffusion;
	}
	else if ((iE == -1) && (iE2 == -1) && (iE3 > -1) && (iE4 > -1)) {
		Diffusion = 0.5*(De3 + De4);
		De3 = Diffusion;
		De4 = Diffusion;
	}
	else if ((iE == -1) && (iE2 > -1) && (iE3 == -1) && (iE4 > -1)) {
		Diffusion = 0.5*(De2 + De4) / 3.0;
		De2 = Diffusion;
		De4 = Diffusion;
	}
	else if ((iE == -1) && (iE2 > -1) && (iE3 > -1) && (iE4 == -1)) {
		Diffusion = 0.5*(De2 + De3) / 3.0;
		De2 = Diffusion;
		De3 = Diffusion;
	}
	/*
	else if ((iE == -1) && (iE2 == -1) && (iE3 > -1) && (iE4 > -1)) {
		Diffusion = 0.5*(De3 + De4);
		De3 = Diffusion;
		De4 = Diffusion;
	}
	*/
	else if ((iE > -1) && (iE2 == -1) && (iE3 == -1) && (iE4 > -1)) {
		Diffusion = 0.5*(De + De4) / 3.0;
		De = Diffusion;
		De4 = Diffusion;
	}
	else if ((iE > -1) && (iE2 == -1) && (iE3 > -1) && (iE4 == -1)) {
		Diffusion = 0.5*(De + De3) / 3.0;
		De = Diffusion;
		De3 = Diffusion;
	}
	/*
	else if ((iE == -1) && (iE2 > -1) && (iE3 == -1) && (iE4 > -1)) {
		Diffusion = 0.5*(De2 + De4);
		De2 = Diffusion;
		De4 = Diffusion;
	}*/
	/*
	else if ((iE > -1) && (iE2 == -1) && (iE3 == -1) && (iE4 > -1)) {
		Diffusion = 0.5*(De + De4) / 3.0;
		De = Diffusion;
		De4 = Diffusion;
	}
	*/
	else if ((iE > -1) && (iE2 > -1) && (iE3 == -1) && (iE4 == -1)) {
		Diffusion = 0.5*(De + De2) / 3.0;
		De = Diffusion;
		De2 = Diffusion;
	}
	/*
	else if ((iE == -1) && (iE2 > -1) && (iE3 > -1) && (iE4 == -1)) {
		Diffusion = 0.5*(De2 + De3);
		De2 = Diffusion;
		De3 = Diffusion;
	}
	*/
	/*
	else if ((iE > -1) && (iE2 == -1) && (iE3 > -1) && (iE4 == -1)) {
		Diffusion = 0.5*(De + De3) / 3.0;
		De = Diffusion;
		De3 = Diffusion;
	}
	*/
	/*
	else if ((iE > -1) && (iE2 > -1) && (iE3 == -1) && (iE4 == -1)) {
		Diffusion = 0.5*(De + De2) / 3.0;
		De = Diffusion;
		De2 = Diffusion;
	}
	*/
} // AVERAGE_DIFFUSION 


//#define DEBUG_MY_ELMATR_QUAD_T3D 1

// собирает одно уравнение матрицы СЛАУ для обобщенного уравнения 
// конвекции - диффузии, для определённого контрольного объёма.
// Для прямоугольной сетки.
// Для чистой теплопроводности. Только внутренние КО.
// Начинаем собирать матрицу на АЛИС сетке 26 сентября 2016. в 14_09.
// 06.10.2020 Наиболее быстрая версия на данный момент.
void my_elmatr_quad_T3D(int iP, equation3D* &sl, equation3D_bon* &slb,
						bool btimedep, doublereal tauparam, integer ishconvection,
					    int** &nvtx, doublereal* &potent, TOCHKA* &pa, 
						float** &prop, float** &prop_b, int*** &neighbors_for_the_internal_node,
					    doublereal alpha, doublereal dbeta,  bool bconvective,
						doublereal dSc_out, POWER_TIME_DEPEND ipower_time_depend, int maxelm, integer flow_interior,
						int** &ptr, BOUND* &border_neighbor, int ls, FLOW* &f,
						bool* &binternalsource, doublereal* &toldtimestep,
						BLOCK* &b, int lb, TPROP* &matlist, integer inumglobaliter,
						SOURCE* &s, doublereal poweron_multiplier_sequence,
						integer* &ilevel_alice, int* &whot_is_block, int maxbound) {

	
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (iP < 0) {
		printf("iP=%lld\n",iP);
		system("pause");
	}
#endif

	

    // btimedep==false - стационарный, иначе (true) нестационарный
	// tauparam - шаг по времени.
	// toldtimestep - температура с предыдущего временного слоя.
    const bool imitation_time=false; // false - псевдо время не используется, true - используется

	// inumglobaliter номер глобальной итерации SIMPLE алгоритма.


	// Поправка Рхи-Чоу должна быть включена иначе скорости 
	// не будут удовлетворять уравнению несжимаемости (что недопустимо с физической точки зрения).
	// если true то включаем поправку Рхи-Чоу.
	//bool bRhieChowi=true, bRhieChowb=false; // i - internal, b - border
	//doublereal RCh=1.0; // регулирование вклада поправки Рхи-Чоу См. Вабищевич.

    // iP - номер центрального контрольного объёма
	// iP внутренний КО 0..maxelm-1
	int iE=-1, iN=-1, iT=-1, iW=-1, iS=-1, iB=-1; // номера соседних контрольных объёмов
	iE=neighbors_for_the_internal_node[E_SIDE][0][iP]; iN=neighbors_for_the_internal_node[N_SIDE][0][iP]; iT=neighbors_for_the_internal_node[T_SIDE][0][iP];
	iW=neighbors_for_the_internal_node[W_SIDE][0][iP]; iS=neighbors_for_the_internal_node[S_SIDE][0][iP]; iB=neighbors_for_the_internal_node[B_SIDE][0][iP];


	sl[iP].iE=iE; sl[iP].iN=iN; sl[iP].iT=iT; 
	sl[iP].iS=iS; sl[iP].iW=iW; sl[iP].iB=iB;
	sl[iP].iP = iP;
	

	// 26.09.2016 Добавок для АЛИС сетки.
	int iE2=-1, iN2=-1, iT2=-1, iW2=-1, iS2=-1, iB2=-1; // номера соседних контрольных объёмов
	int iE3=-1, iN3=-1, iT3=-1, iW3=-1, iS3=-1, iB3=-1; // номера соседних контрольных объёмов
	int iE4=-1, iN4=-1, iT4=-1, iW4=-1, iS4=-1, iB4=-1; // номера соседних контрольных объёмов

	// -1 если не используется и [0..maxelm+maxbound-1] если используется.
	if (b_on_adaptive_local_refinement_mesh) {
		iE2 = neighbors_for_the_internal_node[E_SIDE][1][iP]; iN2 = neighbors_for_the_internal_node[N_SIDE][1][iP]; iT2 = neighbors_for_the_internal_node[T_SIDE][1][iP];
		iW2 = neighbors_for_the_internal_node[W_SIDE][1][iP]; iS2 = neighbors_for_the_internal_node[S_SIDE][1][iP]; iB2 = neighbors_for_the_internal_node[B_SIDE][1][iP];
		iE3 = neighbors_for_the_internal_node[E_SIDE][2][iP]; iN3 = neighbors_for_the_internal_node[N_SIDE][2][iP]; iT3 = neighbors_for_the_internal_node[T_SIDE][2][iP];
		iW3 = neighbors_for_the_internal_node[W_SIDE][2][iP]; iS3 = neighbors_for_the_internal_node[S_SIDE][2][iP]; iB3 = neighbors_for_the_internal_node[B_SIDE][2][iP];
		iE4 = neighbors_for_the_internal_node[E_SIDE][3][iP]; iN4 = neighbors_for_the_internal_node[N_SIDE][3][iP]; iT4 = neighbors_for_the_internal_node[T_SIDE][3][iP];
		iW4 = neighbors_for_the_internal_node[W_SIDE][3][iP]; iS4 = neighbors_for_the_internal_node[S_SIDE][3][iP]; iB4 = neighbors_for_the_internal_node[B_SIDE][3][iP];
	}

	sl[iP].iE2 = iE2; sl[iP].iN2 = iN2; sl[iP].iT2 = iT2;
	sl[iP].iS2 = iS2; sl[iP].iW2 = iW2; sl[iP].iB2 = iB2;

	sl[iP].iE3 = iE3; sl[iP].iN3 = iN3; sl[iP].iT3 = iT3;
	sl[iP].iS3 = iS3; sl[iP].iW3 = iW3; sl[iP].iB3 = iB3;

	sl[iP].iE4 = iE4; sl[iP].iN4 = iN4; sl[iP].iT4 = iT4;
	sl[iP].iS4 = iS4; sl[iP].iW4 = iW4; sl[iP].iB4 = iB4;

	sl[iP].b = 0.0;

	// Инициализирующее обнуление.
	sl[iP].ae = 0.0;
	sl[iP].aw = 0.0;
	sl[iP].an = 0.0;
	sl[iP].as = 0.0;
	sl[iP].at = 0.0;
	sl[iP].ab = 0.0;

	sl[iP].ae2 = 0.0;
	sl[iP].aw2 = 0.0;
	sl[iP].an2 = 0.0;
	sl[iP].as2 = 0.0;
	sl[iP].at2 = 0.0;
	sl[iP].ab2 = 0.0;

	sl[iP].ae3 = 0.0;
	sl[iP].aw3 = 0.0;
	sl[iP].an3 = 0.0;
	sl[iP].as3 = 0.0;
	sl[iP].at3 = 0.0;
	sl[iP].ab3 = 0.0;

	sl[iP].ae4 = 0.0;
	sl[iP].aw4 = 0.0;
	sl[iP].an4 = 0.0;
	sl[iP].as4 = 0.0;
	sl[iP].at4 = 0.0;
	sl[iP].ab4 = 0.0;

	// Признак присутствия связи.
	// От булевых флагов можно избавиться в целях экономии памяти ЭВМ.
	sl[iP].bE2 = false; sl[iP].bW2 = false; sl[iP].bS2 = false;
	sl[iP].bN2 = false; sl[iP].bB2 = false; sl[iP].bT2 = false;

	sl[iP].bE3 = false; sl[iP].bW3 = false; sl[iP].bS3 = false;
	sl[iP].bN3 = false; sl[iP].bB3 = false; sl[iP].bT3 = false;

	sl[iP].bE4 = false; sl[iP].bW4 = false; sl[iP].bS4 = false;
	sl[iP].bN4 = false; sl[iP].bB4 = false; sl[iP].bT4 = false;

	if (b_on_adaptive_local_refinement_mesh) {
		if (iE2 > -1) sl[iP].bE2 = true;
		if (iW2 > -1) sl[iP].bW2 = true;
		if (iN2 > -1) sl[iP].bN2 = true;
		if (iS2 > -1) sl[iP].bS2 = true;
		if (iT2 > -1) sl[iP].bT2 = true;
		if (iB2 > -1) sl[iP].bB2 = true;

		if (iE3 > -1) sl[iP].bE3 = true;
		if (iW3 > -1) sl[iP].bW3 = true;
		if (iN3 > -1) sl[iP].bN3 = true;
		if (iS3 > -1) sl[iP].bS3 = true;
		if (iT3 > -1) sl[iP].bT3 = true;
		if (iB3 > -1) sl[iP].bB3 = true;

		if (iE4 > -1) sl[iP].bE4 = true;
		if (iW4 > -1) sl[iP].bW4 = true;
		if (iN4 > -1) sl[iP].bN4 = true;
		if (iS4 > -1) sl[iP].bS4 = true;
		if (iT4 > -1) sl[iP].bT4 = true;
		if (iB4 > -1) sl[iP].bB4 = true;
	}

	// Внутренний КО.	

	// Если с одной из сторон стоит граница расчётной области
	// то соответствующая переменная равна true
	bool bE=false, bN=false, bT=false, bW=false, bS=false, bB=false;
        

	if (iE>=maxelm) bE=true;
	if (iN>=maxelm) bN=true;
	if (iT>=maxelm) bT=true;
    if (iW>=maxelm) bW=true;
	if (iS>=maxelm) bS=true;
	if (iB>=maxelm) bB=true;

	bool bE2 = false, bN2 = false, bT2 = false, bW2 = false, bS2 = false, bB2 = false;
	bool bE3 = false, bN3 = false, bT3 = false, bW3 = false, bS3 = false, bB3 = false;
	bool bE4 = false, bN4 = false, bT4 = false, bW4 = false, bS4 = false, bB4 = false;

	if (b_on_adaptive_local_refinement_mesh) {
		if (iE2 >= maxelm) bE2 = true;
		if (iN2 >= maxelm) bN2 = true;
		if (iT2 >= maxelm) bT2 = true;
		if (iW2 >= maxelm) bW2 = true;
		if (iS2 >= maxelm) bS2 = true;
		if (iB2 >= maxelm) bB2 = true;
	
		if (iE3 >= maxelm) bE3 = true;
		if (iN3 >= maxelm) bN3 = true;
		if (iT3 >= maxelm) bT3 = true;
		if (iW3 >= maxelm) bW3 = true;
		if (iS3 >= maxelm) bS3 = true;
		if (iB3 >= maxelm) bB3 = true;
	
		if (iE4 >= maxelm) bE4 = true;
		if (iN4 >= maxelm) bN4 = true;
		if (iT4 >= maxelm) bT4 = true;
		if (iW4 >= maxelm) bW4 = true;
		if (iS4 >= maxelm) bS4 = true;
		if (iB4 >= maxelm) bB4 = true;
	}

    /*
    if (iP==25) {
	#if doubleintprecision == 1
		printf("bE=%lld bN=%lld bT=%lld bW=%lld bS=%lld bB=%lld\n",bE,bN,bT,bW,bS,bB);
	#else
		printf("bE=%d bN=%d bT=%d bW=%d bS=%d bB=%d\n",bE,bN,bT,bW,bS,bB);
	#endif
        
        getchar();
	}*/

	// Разрыв связи с источником тепла в воздухе:
    bool bsE=false, bsN=false, bsT=false, bsW=false, bsS=false, bsB=false;
	bool bsE1 = false, bsN1 = false, bsT1 = false, bsW1 = false, bsS1 = false, bsB1 = false;
	// Если есть жидкие зоны и если 
	// iP принадлежит жидкой зоне и граничит с источником тепла внутри расчётной
	// области вдали от её границ, то тогда такую связь требуется порвать.
	// Случай когда источник тепла окружён двумя SOLID зонами не предусмотрен. 
	// Еще источник тепла может находится на границе расчётной области и граничить с жидкостью,
	// тогда такую связь разрывать не следует.
	// Для проверки выполнения заведём переменную 
	//bool binternalfindsituation = false;
	// здесь обрабатывается случай строго внутреннего источника тепла.
	/*
	if ((flow_interior>0)&&(ptr[1][iP]>-1)) {
		// Это означает просто что iP fluid объём.
		if (bE) {
		// граничит с источником тепла
		//if (border_neighbor[iE-maxelm].MCB<ls) bsE=true;
		// именно внутренний источник тепла между жидкостью
		// и твёрдым телом. Только в этом случае разрывается связь
		// с источником со стороны жидкости, в остальных случаях
		// если источник, например, лежит на границе расчётной области
		// и омывается жидкостью связь не прерывается. Это важно.
		if (binternalsource[iE-maxelm]) {
		bsE=true;
		//binternalfindsituation=true;
		}
		}
		if (bN) {
		//if (border_neighbor[iN-maxelm].MCB<ls) bsN=true;
		if (binternalsource[iN-maxelm]) {
		bsN=true;
		//binternalfindsituation=true;
		}
		}
		if (bT) {
		//if (border_neighbor[iT-maxelm].MCB<ls) bsT=true;
		if (binternalsource[iT-maxelm]) {
		bsT=true;
		//binternalfindsituation=true;
		}
		}
		if (bW) {
		// граничит с источником тепла
		//if (border_neighbor[iW-maxelm].MCB<ls) bsW=true;
		if (binternalsource[iW-maxelm]) {
		bsW=true;
		//binternalfindsituation=true;
		}
		}
		if (bS) {
		//if (border_neighbor[iS-maxelm].MCB<ls) bsS=true;
		if (binternalsource[iS-maxelm]) {
		bsS=true;
		//binternalfindsituation=true;
		}
		}
		if (bB) {
		//if (border_neighbor[iB-maxelm].MCB<ls) bsB=true;
		if (binternalsource[iB-maxelm]) {
		bsB=true;
		//binternalfindsituation=true;
		}
		}
		}
		*/
//else
/*{
	// 3 мая новая логика.
	// мы не рвём никаких внутренних связей в матрице.
	// Если мы на грани встречаем источник тепла то мы один раз (благодаря source2Dproblem)
	// выделяем мощность в объеме в ячейке примыкающей к источнику тепла.



	// Если мы идентифицировали внутренний источник тепла то мы рвём одну из связей
	// вне зависимости она solid-solid или solid-fluid.
	if (bE) {
	// граничит с источником тепла
	//if (border_neighbor[iE-maxelm].MCB<ls) bsE=true;
	// именно внутренний источник тепла между жидкостью
	// и твёрдым телом. Только в этом случае разрывается связь
	// с источником со стороны жидкости, в остальных случаях
	// если источник, например, лежит на границе расчётной области
	// и омывается жидкостью связь не прерывается. Это важно.
	if (binternalsource[iE - maxelm]) {
	if (sourse2Dproblem[iE - maxelm]) {
	//bsE = true;
	//binternalfindsituation = true;
	}
	sourse2Dproblem[iE - maxelm] = !sourse2Dproblem[iE - maxelm];
	}
	}
	if (bN) {
	//if (border_neighbor[iN-maxelm].MCB<ls) bsN=true;
	if (binternalsource[iN - maxelm]) {
	if (sourse2Dproblem[iN - maxelm]) {
	//bsN = true;
	//binternalfindsituation = true;
	}
	sourse2Dproblem[iN - maxelm] = !sourse2Dproblem[iN - maxelm];
	}
	}
	if (bT) {
	//if (border_neighbor[iT-maxelm].MCB<ls) bsT=true;
	if (binternalsource[iT - maxelm]) {
	if (sourse2Dproblem[iT - maxelm]) {
	//bsT = true;
	//binternalfindsituation = true;
	}
	}
	sourse2Dproblem[iT - maxelm] = !sourse2Dproblem[iT - maxelm];
	}
	if (bW) {
	// граничит с источником тепла
	//if (border_neighbor[iW-maxelm].MCB<ls) bsW=true;
	if (binternalsource[iW - maxelm]) {
	if (sourse2Dproblem[iW - maxelm]) {
	//bsW = true;
	//binternalfindsituation = true;
	}
	}
	sourse2Dproblem[iW - maxelm] = !sourse2Dproblem[iW - maxelm];
	}
	if (bS) {
	//if (border_neighbor[iS-maxelm].MCB<ls) bsS=true;
	if (binternalsource[iS - maxelm]) {
	if (sourse2Dproblem[iS - maxelm]) {
	//bsS = true;
	//binternalfindsituation = true;
	}
	}
	sourse2Dproblem[iS - maxelm] = !sourse2Dproblem[iS - maxelm];
	}
	if (bB) {
	//if (border_neighbor[iB-maxelm].MCB<ls) bsB=true;
	if (binternalsource[iB - maxelm]) {
	if (sourse2Dproblem[iB - maxelm]) {
	//bsB = true;
	//binternalfindsituation = true;
	}
	}
	sourse2Dproblem[iB - maxelm] = !sourse2Dproblem[iB - maxelm];
	}
	}
	//*/



	//bsE=false; bsN=false; bsT=false; bsW=false; bsS=false; bsB=false; // сброс обрыва связи !!!

	// debug.
	/*if (binternalfindsituation) {
		printf("find internal source...\n");
		getchar();
	}*/

	/*	
    if ((iP>=25)&&(iP<=29)) {
	#if doubleintprecision == 1
		printf("bsE=%lld bsN=%lld bsT=%lld bsW=%lld bsS=%lld bsB=%lld\n",bsE,bsN,bsT,bsW,bsS,bsB);
	#else
		printf("bsE=%d bsN=%d bsT=%d bsW=%d bsS=%d bsB=%d\n",bsE,bsN,bsT,bsW,bsS,bsB);
	#endif
        
        getchar();
	}*/

	// вычисление размеров текущего контрольного объёма:
	doublereal dx=0.0, dy=0.0, dz=0.0;// объём текущего контрольного объёма
	volume3D(iP, nvtx, pa, dx, dy, dz);
	dx = fabs(dx);
	dy = fabs(dy);
	dz = fabs(dz);


	TOCHKA pointP0;
	center_cord3D(iP, nvtx, pa, pointP0, 100);
	

	// для маркировки внутреннего тепловыделения надо: iP булев индикатор, номер источника MCB и всё.

	doublereal Sc2D = 0.0;
	{
		if (bE) {
			if (border_neighbor[iE - maxelm].MCB < ls) {
				
				// Разрываем связь с плоской гранью,
				// делаём обработку как будто мы строго внутренность обрабатываем.
				if ((border_neighbor[iE - maxelm].iI1>-1) && (border_neighbor[iE - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iE - maxelm].iI1] - prop[LAM][border_neighbor[iE - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iE - maxelm]) {
							Sc2D = ((dy*dz / s[border_neighbor[iE - maxelm].MCB].square)*s[border_neighbor[iE - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iE - maxelm] = !sourse2Dproblem[iE - maxelm];
					}
					else {
						if (iP == border_neighbor[iE - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iE - maxelm].iI2]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE - maxelm].MCB].square)*s[border_neighbor[iE - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iE - maxelm] = !sourse2Dproblem[iE - maxelm];
							}
						}
						if (iP == border_neighbor[iE - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iE - maxelm].iI1]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE - maxelm].MCB].square)*s[border_neighbor[iE - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iE - maxelm] = !sourse2Dproblem[iE - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iE - maxelm].iI1) {
						iE = border_neighbor[iE - maxelm].iI2;
					}
					else {
						iE = border_neighbor[iE - maxelm].iI1;
					}
					sl[iP].iE = iE;
					bE = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					// Этого случая никогда не будет, т.к.
					// сеточный генератор работает таким образом,
					// что источник тепла всегда лежит внутри 
					// расчётной области а не на её границе.
					// Проверено 11.07.2016.
					if (border_neighbor[iE - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iE - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** E \n");
					//getchar();
					system("PAUSE");
				}
#endif
				//bsE1 = true;

			}
			
		}
		if (bW) {
			if (border_neighbor[iW - maxelm].MCB < ls) {
				
				
				if ((border_neighbor[iW - maxelm].iI1>-1) && (border_neighbor[iW - maxelm].iI2>-1)) {


					if (fabs(prop[LAM][border_neighbor[iW - maxelm].iI1] - prop[LAM][border_neighbor[iW - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iW - maxelm]) {
							Sc2D = ((dy*dz / s[border_neighbor[iW - maxelm].MCB].square)*s[border_neighbor[iW - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iW - maxelm] = !sourse2Dproblem[iW - maxelm];
					}
					else {
						if (iP == border_neighbor[iW - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iW - maxelm].iI2]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW - maxelm].MCB].square)*s[border_neighbor[iW - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iW - maxelm] = !sourse2Dproblem[iW - maxelm];
							}
						}
						if (iP == border_neighbor[iW - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iW - maxelm].iI1]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW - maxelm].MCB].square)*s[border_neighbor[iW - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iW - maxelm] = !sourse2Dproblem[iW - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}


					if (iP == border_neighbor[iW - maxelm].iI1) {
						iW = border_neighbor[iW - maxelm].iI2;
					}
					else {
						iW = border_neighbor[iW - maxelm].iI1;
					}
					sl[iP].iW = iW;
					bW = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iW - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iW - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** W\n");
					//getchar();
					system("PAUSE");
				}
				//bsW1 = true;
#endif
			}
			
		}
		if (bN) {
			if (border_neighbor[iN - maxelm].MCB < ls) {
				
				if((border_neighbor[iN - maxelm].iI1>-1) && (border_neighbor[iN - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iN - maxelm].iI1] - prop[LAM][border_neighbor[iN - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iN - maxelm]) {
							Sc2D = ((dx*dz / s[border_neighbor[iN - maxelm].MCB].square)*s[border_neighbor[iN - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iN - maxelm] = !sourse2Dproblem[iN - maxelm];
					}
					else {
						if (iP == border_neighbor[iN - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iN - maxelm].iI2]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN - maxelm].MCB].square)*s[border_neighbor[iN - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iN - maxelm] = !sourse2Dproblem[iN - maxelm];
							}
						}
						if (iP == border_neighbor[iN - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iN - maxelm].iI1]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN - maxelm].MCB].square)*s[border_neighbor[iN - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iN - maxelm] = !sourse2Dproblem[iN - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iN - maxelm].iI1) {
						iN = border_neighbor[iN - maxelm].iI2;
					}
					else {
						iN = border_neighbor[iN - maxelm].iI1;
					}
					sl[iP].iN = iN;
					bN = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iN - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iN - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** N\n");
					//getchar();
					system("PAUSE");
				}
				//bsN1 = true;
#endif
			}
			
		}
		if (bS) {
			if (border_neighbor[iS -maxelm].MCB < ls) {
				


				if ((border_neighbor[iS - maxelm].iI1>-1) && (border_neighbor[iS - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iS - maxelm].iI1] - prop[LAM][border_neighbor[iS - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iS - maxelm]) {
							Sc2D = ((dx*dz / s[border_neighbor[iS - maxelm].MCB].square)*s[border_neighbor[iS - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iS - maxelm] = !sourse2Dproblem[iS - maxelm];
					}
					else {
						if (iP == border_neighbor[iS - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iS - maxelm].iI2]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS - maxelm].MCB].square)*s[border_neighbor[iS - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iS - maxelm] = !sourse2Dproblem[iS - maxelm];
							}
						}
						if (iP == border_neighbor[iS - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iS - maxelm].iI1]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS - maxelm].MCB].square)*s[border_neighbor[iS - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iS - maxelm] = !sourse2Dproblem[iS - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}



					if (iP == border_neighbor[iS - maxelm].iI1) {
						iS = border_neighbor[iS - maxelm].iI2;
					}
					else {
						iS = border_neighbor[iS - maxelm].iI1;
					}
					sl[iP].iS = iS;
					bS = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iS - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iS - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** S\n");
					//getchar();
					system("PAUSE");
				}
				//bsS1 = true;
#endif
			}
			
		}
		if (bT) {
			if (border_neighbor[iT - maxelm].MCB < ls) {
				



				if ((border_neighbor[iT - maxelm].iI1>-1) && (border_neighbor[iT - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iT - maxelm].iI1] - prop[LAM][border_neighbor[iT - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iT - maxelm]) {
							Sc2D = ((dx*dy / s[border_neighbor[iT - maxelm].MCB].square)*s[border_neighbor[iT - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iT - maxelm] = !sourse2Dproblem[iT - maxelm];
					}
					else {
						if (iP == border_neighbor[iT - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iT - maxelm].iI2]) {
								
								Sc2D = ((dx*dy / s[border_neighbor[iT - maxelm].MCB].square)*s[border_neighbor[iT - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iT - maxelm] = !sourse2Dproblem[iT - maxelm];
							}
						}
						if (iP == border_neighbor[iT - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iT - maxelm].iI1]) {
								Sc2D = ((dx*dy / s[border_neighbor[iT - maxelm].MCB].square)*s[border_neighbor[iT - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iT - maxelm] = !sourse2Dproblem[iT - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}


					if (iP == border_neighbor[iT - maxelm].iI1) {
						iT = border_neighbor[iT - maxelm].iI2;
					}
					else {
						iT = border_neighbor[iT - maxelm].iI1;
					}
					sl[iP].iT = iT;
					bT = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iT - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iT - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** T\n");
					//getchar();
					system("PAUSE");
				}
				//bsT1 = true;
#endif
			}
			
		}
		if (bB) {
			if (border_neighbor[iB - maxelm].MCB < ls) {
				

				if ((border_neighbor[iB - maxelm].iI1>-1) && (border_neighbor[iB - maxelm].iI2>-1)) {
				
					if (fabs(prop[LAM][border_neighbor[iB - maxelm].iI1] - prop[LAM][border_neighbor[iB - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iB - maxelm]) {
							Sc2D = ((dx*dy / s[border_neighbor[iB - maxelm].MCB].square)*s[border_neighbor[iB - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iB - maxelm] = !sourse2Dproblem[iB - maxelm];
					}
					else {
						if (iP == border_neighbor[iB - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iB - maxelm].iI2]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB - maxelm].MCB].square)*s[border_neighbor[iB - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iB - maxelm] = !sourse2Dproblem[iB - maxelm];
							}
						}
						if (iP == border_neighbor[iB - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iB - maxelm].iI1]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB - maxelm].MCB].square)*s[border_neighbor[iB - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iB - maxelm] = !sourse2Dproblem[iB - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}
					
					if (iP == border_neighbor[iB - maxelm].iI1) {
						iB = border_neighbor[iB - maxelm].iI2;
					}
					else {
						iB = border_neighbor[iB - maxelm].iI1;
					}
					sl[iP].iB = iB;
					bB = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iB - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iB - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** B\n");
					//getchar();
					system("PAUSE");
				}
				//bsB1 = true;
#endif
			}
			
		}

		if (b_on_adaptive_local_refinement_mesh) { 

		if (bE2) {
			if (border_neighbor[iE2 - maxelm].MCB < ls) {

				// Разрываем связь с плоской гранью,
				// делаём обработку как будто мы строго внутренность обрабатываем.
				if ((border_neighbor[iE2 - maxelm].iI1>-1) && (border_neighbor[iE2 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iE2 - maxelm].iI1] - prop[LAM][border_neighbor[iE2 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iE2 - maxelm]) {
							Sc2D = ((dy*dz / s[border_neighbor[iE2 - maxelm].MCB].square)*s[border_neighbor[iE2 - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iE2 - maxelm] = !sourse2Dproblem[iE2 - maxelm];
					}
					else {
						if (iP == border_neighbor[iE2 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iE2 - maxelm].iI2]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE2 - maxelm].MCB].square)*s[border_neighbor[iE2 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iE2 - maxelm] = !sourse2Dproblem[iE2 - maxelm];
							}
						}
						if (iP == border_neighbor[iE2 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iE2 - maxelm].iI1]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE2 - maxelm].MCB].square)*s[border_neighbor[iE2 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iE2 - maxelm] = !sourse2Dproblem[iE2 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iE2 - maxelm].iI1) {
						iE2 = border_neighbor[iE2 - maxelm].iI2;
					}
					else {
						iE2 = border_neighbor[iE2 - maxelm].iI1;
					}
					sl[iP].iE2 = iE2;
					bE2 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					// Этого случая никогда не будет, т.к.
					// сеточный генератор работает таким образом,
					// что источник тепла всегда лежит внутри 
					// расчётной области а не на её границе.
					// Проверено 11.07.2016.
					if (border_neighbor[iE2 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iE2 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** E \n");
					//getchar();
					system("PAUSE");
				}
				//bsE1 = true;
#endif

			}

		}
		if (bW2) {
			if (border_neighbor[iW2 - maxelm].MCB < ls) {


				if ((border_neighbor[iW2 - maxelm].iI1>-1) && (border_neighbor[iW2 - maxelm].iI2>-1)) {


					if (fabs(prop[LAM][border_neighbor[iW2 - maxelm].iI1] - prop[LAM][border_neighbor[iW2 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iW2 - maxelm]) {
							Sc2D = ((dy*dz / s[border_neighbor[iW2 - maxelm].MCB].square)*s[border_neighbor[iW2 - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iW2 - maxelm] = !sourse2Dproblem[iW2 - maxelm];
					}
					else {
						if (iP == border_neighbor[iW2 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iW2 - maxelm].iI2]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW2 - maxelm].MCB].square)*s[border_neighbor[iW2 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iW2 - maxelm] = !sourse2Dproblem[iW2 - maxelm];
							}
						}
						if (iP == border_neighbor[iW2 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iW2 - maxelm].iI1]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW2 - maxelm].MCB].square)*s[border_neighbor[iW2 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iW2 - maxelm] = !sourse2Dproblem[iW2 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}


					if (iP == border_neighbor[iW2 - maxelm].iI1) {
						iW2 = border_neighbor[iW2 - maxelm].iI2;
					}
					else {
						iW2 = border_neighbor[iW2 - maxelm].iI1;
					}
					sl[iP].iW2 = iW2;
					bW2 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iW2 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iW2 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** W\n");
					//getchar();
					system("PAUSE");
				}
				//bsW1 = true;
#endif
			}

		}
		if (bN2) {
			if (border_neighbor[iN2 - maxelm].MCB < ls) {

				if ((border_neighbor[iN2 - maxelm].iI1>-1) && (border_neighbor[iN2 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iN2 - maxelm].iI1] - prop[LAM][border_neighbor[iN2 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iN2 - maxelm]) {
							Sc2D = ((dx*dz / s[border_neighbor[iN2 - maxelm].MCB].square)*s[border_neighbor[iN2 - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iN2 - maxelm] = !sourse2Dproblem[iN2 - maxelm];
					}
					else {
						if (iP == border_neighbor[iN2 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iN2 - maxelm].iI2]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN2 - maxelm].MCB].square)*s[border_neighbor[iN2 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iN2 - maxelm] = !sourse2Dproblem[iN2 - maxelm];
							}
						}
						if (iP == border_neighbor[iN2 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iN2 - maxelm].iI1]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN2 - maxelm].MCB].square)*s[border_neighbor[iN2 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iN2 - maxelm] = !sourse2Dproblem[iN2 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iN2 - maxelm].iI1) {
						iN2 = border_neighbor[iN2 - maxelm].iI2;
					}
					else {
						iN2 = border_neighbor[iN2 - maxelm].iI1;
					}
					sl[iP].iN2 = iN2;
					bN2 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iN2 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iN2 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** N\n");
					//getchar();
					system("PAUSE");
				}
				//bsN1 = true;
#endif
			}

		}
		if (bS2) {
			if (border_neighbor[iS2 - maxelm].MCB < ls) {



				if ((border_neighbor[iS2 - maxelm].iI1>-1) && (border_neighbor[iS2 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iS2 - maxelm].iI1] - prop[LAM][border_neighbor[iS2 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iS2 - maxelm]) {
							Sc2D = ((dx*dz / s[border_neighbor[iS2 - maxelm].MCB].square)*s[border_neighbor[iS2 - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iS2 - maxelm] = !sourse2Dproblem[iS2 - maxelm];
					}
					else {
						if (iP == border_neighbor[iS2 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iS2 - maxelm].iI2]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS2 - maxelm].MCB].square)*s[border_neighbor[iS2 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iS2 - maxelm] = !sourse2Dproblem[iS2 - maxelm];
							}
						}
						if (iP == border_neighbor[iS2 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iS2 - maxelm].iI1]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS2 - maxelm].MCB].square)*s[border_neighbor[iS2 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iS2 - maxelm] = !sourse2Dproblem[iS2 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}



					if (iP == border_neighbor[iS2 - maxelm].iI1) {
						iS2 = border_neighbor[iS2 - maxelm].iI2;
					}
					else {
						iS2 = border_neighbor[iS2 - maxelm].iI1;
					}
					sl[iP].iS2 = iS2;
					bS2 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iS2 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iS2 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** S\n");
					//getchar();
					system("PAUSE");
				}
				//bsS1 = true;
#endif
			}

		}
		if (bT2) {
			if (border_neighbor[iT2 - maxelm].MCB < ls) {




				if ((border_neighbor[iT2 - maxelm].iI1>-1) && (border_neighbor[iT2 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iT2 - maxelm].iI1] - prop[LAM][border_neighbor[iT2 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iT2 - maxelm]) {
							Sc2D = ((dx*dy / s[border_neighbor[iT2 - maxelm].MCB].square)*s[border_neighbor[iT2 - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iT2 - maxelm] = !sourse2Dproblem[iT2 - maxelm];
					}
					else {
						if (iP == border_neighbor[iT2 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iT2 - maxelm].iI2]) {

								Sc2D = ((dx*dy / s[border_neighbor[iT2 - maxelm].MCB].square)*s[border_neighbor[iT2 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iT2 - maxelm] = !sourse2Dproblem[iT2 - maxelm];
							}
						}
						if (iP == border_neighbor[iT2 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iT2 - maxelm].iI1]) {
								Sc2D = ((dx*dy / s[border_neighbor[iT2 - maxelm].MCB].square)*s[border_neighbor[iT2 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iT2 - maxelm] = !sourse2Dproblem[iT2 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}


					if (iP == border_neighbor[iT2 - maxelm].iI1) {
						iT2 = border_neighbor[iT2 - maxelm].iI2;
					}
					else {
						iT2 = border_neighbor[iT2 - maxelm].iI1;
					}
					sl[iP].iT2 = iT2;
					bT2 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iT2 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iT2 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** T\n");
					//getchar();
					system("PAUSE");
				}
				//bsT1 = true;
#endif
			}

		}
		if (bB2) {
			if (border_neighbor[iB2 - maxelm].MCB < ls) {


				if ((border_neighbor[iB2 - maxelm].iI1>-1) && (border_neighbor[iB2 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iB2 - maxelm].iI1] - prop[LAM][border_neighbor[iB2 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iB2 - maxelm]) {
							Sc2D = ((dx*dy / s[border_neighbor[iB2 - maxelm].MCB].square)*s[border_neighbor[iB2 - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iB2 - maxelm] = !sourse2Dproblem[iB2 - maxelm];
					}
					else {
						if (iP == border_neighbor[iB2 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iB2 - maxelm].iI2]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB2 - maxelm].MCB].square)*s[border_neighbor[iB2 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iB2 - maxelm] = !sourse2Dproblem[iB2 - maxelm];
							}
						}
						if (iP == border_neighbor[iB2 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iB2 - maxelm].iI1]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB2 - maxelm].MCB].square)*s[border_neighbor[iB2 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iB2 - maxelm] = !sourse2Dproblem[iB2 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iB2 - maxelm].iI1) {
						iB2 = border_neighbor[iB2 - maxelm].iI2;
					}
					else {
						iB2 = border_neighbor[iB2 - maxelm].iI1;
					}
					sl[iP].iB2 = iB2;
					bB2 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iB2 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iB2 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** B\n");
					//getchar();
					system("PAUSE");
				}
				//bsB1 = true;
#endif
			}

		}

		if (bE3) {
			if (border_neighbor[iE3 - maxelm].MCB < ls) {

				// Разрываем связь с плоской гранью,
				// делаём обработку как будто мы строго внутренность обрабатываем.
				if ((border_neighbor[iE3 - maxelm].iI1>-1) && (border_neighbor[iE3 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iE3 - maxelm].iI1] - prop[LAM][border_neighbor[iE3 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iE3 - maxelm]) {
							Sc2D = ((dy*dz / s[border_neighbor[iE3 - maxelm].MCB].square)*s[border_neighbor[iE3 - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iE3 - maxelm] = !sourse2Dproblem[iE3 - maxelm];
					}
					else {
						if (iP == border_neighbor[iE3 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iE3 - maxelm].iI2]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE3 - maxelm].MCB].square)*s[border_neighbor[iE3 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iE3 - maxelm] = !sourse2Dproblem[iE3 - maxelm];
							}
						}
						if (iP == border_neighbor[iE3 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iE3 - maxelm].iI1]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE3 - maxelm].MCB].square)*s[border_neighbor[iE3 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iE3 - maxelm] = !sourse2Dproblem[iE3 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iE3 - maxelm].iI1) {
						iE3 = border_neighbor[iE3 - maxelm].iI2;
					}
					else {
						iE3 = border_neighbor[iE3 - maxelm].iI1;
					}
					sl[iP].iE3 = iE3;
					bE3 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					// Этого случая никогда не будет, т.к.
					// сеточный генератор работает таким образом,
					// что источник тепла всегда лежит внутри 
					// расчётной области а не на её границе.
					// Проверено 11.07.2016.
					if (border_neighbor[iE3 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iE3 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** E \n");
					//getchar();
					system("PAUSE");
				}
				//bsE1 = true;
#endif

			}

		}
		if (bW3) {
			if (border_neighbor[iW3 - maxelm].MCB < ls) {


				if ((border_neighbor[iW3 - maxelm].iI1>-1) && (border_neighbor[iW3 - maxelm].iI2>-1)) {


					if (fabs(prop[LAM][border_neighbor[iW3 - maxelm].iI1] - prop[LAM][border_neighbor[iW3 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iW3 - maxelm]) {
							Sc2D = ((dy*dz / s[border_neighbor[iW3 - maxelm].MCB].square)*s[border_neighbor[iW3 - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iW3 - maxelm] = !sourse2Dproblem[iW3 - maxelm];
					}
					else {
						if (iP == border_neighbor[iW3 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iW3 - maxelm].iI2]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW3 - maxelm].MCB].square)*s[border_neighbor[iW3 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iW3 - maxelm] = !sourse2Dproblem[iW3 - maxelm];
							}
						}
						if (iP == border_neighbor[iW3 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iW3 - maxelm].iI1]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW3 - maxelm].MCB].square)*s[border_neighbor[iW3 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iW3 - maxelm] = !sourse2Dproblem[iW3 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}


					if (iP == border_neighbor[iW3 - maxelm].iI1) {
						iW3 = border_neighbor[iW3 - maxelm].iI2;
					}
					else {
						iW3 = border_neighbor[iW3 - maxelm].iI1;
					}
					sl[iP].iW3 = iW3;
					bW3 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iW3 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iW3 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** W\n");
					//getchar();
					system("PAUSE");
				}
				//bsW1 = true;
#endif
			}

		}
		if (bN3) {
			if (border_neighbor[iN3 - maxelm].MCB < ls) {

				if ((border_neighbor[iN3 - maxelm].iI1>-1) && (border_neighbor[iN3 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iN3 - maxelm].iI1] - prop[LAM][border_neighbor[iN3 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iN3 - maxelm]) {
							Sc2D = ((dx*dz / s[border_neighbor[iN3 - maxelm].MCB].square)*s[border_neighbor[iN3 - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iN3 - maxelm] = !sourse2Dproblem[iN3 - maxelm];
					}
					else {
						if (iP == border_neighbor[iN3 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iN3 - maxelm].iI2]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN3 - maxelm].MCB].square)*s[border_neighbor[iN3 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iN3 - maxelm] = !sourse2Dproblem[iN3 - maxelm];
							}
						}
						if (iP == border_neighbor[iN3 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iN3 - maxelm].iI1]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN3 - maxelm].MCB].square)*s[border_neighbor[iN3 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iN3 - maxelm] = !sourse2Dproblem[iN3 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iN3 - maxelm].iI1) {
						iN3 = border_neighbor[iN3 - maxelm].iI2;
					}
					else {
						iN3 = border_neighbor[iN3 - maxelm].iI1;
					}
					sl[iP].iN3 = iN3;
					bN3 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iN3 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iN3 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** N\n");
					//getchar();
					system("PAUSE");
				}
				//bsN1 = true;
#endif
			}

		}
		if (bS3) {
			if (border_neighbor[iS3 - maxelm].MCB < ls) {



				if ((border_neighbor[iS3 - maxelm].iI1>-1) && (border_neighbor[iS3 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iS3 - maxelm].iI1] - prop[LAM][border_neighbor[iS3 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iS3 - maxelm]) {
							Sc2D = ((dx*dz / s[border_neighbor[iS3 - maxelm].MCB].square)*s[border_neighbor[iS3 - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iS3 - maxelm] = !sourse2Dproblem[iS3 - maxelm];
					}
					else {
						if (iP == border_neighbor[iS3 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iS3 - maxelm].iI2]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS3 - maxelm].MCB].square)*s[border_neighbor[iS3 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iS3 - maxelm] = !sourse2Dproblem[iS3 - maxelm];
							}
						}
						if (iP == border_neighbor[iS3 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iS3 - maxelm].iI1]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS3 - maxelm].MCB].square)*s[border_neighbor[iS3 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iS3 - maxelm] = !sourse2Dproblem[iS3 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}



					if (iP == border_neighbor[iS3 - maxelm].iI1) {
						iS3 = border_neighbor[iS3 - maxelm].iI2;
					}
					else {
						iS3 = border_neighbor[iS3 - maxelm].iI1;
					}
					sl[iP].iS3 = iS3;
					bS3 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iS3 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iS3 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** S\n");
					//getchar();
					system("PAUSE");
				}
				//bsS1 = true;
#endif
			}

		}
		if (bT3) {
			if (border_neighbor[iT3 - maxelm].MCB < ls) {




				if ((border_neighbor[iT3 - maxelm].iI1>-1) && (border_neighbor[iT3 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iT3 - maxelm].iI1] - prop[LAM][border_neighbor[iT3 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iT3 - maxelm]) {
							Sc2D = ((dx*dy / s[border_neighbor[iT3 - maxelm].MCB].square)*s[border_neighbor[iT3 - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iT3 - maxelm] = !sourse2Dproblem[iT3 - maxelm];
					}
					else {
						if (iP == border_neighbor[iT3 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iT3 - maxelm].iI2]) {

								Sc2D = ((dx*dy / s[border_neighbor[iT3 - maxelm].MCB].square)*s[border_neighbor[iT3 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iT3 - maxelm] = !sourse2Dproblem[iT3 - maxelm];
							}
						}
						if (iP == border_neighbor[iT3 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iT3 - maxelm].iI1]) {
								Sc2D = ((dx*dy / s[border_neighbor[iT3 - maxelm].MCB].square)*s[border_neighbor[iT3 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iT3 - maxelm] = !sourse2Dproblem[iT3 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}


					if (iP == border_neighbor[iT3 - maxelm].iI1) {
						iT3 = border_neighbor[iT3 - maxelm].iI2;
					}
					else {
						iT3 = border_neighbor[iT3 - maxelm].iI1;
					}
					sl[iP].iT3 = iT3;
					bT3 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iT3 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iT3 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** T\n");
					//getchar();
					system("PAUSE");
				}
				//bsT1 = true;
#endif
			}

		}
		if (bB3) {
			if (border_neighbor[iB3 - maxelm].MCB < ls) {


				if ((border_neighbor[iB3 - maxelm].iI1>-1) && (border_neighbor[iB3 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iB3 - maxelm].iI1] - prop[LAM][border_neighbor[iB3 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iB3 - maxelm]) {
							Sc2D = ((dx*dy / s[border_neighbor[iB3 - maxelm].MCB].square)*s[border_neighbor[iB3 - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iB3 - maxelm] = !sourse2Dproblem[iB3 - maxelm];
					}
					else {
						if (iP == border_neighbor[iB3 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iB3 - maxelm].iI2]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB3 - maxelm].MCB].square)*s[border_neighbor[iB3 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iB3 - maxelm] = !sourse2Dproblem[iB3 - maxelm];
							}
						}
						if (iP == border_neighbor[iB3 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iB3 - maxelm].iI1]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB3 - maxelm].MCB].square)*s[border_neighbor[iB3 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iB3 - maxelm] = !sourse2Dproblem[iB3 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iB3 - maxelm].iI1) {
						iB3 = border_neighbor[iB3 - maxelm].iI2;
					}
					else {
						iB3 = border_neighbor[iB3 - maxelm].iI1;
					}
					sl[iP].iB3 = iB3;
					bB3 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iB3 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iB3 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** B\n");
					//getchar();
					system("PAUSE");
				}
				//bsB1 = true;
#endif
			}

		}

		if (bE4) {
			if (border_neighbor[iE4 - maxelm].MCB < ls) {

				// Разрываем связь с плоской гранью,
				// делаём обработку как будто мы строго внутренность обрабатываем.
				if ((border_neighbor[iE4 - maxelm].iI1>-1) && (border_neighbor[iE4 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iE4 - maxelm].iI1] - prop[LAM][border_neighbor[iE4 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iE4 - maxelm]) {
							Sc2D = ((dy*dz / s[border_neighbor[iE4 - maxelm].MCB].square)*s[border_neighbor[iE4 - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iE4 - maxelm] = !sourse2Dproblem[iE4 - maxelm];
					}
					else {
						if (iP == border_neighbor[iE4 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iE4 - maxelm].iI2]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE4 - maxelm].MCB].square)*s[border_neighbor[iE4 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iE4 - maxelm] = !sourse2Dproblem[iE4 - maxelm];
							}
						}
						if (iP == border_neighbor[iE4 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iE4 - maxelm].iI1]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE4 - maxelm].MCB].square)*s[border_neighbor[iE4 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iE4 - maxelm] = !sourse2Dproblem[iE4 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iE4 - maxelm].iI1) {
						iE4 = border_neighbor[iE4 - maxelm].iI2;
					}
					else {
						iE4 = border_neighbor[iE4 - maxelm].iI1;
					}
					sl[iP].iE4 = iE4;
					bE4 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					// Этого случая никогда не будет, т.к.
					// сеточный генератор работает таким образом,
					// что источник тепла всегда лежит внутри 
					// расчётной области а не на её границе.
					// Проверено 11.07.2016.
					if (border_neighbor[iE4 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iE4 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** E \n");
					//getchar();
					system("PAUSE");
				}
				//bsE1 = true;
#endif

			}

		}
		if (bW4) {
			if (border_neighbor[iW4 - maxelm].MCB < ls) {


				if ((border_neighbor[iW4 - maxelm].iI1>-1) && (border_neighbor[iW4 - maxelm].iI2>-1)) {


					if (fabs(prop[LAM][border_neighbor[iW4 - maxelm].iI1] - prop[LAM][border_neighbor[iW4 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iW4 - maxelm]) {
							Sc2D = ((dy*dz / s[border_neighbor[iW4 - maxelm].MCB].square)*s[border_neighbor[iW4 - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iW4 - maxelm] = !sourse2Dproblem[iW4 - maxelm];
					}
					else {
						if (iP == border_neighbor[iW4 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iW4 - maxelm].iI2]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW4 - maxelm].MCB].square)*s[border_neighbor[iW4 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iW4 - maxelm] = !sourse2Dproblem[iW4 - maxelm];
							}
						}
						if (iP == border_neighbor[iW4 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iW4 - maxelm].iI1]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW4 - maxelm].MCB].square)*s[border_neighbor[iW4 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iW4 - maxelm] = !sourse2Dproblem[iW4 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}


					if (iP == border_neighbor[iW4 - maxelm].iI1) {
						iW4 = border_neighbor[iW4 - maxelm].iI2;
					}
					else {
						iW4 = border_neighbor[iW4 - maxelm].iI1;
					}
					sl[iP].iW4 = iW4;
					bW4 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iW4 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iW4 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** W\n");
					//getchar();
					system("PAUSE");
				}
				//bsW1 = true;
#endif
			}

		}
		if (bN4) {
			if (border_neighbor[iN4 - maxelm].MCB < ls) {

				if ((border_neighbor[iN4 - maxelm].iI1>-1) && (border_neighbor[iN4 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iN4 - maxelm].iI1] - prop[LAM][border_neighbor[iN4 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iN4 - maxelm]) {
							Sc2D = ((dx*dz / s[border_neighbor[iN4 - maxelm].MCB].square)*s[border_neighbor[iN4 - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iN4 - maxelm] = !sourse2Dproblem[iN4 - maxelm];
					}
					else {
						if (iP == border_neighbor[iN4 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iN4 - maxelm].iI2]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN4 - maxelm].MCB].square)*s[border_neighbor[iN4 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iN4 - maxelm] = !sourse2Dproblem[iN4 - maxelm];
							}
						}
						if (iP == border_neighbor[iN4 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iN4 - maxelm].iI1]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN4 - maxelm].MCB].square)*s[border_neighbor[iN4 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iN4 - maxelm] = !sourse2Dproblem[iN4 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iN4 - maxelm].iI1) {
						iN4 = border_neighbor[iN4 - maxelm].iI2;
					}
					else {
						iN4 = border_neighbor[iN4 - maxelm].iI1;
					}
					sl[iP].iN4 = iN4;
					bN4 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iN4 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iN4 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** N\n");
					//getchar();
					system("PAUSE");
				}
				//bsN1 = true;
#endif
			}

		}
		if (bS4) {
			if (border_neighbor[iS4 - maxelm].MCB < ls) {



				if ((border_neighbor[iS4 - maxelm].iI1>-1) && (border_neighbor[iS4 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iS4 - maxelm].iI1] - prop[LAM][border_neighbor[iS4 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iS4 - maxelm]) {
							Sc2D = ((dx*dz / s[border_neighbor[iS4 - maxelm].MCB].square)*s[border_neighbor[iS4 - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iS4 - maxelm] = !sourse2Dproblem[iS4 - maxelm];
					}
					else {
						if (iP == border_neighbor[iS4 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iS4 - maxelm].iI2]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS4 - maxelm].MCB].square)*s[border_neighbor[iS4 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iS4 - maxelm] = !sourse2Dproblem[iS4 - maxelm];
							}
						}
						if (iP == border_neighbor[iS4 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iS4 - maxelm].iI1]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS4 - maxelm].MCB].square)*s[border_neighbor[iS4 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iS4 - maxelm] = !sourse2Dproblem[iS4 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}



					if (iP == border_neighbor[iS4 - maxelm].iI1) {
						iS4 = border_neighbor[iS4 - maxelm].iI2;
					}
					else {
						iS4 = border_neighbor[iS4 - maxelm].iI1;
					}
					sl[iP].iS4 = iS4;
					bS4 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iS4 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iS4 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** S\n");
					//getchar();
					system("PAUSE");
				}
				//bsS1 = true;
#endif
			}

		}
		if (bT4) {
			if (border_neighbor[iT4 - maxelm].MCB < ls) {




				if ((border_neighbor[iT4 - maxelm].iI1>-1) && (border_neighbor[iT4 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iT4 - maxelm].iI1] - prop[LAM][border_neighbor[iT4 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iT4 - maxelm]) {
							Sc2D = ((dx*dy / s[border_neighbor[iT4 - maxelm].MCB].square)*s[border_neighbor[iT4 - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iT4 - maxelm] = !sourse2Dproblem[iT4 - maxelm];
					}
					else {
						if (iP == border_neighbor[iT4 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iT4 - maxelm].iI2]) {

								Sc2D = ((dx*dy / s[border_neighbor[iT4 - maxelm].MCB].square)*s[border_neighbor[iT4 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iT4 - maxelm] = !sourse2Dproblem[iT4 - maxelm];
							}
						}
						if (iP == border_neighbor[iT4 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iT4 - maxelm].iI1]) {
								Sc2D = ((dx*dy / s[border_neighbor[iT4 - maxelm].MCB].square)*s[border_neighbor[iT4 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iT4 - maxelm] = !sourse2Dproblem[iT4 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}


					if (iP == border_neighbor[iT4 - maxelm].iI1) {
						iT4 = border_neighbor[iT4 - maxelm].iI2;
					}
					else {
						iT4 = border_neighbor[iT4 - maxelm].iI1;
					}
					sl[iP].iT4 = iT4;
					bT4 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iT4 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iT4 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** T\n");
					//getchar();
					system("PAUSE");
				}
				//bsT1 = true;
#endif
			}

		}
		if (bB4) {
			if (border_neighbor[iB4 - maxelm].MCB < ls) {


				if ((border_neighbor[iB4 - maxelm].iI1>-1) && (border_neighbor[iB4 - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iB4 - maxelm].iI1] - prop[LAM][border_neighbor[iB4 - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iB4 - maxelm]) {
							Sc2D = ((dx*dy / s[border_neighbor[iB4 - maxelm].MCB].square)*s[border_neighbor[iB4 - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iB4 - maxelm] = !sourse2Dproblem[iB4 - maxelm];
					}
					else {
						if (iP == border_neighbor[iB4 - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iB4 - maxelm].iI2]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB4 - maxelm].MCB].square)*s[border_neighbor[iB4 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iB4 - maxelm] = !sourse2Dproblem[iB4 - maxelm];
							}
						}
						if (iP == border_neighbor[iB4 - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iB4 - maxelm].iI1]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB4 - maxelm].MCB].square)*s[border_neighbor[iB4 - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iB4 - maxelm] = !sourse2Dproblem[iB4 - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iB4 - maxelm].iI1) {
						iB4 = border_neighbor[iB4 - maxelm].iI2;
					}
					else {
						iB4 = border_neighbor[iB4 - maxelm].iI1;
					}
					sl[iP].iB4 = iB4;
					bB4 = false;
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				else {
					if (border_neighbor[iB4 - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iB4 - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** B\n");
					//getchar();
					system("PAUSE");
				}
				//bsB1 = true;
#endif
			}

		}
		
		}


	}
	// 11.05.2017
	if (poweron_multiplier_sequence > 0.0) {
		// Sc2D != 0.0
	}
	else {
		Sc2D *= 0.0;
	}
	//Sc2D *= poweron_multiplier_sequence; // на случай если мощность выключена (это нужно для square wave решателя).
	//printf("%e %e %e\n",dx,dy,dz); // debug GOOD
	//getchar();

	doublereal dxe=0.5*dx, dxw=0.5*dx, dyn=0.5*dy, dys=0.5*dy, dzt=0.5*dz, dzb=0.5*dz;
	
    // т.к. известна нумерация вершин куба, то здесь она используется
	// x - direction
	if (iE > -1) {
		if (!bE) dxe = 0.5*(pa[nvtx[1][iE] - 1].x + pa[nvtx[0][iE] - 1].x);
		if (!bE) dxe -= 0.5*(pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
	}
	if (iW > -1) {
		if (!bW) dxw = 0.5*(pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
		if (!bW) dxw -= 0.5*(pa[nvtx[1][iW] - 1].x + pa[nvtx[0][iW] - 1].x);
	}
	// y - direction
	if (iN > -1) {
		if (!bN) dyn = 0.5*(pa[nvtx[2][iN] - 1].y + pa[nvtx[0][iN] - 1].y);
		if (!bN) dyn -= 0.5*(pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
	}
	if (iS > -1) {
		if (!bS) dys = 0.5*(pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
		if (!bS) dys -= 0.5*(pa[nvtx[2][iS] - 1].y + pa[nvtx[0][iS] - 1].y);
	}
    // z - direction
	if (iT > -1) {
		if (!bT) dzt = 0.5*(pa[nvtx[4][iT] - 1].z + pa[nvtx[0][iT] - 1].z);
		if (!bT) dzt -= 0.5*(pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
	}
	if (iB > -1) {
		if (!bB) dzb = 0.5*(pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
		if (!bB) dzb -= 0.5*(pa[nvtx[4][iB] - 1].z + pa[nvtx[0][iB] - 1].z);
	}

	doublereal dxe2 = 0.5*dx, dxw2 = 0.5*dx, dyn2 = 0.5*dy, dys2 = 0.5*dy, dzt2 = 0.5*dz, dzb2 = 0.5*dz;
	doublereal dxe3 = 0.5*dx, dxw3 = 0.5*dx, dyn3 = 0.5*dy, dys3 = 0.5*dy, dzt3 = 0.5*dz, dzb3 = 0.5*dz;
	doublereal dxe4 = 0.5*dx, dxw4 = 0.5*dx, dyn4 = 0.5*dy, dys4 = 0.5*dy, dzt4 = 0.5*dz, dzb4 = 0.5*dz;
	
	if (b_on_adaptive_local_refinement_mesh) {

		// т.к. известна нумерация вершин куба, то здесь она используется
		// x - direction
		if (iE2 > -1) {
			if (!bE2) dxe2 = 0.5 * (pa[nvtx[1][iE2] - 1].x + pa[nvtx[0][iE2] - 1].x);
			if (!bE2) dxe2 -= 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
		}
		if (iW2 > -1) {
			if (!bW2) dxw2 = 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
			if (!bW2) dxw2 -= 0.5 * (pa[nvtx[1][iW2] - 1].x + pa[nvtx[0][iW2] - 1].x);
		}
		// y - direction
		if (iN2 > -1) {
			if (!bN2) dyn2 = 0.5 * (pa[nvtx[2][iN2] - 1].y + pa[nvtx[0][iN2] - 1].y);
			if (!bN2) dyn2 -= 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
		}
		if (iS2 > -1) {
			if (!bS2) dys2 = 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
			if (!bS2) dys2 -= 0.5 * (pa[nvtx[2][iS2] - 1].y + pa[nvtx[0][iS2] - 1].y);
		}
		// z - direction
		if (iT2 > -1) {
			if (!bT2) dzt2 = 0.5 * (pa[nvtx[4][iT2] - 1].z + pa[nvtx[0][iT2] - 1].z);
			if (!bT2) dzt2 -= 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
		}
		if (iB2 > -1) {
			if (!bB2) dzb2 = 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
			if (!bB2) dzb2 -= 0.5 * (pa[nvtx[4][iB2] - 1].z + pa[nvtx[0][iB2] - 1].z);
		}

		// т.к. известна нумерация вершин куба, то здесь она используется
		// x - direction
		if (iE3 > -1) {
			if (!bE3) dxe3 = 0.5 * (pa[nvtx[1][iE3] - 1].x + pa[nvtx[0][iE3] - 1].x);
			if (!bE3) dxe3 -= 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
		}
		if (iW3 > -1) {
			if (!bW3) dxw3 = 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
			if (!bW3) dxw3 -= 0.5 * (pa[nvtx[1][iW3] - 1].x + pa[nvtx[0][iW3] - 1].x);
		}
		// y - direction
		if (iN3 > -1) {
			if (!bN3) dyn3 = 0.5 * (pa[nvtx[2][iN3] - 1].y + pa[nvtx[0][iN3] - 1].y);
			if (!bN3) dyn3 -= 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
		}
		if (iS3 > -1) {
			if (!bS3) dys3 = 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
			if (!bS3) dys3 -= 0.5 * (pa[nvtx[2][iS3] - 1].y + pa[nvtx[0][iS3] - 1].y);
		}
		// z - direction
		if (iT3 > -1) {
			if (!bT3) dzt3 = 0.5 * (pa[nvtx[4][iT3] - 1].z + pa[nvtx[0][iT3] - 1].z);
			if (!bT3) dzt3 -= 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
		}
		if (iB3 > -1) {
			if (!bB3) dzb3 = 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
			if (!bB3) dzb3 -= 0.5 * (pa[nvtx[4][iB3] - 1].z + pa[nvtx[0][iB3] - 1].z);
		}

		// т.к. известна нумерация вершин куба, то здесь она используется
		// x - direction
		if (iE4 > -1) {
			if (!bE4) dxe4 = 0.5 * (pa[nvtx[1][iE4] - 1].x + pa[nvtx[0][iE4] - 1].x);
			if (!bE4) dxe4 -= 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
		}
		if (iW4 > -1) {
			if (!bW4) dxw4 = 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
			if (!bW4) dxw4 -= 0.5 * (pa[nvtx[1][iW4] - 1].x + pa[nvtx[0][iW4] - 1].x);
		}
		// y - direction
		if (iN4 > -1) {
			if (!bN4) dyn4 = 0.5 * (pa[nvtx[2][iN4] - 1].y + pa[nvtx[0][iN4] - 1].y);
			if (!bN4) dyn4 -= 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
		}
		if (iS4 > -1) {
			if (!bS4) dys4 = 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
			if (!bS4) dys4 -= 0.5 * (pa[nvtx[2][iS4] - 1].y + pa[nvtx[0][iS4] - 1].y);
		}
		// z - direction
		if (iT4 > -1) {
			if (!bT4) dzt4 = 0.5 * (pa[nvtx[4][iT4] - 1].z + pa[nvtx[0][iT4] - 1].z);
			if (!bT4) dzt4 -= 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
		}
		if (iB4 > -1) {
			if (!bB4) dzb4 = 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
			if (!bB4) dzb4 -= 0.5 * (pa[nvtx[4][iB4] - 1].z + pa[nvtx[0][iB4] - 1].z);
		}
	}
	
	dxe = fabs(dxe);
	

	dxw = fabs(dxw);

	dyn = fabs(dyn);

	dys = fabs(dys);

	dzt = fabs(dzt);

	dzb = fabs(dzb);

	if (b_on_adaptive_local_refinement_mesh) {

		dxe2 = fabs(dxe2);
		dxe3 = fabs(dxe3);
		dxe4 = fabs(dxe4);

		dxw2 = fabs(dxw2);
		dxw3 = fabs(dxw3);
		dxw4 = fabs(dxw4);

		dyn2 = fabs(dyn2);
		dyn3 = fabs(dyn3);
		dyn4 = fabs(dyn4);

		dys2 = fabs(dys2);
		dys3 = fabs(dys3);
		dys4 = fabs(dys4);

		dzt2 = fabs(dzt2);
		dzt3 = fabs(dzt3);
		dzt4 = fabs(dzt4);

		dzb2 = fabs(dzb2);
		dzb3 = fabs(dzb3);
		dzb4 = fabs(dzb4);

	}

	doublereal feplus, fwplus, fnplus, fsplus, ftplus, fbplus;
	// x-direction
	feplus=0.5*dx/dxe;
	fwplus=0.5*dx/dxw;
	// y-direction
	fnplus=0.5*dy/dyn;
	fsplus=0.5*dy/dys;
	// z-direction
	ftplus=0.5*dz/dzt;
	fbplus=0.5*dz/dzb;

	doublereal feplus2, fwplus2, fnplus2, fsplus2, ftplus2, fbplus2;
	doublereal feplus3, fwplus3, fnplus3, fsplus3, ftplus3, fbplus3;
	doublereal feplus4, fwplus4, fnplus4, fsplus4, ftplus4, fbplus4;

	if (b_on_adaptive_local_refinement_mesh) {

		// x-direction
		feplus2 = 0.5 * dx / dxe2;
		fwplus2 = 0.5 * dx / dxw2;
		// y-direction
		fnplus2 = 0.5 * dy / dyn2;
		fsplus2 = 0.5 * dy / dys2;
		// z-direction
		ftplus2 = 0.5 * dz / dzt2;
		fbplus2 = 0.5 * dz / dzb2;

		// x-direction
		feplus3 = 0.5 * dx / dxe3;
		fwplus3 = 0.5 * dx / dxw3;
		// y-direction
		fnplus3 = 0.5 * dy / dyn3;
		fsplus3 = 0.5 * dy / dys3;
		// z-direction
		ftplus3 = 0.5 * dz / dzt3;
		fbplus3 = 0.5 * dz / dzb3;


		// x-direction
		feplus4 = 0.5 * dx / dxe4;
		fwplus4 = 0.5 * dx / dxw4;
		// y-direction
		fnplus4 = 0.5 * dy / dyn4;
		fsplus4 = 0.5 * dy / dys4;
		// z-direction
		ftplus4 = 0.5 * dz / dzt4;
		fbplus4 = 0.5 * dz / dzb4;
	}

	//printf("%e %e %e %e %e %e\n",feplus, fwplus, fnplus, fsplus, ftplus, fbplus);
	//getchar();

    /*
    if ((iP>=25)&&(iP<=29)) {
        printf("dxe=%e dxw=%e dyn=%e dys=%e dzt=%e dzb=%e\n",dxe, dxw, dyn, dys, dzt, dzb);
        printf("feplus=%e fwplus=%e fnplus=%e fsplus=%e ftplus=%e fbplus=%e\n",feplus, fwplus, fnplus, fsplus, ftplus, fbplus);
	    getchar();
	}
    */

	// плотность аппроксимируется средним гармоническим
	// примечание: здесь под плотностью понимается произведение плотности на теплоёмкость при постоянном давлении.
	doublereal rP, rE=0.0, rN=0.0, rT=0.0, rW=0.0, rS=0.0, rB=0.0;
    rP=prop[RHO][iP]*prop[HEAT_CAPACITY][iP];

	if (iE > -1) {
		if (!bE) rE = prop[RHO][iE] * prop[HEAT_CAPACITY][iE]; else rE = prop_b[RHO][iE - maxelm] * prop_b[HEAT_CAPACITY][iE - maxelm];
	}
	if (iN > -1) {
		if (!bN) rN = prop[RHO][iN] * prop[HEAT_CAPACITY][iN]; else rN = prop_b[RHO][iN - maxelm] * prop_b[HEAT_CAPACITY][iN - maxelm];
	}
	if (iT > -1) {
		if (!bT) rT = prop[RHO][iT] * prop[HEAT_CAPACITY][iT]; else rT = prop_b[RHO][iT - maxelm] * prop_b[HEAT_CAPACITY][iT - maxelm];
	}
	if (iW > -1) {
		if (!bW) rW = prop[RHO][iW] * prop[HEAT_CAPACITY][iW]; else rW = prop_b[RHO][iW - maxelm] * prop_b[HEAT_CAPACITY][iW - maxelm];
	}
	if (iS > -1) {
		if (!bS) rS = prop[RHO][iS] * prop[HEAT_CAPACITY][iS]; else rS = prop_b[RHO][iS - maxelm] * prop_b[HEAT_CAPACITY][iS - maxelm];
	}
	if (iB > -1) {
		if (!bB) rB = prop[RHO][iB] * prop[HEAT_CAPACITY][iB]; else rB = prop_b[RHO][iB - maxelm] * prop_b[HEAT_CAPACITY][iB - maxelm];
	}

	doublereal  rE2=0.0, rN2=0.0, rT2=0.0, rW2=0.0, rS2=0.0, rB2=0.0;
	doublereal  rE3 = 0.0, rN3 = 0.0, rT3 = 0.0, rW3 = 0.0, rS3 = 0.0, rB3 = 0.0;
	doublereal  rE4 = 0.0, rN4 = 0.0, rT4 = 0.0, rW4 = 0.0, rS4 = 0.0, rB4 = 0.0;

	if (b_on_adaptive_local_refinement_mesh) {

		if (iE2 > -1) {
			if (!bE2) rE2 = prop[RHO][iE2] * prop[HEAT_CAPACITY][iE2]; else rE2 = prop_b[RHO][iE2 - maxelm] * prop_b[HEAT_CAPACITY][iE2 - maxelm];
		}
		if (iN2 > -1) {
			if (!bN2) rN2 = prop[RHO][iN2] * prop[HEAT_CAPACITY][iN2]; else rN2 = prop_b[RHO][iN2 - maxelm] * prop_b[HEAT_CAPACITY][iN2 - maxelm];
		}
		if (iT2 > -1) {
			if (!bT2) rT2 = prop[RHO][iT2] * prop[HEAT_CAPACITY][iT2]; else rT2 = prop_b[RHO][iT2 - maxelm] * prop_b[HEAT_CAPACITY][iT2 - maxelm];
		}
		if (iW2 > -1) {
			if (!bW2) rW2 = prop[RHO][iW2] * prop[HEAT_CAPACITY][iW2]; else rW2 = prop_b[RHO][iW2 - maxelm] * prop_b[HEAT_CAPACITY][iW2 - maxelm];
		}
		if (iS2 > -1) {
			if (!bS2) rS2 = prop[RHO][iS2] * prop[HEAT_CAPACITY][iS2]; else rS2 = prop_b[RHO][iS2 - maxelm] * prop_b[HEAT_CAPACITY][iS2 - maxelm];
		}
		if (iB2 > -1) {
			if (!bB2) rB2 = prop[RHO][iB2] * prop[HEAT_CAPACITY][iB2]; else rB2 = prop_b[RHO][iB2 - maxelm] * prop_b[HEAT_CAPACITY][iB2 - maxelm];
		}


		if (iE3 > -1) {
			if (!bE3) rE3 = prop[RHO][iE3] * prop[HEAT_CAPACITY][iE3]; else rE3 = prop_b[RHO][iE3 - maxelm] * prop_b[HEAT_CAPACITY][iE3 - maxelm];
		}
		if (iN3 > -1) {
			if (!bN3) rN3 = prop[RHO][iN3] * prop[HEAT_CAPACITY][iN3]; else rN3 = prop_b[RHO][iN3 - maxelm] * prop_b[HEAT_CAPACITY][iN3 - maxelm];
		}
		if (iT3 > -1) {
			if (!bT3) rT3 = prop[RHO][iT3] * prop[HEAT_CAPACITY][iT3]; else rT3 = prop_b[RHO][iT3 - maxelm] * prop_b[HEAT_CAPACITY][iT3 - maxelm];
		}
		if (iW3 > -1) {
			if (!bW3) rW3 = prop[RHO][iW3] * prop[HEAT_CAPACITY][iW3]; else rW3 = prop_b[RHO][iW3 - maxelm] * prop_b[HEAT_CAPACITY][iW3 - maxelm];
		}
		if (iS3 > -1) {
			if (!bS3) rS3 = prop[RHO][iS3] * prop[HEAT_CAPACITY][iS3]; else rS3 = prop_b[RHO][iS3 - maxelm] * prop_b[HEAT_CAPACITY][iS3 - maxelm];
		}
		if (iB3 > -1) {
			if (!bB3) rB3 = prop[RHO][iB3] * prop[HEAT_CAPACITY][iB3]; else rB3 = prop_b[RHO][iB3 - maxelm] * prop_b[HEAT_CAPACITY][iB3 - maxelm];
		}


		if (iE4 > -1) {
			if (!bE4) rE4 = prop[RHO][iE4] * prop[HEAT_CAPACITY][iE4]; else rE4 = prop_b[RHO][iE4 - maxelm] * prop_b[HEAT_CAPACITY][iE4 - maxelm];
		}
		if (iN4 > -1) {
			if (!bN4) rN4 = prop[RHO][iN4] * prop[HEAT_CAPACITY][iN4]; else rN4 = prop_b[RHO][iN4 - maxelm] * prop_b[HEAT_CAPACITY][iN4 - maxelm];
		}
		if (iT4 > -1) {
			if (!bT4) rT4 = prop[RHO][iT4] * prop[HEAT_CAPACITY][iT4]; else rT4 = prop_b[RHO][iT4 - maxelm] * prop_b[HEAT_CAPACITY][iT4 - maxelm];
		}
		if (iW4 > -1) {
			if (!bW4) rW4 = prop[RHO][iW4] * prop[HEAT_CAPACITY][iW4]; else rW4 = prop_b[RHO][iW4 - maxelm] * prop_b[HEAT_CAPACITY][iW4 - maxelm];
		}
		if (iS4 > -1) {
			if (!bS4) rS4 = prop[RHO][iS4] * prop[HEAT_CAPACITY][iS4]; else rS4 = prop_b[RHO][iS4 - maxelm] * prop_b[HEAT_CAPACITY][iS4 - maxelm];
		}
		if (iB4 > -1) {
			if (!bB4) rB4 = prop[RHO][iB4] * prop[HEAT_CAPACITY][iB4]; else rB4 = prop_b[RHO][iB4 - maxelm] * prop_b[HEAT_CAPACITY][iB4 - maxelm];
		}

	}

	//printf("%e %e %e %e %e\n",rP, rE, rN, rT, rW);
	//getchar();
	

	doublereal rhoe = rP, rhow = rP, rhon = rP, rhos = rP, rhot = rP, rhob = rP;
	// Значение плотности * теплоёмкость на грани КО:
	if (iE > -1) {
		rhoe = rE * rP / (feplus * rE + (1.0 - feplus) * rP); // верные формы записи. проверено.
	}
	if (iW > -1) {
		rhow = rW * rP / (fwplus * rW + (1.0 - fwplus) * rP);
	}
	if (iN > -1) {
		rhon = rN * rP / (fnplus * rN + (1.0 - fnplus) * rP);
	}
	if (iS > -1) {
		rhos = rS * rP / (fsplus * rS + (1.0 - fsplus) * rP);
	}
	if (iT > -1) {
		rhot = rT * rP / (ftplus * rT + (1.0 - ftplus) * rP);
	}
	if (iB > -1) {
		rhob = rB * rP / (fbplus * rB + (1.0 - fbplus) * rP);
	}

	doublereal rhoe2 = rP, rhow2 = rP, rhon2 = rP, rhos2 = rP, rhot2 = rP, rhob2 = rP;
	doublereal rhoe3 = rP, rhow3 = rP, rhon3 = rP, rhos3 = rP, rhot3 = rP, rhob3 = rP;
	doublereal rhoe4 = rP, rhow4 = rP, rhon4 = rP, rhos4 = rP, rhot4 = rP, rhob4 = rP;

	if (b_on_adaptive_local_refinement_mesh) {
		if (iE2 > -1) {
			rhoe2 = rE2 * rP / (feplus2 * rE2 + (1.0 - feplus2) * rP);
		}
		if (iW2 > -1) {
			rhow2 = rW2 * rP / (fwplus2 * rW2 + (1.0 - fwplus2) * rP);
		}
		if (iN2 > -1) {
			rhon2 = rN2 * rP / (fnplus2 * rN2 + (1.0 - fnplus2) * rP);
		}
		if (iS2 > -1) {
			rhos2 = rS2 * rP / (fsplus2 * rS2 + (1.0 - fsplus2) * rP);
		}
		if (iT2 > -1) {
			rhot2 = rT2 * rP / (ftplus2 * rT2 + (1.0 - ftplus2) * rP);
		}
		if (iB2 > -1) {
			rhob2 = rB2 * rP / (fbplus2 * rB2 + (1.0 - fbplus2) * rP);
		}

		if (iE3 > -1) {
			rhoe3 = rE3 * rP / (feplus3 * rE3 + (1.0 - feplus3) * rP);
		}
		if (iW3 > -1) {
			rhow3 = rW3 * rP / (fwplus3 * rW3 + (1.0 - fwplus3) * rP);
		}
		if (iN3 > -1) {
			rhon3 = rN3 * rP / (fnplus3 * rN3 + (1.0 - fnplus3) * rP);
		}
		if (iS3 > -1) {
			rhos3 = rS3 * rP / (fsplus3 * rS3 + (1.0 - fsplus3) * rP);
		}
		if (iT3 > -1) {
			rhot3 = rT3 * rP / (ftplus3 * rT3 + (1.0 - ftplus3) * rP);
		}
		if (iB3 > -1) {
			rhob3 = rB3 * rP / (fbplus3 * rB3 + (1.0 - fbplus3) * rP);
		}

		if (iE4 > -1) {
			rhoe4 = rE4 * rP / (feplus4 * rE4 + (1.0 - feplus4) * rP);
		}
		if (iW4 > -1) {
			rhow4 = rW4 * rP / (fwplus4 * rW4 + (1.0 - fwplus4) * rP);
		}
		if (iN4 > -1) {
			rhon4 = rN4 * rP / (fnplus4 * rN4 + (1.0 - fnplus4) * rP);
		}
		if (iS4 > -1) {
			rhos4 = rS4 * rP / (fsplus4 * rS4 + (1.0 - fsplus4) * rP);
		}
		if (iT4 > -1) {
			rhot4 = rT4 * rP / (ftplus4 * rT4 + (1.0 - ftplus4) * rP);
		}
		if (iB4 > -1) {
			rhob4 = rB4 * rP / (fbplus4 * rB4 + (1.0 - fbplus4) * rP);
		}
	}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (rhoe != rhoe) {
		printf("rhoe = %e in function my_elmatr_quad_T3D\n",rhoe);
		system("pause");
	}
	if (rhow != rhow) {
		printf("rhow = %e in function my_elmatr_quad_T3D\n", rhow);
		system("pause");
	}
	if (rhon != rhon) {
		printf("rhon = %e in function my_elmatr_quad_T3D\n", rhon);
		system("pause");
	}
	if (rhos != rhos) {
		printf("rhos = %e in function my_elmatr_quad_T3D\n", rhos);
		system("pause");
	}
	if (rhot != rhot) {
		printf("rhot = %e in function my_elmatr_quad_T3D\n", rhot);
		system("pause");
	}
	if (rhob != rhob) {
		printf("rhob = %e in function my_elmatr_quad_T3D\n", rhob);
		system("pause");
	}

	if (b_on_adaptive_local_refinement_mesh) {
		if (rhoe2 != rhoe2) {
			printf("rhoe2 = %e in function my_elmatr_quad_T3D\n", rhoe2);
			system("pause");
		}
		if (rhow2 != rhow2) {
			printf("rhow2 = %e in function my_elmatr_quad_T3D\n", rhow2);
			system("pause");
		}
		if (rhon2 != rhon2) {
			printf("rhon2 = %e in function my_elmatr_quad_T3D\n", rhon2);
			system("pause");
		}
		if (rhos2 != rhos2) {
			printf("rhos2 = %e in function my_elmatr_quad_T3D\n", rhos2);
			system("pause");
		}
		if (rhot2 != rhot2) {
			printf("rhot2 = %e in function my_elmatr_quad_T3D\n", rhot2);
			system("pause");
		}
		if (rhob2 != rhob2) {
			printf("rhob2 = %e in function my_elmatr_quad_T3D\n", rhob2);
			system("pause");
		}
		if (rhoe3 != rhoe3) {
			printf("rhoe3 = %e in function my_elmatr_quad_T3D\n", rhoe3);
			system("pause");
		}
		if (rhow3 != rhow3) {
			printf("rhow3 = %e in function my_elmatr_quad_T3D\n", rhow3);
			system("pause");
		}
		if (rhon3 != rhon3) {
			printf("rhon3 = %e in function my_elmatr_quad_T3D\n", rhon3);
			system("pause");
		}
		if (rhos3 != rhos3) {
			printf("rhos3 = %e in function my_elmatr_quad_T3D\n", rhos3);
			system("pause");
		}
		if (rhot3 != rhot3) {
			printf("rhot3 = %e in function my_elmatr_quad_T3D\n", rhot3);
			system("pause");
		}
		if (rhob3 != rhob3) {
			printf("rhob3 = %e in function my_elmatr_quad_T3D\n", rhob3);
			system("pause");
		}
		if (rhoe4 != rhoe4) {
			printf("rhoe4 = %e in function my_elmatr_quad_T3D\n", rhoe4);
			system("pause");
		}
		if (rhow4 != rhow4) {
			printf("rhow4 = %e in function my_elmatr_quad_T3D\n", rhow4);
			system("pause");
		}
		if (rhon4 != rhon4) {
			printf("rhon4 = %e in function my_elmatr_quad_T3D\n", rhon4);
			system("pause");
		}
		if (rhos4 != rhos4) {
			printf("rhos4 = %e in function my_elmatr_quad_T3D\n", rhos4);
			system("pause");
		}
		if (rhot4 != rhot4) {
			printf("rhot4 = %e in function my_elmatr_quad_T3D\n", rhot4);
			system("pause");
		}
		if (rhob4 != rhob4) {
			printf("rhob4 = %e in function my_elmatr_quad_T3D\n", rhob4);
			system("pause");
		}
	}
#endif

	// Поправка Рхи-Чоу добавлена в интерполяцию скорости на грань КО
	// для уравнения теплопередачи в жидкости 12 января 2012 года.
	// Возможно скорости на грани ещё понадобяться для полного учёта диссипативного источникового члена (см. обобщённые уравнения Ньютона). 

	/*
	// линейная интерполяция скорости на грань КО.
    doublereal ue=0.0, uw=0.0, vn=0.0, vs=0.0, wt=0.0, wb=0.0;
	if (bconvective) {
		doublereal velP, velS;
	    if (!bE) {
			bool bsolidP=false, bsolidS=false;
		    if (ptr[1][iE]==-1) {
				// принадлежит твёрдому телу:
			    velS=0.0;
			    bsolidS=true;
		    }
	        else velS=f[ptr[1][iE]].potent[VX][ptr[0][iE]];

	        if (ptr[1][iP]==-1) {
			    // принадлежит твёрдому телу:
			    velP=0.0;
			    bsolidP=true;
		    }
	        else velP=f[ptr[1][iP]].potent[VX][ptr[0][iP]];

		    if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
			    if (bsolidS) {
					// E граница жидкой зоны
					ue=f[ptr[1][iP]].potent[VX][f[ptr[1][iP]].neighbors_for_the_internal_node[ESIDE][0][ptr[0][iP]]];
					// Рхи-Чоу original interpolation method:
					if (bRhieChowb) {
		                ue+=RCh*ugRhieChow_internal_border(ptr[ENUMERATECONTVOL][iP], ESIDE, f[ptr[1][iP]].alpha[VX], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		            }
				}
			    else {
					// W граница жидкой зоны
					ue=f[ptr[1][iE]].potent[VX][f[ptr[1][iE]].neighbors_for_the_internal_node[WSIDE][0][ptr[0][iE]]];
					// ENUMERATECONTVOL == 0
					// Рхи-Чоу original interpolation method:
					if (bRhieChowb) {
			            ue+=RCh*ugRhieChow_internal_border(ptr[ENUMERATECONTVOL][iE], WSIDE, f[ptr[1][iE]].alpha[VX], f[ptr[1][iE]].nvtx, f[ptr[1][iE]].neighbors_for_the_internal_node, f[ptr[1][iE]].maxelm, f[ptr[1][iE]].potent[PRESS], f[ptr[1][iE]].pa, f[ptr[1][iE]].diag_coef); // Вклад поправки Рхи-Чоу
		            }
				}
	    	}
		    else if (!(bsolidS && bsolidP)) {
				// E Грань внутри жидкости 
				ue=feplus*velS+(1.0-feplus)*velP;
				// Рхи-Чоу original interpolation method:
				if (bRhieChowi) {
		            ue+=RCh*ugRhieChow_internal(ptr[ENUMERATECONTVOL][iP], ESIDE, f[ptr[1][iP]].alpha[VX], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		        }
			} else ue=0; // в твёрдом теле
	    } 
	    else  {
		    if (ptr[1][iP]==-1) ue=0.0;
		    else {
				// E граница жидкой зоны.
				ue=f[ptr[1][iP]].potent[VX][f[ptr[1][iP]].neighbors_for_the_internal_node[ESIDE][0][ptr[0][iP]]];
				// Рхи-Чоу original interpolation method:
				if (bRhieChowb) {
		           ue+=RCh*ugRhieChow_internal_border(ptr[ENUMERATECONTVOL][iP], ESIDE, f[ptr[1][iP]].alpha[VX], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		        }
			}
	    }
    
	    if (!bW) {
		    bool bsolidP=false, bsolidS=false;
		    if (ptr[1][iW]==-1) {
				// принадлежит твёрдому телу:
			    velS=0.0;
			    bsolidS=true;
		    }
	        else velS=f[ptr[1][iW]].potent[VX][ptr[0][iW]];

	        if (ptr[1][iP]==-1) {
			    // принадлежит твёрдому телу:
			    velP=0.0;
			    bsolidP=true;
		    }
	        else velP=f[ptr[1][iP]].potent[VX][ptr[0][iP]];

		    if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
			    if (bsolidS) {
					// W граница жидкой зоны
					uw=f[ptr[1][iP]].potent[VX][f[ptr[1][iP]].neighbors_for_the_internal_node[WSIDE][0][ptr[0][iP]]];
					// Rhie-Chow original interpolation method 
				    if (bRhieChowb) {
			            uw+=RCh*ugRhieChow_internal_border(ptr[0][iP], WSIDE, f[ptr[1][iP]].alpha[VX], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		            }
				}
			    else {
					// E граница жидкой зоны
					uw=f[ptr[1][iW]].potent[VX][f[ptr[1][iW]].neighbors_for_the_internal_node[ESIDE][0][ptr[0][iW]]];
					// Рхи-Чоу original interpolation method:
					if (bRhieChowb) {
		                uw+=RCh*ugRhieChow_internal_border(ptr[0][iW], ESIDE, f[ptr[1][iW]].alpha[VX], f[ptr[1][iW]].nvtx, f[ptr[1][iW]].neighbors_for_the_internal_node, f[ptr[1][iW]].maxelm, f[ptr[1][iW]].potent[PRESS], f[ptr[1][iW]].pa, f[ptr[1][iW]].diag_coef); // Вклад поправки Рхи-Чоу
		            }
				}
		    }
		    else if (!(bsolidS && bsolidP)) {
				// W грань внутри жидкости
				uw=fwplus*velS+(1.0-fwplus)*velP;
				//Rhie-Chow original interpolation method
				if (bRhieChowi) {
			        uw+=RCh*ugRhieChow_internal(ptr[0][iP], WSIDE, f[ptr[1][iP]].alpha[VX], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		        } 
			} else uw=0.0;
	    } 
	    else  {
			if (ptr[1][iP]==-1) uw=0.0;
		    else {
				// W граница жидкой зоны
				uw=f[ptr[1][iP]].potent[VX][f[ptr[1][iP]].neighbors_for_the_internal_node[WSIDE][0][ptr[0][iP]]];
				// Rhie-Chow original interpolation method 
				if (bRhieChowb) {
			        uw+=RCh*ugRhieChow_internal_border(ptr[0][iP], WSIDE, f[ptr[1][iP]].alpha[VX], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		        }
			}
	    }
	
	    if (!bN) {
			bool bsolidP=false, bsolidS=false;
		    if (ptr[1][iN]==-1) {
				velS=0.0;
			    bsolidS=true;
		    }
	        else velS=f[ptr[1][iN]].potent[VY][ptr[0][iN]];

	        if (ptr[1][iP]==-1) {
				velP=0.0;
			    bsolidP=true;
		    }
	        else velP=f[ptr[1][iP]].potent[VY][ptr[0][iP]];

		    if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
				if (bsolidS) {
					// N граница жидкой зоны
					vn=f[ptr[1][iP]].potent[VY][f[ptr[1][iP]].neighbors_for_the_internal_node[NSIDE][0][ptr[0][iP]]];
					// Rhie-Chow original interpolation method
				    if (bRhieChowb) {
			           vn+=RCh*ugRhieChow_internal_border(ptr[0][iP], N,  f[ptr[1][iP]].alpha[VY], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		            }
				}
			    else {
					// S граница жидкой зоны
					vn=f[ptr[1][iN]].potent[VY][f[ptr[1][iN]].neighbors_for_the_internal_node[SSIDE][0][ptr[0][iN]]];
					// Rhie-Chow original interpolation method
					if (bRhieChowb) {
		               vn+=RCh*ugRhieChow_internal_border(ptr[0][iN], S,  f[ptr[1][iN]].alpha[VY], f[ptr[1][iN]].nvtx, f[ptr[1][iN]].neighbors_for_the_internal_node, f[ptr[1][iN]].maxelm, f[ptr[1][iN]].potent[PRESS], f[ptr[1][iN]].pa, f[ptr[1][iN]].diag_coef); // Вклад поправки Рхи-Чоу
		            }
				}
		    }
		    else if (!(bsolidS && bsolidP)) {
				// N грань внутри жидкости
				vn=fnplus*velS+(1.0-fnplus)*velP;
				// Rhie-Chow original interpolation method
				if (bRhieChowi) {
			        vn+=RCh*ugRhieChow_internal(ptr[0][iP], N, f[ptr[1][iP]].alpha[VY], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		        }
			} else vn=0.0;
	    } 
	    else  {
			if (ptr[1][iP]==-1) vn=0.0;
		    else {
				// N граница жидкой зоны
				vn=f[ptr[1][iP]].potent[VY][f[ptr[1][iP]].neighbors_for_the_internal_node[NSIDE][0][ptr[0][iP]]];
				// Rhie-Chow original interpolation method
				if (bRhieChowb) {
			       vn+=RCh*ugRhieChow_internal_border(ptr[0][iP], N,  f[ptr[1][iP]].alpha[VY], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		        }
			}
	    }
    
	    if (!bS) {
			bool bsolidP=false, bsolidS=false;
		    if (ptr[1][iS]==-1) {
				// принадлежит твёрдому телу:
			    velS=0.0;
			    bsolidS=true;
		    }
	        else velS=f[ptr[1][iS]].potent[VY][ptr[0][iS]];

	        if (ptr[1][iP]==-1) {
			    // принадлежит твёрдому телу:
			    velP=0.0;
			    bsolidP=true;
		    }
	        else velP=f[ptr[1][iP]].potent[VY][ptr[0][iP]];

		    if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
			    if (bsolidS) {
					// S граница жидкой зоны
					vs=f[ptr[1][iP]].potent[VY][f[ptr[1][iP]].neighbors_for_the_internal_node[SSIDE][0][ptr[0][iP]]];
					// Rhie-Chow original interpolation method
					if (bRhieChowb) {
		                vs+=RCh*ugRhieChow_internal_border(ptr[0][iP], S,  f[ptr[1][iP]].alpha[VY], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		            }
				}
			    else {
					// N граница жидкой зоны
					vs=f[ptr[1][iS]].potent[VY][f[ptr[1][iS]].neighbors_for_the_internal_node[NSIDE][0][ptr[0][iS]]];
					// Rhie-Chow original interpolation method
					if (bRhieChowb) {
			             vs+=RCh*ugRhieChow_internal_border(ptr[0][iS], N,  f[ptr[1][iS]].alpha[VY], f[ptr[1][iS]].nvtx, f[ptr[1][iS]].neighbors_for_the_internal_node, f[ptr[1][iS]].maxelm, f[ptr[1][iS]].potent[PRESS], f[ptr[1][iS]].pa, f[ptr[1][iS]].diag_coef); // Вклад поправки Рхи-Чоу
		            }
				}
		    }
		    else {
				// S грань внутри жидкости
				vs=fsplus*velS+(1.0-fsplus)*velP;
				// Rhie-Chow original interpolation method
				if (bRhieChowi) {
			        vs+=RCh*ugRhieChow_internal(ptr[0][iP], S, f[ptr[1][iP]].alpha[VY], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		        }		   
			}
	    } 
	    else  {
		    if (ptr[1][iP]==-1) vs=0.0;
		    else {
				// S граница жидкой зоны
				vs=f[ptr[1][iP]].potent[VY][f[ptr[1][iP]].neighbors_for_the_internal_node[SSIDE][0][ptr[0][iP]]];
				// Rhie-Chow original interpolation method
				if (bRhieChowb) {
		            vs+=RCh*ugRhieChow_internal_border(ptr[0][iP], S,  f[ptr[1][iP]].alpha[VY], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		        }
			}
	    }
    
        if (!bT) {
		    bool bsolidP=false, bsolidS=false;
    		if (ptr[1][iT]==-1) {
	    		velS=0.0;
		    	bsolidS=true;
		    }
	        else velS=f[ptr[1][iT]].potent[VZ][ptr[0][iT]];

	        if (ptr[1][iP]==-1) {
		    	velP=0.0;
		    	bsolidP=true;
	    	}
	        else velP=f[ptr[1][iP]].potent[VZ][ptr[0][iP]];

		    if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
			    if (bsolidS) {
					// T граница жидкой зоны
					wt=f[ptr[1][iP]].potent[VZ][f[ptr[1][iP]].neighbors_for_the_internal_node[TSIDE][0][ptr[0][iP]]];
					// Rhie-Chow original interpolation method
				    if (bRhieChowb) {
		                wt+=RCh*ugRhieChow_internal_border(ptr[0][iP], TSIDE, f[ptr[1][iP]].alpha[VZ], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		            }
				}
		    	else {
					// B граница жидкой зоны
					wt=f[ptr[1][iT]].potent[VZ][f[ptr[1][iT]].neighbors_for_the_internal_node[BSIDE][0][ptr[0][iT]]];
					// Rhie-Chow original interpolation method
					if (bRhieChowb) {
		                wt+=RCh*ugRhieChow_internal_border(ptr[0][iT], B, f[ptr[1][iT]].alpha[VZ], f[ptr[1][iT]].nvtx, f[ptr[1][iT]].neighbors_for_the_internal_node, f[ptr[1][iT]].maxelm, f[ptr[1][iT]].potent[PRESS], f[ptr[1][iT]].pa, f[ptr[1][iT]].diag_coef); // Вклад поправки Рхи-Чоу
		            }
				}
	    	}
		    else if (!(bsolidS && bsolidP)) {
				// T грань внутри жидкости
				wt=ftplus*velS+(1.0-ftplus)*velP;
				// Rhie-Chow original interpolation method
				if (bRhieChowi) {
			        wt+=RCh*ugRhieChow_internal(ptr[0][iP], TSIDE, f[ptr[1][iP]].alpha[VZ], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		        }		   
			} else wt=0.0;
	    } 
	    else  {
		    if (ptr[1][iP]==-1) wt=0.0;
		    else {
				// T граница жидкой зоны
				wt=f[ptr[1][iP]].potent[VZ][f[ptr[1][iP]].neighbors_for_the_internal_node[TSIDE][0][ptr[0][iP]]];
				// Rhie-Chow original interpolation method
				if (bRhieChowb) {
		            wt+=RCh*ugRhieChow_internal_border(ptr[0][iP], TSIDE, f[ptr[1][iP]].alpha[VZ], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		        }
			}
	    }

	    if (!bB) {
		    bool bsolidP=false, bsolidS=false;
		    if (ptr[1][iB]==-1) {
				// принадлежит твёрдому телу:
			    velS=0.0;
			    bsolidS=true;
		    }
	        else velS=f[ptr[1][iB]].potent[VZ][ptr[0][iB]];

	        if (ptr[1][iP]==-1) {
				// принадлежит твёрдому телу:
			    velP=0.0;
			    bsolidP=true;
		    }
	        else velP=f[ptr[1][iP]].potent[VZ][ptr[0][iP]];

		    if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
			    if (bsolidS) {
					// B граница жидкой зоны
					wb=f[ptr[1][iP]].potent[VZ][f[ptr[1][iP]].neighbors_for_the_internal_node[BSIDE][0][ptr[0][iP]]];
					// Rhie-Chow original interpolation method
				    if (bRhieChowb) {
		                wb+=RCh*ugRhieChow_internal_border(ptr[0][iP], B, f[ptr[1][iP]].alpha[VZ], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		            }
				}
			    else {
					// T граница жидкой зоны
					wb=f[ptr[1][iB]].potent[VZ][f[ptr[1][iB]].neighbors_for_the_internal_node[TSIDE][0][ptr[0][iB]]];
					// Rhie-Chow original interpolation method
					if (bRhieChowb) {
		                wb+=RCh*ugRhieChow_internal_border(ptr[0][iB], TSIDE, f[ptr[1][iB]].alpha[VZ], f[ptr[1][iB]].nvtx, f[ptr[1][iB]].neighbors_for_the_internal_node, f[ptr[1][iB]].maxelm, f[ptr[1][iB]].potent[PRESS], f[ptr[1][iB]].pa, f[ptr[1][iB]].diag_coef); // Вклад поправки Рхи-Чоу
		            }
				}
		    }
		    else if (!(bsolidS && bsolidP)) {
				// B грань внутри жидкости
				wb=fbplus*velS+(1.0-fbplus)*velP;
				// Rhie-Chow original interpolation method
				if (bRhieChowi) {
			        wb+=RCh*ugRhieChow_internal(ptr[0][iP], B, f[ptr[1][iP]].alpha[VZ], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		        }		   
			} else wb=0.0;
	    } 
	    else  {
		    if (ptr[1][iP]==-1) wb=0.0;
		    else {
				// B граница жидкой зоны
				wb=f[ptr[1][iP]].potent[VZ][f[ptr[1][iP]].neighbors_for_the_internal_node[BSIDE][0][ptr[0][iP]]];
				// Rhie-Chow original interpolation method
				if (bRhieChowb) {
		            wb+=RCh*ugRhieChow_internal_border(ptr[0][iP], B, f[ptr[1][iP]].alpha[VZ], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		        }
			}
	    }

	} // end if (bconvective)
    
	//printf("%e %e %e %e %e %e\n",ue, uw, vn, vs, wt, wb);
	//getchar();
	*/

    // Здесь используется алгоритм при котором массовый поток через
    // грани КО, вычисленный на основе скорректированной скорости и давления,
    // запоминается в памяти и потом используется. Но дело в том что в уравнении теплопроводности массовый поток
    // на грани требуется домножать на значение теплоёмкости при постоянном давлении на грани.
    // Поэтому здесь приводится вычисление теплоёмкости.

    // теплоёмкость (heat) аппроксимируется средним гармоническим
	// примечание: здесь под теплоёмкостью понимается только теплоёмкость при постоянном давлении.
	
	doublereal heatP, heatE=0.0, heatN=0.0, heatT=0.0, heatW=0.0, heatS=0.0, heatB=0.0;
    heatP=prop[HEAT_CAPACITY][iP];
	if (iE > -1) {
		if (!bE) heatE = prop[HEAT_CAPACITY][iE]; else heatE = prop_b[HEAT_CAPACITY][iE - maxelm];
	}
	if (iN > -1) {
		if (!bN) heatN = prop[HEAT_CAPACITY][iN]; else heatN = prop_b[HEAT_CAPACITY][iN - maxelm];
	}
	if (iT > -1) {
		if (!bT) heatT = prop[HEAT_CAPACITY][iT]; else heatT = prop_b[HEAT_CAPACITY][iT - maxelm];
	}
	if (iW > -1) {
		if (!bW) heatW = prop[HEAT_CAPACITY][iW]; else heatW = prop_b[HEAT_CAPACITY][iW - maxelm];
	}
	if (iS > -1) {
		if (!bS) heatS = prop[HEAT_CAPACITY][iS]; else heatS = prop_b[HEAT_CAPACITY][iS - maxelm];
	}
	if (iB > -1) {
		if (!bB) heatB = prop[HEAT_CAPACITY][iB]; else heatB = prop_b[HEAT_CAPACITY][iB - maxelm];
	}

	doublereal  heatE2=0.0, heatN2=0.0, heatT2=0.0, heatW2=0.0, heatS2=0.0, heatB2=0.0;
	doublereal  heatE3=0.0, heatN3=0.0, heatT3=0.0, heatW3=0.0, heatS3=0.0, heatB3=0.0;
	doublereal  heatE4=0.0, heatN4=0.0, heatT4=0.0, heatW4=0.0, heatS4=0.0, heatB4=0.0;

	if (b_on_adaptive_local_refinement_mesh) {

		if (iE2 > -1) {
			if (!bE2) heatE2 = prop[HEAT_CAPACITY][iE2]; else heatE2 = prop_b[HEAT_CAPACITY][iE2 - maxelm];
		}
		if (iN2 > -1) {
			if (!bN2) heatN2 = prop[HEAT_CAPACITY][iN2]; else heatN2 = prop_b[HEAT_CAPACITY][iN2 - maxelm];
		}
		if (iT2 > -1) {
			if (!bT2) heatT2 = prop[HEAT_CAPACITY][iT2]; else heatT2 = prop_b[HEAT_CAPACITY][iT2 - maxelm];
		}
		if (iW2 > -1) {
			if (!bW2) heatW2 = prop[HEAT_CAPACITY][iW2]; else heatW2 = prop_b[HEAT_CAPACITY][iW2 - maxelm];
		}
		if (iS2 > -1) {
			if (!bS2) heatS2 = prop[HEAT_CAPACITY][iS2]; else heatS2 = prop_b[HEAT_CAPACITY][iS2 - maxelm];
		}
		if (iB2 > -1) {
			if (!bB2) heatB2 = prop[HEAT_CAPACITY][iB2]; else heatB2 = prop_b[HEAT_CAPACITY][iB2 - maxelm];
		}


		if (iE3 > -1) {
			if (!bE3) heatE3 = prop[HEAT_CAPACITY][iE3]; else heatE3 = prop_b[HEAT_CAPACITY][iE3 - maxelm];
		}
		if (iN3 > -1) {
			if (!bN3) heatN3 = prop[HEAT_CAPACITY][iN3]; else heatN3 = prop_b[HEAT_CAPACITY][iN3 - maxelm];
		}
		if (iT3 > -1) {
			if (!bT3) heatT3 = prop[HEAT_CAPACITY][iT3]; else heatT3 = prop_b[HEAT_CAPACITY][iT3 - maxelm];
		}
		if (iW3 > -1) {
			if (!bW3) heatW3 = prop[HEAT_CAPACITY][iW3]; else heatW3 = prop_b[HEAT_CAPACITY][iW3 - maxelm];
		}
		if (iS3 > -1) {
			if (!bS3) heatS3 = prop[HEAT_CAPACITY][iS3]; else heatS3 = prop_b[HEAT_CAPACITY][iS3 - maxelm];
		}
		if (iB3 > -1) {
			if (!bB3) heatB3 = prop[HEAT_CAPACITY][iB3]; else heatB3 = prop_b[HEAT_CAPACITY][iB3 - maxelm];
		}

		if (iE4 > -1) {
			if (!bE4) heatE4 = prop[HEAT_CAPACITY][iE4]; else heatE4 = prop_b[HEAT_CAPACITY][iE4 - maxelm];
		}
		if (iN4 > -1) {
			if (!bN4) heatN4 = prop[HEAT_CAPACITY][iN4]; else heatN4 = prop_b[HEAT_CAPACITY][iN4 - maxelm];
		}
		if (iT4 > -1) {
			if (!bT4) heatT4 = prop[HEAT_CAPACITY][iT4]; else heatT4 = prop_b[HEAT_CAPACITY][iT4 - maxelm];
		}
		if (iW4 > -1) {
			if (!bW4) heatW4 = prop[HEAT_CAPACITY][iW4]; else heatW4 = prop_b[HEAT_CAPACITY][iW4 - maxelm];
		}
		if (iS4 > -1) {
			if (!bS4) heatS4 = prop[HEAT_CAPACITY][iS4]; else heatS4 = prop_b[HEAT_CAPACITY][iS4 - maxelm];
		}
		if (iB4 > -1) {
			if (!bB4) heatB4 = prop[HEAT_CAPACITY][iB4]; else heatB4 = prop_b[HEAT_CAPACITY][iB4 - maxelm];
		}
	}

	//printf("%e %e %e %e %e\n",heatP, heatE, heatN, heatT, heatW);
	//getchar();
	
	doublereal heate=0.0, heatw=0.0, heatn=0.0, heats=0.0, heatt=0.0, heatb=0.0;

	// Значение теплоёмкости при постоянном давлении на грани КО:
	if (iE > -1) {
		heate = heatE*heatP / (feplus*heatE + (1.0 - feplus)*heatP);
	}
	if (iW > -1) {
		heatw = heatW*heatP / (fwplus*heatW + (1.0 - fwplus)*heatP);
	}
	if (iN > -1) {
		heatn = heatN*heatP / (fnplus*heatN + (1.0 - fnplus)*heatP);
	}
	if (iS > -1) {
		heats = heatS*heatP / (fsplus*heatS + (1.0 - fsplus)*heatP);
	}
	if (iT > -1) {
		heatt = heatT*heatP / (ftplus*heatT + (1.0 - ftplus)*heatP);
	}
	if (iB > -1) {
		heatb = heatB*heatP / (fbplus*heatB + (1.0 - fbplus)*heatP);
	}

	doublereal heate2 = 0.0, heatw2 = 0.0, heatn2 = 0.0, heats2 = 0.0, heatt2 = 0.0, heatb2 = 0.0;
	doublereal heate3 = 0.0, heatw3 = 0.0, heatn3 = 0.0, heats3 = 0.0, heatt3 = 0.0, heatb3 = 0.0;
	doublereal heate4 = 0.0, heatw4 = 0.0, heatn4 = 0.0, heats4 = 0.0, heatt4 = 0.0, heatb4 = 0.0;

	if (b_on_adaptive_local_refinement_mesh) {

		// Значение теплоёмкости при постоянном давлении на грани КО:
		if (iE2 > -1) {
			heate2 = heatE2 * heatP / (feplus2 * heatE2 + (1.0 - feplus2) * heatP);
		}
		if (iW2 > -1) {
			heatw2 = heatW2 * heatP / (fwplus2 * heatW2 + (1.0 - fwplus2) * heatP);
		}
		if (iN2 > -1) {
			heatn2 = heatN2 * heatP / (fnplus2 * heatN2 + (1.0 - fnplus2) * heatP);
		}
		if (iS2 > -1) {
			heats2 = heatS2 * heatP / (fsplus2 * heatS2 + (1.0 - fsplus2) * heatP);
		}
		if (iT2 > -1) {
			heatt2 = heatT2 * heatP / (ftplus2 * heatT2 + (1.0 - ftplus2) * heatP);
		}
		if (iB2 > -1) {
			heatb2 = heatB2 * heatP / (fbplus2 * heatB2 + (1.0 - fbplus2) * heatP);
		}

		// Значение теплоёмкости при постоянном давлении на грани КО:
		if (iE3 > -1) {
			heate3 = heatE3 * heatP / (feplus3 * heatE3 + (1.0 - feplus3) * heatP);
		}
		if (iW3 > -1) {
			heatw3 = heatW3 * heatP / (fwplus3 * heatW3 + (1.0 - fwplus3) * heatP);
		}
		if (iN3 > -1) {
			heatn3 = heatN3 * heatP / (fnplus3 * heatN3 + (1.0 - fnplus3) * heatP);
		}
		if (iS3 > -1) {
			heats3 = heatS3 * heatP / (fsplus3 * heatS3 + (1.0 - fsplus3) * heatP);
		}
		if (iT3 > -1) {
			heatt3 = heatT3 * heatP / (ftplus3 * heatT3 + (1.0 - ftplus3) * heatP);
		}
		if (iB3 > -1) {
			heatb3 = heatB3 * heatP / (fbplus3 * heatB3 + (1.0 - fbplus3) * heatP);
		}

		// Значение теплоёмкости при постоянном давлении на грани КО:
		if (iE4 > -1) {
			heate4 = heatE4 * heatP / (feplus4 * heatE4 + (1.0 - feplus4) * heatP);
		}
		if (iW4 > -1) {
			heatw4 = heatW4 * heatP / (fwplus4 * heatW4 + (1.0 - fwplus4) * heatP);
		}
		if (iN4 > -1) {
			heatn4 = heatN4 * heatP / (fnplus4 * heatN4 + (1.0 - fnplus4) * heatP);
		}
		if (iS4 > -1) {
			heats4 = heatS4 * heatP / (fsplus4 * heatS4 + (1.0 - fsplus4) * heatP);
		}
		if (iT4 > -1) {
			heatt4 = heatT4 * heatP / (ftplus4 * heatT4 + (1.0 - ftplus4) * heatP);
		}
		if (iB4 > -1) {
			heatb4 = heatB4 * heatP / (fbplus4 * heatB4 + (1.0 - fbplus4) * heatP);
		}

	}
	// конвективные потоки
	doublereal Fe=0.0, Fw=0.0, Fn=0.0, Fs=0.0, Ft=0.0, Fb=0.0;
	// Для АЛИС сетки.
	doublereal Fe1 = 0.0, Fe2 = 0.0, Fe3 = 0.0, Fe4 = 0.0;
	doublereal Fw1 = 0.0, Fw2 = 0.0, Fw3 = 0.0, Fw4 = 0.0;
	doublereal Fn1 = 0.0, Fn2 = 0.0, Fn3 = 0.0, Fn4 = 0.0;
	doublereal Fs1 = 0.0, Fs2 = 0.0, Fs3 = 0.0, Fs4 = 0.0;
	doublereal Ft1 = 0.0, Ft2 = 0.0, Ft3 = 0.0, Ft4 = 0.0;
	doublereal Fb1 = 0.0, Fb2 = 0.0, Fb3 = 0.0, Fb4 = 0.0;


	/*
	if (bconvective) 
	{
		Fe=rhoe*ue*dy*dz;
	    Fw=rhow*uw*dy*dz;
	    Fn=rhon*vn*dx*dz;
	    Fs=rhos*vs*dx*dz;
        Ft=rhot*wt*dx*dy;
	    Fb=rhob*wb*dx*dy;
	}
	*/

	if ((ptr!=nullptr) && (bconvective)) 
	{
		// Если ptr==nullptr то отсутствует связь с гидродинамической частью и это означает
		// просто то что гидродинамической части нет как таковой и мы находимся в условиях
		// чистой теплопередачи внутри твёрдого тела.

		if (ptr[1][iP]!=-1) {
		// контрольный объём принадлежит жидкой зоне.
		
			if (!b_on_adaptive_local_refinement_mesh) {
				
				if (ptr[0][iP] > -1) {
					Fe = heate * f[ptr[1][iP]].mf[ptr[0][iP]][E_SIDE];
					Fn = heatn * f[ptr[1][iP]].mf[ptr[0][iP]][N_SIDE];
					Ft = heatt * f[ptr[1][iP]].mf[ptr[0][iP]][T_SIDE];
					Fw = heatw * f[ptr[1][iP]].mf[ptr[0][iP]][W_SIDE];
					Fs = heats * f[ptr[1][iP]].mf[ptr[0][iP]][S_SIDE];
					Fb = heatb * f[ptr[1][iP]].mf[ptr[0][iP]][B_SIDE];

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
					if (Fe != Fe) {
						std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
						printf("Fe=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fe);
						//printf("heate=%e ptr[1][iP]=%lld ptr[0][iP]=%lld mf=%e", heate, ptr[1][iP], ptr[0][iP], f[ptr[1][iP]].mf[ptr[0][iP]][E_SIDE]);
						std::cout << "heate=" << heate << " ptr[1][iP]=" << ptr[1][iP] << " ptr[0][iP]=" << ptr[0][iP] << " mf=" << f[ptr[1][iP]].mf[ptr[0][iP]][E_SIDE];
						system("PAUSE");
					}
					if (Fw != Fw) {
						std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
						printf("Fw=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fw);
						//printf("heatw=%e ptr[1][iP]=%lld ptr[0][iP]=%lld mf=%e", heatw, ptr[1][iP], ptr[0][iP], f[ptr[1][iP]].mf[ptr[0][iP]][W_SIDE]);
						std::cout << "heatw=" << heatw << " ptr[1][iP]=" << ptr[1][iP] << " ptr[0][iP]=" << ptr[0][iP] << " mf=" << f[ptr[1][iP]].mf[ptr[0][iP]][W_SIDE];
						system("PAUSE");
					}
					if (Fn != Fn) {
						std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
						printf("Fn=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fn);
						//printf("heatn=%e ptr[1][iP]=%lld ptr[0][iP]=%lld mf=%e", heatn, ptr[1][iP], ptr[0][iP], f[ptr[1][iP]].mf[ptr[0][iP]][N_SIDE]);
						std::cout << "heatn=" << heatn << " ptr[1][iP]=" << ptr[1][iP] << " ptr[0][iP]=" << ptr[0][iP] << " mf=" << f[ptr[1][iP]].mf[ptr[0][iP]][N_SIDE];
						system("PAUSE");
					}
					if (Fs != Fs) {
						std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
						printf("Fs=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fs);
						//printf("heats=%e ptr[1][iP]=%lld ptr[0][iP]=%lld mf=%e", heats, ptr[1][iP], ptr[0][iP], f[ptr[1][iP]].mf[ptr[0][iP]][S_SIDE]);
						std::cout << "heats=" << heats << " ptr[1][iP]=" << ptr[1][iP] << " ptr[0][iP]=" << ptr[0][iP] << " mf=" << f[ptr[1][iP]].mf[ptr[0][iP]][S_SIDE];
						system("PAUSE");
					}
					if (Ft != Ft) {
						std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
						printf("Ft=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ft);
						//printf("heatt=%e ptr[1][iP]=%lld ptr[0][iP]=%lld mf=%e", heatt, ptr[1][iP], ptr[0][iP], f[ptr[1][iP]].mf[ptr[0][iP]][T_SIDE]);
						std::cout << "heatt=" << heatt << " ptr[1][iP]=" << ptr[1][iP] << " ptr[0][iP]=" << ptr[0][iP] << " mf=" << f[ptr[1][iP]].mf[ptr[0][iP]][T_SIDE];
						system("PAUSE");
					}
					if (Fb != Fb) {
						std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
						printf("Fb=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fb);
						//printf("heatb=%e ptr[1][iP]=%lld ptr[0][iP]=%lld mf=%e", heatb, ptr[1][iP], ptr[0][iP], f[ptr[1][iP]].mf[ptr[0][iP]][B_SIDE]);
						std::cout << "heatb=" << heatb << " ptr[1][iP]=" << ptr[1][iP] << " ptr[0][iP]=" << ptr[0][iP] << " mf=" << f[ptr[1][iP]].mf[ptr[0][iP]][B_SIDE];
						system("PAUSE");
					}
#endif
				}

				//if (fabs(Ft)+fabs(Fb) > 0.0) {
#if doubleintprecision == 1
					//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%lld iP=%lld\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#else
					//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%d iP=%d\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#endif

					//getchar();
				//}
			}
			else {
				// АЛИС сетка !!! 9 августа 2017.
				// Используется простая линейная интерполяция, на первых порах совсем без использования поправки Рхи-Чоу.

				if (ptr[0][iP] > -1) {

					// ВНИМАНИЕ !!! Fg нужно позже домножить на площадь соответствующей грани контрольного объёма.

					if ((iE > -1)&&(!bE)&&(ptr[0][iE] > -1)) {
						// Внутренний узел if (!bE).
						Fe1 = heate*(feplus*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iE]] + (1.0 - feplus)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bE) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
							Fe1 = heate * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]];
						}
					}
					if ((iW > -1)&&(!bW)&&(ptr[0][iW] > -1)) {
						// Внутренний узел if (!bW).
						Fw1 = heatw*(fwplus*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iW]] + (1.0 - fwplus)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bW) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]>-1) {
							Fw1 = heatw * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]];
						}
					}
					if ((iN > -1)&&(!bN)&&(ptr[0][iN] > -1)) {
						Fn1 = heatn*(fnplus*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iN]] + (1.0 - fnplus)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bN) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]>-1) {
							Fn1 = heatn * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]];
						}
					}
					if ((iS > -1)&&(!bS)&&(ptr[0][iS] > -1)) {
						Fs1 = heats*(fsplus*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iS]] + (1.0 - fsplus)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bS) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]>-1) {
							Fs1 = heats * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]];
						}
					}
					if ((iT > -1)&&(!bT)&&(ptr[0][iT] > -1)) {
						Ft1 = heatt*(ftplus*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iT]] + (1.0 - ftplus)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bT) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]>-1) {
							Ft1 = heatt * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]];
						}
					}
					if ((iB > -1)&&(!bB)&&(ptr[0][iB] > -1)) {
						Fb1 = heatb*(fbplus*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iB]] + (1.0 - fbplus)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bB) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]>-1) {
							Fb1 = heatb * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]];
						}
					}
					//***
					if ((iE2 > -1)&&(!bE2)&&(ptr[0][iE2] > -1)) {
						Fe2 = heate2*(feplus2*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iE2]] + (1.0 - feplus2)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bE2) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
							Fe2 = heate2 * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]];
						}
					}
					if ((iW2 > -1)&&(!bW2)&&(ptr[0][iW2] > -1)) {
						Fw2 = heatw2*(fwplus2*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iW2]] + (1.0 - fwplus2)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bW2) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
							Fw2 = heatw2 * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]];
						}
					}
					if ((iN2 > -1)&&(!bN2)&&(ptr[0][iN2] > -1)) {
						Fn2 = heatn2*(fnplus2*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iN2]] + (1.0 - fnplus2)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bN2) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
							Fn2 = heatn2 * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]];
						}
					}
					if ((iS2 > -1)&&(!bS2)&&(ptr[0][iS2] > -1)) {
						Fs2 = heats2*(fsplus2*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iS2]] + (1.0 - fsplus2)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bS2) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
							Fs2 = heats2 * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]];
						}
					}
					if ((iT2 > -1)&&(!bT2)&&(ptr[0][iT2] > -1)) {
						Ft2 = heatt2*(ftplus2*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iT2]] + (1.0 - ftplus2)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bT2) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]>-1) {
							Ft2 = heatt2 * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]];
						}
					}
					if ((iB2 > -1)&&(!bB2)&&(ptr[0][iB2] > -1)) {
						Fb2 = heatb2*(fbplus2*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iB2]] + (1.0 - fbplus2)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bB2) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
							Fb2 = heatb2 * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]];
						}
					}
					//***
					if ((iE3 > -1)&&(!bE3)&&(ptr[0][iE3] > -1)) {
						Fe3 = heate3*(feplus3*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iE3]] + (1.0 - feplus3)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bE3) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]>-1) {
							Fe3 = heate3 * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]];
						}
					}
					if ((iW3 > -1)&&(!bW3)&&(ptr[0][iW3] > -1)) {
						Fw3 = heatw3*(fwplus3*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iW3]] + (1.0 - fwplus3)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bW3) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]>-1) {
							Fw3 = heatw3 * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]];
						}
					}
					if ((iN3 > -1)&&(!bN3)&&(ptr[0][iN3] > -1)) {
						Fn3 = heatn3*(fnplus3*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iN3]] + (1.0 - fnplus3)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bN3) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]>-1) {
							Fn3 = heatn3 * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]];
						}
					}
					if ((iS3 > -1)&&(!bS3)&&(ptr[0][iS3] > -1)) {
						Fs3 = heats3*(fsplus3*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iS3]] + (1.0 - fsplus3)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bS3) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]>-1) {
							Fs3 = heats3 * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]];
						}
					}
					if ((iT3 > -1)&&(!bT3)&&(ptr[0][iT3] > -1)) {
						Ft3 = heatt3*(ftplus3*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iT3]] + (1.0 - ftplus3)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bT3) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]>-1) {
							Ft3 = heatt3 * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]];
						}
					}
					if ((iB3 > -1)&&(!bB3)&&(ptr[0][iB3] > -1)) {
						Fb3 = heatb3*(fbplus3*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iB3]] + (1.0 - ftplus3)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bB3) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]>-1) {
							Fb3 = heatb3 * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]];
						}
					}
					//***
					if ((iE4 > -1)&&(!bE4)&&(ptr[0][iE4] > -1)) {
						Fe4 = heate4*(feplus4*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iE4]] + (1.0 - feplus4)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bE4) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]>-1) {
							Fe4 = heate4 * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]];
						}
					}
					if ((iW4 > -1)&&(!bW4)&&(ptr[0][iW4] > -1)) {
						Fw4 = heatw4*(fwplus4*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iW4]] + (1.0 - fwplus4)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bW4) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]>-1) {
							Fw4 = heatw4 * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]];
						}
					}
					if ((iN4 > -1)&&(!bN4)&&(ptr[0][iN4] > -1)) {
						Fn4 = heatn4*(fnplus4*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iN4]] + (1.0 - fnplus4)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bN4) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]>-1) {
							Fn4 = heatn4 * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]];
						}
					}
					if ((iS4 > -1)&&(!bS4)&&(ptr[0][iS4] > -1)) {
						Fs4 = heats4*(fsplus4*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iS4]] + (1.0 - fsplus4)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bS4) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]>-1) {
							Fs4 = heats4 * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]];
						}
					}
					if ((iT4 > -1)&&(!bT4)&&(ptr[0][iT4] > -1)) {
						Ft4 = heatt4*(ftplus4*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iT4]] + (1.0 - ftplus4)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bT4) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]>-1) {
							Ft4 = heatt4 * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]];
						}
					}
					if ((iB4 > -1)&&(!bB4)&&(ptr[0][iB4] > -1)) {
						Fb4 = heatb4*(fbplus4*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iB4]] + (1.0 - fbplus4)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bB4) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]>-1) {
							Fb4 = heatb4 * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]];
						}
					}
					// patch 08.01.2020
					Fe *= rhoe; Fe1 *= rhoe; Fe2 *= rhoe2; Fe3 *= rhoe3; Fe4 *= rhoe4;
					Fn *= rhon; Fn1 *= rhon; Fn2 *= rhon2; Fn3 *= rhon3; Fn4 *= rhon4;
					Fw *= rhow; Fw1 *= rhow; Fw2 *= rhow2; Fw3 *= rhow3; Fw4 *= rhow4;
					Fs *= rhos; Fs1 *= rhos; Fs2 *= rhos2; Fs3 *= rhos3; Fs4 *= rhos4;
					Ft *= rhot; Ft1 *= rhot; Ft2 *= rhot2; Ft3 *= rhot3; Ft4 *= rhot4;
					Fb *= rhob; Fb1 *= rhob; Fb2 *= rhob2; Fb3 *= rhob3; Fb4 *= rhob4;

					/*// debug сюда заходит при АЛИС сетке. И значения не нулевые Ок.
					if (fabs(Fe1) + fabs(Fe2) + fabs(Fe3) + fabs(Fe4) + fabs(Fw1) + fabs(Fw2) + fabs(Fw3) + fabs(Fw4) +
						fabs(Fn1) + fabs(Fn2) + fabs(Fn3) + fabs(Fn4) + fabs(Fs1) + fabs(Fs2) + fabs(Fs3) + fabs(Fs4) +
						fabs(Ft1) + fabs(Ft2) + fabs(Ft3) + fabs(Ft4) + fabs(Fb1) + fabs(Fb2) + fabs(Fb3) + fabs(Fb4) > 0.1) {
						printf("Fe1=%e Fe2=%e Fe3=%e Fe4=%e Fw=%e Fw2=%e Fw3=%e Fw4=%e \n",Fe1,Fe2,Fe3,Fe4, Fw1, Fw2, Fw3, Fw4);
						printf("Fn1=%e Fn2=%e Fn3=%e Fn4=%e Fs=%e Fs2=%e Fs3=%e Fs4=%e \n", Fn1, Fn2, Fn3, Fn4, Fs1, Fs2, Fs3, Fs4);
						printf("Fe1=%e Fe2=%e Fe3=%e Fe4=%e Fw=%e Fw2=%e Fw3=%e Fw4=%e \n", Ft1, Ft2, Ft3, Ft4, Fb1, Fb2, Fb3, Fb4);
						getchar();
					}
					*/

				}
				
			}


	    }
	    else {
			
			if (!b_on_adaptive_local_refinement_mesh) {

				// контрольный объём iP принадлежит твёрдому телу.
				if (!bE) {
					if (ptr[1][iE] != -1) Fe = heate*f[ptr[1][iE]].mf[ptr[0][iE]][W_SIDE]; // контрольный объём iE принадлежит жидкости, а КО iP принадлежит твёрдому телу.
					else Fe = 0.0; // iP && iE принадлежат твёрдому телу.
				}
				else Fe = 0.0; // грань КО iP принадлежит твёрдотельной со стороны твёрдого тела границе расчётной области.

				if (!bW) {
					if (ptr[1][iW] != -1) Fw = heatw*f[ptr[1][iW]].mf[ptr[0][iW]][E_SIDE];
					else Fw = 0.0;
				}
				else Fw = 0.0;

				if (!bN) {
					if (ptr[1][iN] != -1) Fn = heatn*f[ptr[1][iN]].mf[ptr[0][iN]][S_SIDE];
					else Fn = 0.0;
				}
				else Fn = 0.0;

				if (!bS) {
					if (ptr[1][iS] != -1) Fs = heats*f[ptr[1][iS]].mf[ptr[0][iS]][N_SIDE];
					else Fs = 0.0;
				}
				else Fs = 0.0;

				if (!bT) {
					if (ptr[1][iT] != -1) Ft = heatt*f[ptr[1][iT]].mf[ptr[0][iT]][B_SIDE];
					else Ft = 0.0;
				}
				else Ft = 0.0;

				if (!bB) {
					if (ptr[1][iB] != -1) Fb = heatb*f[ptr[1][iB]].mf[ptr[0][iB]][T_SIDE];
					else Fb = 0.0;
				}
				else Fb = 0.0;
			}
	    }

		/*
		doublereal ts = Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb;
		if (ts != ts) {
			if (Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb > 1.0e-36) {
				printf("%d Fe=%e Fw=%e Fn=%e Fs=%e Ft=%e Fb=%e\n", iP, Fe, Fw, Fn, Fs, Ft, Fb);
				getchar();
			}
		}
		*/
	} // bconvective

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	// конвективные потоки
	if (Fe != Fe) {
		std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
		printf("Fe=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n",Fe);
		system("PAUSE");
	}
	if (Fw != Fw) {
		std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
		printf("Fw=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fw);
		system("PAUSE");
	}
	if (Fn != Fn) {
		std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
		printf("Fn=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fn);
		system("PAUSE");
	}
	if (Fs != Fs) {
		std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
		printf("Fs=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fs);
		system("PAUSE");
	}
	if (Ft != Ft) {
		std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
		printf("Ft=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ft);
		system("PAUSE");
	}
	if (Fb != Fb) {
		std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
		printf("Fb=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fb);
		system("PAUSE");
	}

	if (b_on_adaptive_local_refinement_mesh) {

		// Для АЛИС сетки.
		if (Fe1 != Fe1) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fe1=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fe1);
			system("PAUSE");
		}
		if (Fw1 != Fw1) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fw1=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fw1);
			system("PAUSE");
		}
		if (Fn1 != Fn1) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fn1=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fn1);
			system("PAUSE");
		}
		if (Fs1 != Fs1) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fs1=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fs1);
			system("PAUSE");
		}
		if (Ft1 != Ft1) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Ft1=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ft1);
			system("PAUSE");
		}
		if (Fb1 != Fb1) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fb1=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fb1);
			system("PAUSE");
		}
		if (Fe2 != Fe2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fe2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fe2);
			system("PAUSE");
		}
		if (Fw2 != Fw2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fw2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fw2);
			system("PAUSE");
		}
		if (Fn2 != Fn2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fn2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fn2);
			system("PAUSE");
		}
		if (Fs2 != Fs2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fs2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fs2);
			system("PAUSE");
		}
		if (Ft2 != Ft2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Ft2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ft2);
			system("PAUSE");
		}
		if (Fb2 != Fb2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fb2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fb2);
			system("PAUSE");
		}
		if (Fe3 != Fe3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fe3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fe3);
			system("PAUSE");
		}
		if (Fw3 != Fw3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fw3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fw3);
			system("PAUSE");
		}
		if (Fn3 != Fn3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fn3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fn3);
			system("PAUSE");
		}
		if (Fs3 != Fs3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fs3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fs3);
			system("PAUSE");
		}
		if (Ft3 != Ft3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Ft3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ft3);
			system("PAUSE");
		}
		if (Fb3 != Fb3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fb3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fb3);
			system("PAUSE");
		}
		if (Fe4 != Fe4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fe4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fe4);
			system("PAUSE");
		}
		if (Fw4 != Fw4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fw4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fw4);
			system("PAUSE");
		}
		if (Fn4 != Fn4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fn4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fn4);
			system("PAUSE");
		}
		if (Fs4 != Fs4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fs4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fs4);
			system("PAUSE");
		}
		if (Ft4 != Ft4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Ft4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ft4);
			system("PAUSE");
		}
		if (Fb4 != Fb4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Fb4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fb4);
			system("PAUSE");
		}

	}
#endif
	// коэффициенты диффузии:
	doublereal GP=0.0, GE=0.0, GW=0.0, GN=0.0, GS=0.0, GT=0.0, GB=0.0;
	
    GP=prop[LAM][iP];
	if (iE > -1) {
		if (!bE) GE = prop[LAM][iE]; else GE = prop_b[LAM][iE - maxelm];
	}
	if (iN > -1) {
		if (!bN) GN = prop[LAM][iN]; else GN = prop_b[LAM][iN - maxelm];
	}
	if (iT > -1) {
		if (!bT) GT = prop[LAM][iT]; else GT = prop_b[LAM][iT - maxelm];
	}
	if (iW > -1) {
		if (!bW) GW = prop[LAM][iW]; else GW = prop_b[LAM][iW - maxelm];
	}
	if (iS > -1) {
		if (!bS) GS = prop[LAM][iS]; else GS = prop_b[LAM][iS - maxelm];
	}
	if (iB > -1) {
		if (!bB) GB = prop[LAM][iB]; else GB = prop_b[LAM][iB - maxelm];
	}

	doublereal GE2=0.0, GW2=0.0, GN2=0.0, GS2=0.0, GT2=0.0, GB2=0.0;
	doublereal GE3=0.0, GW3=0.0, GN3=0.0, GS3=0.0, GT3=0.0, GB3=0.0;
	doublereal GE4=0.0, GW4=0.0, GN4=0.0, GS4=0.0, GT4=0.0, GB4=0.0;

	if (b_on_adaptive_local_refinement_mesh) {

		if (iE2 > -1) {
			if (!bE2) GE2 = prop[LAM][iE2]; else GE2 = prop_b[LAM][iE2 - maxelm];
		}
		if (iN2 > -1) {
			if (!bN2) GN2 = prop[LAM][iN2]; else GN2 = prop_b[LAM][iN2 - maxelm];
		}
		if (iT2 > -1) {
			if (!bT2) GT2 = prop[LAM][iT2]; else GT2 = prop_b[LAM][iT2 - maxelm];
		}
		if (iW2 > -1) {
			if (!bW2) GW2 = prop[LAM][iW2]; else GW2 = prop_b[LAM][iW2 - maxelm];
		}
		if (iS2 > -1) {
			if (!bS2) GS2 = prop[LAM][iS2]; else GS2 = prop_b[LAM][iS2 - maxelm];
		}
		if (iB2 > -1) {
			if (!bB2) GB2 = prop[LAM][iB2]; else GB2 = prop_b[LAM][iB2 - maxelm];
		}

		if (iE3 > -1) {
			if (!bE3) GE3 = prop[LAM][iE3]; else GE3 = prop_b[LAM][iE3 - maxelm];
		}
		if (iN3 > -1) {
			if (!bN3) GN3 = prop[LAM][iN3]; else GN3 = prop_b[LAM][iN3 - maxelm];
		}
		if (iT3 > -1) {
			if (!bT3) GT3 = prop[LAM][iT3]; else GT3 = prop_b[LAM][iT3 - maxelm];
		}
		if (iW3 > -1) {
			if (!bW3) GW3 = prop[LAM][iW3]; else GW3 = prop_b[LAM][iW3 - maxelm];
		}
		if (iS3 > -1) {
			if (!bS3) GS3 = prop[LAM][iS3]; else GS3 = prop_b[LAM][iS3 - maxelm];
		}
		if (iB3 > -1) {
			if (!bB3) GB3 = prop[LAM][iB3]; else GB3 = prop_b[LAM][iB3 - maxelm];
		}

		if (iE4 > -1) {
			if (!bE4) GE4 = prop[LAM][iE4]; else GE4 = prop_b[LAM][iE4 - maxelm];
		}
		if (iN4 > -1) {
			if (!bN4) GN4 = prop[LAM][iN4]; else GN4 = prop_b[LAM][iN4 - maxelm];
		}
		if (iT4 > -1) {
			if (!bT4) GT4 = prop[LAM][iT4]; else GT4 = prop_b[LAM][iT4 - maxelm];
		}
		if (iW4 > -1) {
			if (!bW4) GW4 = prop[LAM][iW4]; else GW4 = prop_b[LAM][iW4 - maxelm];
		}
		if (iS4 > -1) {
			if (!bS4) GS4 = prop[LAM][iS4]; else GS4 = prop_b[LAM][iS4 - maxelm];
		}
		if (iB4 > -1) {
			if (!bB4) GB4 = prop[LAM][iB4]; else GB4 = prop_b[LAM][iB4 - maxelm];
		}
	}

	/* // Экспериментальный и не рабочий вариант.
	if (!bE) GE=prop[LAM][iE]; else GE=GP;
    if (!bN) GN=prop[LAM][iN]; else GN=GP;
	if (!bT) GT=prop[LAM][iT]; else GT=GP;
	if (!bW) GW=prop[LAM][iW]; else GW=GP;
    if (!bS) GS=prop[LAM][iS]; else GS=GP;
	if (!bB) GB=prop[LAM][iB]; else GB=GP;
	*/
	
	doublereal Ge=0.0, Gw=0.0, Gn=0.0, Gs=0.0, Gt=0.0, Gb=0.0;

    // Теплопроводность на гранях внутреннего КО:
	if (iE > -1) {
		Ge = GE*GP / (feplus*GE + (1 - feplus)*GP);
	}
	if (iW > -1) {
		Gw = GW*GP / (fwplus*GW + (1 - fwplus)*GP);
	}
	if (iN > -1) {
		Gn = GN*GP / (fnplus*GN + (1 - fnplus)*GP);
	}
	if (iS > -1) {
		Gs = GS*GP / (fsplus*GS + (1 - fsplus)*GP);
	}
	if (iT > -1) {
		Gt = GT*GP / (ftplus*GT + (1 - ftplus)*GP);
	}
	if (iB > -1) {
		Gb = GB*GP / (fbplus*GB + (1 - fbplus)*GP);
	}

	doublereal Ge2 = 0.0, Gw2 = 0.0, Gn2 = 0.0, Gs2 = 0.0, Gt2 = 0.0, Gb2 = 0.0;
	doublereal Ge3 = 0.0, Gw3 = 0.0, Gn3 = 0.0, Gs3 = 0.0, Gt3 = 0.0, Gb3 = 0.0;
	doublereal Ge4 = 0.0, Gw4 = 0.0, Gn4 = 0.0, Gs4 = 0.0, Gt4 = 0.0, Gb4 = 0.0;

	if (b_on_adaptive_local_refinement_mesh) {

		// Теплопроводность на гранях внутреннего КО:
		if (iE2 > -1) {
			Ge2 = GE2 * GP / (feplus2 * GE2 + (1 - feplus2) * GP);
		}
		if (iW2 > -1) {
			Gw2 = GW2 * GP / (fwplus2 * GW2 + (1 - fwplus2) * GP);
		}
		if (iN2 > -1) {
			Gn2 = GN2 * GP / (fnplus2 * GN2 + (1 - fnplus2) * GP);
		}
		if (iS2 > -1) {
			Gs2 = GS2 * GP / (fsplus2 * GS2 + (1 - fsplus2) * GP);
		}
		if (iT2 > -1) {
			Gt2 = GT2 * GP / (ftplus2 * GT2 + (1 - ftplus2) * GP);
		}
		if (iB2 > -1) {
			Gb2 = GB2 * GP / (fbplus2 * GB2 + (1 - fbplus2) * GP);
		}

		

		// Теплопроводность на гранях внутреннего КО:
		if (iE3 > -1) {
			Ge3 = GE3 * GP / (feplus3 * GE3 + (1 - feplus3) * GP);
		}
		if (iW3 > -1) {
			Gw3 = GW3 * GP / (fwplus3 * GW3 + (1 - fwplus3) * GP);
		}
		if (iN3 > -1) {
			Gn3 = GN3 * GP / (fnplus3 * GN3 + (1 - fnplus3) * GP);
		}
		if (iS3 > -1) {
			Gs3 = GS3 * GP / (fsplus3 * GS3 + (1 - fsplus3) * GP);
		}
		if (iT3 > -1) {
			Gt3 = GT3 * GP / (ftplus3 * GT3 + (1 - ftplus3) * GP);
		}
		if (iB3 > -1) {
			Gb3 = GB3 * GP / (fbplus3 * GB3 + (1 - fbplus3) * GP);
		}

		

		// Теплопроводность на гранях внутреннего КО:
		if (iE4 > -1) {
			Ge4 = GE4 * GP / (feplus4 * GE4 + (1 - feplus4) * GP);
		}
		if (iW4 > -1) {
			Gw4 = GW4 * GP / (fwplus4 * GW4 + (1 - fwplus4) * GP);
		}
		if (iN4 > -1) {
			Gn4 = GN4 * GP / (fnplus4 * GN4 + (1 - fnplus4) * GP);
		}
		if (iS4 > -1) {
			Gs4 = GS4 * GP / (fsplus4 * GS4 + (1 - fsplus4) * GP);
		}
		if (iT4 > -1) {
			Gt4 = GT4 * GP / (ftplus4 * GT4 + (1 - ftplus4) * GP);
		}
		if (iB4 > -1) {
			Gb4 = GB4 * GP / (fbplus4 * GB4 + (1 - fbplus4) * GP);
		}

	}

	bool bortho86 = false;
	// Теплопроводность на грани является ортотропной 
	// если два контрольных объёма окружающие грань 
	// имеют одинаковый коэффициент ортотропности.
	if ((ptr != nullptr) && (ptr[1][iP] == -1)) {
		bortho86 = true;
	}
	else if ((ptr != nullptr) && (ptr[1][iP] != -1)) {
		// Жидкая зона ортотропности просто нет.
		bortho86 = false;
	}
	else {
		bortho86 = true;
	}

	if (bortho86) {
		// Корректировка за счёт ортотропности:
		if (iE > -1) {
			if (iE >= maxelm) {
				// Граничный узел.
				if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iE - maxelm]) < 1.0e-23) {
					Ge *= prop[MULT_LAM_X][iP];
				}
			}
			else {
				// Внутренний узел.
				//if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iE]) < 1.0e-23) {
					//Ge *= prop[MULT_LAM_X][iP];
				//}
				// Дает температуру более близкую к истинной.
				//Ge *= 2.0*(prop[MULT_LAM_X][iE])*(prop[MULT_LAM_X][iP]) / (prop[MULT_LAM_X][iP] + prop[MULT_LAM_X][iE]);
				Ge *= fmax(prop[MULT_LAM_X][iE], prop[MULT_LAM_X][iP]);
			}
		}
		if (iW > -1) {
			if (iW >= maxelm) {
				// Граничный узел.
				if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iW - maxelm]) < 1.0e-23) {
					Gw *= prop[MULT_LAM_X][iP];
				}
			}
			else {
				// Внутренний узел.
				//if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iW]) < 1.0e-23) {
					//Gw *= prop[MULT_LAM_X][iP];
				//}
				// Дает температуру более близкую к истинной.
				//Gw *= 2.0*(prop[MULT_LAM_X][iW])*(prop[MULT_LAM_X][iP]) / (prop[MULT_LAM_X][iP] + prop[MULT_LAM_X][iW]);
				Gw *= fmax(prop[MULT_LAM_X][iW], prop[MULT_LAM_X][iP]);
			}
		}
		if (iN > -1) {
			if (iN >= maxelm) {
				// Граничный узел.
				if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iN - maxelm]) < 1.0e-23) {
					Gn *= prop[MULT_LAM_Y][iP];
				}
			}
			else {
				// Внутренний узел.
				//if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iN]) < 1.0e-23) {
					//Gn *= prop[MULT_LAM_Y][iP];
				//}
				// Дает температуру более близкую к истинной.
				//Gn *= 2.0*(prop[MULT_LAM_Y][iN])*(prop[MULT_LAM_Y][iP]) / (prop[MULT_LAM_Y][iP] + prop[MULT_LAM_Y][iN]);
				Gn *= fmax(prop[MULT_LAM_Y][iN], prop[MULT_LAM_Y][iP]);
			}
		}
		if (iS > -1) {
			if (iS >= maxelm) {
				// Граничный узел.
				if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iS - maxelm]) < 1.0e-23) {
					Gs *= prop[MULT_LAM_Y][iP];
				}
			}
			else {
				// Внутренний узел.
				//if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iS]) < 1.0e-23) {
					//Gs *= prop[MULT_LAM_Y][iP];
				//}
				// Дает температуру более близкую к истинной.
				//Gs *= 2.0*(prop[MULT_LAM_Y][iS])*(prop[MULT_LAM_Y][iP]) / (prop[MULT_LAM_Y][iP] + prop[MULT_LAM_Y][iS]);
				Gs *= fmax(prop[MULT_LAM_Y][iS], prop[MULT_LAM_Y][iP]);
			}
		}
		if (iT > -1) {
			if (iT >= maxelm) {
				// Граничный узел.
				if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iT - maxelm]) < 1.0e-23) {
					Gt *= prop[MULT_LAM_Z][iP];
				}
			}
			else {
				// Внутренний узел.
				//if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iT]) < 1.0e-23) {
					//Gt *= prop[MULT_LAM_Z][iP];
				//}
				// Дает температуру более близкую к истинной.
				//Gt *= 2.0*(prop[MULT_LAM_Z][iT])*(prop[MULT_LAM_Z][iP]) / (prop[MULT_LAM_Z][iP] + prop[MULT_LAM_Z][iT]);
				Gt *= fmax(prop[MULT_LAM_Z][iT], prop[MULT_LAM_Z][iP]);
			}
		}
		if (iB > -1) {
			if (iB >= maxelm) {
				// Граничный узел.
				if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iB - maxelm]) < 1.0e-23) {
					Gb *= prop[MULT_LAM_Z][iP];
				}
			}
			else {
				// Внутренний узел.
				// Занижено, температура будет повыше.
				//if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iB]) < 1.0e-23) {
					//Gb *= prop[MULT_LAM_Z][iP];
				//}
				// Дает температуру более близкую к истинной.
				//Gb *= 2.0*(prop[MULT_LAM_Z][iB])*(prop[MULT_LAM_Z][iP]) / (prop[MULT_LAM_Z][iP]+ prop[MULT_LAM_Z][iB]);
				Gb *= fmax(prop[MULT_LAM_Z][iB], prop[MULT_LAM_Z][iP]);
			}
		}

		if (b_on_adaptive_local_refinement_mesh) {
			// Корректировка за счёт ортотропности:
			if (iE2 > -1) {
				if (iE2 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iE2 - maxelm]) < 1.0e-23) {
						Ge2 *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iE2]) < 1.0e-23) {
						Ge2 *= prop[MULT_LAM_X][iP];
					}
				}
			}
			if (iW2 > -1) {
				if (iW2 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iW2 - maxelm]) < 1.0e-23) {
						Gw2 *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iW2]) < 1.0e-23) {
						Gw2 *= prop[MULT_LAM_X][iP];
					}
				}
			}
			if (iN2 > -1) {
				if (iN2 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iN2 - maxelm]) < 1.0e-23) {
						Gn2 *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iN2]) < 1.0e-23) {
						Gn2 *= prop[MULT_LAM_Y][iP];
					}
				}
			}
			if (iS2 > -1) {
				if (iS2 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iS2 - maxelm]) < 1.0e-23) {
						Gs2 *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iS2]) < 1.0e-23) {
						Gs2 *= prop[MULT_LAM_Y][iP];
					}
				}
			}
			if (iT2 > -1) {
				if (iT2 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iT2 - maxelm]) < 1.0e-23) {
						Gt2 *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iT2]) < 1.0e-23) {
						Gt2 *= prop[MULT_LAM_Z][iP];
					}
				}
			}
			if (iB2 > -1) {
				if (iB2 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iB2 - maxelm]) < 1.0e-23) {
						Gb2 *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iB2]) < 1.0e-23) {
						Gb2 *= prop[MULT_LAM_Z][iP];
					}
				}
			}


			// Корректировка за счёт ортотропности:
			if (iE3 > -1) {
				if (iE3 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iE3 - maxelm]) < 1.0e-23) {
						Ge3 *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iE3]) < 1.0e-23) {
						Ge3 *= prop[MULT_LAM_X][iP];
					}
				}
			}
			if (iW3 > -1) {
				if (iW3 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iW3 - maxelm]) < 1.0e-23) {
						Gw3 *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iW3]) < 1.0e-23) {
						Gw3 *= prop[MULT_LAM_X][iP];
					}
				}
			}
			if (iN3 > -1) {
				if (iN3 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iN3 - maxelm]) < 1.0e-23) {
						Gn3 *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iN3]) < 1.0e-23) {
						Gn3 *= prop[MULT_LAM_Y][iP];
					}
				}
			}
			if (iS3 > -1) {
				if (iS3 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iS3 - maxelm]) < 1.0e-23) {
						Gs3 *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iS3]) < 1.0e-23) {
						Gs3 *= prop[MULT_LAM_Y][iP];
					}
				}
			}
			if (iT3 > -1) {
				if (iT3 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iT3 - maxelm]) < 1.0e-23) {
						Gt3 *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iT3]) < 1.0e-23) {
						Gt3 *= prop[MULT_LAM_Z][iP];
					}
				}
			}
			if (iB3 > -1) {
				if (iB3 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iB3 - maxelm]) < 1.0e-23) {
						Gb3 *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iB3]) < 1.0e-23) {
						Gb3 *= prop[MULT_LAM_Z][iP];
					}
				}
			}

			// Корректировка за счёт ортотропности:
			if (iE4 > -1) {
				if (iE4 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iE4 - maxelm]) < 1.0e-23) {
						Ge4 *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iE4]) < 1.0e-23) {
						Ge4 *= prop[MULT_LAM_X][iP];
					}
				}
			}
			if (iW4 > -1) {
				if (iW4 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iW4 - maxelm]) < 1.0e-23) {
						Gw4 *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iW4]) < 1.0e-23) {
						Gw4 *= prop[MULT_LAM_X][iP];
					}
				}
			}
			if (iN4 > -1) {
				if (iN4 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iN4 - maxelm]) < 1.0e-23) {
						Gn4 *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iN4]) < 1.0e-23) {
						Gn4 *= prop[MULT_LAM_Y][iP];
					}
				}
			}
			if (iS4 > -1) {
				if (iS4 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iS4 - maxelm]) < 1.0e-23) {
						Gs4 *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iS4]) < 1.0e-23) {
						Gs4 *= prop[MULT_LAM_Y][iP];
					}
				}
			}
			if (iT4 > -1) {
				if (iT4 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iT4 - maxelm]) < 1.0e-23) {
						Gt4 *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iT4]) < 1.0e-23) {
						Gt4 *= prop[MULT_LAM_Z][iP];
					}
				}
			}
			if (iB4 > -1) {
				if (iB4 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iB4 - maxelm]) < 1.0e-23) {
						Gb4 *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iB4]) < 1.0e-23) {
						Gb4 *= prop[MULT_LAM_Z][iP];
					}
				}
			}
		}
	}
	
	// до.
	// контроль коэффициента теплопроводности:
	//printf("Ge=%e, Gw=%e, Gn=%e, Gs=%e, Gt=%e, Gb=%e\n",Ge,Gw,Gn,Gs,Gt,Gb);


	// Добавляем турбулентную теплопроводность.
	if (bconvective) {
		if (ptr != nullptr) {

			// закомментировано 15.04.2019.
			//if (!b_on_adaptive_local_refinement_mesh) 
			{

				// Если мы имеем чисто твёрдотельную задачу, то в ней данный код не участвует,
				// так как связан с турбулентным добавком к теплопроводности.
				const doublereal dTurbulentPrandtlNumber = 0.85;

				if (iE > -1) {
					if (!bE) {
						bool bsolidP = false, bsolidS = false;
						doublereal turblamS = 0.0, turblamP = 0.0;

						if (ptr[1][iE] == -1) {
							// принадлежит твёрдому телу
							turblamS = 0.0;
							bsolidS = true;
						}
						else {
							if ((f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								turblamS = prop[HEAT_CAPACITY][iE] * f[ptr[1][iE]].potent[MUT][ptr[0][iE]] / dTurbulentPrandtlNumber;
							}
						}

						if (ptr[1][iP] == -1) {
							// принадлежит твёрдому телу
							turblamP = 0.0;
							bsolidP = true;
						}
						else {
							if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
							}
						}

						if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
							doublereal cpe = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iE] / ((1.0 - feplus)*prop[HEAT_CAPACITY][iP] + feplus*prop[HEAT_CAPACITY][iE]);
							if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
								if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]>-1) {
									Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]>-1) {
									Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]>-1) {
									Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]>-1) {
									Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								
							}
							else if ((bsolidP) && ((f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
								if (f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE]]>-1) {
									Ge += cpe*f[ptr[1][iE]].potent[MUT][f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE]]>-1) {
									Ge += cpe*f[ptr[1][iE]].potent[MUT][f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE]]>-1) {
									Ge += cpe*f[ptr[1][iE]].potent[MUT][f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE]]>-1) {
									Ge += cpe*f[ptr[1][iE]].potent[MUT][f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE]]] / dTurbulentPrandtlNumber;
								}							

							}

						}
						else if (!(bsolidS && bsolidP)) {
							Ge += feplus*turblamS + (1.0 - feplus)*turblamP;
						}

					}
					else {
						if (ptr[1][iP] != -1) {
							if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								doublereal cpe = prop_b[HEAT_CAPACITY][iE - maxelm];
								if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]>-1) {
									Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]>-1) {
									Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]>-1) {
									Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]>-1) {
									Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}								
							}
						}
					}
				}

				if (b_on_adaptive_local_refinement_mesh) {

					if (iE2 > -1) {
						if (!bE2) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iE2] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iE2] * f[ptr[1][iE2]].potent[MUT][ptr[0][iE2]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpe = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iE2] / ((1.0 - feplus2) * prop[HEAT_CAPACITY][iP] + feplus2 * prop[HEAT_CAPACITY][iE2]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE2]] > -1) {
										Ge2 += cpe * f[ptr[1][iE2]].potent[MUT][f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE2]] > -1) {
										Ge2 += cpe * f[ptr[1][iE2]].potent[MUT][f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE2]] > -1) {
										Ge2 += cpe * f[ptr[1][iE2]].potent[MUT][f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE2]] > -1) {
										Ge2 += cpe * f[ptr[1][iE2]].potent[MUT][f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE2]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Ge2 += feplus2 * turblamS + (1.0 - feplus2) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpe = prop_b[HEAT_CAPACITY][iE2 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iE3 > -1) {
						if (!bE3) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iE3] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iE3] * f[ptr[1][iE3]].potent[MUT][ptr[0][iE3]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpe = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iE3] / ((1.0 - feplus3) * prop[HEAT_CAPACITY][iP] + feplus3 * prop[HEAT_CAPACITY][iE3]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}

								}
								else if ((bsolidP) && ((f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE3]] > -1) {
										Ge3 += cpe * f[ptr[1][iE3]].potent[MUT][f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE3]] > -1) {
										Ge3 += cpe * f[ptr[1][iE3]].potent[MUT][f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE3]] > -1) {
										Ge3 += cpe * f[ptr[1][iE3]].potent[MUT][f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE3]] > -1) {
										Ge3 += cpe * f[ptr[1][iE3]].potent[MUT][f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE3]]] / dTurbulentPrandtlNumber;
									}

								}

							}
							else if (!(bsolidS && bsolidP)) {
								Ge3 += feplus3 * turblamS + (1.0 - feplus3) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpe = prop_b[HEAT_CAPACITY][iE3 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iE4 > -1) {
						if (!bE4) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iE4] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iE4] * f[ptr[1][iE4]].potent[MUT][ptr[0][iE4]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpe = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iE4] / ((1.0 - feplus4) * prop[HEAT_CAPACITY][iP] + feplus4 * prop[HEAT_CAPACITY][iE4]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}

								}
								else if ((bsolidP) && ((f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE4]] > -1) {
										Ge4 += cpe * f[ptr[1][iE4]].potent[MUT][f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE4]] > -1) {
										Ge4 += cpe * f[ptr[1][iE4]].potent[MUT][f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE4]] > -1) {
										Ge4 += cpe * f[ptr[1][iE4]].potent[MUT][f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE4]] > -1) {
										Ge4 += cpe * f[ptr[1][iE4]].potent[MUT][f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE4]]] / dTurbulentPrandtlNumber;
									}

								}

							}
							else if (!(bsolidS && bsolidP)) {
								Ge4 += feplus4 * turblamS + (1.0 - feplus4) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpe = prop_b[HEAT_CAPACITY][iE4 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}


					if (iN2 > -1) {
						if (!bN2) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iN2] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iN2] * f[ptr[1][iN2]].potent[MUT][ptr[0][iN2]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpn = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iN2] / ((1.0 - fnplus2) * prop[HEAT_CAPACITY][iP] + fnplus2 * prop[HEAT_CAPACITY][iN2]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN2]] > -1) {
										Gn2 += cpn * f[ptr[1][iN2]].potent[MUT][f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN2]] > -1) {
										Gn2 += cpn * f[ptr[1][iN2]].potent[MUT][f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN2]] > -1) {
										Gn2 += cpn * f[ptr[1][iN2]].potent[MUT][f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN2]] > -1) {
										Gn2 += cpn * f[ptr[1][iN2]].potent[MUT][f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN2]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gn2 += fnplus2 * turblamS + (1.0 - fnplus2) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpn = prop_b[HEAT_CAPACITY][iN2 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iN3 > -1) {
						if (!bN3) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iN3] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iN3] * f[ptr[1][iN3]].potent[MUT][ptr[0][iN3]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpn = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iN3] / ((1.0 - fnplus3) * prop[HEAT_CAPACITY][iP] + fnplus3 * prop[HEAT_CAPACITY][iN3]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN3]] > -1) {
										Gn3 += cpn * f[ptr[1][iN3]].potent[MUT][f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN3]] > -1) {
										Gn3 += cpn * f[ptr[1][iN3]].potent[MUT][f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN3]] > -1) {
										Gn3 += cpn * f[ptr[1][iN3]].potent[MUT][f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN3]] > -1) {
										Gn3 += cpn * f[ptr[1][iN3]].potent[MUT][f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN3]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gn3 += fnplus3 * turblamS + (1.0 - fnplus3) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpn = prop_b[HEAT_CAPACITY][iN3 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iN4 > -1) {
						if (!bN4) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iN4] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iN4] * f[ptr[1][iN4]].potent[MUT][ptr[0][iN4]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpn = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iN4] / ((1.0 - fnplus4) * prop[HEAT_CAPACITY][iP] + fnplus4 * prop[HEAT_CAPACITY][iN4]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN4]] > -1) {
										Gn4 += cpn * f[ptr[1][iN4]].potent[MUT][f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN4]] > -1) {
										Gn4 += cpn * f[ptr[1][iN4]].potent[MUT][f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN4]] > -1) {
										Gn4 += cpn * f[ptr[1][iN4]].potent[MUT][f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN4]] > -1) {
										Gn4 += cpn * f[ptr[1][iN4]].potent[MUT][f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN4]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gn4 += fnplus4 * turblamS + (1.0 - fnplus4) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpn = prop_b[HEAT_CAPACITY][iN4 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}


					if (iT2 > -1) {
						if (!bT2) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iT2] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iT2] * f[ptr[1][iT2]].potent[MUT][ptr[0][iT2]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpt = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iT2] / ((1.0 - ftplus2) * prop[HEAT_CAPACITY][iP] + ftplus2 * prop[HEAT_CAPACITY][iT2]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT2]] > -1) {
										Gt2 += cpt * f[ptr[1][iT2]].potent[MUT][f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT2]] > -1) {
										Gt2 += cpt * f[ptr[1][iT2]].potent[MUT][f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT2]] > -1) {
										Gt2 += cpt * f[ptr[1][iT2]].potent[MUT][f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT2]] > -1) {
										Gt2 += cpt * f[ptr[1][iT2]].potent[MUT][f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT2]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gt2 += ftplus2 * turblamS + (1.0 - ftplus2) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpt = prop_b[HEAT_CAPACITY][iT2 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iT3 > -1) {
						if (!bT3) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iT3] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iT3] * f[ptr[1][iT3]].potent[MUT][ptr[0][iT3]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpt = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iT3] / ((1.0 - ftplus3) * prop[HEAT_CAPACITY][iP] + ftplus3 * prop[HEAT_CAPACITY][iT3]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT3]] > -1) {
										Gt3 += cpt * f[ptr[1][iT3]].potent[MUT][f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT3]] > -1) {
										Gt3 += cpt * f[ptr[1][iT3]].potent[MUT][f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT3]] > -1) {
										Gt3 += cpt * f[ptr[1][iT3]].potent[MUT][f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT3]] > -1) {
										Gt3 += cpt * f[ptr[1][iT3]].potent[MUT][f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT3]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gt3 += ftplus3 * turblamS + (1.0 - ftplus3) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpt = prop_b[HEAT_CAPACITY][iT3 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iT4 > -1) {
						if (!bT4) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iT4] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iT4] * f[ptr[1][iT4]].potent[MUT][ptr[0][iT4]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpt = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iT4] / ((1.0 - ftplus4) * prop[HEAT_CAPACITY][iP] + ftplus4 * prop[HEAT_CAPACITY][iT4]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT4]] > -1) {
										Gt4 += cpt * f[ptr[1][iT4]].potent[MUT][f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT4]] > -1) {
										Gt4 += cpt * f[ptr[1][iT4]].potent[MUT][f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT4]] > -1) {
										Gt4 += cpt * f[ptr[1][iT4]].potent[MUT][f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT4]] > -1) {
										Gt4 += cpt * f[ptr[1][iT4]].potent[MUT][f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT4]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gt4 += ftplus4 * turblamS + (1.0 - ftplus4) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpt = prop_b[HEAT_CAPACITY][iT4 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}


					if (iW2 > -1) {
						if (!bW2) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iW2] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iW2] * f[ptr[1][iW2]].potent[MUT][ptr[0][iW2]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpw = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iW2] / ((1.0 - fwplus2) * prop[HEAT_CAPACITY][iP] + fwplus2 * prop[HEAT_CAPACITY][iW2]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW2]] > -1) {
										Gw2 += cpw * f[ptr[1][iW2]].potent[MUT][f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW2]] > -1) {
										Gw2 += cpw * f[ptr[1][iW2]].potent[MUT][f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW2]] > -1) {
										Gw2 += cpw * f[ptr[1][iW2]].potent[MUT][f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW2]] > -1) {
										Gw2 += cpw * f[ptr[1][iW2]].potent[MUT][f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW2]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gw2 += fwplus2 * turblamS + (1.0 - fwplus2) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpw = prop_b[HEAT_CAPACITY][iW2 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iW3 > -1) {
						if (!bW3) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iW3] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iW3] * f[ptr[1][iW3]].potent[MUT][ptr[0][iW3]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpw = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iW3] / ((1.0 - fwplus3) * prop[HEAT_CAPACITY][iP] + fwplus3 * prop[HEAT_CAPACITY][iW3]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW3]] > -1) {
										Gw3 += cpw * f[ptr[1][iW3]].potent[MUT][f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW3]] > -1) {
										Gw3 += cpw * f[ptr[1][iW3]].potent[MUT][f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW3]] > -1) {
										Gw3 += cpw * f[ptr[1][iW3]].potent[MUT][f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW3]] > -1) {
										Gw3 += cpw * f[ptr[1][iW3]].potent[MUT][f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW3]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gw3 += fwplus3 * turblamS + (1.0 - fwplus3) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpw = prop_b[HEAT_CAPACITY][iW3 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iW4 > -1) {
						if (!bW4) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iW4] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iW4] * f[ptr[1][iW4]].potent[MUT][ptr[0][iW4]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpw = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iW4] / ((1.0 - fwplus4) * prop[HEAT_CAPACITY][iP] + fwplus4 * prop[HEAT_CAPACITY][iW4]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW4]] > -1) {
										Gw4 += cpw * f[ptr[1][iW4]].potent[MUT][f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW4]] > -1) {
										Gw4 += cpw * f[ptr[1][iW4]].potent[MUT][f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW4]] > -1) {
										Gw4 += cpw * f[ptr[1][iW4]].potent[MUT][f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW4]] > -1) {
										Gw4 += cpw * f[ptr[1][iW4]].potent[MUT][f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW4]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gw4 += fwplus4 * turblamS + (1.0 - fwplus4) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpw = prop_b[HEAT_CAPACITY][iW4 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}


					if (iS2 > -1) {
						if (!bS2) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iS2] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iS2] * f[ptr[1][iS2]].potent[MUT][ptr[0][iS2]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cps = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iS2] / ((1.0 - fsplus2) * prop[HEAT_CAPACITY][iP] + fsplus2 * prop[HEAT_CAPACITY][iS2]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS2]] > -1) {
										Gs2 += cps * f[ptr[1][iS2]].potent[MUT][f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS2]] > -1) {
										Gs2 += cps * f[ptr[1][iS2]].potent[MUT][f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS2]] > -1) {
										Gs2 += cps * f[ptr[1][iS2]].potent[MUT][f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS2]] > -1) {
										Gs2 += cps * f[ptr[1][iS2]].potent[MUT][f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS2]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gs2 += fsplus2 * turblamS + (1.0 - fsplus2) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cps = prop_b[HEAT_CAPACITY][iS2 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}

								}
							}
						}
					}

					if (iS3 > -1) {
						if (!bS3) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iS3] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iS3] * f[ptr[1][iS3]].potent[MUT][ptr[0][iS3]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cps = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iS3] / ((1.0 - fsplus3) * prop[HEAT_CAPACITY][iP] + fsplus3 * prop[HEAT_CAPACITY][iS3]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS3]] > -1) {
										Gs3 += cps * f[ptr[1][iS3]].potent[MUT][f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS3]] > -1) {
										Gs3 += cps * f[ptr[1][iS3]].potent[MUT][f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS3]] > -1) {
										Gs3 += cps * f[ptr[1][iS3]].potent[MUT][f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS3]] > -1) {
										Gs3 += cps * f[ptr[1][iS3]].potent[MUT][f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS3]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gs3 += fsplus3 * turblamS + (1.0 - fsplus3) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cps = prop_b[HEAT_CAPACITY][iS3 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}

								}
							}
						}
					}

					if (iS4 > -1) {
						if (!bS4) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iS4] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iS4] * f[ptr[1][iS4]].potent[MUT][ptr[0][iS4]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cps = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iS4] / ((1.0 - fsplus4) * prop[HEAT_CAPACITY][iP] + fsplus4 * prop[HEAT_CAPACITY][iS4]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS4]] > -1) {
										Gs4 += cps * f[ptr[1][iS4]].potent[MUT][f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS4]] > -1) {
										Gs4 += cps * f[ptr[1][iS4]].potent[MUT][f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS4]] > -1) {
										Gs4 += cps * f[ptr[1][iS4]].potent[MUT][f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS4]] > -1) {
										Gs4 += cps * f[ptr[1][iS4]].potent[MUT][f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS4]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gs4 += fsplus4 * turblamS + (1.0 - fsplus4) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cps = prop_b[HEAT_CAPACITY][iS4 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}

								}
							}
						}
					}


					if (iB2 > -1) {
						if (!bB2) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iB2] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iB2] * f[ptr[1][iB2]].potent[MUT][ptr[0][iB2]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpb = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iB2] / ((1.0 - fbplus2) * prop[HEAT_CAPACITY][iP] + fbplus2 * prop[HEAT_CAPACITY][iB2]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB2]] > -1) {
										Gb2 += cpb * f[ptr[1][iB2]].potent[MUT][f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB2]] > -1) {
										Gb2 += cpb * f[ptr[1][iB2]].potent[MUT][f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB2]] > -1) {
										Gb2 += cpb * f[ptr[1][iB2]].potent[MUT][f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB2]] > -1) {
										Gb2 += cpb * f[ptr[1][iB2]].potent[MUT][f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB2]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gb2 += fbplus2 * turblamS + (1.0 - fbplus2) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpb = prop_b[HEAT_CAPACITY][iB2 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iB3 > -1) {
						if (!bB3) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iB3] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iB3] * f[ptr[1][iB3]].potent[MUT][ptr[0][iB3]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpb = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iB3] / ((1.0 - fbplus3) * prop[HEAT_CAPACITY][iP] + fbplus3 * prop[HEAT_CAPACITY][iB3]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB3]] > -1) {
										Gb3 += cpb * f[ptr[1][iB3]].potent[MUT][f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB3]] > -1) {
										Gb3 += cpb * f[ptr[1][iB3]].potent[MUT][f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB3]] > -1) {
										Gb3 += cpb * f[ptr[1][iB3]].potent[MUT][f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB3]] > -1) {
										Gb3 += cpb * f[ptr[1][iB3]].potent[MUT][f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB3]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gb3 += fbplus3 * turblamS + (1.0 - fbplus3) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpb = prop_b[HEAT_CAPACITY][iB3 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iB4 > -1) {
						if (!bB4) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iB4] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iB4] * f[ptr[1][iB4]].potent[MUT][ptr[0][iB4]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpb = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iB4] / ((1.0 - fbplus4) * prop[HEAT_CAPACITY][iP] + fbplus4 * prop[HEAT_CAPACITY][iB4]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB4]] > -1) {
										Gb4 += cpb * f[ptr[1][iB4]].potent[MUT][f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB4]] > -1) {
										Gb4 += cpb * f[ptr[1][iB4]].potent[MUT][f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB4]] > -1) {
										Gb4 += cpb * f[ptr[1][iB4]].potent[MUT][f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB4]] > -1) {
										Gb4 += cpb * f[ptr[1][iB4]].potent[MUT][f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB4]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gb4 += fbplus4 * turblamS + (1.0 - fbplus4) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpb = prop_b[HEAT_CAPACITY][iB4 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}



				}

				if (iN > -1) {
					if (!bN) {
						bool bsolidP = false, bsolidS = false;
						doublereal turblamS = 0.0, turblamP = 0.0;

						if (ptr[1][iN] == -1) {
							// принадлежит твёрдому телу
							turblamS = 0.0;
							bsolidS = true;
						}
						else {
							if ((f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								turblamS = prop[HEAT_CAPACITY][iN] * f[ptr[1][iN]].potent[MUT][ptr[0][iN]] / dTurbulentPrandtlNumber;
							}
						}

						if (ptr[1][iP] == -1) {
							// принадлежит твёрдому телу
							turblamP = 0.0;
							bsolidP = true;
						}
						else {
							if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
							}
						}

						if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
							doublereal cpn = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iN] / ((1.0 - fnplus)*prop[HEAT_CAPACITY][iP] + fnplus*prop[HEAT_CAPACITY][iN]);
							if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
								if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]>-1) {
									Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]>-1) {
									Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]>-1) {
									Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]>-1) {
									Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
							}
							else if ((bsolidP) && ((f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
								if (f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN]]>-1) {
									Gn += cpn*f[ptr[1][iN]].potent[MUT][f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN]]>-1) {
									Gn += cpn*f[ptr[1][iN]].potent[MUT][f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN]]>-1) {
									Gn += cpn*f[ptr[1][iN]].potent[MUT][f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN]]>-1) {
									Gn += cpn*f[ptr[1][iN]].potent[MUT][f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN]]] / dTurbulentPrandtlNumber;
								}
							}

						}
						else if (!(bsolidS && bsolidP)) {
							Gn += fnplus*turblamS + (1.0 - fnplus)*turblamP;
						}

					}
					else {
						if (ptr[1][iP] != -1) {
							if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								doublereal cpn = prop_b[HEAT_CAPACITY][iN - maxelm];
								if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
									Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
									Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if(f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
									Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
									Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}								
							}
						}
					}
				}

				

				if (iT > -1) {
					if (!bT) {
						bool bsolidP = false, bsolidS = false;
						doublereal turblamS = 0.0, turblamP = 0.0;

						if (ptr[1][iT] == -1) {
							// принадлежит твёрдому телу
							turblamS = 0.0;
							bsolidS = true;
						}
						else {
							if ((f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								turblamS = prop[HEAT_CAPACITY][iT] * f[ptr[1][iT]].potent[MUT][ptr[0][iT]] / dTurbulentPrandtlNumber;
							}
						}

						if (ptr[1][iP] == -1) {
							// принадлежит твёрдому телу
							turblamP = 0.0;
							bsolidP = true;
						}
						else {
							if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
							}
						}

						if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
							doublereal cpt = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iT] / ((1.0 - ftplus)*prop[HEAT_CAPACITY][iP] + ftplus*prop[HEAT_CAPACITY][iT]);
							if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
								if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]>-1) {
									Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]>-1) {
									Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]>-1) {
									Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]>-1) {
									Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
							}
							else if ((bsolidP) && ((f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
								if (f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT]] > -1) {
									Gt += cpt*f[ptr[1][iT]].potent[MUT][f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT]] > -1) {
									Gt += cpt*f[ptr[1][iT]].potent[MUT][f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT]] > -1) {
									Gt += cpt*f[ptr[1][iT]].potent[MUT][f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT]] > -1) {
									Gt += cpt*f[ptr[1][iT]].potent[MUT][f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT]]] / dTurbulentPrandtlNumber;
								}								
							}
						}
						else if (!(bsolidS && bsolidP)) {
							Gt += ftplus*turblamS + (1.0 - ftplus)*turblamP;
						}

					}
					else {
						if (ptr[1][iP] != -1) {
							if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								doublereal cpt = prop_b[HEAT_CAPACITY][iT - maxelm];
								if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
									Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
									Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
									Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
									Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
							}
						}
					}
				}

				

				if (iW > -1) {
					if (!bW) {
						bool bsolidP = false, bsolidS = false;
						doublereal turblamS = 0.0, turblamP = 0.0;

						if (ptr[1][iW] == -1) {
							// принадлежит твёрдому телу
							turblamS = 0.0;
							bsolidS = true;
						}
						else {
							if ((f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								turblamS = prop[HEAT_CAPACITY][iW] * f[ptr[1][iW]].potent[MUT][ptr[0][iW]] / dTurbulentPrandtlNumber;
							}
						}

						if (ptr[1][iP] == -1) {
							// принадлежит твёрдому телу
							turblamP = 0.0;
							bsolidP = true;
						}
						else {
							if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
							}
						}

						if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
							doublereal cpw = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iW] / ((1.0 - fwplus)*prop[HEAT_CAPACITY][iP] + fwplus*prop[HEAT_CAPACITY][iW]);
							if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
								if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]>-1) {
									Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]>-1) {
									Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]>-1) {
									Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]>-1) {
									Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}								
							}
							else if ((bsolidP) && ((f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
								if (f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW]] > -1) {
									Gw += cpw*f[ptr[1][iW]].potent[MUT][f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW]] > -1) {
									Gw += cpw*f[ptr[1][iW]].potent[MUT][f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW]] > -1) {
									Gw += cpw*f[ptr[1][iW]].potent[MUT][f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW]] > -1) {
									Gw += cpw*f[ptr[1][iW]].potent[MUT][f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW]]] / dTurbulentPrandtlNumber;
								}								
							}
						}
						else if (!(bsolidS && bsolidP)) {
							Gw += fwplus*turblamS + (1.0 - fwplus)*turblamP;
						}

					}
					else {
						if (ptr[1][iP] != -1) {
							if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								doublereal cpw = prop_b[HEAT_CAPACITY][iW - maxelm];
								if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
									Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
									Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
									Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
									Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}								
							}
						}
					}
				}

				

				if (iS > -1) {
					if (!bS) {
						bool bsolidP = false, bsolidS = false;
						doublereal turblamS = 0.0, turblamP = 0.0;

						if (ptr[1][iS] == -1) {
							// принадлежит твёрдому телу
							turblamS = 0.0;
							bsolidS = true;
						}
						else {
							if ((f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								turblamS = prop[HEAT_CAPACITY][iS] * f[ptr[1][iS]].potent[MUT][ptr[0][iS]] / dTurbulentPrandtlNumber;
							}
						}

						if (ptr[1][iP] == -1) {
							// принадлежит твёрдому телу
							turblamP = 0.0;
							bsolidP = true;
						}
						else {
							if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
							}
						}

						if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
							doublereal cps = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iS] / ((1.0 - fsplus)*prop[HEAT_CAPACITY][iP] + fsplus*prop[HEAT_CAPACITY][iS]);
							if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
								if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]>-1) {
									Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]>-1) {
									Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]>-1) {
									Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]>-1) {
									Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
							}
							else if ((bsolidP) && ((f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
								if (f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS]]>-1) {
									Gs += cps*f[ptr[1][iS]].potent[MUT][f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS]]>-1) {
									Gs += cps*f[ptr[1][iS]].potent[MUT][f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS]]>-1) {
									Gs += cps*f[ptr[1][iS]].potent[MUT][f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS]]>-1) {
									Gs += cps*f[ptr[1][iS]].potent[MUT][f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS]]] / dTurbulentPrandtlNumber;
								}
							}

						}
						else if (!(bsolidS && bsolidP)) {
							Gs += fsplus*turblamS + (1.0 - fsplus)*turblamP;
						}

					}
					else {
						if (ptr[1][iP] != -1) {
							if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								doublereal cps = prop_b[HEAT_CAPACITY][iS - maxelm];
								if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]>-1) {
									Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]>-1) {
									Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]>-1) {
									Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]>-1) {
									Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								
							}
						}
					}
				}

				

				if (iB > -1) {
					if (!bB) {
						bool bsolidP = false, bsolidS = false;
						doublereal turblamS = 0.0, turblamP = 0.0;

						if (ptr[1][iB] == -1) {
							// принадлежит твёрдому телу
							turblamS = 0.0;
							bsolidS = true;
						}
						else {
							if ((f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
								(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								turblamS = prop[HEAT_CAPACITY][iB] * f[ptr[1][iB]].potent[MUT][ptr[0][iB]] / dTurbulentPrandtlNumber;
							}
						}

						if (ptr[1][iP] == -1) {
							// принадлежит твёрдому телу
							turblamP = 0.0;
							bsolidP = true;
						}
						else {
							if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
							}
						}

						if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
							doublereal cpb = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iB] / ((1.0 - fbplus)*prop[HEAT_CAPACITY][iP] + fbplus*prop[HEAT_CAPACITY][iB]);
							if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
								if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]>-1) {
									Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]>-1) {
									Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]>-1) {
									Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]>-1) {
									Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
							}
							else if ((bsolidP) && ((f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
								if (f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB]]>-1) {
									Gb += cpb*f[ptr[1][iB]].potent[MUT][f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB]]>-1) {
									Gb += cpb*f[ptr[1][iB]].potent[MUT][f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB]]>-1) {
									Gb += cpb*f[ptr[1][iB]].potent[MUT][f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB]]>-1) {
									Gb += cpb*f[ptr[1][iB]].potent[MUT][f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB]]] / dTurbulentPrandtlNumber;
								}								
							}
						}
						else if (!(bsolidS && bsolidP)) {
							Gb += fbplus*turblamS + (1.0 - fbplus)*turblamP;
						}

					}
					else {
						if (ptr[1][iP] != -1) {
							if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) || 
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
								(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
								doublereal cpb = prop_b[HEAT_CAPACITY][iB - maxelm];
								if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]>-1) {
									Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]>-1) {
									Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]>-1) {
									Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}
								else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]>-1) {
									Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
								}								
							}
						}
					}
				}

				
            }
		}
	}  // Турбулентная теплопроводность.
	
	
	if (!b_on_adaptive_local_refinement_mesh) {
		// Это не помогло не капли.
		// Здесь я просто хотел чтобы навнутренней грани источника тепла 
		// теплопроводность была одинаковой с обоих сторон и в граничной сборке
		// и для сборки во внутренности расчётной области.
		if (bsT1) {
			Gt = conductivity2Dinsource[iT - maxelm];
			Gt *= prop[MULT_LAM_Z][iP];
		}
		if (bsB1) {
			Gb = conductivity2Dinsource[iB - maxelm];
			Gb *= prop[MULT_LAM_Z][iP];
		}
		if (bsN1) {
			Gn = conductivity2Dinsource[iN - maxelm];
			Gn *= prop[MULT_LAM_Y][iP];
		}
		if (bsS1) {
			Gs = conductivity2Dinsource[iS - maxelm];
			Gs *= prop[MULT_LAM_Y][iP];
		}
		if (bsE1) {
			Ge = conductivity2Dinsource[iE - maxelm];
			Ge *= prop[MULT_LAM_X][iP];
		}
		if (bsW1) {
			Gw = conductivity2Dinsource[iW - maxelm];
			Gw *= prop[MULT_LAM_X][iP];
		}

	}

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	// Поверка коэффициента диффузии.
	if (Ge != Ge) {
		std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
		printf("Ge=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ge);
		system("pause");
	}
	if (Gw != Gw) {
		std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
		printf("Gw=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gw);
		system("pause");
	}
	if (Gn != Gn) {
		std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
		printf("Gn=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gn);
		system("pause");
	}
	if (Gs != Gs) {
		std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
		printf("Gs=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gs);
		system("pause");
	}
	if (Gt != Gt) {
		std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
		printf("Gt=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gt);
		system("pause");
	}
	if (Gb != Gb) {
		std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
		printf("Gb=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gb);
		system("pause");
	}

	if (b_on_adaptive_local_refinement_mesh) {

		if (Ge2 != Ge2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Ge2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ge2);
			system("pause");
		}
		if (Gw2 != Gw2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gw2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gw2);
			system("pause");
		}
		if (Gn2 != Gn2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gn2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gn2);
			system("pause");
		}
		if (Gs2 != Gs2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gs2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gs2);
			system("pause");
		}
		if (Gt2 != Gt2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gt2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gt2);
			system("pause");
		}
		if (Gb2 != Gb2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gb2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gb2);
			system("pause");
		}
		if (Ge3 != Ge3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Ge3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ge3);
			system("pause");
		}
		if (Gw3 != Gw3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gw3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gw3);
			system("pause");
		}
		if (Gn3 != Gn3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gn3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gn3);
			system("pause");
		}
		if (Gs3 != Gs3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gs3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gs3);
			system("pause");
		}
		if (Gt3 != Gt3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gt3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gt3);
			system("pause");
		}
		if (Gb3 != Gb3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gb3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gb3);
			system("pause");
		}
		if (Ge4 != Ge4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Ge4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ge4);
			system("pause");
		}
		if (Gw4 != Gw4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gw4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gw4);
			system("pause");
		}
		if (Gn4 != Gn4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gn4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gn4);
			system("pause");
		}
		if (Gs4 != Gs4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gs4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gs4);
			system("pause");
		}
		if (Gt4 != Gt4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gt4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gt4);
			system("pause");
		}
		if (Gb4 != Gb4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gb4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gb4);
			system("pause");
		}
	}
#endif

	// после.
	// контроль коэффициента теплопроводности:
	//printf("Ge=%e, Gw=%e, Gn=%e, Gs=%e, Gt=%e, Gb=%e\n",Ge,Gw,Gn,Gs,Gt,Gb);
	//getchar();

	// Диффузионная составляющая потока:
	// Если источник лежит на границе расчётной области, 
	// то порядок аппроксимации на границе можно повысить с помощью 
	// задания коэффициента beta отличного от единицы.
	doublereal De=1.0, Dw=1.0, Dn=1.0, Ds=1.0, Dt=1.0, Db=1.0;
	
	if (!bE) {
		if (bW) De=dbeta*Ge*dy*dz/dxe;
		else De=Ge*dy*dz/dxe;
	} else De=dbeta*Ge*dy*dz/dxe;

	if (!bW) {
		if (bE) Dw=dbeta*Gw*dy*dz/dxw;
		else Dw=Gw*dy*dz/dxw;
	} else Dw=dbeta*Gw*dy*dz/dxw;


	if (!bN) {
		if (bS) Dn=dbeta*Gn*dx*dz/dyn;
		else Dn=Gn*dx*dz/dyn;
	} else Dn=dbeta*Gn*dx*dz/dyn;

	
	if (!bS) {
		if (bN) Ds=dbeta*Gs*dx*dz/dys;
		else Ds=Gs*dx*dz/dys;
	} else Ds=dbeta*Gs*dx*dz/dys; 

	if (!bT) {
		if (bB) Dt=dbeta*Gt*dx*dy/dzt; 
		else Dt=Gt*dx*dy/dzt;
	} else Dt=dbeta*Gt*dx*dy/dzt;

	if (!bB) {
		if (bT) Db=dbeta*Gb*dx*dy/dzb;
		else Db=Gb*dx*dy/dzb;
	} else Db=dbeta*Gb*dx*dy/dzb;

	doublereal baddDFLUX2=0.0;
	// Этот более высокий порядок аппроксимации вызывает осцилляции с шагом сетки.
	bool bhighorder=false; // включает или выключает добавок увеличивающий порядок точности.
	
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (!b_on_adaptive_local_refinement_mesh) {
		if (De <= 0.0) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error negative or zero De=%e\n", De);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Dn <= 0.0) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error negative or zero Dn=%e\n", Dn);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Dt <= 0.0) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error negative or zero Dt=%e\n", Dt);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Dw <= 0.0) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error negative or zero Dw=%e\n", Dw);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Ds <= 0.0) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error negative or zero Ds=%e\n", Ds);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Db <= 0.0) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error negative or zero Db=%e\n", Db);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}

		if (De != De) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error  De=%e is NAN or INF\n", De);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Dw != Dw) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error  Dw=%e is NAN or INF\n", Dw);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Dn != Dn) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error  Dn=%e is NAN or INF\n", Dn);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Ds != Ds) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error  Ds=%e is NAN or INF\n", Ds);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Dt != Dt) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error  Dt=%e is NAN or INF\n", Dt);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Db != Db) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error  Db=%e is NAN or INF\n", Db);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
	}
#endif

	// Числа Пекле:
	doublereal Pe=0.0, Pw=0.0, Pn=0.0, Ps=0.0, Pt=0.0, Pb=0.0;

	if (!b_on_adaptive_local_refinement_mesh) {
		// Внимание!!! Вычисление чисел Пекле здесь годится только для
		// структурированной сетки. Для АЛИС см. реализацию ниже где
		// правильно учитывается домножение на площадь.

		Pe = Fe / De;
		Pw = -Fw / Dw;
		Pn = Fn / Dn;
		Ps = -Fs / Ds;
		Pt = Ft / Dt;
		Pb = -Fb / Db;

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
		if (Pe != Pe) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error  Pe=%e is NAN or INF\n", Pe);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Pw != Pw) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error  Pw=%e is NAN or INF\n", Pw);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Pn != Pn) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error  Pn=%e is NAN or INF\n", Pn);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Ps != Ps) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error  Ps=%e is NAN or INF\n", Ps);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Pt != Pt) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error  Pt=%e is NAN or INF\n", Pt);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (Pb != Pb) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Error  Pb=%e is NAN or INF\n", Pb);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
#endif
	}

	// Добавка в правую часть при использовании схемы Леонарда QUICK
	// в силу использования метода отложенной коррекции.
	// addition to the right side QUICK Leonard.
	doublereal attrs=0.0;

	// Коэффициенты диффузии. 
	doublereal De2 = 0.0, Dw2 = 0.0, Dn2 = 0.0, Ds2 = 0.0, Dt2 = 0.0, Db2 = 0.0;
	doublereal De3 = 0.0, Dw3 = 0.0, Dn3 = 0.0, Ds3 = 0.0, Dt3 = 0.0, Db3 = 0.0;
	doublereal De4 = 0.0, Dw4 = 0.0, Dn4 = 0.0, Ds4 = 0.0, Dt4 = 0.0, Db4 = 0.0;

	// Числа Пекле.
	doublereal Pe2 = 0.0, Pw2 = 0.0, Pn2 = 0.0, Ps2 = 0.0, Pt2 = 0.0, Pb2 = 0.0;
	doublereal Pe3 = 0.0, Pw3 = 0.0, Pn3 = 0.0, Ps3 = 0.0, Pt3 = 0.0, Pb3 = 0.0;
	doublereal Pe4 = 0.0, Pw4 = 0.0, Pn4 = 0.0, Ps4 = 0.0, Pt4 = 0.0, Pb4 = 0.0;


	if (b_on_adaptive_local_refinement_mesh) {

		if (iE > -1) {
			if (bE) {
				De = Ge * border_neighbor[iE - maxelm].dS / dxe;
				Fe1 *= border_neighbor[iE - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iE]) {
					De = Ge * dy * dz / dxe;
					Fe1 *= dy * dz;
				}
				else if (ilevel_alice[iE] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iE, nvtx, pa, dx_loc, dy_loc, dz_loc);

					De = Ge * dy_loc * dz_loc / dxe;
					Fe1 *= dy_loc * dz_loc;
				}
				else {
					De = Ge * dy * dz / dxe;
					Fe1 *= dy * dz;
				}

			Pe = (Fe1) / (De);
		}

		if (iE2 > -1) {
			if (bE2) {
				De2 = Ge2 * border_neighbor[iE2 - maxelm].dS / dxe2;
				Fe2 *= border_neighbor[iE2 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iE2]) {
					De2 = Ge2 * dy * dz / dxe2;
					Fe2 *= dy * dz;
				}
				else if (ilevel_alice[iE2] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iE2, nvtx, pa, dx_loc, dy_loc, dz_loc);

					De2 = Ge2 * dy_loc * dz_loc / dxe2;
					Fe2 *= dy_loc * dz_loc;
				}
				else {
					De2 = Ge2 * dy * dz / dxe2;
					Fe2 *= dy * dz;
				}

			Pe2 = (Fe2) / (De2);
		}


		if (iE3 > -1) {
			if (bE3) {
				De3 = Ge3 * border_neighbor[iE3 - maxelm].dS / dxe3;
				Fe3 *= border_neighbor[iE3 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iE3]) {
					De3 = Ge3 * dy * dz / dxe3;
					Fe3 *= dy * dz;
				}
				else if (ilevel_alice[iE3] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iE3, nvtx, pa, dx_loc, dy_loc, dz_loc);

					De3 = Ge3 * dy_loc * dz_loc / dxe3;
					Fe3 *= dy_loc * dz_loc;
				}
				else {
					De3 = Ge3 * dy * dz / dxe3;
					Fe3 *= dy * dz;
				}

			Pe3 = (Fe3) / (De3);
		}

		if (iE4 > -1) {
			if (bE4) {
				De4 = Ge4 * border_neighbor[iE4 - maxelm].dS / dxe4;
				Fe4 *= border_neighbor[iE4 - maxelm].dS;

			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iE4]) {
					De4 = Ge4 * dy * dz / dxe4;
					Fe4 *= dy * dz;

				}
				else if (ilevel_alice[iE4] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iE4, nvtx, pa, dx_loc, dy_loc, dz_loc);

					De4 = Ge4 * dy_loc * dz_loc / dxe4;
					Fe4 *= dy_loc * dz_loc;
				}
				else {
					De4 = Ge4 * dy * dz / dxe4;
					Fe4 *= dy * dz;
				}

			Pe4 = (Fe4) / (De4);
		}

		if (iW > -1) {
			if (bW) {
				Dw = Gw * border_neighbor[iW - maxelm].dS / dxw;
				Fw1 *= border_neighbor[iW - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iW]) {
					Dw = Gw * dy * dz / dxw;
					Fw1 *= dy * dz;
				}
				else if (ilevel_alice[iW] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iW, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Dw = Gw * dy_loc * dz_loc / dxw;
					Fw1 *= dy_loc * dz_loc;
				}
				else {
					Dw = Gw * dy * dz / dxw;
					Fw1 *= dy * dz;
				}

			Pw = (Fw1) / (Dw);
		}

		if (iW2 > -1) {
			if (bW2) {
				Dw2 = Gw2 * border_neighbor[iW2 - maxelm].dS / dxw2;
				Fw2 *= border_neighbor[iW2 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iW2]) {
					Dw2 = Gw2 * dy * dz / dxw2;
					Fw2 *= dy * dz;
				}
				else if (ilevel_alice[iW2] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iW2, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Dw2 = Gw2 * dy_loc * dz_loc / dxw2;
					Fw2 *= dy_loc * dz_loc;
				}
				else {
					Dw2 = Gw2 * dy * dz / dxw2;
					Fw2 *= dy * dz;
				}

			Pw2 = (Fw2) / (Dw2);
		}

		if (iW3 > -1) {
			if (bW3) {
				Dw3 = Gw3 * border_neighbor[iW3 - maxelm].dS / dxw3;

				Fw3 *= border_neighbor[iW3 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iW3]) {
					Dw3 = Gw3 * dy * dz / dxw3;
					Fw3 *= dy * dz;
				}
				else if (ilevel_alice[iW3] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iW3, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Dw3 = Gw3 * dy_loc * dz_loc / dxw3;
					Fw3 *= dy_loc * dz_loc;
				}
				else {
					Dw3 = Gw3 * dy * dz / dxw3;
					Fw3 *= dy * dz;
				}

			Pw3 = (Fw3) / (Dw3);
		}

		if (iW4 > -1) {
			if (bW4) {
				Dw4 = Gw4 * border_neighbor[iW4 - maxelm].dS / dxw4;
				Fw4 *= border_neighbor[iW4 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iW4]) {
					Dw4 = Gw4 * dy * dz / dxw4;
					Fw4 *= dy * dz;
				}
				else if (ilevel_alice[iW4] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iW4, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Dw4 = Gw4 * dy_loc * dz_loc / dxw4;
					Fw4 *= dy_loc * dz_loc;
				}
				else {
					Dw4 = Gw4 * dy * dz / dxw4;
					Fw4 *= dy * dz;
				}

			Pw4 = (Fw4) / (Dw4);
		}


		if (iN > -1) {
			if (bN) {
				Dn = Gn * border_neighbor[iN - maxelm].dS / dyn;
				Fn1 *= border_neighbor[iN - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iN]) {
					Dn = Gn * dx * dz / dyn;
					Fn1 *= dx * dz;
				}
				else if (ilevel_alice[iN] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iN, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Dn = Gn * dx_loc * dz_loc / dyn;
					Fn1 *= dx_loc * dz_loc;
				}
				else {
					Dn = Gn * dx * dz / dyn;
					Fn1 *= dx * dz;
				}

			Pn = (Fn1) / (Dn);
		}


		if (iN2 > -1) {
			if (bN2) {
				Dn2 = Gn2 * border_neighbor[iN2 - maxelm].dS / dyn2;
				Fn2 *= border_neighbor[iN2 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iN2]) {
					Dn2 = Gn2 * dx * dz / dyn2;
					Fn2 *= dx * dz;
				}
				else if (ilevel_alice[iN2] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iN2, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Dn2 = Gn2 * dx_loc * dz_loc / dyn2;
					Fn2 *= dx_loc * dz_loc;
				}
				else {
					Dn2 = Gn2 * dx * dz / dyn2;
					Fn2 *= dx * dz;
				}

			Pn2 = (Fn2) / (Dn2);
		}

		if (iN3 > -1) {
			if (bN3) {
				Dn3 = Gn3 * border_neighbor[iN3 - maxelm].dS / dyn3;
				Fn3 *= border_neighbor[iN3 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iN3]) {
					Dn3 = Gn3 * dx * dz / dyn3;
					Fn3 *= dx * dz;
				}
				else if (ilevel_alice[iN3] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iN3, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Dn3 = Gn3 * dx_loc * dz_loc / dyn3;
					Fn3 *= dx_loc * dz_loc;
				}
				else {
					Dn3 = Gn3 * dx * dz / dyn3;
					Fn3 *= dx * dz;
				}

			Pn3 = (Fn3) / (Dn3);
		}

		if (iN4 > -1) {
			if (bN4) {
				Dn4 = Gn4 * border_neighbor[iN4 - maxelm].dS / dyn4;
				Fn4 *= border_neighbor[iN4 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iN4]) {
					Dn4 = Gn4 * dx * dz / dyn4;
					Fn4 *= dx * dz;
				}
				else if (ilevel_alice[iN4] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iN4, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Dn4 = Gn4 * dx_loc * dz_loc / dyn4;
					Fn4 *= dx_loc * dz_loc;
				}
				else {
					Dn4 = Gn4 * dx * dz / dyn4;
					Fn4 *= dx * dz;
				}

			Pn4 = (Fn4) / (Dn4);
		}

		if (iS > -1) {
			if (bS) {
				Ds = Gs * border_neighbor[iS - maxelm].dS / dys;
				Fs1 *= border_neighbor[iS - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iS]) {
					Ds = Gs * dx * dz / dys;
					Fs1 *= dx * dz;
				}
				else if (ilevel_alice[iS] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iS, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Ds = Gs * dx_loc * dz_loc / dys;
					Fs1 *= dx_loc * dz_loc;
				}
				else {
					Ds = Gs * dx * dz / dys;
					Fs1 *= dx * dz;
				}

			Ps = (Fs1) / (Ds);

		}

		if (iS2 > -1) {
			if (bS2) {
				Ds2 = Gs2 * border_neighbor[iS2 - maxelm].dS / dys2;
				Fs2 *= border_neighbor[iS2 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iS2]) {
					Ds2 = Gs2 * dx * dz / dys2;
					Fs2 *= dx * dz;
				}
				else if (ilevel_alice[iS2] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iS2, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Ds2 = Gs2 * dx_loc * dz_loc / dys2;
					Fs2 *= dx_loc * dz_loc;
				}
				else {
					Ds2 = Gs2 * dx * dz / dys2;
					Fs2 *= dx * dz;
				}

			Ps2 = (Fs2) / (Ds2);
		}


		if (iS3 > -1) {
			if (bS3) {
				Ds3 = Gs3 * border_neighbor[iS3 - maxelm].dS / dys3;
				Fs3 *= border_neighbor[iS3 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iS3]) {
					Ds3 = Gs3 * dx * dz / dys3;
					Fs3 *= dx * dz;
				}
				else if (ilevel_alice[iS3] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iS3, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Ds3 = Gs3 * dx_loc * dz_loc / dys3;
					Fs3 *= dx_loc * dz_loc;
				}
				else {
					Ds3 = Gs3 * dx * dz / dys3;
					Fs3 *= dx * dz;
				}

			Ps3 = (Fs3) / (Ds3);
		}


		if (iS4 > -1) {
			if (bS4) {
				Ds4 = Gs4 * border_neighbor[iS4 - maxelm].dS / dys4;
				Fs4 *= border_neighbor[iS4 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iS4]) {
					Ds4 = Gs4 * dx * dz / dys4;
					Fs4 *= dx * dz;
				}
				else if (ilevel_alice[iS4] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iS4, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Ds4 = Gs4 * dx_loc * dz_loc / dys4;
					Fs4 *= dx_loc * dz_loc;
				}
				else {
					Ds4 = Gs4 * dx * dz / dys4;
					Fs4 *= dx * dz;
				}

			Ps4 = (Fs4) / (Ds4);
		}


		if (iT > -1) {
			if (bT) {
				Dt = Gt * border_neighbor[iT - maxelm].dS / dzt;
				Ft1 *= border_neighbor[iT - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iT]) {
					Dt = Gt * dx * dy / dzt;
					Ft1 *= dx * dy;
				}
				else if (ilevel_alice[iT] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iT, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Dt = Gt * dx_loc * dy_loc / dzt;
					Ft1 *= dx_loc * dy_loc;
				}
				else {
					Dt = Gt * dx * dy / dzt;
					Ft1 *= dx * dy;
				}

			Pt = (Ft1) / (Dt);
		}

		if (iT2 > -1) {
			if (bT2) {
				Dt2 = Gt2 * border_neighbor[iT2 - maxelm].dS / dzt2;
				Ft2 *= border_neighbor[iT2 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iT2]) {
					Dt2 = Gt2 * dx * dy / dzt2;
					Ft2 *= dx * dy;
				}
				else if (ilevel_alice[iT2] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iT2, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Dt2 = Gt2 * dx_loc * dy_loc / dzt2;
					Ft2 *= dx_loc * dy_loc;
				}
				else {
					Dt2 = Gt2 * dx * dy / dzt2;
					Ft2 *= dx * dy;
				}

			Pt2 = (Ft2) / (Dt2);
		}
		if (iT3 > -1) {
			if (bT3) {
				Dt3 = Gt3 * border_neighbor[iT3 - maxelm].dS / dzt3;
				Ft3 *= border_neighbor[iT3 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iT3]) {
					Dt3 = Gt3 * dx * dy / dzt3;
					Ft3 *= dx * dy;
				}
				else if (ilevel_alice[iT3] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iT3, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Dt3 = Gt3 * dx_loc * dy_loc / dzt3;
					Ft3 *= dx_loc * dy_loc;
				}
				else {
					Dt3 = Gt3 * dx * dy / dzt3;
					Ft3 *= dx * dy;
				}
			Pt3 = (Ft3) / (Dt3);
		}
		if (iT4 > -1) {
			if (bT4) {
				Dt4 = Gt4 * border_neighbor[iT4 - maxelm].dS / dzt4;
				Ft4 *= border_neighbor[iT4 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iT4]) {
					Dt4 = Gt4 * dx * dy / dzt4;
					Ft4 *= dx * dy;
				}
				else if (ilevel_alice[iT4] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iT4, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Dt4 = Gt4 * dx_loc * dy_loc / dzt4;
					Ft4 *= dx_loc * dy_loc;
				}
				else {
					Dt4 = Gt4 * dx * dy / dzt4;
					Ft4 *= dx * dy;
				}

			Pt4 = (Ft4) / (Dt4);
		}


		if (iB > -1) {
			if (bB) {
				Db = Gb * border_neighbor[iB - maxelm].dS / dzb;
				Fb1 *= border_neighbor[iB - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iB]) {
					Db = Gb * dx * dy / dzb;
					Fb1 *= dx * dy;
				}
				else if (ilevel_alice[iB] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iB, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Db = Gb * dx_loc * dy_loc / dzb;
					Fb1 *= dx_loc * dy_loc;
				}
				else {
					Db = Gb * dx * dy / dzb;
					Fb1 *= dx * dy;
				}

			Pb = (Fb1) / (Db);
		}

		if (iB2 > -1) {
			if (bB2) {
				Db2 = Gb2 * border_neighbor[iB2 - maxelm].dS / dzb2;
				Fb2 *= border_neighbor[iB2 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iB2]) {
					Db2 = Gb2 * dx * dy / dzb2;
					Fb2 *= dx * dy;
				}
				else if (ilevel_alice[iB2] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iB2, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Db2 = Gb2 * dx_loc * dy_loc / dzb2;
					Fb2 *= dx_loc * dy_loc;
				}
				else {
					Db2 = Gb2 * dx * dy / dzb2;
					Fb2 *= dx * dy;
				}

			Pb2 = (Fb2) / (Db2);
		}

		if (iB3 > -1) {
			if (bB3) {
				Db3 = Gb3 * border_neighbor[iB3 - maxelm].dS / dzb3;
				Fb3 *= border_neighbor[iB3 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iB3]) {
					Db3 = Gb3 * dx * dy / dzb3;
					Fb3 *= dx * dy;
				}
				else if (ilevel_alice[iB3] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iB3, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Db3 = Gb3 * dx_loc * dy_loc / dzb3;
					Fb3 *= dx_loc * dy_loc;
				}
				else {
					Db3 = Gb3 * dx * dy / dzb3;
					Fb3 *= dx * dy;
				}

			Pb3 = (Fb3) / (Db3);
		}

		if (iB4 > -1) {
			if (bB4) {
				Db4 = Gb4 * border_neighbor[iB4 - maxelm].dS / dzb4;
				Fb4 *= border_neighbor[iB4 - maxelm].dS;
			}
			else
				if (ilevel_alice[iP] == ilevel_alice[iB4]) {
					Db4 = Gb4 * dx * dy / dzb4;
					Fb4 *= dx * dy;
				}
				else if (ilevel_alice[iB4] > ilevel_alice[iP]) {
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iB4, nvtx, pa, dx_loc, dy_loc, dz_loc);

					Db4 = Gb4 * dx_loc * dy_loc / dzb4;
					Fb4 *= dx_loc * dy_loc;
				}
				else {
					Db4 = Gb4 * dx * dy / dzb4;
					Fb4 *= dx * dy;
				}
			Pb4 = (Fb4) / (Db4);
		}
	}


	// Инициализирующее обнуление.
	sl[iP].ae = 0.0;
	sl[iP].aw = 0.0;
	sl[iP].an = 0.0;
	sl[iP].as = 0.0;
	sl[iP].at = 0.0;
	sl[iP].ab = 0.0;

	sl[iP].ae2 = 0.0;
	sl[iP].aw2 = 0.0;
	sl[iP].an2 = 0.0;
	sl[iP].as2 = 0.0;
	sl[iP].at2 = 0.0;
	sl[iP].ab2 = 0.0;

	sl[iP].ae3 = 0.0;
	sl[iP].aw3 = 0.0;
	sl[iP].an3 = 0.0;
	sl[iP].as3 = 0.0;
	sl[iP].at3 = 0.0;
	sl[iP].ab3 = 0.0;

	sl[iP].ae4 = 0.0;
	sl[iP].aw4 = 0.0;
	sl[iP].an4 = 0.0;
	sl[iP].as4 = 0.0;
	sl[iP].at4 = 0.0;
	sl[iP].ab4 = 0.0;

	if ((b_on_adaptive_local_refinement_mesh)&&(( !(bconvective))||((bconvective)&&(ishconvection < distsheme)))) {

		

		
		// Ещё надо предусмотреть случаи iE2, iE3, iE4.
		// А потом тоже самое для граней WSIDE, S, N, B, T.

		// На каждой грани все коэффициенты диффузии участвующие в дискретизации
		// равны одному и тому-же среднему арифметическому значению.
		// Одинаковый коэффициент диффузии на грани.
		// Но никто не отменял что у разных фейсов разные площади.
		//AVERAGE_DIFFUSION(iE, iE2, iE3, iE4, Ge, Ge2, Ge3, Ge4);
		//AVERAGE_DIFFUSION(iW, iW2, iW3, iW4, Gw, Gw2, Gw3, Gw4);
		//AVERAGE_DIFFUSION(iN, iN2, iN3, iN4, Gn, Gn2, Gn3, Gn4);
		//AVERAGE_DIFFUSION(iS, iS2, iS3, iS4, Gs, Gs2, Gs3, Gs4);
		//AVERAGE_DIFFUSION(iT, iT2, iT3, iT4, Gt, Gt2, Gt3, Gt4);
		//AVERAGE_DIFFUSION(iB, iB2, iB3, iB4, Gb, Gb2, Gb3, Gb4);


		// Неортогональная коррекция. 
		// Начало разработки 1 июля 2017.
		// С включенной неортогональной коррекцией на АЛИС сетке 
		// полученной по fine сетке для задачи
		// Максимова Анатолия Нестеровича наблюдалась расходимость.
		// С включенной неортогональной коррекцией на  АЛИС на базе
		// coarse сетке наблюдалась сходимость, 
		// но решение было найдено с 7% погрешностью. 
		const bool bcorrection_ALICE = false;

		

		// Сборка матрицы на АЛИС сетке:
		if (iE > -1) {
			if (bE) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ae += (De)*ApproxConvective(fabs(Pe), ishconvection) + fmax(-Fe1, 0); 
						//printf("popal Fe1=%e\n",Fe1); getchar();
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe1.1.\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].ae += Ge*border_neighbor[iE - maxelm].dS / dxe;
				}

			}
			else {
				// iE внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iE]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae += (De)*ApproxConvective(fabs(Pe), ishconvection) + fmax(-Fe1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe1.2.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ae += Ge*dy*dz / dxe;
					}
				}
				else if (ilevel_alice[iE] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iE, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae += (De)*ApproxConvective(fabs(Pe), ishconvection) + fmax(-Fe1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe1.3.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ae += Ge*dy_loc*dz_loc / dxe;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge*dy_loc*dz_loc / dxe)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z));
					}


				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iE).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae += (De)*ApproxConvective(fabs(Pe), ishconvection) + fmax(-Fe1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe1.4.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ae += Ge*dy*dz / dxe;
					}
					
					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge*dy*dz / dxe)*(potent[iE] - mnk(iE, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z));
					}
				}
			}
		}

		if (iE2 > -1) {
			if (bE2) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ae2 += (Ge2*border_neighbor[iE2 - maxelm].dS / dxe2)*ApproxConvective(fabs((Fe2)/(Ge2*border_neighbor[iE2 - maxelm].dS / dxe2)), ishconvection) + fmax(-Fe2, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe2.1.\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].ae2 += Ge2*border_neighbor[iE2 - maxelm].dS / dxe2;
				}
			}
			else {
				// iE2 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iE2]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae2 += (Ge2*dy*dz / dxe2)*ApproxConvective(fabs((Fe2)/(Ge2*dy*dz / dxe2)), ishconvection) + fmax(-Fe2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe2.2.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ae2 += Ge2*dy*dz / dxe2;
					}
				}
				else if (ilevel_alice[iE2] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iE2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae2 += (Ge2*dy_loc*dz_loc / dxe2)*ApproxConvective(fabs((Fe2)/(Ge2*dy_loc*dz_loc / dxe2)), ishconvection) + fmax(-Fe2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe2.3.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ae2 += Ge2*dy_loc*dz_loc / dxe2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge2*dy_loc*dz_loc / dxe2)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z));
					}


				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iE2).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae2 += (Ge2*dy*dz / dxe2)*ApproxConvective(fabs((Fe2)/(Ge2*dy*dz / dxe2)), ishconvection) + fmax(-Fe2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe2.4.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ae2 += Ge2*dy*dz / dxe2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge2*dy*dz / dxe2)*(potent[iE2] - mnk(iE2, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z));
					}
				}
			}
		}

		if (iE3 > -1) {
			if (bE3) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ae3 += (Ge3*border_neighbor[iE3 - maxelm].dS / dxe3)*ApproxConvective(fabs((Fe3)/(Ge3*border_neighbor[iE3 - maxelm].dS / dxe3)), ishconvection) + fmax(-Fe3, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe3.1.\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].ae3 += Ge3*border_neighbor[iE3 - maxelm].dS / dxe3;
				}
			}
			else {
				// iE3 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iE3]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae3 += (Ge3*dy*dz / dxe3)*ApproxConvective(fabs((Fe3)/(Ge3*dy*dz / dxe3)), ishconvection) + fmax(-Fe3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe3.2.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ae3 += Ge3*dy*dz / dxe3;
					}
				}
				else if (ilevel_alice[iE3] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iE3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae3 += (Ge3*dy_loc*dz_loc / dxe3)*ApproxConvective(fabs((Fe3)/(Ge3*dy_loc*dz_loc / dxe3)), ishconvection) + fmax(-Fe3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe3.3.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ae3 += Ge3*dy_loc*dz_loc / dxe3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge3*dy_loc*dz_loc / dxe3)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iE3).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae3 += (Ge3*dy*dz / dxe3)*ApproxConvective(fabs((Fe3)/(Ge3*dy*dz / dxe3)), ishconvection) + fmax(-Fe3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh.Fe3.4.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ae3 += Ge3*dy*dz / dxe3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge3*dy*dz / dxe3)*(potent[iE3] - mnk(iE3, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z));
					}

				}
			}
		}

		if (iE4 > -1) {
			if (bE4) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ae4 += (Ge4*border_neighbor[iE4 - maxelm].dS / dxe4)*ApproxConvective(fabs((Fe4)/(Ge4*border_neighbor[iE4 - maxelm].dS / dxe4)), ishconvection) + fmax(-Fe4, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe4.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].ae4 += Ge4*border_neighbor[iE4 - maxelm].dS / dxe4;
				}
			}
			else {
				// iE4 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iE4]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae4 += (Ge4*dy*dz / dxe4)*ApproxConvective(fabs((Fe4)/(Ge4*dy*dz / dxe4)), ishconvection) + fmax(-Fe4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe4.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ae4 += Ge4*dy*dz / dxe4;
					}
				}
				else if (ilevel_alice[iE4] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iE4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae4 += (Ge4*dy_loc*dz_loc / dxe4)*ApproxConvective(fabs((Fe4)/(Ge4*dy_loc*dz_loc / dxe4)), ishconvection) + fmax(-Fe4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe4.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ae4 += Ge4*dy_loc*dz_loc / dxe4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge4*dy_loc*dz_loc / dxe4)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iE).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae4 += (Ge4*dy*dz / dxe4)*ApproxConvective(fabs((Fe4)/(Ge4*dy*dz / dxe4)), ishconvection) + fmax(-Fe4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fe4.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ae4 += Ge4*dy*dz / dxe4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge4*dy*dz / dxe4)*(potent[iE4] - mnk(iE4, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z));
					}
				}
			}
		}

		// Грань Е завершена.

		if (iW > -1) {
			if (bW) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].aw += (Gw*border_neighbor[iW - maxelm].dS / dxw)*ApproxConvective(fabs((Fw1)/(Gw*border_neighbor[iW - maxelm].dS / dxw)), ishconvection) + fmax(Fw1, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw1.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].aw += Gw*border_neighbor[iW - maxelm].dS / dxw;
				}
			}
			else {
				// iW внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iW]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw += (Gw*dy*dz / dxw)*ApproxConvective(fabs((Fw1)/(Gw*dy*dz / dxw)), ishconvection) + fmax(Fw1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw1.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].aw += Gw*dy*dz / dxw;
					}
				}
				else if (ilevel_alice[iW] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iW, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw += (Gw*dy_loc*dz_loc / dxw)*ApproxConvective(fabs((Fw1)/(Gw*dy_loc*dz_loc / dxw)), ishconvection) + fmax(Fw1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw1.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].aw += Gw*dy_loc*dz_loc / dxw;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw*dy_loc*dz_loc / dxw)*( mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iW).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw += (Gw*dy*dz / dxw)*ApproxConvective(fabs((Fw1)/(Gw*dy*dz / dxw)), ishconvection) + fmax(Fw1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw1.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].aw += Gw*dy*dz / dxw;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw*dy*dz / dxw)*( mnk(iW, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z)- potent[iW] );
					}

				}
			}
		}

		if (iW2 > -1) {
			if (bW2) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].aw2 += (Gw2*border_neighbor[iW2 - maxelm].dS / dxw2)*ApproxConvective(fabs((Fw2)/(Gw2*border_neighbor[iW2 - maxelm].dS / dxw2)), ishconvection) + fmax(Fw2, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw2.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].aw2 += Gw2*border_neighbor[iW2 - maxelm].dS / dxw2;
				}
			}
			else {
				// iW2 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iW2]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw2 += (Gw2*dy*dz / dxw2)*ApproxConvective(fabs((Fw2)/(Gw2*dy*dz / dxw2)), ishconvection) + fmax(Fw2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw2.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].aw2 += Gw2*dy*dz / dxw2;
					}
				}
				else if (ilevel_alice[iW2] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iW2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw2 += (Gw2*dy_loc*dz_loc / dxw2)*ApproxConvective(fabs((Fw2)/(Gw2*dy_loc*dz_loc / dxw2)), ishconvection) + fmax(Fw2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw2.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].aw2 += Gw2*dy_loc*dz_loc / dxw2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw2*dy_loc*dz_loc / dxw2)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iW2).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw2 += (Gw2*dy*dz / dxw2)*ApproxConvective(fabs((Fw2)/(Gw2*dy*dz / dxw2)), ishconvection) + fmax(Fw2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw2.4.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].aw2 += Gw2*dy*dz / dxw2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw2*dy*dz / dxw2)*(mnk(iW2, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z) - potent[iW2]);
					}
				}
			}
		}

		if (iW3 > -1) {
			if (bW3) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].aw3 += (Gw3*border_neighbor[iW3 - maxelm].dS / dxw3)*ApproxConvective(fabs((Fw3)/(Gw3*border_neighbor[iW3 - maxelm].dS / dxw3)), ishconvection) + fmax(Fw3, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw3.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].aw3 += Gw3*border_neighbor[iW3 - maxelm].dS / dxw3;
				}
			}
			else {
				// iW3 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iW3]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw3 += (Gw3*dy*dz / dxw3)*ApproxConvective(fabs((Fw3)/(Gw3*dy*dz / dxw3)), ishconvection) + fmax(Fw3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw3.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].aw3 += Gw3*dy*dz / dxw3;
					}
				}
				else if (ilevel_alice[iW3] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iW3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw3 += (Gw3*dy_loc*dz_loc / dxw3)*ApproxConvective(fabs((Fw3)/(Gw3*dy_loc*dz_loc / dxw3)), ishconvection) + fmax(Fw3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw3.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].aw3 += Gw3*dy_loc*dz_loc / dxw3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw3*dy_loc*dz_loc / dxw3)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iW).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw3 += (Gw3*dy*dz / dxw3)*ApproxConvective(fabs((Fw3)/(Gw3*dy*dz / dxw3)), ishconvection) + fmax(Fw3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw3.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].aw3 += Gw3*dy*dz / dxw3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw3*dy*dz / dxw3)*(mnk(iW3, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z) - potent[iW3]);
					}

				}
			}
		}

		if (iW4 > -1) {
			if (bW4) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].aw4 += (Gw4*border_neighbor[iW4 - maxelm].dS / dxw4)*ApproxConvective(fabs((Fw4)/(Gw4*border_neighbor[iW4 - maxelm].dS / dxw4)), ishconvection) + fmax(Fw4, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw4.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].aw4 += Gw4*border_neighbor[iW4 - maxelm].dS / dxw4;
				}
			}
			else {
				// iW4 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iW4]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw4 += (Gw4*dy*dz / dxw4)*ApproxConvective(fabs((Fw4)/(Gw4*dy*dz / dxw4)), ishconvection) + fmax(Fw4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw4.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].aw4 += Gw4*dy*dz / dxw4;
					}
				}
				else if (ilevel_alice[iW4] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iW4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw4 += (Gw4*dy_loc*dz_loc / dxw4)*ApproxConvective(fabs((Fw4)/(Gw4*dy_loc*dz_loc / dxw4)), ishconvection) + fmax(Fw4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw4.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].aw4 += Gw4*dy_loc*dz_loc / dxw4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw4*dy_loc*dz_loc / dxw4)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iW4).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw4 += (Gw4*dy*dz / dxw4)*ApproxConvective(fabs((Fw4)/(Gw4*dy*dz / dxw4)), ishconvection) + fmax(Fw4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw4.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].aw4 += Gw4*dy*dz / dxw4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw4*dy*dz / dxw4)*(mnk(iW4, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z) - potent[iW4]);
					}

				}
			}
		}

		// Грань W завершена.

		if (iN > -1) {
			if (bN) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].an += (Gn*border_neighbor[iN - maxelm].dS / dyn)*ApproxConvective(fabs((Fn1)/(Gn*border_neighbor[iN - maxelm].dS / dyn)), ishconvection) + fmax(-Fn1, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn1.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].an += Gn*border_neighbor[iN - maxelm].dS / dyn;
				}
			}
			else {
				// iN внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iN]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an += (Gn*dx*dz / dyn)*ApproxConvective(fabs((Fn1)/(Gn*dx*dz / dyn)), ishconvection) + fmax(-Fn1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn1.2.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].an += Gn*dx*dz / dyn;
					}
				}
				else if (ilevel_alice[iN] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iN, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an += (Gn*dx_loc*dz_loc / dyn)*ApproxConvective(fabs((Fn1)/(Gn*dx_loc*dz_loc / dyn)), ishconvection) + fmax(-Fn1, 0); ;
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn1.3.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].an += Gn*dx_loc*dz_loc / dyn;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn*dx_loc*dz_loc / dyn)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iN).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an += (Gn*dx*dz / dyn)*ApproxConvective(fabs((Fn1)/(Gn*dx*dz / dyn)), ishconvection) + fmax(-Fn1, 0); 
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn1.4.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].an += Gn*dx*dz / dyn;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn*dx*dz / dyn)*(potent[iN] - mnk(iN, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z));
					}

				}
			}
		}


		if (iN2 > -1) {
			if (bN2) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].an2 += (Gn2*border_neighbor[iN2 - maxelm].dS / dyn2)*ApproxConvective(fabs((Fn2)/(Gn2*border_neighbor[iN2 - maxelm].dS / dyn2)), ishconvection) + fmax(-Fn2, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn2.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].an2 += Gn2*border_neighbor[iN2 - maxelm].dS / dyn2;
				}
			}
			else {
				// iN2 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iN2]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an2 += (Gn2*dx*dz / dyn2)*ApproxConvective(fabs((Fn2)/(Gn2*dx*dz / dyn2)), ishconvection) + fmax(-Fn2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn2.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].an2 += Gn2*dx*dz / dyn2;
					}
				}
				else if (ilevel_alice[iN2] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iN2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an2 += (Gn2*dx_loc*dz_loc / dyn2)*ApproxConvective(fabs((Fn2)/(Gn2*dx_loc*dz_loc / dyn2)), ishconvection) + fmax(-Fn2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn2.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].an2 += Gn2*dx_loc*dz_loc / dyn2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn2*dx_loc*dz_loc / dyn2)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iN2).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an2 += (Gn2*dx*dz / dyn2)*ApproxConvective(fabs((Fn2)/(Gn2*dx*dz / dyn2)), ishconvection) + fmax(-Fn2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn2.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].an2 += Gn2*dx*dz / dyn2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn2*dx*dz / dyn2)*(potent[iN2] - mnk(iN2, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z));
					}

				}
			}
		}


		if (iN3 > -1) {
			if (bN3) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].an3 += (Gn3*border_neighbor[iN3 - maxelm].dS / dyn3)*ApproxConvective(fabs((Fn3)/(Gn3*border_neighbor[iN3 - maxelm].dS / dyn3)), ishconvection) + fmax(-Fn3, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn3.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].an3 += Gn3*border_neighbor[iN3 - maxelm].dS / dyn3;
				}
			}
			else {
				// iN внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iN3]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an3 += (Gn3*dx*dz / dyn3)*ApproxConvective(fabs((Fn3)/(Gn3*dx*dz / dyn3)), ishconvection) + fmax(-Fn3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn3.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].an3 += Gn3*dx*dz / dyn3;
					}
				}
				else if (ilevel_alice[iN3] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iN3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an3 += (Gn3*dx_loc*dz_loc / dyn3)*ApproxConvective(fabs((Fn3)/(Gn3*dx_loc*dz_loc / dyn3)), ishconvection) + fmax(-Fn3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn3.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].an3 += Gn3*dx_loc*dz_loc / dyn3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn3*dx_loc*dz_loc / dyn3)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iN3).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an3 += (Gn3*dx*dz / dyn3)*ApproxConvective(fabs((Fn3)/(Gn3*dx*dz / dyn3)), ishconvection) + fmax(-Fn3, 0); 
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn3.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].an3 += Gn3*dx*dz / dyn3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn3*dx*dz / dyn3)*(potent[iN3] - mnk(iN3, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z));
					}

				}
			}
		}

		if (iN4 > -1) {
			if (bN4) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].an4 += (Gn4*border_neighbor[iN4 - maxelm].dS / dyn4)*ApproxConvective(fabs((Fn4)/(Gn4*border_neighbor[iN4 - maxelm].dS / dyn4)), ishconvection) + fmax(-Fn4, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn4.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].an4 += Gn4*border_neighbor[iN4 - maxelm].dS / dyn4;
				}
			}
			else {
				// iN4 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iN4]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an4 += (Gn4*dx*dz / dyn4)*ApproxConvective(fabs((Fn4)/(Gn4*dx*dz / dyn4)), ishconvection) + fmax(-Fn4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn4.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].an4 += Gn4*dx*dz / dyn4;
					}
				}
				else if (ilevel_alice[iN4] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iN4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an4 += (Gn4*dx_loc*dz_loc / dyn4)*ApproxConvective(fabs((Fn4)/(Gn4*dx_loc*dz_loc / dyn4)), ishconvection) + fmax(-Fn4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn4.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].an4 += Gn4*dx_loc*dz_loc / dyn4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn4*dx_loc*dz_loc / dyn4)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iN4).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an4 += (Gn4*dx*dz / dyn4)*ApproxConvective(fabs((Fn4)/(Gn4*dx*dz / dyn4)), ishconvection) + fmax(-Fn4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn4.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].an4 += Gn4*dx*dz / dyn4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn4*dx*dz / dyn4)*(potent[iN4] - mnk(iN4, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z));
					}

				}
			}
		}

		// Грань N завершена.

		if (iS > -1) {
			if (bS) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].as += (Gs*border_neighbor[iS - maxelm].dS / dys)*ApproxConvective(fabs((Fs1)/(Gs*border_neighbor[iS - maxelm].dS / dys)), ishconvection) + fmax(Fs1, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs1.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].as += Gs*border_neighbor[iS - maxelm].dS / dys;
				}
			}
			else {
				// iS внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iS]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as += (Gs*dx*dz / dys)*ApproxConvective(fabs((Fs1)/(Gs*dx*dz / dys)), ishconvection) + fmax(Fs1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs1.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].as += Gs*dx*dz / dys;
					}
				}
				else if (ilevel_alice[iS] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iS, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as += (Gs*dx_loc*dz_loc / dys)*ApproxConvective(fabs((Fs1)/(Gs*dx_loc*dz_loc / dys)), ishconvection) + fmax(Fs1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs1.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].as += Gs*dx_loc*dz_loc / dys;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs*dx_loc*dz_loc / dys)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iS).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as += (Gs*dx*dz / dys)*ApproxConvective(fabs((Fs1)/(Gs*dx*dz / dys)), ishconvection) + fmax(Fs1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs1.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].as += Gs*dx*dz / dys;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs*dx*dz / dys)*(mnk(iS, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z) - potent[iS]);
					}

				}
			}
		}

		if (iS2 > -1) {
			if (bS2) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].as2 += (Gs2*border_neighbor[iS2 - maxelm].dS / dys2)*ApproxConvective(fabs((Fs2)/(Gs2*border_neighbor[iS2 - maxelm].dS / dys2)), ishconvection) + fmax(Fs2, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs2.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].as2 += Gs2*border_neighbor[iS2 - maxelm].dS / dys2;
				}
			}
			else {
				// iS2 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iS2]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as2 += (Gs2*dx*dz / dys2)*ApproxConvective(fabs((Fs2)/(Gs2*dx*dz / dys2)), ishconvection) + fmax(Fs2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs2.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].as2 += Gs2*dx*dz / dys2;
					}
				}
				else if (ilevel_alice[iS2] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iS2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as2 += (Gs2*dx_loc*dz_loc / dys2)*ApproxConvective(fabs((Fs2)/(Gs2*dx_loc*dz_loc / dys2)), ishconvection) + fmax(Fs2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs2.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].as2 += Gs2*dx_loc*dz_loc / dys2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs2*dx_loc*dz_loc / dys2)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z) - potent[iP]);
					}
				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iS2).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as2 += (Gs2*dx*dz / dys2)*ApproxConvective(fabs((Fs2)/(Gs2*dx*dz / dys2)), ishconvection) + fmax(Fs2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs2.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].as2 += Gs2*dx*dz / dys2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs2*dx*dz / dys2)*(mnk(iS2, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z) - potent[iS2]);
					}
				}
			}
		}

		if (iS3 > -1) {
			if (bS3) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].as3 += (Gs3*border_neighbor[iS3 - maxelm].dS / dys3)*ApproxConvective(fabs((Fs3)/(Gs3*border_neighbor[iS3 - maxelm].dS / dys3)), ishconvection) + fmax(Fs3, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs3.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].as3 += Gs3*border_neighbor[iS3 - maxelm].dS / dys3;
				}
			}
			else {
				// iS3 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iS3]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as3 += (Gs3*dx*dz / dys3)*ApproxConvective(fabs((Fs3)/(Gs3*dx*dz / dys3)), ishconvection) + fmax(Fs3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs3.2.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].as3 += Gs3*dx*dz / dys3;
					}
				}
				else if (ilevel_alice[iS3] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iS3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as3 += (Gs3*dx_loc*dz_loc / dys3)*ApproxConvective(fabs((Fs3)/(Gs3*dx_loc*dz_loc / dys3)), ishconvection) + fmax(Fs3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs3.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].as3 += Gs3*dx_loc*dz_loc / dys3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs3*dx_loc*dz_loc / dys3)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iS3).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as3 += (Gs3*dx*dz / dys3)*ApproxConvective(fabs((Fs3)/(Gs3*dx*dz / dys3)), ishconvection) + fmax(Fs3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs3.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].as3 += Gs3*dx*dz / dys3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs3*dx*dz / dys3)*(mnk(iS3, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z) - potent[iS3]);
					}
				}
			}
		}

		if (iS4 > -1) {
			if (bS4) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].as4 += (Gs4*border_neighbor[iS4 - maxelm].dS / dys4)*ApproxConvective(fabs((Fs4)/(Gs4*border_neighbor[iS4 - maxelm].dS / dys4)), ishconvection) + fmax(Fs4, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs4.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].as4 += Gs4*border_neighbor[iS4 - maxelm].dS / dys4;
				}
			}
			else {
				// iS4 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iS4]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as4 += (Gs4*dx*dz / dys4)*ApproxConvective(fabs((Fs4)/(Gs4*dx*dz / dys4)), ishconvection) + fmax(Fs4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs4.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].as4 += Gs4*dx*dz / dys4;
					}
				}
				else if (ilevel_alice[iS4] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iS4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as4 += (Gs4*dx_loc*dz_loc / dys4)*ApproxConvective(fabs((Fs4)/(Gs4*dx_loc*dz_loc / dys4)), ishconvection) + fmax(Fs4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs4.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].as4 += Gs4*dx_loc*dz_loc / dys4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs4*dx_loc*dz_loc / dys4)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iS4).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as4 += (Gs4*dx*dz / dys4)*ApproxConvective(fabs((Fs4)/(Gs4*dx*dz / dys4)), ishconvection) + fmax(Fs4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs4.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].as4 += Gs4*dx*dz / dys4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs4*dx*dz / dys4)*(mnk(iS4, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z) - potent[iS4]);
					}
				}
			}
		}

		// Грань S завершена.

		if (iT > -1) {
			if (bT) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].at += (Gt*border_neighbor[iT - maxelm].dS / dzt)*ApproxConvective(fabs((Ft1)/(Gt*border_neighbor[iT - maxelm].dS / dzt)), ishconvection) + fmax(-Ft1, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft1.1.\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].at += Gt*border_neighbor[iT - maxelm].dS / dzt;
				}
			}
			else {
				// iT внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iT]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at += (Gt*dx*dy / dzt)*ApproxConvective(fabs((Ft1)/(Gt*dx*dy / dzt)), ishconvection) + fmax(-Ft1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft1.2.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].at += Gt*dx*dy / dzt;
					}
				}
				else if (ilevel_alice[iT] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iT, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at += (Gt*dx_loc*dy_loc / dzt)*ApproxConvective(fabs((Ft1)/(Gt*dx_loc*dy_loc / dzt)), ishconvection) + fmax(-Ft1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft1.3.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].at += Gt*dx_loc*dy_loc / dzt;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt*dx_loc*dy_loc / dzt)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iT).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at += (Gt*dx*dy / dzt)*ApproxConvective(fabs((Ft1)/(Gt*dx*dy / dzt)), ishconvection) + fmax(-Ft1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft1.4.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].at += Gt*dx*dy / dzt;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt*dx*dy / dzt)*(potent[iT] - mnk(iT, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z));
					}
				}
			}
		}


		if (iT2 > -1) {
			if (bT2) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].at2 += (Gt2*border_neighbor[iT2 - maxelm].dS / dzt2)*ApproxConvective(fabs((Ft2)/(Gt2*border_neighbor[iT2 - maxelm].dS / dzt2)), ishconvection) + fmax(-Ft2, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft2.1.\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].at2 += Gt2*border_neighbor[iT2 - maxelm].dS / dzt2;
				}
			}
			else {
				// iT2 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iT2]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at2 += (Gt2*dx*dy / dzt2)*ApproxConvective(fabs((Ft2)/(Gt2*dx*dy / dzt2)), ishconvection) + fmax(-Ft2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft2.2.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].at2 += Gt2*dx*dy / dzt2;
					}
				}
				else if (ilevel_alice[iT2] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iT2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at2 += (Gt2*dx_loc*dy_loc / dzt2)*ApproxConvective(fabs((Ft2)/(Gt2*dx_loc*dy_loc / dzt2)), ishconvection) + fmax(-Ft2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft2.3.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].at2 += Gt2*dx_loc*dy_loc / dzt2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt2*dx_loc*dy_loc / dzt2)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iT2).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at2 += (Gt2*dx*dy / dzt2)*ApproxConvective(fabs((Ft2)/(Gt2*dx*dy / dzt2)), ishconvection) + fmax(-Ft2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft2.4.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].at2 += Gt2*dx*dy / dzt2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt2*dx*dy / dzt2)*(potent[iT2] - mnk(iT2, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z));
					}

				}
			}
		}


		if (iT3 > -1) {
			if (bT3) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].at3 += (Gt3*border_neighbor[iT3 - maxelm].dS / dzt3)*ApproxConvective(fabs((Ft3)/(Gt3*border_neighbor[iT3 - maxelm].dS / dzt3)), ishconvection) + fmax(-Ft3, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft3.1.\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].at3 += Gt3*border_neighbor[iT3 - maxelm].dS / dzt3;
				}
			}
			else {
				// iT3 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iT3]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at3 += (Gt3*dx*dy / dzt3)*ApproxConvective(fabs((Ft3)/(Gt3*dx*dy / dzt3)), ishconvection) + fmax(-Ft3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft3.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].at3 += Gt3*dx*dy / dzt3;
					}
				}
				else if (ilevel_alice[iT3] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iT3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at3 += (Gt3*dx_loc*dy_loc / dzt3)*ApproxConvective(fabs((Ft3)/(Gt3*dx_loc*dy_loc / dzt3)), ishconvection) + fmax(-Ft3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft3.3.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].at3 += Gt3*dx_loc*dy_loc / dzt3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt3*dx_loc*dy_loc / dzt3)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iT3).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at3 += (Gt3*dx*dy / dzt3)*ApproxConvective(fabs((Ft3)/(Gt3*dx*dy / dzt3)), ishconvection) + fmax(-Ft3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft3.4.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].at3 += Gt3*dx*dy / dzt3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt3*dx*dy / dzt3)*(potent[iT3] - mnk(iT3, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z));
					}

				}
			}
		}

		if (iT4 > -1) {
			if (bT4) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].at4 += (Gt4*border_neighbor[iT4 - maxelm].dS / dzt4)*ApproxConvective(fabs((Ft4)/(Gt4*border_neighbor[iT4 - maxelm].dS / dzt4)), ishconvection) + fmax(-Ft4, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft4.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].at4 += Gt4*border_neighbor[iT4 - maxelm].dS / dzt4;
				}
			}
			else {
				// iT4 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iT4]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at4 += (Gt4*dx*dy / dzt4)*ApproxConvective(fabs((Ft4)/(Gt4*dx*dy)), ishconvection) + fmax(-Ft4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft4.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].at4 += Gt4*dx*dy / dzt4;
					}
				}
				else if (ilevel_alice[iT4] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iT4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at4 += (Gt4*dx_loc*dy_loc / dzt4)*ApproxConvective(fabs((Ft4)/(Gt4*dx_loc*dy_loc / dzt4)), ishconvection) + fmax(-Ft4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft4.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].at4 += Gt4*dx_loc*dy_loc / dzt4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt4*dx_loc*dy_loc / dzt4)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iT4).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at4 += (Gt4*dx*dy / dzt4)*ApproxConvective(fabs((Ft4)/(Gt4*dx*dy / dzt4)), ishconvection) + fmax(-Ft4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft4.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].at4 += Gt4*dx*dy / dzt4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt4*dx*dy / dzt4)*(potent[iT4] - mnk(iT4, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z));
					}

				}
			}
		}

		// Грань T завершена.

		if (iB > -1) {
			if (bB) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ab += (Gb*border_neighbor[iB - maxelm].dS / dzb)*ApproxConvective(fabs((Fb1)/(Gb*border_neighbor[iB - maxelm].dS / dzb)), ishconvection) + fmax(Fb1, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb1.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].ab += Gb*border_neighbor[iB - maxelm].dS / dzb;
				}
			}
			else {
				// iB внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iB]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab += (Gb*dx*dy / dzb)*ApproxConvective(fabs((Fb1)/(Gb*dx*dy / dzb)), ishconvection) + fmax(Fb1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb1.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ab += Gb*dx*dy / dzb;
					}
				}
				else if (ilevel_alice[iB] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iB, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab += (Gb*dx_loc*dy_loc / dzb)*ApproxConvective(fabs((Fb1)/(Gb*dx_loc*dy_loc / dzb)), ishconvection) + fmax(Fb1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb1.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ab += Gb*dx_loc*dy_loc / dzb;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb*dx_loc*dy_loc / dzb)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iB).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab += (Gb*dx*dy / dzb)*ApproxConvective(fabs((Fb1)/(Gb*dx*dy / dzb)), ishconvection) + fmax(Fb1, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb1.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ab += Gb*dx*dy / dzb;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb*dx*dy / dzb)*(mnk(iB, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z) - potent[iB]);
					}
				}
			}
		}

		if (iB2 > -1) {
			if (bB2) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ab2 += (Gb2*border_neighbor[iB2 - maxelm].dS / dzb2)*ApproxConvective(fabs((Fb2)/(Gb2*border_neighbor[iB2 - maxelm].dS / dzb2)), ishconvection) + fmax(Fb2, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb2.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].ab2 += Gb2*border_neighbor[iB2 - maxelm].dS / dzb2;
				}
			}
			else {
				// iB2 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iB2]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab2 += (Gb2*dx*dy / dzb2)*ApproxConvective(fabs((Fb2)/(Gb2*dx*dy / dzb2)), ishconvection) + fmax(Fb2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb2.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ab2 += Gb2*dx*dy / dzb2;
					}
				}
				else if (ilevel_alice[iB2] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iB2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab2 += (Gb2*dx_loc*dy_loc / dzb2)*ApproxConvective(fabs((Fb2)/(Gb2*dx_loc*dy_loc / dzb2)), ishconvection) + fmax(Fb2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb2.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ab2 += Gb2*dx_loc*dy_loc / dzb2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb2*dx_loc*dy_loc / dzb2)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iB2).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab2 += (Gb2*dx*dy / dzb2)*ApproxConvective(fabs((Fb2)/(Gb2*dx*dy / dzb2)), ishconvection) + fmax(Fb2, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb2.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ab2 += Gb2*dx*dy / dzb2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb2*dx*dy / dzb2)*(mnk(iB2, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z) - potent[iB2]);
					}

				}
			}
		}

		if (iB3 > -1) {
			if (bB3) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ab3 += (Gb3*border_neighbor[iB3 - maxelm].dS / dzb3)*ApproxConvective(fabs((Fb3)/(Gb3*border_neighbor[iB3 - maxelm].dS / dzb3)), ishconvection) + fmax(Fb3, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb3.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].ab3 += Gb3*border_neighbor[iB3 - maxelm].dS / dzb3;
				}
			}
			else {
				// iB3 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iB3]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab3 += (Gb3*dx*dy / dzb3)*ApproxConvective(fabs((Fb3)/(Gb3*dx*dy / dzb3)), ishconvection) + fmax(Fb3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb3.2\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ab3 += Gb3*dx*dy / dzb3;
					}
				}
				else if (ilevel_alice[iB3] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iB3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab3 += (Gb3*dx_loc*dy_loc / dzb3)*ApproxConvective(fabs((Fb3)/(Gb3*dx_loc*dy_loc / dzb3)), ishconvection) + fmax(Fb3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb3.3.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ab3 += Gb3*dx_loc*dy_loc / dzb3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb3*dx_loc*dy_loc / dzb3)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iB3).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab3 += (Gb3*dx*dy / dzb3)*ApproxConvective(fabs((Fb3)/(Gb3*dx*dy / dzb3)), ishconvection) + fmax(Fb3, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb3.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ab3 += Gb3*dx*dy / dzb3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb3*dx*dy / dzb3)*(mnk(iB3, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z) - potent[iB3]);
					}
				}
			}
		}

		if (iB4 > -1) {
			if (bB4) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ab4 += (Gb4*border_neighbor[iB4 - maxelm].dS / dzb4)*ApproxConvective(fabs((Fb4)/(Gb4*border_neighbor[iB4 - maxelm].dS / dzb4)), ishconvection) + fmax(Fb4, 0);
					}
					else {
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb4.1\n");
						system("pause");
						exit(1);
					}
				}
				else {
					sl[iP].ab4 += Gb4*border_neighbor[iB4 - maxelm].dS / dzb4;
				}
			}
			else {
				// iB4 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iB4]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab4 += (Gb4*dx*dy / dzb4)*ApproxConvective(fabs((Fb4)/(Gb4*dx*dy / dzb4)), ishconvection) + fmax(Fb4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb4.2.\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ab4 += Gb4*dx*dy / dzb4;
					}
				}
				else if (ilevel_alice[iB4] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iB4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab4 += (Gb4*dx_loc*dy_loc / dzb4)*ApproxConvective(fabs((Fb4)/(Gb4*dx_loc*dy_loc / dzb4)), ishconvection) + fmax(Fb4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb4.3\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ab4 += Gb4*dx_loc*dy_loc / dzb4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb4*dx_loc*dy_loc / dzb4)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iB4).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab4 += (Gb4*dx*dy / dzb4)*ApproxConvective(fabs((Fb4)/(Gb4*dx*dy / dzb4)), ishconvection) + fmax(Fb4, 0);
						}
						else {
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb4.4\n");
							system("pause");
							exit(1);
						}
					}
					else {
						sl[iP].ab4 += Gb4*dx*dy / dzb4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb4*dx*dy / dzb4)*(mnk(iB4, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z) - potent[iB4]);
					}

				}
			}
		}

		//  Грань B завершена.
		// 28 сентября 2016. 10_51.
		if (sl[iP].ae < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative ae=%e\n", sl[iP].ae);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].aw < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative aw=%e\n", sl[iP].aw);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].an < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative an=%e\n", sl[iP].an);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].as < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative as=%e\n", sl[iP].as);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].at < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative at=%e\n", sl[iP].at);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].ab < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative ab=%e\n", sl[iP].ab);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}

		if (sl[iP].ae2 < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative ae2=%e\n", sl[iP].ae2);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].aw2 < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative aw2=%e\n", sl[iP].aw2);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].an2 < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative an2=%e\n", sl[iP].an2);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].as2 < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative as2=%e\n", sl[iP].as2);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].at2 < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative at2=%e\n", sl[iP].at2);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].ab2 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative ab2=%e\n", sl[iP].ab2);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}

		if (sl[iP].ae3 < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative ae3=%e\n", sl[iP].ae3);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].aw3 < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative aw3=%e\n", sl[iP].aw3);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].an3 < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative an3=%e\n", sl[iP].an3);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].as3 < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative as3=%e\n", sl[iP].as3);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].at3 < 0.0) {
			std::cout << b[whot_is_block[iP]].name  << std::endl;
			printf("Error UDS negative at3=%e\n", sl[iP].at3);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].ab3 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative ab3=%e\n", sl[iP].ab3);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}

		if (sl[iP].ae4 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative ae4=%e\n", sl[iP].ae4);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].aw4 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative aw4=%e\n", sl[iP].aw4);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].an4 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative an4=%e\n", sl[iP].an4);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].as4 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative as4=%e\n", sl[iP].as4);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].at4 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative at4=%e\n", sl[iP].at4);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].ab4 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative ab4=%e\n", sl[iP].ab4);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
	}
	else {

		if (ishconvection < distsheme) {
			// Вычисление коэффициентов дискретного аналога:
			if (bconvective)
			{


				if (b_on_adaptive_local_refinement_mesh) {

					if (!bsE) sl[iP].ae = De * ApproxConvective(fabs(Pe), ishconvection) + fmax(-Fe1, 0); else sl[iP].ae = 0.0;
					if (!bsW) sl[iP].aw = Dw * ApproxConvective(fabs(Pw), ishconvection) + fmax(Fw1, 0);  else sl[iP].aw = 0.0;
					if (!bsN) sl[iP].an = Dn * ApproxConvective(fabs(Pn), ishconvection) + fmax(-Fn1, 0); else sl[iP].an = 0.0;
					if (!bsS) sl[iP].as = Ds * ApproxConvective(fabs(Ps), ishconvection) + fmax(Fs1, 0); else sl[iP].as = 0.0;
					if (!bsT) sl[iP].at = Dt * ApproxConvective(fabs(Pt), ishconvection) + fmax(-Ft1, 0); else sl[iP].at = 0.0;
					if (!bsB) sl[iP].ab = Db * ApproxConvective(fabs(Pb), ishconvection) + fmax(Fb1, 0); else sl[iP].ab = 0.0;

					if (!bsE) sl[iP].ae2 = De2 * ApproxConvective(fabs(Pe2), ishconvection) + fmax(-Fe2, 0); else sl[iP].ae2 = 0.0;
					if (!bsW) sl[iP].aw2 = Dw2 * ApproxConvective(fabs(Pw2), ishconvection) + fmax(Fw2, 0);  else sl[iP].aw2 = 0.0;
					if (!bsN) sl[iP].an2 = Dn2 * ApproxConvective(fabs(Pn2), ishconvection) + fmax(-Fn2, 0); else sl[iP].an2 = 0.0;
					if (!bsS) sl[iP].as2 = Ds2 * ApproxConvective(fabs(Ps2), ishconvection) + fmax(Fs2, 0); else sl[iP].as2 = 0.0;
					if (!bsT) sl[iP].at2 = Dt2 * ApproxConvective(fabs(Pt2), ishconvection) + fmax(-Ft2, 0); else sl[iP].at2 = 0.0;
					if (!bsB) sl[iP].ab2 = Db2 * ApproxConvective(fabs(Pb2), ishconvection) + fmax(Fb2, 0); else sl[iP].ab2 = 0.0;

					if (!bsE) sl[iP].ae3 = De3 * ApproxConvective(fabs(Pe3), ishconvection) + fmax(-Fe3, 0); else sl[iP].ae3 = 0.0;
					if (!bsW) sl[iP].aw3 = Dw3 * ApproxConvective(fabs(Pw3), ishconvection) + fmax(Fw3, 0);  else sl[iP].aw3 = 0.0;
					if (!bsN) sl[iP].an3 = Dn3 * ApproxConvective(fabs(Pn3), ishconvection) + fmax(-Fn3, 0); else sl[iP].an3 = 0.0;
					if (!bsS) sl[iP].as3 = Ds3 * ApproxConvective(fabs(Ps3), ishconvection) + fmax(Fs3, 0); else sl[iP].as3 = 0.0;
					if (!bsT) sl[iP].at3 = Dt3 * ApproxConvective(fabs(Pt3), ishconvection) + fmax(-Ft3, 0); else sl[iP].at3 = 0.0;
					if (!bsB) sl[iP].ab3 = Db3 * ApproxConvective(fabs(Pb3), ishconvection) + fmax(Fb3, 0); else sl[iP].ab3 = 0.0;

					if (!bsE) sl[iP].ae4 = De4 * ApproxConvective(fabs(Pe4), ishconvection) + fmax(-Fe4, 0); else sl[iP].ae4 = 0.0;
					if (!bsW) sl[iP].aw4 = Dw4 * ApproxConvective(fabs(Pw4), ishconvection) + fmax(Fw4, 0);  else sl[iP].aw4 = 0.0;
					if (!bsN) sl[iP].an4 = Dn4 * ApproxConvective(fabs(Pn4), ishconvection) + fmax(-Fn4, 0); else sl[iP].an4 = 0.0;
					if (!bsS) sl[iP].as4 = Ds4 * ApproxConvective(fabs(Ps4), ishconvection) + fmax(Fs4, 0); else sl[iP].as4 = 0.0;
					if (!bsT) sl[iP].at4 = Dt4 * ApproxConvective(fabs(Pt4), ishconvection) + fmax(-Ft4, 0); else sl[iP].at4 = 0.0;
					if (!bsB) sl[iP].ab4 = Db4 * ApproxConvective(fabs(Pb4), ishconvection) + fmax(Fb4, 0); else sl[iP].ab4 = 0.0;
				}
				else {
					if (!bsE) sl[iP].ae = De * ApproxConvective(fabs(Pe), ishconvection) + fmax(-Fe, 0); else sl[iP].ae = 0.0;
					if (!bsW) sl[iP].aw = Dw * ApproxConvective(fabs(Pw), ishconvection) + fmax(Fw, 0);  else sl[iP].aw = 0.0;
					if (!bsN) sl[iP].an = Dn * ApproxConvective(fabs(Pn), ishconvection) + fmax(-Fn, 0); else sl[iP].an = 0.0;
					if (!bsS) sl[iP].as = Ds * ApproxConvective(fabs(Ps), ishconvection) + fmax(Fs, 0); else sl[iP].as = 0.0;
					if (!bsT) sl[iP].at = Dt * ApproxConvective(fabs(Pt), ishconvection) + fmax(-Ft, 0); else sl[iP].at = 0.0;
					if (!bsB) sl[iP].ab = Db * ApproxConvective(fabs(Pb), ishconvection) + fmax(Fb, 0); else sl[iP].ab = 0.0;
				}


#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (sl[iP].ae < 0.0) {
					std::cout << b[whot_is_block[iP]].name << std::endl;
					printf("Error UDS negative ae=%e\n", sl[iP].ae);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (sl[iP].aw < 0.0) {
					std::cout << b[whot_is_block[iP]].name << std::endl;
					printf("Error UDS negative aw=%e\n", sl[iP].aw);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (sl[iP].an < 0.0) {
					std::cout << b[whot_is_block[iP]].name << std::endl;
					printf("Error UDS negative an=%e\n", sl[iP].an);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (sl[iP].as < 0.0) {
					std::cout << b[whot_is_block[iP]].name << std::endl;
					printf("Error UDS negative as=%e\n", sl[iP].as);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (sl[iP].at < 0.0) {
					std::cout << b[whot_is_block[iP]].name << std::endl;
					printf("Error UDS negative at=%e\n", sl[iP].at);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (sl[iP].ab < 0.0) {
					std::cout << b[whot_is_block[iP]].name << std::endl;
					printf("Error UDS negative ab=%e\n", sl[iP].ab);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}

				if (b_on_adaptive_local_refinement_mesh) {

					if (sl[iP].ae2 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative ae2=%e\n", sl[iP].ae2);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].aw2 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative aw2=%e\n", sl[iP].aw2);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].an2 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative an2=%e\n", sl[iP].an2);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].as2 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative as2=%e\n", sl[iP].as2);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].at2 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative at2=%e\n", sl[iP].at2);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].ab2 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative ab2=%e\n", sl[iP].ab2);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}

					if (sl[iP].ae3 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative ae3=%e\n", sl[iP].ae3);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].aw3 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative aw3=%e\n", sl[iP].aw3);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].an3 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative an3=%e\n", sl[iP].an3);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].as3 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative as3=%e\n", sl[iP].as3);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].at3 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative at3=%e\n", sl[iP].at3);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].ab3 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative ab3=%e\n", sl[iP].ab3);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}

					if (sl[iP].ae4 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative ae4=%e\n", sl[iP].ae4);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].aw4 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative aw4=%e\n", sl[iP].aw4);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].an4 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative an4=%e\n", sl[iP].an4);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].as4 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative as4=%e\n", sl[iP].as4);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
				}
					if (sl[iP].at4 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative at4=%e\n", sl[iP].at4);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
					if (sl[iP].ab4 < 0.0) {
						std::cout << b[whot_is_block[iP]].name << std::endl;
						printf("Error UDS negative ab4=%e\n", sl[iP].ab4);
						printf("in my_elmatr_quad_T3D function\n");
						system("pause");
					}
			}
#endif
			}
			else
			{
				
				// Вычисление 
				// коэффициентов
				// дискретного аналога:
				if (!bsE) sl[iP].ae = De; else sl[iP].ae = 0.0;
				if (!bsW) sl[iP].aw = Dw; else sl[iP].aw = 0.0;
				if (!bsN) sl[iP].an = Dn; else sl[iP].an = 0.0;
				if (!bsS) sl[iP].as = Ds; else sl[iP].as = 0.0;
				if (!bsT) sl[iP].at = Dt; else sl[iP].at = 0.0;
				if (!bsB) sl[iP].ab = Db; else sl[iP].ab = 0.0;

				baddDFLUX2 = 0.0; // инициализация.
				if (bhighorder) { // проверено !
					// если bborder == false то узел строго внутренний.
					// если bborder   то мы находимся вблизи граничного узла.
					bool bborder = false;
					doublereal myflux = 0.0;/*
					myflux=De*(dxe*DFDXiP(potent, iP, ESIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iE]));
					baddDFLUX2+=myflux;
					myflux=Dw*(-dxw*DFDXiP(potent, iP, WSIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iW]));
					baddDFLUX2+=myflux;
					myflux=Dn*(dyn*DFDXiP(potent, iP, N, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iN]));
					baddDFLUX2+=myflux;
					myflux=Ds*(-dys*DFDXiP(potent, iP, S, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iS]));
					baddDFLUX2+=myflux;
					myflux=Dt*(dzt*DFDXiP(potent, iP, TSIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iT]));
					baddDFLUX2+=myflux;
					myflux=Db*(-dzb*DFDXiP(potent, iP, B, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iB]));
					baddDFLUX2+=myflux;
					//baddDFLUX2*=-1.0;*/
					myflux = De*(dxe*DFDXiP(potent, iP, E_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iE]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dw*(-dxw*DFDXiP(potent, iP, W_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iW]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dn*(dyn*DFDXiP(potent, iP, N_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iN]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Ds*(-dys*DFDXiP(potent, iP, S_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iS]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dt*(dzt*DFDXiP(potent, iP, T_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iT]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Db*(-dzb*DFDXiP(potent, iP, B_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iB]));
					if (!bborder) baddDFLUX2 += myflux;
					//baddDFLUX2*=-1.0;  // проверено нужно именно +1.0.
				}

			}
		}
		else if (ishconvection < QUICK)
		{
			// Вычисление коэффициентов дискретного аналога:
			if (bconvective)
			{
				if (b_on_adaptive_local_refinement_mesh) {

					if (!bsE) sl[iP].ae = -Fe1 * fC(Pe, ishconvection, true, feplus) + De * fD(Pe, ishconvection, true, feplus); else sl[iP].ae = 0.0;
					if (!bsW) sl[iP].aw = Fw1 * fC(Pw, ishconvection, true, fwplus) + Dw * fD(Pw, ishconvection, true, fwplus); else sl[iP].aw = 0.0;
					if (!bsN) sl[iP].an = -Fn1 * fC(Pn, ishconvection, true, fnplus) + Dn * fD(Pn, ishconvection, true, fnplus); else sl[iP].an = 0.0;
					if (!bsS) sl[iP].as = Fs1 * fC(Ps, ishconvection, true, fsplus) + Ds * fD(Ps, ishconvection, true, fsplus); else sl[iP].as = 0.0;
					if (!bsT) sl[iP].at = -Ft1 * fC(Pt, ishconvection, true, ftplus) + Dt * fD(Pt, ishconvection, true, ftplus); else sl[iP].at = 0.0;
					if (!bsB) sl[iP].ab = Fb1 * fC(Pb, ishconvection, true, fbplus) + Db * fD(Pb, ishconvection, true, fbplus); else sl[iP].ab = 0.0;

					if (!bsE) sl[iP].ae2 = -Fe2 * fC(Pe2, ishconvection, true, feplus) + De2 * fD(Pe2, ishconvection, true, feplus); else sl[iP].ae2 = 0.0;
					if (!bsW) sl[iP].aw2 = Fw2 * fC(Pw2, ishconvection, true, fwplus) + Dw2 * fD(Pw2, ishconvection, true, fwplus); else sl[iP].aw2 = 0.0;
					if (!bsN) sl[iP].an2 = -Fn2 * fC(Pn2, ishconvection, true, fnplus) + Dn2 * fD(Pn2, ishconvection, true, fnplus); else sl[iP].an2 = 0.0;
					if (!bsS) sl[iP].as2 = Fs2 * fC(Ps2, ishconvection, true, fsplus) + Ds2 * fD(Ps2, ishconvection, true, fsplus); else sl[iP].as2 = 0.0;
					if (!bsT) sl[iP].at2 = -Ft2 * fC(Pt2, ishconvection, true, ftplus) + Dt2 * fD(Pt2, ishconvection, true, ftplus); else sl[iP].at2 = 0.0;
					if (!bsB) sl[iP].ab2 = Fb2 * fC(Pb2, ishconvection, true, fbplus) + Db2 * fD(Pb2, ishconvection, true, fbplus); else sl[iP].ab2 = 0.0;

					if (!bsE) sl[iP].ae3 = -Fe3 * fC(Pe3, ishconvection, true, feplus) + De3 * fD(Pe3, ishconvection, true, feplus); else sl[iP].ae3 = 0.0;
					if (!bsW) sl[iP].aw3 = Fw3 * fC(Pw3, ishconvection, true, fwplus) + Dw3 * fD(Pw3, ishconvection, true, fwplus); else sl[iP].aw3 = 0.0;
					if (!bsN) sl[iP].an3 = -Fn3 * fC(Pn3, ishconvection, true, fnplus) + Dn3 * fD(Pn3, ishconvection, true, fnplus); else sl[iP].an3 = 0.0;
					if (!bsS) sl[iP].as3 = Fs3 * fC(Ps3, ishconvection, true, fsplus) + Ds3 * fD(Ps3, ishconvection, true, fsplus); else sl[iP].as3 = 0.0;
					if (!bsT) sl[iP].at3 = -Ft3 * fC(Pt3, ishconvection, true, ftplus) + Dt3 * fD(Pt3, ishconvection, true, ftplus); else sl[iP].at3 = 0.0;
					if (!bsB) sl[iP].ab3 = Fb3 * fC(Pb3, ishconvection, true, fbplus) + Db3 * fD(Pb3, ishconvection, true, fbplus); else sl[iP].ab3 = 0.0;

					if (!bsE) sl[iP].ae4 = -Fe4 * fC(Pe4, ishconvection, true, feplus) + De4 * fD(Pe4, ishconvection, true, feplus); else sl[iP].ae4 = 0.0;
					if (!bsW) sl[iP].aw4 = Fw4 * fC(Pw4, ishconvection, true, fwplus) + Dw4 * fD(Pw4, ishconvection, true, fwplus); else sl[iP].aw4 = 0.0;
					if (!bsN) sl[iP].an4 = -Fn4 * fC(Pn4, ishconvection, true, fnplus) + Dn4 * fD(Pn4, ishconvection, true, fnplus); else sl[iP].an4 = 0.0;
					if (!bsS) sl[iP].as4 = Fs4 * fC(Ps4, ishconvection, true, fsplus) + Ds4 * fD(Ps4, ishconvection, true, fsplus); else sl[iP].as4 = 0.0;
					if (!bsT) sl[iP].at4 = -Ft4 * fC(Pt4, ishconvection, true, ftplus) + Dt4 * fD(Pt4, ishconvection, true, ftplus); else sl[iP].at4 = 0.0;
					if (!bsB) sl[iP].ab4 = Fb4 * fC(Pb4, ishconvection, true, fbplus) + Db4 * fD(Pb4, ishconvection, true, fbplus); else sl[iP].ab4 = 0.0;

				}
				else {

					if (!bsE) sl[iP].ae = -Fe * fC(Pe, ishconvection, true, feplus) + De * fD(Pe, ishconvection, true, feplus); else sl[iP].ae = 0.0;
					if (!bsW) sl[iP].aw = Fw * fC(Pw, ishconvection, true, fwplus) + Dw * fD(Pw, ishconvection, true, fwplus); else sl[iP].aw = 0.0;
					if (!bsN) sl[iP].an = -Fn * fC(Pn, ishconvection, true, fnplus) + Dn * fD(Pn, ishconvection, true, fnplus); else sl[iP].an = 0.0;
					if (!bsS) sl[iP].as = Fs * fC(Ps, ishconvection, true, fsplus) + Ds * fD(Ps, ishconvection, true, fsplus); else sl[iP].as = 0.0;
					if (!bsT) sl[iP].at = -Ft * fC(Pt, ishconvection, true, ftplus) + Dt * fD(Pt, ishconvection, true, ftplus); else sl[iP].at = 0.0;
					if (!bsB) sl[iP].ab = Fb * fC(Pb, ishconvection, true, fbplus) + Db * fD(Pb, ishconvection, true, fbplus); else sl[iP].ab = 0.0;
				}
			}
			else
			{
				// число Пекле равно 0.
				// fD(Pe) возвращает 1.0.

				// Вычисление 
				// коэффициентов
				// дискретного аналога:
				if (!bsE) sl[iP].ae = De; else sl[iP].ae = 0.0;
				if (!bsW) sl[iP].aw = Dw; else sl[iP].aw = 0.0;
				if (!bsN) sl[iP].an = Dn; else sl[iP].an = 0.0;
				if (!bsS) sl[iP].as = Ds; else sl[iP].as = 0.0;
				if (!bsT) sl[iP].at = Dt; else sl[iP].at = 0.0;
				if (!bsB) sl[iP].ab = Db; else sl[iP].ab = 0.0;

				baddDFLUX2 = 0.0; // инициализация.
				if (bhighorder) { // проверено !
					// если bborder == false то узел строго внутренний.
					// если bborder   то мы находимся вблизи граничного узла.
					bool bborder = false;
					doublereal myflux = 0.0;/*
					myflux=De*(dxe*DFDXiP(potent, iP, ESIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iE]));
					baddDFLUX2+=myflux;
					myflux=Dw*(-dxw*DFDXiP(potent, iP, WSIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iW]));
					baddDFLUX2+=myflux;
					myflux=Dn*(dyn*DFDXiP(potent, iP, N, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iN]));
					baddDFLUX2+=myflux;
					myflux=Ds*(-dys*DFDXiP(potent, iP, S, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iS]));
					baddDFLUX2+=myflux;
					myflux=Dt*(dzt*DFDXiP(potent, iP, TSIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iT]));
					baddDFLUX2+=myflux;
					myflux=Db*(-dzb*DFDXiP(potent, iP, B, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iB]));
					baddDFLUX2+=myflux;
					//baddDFLUX2*=-1.0;*/
					myflux = De*(dxe*DFDXiP(potent, iP, E_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iE]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dw*(-dxw*DFDXiP(potent, iP, W_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iW]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dn*(dyn*DFDXiP(potent, iP, N_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iN]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Ds*(-dys*DFDXiP(potent, iP, S_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iS]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dt*(dzt*DFDXiP(potent, iP, T_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iT]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Db*(-dzb*DFDXiP(potent, iP, B_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iB]));
					if (!bborder) baddDFLUX2 += myflux;
					//baddDFLUX2*=-1.0;  // проверено нужно именно +1.0.
				}
			}
		}
		else if (ishconvection >= QUICK)
		{

			// С учётом конвекции.
			bool berrE = false, berrW = false, berrN = false, berrS = false, berrT = false, berrB = false;
			bool berrE2 = false, berrW2 = false, berrN2 = false, berrS2 = false, berrT2 = false, berrB2 = false;
			bool berrE3 = false, berrW3 = false, berrN3 = false, berrS3 = false, berrT3 = false, berrB3 = false;
			bool berrE4 = false, berrW4 = false, berrN4 = false, berrS4 = false, berrT4 = false, berrB4 = false;
			bool bpatch = true;

			// В 3D пространстве данная схема расщепляется на три одномерных схемы.
			// Схема Леонарда имеет второй порядок и реализуется с помощью механизма отложенной коррекции.

			TOCHKA pointP;
			center_cord3D(iP, nvtx, pa, pointP, 100);


			// X - direction
			doublereal positionxP = pointP.x, positionxE = pointP.x, positionxW = pointP.x, positionxEE = pointP.x, positionxWW = pointP.x, positionxe = pointP.x, positionxw = pointP.x;
			//doublereal FiP = 0.0, FiE = 0.0, FiW = 0.0, FiEE = 0.0, FiWW = 0.0, FiN = 0.0, FiS = 0.0;
			//doublereal FiNN = 0.0, FiSS = 0.0, FiT = 0.0, FiB = 0.0, FiTT = 0.0, FiBB = 0.0;
			//doublereal Fie = 0.0, Fiw = 0.0, Fin = 0.0, Fis = 0.0, Fit = 0.0, Fib = 0.0;
			// Y - direction
			doublereal positionyP = pointP.y, positionyN = pointP.y, positionyS = pointP.y, positionyNN = pointP.y, positionySS = pointP.y, positionyn = pointP.y, positionys = pointP.y;
			// Z - direction
			doublereal positionzP = pointP.z, positionzT = pointP.z, positionzB = pointP.z, positionzTT = pointP.z, positionzBB = pointP.z, positionzt = pointP.z, positionzb = pointP.z;

			/*
			doublereal  FiE2 = 0.0, FiW2 = 0.0, FiEE2 = 0.0, FiWW2 = 0.0, FiN2 = 0.0, FiS2 = 0.0;
			doublereal FiNN2 = 0.0, FiSS2 = 0.0, FiT2 = 0.0, FiB2 = 0.0, FiTT2 = 0.0, FiBB2 = 0.0;
			doublereal Fie2 = 0.0, Fiw2 = 0.0, Fin2 = 0.0, Fis2 = 0.0, Fit2 = 0.0, Fib2 = 0.0;

			doublereal  FiE3 = 0.0, FiW3 = 0.0, FiEE3 = 0.0, FiWW3 = 0.0, FiN3 = 0.0, FiS3 = 0.0;
			doublereal FiNN3 = 0.0, FiSS3 = 0.0, FiT3 = 0.0, FiB3 = 0.0, FiTT3 = 0.0, FiBB3 = 0.0;
			doublereal Fie3 = 0.0, Fiw3 = 0.0, Fin3 = 0.0, Fis3 = 0.0, Fit3 = 0.0, Fib3 = 0.0;

			doublereal  FiE4 = 0.0, FiW4 = 0.0, FiEE4 = 0.0, FiWW4 = 0.0, FiN4 = 0.0, FiS4 = 0.0;
			doublereal FiNN4= 0.0, FiSS4 = 0.0, FiT4 = 0.0, FiB4 = 0.0, FiTT4 = 0.0, FiBB4 = 0.0;
			doublereal Fie4 = 0.0, Fiw4 = 0.0, Fin4 = 0.0, Fis4 = 0.0, Fit4 = 0.0, Fib4 = 0.0;
			*/

			// X - direction
			doublereal  positionxE2 = pointP.x, positionxW2 = pointP.x, positionxEE2 = pointP.x, positionxWW2 = pointP.x, positionxe2 = pointP.x, positionxw2 = pointP.x;
			// Y - direction
			doublereal  positionyN2 = pointP.y, positionyS2 = pointP.y, positionyNN2 = pointP.y, positionySS2 = pointP.y, positionyn2 = pointP.y, positionys2 = pointP.y;
			// Z - direction
			doublereal  positionzT2 = pointP.z, positionzB2 = pointP.z, positionzTT2 = pointP.z, positionzBB2 = pointP.z, positionzt2 = pointP.z, positionzb2 = pointP.z;

			// X - direction
			doublereal  positionxE3 = pointP.x, positionxW3 = pointP.x, positionxEE3 = pointP.x, positionxWW3 = pointP.x, positionxe3 = pointP.x, positionxw3 = pointP.x;
			// Y - direction
			doublereal  positionyN3 = pointP.y, positionyS3 = pointP.y, positionyNN3 = pointP.y, positionySS3 = pointP.y, positionyn3 = pointP.y, positionys3 = pointP.y;
			// Z - direction
			doublereal  positionzT3 = pointP.z, positionzB3 = pointP.z, positionzTT3 = pointP.z, positionzBB3 = pointP.z, positionzt3 = pointP.z, positionzb3 = pointP.z;

			// X - direction
			doublereal  positionxE4 = pointP.x, positionxW4 = pointP.x, positionxEE4 = pointP.x, positionxWW4 = pointP.x, positionxe4 = pointP.x, positionxw4 = pointP.x;
			// Y - direction
			doublereal  positionyN4 = pointP.y, positionyS4 = pointP.y, positionyNN4 = pointP.y, positionySS4 = pointP.y, positionyn4 = pointP.y, positionys4 = pointP.y;
			// Z - direction
			doublereal  positionzT4 = pointP.z, positionzB4 = pointP.z, positionzTT4 = pointP.z, positionzBB4 = pointP.z, positionzt4 = pointP.z, positionzb4 = pointP.z;

			// Будем находится в окрестности температуры в центральном узле. 09.01.2020
			doublereal FiP = potent[iP], FiE = FiP, FiW = FiP, FiEE = FiP, FiWW = FiP, FiN = FiP, FiS = FiP;
			doublereal FiNN = FiP, FiSS = FiP, FiT = FiP, FiB = FiP, FiTT = FiP, FiBB = FiP;
			doublereal Fie = FiP, Fiw = FiP, Fin = FiP, Fis = FiP, Fit = FiP, Fib = FiP;

			doublereal  FiE2 = FiP, FiW2 = FiP, FiEE2 = FiP, FiWW2 = FiP, FiN2 = FiP, FiS2 = FiP;
			doublereal FiNN2 = FiP, FiSS2 = FiP, FiT2 = FiP, FiB2 = FiP, FiTT2 = FiP, FiBB2 = FiP;
			doublereal Fie2 = FiP, Fiw2 = FiP, Fin2 = FiP, Fis2 = FiP, Fit2 = FiP, Fib2 = FiP;

			doublereal  FiE3 = FiP, FiW3 = FiP, FiEE3 = FiP, FiWW3 = FiP, FiN3 = FiP, FiS3 = FiP;
			doublereal FiNN3 = FiP, FiSS3 = FiP, FiT3 = FiP, FiB3 = FiP, FiTT3 = FiP, FiBB3 = FiP;
			doublereal Fie3 = FiP, Fiw3 = FiP, Fin3 = FiP, Fis3 = FiP, Fit3 = FiP, Fib3 = FiP;

			doublereal  FiE4 = FiP, FiW4 = FiP, FiEE4 = FiP, FiWW4 = FiP, FiN4 = FiP, FiS4 = FiP;
			doublereal FiNN4 = FiP, FiSS4 = FiP, FiT4 = FiP, FiB4 = FiP, FiTT4 = FiP, FiBB4 = FiP;
			doublereal Fie4 = FiP, Fiw4 = FiP, Fin4 = FiP, Fis4 = FiP, Fit4 = FiP, Fib4 = FiP;


			if (bconvective)
			{

				
				//printf("iP");
				//system("pause");
				positionxP = pointP.x; positionyP = pointP.y; positionzP = pointP.z;
				FiP = potent[iP];

				if (b_on_adaptive_local_refinement_mesh) {

					// 06.01.2021


					// X - direction
					if ((!bE)&&(iE > -1)) {
						FiE = potent[iE];
						center_cord3D(iE, nvtx, pa, pointP, E_SIDE);
						//printf("iE");
						//system("pause");
						positionxE = pointP.x;
						positionxe = positionxP + 0.5 * dx;

						integer iEE = neighbors_for_the_internal_node[E_SIDE][0][iE];
						if (iEE < 0) {
							iEE = neighbors_for_the_internal_node[E_SIDE][1][iE];
						}
						if (iEE < 0) {
							iEE = neighbors_for_the_internal_node[E_SIDE][2][iE];
						}
						if (iEE < 0) {
							iEE = neighbors_for_the_internal_node[E_SIDE][3][iE];
						}

						if ((iEE >= 0) && (iEE < maxelm)) {
							// внутренний узел
							FiEE = potent[iEE];
							center_cord3D(iEE, nvtx, pa, pointP, EE_SIDE);
							//printf("iEE");
							//system("pause");
							positionxEE = pointP.x;
							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iE];
							ib_3 = whot_is_block[iEE];

							bool bfoundE = false;


							if ((!bW) && (iW > -1)) {

								ib_4 = whot_is_block[iW];
								bfoundE = true;
							}
							else if ((!bW2) && (iW2 > -1)) {

								ib_4 = whot_is_block[iW2];
								bfoundE = true;
							}
							else if ((!bW3) && (iW3 > -1)) {

								ib_4 = whot_is_block[iW3];
								bfoundE = true;
							}
							else if ((!bW4) && (iW4 > -1)) {

								ib_4 = whot_is_block[iW4];
								bfoundE = true;
							}

							
							if ((bfoundE) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiEE = 0.0;
									berrE = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iE];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrE = true;
							}

							// граничный узел
							if ((iEE >= maxelm) && (iEE < maxelm + maxbound)) {
								FiEE = potent[iEE];
							}
							else {
								FiEE = FiE;
							}
							volume3D(iE, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionxEE = positionxE + 0.5 * pointP.x;
						}
					}
					else {
						// это граничный узел
						FiE = potent[iE];
						FiEE = potent[iE];
						positionxe = positionxP + 0.5 * dx;
						positionxE = positionxP + 0.5 * dx;
						positionxEE = positionxP + dx; // этого узла не существует !
					}

					if ((!bW)&&(iW > -1)) {
						center_cord3D(iW, nvtx, pa, pointP, W_SIDE);
						//printf("iW");
						//system("pause");
						positionxW = pointP.x;
						positionxw = positionxP - 0.5 * dx;
						FiW = potent[iW];

						integer iWW = neighbors_for_the_internal_node[W_SIDE][0][iW];
						if (iWW < 0) {
							iWW = neighbors_for_the_internal_node[W_SIDE][1][iW];
						}
						if (iWW < 0) {
							iWW = neighbors_for_the_internal_node[W_SIDE][2][iW];
						}
						if (iWW < 0) {
							iWW = neighbors_for_the_internal_node[W_SIDE][3][iW];
						}

						if ((iWW >= 0) && (iWW < maxelm)) {
							// внутренний узел
							FiWW = potent[iWW];
							center_cord3D(iWW, nvtx, pa, pointP, WW_SIDE);
							//printf("iWW");
							//system("pause");
							positionxWW = pointP.x;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iW];
							ib_3 = whot_is_block[iWW];

							bool bfoundW = false;


							if ((!bE) && (iE > -1)) {

								ib_4 = whot_is_block[iE];
								bfoundW = true;
							}
							else if ((!bE2) && (iE2 > -1)) {

								ib_4 = whot_is_block[iE2];
								bfoundW = true;
							}
							else if ((!bE3) && (iE3 > -1)) {

								ib_4 = whot_is_block[iE3];
								bfoundW = true;
							}
							else if ((!bE4) && (iE4 > -1)) {

								ib_4 = whot_is_block[iE4];
								bfoundW = true;
							}

							if ((bfoundW) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiWW = 0.0;
									berrW = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iW];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrW = true;
							}

							// граничный узел
							if ((iWW >= maxelm) && (iWW < maxelm + maxbound)) {
								FiWW = potent[iWW];
							}
							else {
								FiWW = FiW;
							}
							volume3D(iW, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionxWW = positionxW - 0.5 * pointP.x;
						}
					}
					else {
						// это граничный узел
						FiW = potent[iW];
						FiWW = potent[iW];
						positionxw = positionxP - 0.5 * dx;
						positionxW = positionxP - 0.5 * dx;
						positionxWW = positionxP - dx; // этого узла не существует !
					}

					// Y - direction
					if ((!bN)&&(iN > -1 )) {
						FiN = potent[iN];
						center_cord3D(iN, nvtx, pa, pointP, N_SIDE);
						//printf("iN");
						//system("pause");
						positionyN = pointP.y;
						positionyn = positionxP + 0.5 * dy;

						integer iNN = neighbors_for_the_internal_node[N_SIDE][0][iN];
						if (iNN < 0) {
							iNN = neighbors_for_the_internal_node[N_SIDE][1][iN];
						}
						if (iNN < 0) {
							iNN = neighbors_for_the_internal_node[N_SIDE][2][iN];
						}
						if (iNN < 0) {
							iNN = neighbors_for_the_internal_node[N_SIDE][3][iN];
						}

						if ((iNN >= 0) && (iNN < maxelm)) {
							// внутренний узел
							FiNN = potent[iNN];
							center_cord3D(iNN, nvtx, pa, pointP, NN_SIDE);
							//printf("iNN");
							//system("pause");
							positionyNN = pointP.y;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iN];
							ib_3 = whot_is_block[iNN];

							bool bfoundN = false;


							if ((!bS) && (iS > -1)) {

								ib_4 = whot_is_block[iS];
								bfoundN = true;
							}
							else if ((!bS2) && (iS2 > -1)) {

								ib_4 = whot_is_block[iS2];
								bfoundN = true;
							}
							else if ((!bS3) && (iS3 > -1)) {

								ib_4 = whot_is_block[iS3];
								bfoundN = true;
							}
							else if ((!bS4) && (iS4 > -1)) {

								ib_4 = whot_is_block[iS4];
								bfoundN = true;
							}

							
							if ((bfoundN) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiNN = 0.0;
									berrN = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iN];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrN = true;
							}

							// граничный узел
							if ((iNN >= maxelm) && (iNN < maxelm + maxbound)) {
								FiNN = potent[iNN];
							}
							else {
								FiNN = FiN;
							}
							volume3D(iN, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionyNN = positionyN + 0.5 * pointP.y;
						}
					}
					else {
						// это граничный узел
						FiN = potent[iN];
						FiNN = potent[iN];
						positionyn = positionyP + 0.5 * dy;
						positionyN = positionyP + 0.5 * dy;
						positionyNN = positionyP + dy; // этого узла не существует !
					}

					if ((!bS)&&(iS > -1)) {
						FiS = potent[iS];
						center_cord3D(iS, nvtx, pa, pointP, S_SIDE);
						//printf("iS");
						//system("pause");
						positionyS = pointP.y;
						positionys = positionyP - 0.5 * dy;

						integer iSS = neighbors_for_the_internal_node[S_SIDE][0][iS];
						if (iSS < 0) {
							iSS = neighbors_for_the_internal_node[S_SIDE][1][iS];
						}
						if (iSS < 0) {
							iSS = neighbors_for_the_internal_node[S_SIDE][2][iS];
						}
						if (iSS < 0) {
							iSS = neighbors_for_the_internal_node[S_SIDE][3][iS];
						}

						if ((iSS >= 0) && (iSS < maxelm)) {
							// внутренний узел
							FiSS = potent[iSS];
							center_cord3D(iSS, nvtx, pa, pointP, SS_SIDE);
							//printf("iSS");
							//system("pause");
							positionySS = pointP.y;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iS];
							ib_3 = whot_is_block[iSS];

							bool bfoundS = false;


							if ((!bN) && (iN > -1)) {

								ib_4 = whot_is_block[iN];
								bfoundS = true;
							}
							else if ((!bN2) && (iN2 > -1)) {

								ib_4 = whot_is_block[iN2];
								bfoundS = true;
							}
							else if ((!bN3) && (iN3 > -1)) {

								ib_4 = whot_is_block[iN3];
								bfoundS = true;
							}
							else if ((!bN4) && (iN4 > -1)) {

								ib_4 = whot_is_block[iN4];
								bfoundS = true;
							}

							
							if ((bfoundS) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiSS = 0.0;
									berrS = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iS];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrS = true;
							}

							// граничный узел
							if ((iSS >= maxelm) && (iSS < maxelm + maxbound)) {
								FiSS = potent[iSS];
							}
							else {
								FiSS = FiS;
							}
							volume3D(iS, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionySS = positionyS - 0.5 * pointP.y;
						}
					}
					else {
						// это граничный узел
						FiS = potent[iS]; // ATTANTION !!!! 
						FiSS = potent[iS]; // нулевая скорость внутри твёрдого тела.
						positionys = positionyP - 0.5 * dy;
						positionyS = positionyP - 0.5 * dy;
						positionySS = positionyP - dy; // этого узла не существует !
					}

					// Z - direction
					if ((!bT)&&(iT > -1)) {
						FiT = potent[iT];
						center_cord3D(iT, nvtx, pa, pointP, T_SIDE);
						//printf("iT");
						//system("pause");
						positionzT = pointP.z;
						positionzt = positionzP + 0.5 * dz;

						integer iTT = neighbors_for_the_internal_node[T_SIDE][0][iT];
						if (iTT < 0) {
							iTT = neighbors_for_the_internal_node[T_SIDE][1][iT];
						}
						if (iTT < 0) {
							iTT = neighbors_for_the_internal_node[T_SIDE][2][iT];
						}
						if (iTT < 0) {
							iTT = neighbors_for_the_internal_node[T_SIDE][3][iT];
						}


						if ((iTT >= 0) && (iTT < maxelm)) {
							// внутренний узел
							FiTT = potent[iTT];
							center_cord3D(iTT, nvtx, pa, pointP, TT_SIDE);
							//printf("iTT");
							//system("pause");
							positionzTT = pointP.z;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iT];
							ib_3 = whot_is_block[iTT];

							bool bfoundT = false;


							if ((!bB) && (iB > -1)) {

								ib_4 = whot_is_block[iB];
								bfoundT = true;
							}
							else if ((!bB2) && (iB2 > -1)) {

								ib_4 = whot_is_block[iB2];
								bfoundT = true;
							}
							else if ((!bB3) && (iB3 > -1)) {

								ib_4 = whot_is_block[iB3];
								bfoundT = true;
							}
							else if ((!bB4) && (iB4 > -1)) {

								ib_4 = whot_is_block[iB4];
								bfoundT = true;
							}


							
							if ((bfoundT) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiTT = 0.0;
									berrT = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iT];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrT = true;
							}
							// граничный узел
							if ((iTT >= maxelm) && (iTT < maxelm + maxbound)) {
								FiTT = potent[iTT];
							}
							else {
								FiTT = FiT;
							}
							volume3D(iT, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionzTT = positionzT + 0.5 * pointP.z;
						}
					}
					else {
						// это граничный узел
						FiT = potent[iT];
						FiTT = potent[iT]; // скорость внутри твёрдого тела
						positionzt = positionzP + 0.5 * dz;
						positionzT = positionzP + 0.5 * dz;
						positionzTT = positionzP + dz; // этого узла не существует !
					}

					if ((!bB)&&(iB > -1)) {
						FiB = potent[iB];
						center_cord3D(iB, nvtx, pa, pointP, B_SIDE);
						//printf("iB");
						//system("pause");
						positionzB = pointP.z;
						positionzb = positionzP - 0.5 * dz;

						integer iBB = neighbors_for_the_internal_node[B_SIDE][0][iB];
						if (iBB < 0) {
							iBB = neighbors_for_the_internal_node[B_SIDE][1][iB];
						}
						if (iBB < 0) {
							iBB = neighbors_for_the_internal_node[B_SIDE][2][iB];
						}
						if (iBB < 0) {
							iBB = neighbors_for_the_internal_node[B_SIDE][3][iB];
						}

						if ((iBB >= 0) && (iBB < maxelm)) {
							// внутренний узел
							FiBB = potent[iBB];
							center_cord3D(iBB, nvtx, pa, pointP, BB_SIDE);
							//printf("iBB");
							//system("pause");
							positionzBB = pointP.z;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iB];
							ib_3 = whot_is_block[iBB];

							bool bfoundB = false;


							if ((!bT) && (iT > -1)) {

								ib_4 = whot_is_block[iT];
								bfoundB = true;
							}
							else if ((!bT2) && (iT2 > -1)) {

								ib_4 = whot_is_block[iT2];
								bfoundB = true;
							}
							else if ((!bT3) && (iT3 > -1)) {

								ib_4 = whot_is_block[iT3];
								bfoundB = true;
							}
							else if ((!bT4) && (iT4 > -1)) {

								ib_4 = whot_is_block[iT4];
								bfoundB = true;
							}

							
							if ((bfoundB) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiBB = 0.0;
									berrB = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iB];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrB = true;
							}
							// граничный узел
							if ((iBB >= maxelm) && (iBB < maxelm + maxbound)) {
								FiBB = potent[iBB];
							}
							else {
								FiBB = FiB;
							}
							volume3D(iB, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionzBB = positionzB - 0.5 * pointP.z;
						}
					}
					else {
						// это граничный узел
						FiB = potent[iB];
						FiBB = potent[iB]; // скорость внутри твёрдого тела
						positionzb = positionzP - 0.5 * dz;
						positionzB = positionzP - 0.5 * dz;
						positionzBB = positionzP - dz; // этого узла не существует !
					}


					// X - direction
					if ((!bE2) && (iE2 > -1)) {
						FiE2 = potent[iE2];
						center_cord3D(iE2, nvtx, pa, pointP, E_SIDE);
						//printf("iE");
						//system("pause");
						positionxE2 = pointP.x;
						positionxe2 = positionxP + 0.5 * dx;

						integer iEE2 = neighbors_for_the_internal_node[E_SIDE][0][iE2];
						if (iEE2 < 0) {
							iEE2 = neighbors_for_the_internal_node[E_SIDE][1][iE2];
						}
						if (iEE2 < 0) {
							iEE2 = neighbors_for_the_internal_node[E_SIDE][2][iE2];
						}
						if (iEE2 < 0) {
							iEE2 = neighbors_for_the_internal_node[E_SIDE][3][iE2];
						}


						if ((iEE2 >= 0) && (iEE2 < maxelm)) {
							// внутренний узел
							FiEE2 = potent[iEE2];
							center_cord3D(iEE2, nvtx, pa, pointP, EE_SIDE);
							//printf("iEE");
							//system("pause");
							positionxEE2 = pointP.x;
							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iE2];
							ib_3 = whot_is_block[iEE2];
							bool bfoundW = false;


							if ((!bW) && (iW > -1)) {

								ib_4 = whot_is_block[iW];
								bfoundW = true;
							}
							else if ((!bW2) && (iW2 > -1)) {

								ib_4 = whot_is_block[iW2];
								bfoundW = true;
							}
							else if ((!bW3) && (iW3 > -1)) {

								ib_4 = whot_is_block[iW3];
								bfoundW = true;
							}
							else if ((!bW4) && (iW4 > -1)) {

								ib_4 = whot_is_block[iW4];
								bfoundW = true;
							}

							if ((bfoundW) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiEE2 = 0.0;
									berrE2 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iE2];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrE2 = true;
							}

							// граничный узел
							if ((iEE2 >= maxelm) && (iEE2 < maxelm + maxbound)) {
								FiEE2 = potent[iEE2];
							}
							else {
								FiEE2 = FiE2;
							}
							volume3D(iE2, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionxEE2 = positionxE2 + 0.5 * pointP.x;
						}
					}
					else {
						// это граничный узел
						if (iE2 > -1) {
							FiE2 = potent[iE2];
							FiEE2 = potent[iE2];
						}
						else {
							FiE2 = potent[iE];
							FiEE2 = potent[iE];
						}
						positionxe2 = positionxP + 0.5 * dx;
						positionxE2 = positionxP + 0.5 * dx;
						positionxEE2 = positionxP + dx; // этого узла не существует !
					}

					if ((!bE3) && (iE3 > -1)) {
						FiE3 = potent[iE3];
						center_cord3D(iE3, nvtx, pa, pointP, E_SIDE);
						//printf("iE");
						//system("pause");
						positionxE3 = pointP.x;
						positionxe3 = positionxP + 0.5 * dx;

						integer iEE3 = neighbors_for_the_internal_node[E_SIDE][0][iE3];
						if (iEE3 < 0) {
							iEE3 = neighbors_for_the_internal_node[E_SIDE][1][iE3];
						}
						if (iEE3 < 0) {
							iEE3 = neighbors_for_the_internal_node[E_SIDE][2][iE3];
						}
						if (iEE3 < 0) {
							iEE3 = neighbors_for_the_internal_node[E_SIDE][3][iE3];
						}


						if ((iEE3 >= 0) && (iEE3 < maxelm)) {
							// внутренний узел
							FiEE3 = potent[iEE3];
							center_cord3D(iEE3, nvtx, pa, pointP, EE_SIDE);
							//printf("iEE");
							//system("pause");
							positionxEE3 = pointP.x;
							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iE3];
							ib_3 = whot_is_block[iEE3];
							bool bfoundW = false;


							if ((!bW) && (iW > -1)) {

								ib_4 = whot_is_block[iW];
								bfoundW = true;
							}
							else if ((!bW2) && (iW2 > -1)) {

								ib_4 = whot_is_block[iW2];
								bfoundW = true;
							}
							else if ((!bW3) && (iW3 > -1)) {

								ib_4 = whot_is_block[iW3];
								bfoundW = true;
							}
							else if ((!bW4) && (iW4 > -1)) {

								ib_4 = whot_is_block[iW4];
								bfoundW = true;
							}

							if ((bfoundW) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiEE3 = 0.0;
									berrE3 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iE3];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrE3 = true;
							}

							// граничный узел
							if ((iEE3 >= maxelm) && (iEE3 < maxelm + maxbound)) {
								FiEE3 = potent[iEE3];
							}
							else {
								FiEE3 = FiE3;
							}
							volume3D(iE3, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionxEE3 = positionxE3 + 0.5 * pointP.x;
						}
					}
					else {
						// это граничный узел
						if (iE3 > -1) {
							FiE3 = potent[iE3];
							FiEE3 = potent[iE3];
						}
						else {
							FiE3 = potent[iE];
							FiEE3 = potent[iE];
						}
						positionxe3 = positionxP + 0.5 * dx;
						positionxE3 = positionxP + 0.5 * dx;
						positionxEE3 = positionxP + dx; // этого узла не существует !
					}


					if ((!bE4) && (iE4 > -1)) {
						FiE4 = potent[iE4];
						center_cord3D(iE4, nvtx, pa, pointP, E_SIDE);
						//printf("iE");
						//system("pause");
						positionxE4 = pointP.x;
						positionxe4 = positionxP + 0.5 * dx;

						integer iEE4 = neighbors_for_the_internal_node[E_SIDE][0][iE4];
						if (iEE4 < 0) {
							iEE4 = neighbors_for_the_internal_node[E_SIDE][1][iE4];
						}
						if (iEE4 < 0) {
							iEE4 = neighbors_for_the_internal_node[E_SIDE][2][iE4];
						}
						if (iEE4 < 0) {
							iEE4 = neighbors_for_the_internal_node[E_SIDE][3][iE4];
						}


						if ((iEE4 >= 0) && (iEE4 < maxelm)) {
							// внутренний узел
							FiEE4 = potent[iEE4];
							center_cord3D(iEE4, nvtx, pa, pointP, EE_SIDE);
							//printf("iEE");
							//system("pause");
							positionxEE4 = pointP.x;
							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iE4];
							ib_3 = whot_is_block[iEE4];
							bool bfoundW = false;


							if ((!bW) && (iW > -1)) {

								ib_4 = whot_is_block[iW];
								bfoundW = true;
							}
							else if ((!bW2) && (iW2 > -1)) {

								ib_4 = whot_is_block[iW2];
								bfoundW = true;
							}
							else if ((!bW3) && (iW3 > -1)) {

								ib_4 = whot_is_block[iW3];
								bfoundW = true;
							}
							else if ((!bW4) && (iW4 > -1)) {

								ib_4 = whot_is_block[iW4];
								bfoundW = true;
							}

							if ((bfoundW) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiEE2 = 0.0;
									berrE4 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iE4];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrE4 = true;
							}

							// граничный узел
							if ((iEE4 >= maxelm) && (iEE4 < maxelm + maxbound)) {
								FiEE4 = potent[iEE4];
							}
							else {
								FiEE4 = FiE4;
							}
							volume3D(iE4, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionxEE4 = positionxE4 + 0.5 * pointP.x;
						}
					}
					else {
						// это граничный узел
						if (iE4 > -1) {
							FiE4 = potent[iE4];
							FiEE4 = potent[iE4];
						}
						else {
							FiE4 = potent[iE];
							FiEE4 = potent[iE];
						}
						positionxe4 = positionxP + 0.5 * dx;
						positionxE4 = positionxP + 0.5 * dx;
						positionxEE4 = positionxP + dx; // этого узла не существует !
					}


					if ((!bW2) && (iW2 > -1)) {
						center_cord3D(iW2, nvtx, pa, pointP, W_SIDE);
						//printf("iW");
						//system("pause");
						positionxW2 = pointP.x;
						positionxw2 = positionxP - 0.5 * dx;
						FiW2 = potent[iW2];

						integer iWW2 = neighbors_for_the_internal_node[W_SIDE][0][iW2];
						if (iWW2 < 0) {
							iWW2 = neighbors_for_the_internal_node[W_SIDE][1][iW2];
						}
						if (iWW2 < 0) {
							iWW2 = neighbors_for_the_internal_node[W_SIDE][2][iW2];
						}
						if (iWW2 < 0) {
							iWW2 = neighbors_for_the_internal_node[W_SIDE][3][iW2];
						}

						if ((iWW2 >= 0) && (iWW2 < maxelm)) {
							// внутренний узел
							FiWW2 = potent[iWW2];
							center_cord3D(iWW2, nvtx, pa, pointP, WW_SIDE);
							//printf("iWW");
							//system("pause");
							positionxWW2 = pointP.x;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iW2];
							ib_3 = whot_is_block[iWW2];
							bool bfoundE = false;


							if ((!bE) && (iE > -1)) {

								ib_4 = whot_is_block[iE];
								bfoundE = true;
							}
							else if ((!bE2) && (iE2 > -1)) {

								ib_4 = whot_is_block[iE2];
								bfoundE = true;
							}
							else if ((!bE3) && (iE3 > -1)) {

								ib_4 = whot_is_block[iE3];
								bfoundE = true;
							}
							else if ((!bE4) && (iE4 > -1)) {

								ib_4 = whot_is_block[iE4];
								bfoundE = true;
							}
							

							
							if ((bfoundE) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiWW2 = 0.0;
									berrW2 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iW2];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrW2 = true;
							}

							// граничный узел
							if ((iWW2 >= maxelm) && (iWW2 < maxelm + maxbound)) {
								FiWW2 = potent[iWW2];
							}
							else {
								FiWW2 = FiW2;
							}
							volume3D(iW2, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionxWW2 = positionxW2 - 0.5 * pointP.x;
						}
					}
					else {
						// это граничный узел
						if (iW2 > -1) {
							FiW2 = potent[iW2];
							FiWW2 = potent[iW2];
						}
						else {
							FiW2 = potent[iW];
							FiWW2 = potent[iW];
						}
						positionxw2 = positionxP - 0.5 * dx;
						positionxW2 = positionxP - 0.5 * dx;
						positionxWW2 = positionxP - dx; // этого узла не существует !
					}


					if ((!bW3) && (iW3 > -1)) {
						center_cord3D(iW3, nvtx, pa, pointP, W_SIDE);
						//printf("iW");
						//system("pause");
						positionxW3 = pointP.x;
						positionxw3 = positionxP - 0.5 * dx;
						FiW3 = potent[iW3];

						integer iWW3 = neighbors_for_the_internal_node[W_SIDE][0][iW3];
						if (iWW3 < 0) {
							iWW3 = neighbors_for_the_internal_node[W_SIDE][1][iW3];
						}
						if (iWW3 < 0) {
							iWW3 = neighbors_for_the_internal_node[W_SIDE][2][iW3];
						}
						if (iWW3 < 0) {
							iWW3 = neighbors_for_the_internal_node[W_SIDE][3][iW3];
						}

						if ((iWW3 >= 0) && (iWW3 < maxelm)) {
							// внутренний узел
							FiWW3 = potent[iWW3];
							center_cord3D(iWW3, nvtx, pa, pointP, WW_SIDE);
							//printf("iWW3");
							//system("pause");
							positionxWW3 = pointP.x;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iW3];
							ib_3 = whot_is_block[iWW3];
							bool bfoundE = false;


							if ((!bE) && (iE > -1)) {

								ib_4 = whot_is_block[iE];
								bfoundE = true;
							}
							else if ((!bE2) && (iE2 > -1)) {

								ib_4 = whot_is_block[iE2];
								bfoundE = true;
							}
							else if ((!bE3) && (iE3 > -1)) {

								ib_4 = whot_is_block[iE3];
								bfoundE = true;
							}
							else if ((!bE4) && (iE4 > -1)) {

								ib_4 = whot_is_block[iE4];
								bfoundE = true;
							}



							if ((bfoundE) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiWW3 = 0.0;
									berrW3 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iW3];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrW3 = true;
							}

							// граничный узел
							if ((iWW3 >= maxelm) && (iWW3 < maxelm + maxbound)) {
								FiWW3 = potent[iWW3];
							}
							else {
								FiWW3 = FiW3;
							}
							volume3D(iW3, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionxWW3 = positionxW3 - 0.5 * pointP.x;
						}
					}
					else {
						// это граничный узел
						if (iW3 > -1) {
							FiW3 = potent[iW3];
							FiWW3 = potent[iW3];
						}
						else {
							FiW3 = potent[iW];
							FiWW3 = potent[iW];
						}
						positionxw3 = positionxP - 0.5 * dx;
						positionxW3 = positionxP - 0.5 * dx;
						positionxWW3 = positionxP - dx; // этого узла не существует !
					}

					if ((!bW4) && (iW4 > -1)) {
						center_cord3D(iW4, nvtx, pa, pointP, W_SIDE);
						//printf("iW");
						//system("pause");
						positionxW4 = pointP.x;
						positionxw4 = positionxP - 0.5 * dx;
						FiW4 = potent[iW4];

						integer iWW4 = neighbors_for_the_internal_node[W_SIDE][0][iW4];
						if (iWW4 < 0) {
							iWW4 = neighbors_for_the_internal_node[W_SIDE][1][iW4];
						}
						if (iWW4 < 0) {
							iWW4 = neighbors_for_the_internal_node[W_SIDE][2][iW4];
						}
						if (iWW4 < 0) {
							iWW4 = neighbors_for_the_internal_node[W_SIDE][3][iW4];
						}

						if ((iWW4 >= 0) && (iWW4 < maxelm)) {
							// внутренний узел
							FiWW4 = potent[iWW4];
							center_cord3D(iWW4, nvtx, pa, pointP, WW_SIDE);
							//printf("iWW");
							//system("pause");
							positionxWW4 = pointP.x;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iW4];
							ib_3 = whot_is_block[iWW4];
							bool bfoundE = false;


							if ((!bE) && (iE > -1)) {

								ib_4 = whot_is_block[iE];
								bfoundE = true;
							}
							else if ((!bE2) && (iE2 > -1)) {

								ib_4 = whot_is_block[iE2];
								bfoundE = true;
							}
							else if ((!bE3) && (iE3 > -1)) {

								ib_4 = whot_is_block[iE3];
								bfoundE = true;
							}
							else if ((!bE4) && (iE4 > -1)) {

								ib_4 = whot_is_block[iE4];
								bfoundE = true;
							}



							if ((bfoundE) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiWW4 = 0.0;
									berrW4 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iW4];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrW4 = true;
							}

							// граничный узел
							if ((iWW4 >= maxelm) && (iWW4 < maxelm + maxbound)) {
								FiWW4 = potent[iWW4];
							}
							else {
								FiWW4 = FiW4;
							}
							volume3D(iW4, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionxWW4 = positionxW4 - 0.5 * pointP.x;
						}
					}
					else {
						// это граничный узел
						if (iW4 > -1) {
							FiW4 = potent[iW4];
							FiWW4 = potent[iW4];
						}
						else {
							FiW4 = potent[iW];
							FiWW4 = potent[iW];
						}
						positionxw4 = positionxP - 0.5 * dx;
						positionxW4 = positionxP - 0.5 * dx;
						positionxWW4 = positionxP - dx; // этого узла не существует !
					}


					// Y - direction
					if ((!bN2) && (iN2 > -1)) {
						FiN2 = potent[iN2];
						center_cord3D(iN2, nvtx, pa, pointP, N_SIDE);
						//printf("iN2");
						//system("pause");
						positionyN2 = pointP.y;
						positionyn2 = positionxP + 0.5 * dy;

						integer iNN2 = neighbors_for_the_internal_node[N_SIDE][0][iN2];
						if (iNN2 < 0) {
							iNN2 = neighbors_for_the_internal_node[N_SIDE][1][iN2];
						}
						if (iNN2 < 0) {
							iNN2 = neighbors_for_the_internal_node[N_SIDE][2][iN2];
						}
						if (iNN2 < 0) {
							iNN2 = neighbors_for_the_internal_node[N_SIDE][3][iN2];
						}

						if ((iNN2 >= 0) && (iNN2 < maxelm)) {
							// внутренний узел
							FiNN2 = potent[iNN2];
							center_cord3D(iNN2, nvtx, pa, pointP, NN_SIDE);
							//printf("iNN2");
							//system("pause");
							positionyNN2 = pointP.y;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iN2];
							ib_3 = whot_is_block[iNN2];

							bool bfoundN = false;


							if ((!bS) && (iS > -1)) {

								ib_4 = whot_is_block[iS];
								bfoundN = true;
							}
							else if ((!bS2) && (iS2 > -1)) {

								ib_4 = whot_is_block[iS2];
								bfoundN = true;
							}
							else if ((!bS3) && (iS3 > -1)) {

								ib_4 = whot_is_block[iS3];
								bfoundN = true;
							}
							else if ((!bS4) && (iS4 > -1)) {

								ib_4 = whot_is_block[iS4];
								bfoundN = true;
							}
							

							
							if ((bfoundN) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiNN = 0.0;
									berrN2 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iN2];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrN2 = true;
							}

							// граничный узел
							if ((iNN2 >= maxelm) && (iNN2 < maxelm + maxbound)) {
								FiNN2 = potent[iNN2];
							}
							else {
								FiNN2 = FiN2;
							}
							volume3D(iN2, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionyNN2 = positionyN2 + 0.5 * pointP.y;
						}
					}
					else {
						// это граничный узел
						if (iN2 > -1) {
							FiN2 = potent[iN2];
							FiNN2 = potent[iN2];
						}
						else {
							FiN2 = potent[iN];
							FiNN2 = potent[iN];
						}
						positionyn2 = positionyP + 0.5 * dy;
						positionyN2 = positionyP + 0.5 * dy;
						positionyNN2 = positionyP + dy; // этого узла не существует !
					}

					if ((!bN3) && (iN3 > -1)) {
						FiN3 = potent[iN3];
						center_cord3D(iN3, nvtx, pa, pointP, N_SIDE);
						//printf("iN3");
						//system("pause");
						positionyN3 = pointP.y;
						positionyn3 = positionxP + 0.5 * dy;

						integer iNN3 = neighbors_for_the_internal_node[N_SIDE][0][iN3];
						if (iNN3 < 0) {
							iNN3 = neighbors_for_the_internal_node[N_SIDE][1][iN3];
						}
						if (iNN3 < 0) {
							iNN3 = neighbors_for_the_internal_node[N_SIDE][2][iN3];
						}
						if (iNN3 < 0) {
							iNN3 = neighbors_for_the_internal_node[N_SIDE][3][iN3];
						}

						if ((iNN3 >= 0) && (iNN3 < maxelm)) {
							// внутренний узел
							FiNN3 = potent[iNN3];
							center_cord3D(iNN3, nvtx, pa, pointP, NN_SIDE);
							//printf("iNN3");
							//system("pause");
							positionyNN3 = pointP.y;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iN3];
							ib_3 = whot_is_block[iNN3];

							bool bfoundN = false;


							if ((!bS) && (iS > -1)) {

								ib_4 = whot_is_block[iS];
								bfoundN = true;
							}
							else if ((!bS2) && (iS2 > -1)) {

								ib_4 = whot_is_block[iS2];
								bfoundN = true;
							}
							else if ((!bS3) && (iS3 > -1)) {

								ib_4 = whot_is_block[iS3];
								bfoundN = true;
							}
							else if ((!bS4) && (iS4 > -1)) {

								ib_4 = whot_is_block[iS4];
								bfoundN = true;
							}



							if ((bfoundN) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiNN = 0.0;
									berrN3 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iN3];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrN3 = true;
							}

							// граничный узел
							if ((iNN3 >= maxelm) && (iNN3 < maxelm + maxbound)) {
								FiNN3 = potent[iNN3];
							}
							else {
								FiNN3 = FiN3;
							}
							volume3D(iN3, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionyNN3 = positionyN3 + 0.5 * pointP.y;
						}
					}
					else {
						// это граничный узел
						if (iN3 > -1) {
							FiN3 = potent[iN3];
							FiNN3 = potent[iN3];
						}
						else {
							FiN3 = potent[iN];
							FiNN3 = potent[iN];
						}
						positionyn3 = positionyP + 0.5 * dy;
						positionyN3 = positionyP + 0.5 * dy;
						positionyNN3 = positionyP + dy; // этого узла не существует !
					}


					if ((!bN4) && (iN4 > -1)) {
						FiN4 = potent[iN4];
						center_cord3D(iN4, nvtx, pa, pointP, N_SIDE);
						//printf("iN4");
						//system("pause");
						positionyN4 = pointP.y;
						positionyn4 = positionxP + 0.5 * dy;

						integer iNN4 = neighbors_for_the_internal_node[N_SIDE][0][iN4];
						if (iNN4 < 0) {
							iNN4 = neighbors_for_the_internal_node[N_SIDE][1][iN4];
						}
						if (iNN4 < 0) {
							iNN4 = neighbors_for_the_internal_node[N_SIDE][2][iN4];
						}
						if (iNN4 < 0) {
							iNN4 = neighbors_for_the_internal_node[N_SIDE][3][iN4];
						}

						if ((iNN4 >= 0) && (iNN4 < maxelm)) {
							// внутренний узел
							FiNN4 = potent[iNN4];
							center_cord3D(iNN4, nvtx, pa, pointP, NN_SIDE);
							//printf("iNN4");
							//system("pause");
							positionyNN4 = pointP.y;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iN4];
							ib_3 = whot_is_block[iNN4];

							bool bfoundN = false;


							if ((!bS) && (iS > -1)) {

								ib_4 = whot_is_block[iS];
								bfoundN = true;
							}
							else if ((!bS2) && (iS2 > -1)) {

								ib_4 = whot_is_block[iS2];
								bfoundN = true;
							}
							else if ((!bS3) && (iS3 > -1)) {

								ib_4 = whot_is_block[iS3];
								bfoundN = true;
							}
							else if ((!bS4) && (iS4 > -1)) {

								ib_4 = whot_is_block[iS4];
								bfoundN = true;
							}



							if ((bfoundN) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiNN4 = 0.0;
									berrN4 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iN4];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrN4 = true;
							}

							// граничный узел
							if ((iNN4 >= maxelm) && (iNN4 < maxelm + maxbound)) {
								FiNN4 = potent[iNN4];
							}
							else {
								FiNN4 = FiN4;
							}
							volume3D(iN4, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionyNN4 = positionyN4 + 0.5 * pointP.y;
						}
					}
					else {
						// это граничный узел
						if (iN4 > -1) {
							FiN4 = potent[iN4];
							FiNN4 = potent[iN4];
						}
						else {
							FiN4 = potent[iN];
							FiNN4 = potent[iN];
						}
						positionyn4 = positionyP + 0.5 * dy;
						positionyN4 = positionyP + 0.5 * dy;
						positionyNN4 = positionyP + dy; // этого узла не существует !
					}



					if ((!bS2) && (iS2 > -1)) {
						FiS2 = potent[iS2];
						center_cord3D(iS2, nvtx, pa, pointP, S_SIDE);
						//printf("iS2");
						//system("pause");
						positionyS2 = pointP.y;
						positionys2 = positionyP - 0.5 * dy;

						integer iSS2 = neighbors_for_the_internal_node[S_SIDE][0][iS2];
						if (iSS2 < 0) {
							iSS2 = neighbors_for_the_internal_node[S_SIDE][1][iS2];
						}
						if (iSS2 < 0) {
							iSS2 = neighbors_for_the_internal_node[S_SIDE][2][iS2];
						}
						if (iSS2 < 0) {
							iSS2 = neighbors_for_the_internal_node[S_SIDE][3][iS2];
						}

						if ((iSS2 >= 0) && (iSS2 < maxelm)) {
							// внутренний узел
							FiSS2 = potent[iSS2];
							center_cord3D(iSS2, nvtx, pa, pointP, SS_SIDE);
							//printf("iSS2");
							//system("pause");
							positionySS2 = pointP.y;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iS2];
							ib_3 = whot_is_block[iSS2];

							bool bfoundS = false;


							if ((!bN) && (iN > -1)) {

								ib_4 = whot_is_block[iN];
								bfoundS = true;
							}
							else if ((!bN2) && (iN2 > -1)) {

								ib_4 = whot_is_block[iN2];
								bfoundS = true;
							}
							else if ((!bN3) && (iN3 > -1)) {

								ib_4 = whot_is_block[iN3];
								bfoundS = true;
							}
							else if ((!bN4) && (iN4 > -1)) {

								ib_4 = whot_is_block[iN4];
								bfoundS = true;
							}
							

							
							if ((bfoundS) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiSS2 = 0.0;
									berrS2 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iS2];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrS2 = true;
							}

							// граничный узел
							if ((iSS2 >= maxelm) && (iSS2 < maxelm + maxbound)) {
								FiSS2 = potent[iSS2];
							}
							else {
								FiSS2 = FiS2;
							}
							volume3D(iS2, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionySS2 = positionyS2 - 0.5 * pointP.y;
						}
					}
					else {
						// это граничный узел
						if (iS2 > -1) {
							FiS2 = potent[iS2]; // ATTANTION !!!! 
							FiSS2 = potent[iS2]; // нулевая скорость внутри твёрдого тела.
						}
						else {
							FiS2 = potent[iS]; // ATTANTION !!!! 
							FiSS2 = potent[iS]; // нулевая скорость внутри твёрдого тела.
						}
						positionys2 = positionyP - 0.5 * dy;
						positionyS2 = positionyP - 0.5 * dy;
						positionySS2 = positionyP - dy; // этого узла не существует !
					}


					if ((!bS3) && (iS3 > -1)) {
						FiS3 = potent[iS3];
						center_cord3D(iS3, nvtx, pa, pointP, S_SIDE);
						//printf("iS3");
						//system("pause");
						positionyS3 = pointP.y;
						positionys3 = positionyP - 0.5 * dy;

						integer iSS3 = neighbors_for_the_internal_node[S_SIDE][0][iS3];
						if (iSS3 < 0) {
							iSS3 = neighbors_for_the_internal_node[S_SIDE][1][iS3];
						}
						if (iSS3 < 0) {
							iSS3 = neighbors_for_the_internal_node[S_SIDE][2][iS3];
						}
						if (iSS3 < 0) {
							iSS3 = neighbors_for_the_internal_node[S_SIDE][3][iS3];
						}

						if ((iSS3 >= 0) && (iSS3 < maxelm)) {
							// внутренний узел
							FiSS3 = potent[iSS3];
							center_cord3D(iSS3, nvtx, pa, pointP, SS_SIDE);
							//printf("iSS3");
							//system("pause");
							positionySS3 = pointP.y;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iS3];
							ib_3 = whot_is_block[iSS3];

							bool bfoundS = false;


							if ((!bN) && (iN > -1)) {

								ib_4 = whot_is_block[iN];
								bfoundS = true;
							}
							else if ((!bN2) && (iN2 > -1)) {

								ib_4 = whot_is_block[iN2];
								bfoundS = true;
							}
							else if ((!bN3) && (iN3 > -1)) {

								ib_4 = whot_is_block[iN3];
								bfoundS = true;
							}
							else if ((!bN4) && (iN4 > -1)) {

								ib_4 = whot_is_block[iN4];
								bfoundS = true;
							}



							if ((bfoundS) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiSS2 = 0.0;
									berrS3 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iS3];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrS3 = true;
							}

							// граничный узел
							if ((iSS3 >= maxelm) && (iSS3 < maxelm + maxbound)) {
								FiSS3 = potent[iSS3];
							}
							else {
								FiSS3 = FiS3;
							}
							volume3D(iS3, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionySS3 = positionyS3 - 0.5 * pointP.y;
						}
					}
					else {
						// это граничный узел
						if (iS3 > -1) {
							FiS3 = potent[iS3]; // ATTANTION !!!! 
							FiSS3 = potent[iS3]; // нулевая скорость внутри твёрдого тела.
						}
						else {
							FiS3 = potent[iS]; // ATTANTION !!!! 
							FiSS3 = potent[iS]; // нулевая скорость внутри твёрдого тела.
						}
						positionys3 = positionyP - 0.5 * dy;
						positionyS3 = positionyP - 0.5 * dy;
						positionySS3 = positionyP - dy; // этого узла не существует !
					}


					if ((!bS4) && (iS4 > -1)) {
						FiS4 = potent[iS4];
						center_cord3D(iS4, nvtx, pa, pointP, S_SIDE);
						//printf("iS4");
						//system("pause");
						positionyS4 = pointP.y;
						positionys4 = positionyP - 0.5 * dy;

						integer iSS4 = neighbors_for_the_internal_node[S_SIDE][0][iS4];
						if (iSS4 < 0) {
							iSS4 = neighbors_for_the_internal_node[S_SIDE][1][iS4];
						}
						if (iSS4 < 0) {
							iSS4 = neighbors_for_the_internal_node[S_SIDE][2][iS4];
						}
						if (iSS4 < 0) {
							iSS4 = neighbors_for_the_internal_node[S_SIDE][3][iS4];
						}

						if ((iSS4 >= 0) && (iSS4 < maxelm)) {
							// внутренний узел
							FiSS4 = potent[iSS4];
							center_cord3D(iSS4, nvtx, pa, pointP, SS_SIDE);
							//printf("iSS4");
							//system("pause");
							positionySS4 = pointP.y;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iS4];
							ib_3 = whot_is_block[iSS4];

							bool bfoundS = false;


							if ((!bN) && (iN > -1)) {

								ib_4 = whot_is_block[iN];
								bfoundS = true;
							}
							else if ((!bN2) && (iN2 > -1)) {

								ib_4 = whot_is_block[iN2];
								bfoundS = true;
							}
							else if ((!bN3) && (iN3 > -1)) {

								ib_4 = whot_is_block[iN3];
								bfoundS = true;
							}
							else if ((!bN4) && (iN4 > -1)) {

								ib_4 = whot_is_block[iN4];
								bfoundS = true;
							}



							if ((bfoundS) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiSS4 = 0.0;
									berrS4 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iS4];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrS4 = true;
							}

							// граничный узел
							if ((iSS4 >= maxelm) && (iSS4 < maxelm + maxbound)) {
								FiSS4 = potent[iSS4];
							}
							else {
								FiSS4 = FiS4;
							}
							volume3D(iS4, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionySS4 = positionyS4 - 0.5 * pointP.y;
						}
					}
					else {
						// это граничный узел
						if (iS4 > -1) {
							FiS4 = potent[iS4]; // ATTANTION !!!! 
							FiSS4 = potent[iS4]; // нулевая скорость внутри твёрдого тела.
						}
						else {
							FiS4 = potent[iS]; // ATTANTION !!!! 
							FiSS4 = potent[iS]; // нулевая скорость внутри твёрдого тела.
						}
						positionys4 = positionyP - 0.5 * dy;
						positionyS4 = positionyP - 0.5 * dy;
						positionySS4 = positionyP - dy; // этого узла не существует !
					}


					// Z - direction
					if ((!bT2) && (iT2 > -1)) {
						FiT2 = potent[iT2];
						center_cord3D(iT2, nvtx, pa, pointP, T_SIDE);
						//printf("iT2");
						//system("pause");
						positionzT2 = pointP.z;
						positionzt2 = positionzP + 0.5 * dz;

						integer iTT2 = neighbors_for_the_internal_node[T_SIDE][0][iT2];
						if (iTT2 < 0) {
							iTT2 = neighbors_for_the_internal_node[T_SIDE][1][iT2];
						}
						if (iTT2 < 0) {
							iTT2 = neighbors_for_the_internal_node[T_SIDE][2][iT2];
						}
						if (iTT2 < 0) {
							iTT2 = neighbors_for_the_internal_node[T_SIDE][3][iT2];
						}


						if ((iTT2 >= 0) && (iTT2 < maxelm)) {
							// внутренний узел
							FiTT2 = potent[iTT2];
							center_cord3D(iTT2, nvtx, pa, pointP, TT_SIDE);
							//printf("iTT2");
							//system("pause");
							positionzTT2 = pointP.z;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iT2];
							ib_3 = whot_is_block[iTT2];

							bool bfoundT = false;


							if ((!bB) && (iB > -1)) {

								ib_4 = whot_is_block[iB];
								bfoundT = true;
							}
							else if ((!bB2) && (iB2 > -1)) {

								ib_4 = whot_is_block[iB2];
								bfoundT = true;
							}
							else if ((!bB3) && (iB3 > -1)) {

								ib_4 = whot_is_block[iB3];
								bfoundT = true;
							}
							else if ((!bB4) && (iB4 > -1)) {

								ib_4 = whot_is_block[iB4];
								bfoundT = true;
							}
							

							
							if ((bfoundT) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiTT2 = 0.0;
									berrT2 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iT2];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrT2 = true;
							}
							// граничный узел
							if ((iTT2 >= maxelm) && (iTT2 < maxelm + maxbound)) {
								FiTT2 = potent[iTT2];
							}
							else {
								FiTT2 = FiT2;
							}
							volume3D(iT2, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionzTT2 = positionzT2 + 0.5 * pointP.z;
						}
					}
					else {
						// это граничный узел
						if (iT2 > -1) {
							FiT2 = potent[iT2];
							FiTT2 = potent[iT2]; // скорость внутри твёрдого тела
						}
						else {
							FiT2 = potent[iT];
							FiTT2 = potent[iT]; // скорость внутри твёрдого тела
						}
						//FiT2 = potent[iP];
						//FiTT2 = potent[iP];
						positionzt2 = positionzP + 0.5 * dz;
						positionzT2 = positionzP + 0.5 * dz;
						positionzTT2 = positionzP + dz; // этого узла не существует !
					}

					if ((!bT3) && (iT3 > -1)) {
						FiT3 = potent[iT3];
						center_cord3D(iT3, nvtx, pa, pointP, T_SIDE);
						//printf("iT3");
						//system("pause");
						positionzT3 = pointP.z;
						positionzt3 = positionzP + 0.5 * dz;

						integer iTT3 = neighbors_for_the_internal_node[T_SIDE][0][iT3];
						if (iTT3 < 0) {
							iTT3 = neighbors_for_the_internal_node[T_SIDE][1][iT3];
						}
						if (iTT3 < 0) {
							iTT3 = neighbors_for_the_internal_node[T_SIDE][2][iT3];
						}
						if (iTT3 < 0) {
							iTT3 = neighbors_for_the_internal_node[T_SIDE][3][iT3];
						}


						if ((iTT3 >= 0) && (iTT3 < maxelm)) {
							// внутренний узел
							FiTT3 = potent[iTT3];
							center_cord3D(iTT3, nvtx, pa, pointP, TT_SIDE);
							//printf("iTT3");
							//system("pause");
							positionzTT3 = pointP.z;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iT3];
							ib_3 = whot_is_block[iTT3];

							bool bfoundT = false;


							if ((!bB) && (iB > -1)) {

								ib_4 = whot_is_block[iB];
								bfoundT = true;
							}
							else if ((!bB2) && (iB2 > -1)) {

								ib_4 = whot_is_block[iB2];
								bfoundT = true;
							}
							else if ((!bB3) && (iB3 > -1)) {

								ib_4 = whot_is_block[iB3];
								bfoundT = true;
							}
							else if ((!bB4) && (iB4 > -1)) {

								ib_4 = whot_is_block[iB4];
								bfoundT = true;
							}



							if ((bfoundT) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiTT3 = 0.0;
									berrT3 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iT3];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrT3 = true;
							}
							// граничный узел
							if ((iTT3 >= maxelm) && (iTT3 < maxelm + maxbound)) {
								FiTT3 = potent[iTT3];
							}
							else {
								FiTT3 = FiT3;
							}
							volume3D(iT3, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionzTT3 = positionzT3 + 0.5 * pointP.z;
						}
					}
					else {
						// это граничный узел
						if (iT3 > -1) {
							FiT3 = potent[iT3];
							FiTT3 = potent[iT3]; // скорость внутри твёрдого тела
						}
						else {
							FiT3 = potent[iT];
							FiTT3 = potent[iT]; // скорость внутри твёрдого тела
						}
						//FiT3 = potent[iP];
						//FiTT3 = potent[iP];
						positionzt3 = positionzP + 0.5 * dz;
						positionzT3 = positionzP + 0.5 * dz;
						positionzTT3 = positionzP + dz; // этого узла не существует !
					}

					if ((!bT4) && (iT4 > -1)) {
						FiT4 = potent[iT4];
						center_cord3D(iT4, nvtx, pa, pointP, T_SIDE);
						//printf("iT4");
						//system("pause");
						positionzT4 = pointP.z;
						positionzt4 = positionzP + 0.5 * dz;

						integer iTT4 = neighbors_for_the_internal_node[T_SIDE][0][iT4];
						if (iTT4 < 0) {
							iTT4 = neighbors_for_the_internal_node[T_SIDE][1][iT4];
						}
						if (iTT4 < 0) {
							iTT4 = neighbors_for_the_internal_node[T_SIDE][2][iT4];
						}
						if (iTT4 < 0) {
							iTT4 = neighbors_for_the_internal_node[T_SIDE][3][iT4];
						}


						if ((iTT4 >= 0) && (iTT4 < maxelm)) {
							// внутренний узел
							FiTT4 = potent[iTT4];
							center_cord3D(iTT4, nvtx, pa, pointP, TT_SIDE);
							//printf("iTT4");
							//system("pause");
							positionzTT4 = pointP.z;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iT4];
							ib_3 = whot_is_block[iTT4];

							bool bfoundT = false;


							if ((!bB) && (iB > -1)) {

								ib_4 = whot_is_block[iB];
								bfoundT = true;
							}
							else if ((!bB2) && (iB2 > -1)) {

								ib_4 = whot_is_block[iB2];
								bfoundT = true;
							}
							else if ((!bB3) && (iB3 > -1)) {

								ib_4 = whot_is_block[iB3];
								bfoundT = true;
							}
							else if ((!bB4) && (iB4 > -1)) {

								ib_4 = whot_is_block[iB4];
								bfoundT = true;
							}



							if ((bfoundT) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiTT4 = 0.0;
									berrT4 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iT4];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrT4 = true;
							}
							// граничный узел
							if ((iTT4 >= maxelm) && (iTT4 < maxelm + maxbound)) {
								FiTT4 = potent[iTT4];
							}
							else {
								FiTT4 = FiT4;
							}
							volume3D(iT4, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionzTT4 = positionzT4 + 0.5 * pointP.z;
						}
					}
					else {
						// это граничный узел
						if (iT4 > -1) {
							FiT4 = potent[iT4];
							FiTT4 = potent[iT4]; // скорость внутри твёрдого тела
						}
						else {
							FiT4 = potent[iT];
							FiTT4 = potent[iT]; // скорость внутри твёрдого тела
						}
						//FiT4 = potent[iP];
						//FiTT4 = potent[iP];
						positionzt4 = positionzP + 0.5 * dz;
						positionzT4 = positionzP + 0.5 * dz;
						positionzTT4 = positionzP + dz; // этого узла не существует !
					}

					if ((!bB2) && (iB2 > -1)) {
						FiB2 = potent[iB2];
						center_cord3D(iB2, nvtx, pa, pointP, B_SIDE);
						//printf("iB2");
						//system("pause");
						positionzB2 = pointP.z;
						positionzb2 = positionzP - 0.5 * dz;

						integer iBB2 = neighbors_for_the_internal_node[B_SIDE][0][iB2];
						if (iBB2 < 0) {
							iBB2 = neighbors_for_the_internal_node[B_SIDE][1][iB2];
						}
						if (iBB2 < 0) {
							iBB2 = neighbors_for_the_internal_node[B_SIDE][2][iB2];
						}
						if (iBB2 < 0) {
							iBB2 = neighbors_for_the_internal_node[B_SIDE][3][iB2];
						}

						if ((iBB2 >= 0) && (iBB2 < maxelm)) {
							// внутренний узел
							FiBB2 = potent[iBB2];
							center_cord3D(iBB2, nvtx, pa, pointP, BB_SIDE);
							//printf("iBB2");
							//system("pause");
							positionzBB2 = pointP.z;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iB2];
							ib_3 = whot_is_block[iBB2];

							bool bfoundB = false;


							if ((!bT) && (iT > -1)) {

								ib_4 = whot_is_block[iT];
								bfoundB = true;
							}
							else if ((!bT2) && (iT2 > -1)) {

								ib_4 = whot_is_block[iT2];
								bfoundB = true;
							}
							else if ((!bT3) && (iT3 > -1)) {

								ib_4 = whot_is_block[iT3];
								bfoundB = true;
							}
							else if ((!bT4) && (iT4 > -1)) {

								ib_4 = whot_is_block[iT4];
								bfoundB = true;
							}
							

							
							if ((bfoundB) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiBB2 = 0.0;
									berrB2 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iB2];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrB2 = true;
							}
							// граничный узел
							if ((iBB2 >= maxelm) && (iBB2 < maxelm + maxbound)) {
								FiBB2 = potent[iBB2];
							}
							else {
								FiBB2 = FiB2;
							}
							volume3D(iB2, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionzBB2 = positionzB2 - 0.5 * pointP.z;
						}
					}
					else {
						// это граничный узел
						if (iB2 > -1) {
							FiB2 = potent[iB2];
							FiBB2 = potent[iB2]; // скорость внутри твёрдого тела
						}
						else {
							FiB2 = potent[iB];
							FiBB2 = potent[iB]; // скорость внутри твёрдого тела
						}
						positionzb2 = positionzP - 0.5 * dz;
						positionzB2 = positionzP - 0.5 * dz;
						positionzBB2 = positionzP - dz; // этого узла не существует !
					}

					if ((!bB3) && (iB3 > -1)) {
						FiB3 = potent[iB3];
						center_cord3D(iB3, nvtx, pa, pointP, B_SIDE);
						//printf("iB3");
						//system("pause");
						positionzB3 = pointP.z;
						positionzb3 = positionzP - 0.5 * dz;

						integer iBB3 = neighbors_for_the_internal_node[B_SIDE][0][iB3];
						if (iBB3 < 0) {
							iBB3 = neighbors_for_the_internal_node[B_SIDE][1][iB3];
						}
						if (iBB3 < 0) {
							iBB3 = neighbors_for_the_internal_node[B_SIDE][2][iB3];
						}
						if (iBB3 < 0) {
							iBB3 = neighbors_for_the_internal_node[B_SIDE][3][iB3];
						}

						if ((iBB3 >= 0) && (iBB3 < maxelm)) {
							// внутренний узел
							FiBB3 = potent[iBB3];
							center_cord3D(iBB3, nvtx, pa, pointP, BB_SIDE);
							//printf("iBB3");
							//system("pause");
							positionzBB3 = pointP.z;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iB3];
							ib_3 = whot_is_block[iBB3];

							bool bfoundB = false;


							if ((!bT) && (iT > -1)) {

								ib_4 = whot_is_block[iT];
								bfoundB = true;
							}
							else if ((!bT2) && (iT2 > -1)) {

								ib_4 = whot_is_block[iT2];
								bfoundB = true;
							}
							else if ((!bT3) && (iT3 > -1)) {

								ib_4 = whot_is_block[iT3];
								bfoundB = true;
							}
							else if ((!bT4) && (iT4 > -1)) {

								ib_4 = whot_is_block[iT4];
								bfoundB = true;
							}



							if ((bfoundB) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiBB3 = 0.0;
									berrB3 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iB3];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrB3 = true;
							}
							// граничный узел
							if ((iBB3 >= maxelm) && (iBB3 < maxelm + maxbound)) {
								FiBB3 = potent[iBB3];
							}
							else {
								FiBB3 = FiB3;
							}
							volume3D(iB3, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionzBB3 = positionzB3 - 0.5 * pointP.z;
						}
					}
					else {
						// это граничный узел
						if (iB3 > -1) {
							FiB3 = potent[iB3];
							FiBB3 = potent[iB3]; // скорость внутри твёрдого тела
						}
						else {
							FiB3 = potent[iB];
							FiBB3 = potent[iB]; // скорость внутри твёрдого тела
						}
						positionzb3 = positionzP - 0.5 * dz;
						positionzB3 = positionzP - 0.5 * dz;
						positionzBB3 = positionzP - dz; // этого узла не существует !
					}

					if ((!bB4) && (iB4 > -1)) {
						FiB4 = potent[iB4];
						center_cord3D(iB4, nvtx, pa, pointP, B_SIDE);
						//printf("iB4");
						//system("pause");
						positionzB4 = pointP.z;
						positionzb4 = positionzP - 0.5 * dz;

						integer iBB4 = neighbors_for_the_internal_node[B_SIDE][0][iB4];
						if (iBB4 < 0) {
							iBB4 = neighbors_for_the_internal_node[B_SIDE][1][iB4];
						}
						if (iBB4 < 0) {
							iBB4 = neighbors_for_the_internal_node[B_SIDE][2][iB4];
						}
						if (iBB4 < 0) {
							iBB4 = neighbors_for_the_internal_node[B_SIDE][3][iB4];
						}

						if ((iBB4 >= 0) && (iBB4 < maxelm)) {
							// внутренний узел
							FiBB4 = potent[iBB4];
							center_cord3D(iBB4, nvtx, pa, pointP, BB_SIDE);
							//printf("iBB4");
							//system("pause");
							positionzBB4 = pointP.z;

							integer ib_1, ib_2, ib_3, ib_4;
							ib_1 = whot_is_block[iP];
							ib_2 = whot_is_block[iB4];
							ib_3 = whot_is_block[iBB4];

							bool bfoundB = false;


							if ((!bT) && (iT > -1)) {

								ib_4 = whot_is_block[iT];
								bfoundB = true;
							}
							else if ((!bT2) && (iT2 > -1)) {

								ib_4 = whot_is_block[iT2];
								bfoundB = true;
							}
							else if ((!bT3) && (iT3 > -1)) {

								ib_4 = whot_is_block[iT3];
								bfoundB = true;
							}
							else if ((!bT4) && (iT4 > -1)) {

								ib_4 = whot_is_block[iT4];
								bfoundB = true;
							}



							if ((bfoundB) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

							}
							else {
								if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
									//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
									//getchar();
									//FiBB4 = 0.0;
									berrB4 = true;
								}
							}
						}
						else
						{
							integer ib_1 = whot_is_block[iP];
							integer ib_2 = whot_is_block[iB4];
							if ((b[ib_1].itype != b[ib_2].itype)) {
								//printf("problem found\n");
								//getchar();
								berrB4 = true;
							}
							// граничный узел
							if ((iBB4 >= maxelm) && (iBB4 < maxelm + maxbound)) {
								FiBB4 = potent[iBB4];
							}
							else {
								FiBB4 = FiB4;
							}
							volume3D(iB4, nvtx, pa, pointP.x, pointP.y, pointP.z);
							positionzBB4 = positionzB4 - 0.5 * pointP.z;
						}
					}
					else {
						// это граничный узел
						if (iB4 > -1) {
							FiB4 = potent[iB4];
							FiBB4 = potent[iB4]; // скорость внутри твёрдого тела
						}
						else {
							FiB4 = potent[iB];
							FiBB4 = potent[iB]; // скорость внутри твёрдого тела
						}
						positionzb4 = positionzP - 0.5 * dz;
						positionzB4 = positionzP - 0.5 * dz;
						positionzBB4 = positionzP - dz; // этого узла не существует !
					}




				}
				else {

				// X - direction
				if (!bE) {
					FiE = potent[iE];
					center_cord3D(iE, nvtx, pa, pointP, E_SIDE);
					//printf("iE");
					//system("pause");
					positionxE = pointP.x;
					positionxe = positionxP + 0.5 * dx;

					integer iEE = neighbors_for_the_internal_node[EE_SIDE][0][iP];
					if ((iEE >= 0) && (iEE < maxelm)) {
						// внутренний узел
						FiEE = potent[iEE];
						center_cord3D(iEE, nvtx, pa, pointP, EE_SIDE);
						//printf("iEE");
						//system("pause");
						positionxEE = pointP.x;
						integer ib_1, ib_2, ib_3, ib_4;
						ib_1 = whot_is_block[iP];
						ib_2 = whot_is_block[iE];
						ib_3 = whot_is_block[iEE];
						if (!bW) ib_4 = whot_is_block[iW];
						if ((!bW) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

						}
						else {
							if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
								//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
								//getchar();
								//FiEE = 0.0;
								berrE = true;
							}
						}
					}
					else
					{
						integer ib_1 = whot_is_block[iP];
						integer ib_2 = whot_is_block[iE];
						if ((b[ib_1].itype != b[ib_2].itype)) {
							//printf("problem found\n");
							//getchar();
							berrE = true;
						}

						// граничный узел
						FiEE = potent[iEE];
						volume3D(iE, nvtx, pa, pointP.x, pointP.y, pointP.z);
						positionxEE = positionxE + 0.5 * pointP.x;
					}
				}
				else {
					// это граничный узел
					FiE = potent[iE];
					FiEE = potent[iE];
					positionxe = positionxP + 0.5 * dx;
					positionxE = positionxP + 0.5 * dx;
					positionxEE = positionxP + dx; // этого узла не существует !
				}

				if (!bW) {
					center_cord3D(iW, nvtx, pa, pointP, W_SIDE);
					//printf("iW");
					//system("pause");
					positionxW = pointP.x;
					positionxw = positionxP - 0.5 * dx;
					FiW = potent[iW];

					integer iWW = neighbors_for_the_internal_node[WW_SIDE][0][iP];
					if ((iWW >= 0) && (iWW < maxelm)) {
						// внутренний узел
						FiWW = potent[iWW];
						center_cord3D(iWW, nvtx, pa, pointP, WW_SIDE);
						//printf("iWW");
						//system("pause");
						positionxWW = pointP.x;

						integer ib_1, ib_2, ib_3, ib_4;
						ib_1 = whot_is_block[iP];
						ib_2 = whot_is_block[iW];
						ib_3 = whot_is_block[iWW];
						if (!bE) ib_4 = whot_is_block[iE];
						if ((!bE) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

						}
						else {
							if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
								//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
								//getchar();
								//FiWW = 0.0;
								berrW = true;
							}
						}
					}
					else
					{
						integer ib_1 = whot_is_block[iP];
						integer ib_2 = whot_is_block[iW];
						if ((b[ib_1].itype != b[ib_2].itype)) {
							//printf("problem found\n");
							//getchar();
							berrW = true;
						}

						// граничный узел
						FiWW = potent[iWW];
						volume3D(iW, nvtx, pa, pointP.x, pointP.y, pointP.z);
						positionxWW = positionxW - 0.5 * pointP.x;
					}
				}
				else {
					// это граничный узел
					FiW = potent[iW];
					FiWW = potent[iW];
					positionxw = positionxP - 0.5 * dx;
					positionxW = positionxP - 0.5 * dx;
					positionxWW = positionxP - dx; // этого узла не существует !
				}

				// Y - direction
				if (!bN) {
					FiN = potent[iN];
					center_cord3D(iN, nvtx, pa, pointP, N_SIDE);
					//printf("iN");
					//system("pause");
					positionyN = pointP.y;
					positionyn = positionxP + 0.5 * dy;

					integer iNN = neighbors_for_the_internal_node[NN_SIDE][0][iP];
					if ((iNN >= 0) && (iNN < maxelm)) {
						// внутренний узел
						FiNN = potent[iNN];
						center_cord3D(iNN, nvtx, pa, pointP, NN_SIDE);
						//printf("iNN");
						//system("pause");
						positionyNN = pointP.y;

						integer ib_1, ib_2, ib_3, ib_4;
						ib_1 = whot_is_block[iP];
						ib_2 = whot_is_block[iN];
						ib_3 = whot_is_block[iNN];
						if (!bS) ib_4 = whot_is_block[iS];
						if ((!bS) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

						}
						else {
							if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
								//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
								//getchar();
								//FiNN = 0.0;
								berrN = true;
							}
						}
					}
					else
					{
						integer ib_1 = whot_is_block[iP];
						integer ib_2 = whot_is_block[iN];
						if ((b[ib_1].itype != b[ib_2].itype)) {
							//printf("problem found\n");
							//getchar();
							berrN = true;
						}

						// граничный узел
						FiNN = potent[iNN];
						volume3D(iN, nvtx, pa, pointP.x, pointP.y, pointP.z);
						positionyNN = positionyN + 0.5 * pointP.y;
					}
				}
				else {
					// это граничный узел
					FiN = potent[iN];
					FiNN = potent[iN];
					positionyn = positionyP + 0.5 * dy;
					positionyN = positionyP + 0.5 * dy;
					positionyNN = positionyP + dy; // этого узла не существует !
				}

				if (!bS) {
					FiS = potent[iS];
					center_cord3D(iS, nvtx, pa, pointP, S_SIDE);
					//printf("iS");
					//system("pause");
					positionyS = pointP.y;
					positionys = positionyP - 0.5 * dy;

					integer iSS = neighbors_for_the_internal_node[SS_SIDE][0][iP];
					if ((iSS >= 0) && (iSS < maxelm)) {
						// внутренний узел
						FiSS = potent[iSS];
						center_cord3D(iSS, nvtx, pa, pointP, SS_SIDE);
						//printf("iSS");
						//system("pause");
						positionySS = pointP.y;

						integer ib_1, ib_2, ib_3, ib_4;
						ib_1 = whot_is_block[iP];
						ib_2 = whot_is_block[iS];
						ib_3 = whot_is_block[iSS];
						if (!bN) ib_4 = whot_is_block[iN];
						if ((!bN) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

						}
						else {
							if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
								//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
								//getchar();
								//FiSS = 0.0;
								berrS = true;
							}
						}
					}
					else
					{
						integer ib_1 = whot_is_block[iP];
						integer ib_2 = whot_is_block[iS];
						if ((b[ib_1].itype != b[ib_2].itype)) {
							//printf("problem found\n");
							//getchar();
							berrS = true;
						}

						// граничный узел
						FiSS = potent[iSS];
						volume3D(iS, nvtx, pa, pointP.x, pointP.y, pointP.z);
						positionySS = positionyS - 0.5 * pointP.y;
					}
				}
				else {
					// это граничный узел
					FiS = potent[iS]; // ATTANTION !!!! 
					FiSS = potent[iS]; // нулевая скорость внутри твёрдого тела.
					positionys = positionyP - 0.5 * dy;
					positionyS = positionyP - 0.5 * dy;
					positionySS = positionyP - dy; // этого узла не существует !
				}

				// Z - direction
				if (!bT) {
					FiT = potent[iT];
					center_cord3D(iT, nvtx, pa, pointP, T_SIDE);
					//printf("iT");
					//system("pause");
					positionzT = pointP.z;
					positionzt = positionzP + 0.5 * dz;

					integer iTT = neighbors_for_the_internal_node[TT_SIDE][0][iP];
					if ((iTT >= 0) && (iTT < maxelm)) {
						// внутренний узел
						FiTT = potent[iTT];
						center_cord3D(iTT, nvtx, pa, pointP, TT_SIDE);
						//printf("iTT");
						//system("pause");
						positionzTT = pointP.z;

						integer ib_1, ib_2, ib_3, ib_4;
						ib_1 = whot_is_block[iP];
						ib_2 = whot_is_block[iT];
						ib_3 = whot_is_block[iTT];
						if (!bB) ib_4 = whot_is_block[iB];
						if ((!bB) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

						}
						else {
							if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
								//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
								//getchar();
								//FiTT = 0.0;
								berrT = true;
							}
						}
					}
					else
					{
						integer ib_1 = whot_is_block[iP];
						integer ib_2 = whot_is_block[iT];
						if ((b[ib_1].itype != b[ib_2].itype)) {
							//printf("problem found\n");
							//getchar();
							berrT = true;
						}
						// граничный узел
						FiTT = potent[iTT];
						volume3D(iT, nvtx, pa, pointP.x, pointP.y, pointP.z);
						positionzTT = positionzT + 0.5 * pointP.z;
					}
				}
				else {
					// это граничный узел
					FiT = potent[iT];
					FiTT = potent[iT]; // скорость внутри твёрдого тела
					positionzt = positionzP + 0.5 * dz;
					positionzT = positionzP + 0.5 * dz;
					positionzTT = positionzP + dz; // этого узла не существует !
				}

				if (!bB) {
					FiB = potent[iB];
					center_cord3D(iB, nvtx, pa, pointP, B_SIDE);
					//printf("iB");
					//system("pause");
					positionzB = pointP.z;
					positionzb = positionzP - 0.5 * dz;

					integer iBB = neighbors_for_the_internal_node[BB_SIDE][0][iP];
					if ((iBB >= 0) && (iBB < maxelm)) {
						// внутренний узел
						FiBB = potent[iBB];
						center_cord3D(iBB, nvtx, pa, pointP, BB_SIDE);
						//printf("iBB");
						//system("pause");
						positionzBB = pointP.z;

						integer ib_1, ib_2, ib_3, ib_4;
						ib_1 = whot_is_block[iP];
						ib_2 = whot_is_block[iB];
						ib_3 = whot_is_block[iBB];
						if (!bT) ib_4 = whot_is_block[iT];
						if ((!bT) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

						}
						else {
							if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
								//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
								//getchar();
								//FiBB = 0.0;
								berrB = true;
							}
						}
					}
					else
					{
						integer ib_1 = whot_is_block[iP];
						integer ib_2 = whot_is_block[iB];
						if ((b[ib_1].itype != b[ib_2].itype)) {
							//printf("problem found\n");
							//getchar();
							berrB = true;
						}
						// граничный узел
						FiBB = potent[iBB];
						volume3D(iB, nvtx, pa, pointP.x, pointP.y, pointP.z);
						positionzBB = positionzB - 0.5 * pointP.z;
					}
				}
				else {
					// это граничный узел
					FiB = potent[iB];
					FiBB = potent[iB]; // скорость внутри твёрдого тела
					positionzb = positionzP - 0.5 * dz;
					positionzB = positionzP - 0.5 * dz;
					positionzBB = positionzP - dz; // этого узла не существует !
				}

			    }


				berrE = false; berrW = false; berrN = false; berrS = false; berrT = false; berrB = false;
				berrE2 = false; berrW2 = false; berrN2 = false; berrS2 = false; berrT2 = false; berrB2 = false;
				berrE3 = false; berrW3 = false; berrN3 = false; berrS3 = false; berrT3 = false; berrB3 = false;
				berrE4 = false; berrW4 = false; berrN4 = false; berrS4 = false; berrT4 = false; berrB4 = false;


				if ((ishconvection >= QUICK) && (ishconvection <= FROMM)) {

					if (b_on_adaptive_local_refinement_mesh) {

						// X - direction
						Fie = cell_face_value_global(ishconvection, (Fe1), FiW, FiP, FiE, FiEE);
						Fiw = cell_face_value_global(ishconvection, (Fw1), FiWW, FiW, FiP, FiE);
						// Y - direction
						Fin = cell_face_value_global(ishconvection, (Fn1), FiS, FiP, FiN, FiNN);
						Fis = cell_face_value_global(ishconvection, (Fs1), FiSS, FiS, FiP, FiN);
						// Z - direction
						Fit = cell_face_value_global(ishconvection, (Ft1), FiB, FiP, FiT, FiTT);
						Fib = cell_face_value_global(ishconvection, (Fb1), FiBB, FiB, FiP, FiT);

						// X - direction
						Fie2 = cell_face_value_global(ishconvection, (Fe2), FiW2, FiP, FiE2, FiEE2);
						Fiw2 = cell_face_value_global(ishconvection, (Fw2), FiWW2, FiW2, FiP, FiE2);
						// Y - direction
						Fin2 = cell_face_value_global(ishconvection, (Fn2), FiS2, FiP, FiN2, FiNN2);
						Fis2 = cell_face_value_global(ishconvection, (Fs2), FiSS2, FiS2, FiP, FiN2);
						// Z - direction
						Fit2 = cell_face_value_global(ishconvection, (Ft2), FiB2, FiP, FiT2, FiTT2);
						Fib2 = cell_face_value_global(ishconvection, (Fb2), FiBB2, FiB2, FiP, FiT2);

						// X - direction
						Fie3 = cell_face_value_global(ishconvection, (Fe3), FiW3, FiP, FiE3, FiEE3);
						Fiw3 = cell_face_value_global(ishconvection, (Fw3), FiWW3, FiW3, FiP, FiE3);
						// Y - direction
						Fin3 = cell_face_value_global(ishconvection, (Fn3), FiS3, FiP, FiN3, FiNN3);
						Fis3 = cell_face_value_global(ishconvection, (Fs3), FiSS3, FiS3, FiP, FiN3);
						// Z - direction
						Fit3 = cell_face_value_global(ishconvection, (Ft3), FiB3, FiP, FiT3, FiTT3);
						Fib3 = cell_face_value_global(ishconvection, (Fb3), FiBB3, FiB3, FiP, FiT3);

						// X - direction
						Fie4 = cell_face_value_global(ishconvection, (Fe4), FiW4, FiP, FiE4, FiEE4);
						Fiw4 = cell_face_value_global(ishconvection, (Fw4), FiWW4, FiW4, FiP, FiE4);
						// Y - direction
						Fin4 = cell_face_value_global(ishconvection, (Fn4), FiS4, FiP, FiN4, FiNN4);
						Fis4 = cell_face_value_global(ishconvection, (Fs4), FiSS4, FiS4, FiP, FiN4);
						// Z - direction
						Fit4 = cell_face_value_global(ishconvection, (Ft4), FiB4, FiP, FiT4, FiTT4);
						Fib4 = cell_face_value_global(ishconvection, (Fb4), FiBB4, FiB4, FiP, FiT4);
					}
					else {
						// X - direction
						Fie = cell_face_value_global(ishconvection, (Fe), FiW, FiP, FiE, FiEE);
						Fiw = cell_face_value_global(ishconvection, (Fw), FiWW, FiW, FiP, FiE);
						// Y - direction
						Fin = cell_face_value_global(ishconvection, (Fn), FiS, FiP, FiN, FiNN);
						Fis = cell_face_value_global(ishconvection, (Fs), FiSS, FiS, FiP, FiN);
						// Z - direction
						Fit = cell_face_value_global(ishconvection, (Ft), FiB, FiP, FiT, FiTT);
						Fib = cell_face_value_global(ishconvection, (Fb), FiBB, FiB, FiP, FiT);
					}
				}

				

				if (ishconvection >= UNEVENQUICK) {


					/*
					// закомментированный фрагмент относится к одной устаревшей реализации схемы QUICK на неравномерной сетке.
					// Реализация была заимствована из статьи: ...
					// В данный момент данная реализация не используется.
					//doublereal gamma1E, gamma2E, gamma1W, gamma2W, delta1E, delta2E, delta1W, delta2W;
					//doublereal gamma1N, gamma2N, gamma1S, gamma2S, delta1N, delta2N, delta1S, delta2S;
					//doublereal gamma1T, gamma2T, gamma1B, gamma2B, delta1T, delta2T, delta1B, delta2B;
					// X - direction
					// gamma
					//gamma1E=((positionxe-positionxE)*(positionxe-positionxP))/((positionxW-positionxE)*(positionxW-positionxP));
					//gamma2E=((positionxe-positionxP)*(positionxe-positionxW))/((positionxE-positionxP)*(positionxE-positionxW));
					//gamma1W=((positionxw-positionxP)*(positionxw-positionxW))/((positionxWW-positionxP)*(positionxWW-positionxW));
					//gamma2W=((positionxw-positionxW)*(positionxw-positionxWW))/((positionxP-positionxW)*(positionxP-positionxWW));
					// delta
					//delta1E=((positionxe-positionxEE)*(positionxe-positionxE))/((positionxP-positionxEE)*(positionxP-positionxE));
					//delta2E=((positionxe-positionxE)*(positionxe-positionxP))/((positionxEE-positionxE)*(positionxEE-positionxP));
					//delta1W=((positionxw-positionxE)*(positionxw-positionxP))/((positionxW-positionxE)*(positionxW-positionxP));
					//delta2W=((positionxw-positionxP)*(positionxw-positionxW))/((positionxE-positionxP)*(positionxE-positionxW));
					// Y - direction
					// gamma
					//gamma1N=((positionyn-positionyN)*(positionyn-positionyP))/((positionyS-positionyN)*(positionyS-positionyP));
					//gamma2N=((positionyn-positionyP)*(positionyn-positionyS))/((positionyN-positionyP)*(positionyN-positionyS));
					//gamma1S=((positionys-positionyP)*(positionys-positionyS))/((positionySS-positionyP)*(positionySS-positionyS));
					//gamma2S=((positionys-positionyS)*(positionys-positionySS))/((positionyP-positionyS)*(positionyP-positionySS));
					// delta
					//delta1N=((positionyn-positionyNN)*(positionyn-positionyN))/((positionyP-positionyNN)*(positionyP-positionyN));
					//delta2N=((positionyn-positionyN)*(positionyn-positionyP))/((positionyNN-positionyN)*(positionyNN-positionyP));
					//delta1S=((positionys-positionyN)*(positionys-positionyP))/((positionyS-positionyN)*(positionyS-positionyP));
					//delta2S=((positionys-positionyP)*(positionys-positionyS))/((positionyN-positionyP)*(positionyN-positionyS));
					// Z - direction
					// gamma
					//gamma1T=((positionzt-positionzT)*(positionzt-positionzP))/((positionzB-positionzT)*(positionzB-positionzP));
					//gamma2T=((positionzt-positionzP)*(positionzt-positionzB))/((positionzT-positionzP)*(positionzT-positionzB));
					//gamma1B=((positionzb-positionzP)*(positionzb-positionzB))/((positionzBB-positionzP)*(positionzBB-positionzB));
					//gamma2B=((positionzb-positionzB)*(positionzb-positionzBB))/((positionzP-positionzB)*(positionzP-positionzBB));
					// delta
					//delta1T=((positionzt-positionzTT)*(positionzt-positionzT))/((positionzP-positionzTT)*(positionzP-positionzT));
					//delta2T=((positionzt-positionzT)*(positionzt-positionzP))/((positionzTT-positionzT)*(positionzTT-positionzP));
					//delta1B=((positionzb-positionzT)*(positionzb-positionzP))/((positionzB-positionzT)*(positionzB-positionzP));
					//delta2B=((positionzb-positionzP)*(positionzb-positionzB))/((positionzT-positionzP)*(positionzT-positionzB));
					*/



					// Вычисление искомой величины на грани КО
					// используется схема Леонарда QUICK.
					/* таблица соответствия:
					 *  A	B	C	D	e	+/-
					 *  W	P	E	-	e	+
					 *  -	P	E	EE  e   -
					 *  WW   W	P	-	w	+
					 *  -	W	P	E	w	-
					 *  S	P	N	-	n	+
					 *  -	P	N	NN  n	-
					 *  SS   S	P	-	s	+
					 *  -	S	P	N	s	-
					 *  B	P	T	-	t	+
					 *  -	P	T	TT  t	-
					 *  BB   B	P	-	b	+
					 *  -	B	P	T	b	-
					 */

					if (ishconvection == UNEVENQUICK)
					{

						if (b_on_adaptive_local_refinement_mesh) {


							// X - direction
							Fie = workQUICK(dx, 2.0 * (positionxE - positionxe), positionxW, positionxP, positionxE, positionxEE, FiW, FiP, FiE, FiEE, (Fe1));
							Fiw = workQUICK(2.0 * (positionxw - positionxW), dx, positionxWW, positionxW, positionxP, positionxE, FiWW, FiW, FiP, FiE, (Fw1));
							// Y - direction
							Fin = workQUICK(dy, 2.0 * (positionyN - positionyn), positionyS, positionyP, positionyN, positionyNN, FiS, FiP, FiN, FiNN, (Fn1));
							Fis = workQUICK(2.0 * (positionys - positionyS), dy, positionySS, positionyS, positionyP, positionyN, FiSS, FiS, FiP, FiN, (Fs1));
							// Z - direction
							Fit = workQUICK(dz, 2.0 * (positionzT - positionzt), positionzB, positionzP, positionzT, positionzTT, FiB, FiP, FiT, FiTT, (Ft1));
							Fib = workQUICK(2.0 * (positionzb - positionzB), dz, positionzBB, positionzB, positionzP, positionzT, FiBB, FiB, FiP, FiT, (Fb1));

							// X - direction
							Fie2 = workQUICK(dx, 2.0 * (positionxE2 - positionxe2), positionxW2, positionxP, positionxE2, positionxEE2, FiW2, FiP, FiE2, FiEE2, (Fe2));
							Fiw2 = workQUICK(2.0 * (positionxw2 - positionxW2), dx, positionxWW2, positionxW2, positionxP, positionxE2, FiWW2, FiW2, FiP, FiE2, (Fw2));
							// Y - direction
							Fin2 = workQUICK(dy, 2.0 * (positionyN2 - positionyn2), positionyS2, positionyP, positionyN2, positionyNN2, FiS2, FiP, FiN2, FiNN2, (Fn2));
							Fis2 = workQUICK(2.0 * (positionys2 - positionyS2), dy, positionySS2, positionyS2, positionyP, positionyN2, FiSS2, FiS2, FiP, FiN2, (Fs2));
							// Z - direction
							Fit2 = workQUICK(dz, 2.0 * (positionzT2 - positionzt2), positionzB2, positionzP, positionzT2, positionzTT2, FiB2, FiP, FiT2, FiTT2, (Ft2));
							Fib2 = workQUICK(2.0 * (positionzb2 - positionzB2), dz, positionzBB2, positionzB2, positionzP, positionzT2, FiBB2, FiB2, FiP, FiT2, (Fb2));

							// X - direction
							Fie3 = workQUICK(dx, 2.0 * (positionxE3 - positionxe3), positionxW3, positionxP, positionxE3, positionxEE3, FiW3, FiP, FiE3, FiEE3, (Fe3));
							Fiw3 = workQUICK(2.0 * (positionxw3 - positionxW3), dx, positionxWW3, positionxW3, positionxP, positionxE3, FiWW3, FiW3, FiP, FiE3, (Fw3));
							// Y - direction
							Fin3 = workQUICK(dy, 2.0 * (positionyN3 - positionyn3), positionyS3, positionyP, positionyN3, positionyNN3, FiS3, FiP, FiN3, FiNN3, (Fn3));
							Fis3 = workQUICK(2.0 * (positionys3 - positionyS3), dy, positionySS3, positionyS3, positionyP, positionyN3, FiSS3, FiS3, FiP, FiN3, (Fs3));
							// Z - direction
							Fit3 = workQUICK(dz, 2.0 * (positionzT3 - positionzt3), positionzB3, positionzP, positionzT3, positionzTT3, FiB3, FiP, FiT3, FiTT3, (Ft3));
							Fib3 = workQUICK(2.0 * (positionzb3 - positionzB3), dz, positionzBB3, positionzB3, positionzP, positionzT3, FiBB3, FiB3, FiP, FiT3, (Fb3));

							// X - direction
							Fie4 = workQUICK(dx, 2.0 * (positionxE4 - positionxe4), positionxW4, positionxP, positionxE4, positionxEE4, FiW4, FiP, FiE4, FiEE4, (Fe4));
							Fiw4 = workQUICK(2.0 * (positionxw4 - positionxW4), dx, positionxWW4, positionxW4, positionxP, positionxE4, FiWW4, FiW4, FiP, FiE4, (Fw4));
							// Y - direction
							Fin4 = workQUICK(dy, 2.0 * (positionyN4 - positionyn4), positionyS4, positionyP, positionyN4, positionyNN4, FiS4, FiP, FiN4, FiNN4, (Fn4));
							Fis4 = workQUICK(2.0 * (positionys4 - positionyS4), dy, positionySS4, positionyS4, positionyP, positionyN4, FiSS4, FiS4, FiP, FiN4, (Fs4));
							// Z - direction
							Fit4 = workQUICK(dz, 2.0 * (positionzT4 - positionzt4), positionzB4, positionzP, positionzT4, positionzTT4, FiB4, FiP, FiT4, FiTT4, (Ft4));
							Fib4 = workQUICK(2.0 * (positionzb4 - positionzB4), dz, positionzBB4, positionzB4, positionzP, positionzT4, FiBB4, FiB4, FiP, FiT4, (Fb4));

						}
						else {

							// X - direction
							Fie = workQUICK(dx, 2.0 * (positionxE - positionxe), positionxW, positionxP, positionxE, positionxEE, FiW, FiP, FiE, FiEE, (Fe));
							Fiw = workQUICK(2.0 * (positionxw - positionxW), dx, positionxWW, positionxW, positionxP, positionxE, FiWW, FiW, FiP, FiE, (Fw));
							// Y - direction
							Fin = workQUICK(dy, 2.0 * (positionyN - positionyn), positionyS, positionyP, positionyN, positionyNN, FiS, FiP, FiN, FiNN, (Fn));
							Fis = workQUICK(2.0 * (positionys - positionyS), dy, positionySS, positionyS, positionyP, positionyN, FiSS, FiS, FiP, FiN, (Fs));
							// Z - direction
							Fit = workQUICK(dz, 2.0 * (positionzT - positionzt), positionzB, positionzP, positionzT, positionzTT, FiB, FiP, FiT, FiTT, (Ft));
							Fib = workQUICK(2.0 * (positionzb - positionzB), dz, positionzBB, positionzB, positionzP, positionzT, FiBB, FiB, FiP, FiT, (Fb));
						}
					}

					if ((ishconvection > UNEVENQUICK) && (ishconvection <= UNEVEN_CUBISTA))
					{
						// Пока на данный момент рекомендуется попробовать использовать только первые четыре схемы:
						// 1. UNEVEN_MUSCL, 2. UNEVEN_SOUCUP, 3. UNEVEN_HLPA, 4. UNEVEN_SMART.
						// перечисленные схемы прошли предварительную проверку.

						if (b_on_adaptive_local_refinement_mesh) {

							// X - direction
							Fie = workKN_VOLKOV(positionxW, positionxP, positionxE, positionxEE, FiW, FiP, FiE, FiEE, (Fe1), ishconvection);
							Fiw = workKN_VOLKOV(positionxWW, positionxW, positionxP, positionxE, FiWW, FiW, FiP, FiE, (Fw1), ishconvection);
							// Y - direction
							Fin = workKN_VOLKOV(positionyS, positionyP, positionyN, positionyNN, FiS, FiP, FiN, FiNN, (Fn1), ishconvection);
							Fis = workKN_VOLKOV(positionySS, positionyS, positionyP, positionyN, FiSS, FiS, FiP, FiN, (Fs1), ishconvection);
							// Z - direction
							Fit = workKN_VOLKOV(positionzB, positionzP, positionzT, positionzTT, FiB, FiP, FiT, FiTT, (Ft1), ishconvection);
							Fib = workKN_VOLKOV(positionzBB, positionzB, positionzP, positionzT, FiBB, FiB, FiP, FiT, (Fb1), ishconvection);

							// X - direction
							Fie2 = workKN_VOLKOV(positionxW2, positionxP, positionxE2, positionxEE2, FiW2, FiP, FiE2, FiEE2, (Fe2), ishconvection);
							Fiw2 = workKN_VOLKOV(positionxWW2, positionxW2, positionxP, positionxE2, FiWW2, FiW2, FiP, FiE2, (Fw2), ishconvection);
							// Y - direction
							Fin2 = workKN_VOLKOV(positionyS2, positionyP, positionyN2, positionyNN2, FiS2, FiP, FiN2, FiNN2, (Fn2), ishconvection);
							Fis2 = workKN_VOLKOV(positionySS2, positionyS2, positionyP, positionyN2, FiSS2, FiS2, FiP, FiN2, (Fs2), ishconvection);
							// Z - direction
							Fit2 = workKN_VOLKOV(positionzB2, positionzP, positionzT2, positionzTT2, FiB2, FiP, FiT2, FiTT2, (Ft2), ishconvection);
							Fib2 = workKN_VOLKOV(positionzBB2, positionzB2, positionzP, positionzT2, FiBB2, FiB2, FiP, FiT2, (Fb2), ishconvection);

							// X - direction
							Fie3 = workKN_VOLKOV(positionxW3, positionxP, positionxE3, positionxEE3, FiW3, FiP, FiE3, FiEE3, (Fe3), ishconvection);
							Fiw3 = workKN_VOLKOV(positionxWW3, positionxW3, positionxP, positionxE3, FiWW3, FiW3, FiP, FiE3, (Fw3), ishconvection);
							// Y - direction
							Fin3 = workKN_VOLKOV(positionyS3, positionyP, positionyN3, positionyNN3, FiS3, FiP, FiN3, FiNN3, (Fn3), ishconvection);
							Fis3 = workKN_VOLKOV(positionySS3, positionyS3, positionyP, positionyN3, FiSS3, FiS3, FiP, FiN3, (Fs3), ishconvection);
							// Z - direction
							Fit3 = workKN_VOLKOV(positionzB3, positionzP, positionzT3, positionzTT3, FiB3, FiP, FiT3, FiTT3, (Ft3), ishconvection);
							Fib3 = workKN_VOLKOV(positionzBB3, positionzB3, positionzP, positionzT3, FiBB3, FiB3, FiP, FiT3, (Fb3), ishconvection);

							// X - direction
							Fie4 = workKN_VOLKOV(positionxW4, positionxP, positionxE4, positionxEE4, FiW4, FiP, FiE4, FiEE4, (Fe4), ishconvection);
							Fiw4 = workKN_VOLKOV(positionxWW4, positionxW4, positionxP, positionxE4, FiWW4, FiW4, FiP, FiE4, (Fw4), ishconvection);
							// Y - direction
							Fin4 = workKN_VOLKOV(positionyS4, positionyP, positionyN4, positionyNN4, FiS4, FiP, FiN4, FiNN4, (Fn4), ishconvection);
							Fis4 = workKN_VOLKOV(positionySS4, positionyS4, positionyP, positionyN4, FiSS4, FiS4, FiP, FiN4, (Fs4), ishconvection);
							// Z - direction
							Fit4 = workKN_VOLKOV(positionzB4, positionzP, positionzT4, positionzTT4, FiB4, FiP, FiT4, FiTT4, (Ft4), ishconvection);
							Fib4 = workKN_VOLKOV(positionzBB4, positionzB4, positionzP, positionzT4, FiBB4, FiB4, FiP, FiT4, (Fb4), ishconvection);

						}
						else {
							// X - direction
							Fie = workKN_VOLKOV(positionxW, positionxP, positionxE, positionxEE, FiW, FiP, FiE, FiEE, (Fe), ishconvection);
							Fiw = workKN_VOLKOV(positionxWW, positionxW, positionxP, positionxE, FiWW, FiW, FiP, FiE, (Fw), ishconvection);
							// Y - direction
							Fin = workKN_VOLKOV(positionyS, positionyP, positionyN, positionyNN, FiS, FiP, FiN, FiNN, (Fn), ishconvection);
							Fis = workKN_VOLKOV(positionySS, positionyS, positionyP, positionyN, FiSS, FiS, FiP, FiN, (Fs), ishconvection);
							// Z - direction
							Fit = workKN_VOLKOV(positionzB, positionzP, positionzT, positionzTT, FiB, FiP, FiT, FiTT, (Ft), ishconvection);
							Fib = workKN_VOLKOV(positionzBB, positionzB, positionzP, positionzT, FiBB, FiB, FiP, FiT, (Fb), ishconvection);
						
						}
						
					}

				}
			}



			// Ссылка: SIMPLE method for the solution of incompressible flows on non-staggered grids
			// I. Sezai - Eastern Mediterranean University, Mechanical Engineering Department, Mersin 10-Turkey Revised in 
			// January, 2011.

			// Вычисление коэффициентов дискретного аналога:
			// Реализуется метод отложенной коррекции:
			// неявно реализуется только противопоточная часть, 
			// а уточняющие члены записываются в правую часть 
			// линейной системы уравнений.
			if (bconvective)
			{

				//if (!bsE) sl[iP].ae = De*fD(Pe, EXP2, true, feplus) + fmax(-(Fe), 0); else sl[iP].ae = 0.0;
				//if (!bsW) sl[iP].aw = Dw*fD(Pw, EXP2, true, fwplus) + fmax((Fw), 0); else sl[iP].aw = 0.0;
				//if (!bsN) sl[iP].an = Dn*fD(Pn, EXP2, true, fnplus) + fmax(-(Fn), 0); else sl[iP].an = 0.0;
				//if (!bsS) sl[iP].as = Ds*fD(Ps, EXP2, true, fsplus) + fmax((Fs), 0); else sl[iP].as = 0.0;
				//if (!bsT) sl[iP].at = Dt*fD(Pt, EXP2, true, ftplus) + fmax(-(Ft), 0); else sl[iP].at = 0.0;
				//if (!bsB) sl[iP].ab = Db*fD(Pb, EXP2, true, fbplus) + fmax((Fb), 0);  else sl[iP].ab = 0.0;

				// Нужно просто UDS.
				// так рекомендуют в интернетах.

				if (b_on_adaptive_local_refinement_mesh) {

					if (!bsE) sl[iP].ae = De + fmax(-(Fe1), 0); else sl[iP].ae = 0.0;
					if (!bsW) sl[iP].aw = Dw + fmax((Fw1), 0); else sl[iP].aw = 0.0;
					if (!bsN) sl[iP].an = Dn + fmax(-(Fn1), 0); else sl[iP].an = 0.0;
					if (!bsS) sl[iP].as = Ds + fmax((Fs1), 0); else sl[iP].as = 0.0;
					if (!bsT) sl[iP].at = Dt + fmax(-(Ft1), 0); else sl[iP].at = 0.0;
					if (!bsB) sl[iP].ab = Db + fmax((Fb1), 0);  else sl[iP].ab = 0.0;

					if (!bsE) sl[iP].ae2 = De2 + fmax(-(Fe2), 0); else sl[iP].ae2 = 0.0;
					if (!bsW) sl[iP].aw2 = Dw2 + fmax((Fw2), 0); else sl[iP].aw2 = 0.0;
					if (!bsN) sl[iP].an2 = Dn2 + fmax(-(Fn2), 0); else sl[iP].an2 = 0.0;
					if (!bsS) sl[iP].as2 = Ds2 + fmax((Fs2), 0); else sl[iP].as2 = 0.0;
					if (!bsT) sl[iP].at2 = Dt2 + fmax(-(Ft2), 0); else sl[iP].at2 = 0.0;
					if (!bsB) sl[iP].ab2 = Db2 + fmax((Fb2), 0);  else sl[iP].ab2 = 0.0;

					if (!bsE) sl[iP].ae3 = De3 + fmax(-(Fe3), 0); else sl[iP].ae3 = 0.0;
					if (!bsW) sl[iP].aw3 = Dw3 + fmax((Fw3), 0); else sl[iP].aw3 = 0.0;
					if (!bsN) sl[iP].an3 = Dn3 + fmax(-(Fn3), 0); else sl[iP].an3 = 0.0;
					if (!bsS) sl[iP].as3 = Ds3 + fmax((Fs3), 0); else sl[iP].as3 = 0.0;
					if (!bsT) sl[iP].at3 = Dt3 + fmax(-(Ft3), 0); else sl[iP].at3 = 0.0;
					if (!bsB) sl[iP].ab3 = Db3 + fmax((Fb3), 0);  else sl[iP].ab3 = 0.0;

					if (!bsE) sl[iP].ae4 = De4 + fmax(-(Fe4), 0); else sl[iP].ae4 = 0.0;
					if (!bsW) sl[iP].aw4 = Dw4 + fmax((Fw4), 0); else sl[iP].aw4 = 0.0;
					if (!bsN) sl[iP].an4 = Dn4 + fmax(-(Fn4), 0); else sl[iP].an4 = 0.0;
					if (!bsS) sl[iP].as4 = Ds4 + fmax((Fs4), 0); else sl[iP].as4 = 0.0;
					if (!bsT) sl[iP].at4 = Dt4 + fmax(-(Ft4), 0); else sl[iP].at4 = 0.0;
					if (!bsB) sl[iP].ab4 = Db4 + fmax((Fb4), 0);  else sl[iP].ab4 = 0.0;

					attrs = 0.0;


					bool b_strictly_internal_node = ((!bE)&& (!bW)&& (!bN)&&((!bS))&& (!bT)&&(!bB)&& (!bE2) && (!bW2) && (!bN2) && ((!bS2)) && (!bT2) && (!bB2)&& (!bE3) && (!bW3) && (!bN3) && ((!bS3)) && (!bT3) && (!bB3)&& (!bE4) && (!bW4) && (!bN4) && ((!bS4)) && (!bT4) && (!bB4));

					//bool b_strictly_internal_node = true;// Так делать нельзя, всплеск расходимости.

					if (b[whot_is_block[iP]].itype == PHYSICS_TYPE_IN_BODY::SOLID) {
						// Принадлежит твёрдому телу. Не походит для конвекции.
						b_strictly_internal_node = false;
					}

					if (b_strictly_internal_node) {

						// 9.01.2021
						    attrs += -fmax((Fe1), 0) * (Fie - FiP) + fmax(-(Fe1), 0) * (Fie - FiE);
						    attrs += -fmax(-(Fw1), 0) * (Fiw - FiP) + fmax((Fw1), 0) * (Fiw - FiW);
						    attrs += -fmax((Fn1), 0) * (Fin - FiP) + fmax(-(Fn1), 0) * (Fin - FiN);
						    attrs += -fmax(-(Fs1), 0) * (Fis - FiP) + fmax((Fs1), 0) * (Fis - FiS);
						    attrs += -fmax((Ft1), 0) * (Fit - FiP) + fmax(-(Ft1), 0) * (Fit - FiT);
						    attrs += -fmax(-(Fb1), 0) * (Fib - FiP) + fmax((Fb1), 0) * (Fib - FiB);

						    attrs += -fmax((Fe2), 0) * (Fie2 - FiP) + fmax(-(Fe2), 0) * (Fie2 - FiE2);
						    attrs += -fmax(-(Fw2), 0) * (Fiw2 - FiP) + fmax((Fw2), 0) * (Fiw2 - FiW2);
						    attrs += -fmax((Fn2), 0) * (Fin2 - FiP) + fmax(-(Fn2), 0) * (Fin2 - FiN2);
						    attrs += -fmax(-(Fs2), 0) * (Fis2 - FiP) + fmax((Fs2), 0) * (Fis2 - FiS2);
						    attrs += -fmax((Ft2), 0) * (Fit2 - FiP) + fmax(-(Ft2), 0) * (Fit2 - FiT2);
						    attrs += -fmax(-(Fb2), 0) * (Fib2 - FiP) + fmax((Fb2), 0) * (Fib2 - FiB2);

						    attrs += -fmax((Fe3), 0) * (Fie3 - FiP) + fmax(-(Fe3), 0) * (Fie3 - FiE3);
						    attrs += -fmax(-(Fw3), 0) * (Fiw3 - FiP) + fmax((Fw3), 0) * (Fiw3 - FiW3);
						    attrs += -fmax((Fn3), 0) * (Fin3 - FiP) + fmax(-(Fn3), 0) * (Fin3 - FiN3);
						    attrs += -fmax(-(Fs3), 0) * (Fis3 - FiP) + fmax((Fs3), 0) * (Fis3 - FiS3);
						    attrs += -fmax((Ft3), 0) * (Fit3 - FiP) + fmax(-(Ft3), 0) * (Fit3 - FiT3);
						    attrs += -fmax(-(Fb3), 0) * (Fib3 - FiP) + fmax((Fb3), 0) * (Fib3 - FiB3);

						    attrs += -fmax((Fe4), 0) * (Fie4 - FiP) + fmax(-(Fe4), 0) * (Fie4 - FiE4);
						    attrs += -fmax(-(Fw4), 0) * (Fiw4 - FiP) + fmax((Fw4), 0) * (Fiw4 - FiW4);
						    attrs += -fmax((Fn4), 0) * (Fin4 - FiP) + fmax(-(Fn4), 0) * (Fin4 - FiN4);
						    attrs += -fmax(-(Fs4), 0) * (Fis4 - FiP) + fmax((Fs4), 0) * (Fis4 - FiS4);
						    attrs += -fmax((Ft4), 0) * (Fit4 - FiP) + fmax(-(Ft4), 0) * (Fit4 - FiT4);
						    attrs += -fmax(-(Fb4), 0) * (Fib4 - FiP) + fmax((Fb4), 0) * (Fib4 - FiB4);							

					}
					else {
						attrs = 0.0;
					}
					//attrs=0.0; // сброс схемы Леонарда.

				}
				else {

					if (!bsE) sl[iP].ae = De + fmax(-(Fe), 0); else sl[iP].ae = 0.0;
					if (!bsW) sl[iP].aw = Dw + fmax((Fw), 0); else sl[iP].aw = 0.0;
					if (!bsN) sl[iP].an = Dn + fmax(-(Fn), 0); else sl[iP].an = 0.0;
					if (!bsS) sl[iP].as = Ds + fmax((Fs), 0); else sl[iP].as = 0.0;
					if (!bsT) sl[iP].at = Dt + fmax(-(Ft), 0); else sl[iP].at = 0.0;
					if (!bsB) sl[iP].ab = Db + fmax((Fb), 0);  else sl[iP].ab = 0.0;

					attrs = 0.0;

					bool b_strictly_internal_node = ((!bE) && (!bW) && (!bN) && ((!bS)) && (!bT) && (!bB));

					//bool b_strictly_internal_node = true;// Так делать нельзя, всплеск расходимости.

					if (b[whot_is_block[iP]].itype == PHYSICS_TYPE_IN_BODY::SOLID) {
						// Принадлежит твёрдому телу. Не походит для конвекции.
						b_strictly_internal_node = false;
					}

					if (b_strictly_internal_node) {

						// 6.01.2018
						if (!bsE)  if (!berrE) attrs += -fmax((Fe), 0) * (Fie - FiP) + fmax(-(Fe), 0) * (Fie - FiE);
						if (!bsW)  if (!berrW) attrs += -fmax(-(Fw), 0) * (Fiw - FiP) + fmax((Fw), 0) * (Fiw - FiW);
						if (!bsN)  if (!berrN) attrs += -fmax((Fn), 0) * (Fin - FiP) + fmax(-(Fn), 0) * (Fin - FiN);
						if (!bsS)  if (!berrS) attrs += -fmax(-(Fs), 0) * (Fis - FiP) + fmax((Fs), 0) * (Fis - FiS);
						if (!bsT)  if (!berrT) attrs += -fmax((Ft), 0) * (Fit - FiP) + fmax(-(Ft), 0) * (Fit - FiT);
						if (!bsB)  if (!berrB) attrs += -fmax(-(Fb), 0) * (Fib - FiP) + fmax((Fb), 0) * (Fib - FiB);

						//attrs=0.0; // сброс схемы Леонарда.
					}
					else {
						attrs = 0.0;
					}
				}
			}
			else
			{
				// Вычисление 
				// коэффициентов
				// дискретного аналога:
				if (!bsE) sl[iP].ae = De; else sl[iP].ae = 0.0;
				if (!bsW) sl[iP].aw = Dw; else sl[iP].aw = 0.0;
				if (!bsN) sl[iP].an = Dn; else sl[iP].an = 0.0;
				if (!bsS) sl[iP].as = Ds; else sl[iP].as = 0.0;
				if (!bsT) sl[iP].at = Dt; else sl[iP].at = 0.0;
				if (!bsB) sl[iP].ab = Db; else sl[iP].ab = 0.0;

				attrs = 0.0; // только диффузия.

				baddDFLUX2 = 0.0; // инициализация.
				if (bhighorder) { // проверено !
					// если bborder == false то узел строго внутренний.
					// если bborder   то мы находимся вблизи граничного узла.
					bool bborder = false;
					doublereal myflux = 0.0;/*
					myflux=De*(dxe*DFDXiP(potent, iP, ESIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iE]));
					baddDFLUX2+=myflux;
					myflux=Dw*(-dxw*DFDXiP(potent, iP, WSIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iW]));
					baddDFLUX2+=myflux;
					myflux=Dn*(dyn*DFDXiP(potent, iP, N, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iN]));
					baddDFLUX2+=myflux;
					myflux=Ds*(-dys*DFDXiP(potent, iP, S, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iS]));
					baddDFLUX2+=myflux;
					myflux=Dt*(dzt*DFDXiP(potent, iP, TSIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iT]));
					baddDFLUX2+=myflux;
					myflux=Db*(-dzb*DFDXiP(potent, iP, B, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iB]));
					baddDFLUX2+=myflux;
					//baddDFLUX2*=-1.0;*/
					myflux = De*(dxe*DFDXiP(potent, iP, E_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iE]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dw*(-dxw*DFDXiP(potent, iP, W_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iW]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dn*(dyn*DFDXiP(potent, iP, N_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iN]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Ds*(-dys*DFDXiP(potent, iP, S_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iS]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dt*(dzt*DFDXiP(potent, iP, T_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iT]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Db*(-dzb*DFDXiP(potent, iP, B_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iB]));
					if (!bborder) baddDFLUX2 += myflux;
					//baddDFLUX2*=-1.0; // проверено нужно именно +1.0.
				}
			}


		}
	}

    //printf("%e %e %e %e %e %e\n",sl[iP].ae,sl[iP].aw, sl[iP].an, sl[iP].as, sl[iP].at, sl[iP].ab);
	//getchar(); // GOOD


    doublereal tau=1.0, apzero1=0.0, apzero0=0.0;
	doublereal Fold=0.0; // значение функции с предыдущего временного слоя
	if (btimedep) {
	   // нестационарный
	   tau=tauparam; // шаг по времени
	   if (toldtimestep!=nullptr) {
	       Fold=toldtimestep[iP]; // температура с предыдущего временного шага по времени.
	   }
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	   else {
		    printf("Fatal error!!! in function my_elmatr_quad_T3D. toldtimestep == nullptr in unsteady modelling...");
		    system("PAUSE");
		    exit(1);
	   }
#endif
	}
	else {
	   // стационарный

	   // введём псевдовремя:
		// Согласно Гаврилову Андрею псевдо время для SIMPLE процедуры вычисляется
		// по формуле (Ч5.1.12) которая приведена в части 5 описания на sigmaflow.
		if (b_on_adaptive_local_refinement_mesh) {
			doublereal sum_2 = sl[iP].ae2 + sl[iP].aw2 + sl[iP].an2 + sl[iP].as2 + sl[iP].at2 + sl[iP].ab2;
			doublereal sum_3 = sl[iP].ae3 + sl[iP].aw3 + sl[iP].an3 + sl[iP].as3 + sl[iP].at3 + sl[iP].ab3;
			doublereal sum_4 = sl[iP].ae4 + sl[iP].aw4 + sl[iP].an4 + sl[iP].as4 + sl[iP].at4 + sl[iP].ab4;
			tau = rP*dx*dy*dz*alpha / ((sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab + sum_2 + sum_3 + sum_4));
		}
		else {
			tau = rP*dx*dy*dz*alpha / ((sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab));
		}
       Fold=potent[iP];	    	
	}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (sl[iP].ae != sl[iP].ae) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: sl[iP].ae=%e in function my_elmatr_quad_T3D\n", sl[iP].ae);
		system("pause");
	}
	if (sl[iP].aw != sl[iP].aw) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: sl[iP].aw=%e in function my_elmatr_quad_T3D\n", sl[iP].aw);
		system("pause");
	}
	if (sl[iP].an != sl[iP].an) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: sl[iP].an=%e in function my_elmatr_quad_T3D\n", sl[iP].an);
		system("pause");
	}
	if (sl[iP].as != sl[iP].as) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: sl[iP].as=%e in function my_elmatr_quad_T3D\n", sl[iP].as);
		system("pause");
	}
	if (sl[iP].at != sl[iP].at) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: sl[iP].at=%e in function my_elmatr_quad_T3D\n", sl[iP].at);
		system("pause");
	}
	if (sl[iP].ab != sl[iP].ab) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: sl[iP].ab=%e in function my_elmatr_quad_T3D\n", sl[iP].ab);
		system("pause");
	}
	if (b_on_adaptive_local_refinement_mesh) {
		if (sl[iP].ae2 != sl[iP].ae2) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].ae2=%e in function my_elmatr_quad_T3D\n", sl[iP].ae2);
			system("pause");
		}
		if (sl[iP].aw2 != sl[iP].aw2) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].aw2=%e in function my_elmatr_quad_T3D\n", sl[iP].aw2);
			system("pause");
		}
		if (sl[iP].an2 != sl[iP].an2) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].an2=%e in function my_elmatr_quad_T3D\n", sl[iP].an2);
			system("pause");
		}
		if (sl[iP].as2 != sl[iP].as2) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].as2=%e in function my_elmatr_quad_T3D\n", sl[iP].as2);
			system("pause");
		}
		if (sl[iP].at2 != sl[iP].at2) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].at2=%e in function my_elmatr_quad_T3D\n", sl[iP].at2);
			system("pause");
		}
		if (sl[iP].ab2 != sl[iP].ab2) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].ab2=%e in function my_elmatr_quad_T3D\n", sl[iP].ab2);
			system("pause");
		}
		if (sl[iP].ae3 != sl[iP].ae3) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].ae3=%e in function my_elmatr_quad_T3D\n", sl[iP].ae3);
			system("pause");
		}
		if (sl[iP].aw3 != sl[iP].aw3) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].aw3=%e in function my_elmatr_quad_T3D\n", sl[iP].aw3);
			system("pause");
		}
		if (sl[iP].an3 != sl[iP].an3) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].an3=%e in function my_elmatr_quad_T3D\n", sl[iP].an3);
			system("pause");
		}
		if (sl[iP].as3 != sl[iP].as3) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].as3=%e in function my_elmatr_quad_T3D\n", sl[iP].as3);
			system("pause");
		}
		if (sl[iP].at3 != sl[iP].at3) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].at3=%e in function my_elmatr_quad_T3D\n", sl[iP].at3);
			system("pause");
		}
		if (sl[iP].ab3 != sl[iP].ab3) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].ab3=%e in function my_elmatr_quad_T3D\n", sl[iP].ab3);
			system("pause");
		}
		if (sl[iP].ae4 != sl[iP].ae4) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].ae4=%e in function my_elmatr_quad_T3D\n", sl[iP].ae4);
			system("pause");
		}
		if (sl[iP].aw4 != sl[iP].aw4) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].aw4=%e in function my_elmatr_quad_T3D\n", sl[iP].aw4);
			system("pause");
		}
		if (sl[iP].an4 != sl[iP].an4) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].an4=%e in function my_elmatr_quad_T3D\n", sl[iP].an4);
			system("pause");
		}
		if (sl[iP].as4 != sl[iP].as4) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].as4=%e in function my_elmatr_quad_T3D\n", sl[iP].as4);
			system("pause");
		}
		if (sl[iP].at4 != sl[iP].at4) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].at4=%e in function my_elmatr_quad_T3D\n", sl[iP].at4);
			system("pause");
		}
		if (sl[iP].ab4 != sl[iP].ab4) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].ab4=%e in function my_elmatr_quad_T3D\n", sl[iP].ab4);
			system("pause");
		}
	}
#endif

	// Внимание! при решении уравнений Навье-Стокса в нестационарной постановке давление нужно будет
	// брать с предыдущего временного шага. 
	if ((!btimedep) && (!imitation_time)) {
		// стационарный и имитация шагов по времени не используется
		apzero1=0.0; // с нового временного слоя.
		apzero0=0.0; // с предыдущего временного слоя
	}
	else {
		// Это неактивно, проверено 7 августа 2016.
		// 15 сентября 2016 Это активно при нестационарной теплопередаче в твёрдом теле.
		//printf("Told comming\n");
		//getchar();

		apzero0 = apzero1=rP*dx*dy*dz/tau; // rho1*cp1*dx*dy*dz/tau. // ap01

		/*
		ВНИМАНИЕ!!! Так делать нельзя никогда.
		TOCHKA p; // координаты центра КО.
		integer ib; // номер блока которому принадлежит КО.
		doublereal rho=1.1614, cp=1005; // инициализация default  dry air 300K 1atm properties
		center_cord3D(iP, nvtx, pa, p,100); // вычисление координат центра КО.
		in_model_temp(p,ib,b,lb); // возвращает номер блока ib которому принадлежит контрольный объём с номером iP.
		 
		if (matlist[b[ib].imatid].blibmat==1) {
			// библиотечный, внутрипрограммный материал.
			if (b[ib].itype== PHYSICS_TYPE_IN_BODY::SOLID) {
				doublereal lam=0.0; // не используемое далее значение.
			    my_solid_properties(Fold, rho, cp, lam, matlist[b[ib].imatid].ilibident);
		    } // SOLID
		    if (b[ib].itype== PHYSICS_TYPE_IN_BODY::FLUID) {
			   doublereal mu, beta_t, lam; // значения не используются но требуются.
		       doublereal pressure;
			   if (ptr != nullptr) {
				   if (ptr[1][iP] == -1) {
					   pressure = 0.0; // давление внутри твёрдого тела (этого не может быть, т.к. здесь обязательно жидкость).
				   }
				   else pressure = f[ptr[1][iP]].potent[PRESS][ptr[0][iP]];
			   }
			   else {
				   // ptr==nullptr
				   pressure = 0.0;
			   }
			   my_fluid_properties(Fold, pressure, rho, cp, lam, mu, beta_t, matlist[b[ib].imatid].ilibident);
		    } // FLUID
		}
		else if (matlist[b[ib].imatid].blibmat==0) {
			// материал определённый пользователем:
			// постоянные свойства.
			rho=matlist[b[ib].imatid].rho;
			//cp=matlist[b[ib].imatid].cp;
			cp = get_lam(matlist[b[ib].imatid].n_cp, matlist[b[ib].imatid].temp_cp, matlist[b[ib].imatid].arr_cp, Fold);

		}
		*/
		// Наверно нехорошо если apzero0 и apzero1 вычисляются по разным формулам.
		// ГИПОТЕЗА: это может приводить к потери консервативности схемы.
		// Консервативность схемы теряется. НИКОГДА не делать их разными. Они 
		// должны быть абсолютно одинаковыми.
		//apzero0=rho*cp*dx*dy*dz/tau; // ap00

		//printf("apzero0=%e, apzero1=%e\n",apzero0,apzero1);
		//getchar();
	}

	// Теперь т.к. теплоёмкость и плотность зависят от температуры,
	// необходимо также вычислить коээфициент ap00 с предыдущего временного слоя:

	/*if (iP==20) {
	printf("tau=%e\n",tau);
	getchar();
	}*/
  
	// источниковый член
	doublereal dSc = Sc2D;
	doublereal dSp = 0.0;
	if (btimedep) {
		//if (ipower_time_depend > 0) {
			//if (poweron_multiplier_sequence > 0.1) {
				//printf("%d %e\n", ipower_time_depend, poweron_multiplier_sequence);
				//getchar();
			//}
		//}

		// нестационарный решатель.
		if (ipower_time_depend== POWER_TIME_DEPEND::CONST_POWER) {
			// Мощность внутри блока не зависит от времени и выделяется постоянно.
			dSc += dSc_out;
		}
		else if (ipower_time_depend == POWER_TIME_DEPEND::SQUARE_WAVE)  {
			// Мощность выделяется только в моменты отличности от нуля multiplyera.
			if (poweron_multiplier_sequence > 0.0) {
				dSc += dSc_out;
			}
		}
	    else if (ipower_time_depend == POWER_TIME_DEPEND::SQUARE_WAVE2)  {
		    // Square Wave Apparat.
		    // Мощность выделяется только в моменты отличности от нуля multiplyera
		    // с учётом значения константы multiplyer.
		    if (poweron_multiplier_sequence > 0.0) {
			    dSc += dSc_out*poweron_multiplier_sequence;
	     	}
	    }
		else if (ipower_time_depend == POWER_TIME_DEPEND::HOT_COLD) {
			// Мощность выделяется только в моменты отличности от нуля multiplyera.
			if (poweron_multiplier_sequence > 0.0) {
				dSc += dSc_out;
			}
		}
		else if (ipower_time_depend == POWER_TIME_DEPEND::PIECEWISE_CONST) {
		    // piecewise const
			if (poweron_multiplier_sequence > 0.0) {
				dSc += dSc_out * poweron_multiplier_sequence;
				
			}
		}
	}
	else {
		dSc += dSc_out;
	}

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (dSc != dSc) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: dSc=%e in function my_elmatr_quad_T3D\n", dSc);
		system("pause");
	}
#endif
	/*if (iP==23901) {
		printf("ae=%e, aw=%e, an=%e, as=%e, at=%e, ab=%e\n",sl[iP].ae,sl[iP].aw,sl[iP].an,sl[iP].as,sl[iP].at,sl[iP].ab);
		printf("ap01=%e, source=%e\n",apzero1,dSp*dx*dy*dz);
		getchar();
	}
	*/

	// Учтём энергию диссипируемую в виде тепла благодаря вязкости:
	doublereal rbdissipate=0.0;
	if ((ptr!=nullptr) && (ptr[1][iP]!=-1)) {
		// контрольный объём принадлежит жидкой зоне.
		rbdissipate+=f[ptr[1][iP]].prop[MU_DYNAMIC_VISCOSITY][ptr[0][iP]]*f[ptr[1][iP]].SInvariantStrainRateTensor[ptr[0][iP]]*f[ptr[1][iP]].SInvariantStrainRateTensor[ptr[0][iP]];
		/*if (inumglobaliter>=66) {
			printf("mu=%e, tensor=%e\n",f[ptr[1][iP]].prop[MU][ptr[0][iP]], f[ptr[1][iP]].SInvariantStrainRateTensor[ptr[0][iP]]);
		}*/
	}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (rbdissipate != rbdissipate) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: rbdissipate=%e in function my_elmatr_quad_T3D\n", rbdissipate);
		system("pause");
	}
#endif
	//printf("rbdissipate=%e\n",rbdissipate);
	//getchar();


	// 1.0 знаки реверсированы. Даёт расходимость солвера.
	// -1.0 ap=summa anb.
	doublereal signumflow = -1.0;

	// проверка источникового члена.
	//printf("dSp=%e, dSc=%e\n",dSp,dSc);
	//getchar();
	if (b_on_adaptive_local_refinement_mesh) {
		doublereal sum_2 = sl[iP].ae2 + sl[iP].aw2 + sl[iP].an2 + sl[iP].as2 + sl[iP].at2 + sl[iP].ab2;
		doublereal sum_3 = sl[iP].ae3 + sl[iP].aw3 + sl[iP].an3 + sl[iP].as3 + sl[iP].at3 + sl[iP].ab3;
		doublereal sum_4 = sl[iP].ae4 + sl[iP].aw4 + sl[iP].an4 + sl[iP].as4 + sl[iP].at4 + sl[iP].ab4;
		
		if (bconvective) {
			// С конвекцией
			// Стационарный гидродинамический решатель
			if (!btimedep) {
				sl[iP].ap = sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab;
				sl[iP].ap += sum_2 + sum_3 + sum_4 - dSp * dx * dy * dz;

				
				/*
				 sl[iP].ap = De + fmax(+(signumflow*Fe1), 0); 
				 sl[iP].ap += Dw + fmax(-(signumflow*Fw1), 0);
				 sl[iP].ap += Dn + fmax(+(signumflow*Fn1), 0); 
				 sl[iP].ap += Ds + fmax(-(signumflow*Fs1), 0);
				 sl[iP].ap += Dt + fmax(+(signumflow*Ft1), 0); 
				 sl[iP].ap += Db + fmax(-(signumflow*Fb1), 0);

				 sl[iP].ap += De2 + fmax(+(signumflow*Fe2), 0); 
				 sl[iP].ap += Dw2 + fmax(-(signumflow*Fw2), 0);
				 sl[iP].ap += Dn2 + fmax(+(signumflow*Fn2), 0); 
				 sl[iP].ap += Ds2 + fmax(-(signumflow*Fs2), 0); 
				 sl[iP].ap += Dt2 + fmax(+(signumflow*Ft2), 0);
				 sl[iP].ap += Db2 + fmax(-(signumflow*Fb2), 0); 

				 sl[iP].ap += De3 + fmax(+(signumflow*Fe3), 0); 
				 sl[iP].ap += Dw3 + fmax(-(signumflow*Fw3), 0); 
				 sl[iP].ap += Dn3 + fmax(+(signumflow*Fn3), 0); 
				 sl[iP].ap += Ds3 + fmax(-(signumflow*Fs3), 0); 
				 sl[iP].ap += Dt3 + fmax(+(signumflow*Ft3), 0); 
				 sl[iP].ap += Db3 + fmax(-(signumflow*Fb3), 0);

				 sl[iP].ap += De4 + fmax(+(signumflow*Fe4), 0); 
				 sl[iP].ap += Dw4 + fmax(-(signumflow*Fw4), 0); 
				 sl[iP].ap += Dn4 + fmax(+(signumflow*Fn4), 0); 
				 sl[iP].ap += Ds4 + fmax(-(signumflow*Fs4), 0); 
				 sl[iP].ap += Dt4 + fmax(+(signumflow*Ft4), 0); 
				 sl[iP].ap += Db4 + fmax(-(signumflow*Fb4), 0); 

				 sl[iP].ap +=  -dSp * dx * dy * dz;
				 */
				 doublereal deltaF = fabs(Fe1 - Fw1 + Fn1 - Fs1 + Ft1 - Fb1 + Fe2 - Fw2 + Fn2 - Fs2 + Ft2 - Fb2 + Fe3 - Fw3 + Fn3 - Fs3 + Ft3 - Fb3 + Fe4 - Fw4 + Fn4 - Fs4 + Ft4 - Fb4);
				 if (deltaF != deltaF) {
					 printf("Fe1=%e Fw1=%e Fn1=%e Fs1=%e Ft1=%e Fb1=%e\n", Fe1, Fw1, Fn1, Fs1, Ft1, Fb1);
					 printf("Fe2=%e Fw2=%e Fn2=%e Fs2=%e Ft2=%e Fb2=%e\n", Fe2, Fw2, Fn2, Fs2, Ft2, Fb2);
					 printf("Fe3=%e Fw3=%e Fn3=%e Fs3=%e Ft3=%e Fb3=%e\n", Fe3, Fw3, Fn3, Fs3, Ft3, Fb3);
					 printf("Fe4=%e Fw4=%e Fn4=%e Fs4=%e Ft4=%e Fb4=%e\n", Fe4, Fw4, Fn4, Fs4, Ft4, Fb4);
					 printf("ERROR TEMPERATURE CONVECTIVE deltaF=%e\n", deltaF);
				 }

				 //sl[iP].ap += deltaF;

			}
			else {
				sl[iP].ap = sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab;
				sl[iP].ap += sum_2 + sum_3 + sum_4 + apzero1 - dSp * dx * dy * dz;
			}
		}
		else {
			sl[iP].ap = sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab;
			sl[iP].ap += sum_2 + sum_3 + sum_4 +apzero1 - dSp * dx* dy* dz;//+apzero1-dSp*dx*dy*dz; // диагональный элемент матрицы
		}
	}
	else {

		if (bconvective) {

			

			if (ishconvection < distsheme) {
				// 07.05.2017
				// Моя наработка:
				// ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).
				if (!bsE) {
					sl[iP].ap = De*ApproxConvective(fabs(Pe), ishconvection) + fmax(+(signumflow*Fe), 0);
				}
				else {
					sl[iP].ap = 0.0;
				}
				if (!bsW) {
					sl[iP].ap += Dw*ApproxConvective(fabs(Pw), ishconvection) + fmax(-(signumflow * Fw), 0);
				}
				if (!bsN) {
					sl[iP].ap += Dn*ApproxConvective(fabs(Pn), ishconvection) + fmax(+(signumflow * Fn), 0);
				}
				if (!bsS) {
					sl[iP].ap += Ds*ApproxConvective(fabs(Ps), ishconvection) + fmax(-(signumflow * Fs), 0);
				}
				if (!bsT) {
					sl[iP].ap += Dt*ApproxConvective(fabs(Pt), ishconvection) + fmax(+(signumflow * Ft), 0);
				}
				if (!bsB) {
					sl[iP].ap += Db*ApproxConvective(fabs(Pb), ishconvection) + fmax(-(signumflow * Fb), 0);
				}
			}
			else if (ishconvection < QUICK)
			{
				//  8.05.2017
				// Моя наработка:
				// ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).

				if (!bsE) sl[iP].ap = +signumflow * Fe*fC(Pe, ishconvection, true, feplus) + De*fD(Pe, ishconvection, true, feplus); else sl[iP].ap = 0.0;
				if (!bsW) sl[iP].ap += -signumflow * Fw*fC(Pw, ishconvection, true, fwplus) + Dw*fD(Pw, ishconvection, true, fwplus); else sl[iP].ap += 0.0;
				if (!bsN) sl[iP].ap += +signumflow * Fn*fC(Pn, ishconvection, true, fnplus) + Dn*fD(Pn, ishconvection, true, fnplus); else sl[iP].ap += 0.0;
				if (!bsS) sl[iP].ap += -signumflow * Fs*fC(Ps, ishconvection, true, fsplus) + Ds*fD(Ps, ishconvection, true, fsplus); else sl[iP].ap += 0.0;
				if (!bsT) sl[iP].ap += +signumflow * Ft*fC(Pt, ishconvection, true, ftplus) + Dt*fD(Pt, ishconvection, true, ftplus); else sl[iP].ap += 0.0;
				if (!bsB) sl[iP].ap += -signumflow * Fb*fC(Pb, ishconvection, true, fbplus) + Db*fD(Pb, ishconvection, true, fbplus); else sl[iP].ap += 0.0;
				
			}
			else if (ishconvection >= QUICK)
			{
				
				//  8.05.2017
				// Моя наработка:
				// ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).
				//if (!bsE) sl[iP].ap = De*fD(Pe, EXP2, true, feplus) + fmax(+(signumflow*Fe), 0); else sl[iP].ap = 0.0;
				//if (!bsW) sl[iP].ap += Dw*fD(Pw, EXP2, true, fwplus) + fmax(-(signumflow*Fw), 0); else sl[iP].ap += 0.0;
				//if (!bsN) sl[iP].ap += Dn*fD(Pn, EXP2, true, fnplus) + fmax(+(signumflow*Fn), 0); else sl[iP].ap += 0.0;
				//if (!bsS) sl[iP].ap += Ds*fD(Ps, EXP2, true, fsplus) + fmax(-(signumflow*Fs), 0); else sl[iP].ap += 0.0;
				//if (!bsT) sl[iP].ap += Dt*fD(Pt, EXP2, true, ftplus) + fmax(+(signumflow*Ft), 0); else sl[iP].ap += 0.0;
				//if (!bsB) sl[iP].ap += Db*fD(Pb, EXP2, true, fbplus) + fmax(-(signumflow*Fb), 0);  else sl[iP].ap += 0.0;

				// Нужно просто UDS.
				// так рекомендуют в интернетах.
				// Моя наработка:
				// ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).
				if (!bsE) sl[iP].ap = De + fmax(+(signumflow * Fe), 0); else sl[iP].ap = 0.0;
				if (!bsW) sl[iP].ap += Dw + fmax(-(signumflow * Fw), 0); else sl[iP].ap += 0.0;
				if (!bsN) sl[iP].ap += Dn + fmax(+(signumflow * Fn), 0); else sl[iP].ap += 0.0;
				if (!bsS) sl[iP].ap += Ds + fmax(-(signumflow * Fs), 0); else sl[iP].ap += 0.0;
				if (!bsT) sl[iP].ap += Dt + fmax(+(signumflow * Ft), 0); else sl[iP].ap += 0.0;
				if (!bsB) sl[iP].ap += Db + fmax(-(signumflow * Fb), 0); else sl[iP].ap += 0.0;

			}
			sl[iP].ap += apzero1 - dSp*dx*dy*dz;
			// Только так и никак иначе проверено на opening тесте.
			// Если так не делать то проблемы в мультигриде типа bad string в самых неожиданных местах.
			// Данная дефиниция переопределяет всё предыдущее.
			// Если так НЕ!!! делать то не сходится метод решения СЛАУ а amg разваливается при решении bad string.
			sl[iP].ap = sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab + apzero1 - dSp*dx*dy*dz;//+apzero1-dSp*dx*dy*dz; // диагональный элемент матрицы
			


		}
		else {
			sl[iP].ap = sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab + apzero1 - dSp*dx*dy*dz;//+apzero1-dSp*dx*dy*dz; // диагональный элемент матрицы
		}

		
		

	}

	
	
	doublereal ts = sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (ts != ts) {
		//if (Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb > 1.0e-36) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("PEREPOLNENIE iP==%lld ae=%e aw=%e an=%e as=%e at=%e ab=%e\n", iP, Fe, Fw, Fn, Fs, Ft, Fb);
			system("pause");
		//}
	}
#endif
	

	doublereal rpower_diss = dSc;
	//6.10.2018
	/*
	// Не проходит валидации, тепловая мощность занижена !!!
	if (!bE && !bW) {
		rpower_diss *= dx;
	}
	else {
		rpower_diss *= 0.5*dx;
	}
	if (!bN && !bS) {
		rpower_diss *= dy;
	}
	else {
		rpower_diss *= 0.5*dy;
	}
	if (!bT && !bB) {
		rpower_diss *= dz;
	}
	else {
		rpower_diss *= 0.5*dz;
	}
	*/

	// 23.12.2018
	// Проходит валидацию.
	rpower_diss *= dx*dy*dz;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (attrs != attrs) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: attrs=%e in function my_elmatr_quad_T3D\n", attrs);
		system("pause");
	}
	if (apzero0 != apzero0) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: apzero0=%e in function my_elmatr_quad_T3D\n", apzero0);
		system("pause");
	}
#endif
	// 3.07.2017. 
	// ВНИМАНИЕ !!! заменить на обычное присваивание если ненужна ортогональная коррекция.
	if ((b_on_adaptive_local_refinement_mesh)&&((bconvective))) {
		sl[iP].b += rpower_diss + apzero0 * Fold;
	}
	else {
		sl[iP].b += rpower_diss/*dSc*dx*dy*dz*/ + apzero0 * Fold;//+apzero0*Fold;// правая часть //-Fold*(Fe-Fw+Fn-Fs); // этот член вызывает нефизичное решение
	}
	// Если рассчитывается схема высокой разрешающей способности то этот член обязательно должен быть включён.
	sl[iP].b += attrs; // Схема высокой разрешающей способности для конвекции. Например, SMARTER 3 порядка.
	
	//if (fabs(sl[iP].b) > 1.0e-30) {
		//std::cout << "b="<<sl[iP].b << std::endl;
		//getchar();
	//}
	if (fabs(apzero1 - dSp * dx * dy * dz) > 1.0e-30) {
		std::cout << "apzero1="<<apzero1 - dSp * dx * dy * dz << std::endl;
		getchar();
	}
	

	// Усиление диагонального преобладания в случае невыполнения уравнения неразрывности,
	// на сошедшемся решении (удовлетворяющем уравнению неразрывности) вклад этого члена исчезает.
	// Ни в коем случае не включать (Fe-Fw+Fn-Fs+Ft-Fb), т.к. приводит к сильно нефизичному решению в opening тесте.
	//sl[iP].ap += fabs(Fe-Fw+Fn-Fs+Ft-Fb);
	//sl[iP].ap += Fe - Fw + Fn - Fs + Ft - Fb;
	//sl[iP].b+=rbdissipate*dx*dy*dz; // можно оставить
	//sl[iP].b+=baddDFLUX2; // можно оставить.
	   /*if (inumglobaliter>=66) {
			printf("dSc=%e, apzero0=%e, Fold=%e, rbdissipate=%e, vol=%e\n",dSc,apzero0, Fold,rbdissipate, dx*dy*dz);
			getchar();
		}
		*/

        /*
         if (iP==26) {
		 #if doubleintprecision == 1
			 printf("numberCV=%lld ap=%1.4e ae=%1.4e aw=%1.4e an=%1.4e as=%1.4e at=%1.4e ab=%1.4e b=%1.4e\n",
		 #else
			 printf("numberCV=%d ap=%1.4e ae=%1.4e aw=%1.4e an=%1.4e as=%1.4e at=%1.4e ab=%1.4e b=%1.4e\n",
		 #endif
       
		   iP,sl[iP].ap,sl[iP].ae,sl[iP].aw,sl[iP].an,sl[iP].as,sl[iP].at,sl[iP].ab,sl[iP].b);
       getchar();
	}*/

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	// debug
	if (0) {
		// Исследовал одну ошибку.
		// Она была вызвана неконсервативностью схемы из-за различных значений apzero 0!=1.
		if ((iP > 302940) && (iP <= 302951)) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("b=%e ap=%e ae=%e aw=%e an=%e as=%e at=%e ab=%e\n", sl[iP].b, sl[iP].ap, sl[iP].ae, sl[iP].aw, sl[iP].an, sl[iP].as, sl[iP].at, sl[iP].ab);
			printf("ae2=%e aw2=%e an2=%e as2=%e at2=%e ab2=%e\n", sl[iP].ae2, sl[iP].aw2, sl[iP].an2, sl[iP].as2, sl[iP].at2, sl[iP].ab2);
			printf("ae3=%e aw3=%e an3=%e as3=%e at3=%e ab3=%e\n", sl[iP].ae2, sl[iP].aw2, sl[iP].an2, sl[iP].as2, sl[iP].at2, sl[iP].ab2);
			printf("ae4=%e aw4=%e an4=%e as4=%e at4=%e ab4=%e\n", sl[iP].ae2, sl[iP].aw2, sl[iP].an2, sl[iP].as2, sl[iP].at2, sl[iP].ab2);
			printf("b: attrs=%e apzero0=%e Fold=%e rpower_diss=%e ap: apzero1=%e dSp*dx*dy*dz=%e\n",
				attrs, apzero0, Fold, rpower_diss, apzero1, dSp * dx * dy * dz);
			system("pause");
		}
	}
#endif

	/*
	if ((iB == maxelm+28148) || (iB2 == maxelm + 28148) || (iB3 == maxelm + 28148) || (iB4 == maxelm + 28148))
	{
		printf("incomming\n");

		printf("iP=%lld b=%e ap=%e ae=%e aw=%e an=%e as=%e at=%e ab=%e\n",iP, sl[iP].b, sl[iP].ap, sl[iP].ae, sl[iP].aw, sl[iP].an, sl[iP].as, sl[iP].at, sl[iP].ab);
		printf("ae2=%e aw2=%e an2=%e as2=%e at2=%e ab2=%e\n", sl[iP].ae2, sl[iP].aw2, sl[iP].an2, sl[iP].as2, sl[iP].at2, sl[iP].ab2);
		printf("ae3=%e aw3=%e an3=%e as3=%e at3=%e ab3=%e\n", sl[iP].ae2, sl[iP].aw2, sl[iP].an2, sl[iP].as2, sl[iP].at2, sl[iP].ab2);
		printf("ae4=%e aw4=%e an4=%e as4=%e at4=%e ab4=%e\n", sl[iP].ae2, sl[iP].aw2, sl[iP].an2, sl[iP].as2, sl[iP].at2, sl[iP].ab2);
		printf("b: attrs=%e apzero0=%e Fold=%e rpower_diss=%e ap: apzero1=%e dSp*dx*dy*dz=%e\n",
			attrs, apzero0, Fold, rpower_diss, apzero1, dSp* dx* dy* dz);

		getchar();
	}*/

    // Симметризация матрицы СЛАУ:
	// Граничные узлы обязательно должны собираться в первую очередь.
	// В теории должно получаться эллиптическое уравнение с SPD матрицей.
	/*
	// Строка матрицы выглядит примерно следующим образом:
	// -ab ... -as ... -aw ... +ap ... -ae ... -an ... -at == b

	
	// Учёт краевых условий Дирихле:
	if ((iE>maxelm) && (slb[iE-maxelm].iI==(-1))) {
		sl[iP].b+=sl[iP].ae*slb[iE-maxelm].b/slb[iE-maxelm].aw;
		sl[iP].ae=0.0;
		sl[iP].iE=-1;
	}
    
	if ((iW>maxelm) && (slb[iW-maxelm].iI==(-1))) {
		sl[iP].b+=sl[iP].aw*slb[iW-maxelm].b/slb[iW-maxelm].aw;
		sl[iP].aw=0.0;
		sl[iP].iW=-1;
	}

	if ((iN>maxelm) && (slb[iN-maxelm].iI==(-1))) {
		sl[iP].b+=sl[iP].an*slb[iN-maxelm].b/slb[iN-maxelm].aw;
		sl[iP].an=0.0;
		sl[iP].iN=-1;
	}

	if ((iS>maxelm) && (slb[iS-maxelm].iI==(-1))) {
		sl[iP].b+=sl[iP].as*slb[iS-maxelm].b/slb[iS-maxelm].aw;
		sl[iP].as=0.0;
		sl[iP].iS=-1;
	}

	if ((iT>maxelm) && (slb[iT-maxelm].iI==(-1))) {
		sl[iP].b+=sl[iP].at*slb[iT-maxelm].b/slb[iT-maxelm].aw;
		sl[iP].at=0.0;
		sl[iP].iT=-1;
	}

	if ((iB>maxelm) && (slb[iB-maxelm].iI==(-1))) {
		sl[iP].b+=sl[iP].ab*slb[iB-maxelm].b/slb[iB-maxelm].aw;
		sl[iP].ab=0.0;
		sl[iP].iB=-1;
	}
	
	*/

    /*
    if (iP==26) {
	#if doubleintprecision == 1
		printf("numberCV=%lld ap=%1.4e ae=%1.4e aw=%1.4e an=%1.4e as=%1.4e at=%1.4e ab=%1.4e b=%1.4e\n",
		iP,sl[iP].ap,sl[iP].ae,sl[iP].aw,sl[iP].an,sl[iP].as,sl[iP].at,sl[iP].ab,sl[iP].b);
	#else
		printf("numberCV=%d ap=%1.4e ae=%1.4e aw=%1.4e an=%1.4e as=%1.4e at=%1.4e ab=%1.4e b=%1.4e\n",
		iP,sl[iP].ap,sl[iP].ae,sl[iP].aw,sl[iP].an,sl[iP].as,sl[iP].at,sl[iP].ab,sl[iP].b);
	#endif
       
       getchar();
	}
    */

	if (fabs(sl[iP].ap) < 1.0e-30) {
		sl[iP].ap = 1.0;
		sl[iP].b = Fold; // температура с предыдущей итерации.
	}

} // my_elmatr_quad_T3D



/*
// Модификация матрицы СЛАУ для учёта влияния radiosity Prism Object.
void radiosity_patch_for_vacuum_Prism_Object(equation3D* &sl, equation3D_bon* &slb, BLOCK* &b, integer lb, integer maxelm)
{
	for (integer i = 0; i < lb; i++) {
		if (b[i].radiation.binternalRadiation)
		{
			if ((b[i].radiation.nodelistW != nullptr) && (b[i].radiation.nodelistE != nullptr) && (b[i].radiation.nodelistS != nullptr) && (b[i].radiation.nodelistN != nullptr) && (b[i].radiation.nodelistB != nullptr) && (b[i].radiation.nodelistT != nullptr))
			{
				
				for (integer j = 0; j < b[i].radiation.nodelistWsize; j++) {
					//sl[b[i].radiation.nodelistW[j].node1].b += b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;
					if (b[i].radiation.nodelistW[j].node2 >= maxelm) {
						// Граничный.
						// Внимание минус !!!
						//slb[b[i].radiation.nodelistW[j].node2 - maxelm].b += -b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;
					}
					else {
						// внутренний.
						// Внимание минус !!!
						sl[b[i].radiation.nodelistW[j].node2].b += -(b[i].radiation.JW-b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
					}
				}


				for (integer j = 0; j < b[i].radiation.nodelistEsize; j++) {
					//sl[b[i].radiation.nodelistE[j].node1].b += b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
					if (b[i].radiation.nodelistE[j].node2 >= maxelm) {
						// Граничный.
						// Внимание минус !!!
						//slb[b[i].radiation.nodelistE[j].node2 - maxelm].b += -b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
					}
					else {
						// внутренний.
						// поменяли знак со случаем West, т.к. здесь East отдаёт то что лучит и наоборот поглощает то что лучит West.
						// Выполняется полный баланс по Ломоносову - излишек излученный West полностью поглотиться Estom.
						sl[b[i].radiation.nodelistE[j].node2].b += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
					}
				}

				for (integer j = 0; j < b[i].radiation.nodelistSsize; j++) {
					//sl[b[i].radiation.nodelistS[j].node1].b += b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
					if (b[i].radiation.nodelistS[j].node2 >= maxelm) {
						// Граничный.
						// Внимание минус !!!
						//slb[b[i].radiation.nodelistS[j].node2 - maxelm].b += -b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
					}
					else {
						// внутренний.
						// Внимание минус !!!
						sl[b[i].radiation.nodelistS[j].node2].b += -(b[i].radiation.JS-b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
					}
				}


				for (integer j = 0; j < b[i].radiation.nodelistNsize; j++) {
					//sl[b[i].radiation.nodelistN[j].node1].b += b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;
					if (b[i].radiation.nodelistN[j].node2 >= maxelm) {
						// Граничный.
						// Внимание минус !!!
						//slb[b[i].radiation.nodelistN[j].node2 - maxelm].b += -b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;
					}
					else {
						// внутренний.
						sl[b[i].radiation.nodelistN[j].node2].b += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
					}
				}
				

				for (integer j = 0; j < b[i].radiation.nodelistBsize; j++) {
					//sl[b[i].radiation.nodelistB[j].node1].b += b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
					if (b[i].radiation.nodelistB[j].node2 >= maxelm) {
						// Граничный.
						// Внимание минус !!!
						//slb[b[i].radiation.nodelistB[j].node2 - maxelm].b += -b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
					}
					else {
						// внутренний.
						// Внимание минус !!!
						// излучил (значит отдал в направлении ОY), но он же и принял то что лучил на него TOP.
						sl[b[i].radiation.nodelistB[j].node2].b += -(b[i].radiation.JB-b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
					}
				}


				for (integer j = 0; j < b[i].radiation.nodelistTsize; j++) {
					//sl[b[i].radiation.nodelistT[j].node1].b += b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
					if (b[i].radiation.nodelistT[j].node2 >= maxelm) {
						// Граничный.
						// Внимание минус !!!
						//slb[b[i].radiation.nodelistT[j].node2 - maxelm].b += -b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
					}
					else {
						// внутренний.
						// поменяли знак со случаем Bottom, т.к. здесь top отдаёт то что лучит и наоборот поглощает то что лучит bottom.
						// Выполняется полный баланс по Ломоносову - излишек излученный botomom полностью поглотиться topom.
						sl[b[i].radiation.nodelistT[j].node2].b += (b[i].radiation.JB-b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
					}
				}

			}
		}
	}
} // radiosity_patch_for_vacuum_Prism_Object
*/

/*
// Модификация матрицы СЛАУ для учёта влияния radiosity Prism Object.
void radiosity_patch_for_vacuum_Prism_Object(equation3D* &sl, equation3D_bon* &slb, BLOCK* &b, integer lb, integer maxelm)
{
	doublereal result, alpha = 0.1;
	for (integer i = 0; i < lb; i++) {
		if (b[i].radiation.binternalRadiation)
		{
			if ((b[i].radiation.nodelistW != nullptr) && (b[i].radiation.nodelistE != nullptr) && (b[i].radiation.nodelistS != nullptr) && (b[i].radiation.nodelistN != nullptr) && (b[i].radiation.nodelistB != nullptr) && (b[i].radiation.nodelistT != nullptr))
			{

				for (integer j = 0; j < b[i].radiation.nodelistWsize; j++) {
					//sl[b[i].radiation.nodelistW[j].node1].b += b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;
					if (b[i].radiation.nodelistW[j].node2 >= maxelm) {
						// Граничный.
						// Внимание минус !!!
						//slb[b[i].radiation.nodelistW[j].node2 - maxelm].b += -b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;
					}
					else {
						// внутренний.
						// Внимание минус !!!
						result = sl[b[i].radiation.nodelistW[j].node2].b - (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
						sl[b[i].radiation.nodelistW[j].node2].b = alpha*(result)+(1 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node2]);
						bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node2] = sl[b[i].radiation.nodelistW[j].node2].b;
						//sl[b[i].radiation.nodelistW[j].node2].b += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
					}
				}


				for (integer j = 0; j < b[i].radiation.nodelistEsize; j++) {
					//sl[b[i].radiation.nodelistE[j].node1].b += b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
					if (b[i].radiation.nodelistE[j].node2 >= maxelm) {
						// Граничный.
						// Внимание минус !!!
						//slb[b[i].radiation.nodelistE[j].node2 - maxelm].b += -b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
					}
					else {
						// внутренний.
						// поменяли знак со случаем West, т.к. здесь East отдаёт то что лучит и наоборот поглощает то что лучит West.
						// Выполняется полный баланс по Ломоносову - излишек излученный West полностью поглотиться Estom.
						result = sl[b[i].radiation.nodelistE[j].node2].b + (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
						sl[b[i].radiation.nodelistE[j].node2].b = alpha*result + (1.0 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node2]);
						bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node2] = sl[b[i].radiation.nodelistE[j].node2].b;
						//sl[b[i].radiation.nodelistE[j].node2].b += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
					}
				}

				for (integer j = 0; j < b[i].radiation.nodelistSsize; j++) {
					//sl[b[i].radiation.nodelistS[j].node1].b += b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
					if (b[i].radiation.nodelistS[j].node2 >= maxelm) {
						// Граничный.
						// Внимание минус !!!
						//slb[b[i].radiation.nodelistS[j].node2 - maxelm].b += -b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
					}
					else {
						// внутренний.
						// Внимание минус !!!
						result = sl[b[i].radiation.nodelistS[j].node2].b -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
						sl[b[i].radiation.nodelistS[j].node2].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node2];
						bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node2] = sl[b[i].radiation.nodelistS[j].node2].b;
						//sl[b[i].radiation.nodelistS[j].node2].b += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
					}
				}


				for (integer j = 0; j < b[i].radiation.nodelistNsize; j++) {
					//sl[b[i].radiation.nodelistN[j].node1].b += b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;
					if (b[i].radiation.nodelistN[j].node2 >= maxelm) {
						// Граничный.
						// Внимание минус !!!
						//slb[b[i].radiation.nodelistN[j].node2 - maxelm].b += -b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;
					}
					else {
						// внутренний.
						result = sl[b[i].radiation.nodelistN[j].node2].b + (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
						sl[b[i].radiation.nodelistN[j].node2].b = alpha*result + (1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node2];
						bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node2] = sl[b[i].radiation.nodelistN[j].node2].b;
						//sl[b[i].radiation.nodelistN[j].node2].b += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
					}
				}


				for (integer j = 0; j < b[i].radiation.nodelistBsize; j++) {
					//sl[b[i].radiation.nodelistB[j].node1].b += b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
					if (b[i].radiation.nodelistB[j].node2 >= maxelm) {
						// Граничный.
						// Внимание минус !!!
						//slb[b[i].radiation.nodelistB[j].node2 - maxelm].b += -b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
					}
					else {
						// внутренний.
						// Внимание минус !!!
						// излучил (значит отдал в направлении ОY), но он же и принял то что лучил на него TOP.
						result = sl[b[i].radiation.nodelistB[j].node2].b  -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
						sl[b[i].radiation.nodelistB[j].node2].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node2];
						bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node2] = sl[b[i].radiation.nodelistB[j].node2].b;
						//sl[b[i].radiation.nodelistB[j].node2].b += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
					}
				}


				for (integer j = 0; j < b[i].radiation.nodelistTsize; j++) {
					//sl[b[i].radiation.nodelistT[j].node1].b += b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
					if (b[i].radiation.nodelistT[j].node2 >= maxelm) {
						// Граничный.
						// Внимание минус !!!
						//slb[b[i].radiation.nodelistT[j].node2 - maxelm].b += -b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
					}
					else {
						// внутренний.
						// поменяли знак со случаем Bottom, т.к. здесь top отдаёт то что лучит и наоборот поглощает то что лучит bottom.
						// Выполняется полный баланс по Ломоносову - излишек излученный botomom полностью поглотиться topom.
						result = sl[b[i].radiation.nodelistT[j].node2].b + (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
						sl[b[i].radiation.nodelistT[j].node2].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node2];
						bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node2] = sl[b[i].radiation.nodelistT[j].node2].b;
						//sl[b[i].radiation.nodelistT[j].node2].b += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
					}
				}

			}
		}
	}
} // radiosity_patch_for_vacuum_Prism_Object
*/



// Модификация матрицы СЛАУ для учёта влияния radiosity Prism Object.
//void radiosity_patch_for_vacuum_Prism_Object(equation3D* &sl, equation3D_bon* &slb, BLOCK* &b, integer lb, integer maxelm)
// 26.09.2016 Работает и для АЛИС сетки тоже.
void radiosity_patch_for_vacuum_Prism_Object_(doublereal* &rthdsd, BLOCK* &b, integer lb, integer maxelm, int *& whot_is_block)
{


	for (integer i = 0; i < maxelm; i++) {
		// инициализация.
		b_buffer_correct_source[i] = 0.0;
	}

	for (integer i = 0; i < lb; i++) {
		if (b[i].radiation.binternalRadiation)
		{
			if ((b[i].radiation.nodelistW != nullptr) &&
				(b[i].radiation.nodelistE != nullptr) &&
				(b[i].radiation.nodelistS != nullptr) &&
				(b[i].radiation.nodelistN != nullptr) &&
				(b[i].radiation.nodelistB != nullptr) &&
				(b[i].radiation.nodelistT != nullptr))
			{

				for (integer j = 0; j < b[i].radiation.nodelistWsize; j++) {
					//sl[b[i].radiation.nodelistW[j].node1].b += b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;

					if (b[i].radiation.nodelistW[j].node21>-1) {
						if (b[i].radiation.nodelistW[j].node21 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistW[j].node21 - maxelm].b += -b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistW[j].node21].b - (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							//sl[b[i].radiation.nodelistW[j].node21].b = alpha*(result)+(1 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21] = sl[b[i].radiation.nodelistW[j].node21].b;
							//sl[b[i].radiation.nodelistW[j].node21].b += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistW[j].node21]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistW[j].node21] += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS1;
							}
						}
					}

					if (b[i].radiation.nodelistW[j].node22>-1) {
						if (b[i].radiation.nodelistW[j].node22 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistW[j].node21 - maxelm].b += -b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistW[j].node21].b - (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							//sl[b[i].radiation.nodelistW[j].node21].b = alpha*(result)+(1 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21] = sl[b[i].radiation.nodelistW[j].node21].b;
							//sl[b[i].radiation.nodelistW[j].node21].b += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistW[j].node22]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistW[j].node22] += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS2;
							}
						}
					}

					if (b[i].radiation.nodelistW[j].node23>-1) {
						if (b[i].radiation.nodelistW[j].node23 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistW[j].node21 - maxelm].b += -b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistW[j].node21].b - (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							//sl[b[i].radiation.nodelistW[j].node21].b = alpha*(result)+(1 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21] = sl[b[i].radiation.nodelistW[j].node21].b;
							//sl[b[i].radiation.nodelistW[j].node21].b += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistW[j].node23]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistW[j].node23] += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS3;
							}
						}
					}

					if (b[i].radiation.nodelistW[j].node24>-1) {
						if (b[i].radiation.nodelistW[j].node24 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistW[j].node21 - maxelm].b += -b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistW[j].node21].b - (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							//sl[b[i].radiation.nodelistW[j].node21].b = alpha*(result)+(1 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21] = sl[b[i].radiation.nodelistW[j].node21].b;
							//sl[b[i].radiation.nodelistW[j].node21].b += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistW[j].node24]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistW[j].node24] += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS4;
							}
						}
					}

				}


				for (integer j = 0; j < b[i].radiation.nodelistEsize; j++) {
					//sl[b[i].radiation.nodelistE[j].node1].b += b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
					if (b[i].radiation.nodelistE[j].node21>-1) {
						if (b[i].radiation.nodelistE[j].node21 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistE[j].node21 - maxelm].b += -b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем West, т.к. здесь East отдаёт то что лучит и наоборот поглощает то что лучит West.
							// Выполняется полный баланс по Ломоносову - излишек излученный West полностью поглотиться Estom.
							//result = sl[b[i].radiation.nodelistE[j].node21].b + (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							//sl[b[i].radiation.nodelistE[j].node21].b = alpha*result + (1.0 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21] = sl[b[i].radiation.nodelistE[j].node21].b;
							//sl[b[i].radiation.nodelistE[j].node21].b += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistE[j].node21]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistE[j].node21] += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS1;
							}
						}
					}
					if (b[i].radiation.nodelistE[j].node22>-1) {
						if (b[i].radiation.nodelistE[j].node22 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistE[j].node21 - maxelm].b += -b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем West, т.к. здесь East отдаёт то что лучит и наоборот поглощает то что лучит West.
							// Выполняется полный баланс по Ломоносову - излишек излученный West полностью поглотиться Estom.
							//result = sl[b[i].radiation.nodelistE[j].node21].b + (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							//sl[b[i].radiation.nodelistE[j].node21].b = alpha*result + (1.0 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21] = sl[b[i].radiation.nodelistE[j].node21].b;
							//sl[b[i].radiation.nodelistE[j].node21].b += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistE[j].node22]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistE[j].node22] += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS2;
							}
						}
					}
					if (b[i].radiation.nodelistE[j].node23>-1) {
						if (b[i].radiation.nodelistE[j].node23 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistE[j].node21 - maxelm].b += -b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем West, т.к. здесь East отдаёт то что лучит и наоборот поглощает то что лучит West.
							// Выполняется полный баланс по Ломоносову - излишек излученный West полностью поглотиться Estom.
							//result = sl[b[i].radiation.nodelistE[j].node21].b + (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							//sl[b[i].radiation.nodelistE[j].node21].b = alpha*result + (1.0 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21] = sl[b[i].radiation.nodelistE[j].node21].b;
							//sl[b[i].radiation.nodelistE[j].node21].b += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistE[j].node23]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistE[j].node23] += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS3;
							}
						}
					}
					if (b[i].radiation.nodelistE[j].node24>-1) {
						if (b[i].radiation.nodelistE[j].node24 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistE[j].node21 - maxelm].b += -b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем West, т.к. здесь East отдаёт то что лучит и наоборот поглощает то что лучит West.
							// Выполняется полный баланс по Ломоносову - излишек излученный West полностью поглотиться Estom.
							//result = sl[b[i].radiation.nodelistE[j].node21].b + (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							//sl[b[i].radiation.nodelistE[j].node21].b = alpha*result + (1.0 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21] = sl[b[i].radiation.nodelistE[j].node21].b;
							//sl[b[i].radiation.nodelistE[j].node21].b += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistE[j].node24]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistE[j].node24] += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS4;
							}
						}
					}

				}

				for (integer j = 0; j < b[i].radiation.nodelistSsize; j++) {
					//sl[b[i].radiation.nodelistS[j].node1].b += b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
					if (b[i].radiation.nodelistS[j].node21>-1) {
						if (b[i].radiation.nodelistS[j].node21 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistS[j].node21 - maxelm].b += -b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistS[j].node21].b - (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							//sl[b[i].radiation.nodelistS[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21] = sl[b[i].radiation.nodelistS[j].node21].b;
							//sl[b[i].radiation.nodelistS[j].node21].b += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistS[j].node21]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistS[j].node21] += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS1;
							}
						}
					}
					if (b[i].radiation.nodelistS[j].node22>-1) {
						if (b[i].radiation.nodelistS[j].node22 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistS[j].node21 - maxelm].b += -b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistS[j].node21].b - (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							//sl[b[i].radiation.nodelistS[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21] = sl[b[i].radiation.nodelistS[j].node21].b;
							//sl[b[i].radiation.nodelistS[j].node21].b += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistS[j].node22]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistS[j].node22] += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS2;
							}
						}
					}
					if (b[i].radiation.nodelistS[j].node23>-1) {
						if (b[i].radiation.nodelistS[j].node23 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistS[j].node21 - maxelm].b += -b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistS[j].node21].b - (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							//sl[b[i].radiation.nodelistS[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21] = sl[b[i].radiation.nodelistS[j].node21].b;
							//sl[b[i].radiation.nodelistS[j].node21].b += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistS[j].node23]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistS[j].node23] += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS3;
							}
						}
					}
					if (b[i].radiation.nodelistS[j].node24>-1) {
						if (b[i].radiation.nodelistS[j].node24 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistS[j].node21 - maxelm].b += -b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistS[j].node21].b - (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							//sl[b[i].radiation.nodelistS[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21] = sl[b[i].radiation.nodelistS[j].node21].b;
							//sl[b[i].radiation.nodelistS[j].node21].b += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistS[j].node24]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistS[j].node24] += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS4;
							}
						}
					}
				}


				for (integer j = 0; j < b[i].radiation.nodelistNsize; j++) {
					//sl[b[i].radiation.nodelistN[j].node1].b += b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;

					if (b[i].radiation.nodelistN[j].node21>-1) {
						if (b[i].radiation.nodelistN[j].node21 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistN[j].node21 - maxelm].b += -b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;
						}
						else {
							// внутренний.
							//result = sl[b[i].radiation.nodelistN[j].node21].b + (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							//sl[b[i].radiation.nodelistN[j].node21].b = alpha*result + (1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21] = sl[b[i].radiation.nodelistN[j].node21].b;
							//sl[b[i].radiation.nodelistN[j].node21].b += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistN[j].node21]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistN[j].node21] += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS1;
							}
						}
					}
					if (b[i].radiation.nodelistN[j].node22>-1) {
						if (b[i].radiation.nodelistN[j].node22 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistN[j].node21 - maxelm].b += -b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;
						}
						else {
							// внутренний.
							//result = sl[b[i].radiation.nodelistN[j].node21].b + (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							//sl[b[i].radiation.nodelistN[j].node21].b = alpha*result + (1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21] = sl[b[i].radiation.nodelistN[j].node21].b;
							//sl[b[i].radiation.nodelistN[j].node21].b += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistN[j].node22]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistN[j].node22] += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS2;
							}
						}
					}
					if (b[i].radiation.nodelistN[j].node23>-1) {
						if (b[i].radiation.nodelistN[j].node23 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistN[j].node21 - maxelm].b += -b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;
						}
						else {
							// внутренний.
							//result = sl[b[i].radiation.nodelistN[j].node21].b + (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							//sl[b[i].radiation.nodelistN[j].node21].b = alpha*result + (1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21] = sl[b[i].radiation.nodelistN[j].node21].b;
							//sl[b[i].radiation.nodelistN[j].node21].b += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistN[j].node23]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistN[j].node23] += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS3;
							}
						}
					}
					if (b[i].radiation.nodelistN[j].node24>-1) {
						if (b[i].radiation.nodelistN[j].node24 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistN[j].node21 - maxelm].b += -b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;
						}
						else {
							// внутренний.
							//result = sl[b[i].radiation.nodelistN[j].node21].b + (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							//sl[b[i].radiation.nodelistN[j].node21].b = alpha*result + (1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21] = sl[b[i].radiation.nodelistN[j].node21].b;
							//sl[b[i].radiation.nodelistN[j].node21].b += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistN[j].node24]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistN[j].node24] += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS4;
							}
						}
					}

				}


				for (integer j = 0; j < b[i].radiation.nodelistBsize; j++) {
					//sl[b[i].radiation.nodelistB[j].node1].b += b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
					if (b[i].radiation.nodelistB[j].node21>-1) {
						if (b[i].radiation.nodelistB[j].node21 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistB[j].node21 - maxelm].b += -b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							// излучил (значит отдал в направлении ОY), но он же и принял то что лучил на него TOP.
							//result = sl[b[i].radiation.nodelistB[j].node21].b - (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							//sl[b[i].radiation.nodelistB[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21] = sl[b[i].radiation.nodelistB[j].node21].b;
							//sl[b[i].radiation.nodelistB[j].node21].b += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistB[j].node21]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistB[j].node21] += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS1;
							}
						}
					}
					if (b[i].radiation.nodelistB[j].node22>-1) {
						if (b[i].radiation.nodelistB[j].node22 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistB[j].node21 - maxelm].b += -b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							// излучил (значит отдал в направлении ОY), но он же и принял то что лучил на него TOP.
							//result = sl[b[i].radiation.nodelistB[j].node21].b - (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							//sl[b[i].radiation.nodelistB[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21] = sl[b[i].radiation.nodelistB[j].node21].b;
							//sl[b[i].radiation.nodelistB[j].node21].b += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistB[j].node22]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistB[j].node22] += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS2;
							}
						}
					}
					if (b[i].radiation.nodelistB[j].node23>-1) {
						if (b[i].radiation.nodelistB[j].node23 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistB[j].node21 - maxelm].b += -b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							// излучил (значит отдал в направлении ОY), но он же и принял то что лучил на него TOP.
							//result = sl[b[i].radiation.nodelistB[j].node21].b - (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							//sl[b[i].radiation.nodelistB[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21] = sl[b[i].radiation.nodelistB[j].node21].b;
							//sl[b[i].radiation.nodelistB[j].node21].b += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistB[j].node23]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistB[j].node23] += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS3;
							}
						}
					}
					if (b[i].radiation.nodelistB[j].node24>-1) {
						if (b[i].radiation.nodelistB[j].node24 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistB[j].node21 - maxelm].b += -b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							// излучил (значит отдал в направлении ОY), но он же и принял то что лучил на него TOP.
							//result = sl[b[i].radiation.nodelistB[j].node21].b - (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							//sl[b[i].radiation.nodelistB[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21] = sl[b[i].radiation.nodelistB[j].node21].b;
							//sl[b[i].radiation.nodelistB[j].node21].b += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistB[j].node24]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistB[j].node24] += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS4;
							}
						}
					}
				}


				for (integer j = 0; j < b[i].radiation.nodelistTsize; j++) {
					//sl[b[i].radiation.nodelistT[j].node1].b += b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
					if (b[i].radiation.nodelistT[j].node21>-1) {
						if (b[i].radiation.nodelistT[j].node21 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistT[j].node21 - maxelm].b += -b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем Bottom, т.к. здесь top отдаёт то что лучит и наоборот поглощает то что лучит bottom.
							// Выполняется полный баланс по Ломоносову - излишек излученный botomom полностью поглотиться topom.
							//result = sl[b[i].radiation.nodelistT[j].node21].b + (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							//sl[b[i].radiation.nodelistT[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21] = sl[b[i].radiation.nodelistT[j].node21].b;
							//sl[b[i].radiation.nodelistT[j].node21].b += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistT[j].node21]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistT[j].node21] += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS1;
							}
						}
					}
					if (b[i].radiation.nodelistT[j].node22>-1) {
						if (b[i].radiation.nodelistT[j].node22 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistT[j].node21 - maxelm].b += -b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем Bottom, т.к. здесь top отдаёт то что лучит и наоборот поглощает то что лучит bottom.
							// Выполняется полный баланс по Ломоносову - излишек излученный botomom полностью поглотиться topom.
							//result = sl[b[i].radiation.nodelistT[j].node21].b + (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							//sl[b[i].radiation.nodelistT[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21] = sl[b[i].radiation.nodelistT[j].node21].b;
							//sl[b[i].radiation.nodelistT[j].node21].b += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistT[j].node22]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistT[j].node22] += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS2;
							}
						}
					}
					if (b[i].radiation.nodelistT[j].node23>-1) {
						if (b[i].radiation.nodelistT[j].node23 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistT[j].node21 - maxelm].b += -b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем Bottom, т.к. здесь top отдаёт то что лучит и наоборот поглощает то что лучит bottom.
							// Выполняется полный баланс по Ломоносову - излишек излученный botomom полностью поглотиться topom.
							//result = sl[b[i].radiation.nodelistT[j].node21].b + (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							//sl[b[i].radiation.nodelistT[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21] = sl[b[i].radiation.nodelistT[j].node21].b;
							//sl[b[i].radiation.nodelistT[j].node21].b += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistT[j].node23]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistT[j].node23] += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS3;
							}
						}
					}
					if (b[i].radiation.nodelistT[j].node24>-1) {
						if (b[i].radiation.nodelistT[j].node24 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistT[j].node21 - maxelm].b += -b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем Bottom, т.к. здесь top отдаёт то что лучит и наоборот поглощает то что лучит bottom.
							// Выполняется полный баланс по Ломоносову - излишек излученный botomom полностью поглотиться topom.
							//result = sl[b[i].radiation.nodelistT[j].node21].b + (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							//sl[b[i].radiation.nodelistT[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21] = sl[b[i].radiation.nodelistT[j].node21].b;
							//sl[b[i].radiation.nodelistT[j].node21].b += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							if (!b[whot_is_block[b[i].radiation.nodelistT[j].node24]].radiation.binternalRadiation)
							{
								b_buffer_correct_source[b[i].radiation.nodelistT[j].node24] += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS4;
							}
						}
					}

				}

			}
		}
	}

	//doublereal result34 = 0.0;  
	//doublereal alpha34 = 0.00625; // 0.00625 0.1 0.02
	//alpha34 = my_amg_manager.theta_Speed;

	for (integer i = 0; i < maxelm; i++) {
		if (fabs(b_buffer_correct_source[i]) > 1.0e-20) {
			// Без релаксации:
			//sl[i].b += b_buffer_correct_source[i];
			rthdsd[i] += b_buffer_correct_source[i];
			bsource_term_radiation_for_relax[i] = b_buffer_correct_source[i];

			// Восстаовлено 23.11.2016
			// С нижней релаксацией: 
			//result34 = b_buffer_correct_source[i];
			//doublereal badditional = alpha34*(result34)+(1.0 - alpha34)*(bsource_term_radiation_for_relax[i]);
			//rthdsd[i]+=badditional;
			//bsource_term_radiation_for_relax[i] = badditional;

			/*
			// закомментировано 23_11_2016.
			if (fabs(bsource_term_radiation_for_relax[i]) > 1.0e-20) {
			// С нижней релаксацией:
			result34 = b_buffer_correct_source[i];
			if (b_buffer_correct_source[i] * bsource_term_radiation_for_relax[i] > 0.0) {
			//doublereal badditional = alpha34*(result34)+(1.0 - alpha34)*(bsource_term_radiation_for_relax[i]);
			rthdsd[i] += b_buffer_correct_source[i];
			bsource_term_radiation_for_relax[i] = b_buffer_correct_source[i];
			}
			else {
			result34 = 0.0; // противопоточная схема. Противодействует нарушению монотонности.
			//doublereal badditional = alpha34*(result34)+(1.0 - alpha34)*(bsource_term_radiation_for_relax[i]);
			rthdsd[i] += 0.0;
			//bsource_term_radiation_for_relax[i] = badditional;
			}
			}
			else {
			// С нижней релаксацией:
			result34 = b_buffer_correct_source[i];
			//doublereal badditional = alpha34*(result34)+(1.0 - alpha34)*(bsource_term_radiation_for_relax[i]);
			rthdsd[i] += b_buffer_correct_source[i];
			bsource_term_radiation_for_relax[i] = b_buffer_correct_source[i];
			}
			*/
		}
	}

} // radiosity_patch_for_vacuum_Prism_Object


// Модификация матрицы СЛАУ для учёта влияния radiosity Prism Object.
//void radiosity_patch_for_vacuum_Prism_Object(equation3D* &sl, equation3D_bon* &slb, BLOCK* &b, integer lb, integer maxelm)
// 26.09.2016 Работает и для АЛИС сетки тоже.
void radiosity_patch_for_vacuum_Prism_Object_old(doublereal* &rthdsd, BLOCK* &b, integer lb, integer maxelm)
{

	
	for (integer i = 0; i < maxelm; i++) {
		// инициализация.
		b_buffer_correct_source[i] = 0.0;
	}
	
	for (integer i = 0; i < lb; i++) {
		if (b[i].radiation.binternalRadiation)
		{
			if ((b[i].radiation.nodelistW != nullptr) &&
				(b[i].radiation.nodelistE != nullptr) && 
				(b[i].radiation.nodelistS != nullptr) && 
				(b[i].radiation.nodelistN != nullptr) &&
				(b[i].radiation.nodelistB != nullptr) &&
				(b[i].radiation.nodelistT != nullptr))
			{

				for (integer j = 0; j < b[i].radiation.nodelistWsize; j++) {
					//sl[b[i].radiation.nodelistW[j].node1].b += b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;

					if (b[i].radiation.nodelistW[j].node21>-1) {
						if (b[i].radiation.nodelistW[j].node21 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistW[j].node21 - maxelm].b += -b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistW[j].node21].b - (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							//sl[b[i].radiation.nodelistW[j].node21].b = alpha*(result)+(1 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21] = sl[b[i].radiation.nodelistW[j].node21].b;
							//sl[b[i].radiation.nodelistW[j].node21].b += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistW[j].node21] += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS1;
						}
					}

					if (b[i].radiation.nodelistW[j].node22>-1) {
						if (b[i].radiation.nodelistW[j].node22 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistW[j].node21 - maxelm].b += -b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistW[j].node21].b - (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							//sl[b[i].radiation.nodelistW[j].node21].b = alpha*(result)+(1 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21] = sl[b[i].radiation.nodelistW[j].node21].b;
							//sl[b[i].radiation.nodelistW[j].node21].b += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistW[j].node22] += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS2;
						}
					}

					if (b[i].radiation.nodelistW[j].node23>-1) {
						if (b[i].radiation.nodelistW[j].node23 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistW[j].node21 - maxelm].b += -b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistW[j].node21].b - (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							//sl[b[i].radiation.nodelistW[j].node21].b = alpha*(result)+(1 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21] = sl[b[i].radiation.nodelistW[j].node21].b;
							//sl[b[i].radiation.nodelistW[j].node21].b += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistW[j].node23] += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS3;
						}
					}

					if (b[i].radiation.nodelistW[j].node24>-1) {
						if (b[i].radiation.nodelistW[j].node24 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistW[j].node21 - maxelm].b += -b[i].radiation.JW*b[i].radiation.nodelistW[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistW[j].node21].b - (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							//sl[b[i].radiation.nodelistW[j].node21].b = alpha*(result)+(1 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistW[j].node21] = sl[b[i].radiation.nodelistW[j].node21].b;
							//sl[b[i].radiation.nodelistW[j].node21].b += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistW[j].node24] += -(b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistW[j].dS4;
						}
					}

				}


				for (integer j = 0; j < b[i].radiation.nodelistEsize; j++) {
					//sl[b[i].radiation.nodelistE[j].node1].b += b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
					if (b[i].radiation.nodelistE[j].node21>-1) {
						if (b[i].radiation.nodelistE[j].node21 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistE[j].node21 - maxelm].b += -b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем West, т.к. здесь East отдаёт то что лучит и наоборот поглощает то что лучит West.
							// Выполняется полный баланс по Ломоносову - излишек излученный West полностью поглотиться Estom.
							//result = sl[b[i].radiation.nodelistE[j].node21].b + (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							//sl[b[i].radiation.nodelistE[j].node21].b = alpha*result + (1.0 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21] = sl[b[i].radiation.nodelistE[j].node21].b;
							//sl[b[i].radiation.nodelistE[j].node21].b += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistE[j].node21] += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS1;
						}
					}
					if (b[i].radiation.nodelistE[j].node22>-1) {
						if (b[i].radiation.nodelistE[j].node22 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistE[j].node21 - maxelm].b += -b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем West, т.к. здесь East отдаёт то что лучит и наоборот поглощает то что лучит West.
							// Выполняется полный баланс по Ломоносову - излишек излученный West полностью поглотиться Estom.
							//result = sl[b[i].radiation.nodelistE[j].node21].b + (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							//sl[b[i].radiation.nodelistE[j].node21].b = alpha*result + (1.0 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21] = sl[b[i].radiation.nodelistE[j].node21].b;
							//sl[b[i].radiation.nodelistE[j].node21].b += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistE[j].node22] += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS2;
						}
					}
					if (b[i].radiation.nodelistE[j].node23>-1) {
						if (b[i].radiation.nodelistE[j].node23 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistE[j].node21 - maxelm].b += -b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем West, т.к. здесь East отдаёт то что лучит и наоборот поглощает то что лучит West.
							// Выполняется полный баланс по Ломоносову - излишек излученный West полностью поглотиться Estom.
							//result = sl[b[i].radiation.nodelistE[j].node21].b + (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							//sl[b[i].radiation.nodelistE[j].node21].b = alpha*result + (1.0 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21] = sl[b[i].radiation.nodelistE[j].node21].b;
							//sl[b[i].radiation.nodelistE[j].node21].b += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistE[j].node23] += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS3;
						}
					}
					if (b[i].radiation.nodelistE[j].node24>-1) {
						if (b[i].radiation.nodelistE[j].node24 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistE[j].node21 - maxelm].b += -b[i].radiation.JE*b[i].radiation.nodelistE[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем West, т.к. здесь East отдаёт то что лучит и наоборот поглощает то что лучит West.
							// Выполняется полный баланс по Ломоносову - излишек излученный West полностью поглотиться Estom.
							//result = sl[b[i].radiation.nodelistE[j].node21].b + (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							//sl[b[i].radiation.nodelistE[j].node21].b = alpha*result + (1.0 - alpha)*(bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21]);
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistE[j].node21] = sl[b[i].radiation.nodelistE[j].node21].b;
							//sl[b[i].radiation.nodelistE[j].node21].b += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistE[j].node24] += (b[i].radiation.JW - b[i].radiation.JE)*b[i].radiation.nodelistE[j].dS4;
						}
					}

				}

				for (integer j = 0; j < b[i].radiation.nodelistSsize; j++) {
					//sl[b[i].radiation.nodelistS[j].node1].b += b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
					if (b[i].radiation.nodelistS[j].node21>-1) {
						if (b[i].radiation.nodelistS[j].node21 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistS[j].node21 - maxelm].b += -b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistS[j].node21].b - (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							//sl[b[i].radiation.nodelistS[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21] = sl[b[i].radiation.nodelistS[j].node21].b;
							//sl[b[i].radiation.nodelistS[j].node21].b += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistS[j].node21] += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS1;
						}
					}
					if (b[i].radiation.nodelistS[j].node22>-1) {
						if (b[i].radiation.nodelistS[j].node22 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistS[j].node21 - maxelm].b += -b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistS[j].node21].b - (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							//sl[b[i].radiation.nodelistS[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21] = sl[b[i].radiation.nodelistS[j].node21].b;
							//sl[b[i].radiation.nodelistS[j].node21].b += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistS[j].node22] += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS2;
						}
					}
					if (b[i].radiation.nodelistS[j].node23>-1) {
						if (b[i].radiation.nodelistS[j].node23 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistS[j].node21 - maxelm].b += -b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistS[j].node21].b - (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							//sl[b[i].radiation.nodelistS[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21] = sl[b[i].radiation.nodelistS[j].node21].b;
							//sl[b[i].radiation.nodelistS[j].node21].b += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistS[j].node23] += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS3;
						}
					}
					if (b[i].radiation.nodelistS[j].node24>-1) {
						if (b[i].radiation.nodelistS[j].node24 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistS[j].node21 - maxelm].b += -b[i].radiation.JS*b[i].radiation.nodelistS[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							//result = sl[b[i].radiation.nodelistS[j].node21].b - (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							//sl[b[i].radiation.nodelistS[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistS[j].node21] = sl[b[i].radiation.nodelistS[j].node21].b;
							//sl[b[i].radiation.nodelistS[j].node21].b += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistS[j].node24] += -(b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistS[j].dS4;
						}
					}
				}


				for (integer j = 0; j < b[i].radiation.nodelistNsize; j++) {
					//sl[b[i].radiation.nodelistN[j].node1].b += b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;

					if (b[i].radiation.nodelistN[j].node21>-1) {
						if (b[i].radiation.nodelistN[j].node21 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistN[j].node21 - maxelm].b += -b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;
						}
						else {
							// внутренний.
							//result = sl[b[i].radiation.nodelistN[j].node21].b + (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							//sl[b[i].radiation.nodelistN[j].node21].b = alpha*result + (1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21] = sl[b[i].radiation.nodelistN[j].node21].b;
							//sl[b[i].radiation.nodelistN[j].node21].b += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistN[j].node21] += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS1;
						}
					}
					if (b[i].radiation.nodelistN[j].node22>-1) {
						if (b[i].radiation.nodelistN[j].node22 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistN[j].node21 - maxelm].b += -b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;
						}
						else {
							// внутренний.
							//result = sl[b[i].radiation.nodelistN[j].node21].b + (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							//sl[b[i].radiation.nodelistN[j].node21].b = alpha*result + (1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21] = sl[b[i].radiation.nodelistN[j].node21].b;
							//sl[b[i].radiation.nodelistN[j].node21].b += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistN[j].node22] += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS2;
						}
					}
					if (b[i].radiation.nodelistN[j].node23>-1) {
						if (b[i].radiation.nodelistN[j].node23 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistN[j].node21 - maxelm].b += -b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;
						}
						else {
							// внутренний.
							//result = sl[b[i].radiation.nodelistN[j].node21].b + (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							//sl[b[i].radiation.nodelistN[j].node21].b = alpha*result + (1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21] = sl[b[i].radiation.nodelistN[j].node21].b;
							//sl[b[i].radiation.nodelistN[j].node21].b += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistN[j].node23] += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS3;
						}
					}
					if (b[i].radiation.nodelistN[j].node24>-1) {
						if (b[i].radiation.nodelistN[j].node24 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistN[j].node21 - maxelm].b += -b[i].radiation.JN*b[i].radiation.nodelistN[j].dS;
						}
						else {
							// внутренний.
							//result = sl[b[i].radiation.nodelistN[j].node21].b + (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							//sl[b[i].radiation.nodelistN[j].node21].b = alpha*result + (1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistN[j].node21] = sl[b[i].radiation.nodelistN[j].node21].b;
							//sl[b[i].radiation.nodelistN[j].node21].b += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistN[j].node24] += (b[i].radiation.JS - b[i].radiation.JN)*b[i].radiation.nodelistN[j].dS4;
						}
					}

				}


				for (integer j = 0; j < b[i].radiation.nodelistBsize; j++) {
					//sl[b[i].radiation.nodelistB[j].node1].b += b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
					if (b[i].radiation.nodelistB[j].node21>-1) {
						if (b[i].radiation.nodelistB[j].node21 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistB[j].node21 - maxelm].b += -b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							// излучил (значит отдал в направлении ОY), но он же и принял то что лучил на него TOP.
							//result = sl[b[i].radiation.nodelistB[j].node21].b - (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							//sl[b[i].radiation.nodelistB[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21] = sl[b[i].radiation.nodelistB[j].node21].b;
							//sl[b[i].radiation.nodelistB[j].node21].b += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistB[j].node21] += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS1;
						}
					}
					if (b[i].radiation.nodelistB[j].node22>-1) {
						if (b[i].radiation.nodelistB[j].node22 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistB[j].node21 - maxelm].b += -b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							// излучил (значит отдал в направлении ОY), но он же и принял то что лучил на него TOP.
							//result = sl[b[i].radiation.nodelistB[j].node21].b - (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							//sl[b[i].radiation.nodelistB[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21] = sl[b[i].radiation.nodelistB[j].node21].b;
							//sl[b[i].radiation.nodelistB[j].node21].b += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistB[j].node22] += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS2;
						}
					}
					if (b[i].radiation.nodelistB[j].node23>-1) {
						if (b[i].radiation.nodelistB[j].node23 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistB[j].node21 - maxelm].b += -b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							// излучил (значит отдал в направлении ОY), но он же и принял то что лучил на него TOP.
							//result = sl[b[i].radiation.nodelistB[j].node21].b - (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							//sl[b[i].radiation.nodelistB[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21] = sl[b[i].radiation.nodelistB[j].node21].b;
							//sl[b[i].radiation.nodelistB[j].node21].b += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistB[j].node23] += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS3;
						}
					}
					if (b[i].radiation.nodelistB[j].node24>-1) {
						if (b[i].radiation.nodelistB[j].node24 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistB[j].node21 - maxelm].b += -b[i].radiation.JB*b[i].radiation.nodelistB[j].dS;
						}
						else {
							// внутренний.
							// Внимание минус !!!
							// излучил (значит отдал в направлении ОY), но он же и принял то что лучил на него TOP.
							//result = sl[b[i].radiation.nodelistB[j].node21].b - (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							//sl[b[i].radiation.nodelistB[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistB[j].node21] = sl[b[i].radiation.nodelistB[j].node21].b;
							//sl[b[i].radiation.nodelistB[j].node21].b += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistB[j].node24] += -(b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistB[j].dS4;
						}
					}
				}


				for (integer j = 0; j < b[i].radiation.nodelistTsize; j++) {
					//sl[b[i].radiation.nodelistT[j].node1].b += b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
					if (b[i].radiation.nodelistT[j].node21>-1) {
						if (b[i].radiation.nodelistT[j].node21 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistT[j].node21 - maxelm].b += -b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем Bottom, т.к. здесь top отдаёт то что лучит и наоборот поглощает то что лучит bottom.
							// Выполняется полный баланс по Ломоносову - излишек излученный botomom полностью поглотиться topom.
							//result = sl[b[i].radiation.nodelistT[j].node21].b + (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							//sl[b[i].radiation.nodelistT[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21] = sl[b[i].radiation.nodelistT[j].node21].b;
							//sl[b[i].radiation.nodelistT[j].node21].b += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistT[j].node21] += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS1;
						}
					}
					if (b[i].radiation.nodelistT[j].node22>-1) {
						if (b[i].radiation.nodelistT[j].node22 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistT[j].node21 - maxelm].b += -b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем Bottom, т.к. здесь top отдаёт то что лучит и наоборот поглощает то что лучит bottom.
							// Выполняется полный баланс по Ломоносову - излишек излученный botomom полностью поглотиться topom.
							//result = sl[b[i].radiation.nodelistT[j].node21].b + (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							//sl[b[i].radiation.nodelistT[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21] = sl[b[i].radiation.nodelistT[j].node21].b;
							//sl[b[i].radiation.nodelistT[j].node21].b += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistT[j].node22] += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS2;
						}
					}
					if (b[i].radiation.nodelistT[j].node23>-1) {
						if (b[i].radiation.nodelistT[j].node23 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistT[j].node21 - maxelm].b += -b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем Bottom, т.к. здесь top отдаёт то что лучит и наоборот поглощает то что лучит bottom.
							// Выполняется полный баланс по Ломоносову - излишек излученный botomom полностью поглотиться topom.
							//result = sl[b[i].radiation.nodelistT[j].node21].b + (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							//sl[b[i].radiation.nodelistT[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21] = sl[b[i].radiation.nodelistT[j].node21].b;
							//sl[b[i].radiation.nodelistT[j].node21].b += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistT[j].node23] += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS3;
						}
					}
					if (b[i].radiation.nodelistT[j].node24>-1) {
						if (b[i].radiation.nodelistT[j].node24 >= maxelm) {
							// Граничный.
							// Внимание минус !!!
							//slb[b[i].radiation.nodelistT[j].node21 - maxelm].b += -b[i].radiation.JT*b[i].radiation.nodelistT[j].dS;
						}
						else {
							// внутренний.
							// поменяли знак со случаем Bottom, т.к. здесь top отдаёт то что лучит и наоборот поглощает то что лучит bottom.
							// Выполняется полный баланс по Ломоносову - излишек излученный botomom полностью поглотиться topom.
							//result = sl[b[i].radiation.nodelistT[j].node21].b + (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							//sl[b[i].radiation.nodelistT[j].node21].b = alpha*(result)+(1.0 - alpha)*bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21];
							//bsource_term_radiation_for_relax[b[i].radiation.nodelistT[j].node21] = sl[b[i].radiation.nodelistT[j].node21].b;
							//sl[b[i].radiation.nodelistT[j].node21].b += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS;
							b_buffer_correct_source[b[i].radiation.nodelistT[j].node24] += (b[i].radiation.JB - b[i].radiation.JT)*b[i].radiation.nodelistT[j].dS4;
						}
					}

				}

			}
		}
	}
	
	//doublereal result34 = 0.0;  
	//doublereal alpha34 = 0.00625; // 0.00625 0.1 0.02
	//alpha34 = my_amg_manager.theta_Speed;

	for (integer i = 0; i < maxelm; i++) {
		if (fabs(b_buffer_correct_source[i]) > 1.0e-20) {
			// Без релаксации:
			//sl[i].b += b_buffer_correct_source[i];
			rthdsd[i] += b_buffer_correct_source[i];
			bsource_term_radiation_for_relax[i] = b_buffer_correct_source[i];

			// Восстаовлено 23.11.2016
			// С нижней релаксацией: 
			//result34 = b_buffer_correct_source[i];
			//doublereal badditional = alpha34*(result34)+(1.0 - alpha34)*(bsource_term_radiation_for_relax[i]);
			//rthdsd[i]+=badditional;
			//bsource_term_radiation_for_relax[i] = badditional;
			
			/*
			// закомментировано 23_11_2016.
			if (fabs(bsource_term_radiation_for_relax[i]) > 1.0e-20) {
				// С нижней релаксацией: 
				result34 = b_buffer_correct_source[i];
				if (b_buffer_correct_source[i] * bsource_term_radiation_for_relax[i] > 0.0) {
					//doublereal badditional = alpha34*(result34)+(1.0 - alpha34)*(bsource_term_radiation_for_relax[i]);
					rthdsd[i] += b_buffer_correct_source[i];
					bsource_term_radiation_for_relax[i] = b_buffer_correct_source[i];
				}
				else {
					result34 = 0.0; // противопоточная схема. Противодействует нарушению монотонности.
					//doublereal badditional = alpha34*(result34)+(1.0 - alpha34)*(bsource_term_radiation_for_relax[i]);
					rthdsd[i] += 0.0;
					//bsource_term_radiation_for_relax[i] = badditional;
				}
			}
			else {
				// С нижней релаксацией: 
				result34 = b_buffer_correct_source[i];
				//doublereal badditional = alpha34*(result34)+(1.0 - alpha34)*(bsource_term_radiation_for_relax[i]);
				rthdsd[i] += b_buffer_correct_source[i];
				bsource_term_radiation_for_relax[i] = b_buffer_correct_source[i];
			}
			*/
		}
	}
	
} // radiosity_patch_for_vacuum_Prism_Object


// Термоупругость сборка матрицы Жёсткости для шестигранной призмы.  4.08.2017.
  // 16.09.2017.
// 21.08.2020 Верный вариант для скалярных механических свойств не ортотропных.
void Thermal_Structural_assemble_Volk3(integer iP, int** nvtx,
	TOCHKA* pa, float** prop, doublereal**& Kmatrix,
	bool btimedep, doublereal timestep_sizenow, 
	doublereal timestep_sizeold,
	doublereal timestep_sizeold1, doublereal timestep_sizeold2, 
	bool bActiveShearModule)
{

	//nvtx
	// ---|+--|-+-|++-|--+|+-+|-++|+++
	// 1	2	3	4	5	6	7	8
	// 3    4    | 7    8
	// 1	2    | 5	6
	// Порядок перечисления функций формы в данной сборке.

	doublereal hx = 1.0, hy = 1.0, hz = 1.0; // размеры кубика
	volume3D(iP, nvtx, pa, hx, hy, hz);
	//printf("%e %e %e\n",hx,hy,hz);
	if (pa[nvtx[2][iP] - 1].x > pa[nvtx[3][iP] - 1].x) {
		printf("error nvtx\n");
		getchar();
	}
	//for (integer i_1 = 0; i_1 < 8; i_1++) {
		//printf("x=%e y=%e z=%e\n", pa[nvtx[i_1][iP] - 1].x, pa[nvtx[i_1][iP] - 1].y, pa[nvtx[i_1][iP] - 1].z);
	//}
	//getchar();

	//check_nvtx_order1(iP, nvtx, pa);
	//check_nvtx_order2(iP, nvtx, pa);
	//system("pause");

	// Модуль Юнга
	doublereal E = prop[YOUNG_MODULE][iP];
	const doublereal divK = 1.0e-7;
	E *= divK;
	doublereal Ex, Ey, Ez;
	//Ex = Ey = Ez = E;
	Ex = prop[MULT_YOUNG_MODULE_X][iP] * E;
	Ey = prop[MULT_YOUNG_MODULE_Y][iP] * E;
	Ez = prop[MULT_YOUNG_MODULE_Z][iP] * E;
	
	// Коэффициент Пуассона
	doublereal nu = prop[POISSON_RATIO][iP];
	doublereal nuxy, nuxz, nuyx, nuyz, nuzx, nuzy;
	//nuxy = nuxz = nuyx = nuyz = nuzx = nuzy = nu;
	nuxy = prop[MULT_POISSON_RATIO_XY][iP] * nu;
	nuxz = prop[MULT_POISSON_RATIO_XZ][iP] * nu;
	nuyz = prop[MULT_POISSON_RATIO_YZ][iP] * nu;
	nuyx = prop[MULT_POISSON_RATIO_YX][iP] * nu;
	nuzx = prop[MULT_POISSON_RATIO_ZX][iP] * nu;
	nuzy = prop[MULT_POISSON_RATIO_ZY][iP] * nu;

	// Модуль сдвига.
	doublereal Gxy, Gyz, Gxz; // shear modulus
	if (!bActiveShearModule) {
		Gxy = Gyz = Gxz = Ex / (2.0 * (1.0 + nuxy));
	}
	else {
		Gyz = prop[SHEAR_MODULE_YZ][iP];
		Gxz = prop[SHEAR_MODULE_XZ][iP];
		Gxy = prop[SHEAR_MODULE_XY][iP];
	}

	// Сборка локальной матрицы.
	// Данная матрица 24*24 сгенерирована системой символьной математики maple2019 за половину рабочего дня.

	// Книга по которой выполнена сборка:
	// 1. Г.А.Маковкин С.Ю.Лихачева
	// Применение МКЭ к решению задач механики  деформируемого твердого тела
	// Учебное пособие
	// 2. Теоретическое руководство к программе ANSYS Mechanical.
	// Часть 1

	Kmatrix[0][0] = 0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.2222222222 / (hy*hy)*Gxy +
		0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[0][1] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[0][2] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[0][3] = -0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[0][4] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[0][5] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[0][6] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.2222222222 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[0][7] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[0][8] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[0][9] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy +
		0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[0][10] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[0][11] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[0][12] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy
		- 0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[0][13] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[0][14] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[0][15] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[0][16] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[0][17] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[0][18] = 0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy
		- 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[0][19] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[0][20] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[0][21] = -0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx
		+ nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[0][22] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[0][23] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[1][0] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[1][1] = 0.2222222222 / (hx*hx)*Gxy + 0.2222222222 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[1][2] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[1][3] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[1][4] = -0.2222222222 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[1][5] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[1][6] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[1][7] = 0.1111111111 / (hx*hx)*Gxy - 0.2222222222 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[1][8] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[1][9] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[1][10] = -0.1111111111 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[1][11] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[1][12] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[1][13] = 0.1111111111 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[1][14] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[1][15] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[1][16] = -0.1111111111 / (hx*hx)*Gxy + 0.5555555555E-1 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[1][17] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[1][18] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[1][19] = 0.5555555556E-1 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[1][20] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[1][21] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[1][22] = -0.5555555556E-1 / (hx*hx)*Gxy - 0.5555555555E-1 / (hy*hy)*(
		nuxz*nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0
			)*Ey - 0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[1][23] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[2][0] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[2][1] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[2][2] = 0.2222222222 / (hx*hx)*Gxz + 0.2222222222 / (hy*hy)*Gyz +
		0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[2][3] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[2][4] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[2][5] = -0.2222222222 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[2][6] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[2][7] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[2][8] = 0.1111111111 / (hx*hx)*Gxz - 0.2222222222 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[2][9] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[2][10] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[2][11] = -0.1111111111 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz +
		0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[2][12] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[2][13] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[2][14] = 0.1111111111 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz
		- 0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[2][15] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[2][16] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[2][17] = -0.1111111111 / (hx*hx)*Gxz + 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[2][18] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[2][19] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[2][20] = 0.5555555556E-1 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[2][21] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[2][22] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[2][23] = -0.5555555556E-1 / (hx*hx)*Gxz - 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[3][0] = -0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[3][1] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[3][2] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[3][3] = 0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.2222222222 / (hy*hy)*Gxy +
		0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[3][4] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[3][5] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[3][6] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy +
		0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[3][7] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[3][8] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[3][9] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.2222222222 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[3][10] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[3][11] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[3][12] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[3][13] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[3][14] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[3][15] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy
		- 0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[3][16] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[3][17] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[3][18] = -0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx
		+ nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[3][19] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[3][20] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[3][21] = 0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy
		- 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[3][22] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[3][23] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[4][0] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[4][1] = -0.2222222222 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[4][2] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[4][3] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[4][4] = 0.2222222222 / (hx*hx)*Gxy + 0.2222222222 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[4][5] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[4][6] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[4][7] = -0.1111111111 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[4][8] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[4][9] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[4][10] = 0.1111111111 / (hx*hx)*Gxy - 0.2222222222 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[4][11] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[4][12] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[4][13] = -0.1111111111 / (hx*hx)*Gxy + 0.5555555555E-1 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[4][14] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[4][15] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[4][16] = 0.1111111111 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[4][17] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[4][18] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[4][19] = -0.5555555556E-1 / (hx*hx)*Gxy - 0.5555555555E-1 / (hy*hy)*(
		nuxz*nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0
			)*Ey - 0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[4][20] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[4][21] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[4][22] = 0.5555555556E-1 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[4][23] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[5][0] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[5][1] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[5][2] = -0.2222222222 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[5][3] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[5][4] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[5][5] = 0.2222222222 / (hx*hx)*Gxz + 0.2222222222 / (hy*hy)*Gyz +
		0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[5][6] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[5][7] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[5][8] = -0.1111111111 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz +
		0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[5][9] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[5][10] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[5][11] = 0.1111111111 / (hx*hx)*Gxz - 0.2222222222 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[5][12] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[5][13] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[5][14] = -0.1111111111 / (hx*hx)*Gxz + 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[5][15] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[5][16] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[5][17] = 0.1111111111 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz
		- 0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[5][18] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[5][19] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[5][20] = -0.5555555556E-1 / (hx*hx)*Gxz - 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[5][21] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[5][22] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[5][23] = 0.5555555556E-1 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[6][0] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.2222222222 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[6][1] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[6][2] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[6][3] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy +
		0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[6][4] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[6][5] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[6][6] = 0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.2222222222 / (hy*hy)*Gxy +
		0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[6][7] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[6][8] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[6][9] = -0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[6][10] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[6][11] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[6][12] = 0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy
		- 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[6][13] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[6][14] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[6][15] = -0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx
		+ nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[6][16] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[6][17] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[6][18] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy
		- 0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[6][19] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[6][20] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[6][21] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[6][22] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[6][23] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[7][0] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[7][1] = 0.1111111111 / (hx*hx)*Gxy - 0.2222222222 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[7][2] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[7][3] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[7][4] = -0.1111111111 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[7][5] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[7][6] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[7][7] = 0.2222222222 / (hx*hx)*Gxy + 0.2222222222 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[7][8] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[7][9] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[7][10] = -0.2222222222 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[7][11] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[7][12] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[7][13] = 0.5555555556E-1 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[7][14] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[7][15] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[7][16] = -0.5555555556E-1 / (hx*hx)*Gxy - 0.5555555555E-1 / (hy*hy)*(
		nuxz*nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0
			)*Ey - 0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[7][17] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[7][18] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[7][19] = 0.1111111111 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[7][20] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[7][21] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[7][22] = -0.1111111111 / (hx*hx)*Gxy + 0.5555555555E-1 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[7][23] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[8][0] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[8][1] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[8][2] = 0.1111111111 / (hx*hx)*Gxz - 0.2222222222 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[8][3] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[8][4] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[8][5] = -0.1111111111 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz +
		0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[8][6] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[8][7] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[8][8] = 0.2222222222 / (hx*hx)*Gxz + 0.2222222222 / (hy*hy)*Gyz +
		0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[8][9] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[8][10] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[8][11] = -0.2222222222 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[8][12] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[8][13] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[8][14] = 0.5555555556E-1 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[8][15] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[8][16] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[8][17] = -0.5555555556E-1 / (hx*hx)*Gxz - 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[8][18] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[8][19] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[8][20] = 0.1111111111 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz
		- 0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[8][21] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[8][22] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[8][23] = -0.1111111111 / (hx*hx)*Gxz + 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[9][0] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy +
		0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[9][1] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[9][2] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[9][3] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.2222222222 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[9][4] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[9][5] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[9][6] = -0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[9][7] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[9][8] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[9][9] = 0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.2222222222 / (hy*hy)*Gxy +
		0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[9][10] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[9][11] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[9][12] = -0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx
		+ nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[9][13] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[9][14] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[9][15] = 0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy
		- 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[9][16] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[9][17] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[9][18] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[9][19] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[9][20] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[9][21] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy
		- 0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[9][22] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[9][23] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[10][0] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[10][1] = -0.1111111111 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[10][2] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[10][3] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[10][4] = 0.1111111111 / (hx*hx)*Gxy - 0.2222222222 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[10][5] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[10][6] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[10][7] = -0.2222222222 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[10][8] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[10][9] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[10][10] = 0.2222222222 / (hx*hx)*Gxy + 0.2222222222 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[10][11] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[10][12] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[10][13] = -0.5555555556E-1 / (hx*hx)*Gxy - 0.5555555555E-1 / (hy*hy)*(
		nuxz*nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0
			)*Ey - 0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[10][14] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[10][15] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[10][16] = 0.5555555556E-1 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[10][17] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[10][18] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[10][19] = -0.1111111111 / (hx*hx)*Gxy + 0.5555555555E-1 / (hy*hy)*(nuxz
		*nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[10][20] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[10][21] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[10][22] = 0.1111111111 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[10][23] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[11][0] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[11][1] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[11][2] = -0.1111111111 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz +
		0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[11][3] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[11][4] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[11][5] = 0.1111111111 / (hx*hx)*Gxz - 0.2222222222 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[11][6] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[11][7] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[11][8] = -0.2222222222 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[11][9] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[11][10] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[11][11] = 0.2222222222 / (hx*hx)*Gxz + 0.2222222222 / (hy*hy)*Gyz +
		0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[11][12] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[11][13] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[11][14] = -0.5555555556E-1 / (hx*hx)*Gxz - 0.5555555555E-1 / (hy*hy)*
		Gyz - 0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy
			* nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[11][15] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[11][16] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[11][17] = 0.5555555556E-1 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[11][18] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[11][19] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[11][20] = -0.1111111111 / (hx*hx)*Gxz + 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[11][21] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[11][22] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[11][23] = 0.1111111111 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz
		- 0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[12][0] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy
		- 0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[12][1] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[12][2] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[12][3] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[12][4] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[12][5] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[12][6] = 0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy
		- 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[12][7] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[12][8] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[12][9] = -0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx
		+ nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[12][10] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[12][11] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[12][12] = 0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.2222222222 / (hy*hy)*Gxy +
		0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[12][13] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[12][14] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[12][15] = -0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[12][16] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[12][17] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[12][18] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.2222222222 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[12][19] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[12][20] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[12][21] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy +
		0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[12][22] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[12][23] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[13][0] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[13][1] = 0.1111111111 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[13][2] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[13][3] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[13][4] = -0.1111111111 / (hx*hx)*Gxy + 0.5555555555E-1 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[13][5] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[13][6] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[13][7] = 0.5555555556E-1 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[13][8] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[13][9] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[13][10] = -0.5555555556E-1 / (hx*hx)*Gxy - 0.5555555555E-1 / (hy*hy)*(
		nuxz*nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0
			)*Ey - 0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[13][11] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[13][12] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[13][13] = 0.2222222222 / (hx*hx)*Gxy + 0.2222222222 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[13][14] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[13][15] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[13][16] = -0.2222222222 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[13][17] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[13][18] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[13][19] = 0.1111111111 / (hx*hx)*Gxy - 0.2222222222 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[13][20] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[13][21] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[13][22] = -0.1111111111 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[13][23] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[14][0] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[14][1] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[14][2] = 0.1111111111 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz
		- 0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[14][3] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[14][4] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[14][5] = -0.1111111111 / (hx*hx)*Gxz + 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[14][6] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[14][7] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[14][8] = 0.5555555556E-1 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[14][9] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[14][10] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[14][11] = -0.5555555556E-1 / (hx*hx)*Gxz - 0.5555555555E-1 / (hy*hy)*
		Gyz - 0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy
			* nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[14][12] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[14][13] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[14][14] = 0.2222222222 / (hx*hx)*Gxz + 0.2222222222 / (hy*hy)*Gyz +
		0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[14][15] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[14][16] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[14][17] = -0.2222222222 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[14][18] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[14][19] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[14][20] = 0.1111111111 / (hx*hx)*Gxz - 0.2222222222 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[14][21] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[14][22] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[14][23] = -0.1111111111 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz +
		0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[15][0] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[15][1] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[15][2] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[15][3] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy
		- 0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[15][4] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[15][5] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[15][6] = -0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx
		+ nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[15][7] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[15][8] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[15][9] = 0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy
		- 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[15][10] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[15][11] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[15][12] = -0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[15][13] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[15][14] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[15][15] = 0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.2222222222 / (hy*hy)*Gxy +
		0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[15][16] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[15][17] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[15][18] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy +
		0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[15][19] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[15][20] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[15][21] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.2222222222 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[15][22] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[15][23] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[16][0] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[16][1] = -0.1111111111 / (hx*hx)*Gxy + 0.5555555555E-1 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[16][2] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[16][3] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[16][4] = 0.1111111111 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[16][5] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[16][6] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[16][7] = -0.5555555556E-1 / (hx*hx)*Gxy - 0.5555555555E-1 / (hy*hy)*(
		nuxz*nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0
			)*Ey - 0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[16][8] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[16][9] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[16][10] = 0.5555555556E-1 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[16][11] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[16][12] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[16][13] = -0.2222222222 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[16][14] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[16][15] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[16][16] = 0.2222222222 / (hx*hx)*Gxy + 0.2222222222 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[16][17] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[16][18] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[16][19] = -0.1111111111 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[16][20] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[16][21] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[16][22] = 0.1111111111 / (hx*hx)*Gxy - 0.2222222222 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[16][23] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[17][0] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[17][1] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[17][2] = -0.1111111111 / (hx*hx)*Gxz + 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[17][3] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[17][4] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[17][5] = 0.1111111111 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz
		- 0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[17][6] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[17][7] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[17][8] = -0.5555555556E-1 / (hx*hx)*Gxz - 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[17][9] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[17][10] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[17][11] = 0.5555555556E-1 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[17][12] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[17][13] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[17][14] = -0.2222222222 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[17][15] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[17][16] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[17][17] = 0.2222222222 / (hx*hx)*Gxz + 0.2222222222 / (hy*hy)*Gyz +
		0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[17][18] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[17][19] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[17][20] = -0.1111111111 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz +
		0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[17][21] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[17][22] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[17][23] = 0.1111111111 / (hx*hx)*Gxz - 0.2222222222 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[18][0] = 0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy
		- 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[18][1] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[18][2] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[18][3] = -0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx
		+ nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[18][4] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[18][5] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[18][6] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy
		- 0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[18][7] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[18][8] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[18][9] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[18][10] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[18][11] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[18][12] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.2222222222 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[18][13] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[18][14] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[18][15] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy +
		0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[18][16] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[18][17] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[18][18] = 0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.2222222222 / (hy*hy)*Gxy +
		0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[18][19] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[18][20] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[18][21] = -0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[18][22] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[18][23] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[19][0] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[19][1] = 0.5555555556E-1 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[19][2] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[19][3] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[19][4] = -0.5555555556E-1 / (hx*hx)*Gxy - 0.5555555555E-1 / (hy*hy)*(
		nuxz*nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0
			)*Ey - 0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[19][5] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[19][6] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[19][7] = 0.1111111111 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*nuzx
		- 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[19][8] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[19][9] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[19][10] = -0.1111111111 / (hx*hx)*Gxy + 0.5555555555E-1 / (hy*hy)*(nuxz
		*nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[19][11] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[19][12] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[19][13] = 0.1111111111 / (hx*hx)*Gxy - 0.2222222222 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[19][14] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[19][15] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[19][16] = -0.1111111111 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[19][17] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[19][18] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[19][19] = 0.2222222222 / (hx*hx)*Gxy + 0.2222222222 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[19][20] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[19][21] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[19][22] = -0.2222222222 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[19][23] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[20][0] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[20][1] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[20][2] = 0.5555555556E-1 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[20][3] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[20][4] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[20][5] = -0.5555555556E-1 / (hx*hx)*Gxz - 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[20][6] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[20][7] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[20][8] = 0.1111111111 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz
		- 0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[20][9] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[20][10] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[20][11] = -0.1111111111 / (hx*hx)*Gxz + 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[20][12] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[20][13] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[20][14] = 0.1111111111 / (hx*hx)*Gxz - 0.2222222222 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[20][15] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[20][16] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[20][17] = -0.1111111111 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz +
		0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[20][18] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[20][19] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[20][20] = 0.2222222222 / (hx*hx)*Gxz + 0.2222222222 / (hy*hy)*Gyz +
		0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[20][21] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[20][22] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[20][23] = -0.2222222222 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[21][0] = -0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx
		+ nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[21][1] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[21][2] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[21][3] = 0.5555555556E-1 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy
		- 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[21][4] = 0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[21][5] = 0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[21][6] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.5555555555E-1 / (hy*hy)*
		Gxy - 0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[21][7] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[21][8] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[21][9] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy
		- 0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[21][10] = -0.8333333333E-1 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[21][11] = 0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[21][12] = -0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.1111111111 / (hy*hy)*Gxy +
		0.5555555554E-1 / (hz*hz)*Gxz;
	Kmatrix[21][13] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[21][14] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[21][15] = 0.1111111111 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex - 0.2222222222 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[21][16] = 0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[21][17] = -0.8333333334E-1 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[21][18] = -0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.1111111111 / (hy*hy)*Gxy +
		0.1111111111 / (hz*hz)*Gxz;
	Kmatrix[21][19] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[21][20] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[21][21] = 0.2222222222 / (hx*hx)*(nuyz*nuzy - 1.0) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex + 0.2222222222 / (hy*hy)*Gxy +
		0.2222222222 / (hz*hz)*Gxz;
	Kmatrix[21][22] = -0.1666666667 / hx * (nuxz*nuzy + nuxy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[21][23] = -0.1666666667 / hx * (nuxy*nuyz + nuxz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[22][0] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[22][1] = -0.5555555556E-1 / (hx*hx)*Gxy - 0.5555555555E-1 / (hy*hy)*(
		nuxz*nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0
			)*Ey - 0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[22][2] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[22][3] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[22][4] = 0.5555555556E-1 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[22][5] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[22][6] = 0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy / hx;
	Kmatrix[22][7] = -0.1111111111 / (hx*hx)*Gxy + 0.5555555555E-1 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[22][8] = 0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[22][9] = -0.8333333333E-1 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333333E-1 / hy * Gxy /
		hx;
	Kmatrix[22][10] = 0.1111111111 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey
		- 0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[22][11] = 0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[22][12] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[22][13] = -0.1111111111 / (hx*hx)*Gxy - 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.5555555554E-1 / (hz*hz)*Gyz;
	Kmatrix[22][14] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[22][15] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hy * Gxy / hx;
	Kmatrix[22][16] = 0.1111111111 / (hx*hx)*Gxy - 0.2222222222 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[22][17] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[22][18] = 0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[22][19] = -0.2222222222 / (hx*hx)*Gxy + 0.1111111111 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.1111111111 / (hz*hz)*Gyz;
	Kmatrix[22][20] = -0.8333333332E-1 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[22][21] = -0.1666666667 / hy * (nuyz*nuzx + nuyx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hy * Gxy / hx;
	Kmatrix[22][22] = 0.2222222222 / (hx*hx)*Gxy + 0.2222222222 / (hy*hy)*(nuxz*
		nuzx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey +
		0.2222222222 / (hz*hz)*Gyz;
	Kmatrix[22][23] = -0.1666666667 / hy * (nuxz*nuyx + nuyz) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez / hz + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[23][0] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz / hx;
	Kmatrix[23][1] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz
		* nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz / hy;
	Kmatrix[23][2] = -0.5555555556E-1 / (hx*hx)*Gxz - 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[23][3] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[23][4] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[23][5] = 0.5555555556E-1 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[23][6] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[23][7] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[23][8] = -0.1111111111 / (hx*hx)*Gxz + 0.5555555555E-1 / (hy*hy)*Gyz
		- 0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[23][9] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx - 0.1666666667 / hz * Gxz / hx;
	Kmatrix[23][10] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy - 0.1666666667 / hz * Gyz / hy;
	Kmatrix[23][11] = 0.1111111111 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz
		- 0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[23][12] = 0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[23][13] = 0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[23][14] = -0.1111111111 / (hx*hx)*Gxz - 0.1111111111 / (hy*hy)*Gyz +
		0.5555555554E-1 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy *
			nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[23][15] = -0.8333333334E-1 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.8333333334E-1 / hz * Gxz /
		hx;
	Kmatrix[23][16] = 0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[23][17] = 0.1111111111 / (hx*hx)*Gxz - 0.2222222222 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[23][18] = 0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[23][19] = -0.8333333332E-1 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx +
		nuxz * nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.8333333332E-1 / hz * Gyz /
		hy;
	Kmatrix[23][20] = -0.2222222222 / (hx*hx)*Gxz + 0.1111111111 / (hy*hy)*Gyz +
		0.1111111111 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;
	Kmatrix[23][21] = -0.1666666667 / hz * (nuyx*nuzy + nuzx) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ex / hx + 0.1666666667 / hz * Gxz / hx;
	Kmatrix[23][22] = -0.1666666667 / hz * (nuxy*nuzx + nuzy) / (nuxy*nuyz*nuzx + nuxz *
		nuyx*nuzy + nuxy * nuyx + nuxz * nuzx + nuyz * nuzy - 1.0)*Ey / hy + 0.1666666667 / hz * Gyz / hy;
	Kmatrix[23][23] = 0.2222222222 / (hx*hx)*Gxz + 0.2222222222 / (hy*hy)*Gyz +
		0.2222222222 / (hz*hz)*(nuxy*nuyx - 1.0) / (nuxy*nuyz*nuzx + nuxz * nuyx*nuzy + nuxy * nuyx +
			nuxz * nuzx + nuyz * nuzy - 1.0)*Ez;

	for (integer i_1 = 0; i_1 < 24; i_1++) {
		for (integer j_1 = 0; j_1 < 24; j_1++) {
			Kmatrix[i_1][j_1] *= hx * hy * hz;
		}
	}


	if (btimedep) {
		// Нестационарная добавка к диагонали.
		for (integer i_1 = 0; i_1 < 24; i_1++) {
			Kmatrix[i_1][i_1] += 0.125*prop[RHO][iP] * hx * hy * hz / (timestep_sizenow*0.5*(timestep_sizeold+timestep_sizenow));
			// Высокий порядок n=4, осцилирует.
			/*Kmatrix[i_1][i_1] += 0.125 * prop[RHO][iP] * hx * hy * hz* (1.0 / ((timestep_sizenow + timestep_sizeold + timestep_sizeold1)* 0.5 * (timestep_sizeold + timestep_sizenow))+
				1.0 / ((timestep_sizenow + timestep_sizeold + timestep_sizeold1) * 0.5 * (timestep_sizenow)) + 
				1.0 / ((timestep_sizenow + timestep_sizeold + timestep_sizeold1) * 0.5 * (timestep_sizeold + timestep_sizenow + timestep_sizeold1 + timestep_sizeold2))+
				1.0 / ((timestep_sizenow + timestep_sizeold) * 0.5 * (timestep_sizenow)) + 
				1.0 / ((timestep_sizenow + timestep_sizeold) * 0.5 * (timestep_sizenow + timestep_sizeold + timestep_sizeold1 + timestep_sizeold2)) + 
				1.0 / ((timestep_sizenow) * 0.5 * (timestep_sizenow + timestep_sizeold + timestep_sizeold1 + timestep_sizeold2)));*/
		}
	}

	// Внимание никакой смены индексов - переупорядочения не требуется.
	// Всё верно. Ни в коем случае ничео не менять. 22.08.2020.
	// В соответствии с файлом МКЭ7. см. 22.08.2020.


} // Thermal_Structural_assemble_Volk3

// Термоупругость сборка матрицы Жёсткости для шестигранной призмы.  4.08.2017.
  // 16.09.2017.
// 21.08.2020 Верный вариант для скалярных механических свойств не ортотропных.
void Thermal_Structural_assemble_Volk4(integer iP, int** nvtx,
	TOCHKA* pa, float** prop, doublereal**& Kmatrix,
	bool btimedep, doublereal timestep_sizenow, doublereal timestep_sizeold,
	doublereal timestep_sizeold1, doublereal timestep_sizeold2)
{

	//nvtx
	// ---|+--|-+-|++-|--+|+-+|-++|+++
	// 1	2	3	4	5	6	7	8
	// 3    4    | 7    8
	// 1	2    | 5	6
	// Порядок перечисления функций формы в данной сборке.

	doublereal hx = 1.0, hy = 1.0, hz = 1.0; // размеры кубика
	volume3D(iP, nvtx, pa, hx, hy, hz);
	//printf("%e %e %e\n",hx,hy,hz);
	if (pa[nvtx[2][iP] - 1].x > pa[nvtx[3][iP] - 1].x) {
		printf("error nvtx\n");
		getchar();
	}
	//for (integer i_1 = 0; i_1 < 8; i_1++) {
		//printf("x=%e y=%e z=%e\n", pa[nvtx[i_1][iP] - 1].x, pa[nvtx[i_1][iP] - 1].y, pa[nvtx[i_1][iP] - 1].z);
	//}
	//getchar();

	check_nvtx_order1(iP, nvtx, pa);
	check_nvtx_order2(iP, nvtx, pa);
	//system("pause");

	
	doublereal E = prop[YOUNG_MODULE][iP];
	const doublereal divK = 1.0e-7;
	E *= divK;
	//doublereal nu = E / (2.0 * mu1) -1.0; // Poisson ratio
	doublereal nu = prop[POISSON_RATIO][iP];
	// Параметры из книжки. 
	doublereal lambda = nu / (1.0 - nu);
	doublereal mu = (1.0 - 2.0 * nu) / (2.0 * (1.0 - nu));
	doublereal Em = E * (1.0 - nu) / ((1.0+nu)*(1.0-2.0*nu));

	//const doublereal kc1 = 0.05555557;
	//const doublereal kc2 = 0.04166666;
	//const doublereal kc3 = 0.02777777;
	//const doublereal kc4 = 0.02083333;
	//const doublereal kc5 = 0.01388888;

	// Сборка локальной матрицы.
	// Данная матрица 24*24 сгенерирована системой символьной математики maple2019 за половину рабочего дня.

	// Книга по которой выполнена сборка:
	// Г.А.Маковкин С.Ю.Лихачева
	// Применение МКЭ к решению задач механики  деформируемого твердого тела
	// Учебное пособие
	// Часть 1

	Kmatrix[0][0] = 0.2222222222 / (hx*hx)*Em + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[0][1] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[0][2] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[0][3] = -0.2222222222 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[0][4] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[0][5] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[0][6] = 0.1111111111 / (hx*hx)*Em - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[0][7] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[0][8] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu /
		hx;
	Kmatrix[0][9] = -0.1111111111 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[0][10] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[0][11] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[0][12] = 0.1111111111 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[0][13] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[0][14] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[0][15] = -0.1111111111 / (hx*hx)*Em + 0.5555555555E-1 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[0][16] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[0][17] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[0][18] = 0.5555555556E-1 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[0][19] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[0][20] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[0][21] = -0.5555555556E-1 / (hx*hx)*Em - 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[0][22] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[0][23] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[1][0] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[1][1] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[1][2] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[1][3] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[1][4] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[1][5] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*mu /
		hy;
	Kmatrix[1][6] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[1][7] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[1][8] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[1][9] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[1][10] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[1][11] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[1][12] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[1][13] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[1][14] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[1][15] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[1][16] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[1][17] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[1][18] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[1][19] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[1][20] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[1][21] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[1][22] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[1][23] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[2][0] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[2][1] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[2][2] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em;
	Kmatrix[2][3] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[2][4] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*mu /
		hy;
	Kmatrix[2][5] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[2][6] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu /
		hx;
	Kmatrix[2][7] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[2][8] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[2][9] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[2][10] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[2][11] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[2][12] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[2][13] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[2][14] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em;
	Kmatrix[2][15] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[2][16] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[2][17] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.1111111111 / (hz*hz)*Em;
	Kmatrix[2][18] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[2][19] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[2][20] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em;
	Kmatrix[2][21] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[2][22] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[2][23] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em*mu - 0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[3][0] = -0.2222222222 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[3][1] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[3][2] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[3][3] = 0.2222222222 / (hx*hx)*Em + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[3][4] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[3][5] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[3][6] = -0.1111111111 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[3][7] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[3][8] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[3][9] = 0.1111111111 / (hx*hx)*Em - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[3][10] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[3][11] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[3][12] = -0.1111111111 / (hx*hx)*Em + 0.5555555555E-1 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[3][13] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[3][14] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[3][15] = 0.1111111111 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[3][16] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[3][17] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[3][18] = -0.5555555556E-1 / (hx*hx)*Em - 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[3][19] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[3][20] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[3][21] = 0.5555555556E-1 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[3][22] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[3][23] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[4][0] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[4][1] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[4][2] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*mu /
		hy;
	Kmatrix[4][3] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[4][4] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[4][5] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[4][6] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[4][7] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[4][8] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*mu /
		hy;
	Kmatrix[4][9] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[4][10] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[4][11] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[4][12] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[4][13] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[4][14] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[4][15] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[4][16] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[4][17] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[4][18] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[4][19] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[4][20] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[4][21] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[4][22] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[4][23] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[5][0] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[5][1] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*mu /
		hy;
	Kmatrix[5][2] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[5][3] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[5][4] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[5][5] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em;
	Kmatrix[5][6] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu /
		hx;
	Kmatrix[5][7] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[5][8] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[5][9] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[5][10] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[5][11] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[5][12] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[5][13] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[5][14] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.1111111111 / (hz*hz)*Em;
	Kmatrix[5][15] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[5][16] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[5][17] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em;
	Kmatrix[5][18] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[5][19] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[5][20] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em*mu - 0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[5][21] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[5][22] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[5][23] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em;
	Kmatrix[6][0] = 0.1111111111 / (hx*hx)*Em - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[6][1] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[6][2] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu /
		hx;
	Kmatrix[6][3] = -0.1111111111 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[6][4] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[6][5] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu /
		hx;
	Kmatrix[6][6] = 0.2222222222 / (hx*hx)*Em + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[6][7] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[6][8] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[6][9] = -0.2222222222 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[6][10] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[6][11] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[6][12] = 0.5555555556E-1 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[6][13] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[6][14] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[6][15] = -0.5555555556E-1 / (hx*hx)*Em - 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[6][16] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[6][17] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[6][18] = 0.1111111111 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[6][19] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[6][20] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[6][21] = -0.1111111111 / (hx*hx)*Em + 0.5555555555E-1 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[6][22] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[6][23] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[7][0] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[7][1] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[7][2] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[7][3] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[7][4] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[7][5] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[7][6] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[7][7] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[7][8] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[7][9] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[7][10] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[7][11] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[7][12] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[7][13] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[7][14] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[7][15] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[7][16] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[7][17] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[7][18] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[7][19] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[7][20] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[7][21] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[7][22] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[7][23] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[8][0] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu /
		hx;
	Kmatrix[8][1] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[8][2] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[8][3] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[8][4] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*mu /
		hy;
	Kmatrix[8][5] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[8][6] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[8][7] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[8][8] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em;
	Kmatrix[8][9] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[8][10] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[8][11] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[8][12] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[8][13] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[8][14] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em;
	Kmatrix[8][15] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[8][16] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[8][17] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em*mu - 0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[8][18] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[8][19] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[8][20] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em;
	Kmatrix[8][21] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[8][22] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[8][23] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.1111111111 / (hz*hz)*Em;
	Kmatrix[9][0] = -0.1111111111 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[9][1] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[9][2] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[9][3] = 0.1111111111 / (hx*hx)*Em - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[9][4] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[9][5] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[9][6] = -0.2222222222 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[9][7] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[9][8] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[9][9] = 0.2222222222 / (hx*hx)*Em + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[9][10] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[9][11] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[9][12] = -0.5555555556E-1 / (hx*hx)*Em - 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[9][13] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[9][14] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[9][15] = 0.5555555556E-1 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[9][16] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[9][17] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[9][18] = -0.1111111111 / (hx*hx)*Em + 0.5555555555E-1 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[9][19] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[9][20] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[9][21] = 0.1111111111 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[9][22] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[9][23] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[10][0] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[10][1] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[10][2] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[10][3] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[10][4] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[10][5] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[10][6] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[10][7] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[10][8] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[10][9] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[10][10] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[10][11] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[10][12] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[10][13] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[10][14] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[10][15] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[10][16] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[10][17] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[10][18] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[10][19] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[10][20] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[10][21] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[10][22] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[10][23] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[11][0] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[11][1] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[11][2] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[11][3] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[11][4] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[11][5] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[11][6] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[11][7] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[11][8] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[11][9] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[11][10] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[11][11] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em;
	Kmatrix[11][12] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[11][13] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[11][14] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em*mu - 0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[11][15] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[11][16] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[11][17] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*
		mu - 0.1111111111 / (hz*hz)*Em;
	Kmatrix[11][18] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[11][19] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[11][20] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.1111111111 / (hz*hz)*Em;
	Kmatrix[11][21] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[11][22] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[11][23] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em;
	Kmatrix[12][0] = 0.1111111111 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[12][1] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[12][2] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[12][3] = -0.1111111111 / (hx*hx)*Em + 0.5555555555E-1 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[12][4] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[12][5] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[12][6] = 0.5555555556E-1 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[12][7] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[12][8] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[12][9] = -0.5555555556E-1 / (hx*hx)*Em - 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[12][10] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[12][11] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[12][12] = 0.2222222222 / (hx*hx)*Em + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[12][13] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[12][14] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[12][15] = -0.2222222222 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[12][16] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[12][17] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[12][18] = 0.1111111111 / (hx*hx)*Em - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[12][19] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[12][20] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[12][21] = -0.1111111111 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[12][22] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[12][23] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[13][0] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[13][1] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[13][2] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[13][3] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[13][4] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[13][5] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[13][6] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[13][7] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[13][8] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[13][9] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[13][10] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[13][11] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[13][12] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[13][13] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[13][14] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[13][15] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[13][16] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[13][17] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[13][18] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[13][19] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[13][20] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[13][21] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[13][22] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[13][23] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[14][0] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[14][1] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[14][2] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em;
	Kmatrix[14][3] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[14][4] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[14][5] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.1111111111 / (hz*hz)*Em;
	Kmatrix[14][6] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[14][7] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[14][8] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em;
	Kmatrix[14][9] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[14][10] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[14][11] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em*mu - 0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[14][12] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[14][13] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[14][14] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em;
	Kmatrix[14][15] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[14][16] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[14][17] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[14][18] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[14][19] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[14][20] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[14][21] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[14][22] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[14][23] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[15][0] = -0.1111111111 / (hx*hx)*Em + 0.5555555555E-1 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[15][1] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[15][2] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[15][3] = 0.1111111111 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[15][4] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[15][5] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[15][6] = -0.5555555556E-1 / (hx*hx)*Em - 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[15][7] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[15][8] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[15][9] = 0.5555555556E-1 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[15][10] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[15][11] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[15][12] = -0.2222222222 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[15][13] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[15][14] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[15][15] = 0.2222222222 / (hx*hx)*Em + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[15][16] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[15][17] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[15][18] = -0.1111111111 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[15][19] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[15][20] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[15][21] = 0.1111111111 / (hx*hx)*Em - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[15][22] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[15][23] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[16][0] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[16][1] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[16][2] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[16][3] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[16][4] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[16][5] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[16][6] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[16][7] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[16][8] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[16][9] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[16][10] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[16][11] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[16][12] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[16][13] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[16][14] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[16][15] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[16][16] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[16][17] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[16][18] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[16][19] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[16][20] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[16][21] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[16][22] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[16][23] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[17][0] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[17][1] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[17][2] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.1111111111 / (hz*hz)*Em;
	Kmatrix[17][3] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[17][4] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[17][5] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em;
	Kmatrix[17][6] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[17][7] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[17][8] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em*mu - 0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[17][9] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[17][10] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[17][11] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*
		mu - 0.1111111111 / (hz*hz)*Em;
	Kmatrix[17][12] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[17][13] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[17][14] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[17][15] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[17][16] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[17][17] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em;
	Kmatrix[17][18] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[17][19] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[17][20] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[17][21] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[17][22] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[17][23] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[18][0] = 0.5555555556E-1 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[18][1] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[18][2] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[18][3] = -0.5555555556E-1 / (hx*hx)*Em - 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[18][4] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[18][5] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[18][6] = 0.1111111111 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[18][7] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[18][8] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[18][9] = -0.1111111111 / (hx*hx)*Em + 0.5555555555E-1 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[18][10] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[18][11] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[18][12] = 0.1111111111 / (hx*hx)*Em - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[18][13] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[18][14] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[18][15] = -0.1111111111 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[18][16] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[18][17] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[18][18] = 0.2222222222 / (hx*hx)*Em + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[18][19] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[18][20] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[18][21] = -0.2222222222 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[18][22] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[18][23] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[19][0] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[19][1] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[19][2] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[19][3] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[19][4] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[19][5] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[19][6] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[19][7] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[19][8] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[19][9] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[19][10] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[19][11] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[19][12] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[19][13] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[19][14] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[19][15] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[19][16] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[19][17] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[19][18] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[19][19] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[19][20] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[19][21] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[19][22] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[19][23] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[20][0] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[20][1] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[20][2] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em;
	Kmatrix[20][3] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[20][4] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[20][5] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em*mu - 0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[20][6] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[20][7] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[20][8] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em;
	Kmatrix[20][9] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[20][10] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[20][11] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.1111111111 / (hz*hz)*Em;
	Kmatrix[20][12] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[20][13] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[20][14] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[20][15] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[20][16] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[20][17] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[20][18] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[20][19] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[20][20] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em;
	Kmatrix[20][21] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[20][22] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[20][23] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[21][0] = -0.5555555556E-1 / (hx*hx)*Em - 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[21][1] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[21][2] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[21][3] = 0.5555555556E-1 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[21][4] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[21][5] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[21][6] = -0.1111111111 / (hx*hx)*Em + 0.5555555555E-1 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[21][7] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[21][8] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[21][9] = 0.1111111111 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[21][10] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[21][11] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[21][12] = -0.1111111111 / (hx*hx)*Em - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[21][13] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[21][14] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[21][15] = 0.1111111111 / (hx*hx)*Em - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[21][16] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[21][17] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[21][18] = -0.2222222222 / (hx*hx)*Em + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[21][19] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[21][20] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[21][21] = 0.2222222222 / (hx*hx)*Em + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[21][22] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[21][23] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[22][0] = -0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[22][1] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em - 0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[22][2] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[22][3] = 0.8333333333E-1 / hx * Em*lambda / hy - 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[22][4] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[22][5] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[22][6] = -0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*
		mu / hx;
	Kmatrix[22][7] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em
		- 0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[22][8] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[22][9] = 0.8333333333E-1 / hx * Em*lambda / hy + 0.8333333333E-1 / hy * Em*mu
		/ hx;
	Kmatrix[22][10] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em
		- 0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[22][11] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[22][12] = -0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[22][13] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em +
		0.5555555554E-1 / (hz*hz)*Em*mu;
	Kmatrix[22][14] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[22][15] = 0.1666666667 / hx * Em*lambda / hy - 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[22][16] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[22][17] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[22][18] = -0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[22][19] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em +
		0.1111111111 / (hz*hz)*Em*mu;
	Kmatrix[22][20] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[22][21] = 0.1666666667 / hx * Em*lambda / hy + 0.1666666667 / hy * Em*mu / hx;
	Kmatrix[22][22] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em +
		0.2222222222 / (hz*hz)*Em*mu;
	Kmatrix[22][23] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[23][0] = -0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[23][1] = -0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[23][2] = -0.5555555556E-1 / (hx*hx)*Em*mu - 0.5555555555E-1 / (hy*hy)*
		Em*mu - 0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[23][3] = 0.8333333334E-1 / hx * Em*lambda / hz - 0.8333333334E-1 / hz * Em*mu
		/ hx;
	Kmatrix[23][4] = -0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[23][5] = 0.5555555556E-1 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu
		- 0.1111111111 / (hz*hz)*Em;
	Kmatrix[23][6] = -0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[23][7] = 0.8333333332E-1 / hy * Em*lambda / hz - 0.8333333332E-1 / hz * Em*mu
		/ hy;
	Kmatrix[23][8] = -0.1111111111 / (hx*hx)*Em*mu + 0.5555555555E-1 / (hy*hy)*Em*
		mu - 0.1111111111 / (hz*hz)*Em;
	Kmatrix[23][9] = 0.1666666667 / hx * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[23][10] = 0.1666666667 / hy * Em*lambda / hz - 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[23][11] = 0.1111111111 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu
		- 0.2222222222 / (hz*hz)*Em;
	Kmatrix[23][12] = -0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[23][13] = -0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[23][14] = -0.1111111111 / (hx*hx)*Em*mu - 0.1111111111 / (hy*hy)*Em*mu +
		0.5555555554E-1 / (hz*hz)*Em;
	Kmatrix[23][15] = 0.8333333334E-1 / hx * Em*lambda / hz + 0.8333333334E-1 / hz * Em*
		mu / hx;
	Kmatrix[23][16] = -0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[23][17] = 0.1111111111 / (hx*hx)*Em*mu - 0.2222222222 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[23][18] = -0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[23][19] = 0.8333333332E-1 / hy * Em*lambda / hz + 0.8333333332E-1 / hz * Em*
		mu / hy;
	Kmatrix[23][20] = -0.2222222222 / (hx*hx)*Em*mu + 0.1111111111 / (hy*hy)*Em*mu +
		0.1111111111 / (hz*hz)*Em;
	Kmatrix[23][21] = 0.1666666667 / hx * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hx;
	Kmatrix[23][22] = 0.1666666667 / hy * Em*lambda / hz + 0.1666666667 / hz * Em*mu / hy;
	Kmatrix[23][23] = 0.2222222222 / (hx*hx)*Em*mu + 0.2222222222 / (hy*hy)*Em*mu +
		0.2222222222 / (hz*hz)*Em;


	///K = ES / L;


	for (integer i_1 = 0; i_1 < 24; i_1++) {
		for (integer j_1 = 0; j_1 < 24; j_1++) {
			Kmatrix[i_1][j_1] *= fabs(hx * hy * hz);			
		}
	}


	if (btimedep) {

		

		// Нестационарная добавка к диагонали.
		for (integer i_1 = 0; i_1 < 24; i_1++) {
			//Kmatrix[i_1][i_1] += 0.125*prop[RHO][iP] * hx * hy * hz / (timestep_sizenow*timestep_sizenow);

			

			Kmatrix[i_1][i_1] += 0.125 * prop[RHO][iP] * hx * hy * hz / (timestep_sizenow * 0.5 * (timestep_sizeold + timestep_sizenow));
			

			// Высокий порядок n=4, осцилирует.
			/*Kmatrix[i_1][i_1] += 0.125 * prop[RHO][iP] * hx * hy * hz* (1.0 / ((timestep_sizenow + timestep_sizeold + timestep_sizeold1)* 0.5 * (timestep_sizeold + timestep_sizenow))+
				1.0 / ((timestep_sizenow + timestep_sizeold + timestep_sizeold1) * 0.5 * (timestep_sizenow)) +
				1.0 / ((timestep_sizenow + timestep_sizeold + timestep_sizeold1) * 0.5 * (timestep_sizeold + timestep_sizenow + timestep_sizeold1 + timestep_sizeold2))+
				1.0 / ((timestep_sizenow + timestep_sizeold) * 0.5 * (timestep_sizenow)) +
				1.0 / ((timestep_sizenow + timestep_sizeold) * 0.5 * (timestep_sizenow + timestep_sizeold + timestep_sizeold1 + timestep_sizeold2)) +
				1.0 / ((timestep_sizenow) * 0.5 * (timestep_sizenow + timestep_sizeold + timestep_sizeold1 + timestep_sizeold2)));*/

		}
	}

	// Внимание никакой смены индексов - переупорядочения не требуется.
	// Всё верно. Ни в коем случае ничео не менять. 22.08.2020.
	// В соответствии с файлом МКЭ7. см. 22.08.2020.

} // Thermal_Structural_assemble_Volk4


// Термоупругость сборка матрицы Жёсткости для шестигранной призмы.  4.08.2017.
  // 16.09.2017.
// 21.08.2020 Верный вариант для скалярных механических свойств не ортотропных.
//
//  03.03.2021.
// function K = stiffnessMatrix_brick(E,nu,length_x,length_y,length_z)
// STIFFNESSMATRIX_BRICK Compute stiffness matrix for brick element
// K = stiffnessMatrix_brick(E, nu, length_x, length_y, length_z) Computes
// the 24x24 stiffness matrix for a regular 8 noded hexahedral finite
// element with Young´s modulus "E", Poisson ratio "nu" and lengths in x,
// yand z direction "length_x", "length_y" and "length_z" respectively.
// Numerical integration is performed with 8 Gauss points, which yields
// exact results for regular elements.Weight factors are oneand
// therefore not included in the code.
//
// Contact: Diego.Petraroia@rub.de
//
//  c3d8
//
// Совпало с тем что у меня НО смещение в 100раз больше чем в ANSYS. НЕфизично.
void Thermal_Structural_assemble_Volk5(integer iP, int** nvtx,
	TOCHKA* pa, float** prop, doublereal**& Kmatrix,
	bool btimedep, doublereal timestep_sizenow, doublereal timestep_sizeold,
	doublereal timestep_sizeold1, doublereal timestep_sizeold2, 
	bool* &bActiveShearModule)
{

	//nvtx
	// ---|+--|-+-|++-|--+|+-+|-++|+++
	// 1	2	3	4	5	6	7	8
	// 3    4    | 7    8
	// 1	2    | 5	6
	// Порядок перечисления функций формы в данной сборке.

	doublereal hx = 1.0, hy = 1.0, hz = 1.0; // размеры кубика
	volume3D(iP, nvtx, pa, hx, hy, hz);
	//printf("%e %e %e\n",hx,hy,hz);
	if (pa[nvtx[2][iP] - 1].x > pa[nvtx[3][iP] - 1].x) {
		printf("error nvtx\n");
		getchar();
	}

	for (integer i_1 = 0; i_1 < 8; i_1++) {
		//printf("%e %e %e\n", pa[nvtx[i_1][iP] - 1].x, pa[nvtx[i_1][iP] - 1].y, pa[nvtx[i_1][iP] - 1].z);
	}
	//getchar();
	//for (integer i_1 = 0; i_1 < 8; i_1++) {
		//printf("x=%e y=%e z=%e\n", pa[nvtx[i_1][iP] - 1].x, pa[nvtx[i_1][iP] - 1].y, pa[nvtx[i_1][iP] - 1].z);
	//}
	//getchar();

	check_nvtx_order1(iP, nvtx, pa);
	check_nvtx_order2(iP, nvtx, pa);
	//system("pause");


	doublereal E = prop[YOUNG_MODULE][iP];
	const double divK = 1.0e-7;
	E *= divK;
	//doublereal nu = E / (2.0 * mu1) -1.0; // Poisson ratio
	doublereal nu = prop[POISSON_RATIO][iP];
	// Параметры из книжки. 
	//doublereal lambda = nu / (1.0 - nu);
	//doublereal mu = (1.0 - 2.0 * nu) / (2.0 * (1.0 - nu));
	//doublereal Em = E * (1.0 - nu) / ((1.0 + nu) * (1.0 - 2.0 * nu));

	//const doublereal kc1 = 0.05555557;
	//const doublereal kc2 = 0.04166666;
	//const doublereal kc3 = 0.02777777;
	//const doublereal kc4 = 0.02083333;
	//const doublereal kc5 = 0.01388888;


	//printf("hx=%e hy=%e hz=%e E=%e nu=%e\n",hx,hy,hz,E,nu);
	//getchar();

	// Сборка локальной матрицы.
	// Данная матрица 24*24 сгенерирована системой символьной математики maple2019 за половину рабочего дня.

	// Книга по которой выполнена сборка:
	// Г.А.Маковкин С.Ю.Лихачева
	// Применение МКЭ к решению задач механики  деформируемого твердого тела
	// Учебное пособие
	// Часть 1

	// Compute 3D constitutive matrix (linear continuum mechanics)
	/*doublereal C[6][6] =
	{
		{1.0 - nu, nu, nu, 0.0, 0.0, 0.0},
		{nu, 1.0 - nu, nu, 0.0, 0.0, 0.0},
		{nu, nu, 1.0 - nu, 0.0, 0.0, 0.0},
		{0.0, 0.0, 0.0, (1.0 - 2.0 * nu) / 2.0, 0.0, 0.0},
		{0.0, 0.0, 0.0, 0.0, (1.0 - 2.0 * nu) / 2.0, 0.0},
		{0.0, 0.0, 0.0, 0.0, 0.0, (1.0-2.0*nu)/2.0}
	};

	for (int i_1 = 0; i_1 < 6; i_1++) {
		for (int i_2 = 0; i_2 < 6; i_2++) {
			C[i_1][i_2] *= E / ((1.0 + nu)*(1.0-2.0*nu));
		}
	}*/

	doublereal Gxy, Gyz, Gxz;
	if (!bActiveShearModule[iP]) {
		Gxy = Gyz = Gxz = E / (2.0 * (1.0 + nu));
	}
	else {
		Gyz = divK*prop[SHEAR_MODULE_YZ][iP];
		Gxz = divK*prop[SHEAR_MODULE_XZ][iP];
		Gxy = divK*prop[SHEAR_MODULE_XY][iP];
	}

	doublereal Ex = divK*prop[MULT_YOUNG_MODULE_X][iP] * prop[YOUNG_MODULE][iP]; // Модуль Юнга Па.
	doublereal Ey = divK*prop[MULT_YOUNG_MODULE_Y][iP] * prop[YOUNG_MODULE][iP]; // Модуль Юнга Па.
	doublereal Ez = divK*prop[MULT_YOUNG_MODULE_Z][iP] * prop[YOUNG_MODULE][iP]; // Модуль Юнга Па.

	doublereal nuyz = prop[MULT_POISSON_RATIO_YZ][iP] * prop[POISSON_RATIO][iP];
	doublereal nuxz = prop[MULT_POISSON_RATIO_XZ][iP] * prop[POISSON_RATIO][iP];
	doublereal nuxy = prop[MULT_POISSON_RATIO_XY][iP] * prop[POISSON_RATIO][iP];
	doublereal nuzy = prop[MULT_POISSON_RATIO_ZY][iP] * prop[POISSON_RATIO][iP];
	doublereal nuzx = prop[MULT_POISSON_RATIO_ZX][iP] * prop[POISSON_RATIO][iP];
	doublereal nuyx = prop[MULT_POISSON_RATIO_YX][iP] * prop[POISSON_RATIO][iP];

	/*
	doublereal C_1[6][6] =
	{
		{1.0/Ex, - nu/Ex, -nu/Ex, 0.0, 0.0, 0.0},
		{-nu/Ey, 1.0/Ey, -nu/Ey, 0.0, 0.0, 0.0},
		{-nu/Ez, -nu/Ez, 1.0/Ez, 0.0, 0.0, 0.0},
		{0.0, 0.0, 0.0, 1.0/Gxy, 0.0, 0.0},
		{0.0, 0.0, 0.0, 0.0, 1.0/Gyz, 0.0},
		{0.0, 0.0, 0.0, 0.0, 0.0, 1.0/Gxz}
	};*/


	doublereal C_1[6][6] =
	{
		{1.0 / Ex, -nuxy / Ex, -nuxz / Ex, 0.0, 0.0, 0.0},
		{-nuyx / Ey, 1.0 / Ey, -nuyz / Ey, 0.0, 0.0, 0.0},
		{-nuzx / Ez, -nuzy / Ez, 1.0 / Ez, 0.0, 0.0, 0.0},
		{0.0, 0.0, 0.0, 1.0 / Gxy, 0.0, 0.0},
		{0.0, 0.0, 0.0, 0.0, 1.0 / Gyz, 0.0},
		{0.0, 0.0, 0.0, 0.0, 0.0, 1.0 / Gxz}
	};

	doublereal** C = new doublereal * [6];
	for (int i_1 = 0; i_1 < 6; i_1++) {
		C[i_1] = new doublereal[6];
		for (int i_2 = 0; i_2 < 6; i_2++) {
			C[i_1][i_2] = C_1[i_1][i_2];
		}
	}

	inverse_matrix_simple(C,6,false);


	int iGn = 2;// 4; //2
	// Gauss points coordinates on each direction
	doublereal GaussPoint[2] = { -1.0/sqrt(3.0), 1.0/sqrt(3.0)};
	doublereal GaussWeight[2] = {1.0, 1.0};

	//doublereal GaussPoint[4] = {-0.861136, -0.339981, 0.339981, 0.861136};
	//doublereal GaussWeight[4] = {0.347855, 0.652145, 0.652145, 0.347855};

	// Matrix of vertices coordinates. Generic element centred at the origin.
	/*doublereal coordinates[8][3] = {
		{-hx / 2.0, -hy / 2.0, -hz / 2.0},
		{ hx / 2.0, -hy / 2.0, -hz / 2.0},
		{ hx / 2.0,  hy / 2.0, -hz / 2.0},
		{-hx / 2.0,  hy / 2.0, -hz / 2.0},
		{-hx / 2.0, -hy / 2.0,  hz / 2.0},
		{ hx / 2.0, -hy / 2.0,  hz / 2.0},
		{ hx / 2.0,  hy / 2.0,  hz / 2.0},
		{-hx / 2.0,  hy / 2.0,  hz / 2.0}
	};*/

	doublereal coordinates[8][3] = {
		{-hx / 2.0, -hy / 2.0, -hz / 2.0},
		{ hx / 2.0, -hy / 2.0, -hz / 2.0},		
		{-hx / 2.0,  hy / 2.0, -hz / 2.0},
		{ hx / 2.0,  hy / 2.0, -hz / 2.0},
		{-hx / 2.0, -hy / 2.0,  hz / 2.0},
		{ hx / 2.0, -hy / 2.0,  hz / 2.0},		
		{-hx / 2.0,  hy / 2.0,  hz / 2.0},
		{ hx / 2.0,  hy / 2.0,  hz / 2.0}
	};

    // Preallocate memory for stiffness matrix
	// initialization stiffness matrix
	for (int i_1 = 0; i_1 < 24; i_1++) {
		for (int i_2 = 0; i_2 < 24; i_2++) {
			Kmatrix[i_1][i_2]=0.0;
		}
	}
	

	for (int i_1 = 0; i_1 < iGn; i_1++) {
		for (int i_2 = 0; i_2 < iGn; i_2++) {
			for (int i_3 = 0; i_3 < iGn; i_3++) {

				doublereal xi1 = GaussPoint[i_1];
				doublereal xi2 = GaussPoint[i_2];
				doublereal xi3 = GaussPoint[i_3];

				// Compute shape functions derivatives
				/*doublereal dShape[3][8] = {
					{-(1 - xi2) * (1 - xi3),(1 - xi2) * (1 - xi3), (1 + xi2) * (1 - xi3),-(1 + xi2) * (1 - xi3),-(1 - xi2) * (1 + xi3),(1 - xi2) * (1 + xi3),(1 + xi2) * (1 + xi3),-(1 + xi2) * (1 + xi3)},
					{-(1 - xi1) * (1 - xi3),-(1 + xi1) * (1 - xi3),(1 + xi1) * (1 - xi3), (1 - xi1) * (1 - xi3),-(1 - xi1) * (1 + xi3),-(1 + xi1) * (1 + xi3), (1 + xi1) * (1 + xi3),(1 - xi1) * (1 + xi3)},
					{-(1 - xi1) * (1 - xi2), -(1 + xi1) * (1 - xi2),-(1 + xi1) * (1 + xi2),-(1 - xi1) * (1 + xi2),(1 - xi1) * (1 - xi2),(1 + xi1) * (1 - xi2),(1 + xi1) * (1 + xi2),(1 - xi1) * (1 + xi2)}
				};*/

				// Compute shape functions derivatives
				/*doublereal dShape[3][8] = {
					{-(1 - xi2) * (1 - xi3),(1 - xi2) * (1 - xi3), -(1 + xi2) * (1 - xi3),(1 + xi2) * (1 - xi3),-(1 - xi2) * (1 + xi3),(1 - xi2) * (1 + xi3),-(1 + xi2) * (1 + xi3), (1 + xi2) * (1 + xi3)},
					{-(1 - xi1) * (1 - xi3),-(1 + xi1) * (1 - xi3), (1 - xi1) * (1 - xi3),(1 + xi1) * (1 - xi3),-(1 - xi1) * (1 + xi3),-(1 + xi1) * (1 + xi3), (1 - xi1) * (1 + xi3), (1 + xi1) * (1 + xi3)},
					{-(1 - xi1) * (1 - xi2), -(1 + xi1) * (1 - xi2),-(1 - xi1) * (1 + xi2),-(1 + xi1) * (1 + xi2),(1 - xi1) * (1 - xi2),(1 + xi1) * (1 - xi2),(1 - xi1) * (1 + xi2), (1 + xi1) * (1 + xi2)}
				};*/

				doublereal dShape[3][8] = {
					{-1.0 * xi2 * xi3 + 1.0 * xi2 + 1.0 * xi3 - 1.0, 
					 1.0 * xi2 * xi3 - 1.0 * xi2 - 1.0 * xi3 + 1.0,
					1.0 * xi2 * xi3 - 1.0 * xi2 + 1.0 * xi3 - 1.0,
					-1.0 * xi2 * xi3 + 1.0 * xi2 - 1.0 * xi3 + 1.0,
					1.0 * xi2 * xi3 + 1.0 * xi2 - 1.0 * xi3 - 1.0,
					-1.0 * xi2 * xi3 - 1.0 * xi2 + 1.0 * xi3 + 1.0,
					-1.0 * xi2 * xi3 - 1.0 * xi2 - 1.0 * xi3 - 1.0,
					1.0 * xi2 * xi3 + 1.0 * xi2 + 1.0 * xi3 + 1.0},
					{-1.0 * xi1 * xi3 + 1.0 * xi1 + 1.0 * xi3 - 1.0,
				1.0 * xi1 * xi3 - 1.0 * xi1 + 1.0 * xi3 - 1.0,
				1.0 * xi1 * xi3 - 1.0 * xi1 - 1.0 * xi3 + 1.0,
				-1.0 * xi1 * xi3 + 1.0 * xi1 - 1.0 * xi3 + 1.0,
				1.0 * xi1 * xi3 + 1.0 * xi1 - 1.0 * xi3 - 1.0,
				-1.0 * xi1 * xi3 - 1.0 * xi1 - 1.0 * xi3 - 1.0,
				-1.0 * xi1 * xi3 - 1.0 * xi1 + 1.0 * xi3 + 1.0,
				1.0 * xi1 * xi3 + 1.0 * xi1 + 1.0 * xi3 + 1.0},
					{-1.0 * xi1 * xi2 + 1.0 * xi1 + 1.0 * xi2 - 1.0,
				1.0 * xi1 * xi2 - 1.0 * xi1 + 1.0 * xi2 - 1.0,
				1.0 * xi1 * xi2 + 1.0 * xi1 - 1.0 * xi2 - 1.0,
				-1.0 * xi1 * xi2 - 1.0 * xi1 - 1.0 * xi2 - 1.0,
				1.0 * xi1 * xi2 - 1.0 * xi1 - 1.0 * xi2 + 1.0,
				-1.0 * xi1 * xi2 + 1.0 * xi1 - 1.0 * xi2 + 1.0,
				-1.0 * xi1 * xi2 - 1.0 * xi1 + 1.0 * xi2 + 1.0,
				1.0 * xi1 * xi2 + 1.0 * xi1 + 1.0 * xi2 + 1.0}
				};




				for (int i_4 = 0; i_4 < 3; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
						dShape[i_4][i_5] *= 1.0 / 8.0;
					}
				}

				// Compute Jacobian matrix
				doublereal JacobianMatrix[3][3] = {
					{0.0, 0.0, 0.0},
					{0.0, 0.0, 0.0},
					{0.0, 0.0, 0.0}
				};

				for (int i_4 = 0; i_4 < 3; i_4++) {
					for (int i_5 = 0; i_5 < 3; i_5++) {
						for (int i_6 = 0; i_6 < 8; i_6++) {
							JacobianMatrix[i_4][i_5] += dShape[i_4][i_6] * coordinates[i_6][i_5];
						}
					}
				}

				// Compute inverse Jacobian matrix
				doublereal inverseJacobianMatrix[3][3] = {
					{0.0, 0.0, 0.0},
					{0.0, 0.0, 0.0},
					{0.0, 0.0, 0.0}
				};

				{
					/*printf("Jacobian\n");
					printf("%e %e %e \n", JacobianMatrix[0][0], JacobianMatrix[0][1], JacobianMatrix[0][2]);
					printf("%e %e %e \n", JacobianMatrix[1][0], JacobianMatrix[1][1], JacobianMatrix[1][2]);
					printf("%e %e %e \n", JacobianMatrix[2][0], JacobianMatrix[2][1], JacobianMatrix[2][2]);
					getchar();*/

					
					inverseJacobianMatrix[0][0] = (JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[1][2] * JacobianMatrix[2][1]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0]
						* JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0]
						* JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[0][1] = -(JacobianMatrix[0][1] * JacobianMatrix[2][2] - JacobianMatrix[0][2] * JacobianMatrix[2][1]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - 
						JacobianMatrix[0][0] * JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] *
						JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[0][2] = (JacobianMatrix[0][1] * JacobianMatrix[1][2] - JacobianMatrix[0][2] * JacobianMatrix[1][1]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0]
						* JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0]
						* JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[1][0] = -(JacobianMatrix[1][0] * JacobianMatrix[2][2] - JacobianMatrix[1][2] * JacobianMatrix[2][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0]
						* JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] *
						JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[1][1] = (JacobianMatrix[0][0] * JacobianMatrix[2][2] - JacobianMatrix[0][2] * JacobianMatrix[2][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] 
						* JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0] *
						JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[1][2] = -(JacobianMatrix[0][0] * JacobianMatrix[1][2] - JacobianMatrix[0][2] * JacobianMatrix[1][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2]
						* JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] *
						JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[2][0] = (JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[1][1] * JacobianMatrix[2][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2] 
						* JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0] * JacobianMatrix[2][1] - 
						JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[2][1] = -(JacobianMatrix[0][0] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[2][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2] 
						* JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] *
						JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[2][2] = (JacobianMatrix[0][0] * JacobianMatrix[1][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2] 
						* JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0] *
						JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);

					/*printf("%e %e %e \n", inverseJacobianMatrix[0][0], inverseJacobianMatrix[0][1], inverseJacobianMatrix[0][2]);
					printf("%e %e %e \n", inverseJacobianMatrix[1][0], inverseJacobianMatrix[1][1], inverseJacobianMatrix[1][2]);
					printf("%e %e %e \n", inverseJacobianMatrix[2][0], inverseJacobianMatrix[2][1], inverseJacobianMatrix[2][2]);
					getchar();*/

				}

				doublereal auxiliar[3][8] = {
					{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
					{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
					{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}
				};

				// Compute auxiliar matrix for construction of B-Operator

				for (int i_4 = 0; i_4 < 3; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
						for (int i_6 = 0; i_6 < 3; i_6++) {
							auxiliar[i_4][i_5] += inverseJacobianMatrix[i_4][i_6] * dShape[i_6][i_5];
						}
					}
				}

				// Preallocate memory for B-Operator
				doublereal B[6][24];
				for (int i_4 = 0; i_4 < 6; i_4++) {
					for (int i_5 = 0; i_5 < 24; i_5++) {
						B[i_4][i_5] = 0.0;
					}
				}

				// Construct first three rows
				for (int i_4 = 0; i_4 < 3; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
						B[i_4][3 * i_5 + i_4] = auxiliar[i_4][i_5];
					}
				}

				// Construct fourth row
				for (int i_5 = 0; i_5 < 8; i_5++) {
					B[3][3 * i_5]= auxiliar[1][i_5];
				}
				for (int i_5 = 0; i_5 < 8; i_5++) {
					B[3][3 * i_5+1] = auxiliar[0][i_5];
				}
				// Construct fifth row
				for (int i_5 = 0; i_5 < 8; i_5++) {
					B[4][3 * i_5+2] = auxiliar[1][i_5];
				}
				for (int i_5 = 0; i_5 < 8; i_5++) {
					B[4][3 * i_5 + 1] = auxiliar[2][i_5];
				}
				// Construct sixth row
				for (int i_5 = 0; i_5 < 8; i_5++) {
					B[5][3 * i_5 ] = auxiliar[2][i_5];
				}
				for (int i_5 = 0; i_5 < 8; i_5++) {
					B[5][3 * i_5 + 2] = auxiliar[0][i_5];
				}



				// Preallocate memory for B-Operator
				doublereal M1[24][6];
				for (int i_4 = 0; i_4 < 24; i_4++) {
					for (int i_5 = 0; i_5 < 6; i_5++) {
						M1[i_4][i_5] = 0.0;
					}
				}

				for (int i_4 = 0; i_4 < 24; i_4++) {
					for (int i_5 = 0; i_5 < 6; i_5++) {
						for (int i_6 = 0; i_6 < 6; i_6++) {
							M1[i_4][i_5] += B[i_6][i_4] * C[i_6][i_5];
						}
					}
				}

				// determinant
				doublereal det = JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2]
					+ JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0];

				// Add to stiffness matrix
				for (int i_4 = 0; i_4 < 24; i_4++) {
					for (int i_5 = 0; i_5 < 24; i_5++) {
						for (int i_6 = 0; i_6 < 6; i_6++) {
							Kmatrix[i_4][i_5] += GaussWeight[i_1]* GaussWeight[i_2] * GaussWeight[i_3] * det * M1[i_4][i_6] * B[i_6][i_5];
						}
					}
				}


			}
		}
	}

	for (int i_1 = 0; i_1 < 6; i_1++) {
		delete[] C[i_1];
	}
	delete[] C;

	if (btimedep) {
		// Нестационарная добавка к диагонали.
		for (integer i_1 = 0; i_1 < 24; i_1++) {
			//Kmatrix[i_1][i_1] += 0.125*prop[RHO][iP] * hx * hy * hz / (timestep_sizenow*timestep_sizenow);

			// sizex * sizey * sizez - dimension default interior.

			Kmatrix[i_1][i_1] += 0.125 * prop[RHO][iP] * hx * hy * hz / (timestep_sizenow * 0.5 * (timestep_sizeold + timestep_sizenow));
			//Kmatrix[i_1][i_1] += 0.125 * prop[RHO][iP] * sizex * sizey * sizez / (timestep_sizenow * 0.5 * (timestep_sizeold + timestep_sizenow));

			// Высокий порядок n=4, осцилирует.
			/*Kmatrix[i_1][i_1] += 0.125 * prop[RHO][iP] * hx * hy * hz* (1.0 / ((timestep_sizenow + timestep_sizeold + timestep_sizeold1)* 0.5 * (timestep_sizeold + timestep_sizenow))+
				1.0 / ((timestep_sizenow + timestep_sizeold + timestep_sizeold1) * 0.5 * (timestep_sizenow)) +
				1.0 / ((timestep_sizenow + timestep_sizeold + timestep_sizeold1) * 0.5 * (timestep_sizeold + timestep_sizenow + timestep_sizeold1 + timestep_sizeold2))+
				1.0 / ((timestep_sizenow + timestep_sizeold) * 0.5 * (timestep_sizenow)) +
				1.0 / ((timestep_sizenow + timestep_sizeold) * 0.5 * (timestep_sizenow + timestep_sizeold + timestep_sizeold1 + timestep_sizeold2)) +
				1.0 / ((timestep_sizenow) * 0.5 * (timestep_sizenow + timestep_sizeold + timestep_sizeold1 + timestep_sizeold2)));*/

		}
	}

	// Внимание никакой смены индексов - переупорядочения не требуется.
	// Всё верно. Ни в коем случае ничео не менять. 22.08.2020.
	// В соответствии с файлом МКЭ7. см. 22.08.2020.

} // Thermal_Structural_assemble_Volk5


// Термоупругость сборка силы линейного теплового расширения.  4.08.2017.
  // 16.09.2017. 14.03.2021.
// 21.08.2020 Верный вариант для скалярных механических свойств не ортотропных.
//
//  03.03.2021.
// function K = stiffnessMatrix_brick(E,nu,length_x,length_y,length_z)
// STIFFNESSMATRIX_BRICK Compute stiffness matrix for brick element
// K = stiffnessMatrix_brick(E, nu, length_x, length_y, length_z) Computes
// the 24x24 stiffness matrix for a regular 8 noded hexahedral finite
// element with Young´s modulus "E", Poisson ratio "nu" and lengths in x,
// yand z direction "length_x", "length_y" and "length_z" respectively.
// Numerical integration is performed with 8 Gauss points, which yields
// exact results for regular elements.Weight factors are oneand
// therefore not included in the code.
//
// Contact: Diego.Petraroia@rub.de
//
//  c3d8
//
// Совпало с тем что у меня НО смещение в 100раз больше чем в ANSYS. НЕфизично.
void Thermal_Structural_assemble_Volk6(integer iP, int** nvtx,
	TOCHKA* pa, float** prop, doublereal*& force,
	doublereal alphax, doublereal alphay, doublereal alphaz,
	doublereal Temperature, doublereal operating_temperature,
	bool*& bActiveShearModule)
{

	// alphax - коэффициент линейного теплового расширения по оси ох.
    // alphay - коэффициент линейного теплового расширения по оси ох.
	// alphaz - коэффициент линейного теплового расширения по оси ох.
	// operating_temperature - температура нулевой деформации.
	// Temperature - температура в центре контрольного объёма или ячейки.


	// Память под вектор force предполагается выделеной заранее во внешнем коде.
	// force[24] - Вектор узловых сил fx1, fy1, fz1, fx2, fy2, fz2, ..., fx8, fy8, fz8.

	//nvtx
	// ---|+--|-+-|++-|--+|+-+|-++|+++
	// 1	2	3	4	5	6	7	8
	// 3    4    | 7    8
	// 1	2    | 5	6
	// Порядок перечисления функций формы в данной сборке.

	doublereal hx = 1.0, hy = 1.0, hz = 1.0; // размеры кубика
	volume3D(iP, nvtx, pa, hx, hy, hz);
	//printf("%e %e %e\n",hx,hy,hz);
	if (pa[nvtx[2][iP] - 1].x > pa[nvtx[3][iP] - 1].x) {
		printf("error nvtx\n");
		getchar();
	}

	for (integer i_1 = 0; i_1 < 8; i_1++) {
		//printf("%e %e %e\n", pa[nvtx[i_1][iP] - 1].x, pa[nvtx[i_1][iP] - 1].y, pa[nvtx[i_1][iP] - 1].z);
	}
	//getchar();
	//for (integer i_1 = 0; i_1 < 8; i_1++) {
		//printf("x=%e y=%e z=%e\n", pa[nvtx[i_1][iP] - 1].x, pa[nvtx[i_1][iP] - 1].y, pa[nvtx[i_1][iP] - 1].z);
	//}
	//getchar();

	check_nvtx_order1(iP, nvtx, pa);
	check_nvtx_order2(iP, nvtx, pa);
	//system("pause");


	doublereal E = prop[YOUNG_MODULE][iP];
	
	//doublereal nu = E / (2.0 * mu1) -1.0; // Poisson ratio
	doublereal nu = prop[POISSON_RATIO][iP];
	// Параметры из книжки. 
	//doublereal lambda = nu / (1.0 - nu);
	//doublereal mu = (1.0 - 2.0 * nu) / (2.0 * (1.0 - nu));
	//doublereal Em = E * (1.0 - nu) / ((1.0 + nu) * (1.0 - 2.0 * nu));

	//const doublereal kc1 = 0.05555557;
	//const doublereal kc2 = 0.04166666;
	//const doublereal kc3 = 0.02777777;
	//const doublereal kc4 = 0.02083333;
	//const doublereal kc5 = 0.01388888;


	//printf("hx=%e hy=%e hz=%e E=%e nu=%e\n",hx,hy,hz,E,nu);
	//getchar();

	// Сборка локальной матрицы.
	// Данная матрица 24*24 сгенерирована системой символьной математики maple2019 за половину рабочего дня.

	// Книга по которой выполнена сборка:
	// Г.А.Маковкин С.Ю.Лихачева
	// Применение МКЭ к решению задач механики  деформируемого твердого тела
	// Учебное пособие
	// Часть 1

	// Temperature - Температура в центре ячейки cell[iP].
	// operating_temperature - справочная температура нулевой деформации.
	// alphai, i = x,y,z коэффициент линейного теплового расширения.

	doublereal epsilon_t[6][1] =
	{
		{alphax * (Temperature - operating_temperature)},
		{alphay * (Temperature - operating_temperature)},
		{alphaz * (Temperature - operating_temperature)},
		{0.0},
		{0.0},
		{0.0}
	};

	// Compute 3D constitutive matrix (linear continuum mechanics)
	/*doublereal C[6][6] =
	{
		{1.0 - nu, nu, nu, 0.0, 0.0, 0.0},
		{nu, 1.0 - nu, nu, 0.0, 0.0, 0.0},
		{nu, nu, 1.0 - nu, 0.0, 0.0, 0.0},
		{0.0, 0.0, 0.0, (1.0 - 2.0 * nu) / 2.0, 0.0, 0.0},
		{0.0, 0.0, 0.0, 0.0, (1.0 - 2.0 * nu) / 2.0, 0.0},
		{0.0, 0.0, 0.0, 0.0, 0.0, (1.0 - 2.0 * nu) / 2.0}
	};

	for (int i_1 = 0; i_1 < 6; i_1++) {
		for (int i_2 = 0; i_2 < 6; i_2++) {
			C[i_1][i_2] *= E / ((1.0 + nu) * (1.0 - 2.0 * nu));
		}
	}*/


	doublereal Gxy, Gyz, Gxz;
	if (!bActiveShearModule[iP]) {
		Gxy = Gyz = Gxz = E / (2.0 * (1.0 + nu));
	}
	else {
		Gyz = prop[SHEAR_MODULE_YZ][iP];
		Gxz = prop[SHEAR_MODULE_XZ][iP];
		Gxy = prop[SHEAR_MODULE_XY][iP];
	}

	doublereal Ex = prop[MULT_YOUNG_MODULE_X][iP] * prop[YOUNG_MODULE][iP]; // Модуль Юнга Па.
	doublereal Ey = prop[MULT_YOUNG_MODULE_Y][iP] * prop[YOUNG_MODULE][iP]; // Модуль Юнга Па.
	doublereal Ez = prop[MULT_YOUNG_MODULE_Z][iP] * prop[YOUNG_MODULE][iP]; // Модуль Юнга Па.

	doublereal nuyz = prop[MULT_POISSON_RATIO_YZ][iP] * prop[POISSON_RATIO][iP];
	doublereal nuxz = prop[MULT_POISSON_RATIO_XZ][iP] * prop[POISSON_RATIO][iP];
	doublereal nuxy = prop[MULT_POISSON_RATIO_XY][iP] * prop[POISSON_RATIO][iP];
	doublereal nuzy = prop[MULT_POISSON_RATIO_ZY][iP] * prop[POISSON_RATIO][iP];
	doublereal nuzx = prop[MULT_POISSON_RATIO_ZX][iP] * prop[POISSON_RATIO][iP];
	doublereal nuyx = prop[MULT_POISSON_RATIO_YX][iP] * prop[POISSON_RATIO][iP];

	/*doublereal C_1[6][6] =
	{
		{1.0 / Ex, -nu / Ex, -nu / Ex, 0.0, 0.0, 0.0},
		{-nu / Ey, 1.0 / Ey, -nu / Ey, 0.0, 0.0, 0.0},
		{-nu / Ez, -nu / Ez, 1.0 / Ez, 0.0, 0.0, 0.0},
		{0.0, 0.0, 0.0, 1.0 / Gxy, 0.0, 0.0},
		{0.0, 0.0, 0.0, 0.0, 1.0 / Gyz, 0.0},
		{0.0, 0.0, 0.0, 0.0, 0.0, 1.0 / Gxz}
	};*/

	doublereal C_1[6][6] =
	{
		{1.0 / Ex, -nuxy / Ex, -nuxz / Ex, 0.0, 0.0, 0.0},
		{-nuyx / Ey, 1.0 / Ey, -nuyz / Ey, 0.0, 0.0, 0.0},
		{-nuzx / Ez, -nuzy / Ez, 1.0 / Ez, 0.0, 0.0, 0.0},
		{0.0, 0.0, 0.0, 1.0 / Gxy, 0.0, 0.0},
		{0.0, 0.0, 0.0, 0.0, 1.0 / Gyz, 0.0},
		{0.0, 0.0, 0.0, 0.0, 0.0, 1.0 / Gxz}
	};

	doublereal** C = new doublereal * [6];
	for (int i_1 = 0; i_1 < 6; i_1++) {
		C[i_1] = new doublereal[6];
		for (int i_2 = 0; i_2 < 6; i_2++) {
			C[i_1][i_2] = C_1[i_1][i_2];
		}
	}

	inverse_matrix_simple(C, 6, false);

	int iGn = 2;// 4; //2
	// Gauss points coordinates on each direction
	doublereal GaussPoint[2] = { -1.0 / sqrt(3.0), 1.0 / sqrt(3.0) };
	doublereal GaussWeight[2] = { 1.0, 1.0 };

	//doublereal GaussPoint[4] = {-0.861136, -0.339981, 0.339981, 0.861136};
	//doublereal GaussWeight[4] = {0.347855, 0.652145, 0.652145, 0.347855};

	// Matrix of vertices coordinates. Generic element centred at the origin.
	/*doublereal coordinates[8][3] = {
		{-hx / 2.0, -hy / 2.0, -hz / 2.0},
		{ hx / 2.0, -hy / 2.0, -hz / 2.0},
		{ hx / 2.0,  hy / 2.0, -hz / 2.0},
		{-hx / 2.0,  hy / 2.0, -hz / 2.0},
		{-hx / 2.0, -hy / 2.0,  hz / 2.0},
		{ hx / 2.0, -hy / 2.0,  hz / 2.0},
		{ hx / 2.0,  hy / 2.0,  hz / 2.0},
		{-hx / 2.0,  hy / 2.0,  hz / 2.0}
	};*/

	doublereal coordinates[8][3] = {
		{-hx / 2.0, -hy / 2.0, -hz / 2.0},
		{ hx / 2.0, -hy / 2.0, -hz / 2.0},
		{-hx / 2.0,  hy / 2.0, -hz / 2.0},
		{ hx / 2.0,  hy / 2.0, -hz / 2.0},
		{-hx / 2.0, -hy / 2.0,  hz / 2.0},
		{ hx / 2.0, -hy / 2.0,  hz / 2.0},
		{-hx / 2.0,  hy / 2.0,  hz / 2.0},
		{ hx / 2.0,  hy / 2.0,  hz / 2.0}
	};

	// Preallocate memory for stiffness matrix
	// initialization stiffness matrix
	for (int i_1 = 0; i_1 < 24; i_1++) {
			force[i_1] = 0.0;
	}


	for (int i_1 = 0; i_1 < iGn; i_1++) {
		for (int i_2 = 0; i_2 < iGn; i_2++) {
			for (int i_3 = 0; i_3 < iGn; i_3++) {

				doublereal xi1 = GaussPoint[i_1];
				doublereal xi2 = GaussPoint[i_2];
				doublereal xi3 = GaussPoint[i_3];

				// Compute shape functions derivatives
				/*doublereal dShape[3][8] = {
					{-(1 - xi2) * (1 - xi3),(1 - xi2) * (1 - xi3), (1 + xi2) * (1 - xi3),-(1 + xi2) * (1 - xi3),-(1 - xi2) * (1 + xi3),(1 - xi2) * (1 + xi3),(1 + xi2) * (1 + xi3),-(1 + xi2) * (1 + xi3)},
					{-(1 - xi1) * (1 - xi3),-(1 + xi1) * (1 - xi3),(1 + xi1) * (1 - xi3), (1 - xi1) * (1 - xi3),-(1 - xi1) * (1 + xi3),-(1 + xi1) * (1 + xi3), (1 + xi1) * (1 + xi3),(1 - xi1) * (1 + xi3)},
					{-(1 - xi1) * (1 - xi2), -(1 + xi1) * (1 - xi2),-(1 + xi1) * (1 + xi2),-(1 - xi1) * (1 + xi2),(1 - xi1) * (1 - xi2),(1 + xi1) * (1 - xi2),(1 + xi1) * (1 + xi2),(1 - xi1) * (1 + xi2)}
				};*/

				// Compute shape functions derivatives
				/*doublereal dShape[3][8] = {
					{-(1 - xi2) * (1 - xi3),(1 - xi2) * (1 - xi3), -(1 + xi2) * (1 - xi3),(1 + xi2) * (1 - xi3),-(1 - xi2) * (1 + xi3),(1 - xi2) * (1 + xi3),-(1 + xi2) * (1 + xi3), (1 + xi2) * (1 + xi3)},
					{-(1 - xi1) * (1 - xi3),-(1 + xi1) * (1 - xi3), (1 - xi1) * (1 - xi3),(1 + xi1) * (1 - xi3),-(1 - xi1) * (1 + xi3),-(1 + xi1) * (1 + xi3), (1 - xi1) * (1 + xi3), (1 + xi1) * (1 + xi3)},
					{-(1 - xi1) * (1 - xi2), -(1 + xi1) * (1 - xi2),-(1 - xi1) * (1 + xi2),-(1 + xi1) * (1 + xi2),(1 - xi1) * (1 - xi2),(1 + xi1) * (1 - xi2),(1 - xi1) * (1 + xi2), (1 + xi1) * (1 + xi2)}
				};*/

				doublereal dShape[3][8] = {
					{-1.0 * xi2 * xi3 + 1.0 * xi2 + 1.0 * xi3 - 1.0,
					 1.0 * xi2 * xi3 - 1.0 * xi2 - 1.0 * xi3 + 1.0,
					1.0 * xi2 * xi3 - 1.0 * xi2 + 1.0 * xi3 - 1.0,
					-1.0 * xi2 * xi3 + 1.0 * xi2 - 1.0 * xi3 + 1.0,
					1.0 * xi2 * xi3 + 1.0 * xi2 - 1.0 * xi3 - 1.0,
					-1.0 * xi2 * xi3 - 1.0 * xi2 + 1.0 * xi3 + 1.0,
					-1.0 * xi2 * xi3 - 1.0 * xi2 - 1.0 * xi3 - 1.0,
					1.0 * xi2 * xi3 + 1.0 * xi2 + 1.0 * xi3 + 1.0},
					{-1.0 * xi1 * xi3 + 1.0 * xi1 + 1.0 * xi3 - 1.0,
				1.0 * xi1 * xi3 - 1.0 * xi1 + 1.0 * xi3 - 1.0,
				1.0 * xi1 * xi3 - 1.0 * xi1 - 1.0 * xi3 + 1.0,
				-1.0 * xi1 * xi3 + 1.0 * xi1 - 1.0 * xi3 + 1.0,
				1.0 * xi1 * xi3 + 1.0 * xi1 - 1.0 * xi3 - 1.0,
				-1.0 * xi1 * xi3 - 1.0 * xi1 - 1.0 * xi3 - 1.0,
				-1.0 * xi1 * xi3 - 1.0 * xi1 + 1.0 * xi3 + 1.0,
				1.0 * xi1 * xi3 + 1.0 * xi1 + 1.0 * xi3 + 1.0},
					{-1.0 * xi1 * xi2 + 1.0 * xi1 + 1.0 * xi2 - 1.0,
				1.0 * xi1 * xi2 - 1.0 * xi1 + 1.0 * xi2 - 1.0,
				1.0 * xi1 * xi2 + 1.0 * xi1 - 1.0 * xi2 - 1.0,
				-1.0 * xi1 * xi2 - 1.0 * xi1 - 1.0 * xi2 - 1.0,
				1.0 * xi1 * xi2 - 1.0 * xi1 - 1.0 * xi2 + 1.0,
				-1.0 * xi1 * xi2 + 1.0 * xi1 - 1.0 * xi2 + 1.0,
				-1.0 * xi1 * xi2 - 1.0 * xi1 + 1.0 * xi2 + 1.0,
				1.0 * xi1 * xi2 + 1.0 * xi1 + 1.0 * xi2 + 1.0}
				};




				for (int i_4 = 0; i_4 < 3; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
						dShape[i_4][i_5] *= 1.0 / 8.0;
					}
				}

				// Compute Jacobian matrix
				doublereal JacobianMatrix[3][3] = {
					{0.0, 0.0, 0.0},
					{0.0, 0.0, 0.0},
					{0.0, 0.0, 0.0}
				};

				for (int i_4 = 0; i_4 < 3; i_4++) {
					for (int i_5 = 0; i_5 < 3; i_5++) {
						for (int i_6 = 0; i_6 < 8; i_6++) {
							JacobianMatrix[i_4][i_5] += dShape[i_4][i_6] * coordinates[i_6][i_5];
						}
					}
				}

				// Compute inverse Jacobian matrix
				doublereal inverseJacobianMatrix[3][3] = {
					{0.0, 0.0, 0.0},
					{0.0, 0.0, 0.0},
					{0.0, 0.0, 0.0}
				};

				{
					/*printf("Jacobian\n");
					printf("%e %e %e \n", JacobianMatrix[0][0], JacobianMatrix[0][1], JacobianMatrix[0][2]);
					printf("%e %e %e \n", JacobianMatrix[1][0], JacobianMatrix[1][1], JacobianMatrix[1][2]);
					printf("%e %e %e \n", JacobianMatrix[2][0], JacobianMatrix[2][1], JacobianMatrix[2][2]);
					getchar();*/


					inverseJacobianMatrix[0][0] = (JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[1][2] * JacobianMatrix[2][1]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0]
						* JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0]
						* JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[0][1] = -(JacobianMatrix[0][1] * JacobianMatrix[2][2] - JacobianMatrix[0][2] * JacobianMatrix[2][1]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] -
						JacobianMatrix[0][0] * JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] *
						JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[0][2] = (JacobianMatrix[0][1] * JacobianMatrix[1][2] - JacobianMatrix[0][2] * JacobianMatrix[1][1]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0]
						* JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0]
						* JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[1][0] = -(JacobianMatrix[1][0] * JacobianMatrix[2][2] - JacobianMatrix[1][2] * JacobianMatrix[2][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0]
						* JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] *
						JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[1][1] = (JacobianMatrix[0][0] * JacobianMatrix[2][2] - JacobianMatrix[0][2] * JacobianMatrix[2][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0]
						* JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0] *
						JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[1][2] = -(JacobianMatrix[0][0] * JacobianMatrix[1][2] - JacobianMatrix[0][2] * JacobianMatrix[1][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2]
						* JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] *
						JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[2][0] = (JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[1][1] * JacobianMatrix[2][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2]
						* JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0] * JacobianMatrix[2][1] -
						JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[2][1] = -(JacobianMatrix[0][0] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[2][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2]
						* JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] *
						JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[2][2] = (JacobianMatrix[0][0] * JacobianMatrix[1][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2]
						* JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0] *
						JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);

					/*printf("%e %e %e \n", inverseJacobianMatrix[0][0], inverseJacobianMatrix[0][1], inverseJacobianMatrix[0][2]);
					printf("%e %e %e \n", inverseJacobianMatrix[1][0], inverseJacobianMatrix[1][1], inverseJacobianMatrix[1][2]);
					printf("%e %e %e \n", inverseJacobianMatrix[2][0], inverseJacobianMatrix[2][1], inverseJacobianMatrix[2][2]);
					getchar();*/

				}

				doublereal auxiliar[3][8] = {
					{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
					{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
					{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}
				};

				// Compute auxiliar matrix for construction of B-Operator

				for (int i_4 = 0; i_4 < 3; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
						for (int i_6 = 0; i_6 < 3; i_6++) {
							auxiliar[i_4][i_5] += inverseJacobianMatrix[i_4][i_6] * dShape[i_6][i_5];
						}
					}
				}

				// Preallocate memory for B-Operator
				doublereal B[6][24];
				for (int i_4 = 0; i_4 < 6; i_4++) {
					for (int i_5 = 0; i_5 < 24; i_5++) {
						B[i_4][i_5] = 0.0;
					}
				}

				// Construct first three rows
				for (int i_4 = 0; i_4 < 3; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
						B[i_4][3 * i_5 + i_4] = auxiliar[i_4][i_5];
					}
				}

				// Construct fourth row
				for (int i_5 = 0; i_5 < 8; i_5++) {
					B[3][3 * i_5] = auxiliar[1][i_5];
				}
				for (int i_5 = 0; i_5 < 8; i_5++) {
					B[3][3 * i_5 + 1] = auxiliar[0][i_5];
				}
				// Construct fifth row
				for (int i_5 = 0; i_5 < 8; i_5++) {
					B[4][3 * i_5 + 2] = auxiliar[1][i_5];
				}
				for (int i_5 = 0; i_5 < 8; i_5++) {
					B[4][3 * i_5 + 1] = auxiliar[2][i_5];
				}
				// Construct sixth row
				for (int i_5 = 0; i_5 < 8; i_5++) {
					B[5][3 * i_5] = auxiliar[2][i_5];
				}
				for (int i_5 = 0; i_5 < 8; i_5++) {
					B[5][3 * i_5 + 2] = auxiliar[0][i_5];
				}



				// Preallocate memory for B-Operator
				doublereal M1[24][6];
				for (int i_4 = 0; i_4 < 24; i_4++) {
					for (int i_5 = 0; i_5 < 6; i_5++) {
						M1[i_4][i_5] = 0.0;
					}
				}

				for (int i_4 = 0; i_4 < 24; i_4++) {
					for (int i_5 = 0; i_5 < 6; i_5++) {
						for (int i_6 = 0; i_6 < 6; i_6++) {
							M1[i_4][i_5] += B[i_6][i_4] * C[i_6][i_5];
						}
					}
				}

				// determinant
				doublereal det = JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2]
					+ JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0];

				// Add to stiffness matrix
				for (int i_4 = 0; i_4 < 24; i_4++) {
					for (int i_6 = 0; i_6 < 6; i_6++) {
						force[i_4] += GaussWeight[i_1] * GaussWeight[i_2] * GaussWeight[i_3] * det * M1[i_4][i_6] * epsilon_t[i_6][0];
					}
				}


			}
		}
	}

	for (int i_1 = 0; i_1 < 6; i_1++) {
		delete[] C[i_1];
	}
	delete[] C;

	// Внимание никакой смены индексов - переупорядочения не требуется.
	// Всё верно. Ни в коем случае ничео не менять. 22.08.2020.
	// В соответствии с файлом МКЭ7. см. 22.08.2020.

} // Thermal_Structural_assemble_Volk6

  // поддерживаются вращения вокруг оси цилиндра для деформаций.
  // деформации должны лежать на уравнении касательной:
  // (x1-xC)*(x-xC)+(y1-yC)*(y-yC)=R^2. для плоскости XY.
typedef struct TCylindricalSupport {
	integer iPlane;
	bool bactive; // нужно ли включать Cylindrical Support граничное условие.
	doublereal xC, yC, zC, Radius; // центр окружности.
	doublereal x1, y1, z1; // точка в которой ставится касательная.
} CylindricalSupport;

  // Включение одиночных матричных элементов Kmatrix и Tmatrix (selm, telm)
  // в глобальную матрицу Smatrix и (если bsecond_member_of_equation=true)
  // правую часть.
  // 8.4.2017
void elembdSparse(integer ie, SIMPLESPARSE &sparseM, int** nvtx,
	bool* &constr, doublereal* &rthdsd,
	doublereal** &Kmatrix, doublereal* &potent,
	bool bsecond_member_of_equation, CylindricalSupport* &cylsup,
	doublereal epsx, doublereal epsy, doublereal epsz) {

	// перебор матричных элементов S и T (selm и telm)
	// и корректировка глобальной матрицы S и правой части

	const integer nve = 8;
	doublereal distancez = 0.0, distancex = 0.0;

	integer i, j; // счётчики цикла for
	integer irow, icol; // строка, столбец
	for (i = 0; i<nve; i++) {
		for (integer idirection1 = 0; idirection1 < 3; idirection1++) {
			irow = idirection1 + 3 * (nvtx[i][ie] - 1);

			// Строка соответствует фиксированному потенциалу ?
			if (constr[irow]) { // да
				if (cylsup[irow].bactive) {
					switch (cylsup[irow].iPlane) {
					case XY_PLANE:
						switch (idirection1) {
						case 0:
							addelmsimplesparse_Stress_clean_string(sparseM, irow);
							addelmsimplesparse_Stress(sparseM, (cylsup[irow].x1 - cylsup[irow].xC), irow, irow, false, false);
							addelmsimplesparse_Stress(sparseM, (cylsup[irow].y1 - cylsup[irow].yC), irow, irow+1, false, false);
							if (bsecond_member_of_equation) rthdsd[irow] = cylsup[irow].Radius*cylsup[irow].Radius+cylsup[irow].xC*(cylsup[irow].x1-cylsup[irow].xC)+ cylsup[irow].yC*(cylsup[irow].y1 - cylsup[irow].yC);
							break;
						case 1: 
							addelmsimplesparse_Stress_clean_string(sparseM, irow);
							addelmsimplesparse_Stress(sparseM, (cylsup[irow].x1 - cylsup[irow].xC), irow, irow-1, false, false);
							addelmsimplesparse_Stress(sparseM, (cylsup[irow].y1 - cylsup[irow].yC), irow, irow, false, false);
							if (bsecond_member_of_equation) rthdsd[irow] = cylsup[irow].Radius*cylsup[irow].Radius + cylsup[irow].xC*(cylsup[irow].x1 - cylsup[irow].xC) + cylsup[irow].yC*(cylsup[irow].y1 - cylsup[irow].yC);
							break;
						case 2:
							//setValueIMatrix(&sparseS, irow, irow, 1.0f);
							addelmsimplesparse_Stress(sparseM, 1.0f, irow, irow, true, true);
							if (bsecond_member_of_equation) rthdsd[irow] = potent[irow];
							break;
						}
						break;
					case XZ_PLANE: 
						switch (idirection1) {
						case 0:
							addelmsimplesparse_Stress_clean_string(sparseM, irow);
							if (irow == 3) {
							//	printf("clean string=%d\n", irow);
								//getchar();
							}
							if (fabs(cylsup[irow].z1 - cylsup[irow].zC) < epsz) {
								distancez = epsz;
							}
							else {
								distancez = cylsup[irow].z1 - cylsup[irow].zC;
							}

							if (cylsup[irow].x1 - cylsup[irow].xC < epsx) {
								if (fabs(cylsup[irow].x1 - cylsup[irow].xC) < epsx) {
									//printf("irow=%d %e \n",irow, cylsup[irow].x1 - cylsup[irow].xC);
									//printf("xC=%e zC=%e x1=%e z1=%e R=%e\n", cylsup[irow].xC, cylsup[irow].zC, cylsup[irow].x1, cylsup[irow].z1, cylsup[irow].Radius);
									//getchar();
									addelmsimplesparse_Stress(sparseM, 1.0, irow, irow, false, false);
									addelmsimplesparse_Stress(sparseM, -(distancez)/(epsx), irow, irow + 2, false, false);
									if (bsecond_member_of_equation) rthdsd[irow] = (cylsup[irow].Radius*cylsup[irow].Radius + cylsup[irow].xC*(epsx) + cylsup[irow].zC*(distancez))/(epsx);
									//printf("ap=%e %e %e\n",1.0, -(distancez) / (epsx), rthdsd[irow]);
									//getchar();
								}
								else {
									addelmsimplesparse_Stress(sparseM, -(cylsup[irow].x1 - cylsup[irow].xC), irow, irow, false, false);
									addelmsimplesparse_Stress(sparseM, (distancez), irow, irow + 2, false, false);
									if (bsecond_member_of_equation) rthdsd[irow] = -cylsup[irow].Radius*cylsup[irow].Radius - cylsup[irow].xC*(cylsup[irow].x1 - cylsup[irow].xC) - cylsup[irow].zC*(distancez);
									//printf("ap=%e %e %e\n", -(cylsup[irow].x1 - cylsup[irow].xC), (distancez), rthdsd[irow]);
									//getchar();
								}
							}
							else {
								addelmsimplesparse_Stress(sparseM, (cylsup[irow].x1 - cylsup[irow].xC), irow, irow, false, false);
								addelmsimplesparse_Stress(sparseM, -(distancez), irow, irow + 2, false, false);
								if (bsecond_member_of_equation) rthdsd[irow] = cylsup[irow].Radius*cylsup[irow].Radius + cylsup[irow].xC*(cylsup[irow].x1 - cylsup[irow].xC) + cylsup[irow].zC*(distancez);
								//printf("ap=%e %e %e\n", (cylsup[irow].x1 - cylsup[irow].xC), -(distancez), rthdsd[irow]);
								//getchar();
							}
							break;
						case 1:
							//setValueIMatrix(&sparseS, irow, irow, 1.0f);
							addelmsimplesparse_Stress(sparseM, 1.0f, irow, irow, true, true);
							if (bsecond_member_of_equation) rthdsd[irow] = potent[irow];
							break;
						case 2:
							addelmsimplesparse_Stress_clean_string(sparseM, irow);
							if (fabs(cylsup[irow].x1 - cylsup[irow].xC) < epsx) {
								distancex = epsx;
							}
							else {
								distancex = cylsup[irow].x1 - cylsup[irow].xC;
							}
							if ((cylsup[irow].z1 - cylsup[irow].zC) < epsz) {
								if (fabs(cylsup[irow].z1 - cylsup[irow].zC) < epsz) {
									//printf("irow=%d %e \n", irow, cylsup[irow].z1 - cylsup[irow].zC);
									//printf("xC=%e zC=%e x1=%e z1=%e R=%e\n", cylsup[irow].xC, cylsup[irow].zC, cylsup[irow].x1, cylsup[irow].z1, cylsup[irow].Radius);

									//getchar();
									addelmsimplesparse_Stress(sparseM, -(distancex)/(epsz), irow, irow - 2, false, false);
									addelmsimplesparse_Stress(sparseM,+1.0 , irow, irow, false, false);
									if (bsecond_member_of_equation) rthdsd[irow] = -(cylsup[irow].Radius*cylsup[irow].Radius + cylsup[irow].xC*(distancex) + cylsup[irow].zC*(epsz))/(epsz);
									//printf("ap=%e %e %e\n", 1.0,-(distancex) / (epsz), rthdsd[irow]);
									//getchar();
								}
								else {
									addelmsimplesparse_Stress(sparseM, (distancex), irow, irow - 2, false, false);
									addelmsimplesparse_Stress(sparseM, -(cylsup[irow].z1 - cylsup[irow].zC), irow, irow, false, false);
									if (bsecond_member_of_equation) rthdsd[irow] = cylsup[irow].Radius*cylsup[irow].Radius + cylsup[irow].xC*(distancex) + cylsup[irow].zC*(cylsup[irow].z1 - cylsup[irow].zC);
									//printf("ap=%e %e %e\n", -(cylsup[irow].z1 - cylsup[irow].zC), (distancex), rthdsd[irow]);
									//getchar();
								}
							}
							else {
								addelmsimplesparse_Stress(sparseM, -(distancex), irow, irow - 2, false, false);
								addelmsimplesparse_Stress(sparseM, +(cylsup[irow].z1 - cylsup[irow].zC), irow, irow, false, false);
								if (bsecond_member_of_equation) rthdsd[irow] = -cylsup[irow].Radius*cylsup[irow].Radius + cylsup[irow].xC*(distancex) + cylsup[irow].zC*(cylsup[irow].z1 - cylsup[irow].zC);
								//printf("ap=%e %e %e\n", (cylsup[irow].z1 - cylsup[irow].zC), -(distancex), rthdsd[irow]);
								//getchar();
							}
							break;
						}
						break;
					case YZ_PLANE:
						switch (idirection1) {
						case 0:
							//setValueIMatrix(&sparseS, irow, irow, 1.0f);
							addelmsimplesparse_Stress(sparseM, 1.0f, irow, irow, true, true);
							if (bsecond_member_of_equation) rthdsd[irow] = potent[irow];
							break;
						case 1:
							addelmsimplesparse_Stress_clean_string(sparseM, irow);
							addelmsimplesparse_Stress(sparseM, (cylsup[irow].y1 - cylsup[irow].yC), irow, irow, false, false);
							addelmsimplesparse_Stress(sparseM, (cylsup[irow].z1 - cylsup[irow].zC), irow, irow + 1, false, false);
							if (bsecond_member_of_equation) rthdsd[irow] = cylsup[irow].Radius*cylsup[irow].Radius + cylsup[irow].yC*(cylsup[irow].y1 - cylsup[irow].yC) + cylsup[irow].zC*(cylsup[irow].z1 - cylsup[irow].zC);
							break;
						case 2:
							addelmsimplesparse_Stress_clean_string(sparseM, irow);
							addelmsimplesparse_Stress(sparseM, (cylsup[irow].y1 - cylsup[irow].yC), irow, irow - 1, false, false);
							addelmsimplesparse_Stress(sparseM, (cylsup[irow].z1 - cylsup[irow].zC), irow, irow, false, false);
							if (bsecond_member_of_equation) rthdsd[irow] = cylsup[irow].Radius*cylsup[irow].Radius + cylsup[irow].yC*(cylsup[irow].y1 - cylsup[irow].yC) + cylsup[irow].zC*(cylsup[irow].z1 - cylsup[irow].zC);
							break;
						}
						break;
					}
				}
				else {
					//setValueIMatrix(&sparseS, irow, irow, 1.0f);
					addelmsimplesparse_Stress(sparseM, 1.0f, irow, irow, true, true);
					if (bsecond_member_of_equation) rthdsd[irow] = potent[irow];
				}
			}
			else { // нет
				   // нет, потенциал переменный, просмотр nve-столбцов
				for (j = 0; j < nve; j++) {
					for (integer idirection2 = 0; idirection2 < 3; idirection2++) {
						icol = idirection2 + 3 * (nvtx[j][ie] - 1);

						// Столбец соответствует фиксированному потенциалу ?
						if (constr[icol]) { // да
											// Тогда увеличение только правой части
											//if (bsecond_member_of_equation) rthdsd[irow] += /*Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j] * source[ie]*/ - selm[i][j] * potent[icol];
							
							if (cylsup[icol].bactive) {
								switch (cylsup[icol].iPlane) {
								case XY_PLANE:
									switch (idirection2) {
									case 0: addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
										break;
									case 1: addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
										break;
									case 2:
										break;
									}
									break;
								case XZ_PLANE:
									switch (idirection2) {
									case 0: addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
										break;
									case 1:
										break;
									case 2: addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
										break;
									}
									break;
								case YZ_PLANE:
									switch (idirection2) {
									case 0:
										break;
									case 1: addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
										break;
									case 2: addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
										break;
									}
									break;
								}
						    }
							
							
						}
						else { // нет
							   // тогда увеличение глобальной матрицы S и правой части
							   //addValueIMatrix(&sparseS, irow, icol, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j]);
							addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
							//if (bsecond_member_of_equation) rthdsd[irow] += telm[i][j] * source[ie];
						}
					}
				}
			}
		}
	}
} //elembdSparse(ie)

// Включение одиночных матричных элементов Kmatrix и Tmatrix (selm, telm)
// в глобальную матрицу Smatrix и (если bsecond_member_of_equation=true)
// правую часть.
// 8.4.2017
// 21.10.2018 Проверено верно.
void elembdSparse_noCylindricalSupport_omp8(integer ie, SIMPLESPARSE& sparseM, int** nvtx,
	bool*& constr, doublereal*& rthdsd,
	doublereal**& Kmatrix, doublereal*& potent,
	bool bsecond_member_of_equation,
	CylindricalSupport*& cylsup,
	doublereal epsx, doublereal epsy, doublereal epsz,
	integer maxnode) {
	// перебор матричных элементов S и T (selm и telm)
	// и корректировка глобальной матрицы S и правой части


	//printf("incomming\n");
	//getchar();

	const integer nve = 8;

	//integer i, j; // счётчики цикла for
	//integer irow, icol; // строка, столбец

#pragma omp parallel for
	for (integer i = 0; i < nve; i++) {
		for (integer idirection1 = 0; idirection1 < 3; idirection1++) {
			integer irow = idirection1 + 3 * (nvtx[i][ie] - 1);
			//сначала все х, потом все y потом все z. Такова нумерация rthdsd и potent.
			//irow= idirection1*maxnode+ (nvtx[i][ie] - 1);

			// Строка соответствует фиксированному потенциалу ?
			if (constr[irow]) { // да
				//printf("constr[irow]\n");
				//printf("rthdsd=%e potent=%e\n", rthdsd[irow], potent[irow]);
				//getchar();

				//setValueIMatrix(&sparseS, irow, irow, 1.0f);
				//---->>>>addelmsimplesparse_Stress(sparseM, 1.0f, irow, irow, true, true);

				{
					// ZDES 18.07.2021

					doublereal aij = 1.0f;
					integer i_1 = irow;
					integer j_1 = irow;
					bool bset = true;
					bool bsetD = true;

					const doublereal MY_ZERO_TOLERANCE = 1.0e-300;

					NONZEROELEM* p;
					p = sparseM.root[i_1];// Корневой элемент строки i_1
					// линейный поиск элемента с ключом key
					while ((p != nullptr) && (p->key != j_1)) p = p->next;
					if (p != nullptr) {
						// элемент найден
						if (bsetD) {
							// Удалить строку.
							NONZEROELEM* q = nullptr;
							p = nullptr;
							p = sparseM.root[i_1];
							q = p->next;
							p->next = nullptr;




							while (q != nullptr) {
								p = q;

								printf(" Dirichlet p-aij=%e\n", p->aij);
								system("pause");
								q = p->next;
								p->next = nullptr;
								delete p;
								p = nullptr;
#pragma omp critical
								{
									sparseM.n--;
								}
							}
							// Установить условие Дирихле равное единице.
							p = sparseM.root[i_1];
							if (fabs(aij) > MY_ZERO_TOLERANCE) {
								p->aij = aij;
								p->key = j_1;
							}
							p = nullptr;
						}
						else {
							if (fabs(aij) > MY_ZERO_TOLERANCE) {
								if (bset) p->aij = aij; // установка
								else {
									if (fabs(aij) > MY_ZERO_TOLERANCE) {
										//printf("%e\n", p->aij);
										p->aij += aij; // добавление
										//printf("%e %e\n", p->aij,aij);
										//if (i_1 == 3) {
											//if (fabs(p->aij) < MY_ZERO_TOLERANCE) {
												//printf("i_1=%d j_1=%d\n", i_1, p->key);
												//getchar();
											//}
										//}
									}
								}
							}
						}
					}
					else
					{
						// если такого элемента нет в списке
						// то добавление элемента в начало списка.
						if (fabs(aij) > MY_ZERO_TOLERANCE) {
							NONZEROELEM* q = new NONZEROELEM;
							q->aij = aij;
							q->key = j_1;
							q->next = sparseM.root[i_1];
							sparseM.root[i_1] = q;
							q = nullptr;
#pragma omp critical
							{
								sparseM.n++; // количество ненулевых элементов увеличилось на 1. 
							}
						}
					}
				}


				if (bsecond_member_of_equation) rthdsd[irow] = potent[irow];
			}
			else { // нет
				   // нет, потенциал переменный, просмотр nve-столбцов
				for (integer j = 0; j < nve; j++) {
					for (integer idirection2 = 0; idirection2 < 3; idirection2++) {
						integer icol = idirection2 + 3 * (nvtx[j][ie] - 1);
						// Сначала только х, потом только y, потом только z.
						//icol = idirection2*maxnode + (nvtx[j][ie] - 1);

						// Столбец соответствует фиксированному потенциалу ?
						if (constr[icol]) { // да
							// В К матрице все вперемежку x,y,z, снова x,y,z снова x,y,z ???? Да. 

							//printf("constr[icol]\n");
							//getchar();

							// В теплопередаче этот элемент присутствует.
							// здесь он приводит к расходимости.
							//------>>>>>addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);


							// Экспериментальный кусок должен пройти проверку.
							// 18,07,2021 Проверка пройдена это верно. Даёт симметричный портрет матрицы СЛАУ.
							addelmsimplesparse_Stress(sparseM, 1.0f, icol, icol, true, true);
							rthdsd[irow] -= Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j] * potent[icol];

							{
								// ZDES 18.07.2021

								doublereal aij = 1.0;
								integer i_1 = icol;
								integer j_1 = icol;
								bool bset = true;
								bool bsetD = true;

#pragma omp critical
								{

									const doublereal MY_ZERO_TOLERANCE = 1.0e-300;

									NONZEROELEM* p;
									p = sparseM.root[i_1];// Корневой элемент строки i_1
									// линейный поиск элемента с ключом key
									while ((p != nullptr) && (p->key != j_1)) p = p->next;
									if (p != nullptr) {
										// элемент найден
										if (bsetD) {
											// Удалить строку.
											NONZEROELEM* q = nullptr;
											p = nullptr;
											p = sparseM.root[i_1];
											q = p->next;
											p->next = nullptr;




											while (q != nullptr) {
												p = q;

												printf(" Dirichlet p-aij=%e\n", p->aij);
												system("pause");
												q = p->next;
												p->next = nullptr;
												delete p;
												p = nullptr;

													sparseM.n--;
											}
											// Установить условие Дирихле равное единице.
											p = sparseM.root[i_1];
											if (fabs(aij) > MY_ZERO_TOLERANCE) {
												p->aij = aij;
												p->key = j_1;
											}
											p = nullptr;
										}
										else {
											if (fabs(aij) > MY_ZERO_TOLERANCE) {
												if (bset) p->aij = aij; // установка
												else {
													if (fabs(aij) > MY_ZERO_TOLERANCE) {
														//printf("%e\n", p->aij);
														p->aij += aij; // добавление
														//printf("%e %e\n", p->aij,aij);
														//if (i_1 == 3) {
															//if (fabs(p->aij) < MY_ZERO_TOLERANCE) {
																//printf("i_1=%d j_1=%d\n", i_1, p->key);
																//getchar();
															//}
														//}
													}
												}
											}
										}
									}
									else
									{
										// если такого элемента нет в списке
										// то добавление элемента в начало списка.
										if (fabs(aij) > MY_ZERO_TOLERANCE) {
											NONZEROELEM* q = new NONZEROELEM;
											q->aij = aij;
											q->key = j_1;
											q->next = sparseM.root[i_1];
											sparseM.root[i_1] = q;
											q = nullptr;

											sparseM.n++; // количество ненулевых элементов увеличилось на 1. 

										}
									}

								}
							}


							// Тогда увеличение только правой части
			//if (bsecond_member_of_equation) rthdsd[irow] += /*Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j] * source[ie]*/ - selm[i][j] * potent[icol];
						}
						else { // нет
							   // тогда увеличение глобальной матрицы S и правой части
							//addValueIMatrix(&sparseS, irow, icol, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j]);
							//----->>>>addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);


							{
								// ZDES 18.07.2021

								doublereal aij = Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j];
								integer i_1 = irow;
								integer j_1 = icol;
								bool bset = false;
								bool bsetD = false;

								const doublereal MY_ZERO_TOLERANCE = 1.0e-300;

								NONZEROELEM* p;
								p = sparseM.root[i_1];// Корневой элемент строки i_1
								// линейный поиск элемента с ключом key
								while ((p != nullptr) && (p->key != j_1)) p = p->next;
								if (p != nullptr) {
									// элемент найден
									if (bsetD) {
										// Удалить строку.
										NONZEROELEM* q = nullptr;
										p = nullptr;
										p = sparseM.root[i_1];
										q = p->next;
										p->next = nullptr;




										while (q != nullptr) {
											p = q;

											printf(" Dirichlet p-aij=%e\n", p->aij);
											system("pause");
											q = p->next;
											p->next = nullptr;
											delete p;
											p = nullptr;
#pragma omp critical
											{
												sparseM.n--;
											}
										}
										// Установить условие Дирихле равное единице.
										p = sparseM.root[i_1];
										if (fabs(aij) > MY_ZERO_TOLERANCE) {
											p->aij = aij;
											p->key = j_1;
										}
										p = nullptr;
									}
									else {
										if (fabs(aij) > MY_ZERO_TOLERANCE) {
											if (bset) p->aij = aij; // установка
											else {
												if (fabs(aij) > MY_ZERO_TOLERANCE) {
													//printf("%e\n", p->aij);
													p->aij += aij; // добавление
													//printf("%e %e\n", p->aij,aij);
													//if (i_1 == 3) {
														//if (fabs(p->aij) < MY_ZERO_TOLERANCE) {
															//printf("i_1=%d j_1=%d\n", i_1, p->key);
															//getchar();
														//}
													//}
												}
											}
										}
									}
								}
								else
								{
									// если такого элемента нет в списке
									// то добавление элемента в начало списка.
									if (fabs(aij) > MY_ZERO_TOLERANCE) {
										NONZEROELEM* q = new NONZEROELEM;
										q->aij = aij;
										q->key = j_1;
										q->next = sparseM.root[i_1];
										sparseM.root[i_1] = q;
										q = nullptr;
#pragma omp critical
										{
											sparseM.n++; // количество ненулевых элементов увеличилось на 1. 
										}
									}
								}
							
							}


							//if (bsecond_member_of_equation) rthdsd[irow] += telm[i][j] * source[ie];
						}
					}
				}
			}
		}
	}
} //elembdSparse_noCylindricalSupport_omp8(ie)

// Включение одиночных матричных элементов Kmatrix и Tmatrix (selm, telm)
// в глобальную матрицу Smatrix и (если bsecond_member_of_equation=true)
// правую часть.
// 8.4.2017
// 21.10.2018 Проверено верно.
void elembdSparse_noCylindricalSupport(integer ie, SIMPLESPARSE &sparseM, int** nvtx,
	bool* &constr,	doublereal* &rthdsd, 
	doublereal** &Kmatrix, doublereal* &potent,
	bool bsecond_member_of_equation,
	CylindricalSupport* &cylsup,  
	doublereal epsx, doublereal epsy, doublereal epsz,
	integer maxnode) {
	// перебор матричных элементов S и T (selm и telm)
	// и корректировка глобальной матрицы S и правой части


	//printf("incomming\n");
	//getchar();

	const integer nve = 8;

	//integer i, j; // счётчики цикла for
	//integer irow, icol; // строка, столбец

	for (integer i = 0; i<nve; i++) {
		for (integer idirection1 = 0; idirection1 < 3; idirection1++) {
			integer irow = idirection1 + 3*(nvtx[i][ie] - 1);
			//сначала все х, потом все y потом все z. Такова нумерация rthdsd и potent.
			//irow= idirection1*maxnode+ (nvtx[i][ie] - 1);

			// Строка соответствует фиксированному потенциалу ?
			if (constr[irow]) { // да
				//printf("constr[irow]\n");
				//printf("rthdsd=%e potent=%e\n", rthdsd[irow], potent[irow]);
				//getchar();

				//setValueIMatrix(&sparseS, irow, irow, 1.0f);
#if !bStableVersion
				addelmsimplesparse_Stress_ell(1.0f, irow, irow, true, true);
#else
				addelmsimplesparse_Stress(sparseM, 1.0f, irow, irow, true, true);
#endif
				
				if (bsecond_member_of_equation) rthdsd[irow] = potent[irow];
			}
			else { // нет
				   // нет, потенциал переменный, просмотр nve-столбцов
				for (integer j = 0; j < nve; j++) {
					for (integer idirection2 = 0; idirection2 < 3; idirection2++) {
						integer icol = idirection2 + 3*(nvtx[j][ie] - 1);
						// Сначала только х, потом только y, потом только z.
						//icol = idirection2*maxnode + (nvtx[j][ie] - 1);

						// Столбец соответствует фиксированному потенциалу ?
						if (constr[icol]) { // да
							// В К матрице все вперемежку x,y,z, снова x,y,z снова x,y,z ???? Да. 

							//printf("constr[icol]\n");
							//getchar();

							// В теплопередаче этот элемент присутствует.
							// здесь он приводит к расходимости.
							//---->>addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);

							// Экспериментальный кусок должен пройти проверку.
							// 18,07,2021 Проверка пройдена это верно. Даёт симметричный портрет матрицы СЛАУ.
#if !bStableVersion
							addelmsimplesparse_Stress_ell(1.0f, icol, icol, true, true);
#else
							addelmsimplesparse_Stress(sparseM, 1.0f, icol, icol, true, true);
#endif
							
							rthdsd[irow] -= Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j] * potent[icol];
											// Тогда увеличение только правой части
							//if (bsecond_member_of_equation) rthdsd[irow] += /*Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j] * source[ie]*/ - selm[i][j] * potent[icol];
						}
						else { // нет
							   // тогда увеличение глобальной матрицы S и правой части
							//addValueIMatrix(&sparseS, irow, icol, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j]);
#if !bStableVersion
							addelmsimplesparse_Stress_ell(Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
#else
							addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
#endif
							
							//if (bsecond_member_of_equation) rthdsd[irow] += telm[i][j] * source[ie];
						}
					}
				}
			}
		}
	}
} //elembdSparse_noCylindricalSupport(ie)

 
// Включение одиночных матричных элементов Kmatrix и Tmatrix (selm, telm)
// в глобальную матрицу Smatrix и (если bsecond_member_of_equation=true)
// правую часть.
// 8.4.2017
// 21.10.2018 Проверено верно.
// Двупоточный вариант 11,08,2021.
void elembdSparse_noCylindricalSupport(integer ie, SIMPLESPARSE& sparseM, int** nvtx,
	bool*& constr, doublereal*& rthdsd,
	doublereal**& Kmatrix, doublereal*& potent,
	bool bsecond_member_of_equation,
	CylindricalSupport*& cylsup,
	doublereal epsx, doublereal epsy, doublereal epsz,
	integer maxnode, int tid, int* &inumerate) {
	// перебор матричных элементов S и T (selm и telm)
	// и корректировка глобальной матрицы S и правой части


	//printf("incomming\n");
	//getchar();

	const integer nve = 8;

	//integer i, j; // счётчики цикла for
	//integer irow, icol; // строка, столбец

	for (integer i = 0; i < nve; i++) {
		for (integer idirection1 = 0; idirection1 < 3; idirection1++) {
			integer irow = idirection1 + 3 * (nvtx[i][ie] - 1);
			//сначала все х, потом все y потом все z. Такова нумерация rthdsd и potent.
			//irow= idirection1*maxnode+ (nvtx[i][ie] - 1);

			// Строка соответствует фиксированному потенциалу ?
			if (constr[irow]) { // да
				//printf("constr[irow]\n");
				//printf("rthdsd=%e potent=%e\n", rthdsd[irow], potent[irow]);
				//getchar();

				//setValueIMatrix(&sparseS, irow, irow, 1.0f);
#if !bStableVersion
				if ((tid == 0) && (inumerate[irow] == 2)) {

					std::cout << "incomming  \n";
					getchar();
#pragma omp single
					addelmsimplesparse_Stress_ell(1.0f, irow, irow, true, true);
				}
				else if ((tid == 1) && (inumerate[irow] == 1)) {
					std::cout << "incomming  \n";
					getchar();
#pragma omp single
					addelmsimplesparse_Stress_ell(1.0f, irow, irow, true, true);
				}
				else {
					addelmsimplesparse_Stress_ell(1.0f, irow, irow, true, true);
				}
#else
				addelmsimplesparse_Stress(sparseM, 1.0f, irow, irow, true, true);
#endif

				if (bsecond_member_of_equation) rthdsd[irow] = potent[irow];
			}
			else { // нет
				   // нет, потенциал переменный, просмотр nve-столбцов
				for (integer j = 0; j < nve; j++) {
					for (integer idirection2 = 0; idirection2 < 3; idirection2++) {
						integer icol = idirection2 + 3 * (nvtx[j][ie] - 1);
						// Сначала только х, потом только y, потом только z.
						//icol = idirection2*maxnode + (nvtx[j][ie] - 1);

						// Столбец соответствует фиксированному потенциалу ?
						if (constr[icol]) { // да
							// В К матрице все вперемежку x,y,z, снова x,y,z снова x,y,z ???? Да. 

							//printf("constr[icol]\n");
							//getchar();

							// В теплопередаче этот элемент присутствует.
							// здесь он приводит к расходимости.
							//---->>addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);

							// Экспериментальный кусок должен пройти проверку.
							// 18,07,2021 Проверка пройдена это верно. Даёт симметричный портрет матрицы СЛАУ.
#if !bStableVersion
							if ((tid == 0) && (inumerate[icol] == 2)) {
								std::cout << "incomming  \n";
								getchar();
#pragma omp single
								addelmsimplesparse_Stress_ell(1.0f, icol, icol, true, true);
							}
							else 
								if ((tid == 1) && (inumerate[icol] == 1)) {
									std::cout << "incomming  \n";
									getchar();
#pragma omp single
									addelmsimplesparse_Stress_ell(1.0f, icol, icol, true, true);
								}
								else {
									addelmsimplesparse_Stress_ell(1.0f, icol, icol, true, true);
								}
#else
							addelmsimplesparse_Stress(sparseM, 1.0f, icol, icol, true, true);
#endif

							rthdsd[irow] -= Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j] * potent[icol];
							// Тогда увеличение только правой части
			//if (bsecond_member_of_equation) rthdsd[irow] += /*Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j] * source[ie]*/ - selm[i][j] * potent[icol];
						}
						else { // нет
							   // тогда увеличение глобальной матрицы S и правой части
							//addValueIMatrix(&sparseS, irow, icol, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j]);
#if !bStableVersion
							if ((tid == 0) && (inumerate[irow] == 2)) {
								std::cout << "incomming  \n";
								getchar();
#pragma omp single
								addelmsimplesparse_Stress_ell(Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
							}
							else if ((tid == 1) && (inumerate[irow] == 1)) {
								std::cout << "incomming  \n";
								getchar();
#pragma omp single
								addelmsimplesparse_Stress_ell(Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
							}
							else {

								addelmsimplesparse_Stress_ell(Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
							}
#else
							addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
#endif

							//if (bsecond_member_of_equation) rthdsd[irow] += telm[i][j] * source[ie];
						}
					}
				}
			}
		}
	}
} //elembdSparse_noCylindricalSupport(ie)



  // Включение одиночных матричных элементов Kmatrix и Tmatrix (selm, telm)
  // в глобальную матрицу Smatrix и (если bsecond_member_of_equation=true)
  // правую часть.
  // 8.4.2017
void elembdSparse2(integer ie, IMatrix &sparseS, int** nvtx,
	bool* &constr, doublereal* &rthdsd,
	doublereal** &Kmatrix, doublereal* &potent,
	bool bsecond_member_of_equation) {

	// maxnod ненужно в глобальной нумерация xyz xyz xyz....

	// перебор матричных элементов S и T (selm и telm)
	// и корректировка глобальной матрицы S и правой части

	const integer nve = 8;

	integer i, j; // счётчики цикла for
	integer irow, icol; // строка, столбец
	for (i = 0; i<nve; i++) {
		for (integer idirection1 = 0; idirection1 < 3; idirection1++) {
			irow = idirection1 + 3 * (nvtx[i][ie] - 1);

			

			// Строка соответствует фиксированному потенциалу ?
			if (constr[irow]) { // да
				setValueIMatrix(&sparseS, irow, irow, 1.0f);
				//addelmsimplesparse_Stress(sparseM, 1.0f, irow, irow, true, true);
				if (bsecond_member_of_equation) rthdsd[irow] = potent[irow];
			}
			else { // нет
				   // нет, потенциал переменный, просмотр nve-столбцов
				for (j = 0; j < nve; j++) {
					for (integer idirection2 = 0; idirection2 < 3; idirection2++) {
						icol = idirection2 + 3 * (nvtx[j][ie] - 1);

						

						// Столбец соответствует фиксированному потенциалу ?
						if (constr[icol]) { // да
											// Тогда увеличение только правой части
											//if (bsecond_member_of_equation) rthdsd[irow] += /*Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j] * source[ie]*/ - selm[i][j] * potent[icol];
						}
						else { // нет
							   // тогда увеличение глобальной матрицы S и правой части
							 addValueIMatrix(&sparseS, irow, icol, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j]);

							
							//addelmsimplesparse_Stress(sparseM, Kmatrix[idirection1 + 3 * i][idirection2 + 3 * j], irow, icol, false, false);
							//if (bsecond_member_of_equation) rthdsd[irow] += telm[i][j] * source[ie];
						}
					}
				}
			}
		}
	}
} //elembdSparse(ie)

  

  // Включение одиночных матричных элементов Kmatrix и Tmatrix (selm, telm)
  // в глобальную матрицу Smatrix и (если bsecond_member_of_equation=true)
  // правую часть. Для уравнения ТЕПЛОПЕРЕДАЧИ.
  // 19.05.2018
void elembdSparse3(integer ie, IMatrix &sparseS, int** nvtx,
	bool* &constr, doublereal* &rthdsd,
	doublereal** &Kmatrix, doublereal* &potent,
	bool bsecond_member_of_equation) {
	// перебор матричных элементов S и T (selm и telm)
	// и корректировка глобальной матрицы S и правой части

	const integer nve = 8;

	integer i, j; // счётчики цикла for
	integer irow, icol; // строка, столбец
	for (i = 0; i<nve; i++) {
		irow = nvtx[i][ie] - 1;

		// Строка соответствует фиксированному потенциалу ?
		if (constr[irow]) { // да
			setValueIMatrix(&sparseS, irow, irow, 1.0f);
			//addelmsimplesparse_Stress(sparseM, 1.0f, irow, irow, true, true);
			if (bsecond_member_of_equation) rthdsd[irow] = potent[irow];
		}
		else { // нет
			   // нет, потенциал переменный, просмотр nve-столбцов
			for (j = 0; j < nve; j++) {

				icol = nvtx[j][ie] - 1;

				// Столбец соответствует фиксированному потенциалу ?
				if (constr[icol]) { // да
					addValueIMatrix(&sparseS, irow, icol, Kmatrix[i][j]);
									// Тогда увеличение только правой части
									//if (bsecond_member_of_equation) rthdsd[irow] += /*Kmatrix[i][j] * source[ie]*/ - selm[i][j] * potent[icol];
				}
				else { // нет
					   // тогда увеличение глобальной матрицы S и правой части
					addValueIMatrix(&sparseS, irow, icol, Kmatrix[i][j]);
					//addelmsimplesparse_Stress(sparseM, Kmatrix[i][j], irow, icol, false, false);
					//if (bsecond_member_of_equation) rthdsd[irow] += telm[i][j] * source[ie];
				}
			}
		}

	}
} //elembdSparse(ie)


  // Включение одиночных матричных элементов Kmatrix и Tmatrix (selm, telm)
  // в глобальную матрицу Smatrix и (если bsecond_member_of_equation=true)
  // правую часть. Для уравнения ТЕПЛОПЕРЕДАЧИ.
  // 19.05.2018
void elembdSparse4(integer ie, SIMPLESPARSE &sparseM, int** nvtx,
	bool* &constr, doublereal* &rthdsd,
	doublereal** &Kmatrix, doublereal* &potent,
	bool bsecond_member_of_equation) {
	// перебор матричных элементов S и T (selm и telm)
	// и корректировка глобальной матрицы S и правой части

	const integer nve = 8;

	integer i, j; // счётчики цикла for
	integer irow, icol; // строка, столбец
	for (i = 0; i<nve; i++) {
		irow = nvtx[i][ie] - 1;

		// Строка соответствует фиксированному потенциалу ?
		if (constr[irow]) { // да
			//setValueIMatrix(sparseM, irow, irow, 1.0f);
#if !bStableVersion
			addelmsimplesparse_Stress_ell(1.0f, irow, irow, true, true);
#else
			addelmsimplesparse_Stress(sparseM, 1.0f, irow, irow, true, true);
#endif
			
			//addelmsimplesparse_Stress(sparseM, 1.0f, irow, irow, false, false);
			if (bsecond_member_of_equation) rthdsd[irow] = potent[irow];
		}
		else { // нет
			   // нет, потенциал переменный, просмотр nve-столбцов
			for (j = 0; j < nve; j++) {

				icol = nvtx[j][ie] - 1;

				// Столбец соответствует фиксированному потенциалу ?
				if (constr[icol]) { // да
					// обязательно должно быть проверено 24.10.2018
					//----->addelmsimplesparse_Stress(sparseM, Kmatrix[i][j], irow, icol, false, false);
									// Тогда увеличение только правой части
									//if (bsecond_member_of_equation) rthdsd[irow] += /*Kmatrix[i][j] * source[ie]*/ - selm[i][j] * potent[icol];

					// Даёт симметричную матрицу для ICCG решателя. Новая модификация 19,07,2021 для температурного солвера. 
#if !bStableVersion
					addelmsimplesparse_Stress_ell(1.0f, icol, icol, true, true);
#else
					addelmsimplesparse_Stress(sparseM, 1.0f, icol, icol, true, true);
#endif
					
					// Важное дополнение для ICCG решателя.
					if (bsecond_member_of_equation) rthdsd[irow] -= Kmatrix[i][j] * potent[icol];
				}
				else { // нет
					   // тогда увеличение глобальной матрицы S и правой части
#if !bStableVersion
					addelmsimplesparse_Stress_ell(Kmatrix[i][j], irow, icol, false, false);
#else
					addelmsimplesparse_Stress(sparseM, Kmatrix[i][j], irow, icol, false, false);
#endif
					
					//addelmsimplesparse_Stress(sparseM, Kmatrix[i][j], irow, icol, false, false);
					//if (bsecond_member_of_equation) rthdsd[irow] += telm[i][j] * source[ie];
				}
			}
		}

	}
} //elembdSparse(ie)


  // Термоупругость сборка матрицы теплопередачи для шестигранной призмы. 4.08.2017.
  // 16.09.2017.
void Thermal_ALICE_assemble_old(integer iP, int** nvtx,
	TOCHKA* pa, float** prop, doublereal** &Kmatrix)
{

	//nvtx
	// ---|+--|-+-|++-|--+|+-+|-++|+++
	// 1	2	3	4	5	6	7	8
	// Порядок перечисления функций формы в данной сборке.
	// --+|-++|+++|+-+|---|-+-|++-|+--
	// 5	7	8	6	1	3	4	2
	// После сборки нужна перенумерация узлов матрицы. 


	doublereal hx = 1.0, hy = 1.0, hz = 1.0; // размеры кубика
	volume3D(iP, nvtx, pa, hx, hy, hz);
	//printf("%e %e %e\n",hx,hy,hz);

	doublereal lambda; // Коэффициент Теплопроводности.

	lambda = prop[LAM][iP];

	// стационарная задача теплопроводности.

	// Сборка локальной матрицы.
	Kmatrix[0][0] = 0.25*lambda*((prop[MULT_LAM_X][iP] * hy*hz / hx)+ (prop[MULT_LAM_Y][iP] * hx * hz / hy)+(prop[MULT_LAM_Z][iP] * hy*hx / hz));
	Kmatrix[0][1] = -0.25*lambda*prop[MULT_LAM_X][iP]*hy*hz/hx;
	Kmatrix[0][2] = 0.0;
	Kmatrix[0][3] = -0.25*lambda*prop[MULT_LAM_Y][iP] *hx*hz / hy;
	Kmatrix[0][4] = -0.25*lambda*prop[MULT_LAM_Z][iP]*hy*hx / hz;
	Kmatrix[0][5] = 0.0;
	Kmatrix[0][6] = 0.0;
	Kmatrix[0][7] = 0.0;
    //
	Kmatrix[1][0] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	Kmatrix[1][1] = 0.25*lambda*((prop[MULT_LAM_X][iP] * hy*hz / hx) + (prop[MULT_LAM_Y][iP] * hx * hz / hy) + (prop[MULT_LAM_Z][iP] * hy*hx / hz));
	Kmatrix[1][2] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[1][3] = 0.0;
	Kmatrix[1][4] = 0.0;
	Kmatrix[1][5] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	Kmatrix[1][6] = 0.0;
	Kmatrix[1][7] = 0.0;
	//
	
	Kmatrix[2][0] = 0.0;
	Kmatrix[2][1] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[2][2] = 0.25*lambda*((prop[MULT_LAM_X][iP]*hy*hz / hx) + (prop[MULT_LAM_Y][iP] *hx * hz / hy) + (prop[MULT_LAM_Z][iP] *hy*hx / hz));
	Kmatrix[2][3] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	Kmatrix[2][4] = 0.0;
	Kmatrix[2][5] = 0.0;
	Kmatrix[2][6] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	Kmatrix[2][7] = 0.0;
	// 
	Kmatrix[3][0] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[3][1] = 0.0;
	Kmatrix[3][2] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	Kmatrix[3][3] = 0.25*lambda*((prop[MULT_LAM_X][iP]*hy*hz / hx) + (prop[MULT_LAM_Y][iP] *hx * hz / hy) + (prop[MULT_LAM_Z][iP] *hy*hx / hz));
	Kmatrix[3][4] = 0.0;
	Kmatrix[3][5] = 0.0;
	Kmatrix[3][6] = 0.0;
	Kmatrix[3][7] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	
	/*
	// 
	Kmatrix[2][0] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[2][1] = 0.0;
	Kmatrix[2][2] = 0.25*lambda*((prop[MULT_LAM_X][iP] * hy*hz / hx) + (prop[MULT_LAM_Y][iP] * hx * hz / hy) + (prop[MULT_LAM_Z][iP] * hy*hx / hz));
	Kmatrix[2][3] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	Kmatrix[2][4] = 0.0;
	Kmatrix[2][5] = 0.0;
	Kmatrix[2][6] =  -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	Kmatrix[2][7] = 0.0;
	//
	Kmatrix[3][0] = 0.0;
	Kmatrix[3][1] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[3][2] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	Kmatrix[3][3] = 0.25*lambda*(prop[MULT_LAM_X][iP] * (hy*hz / hx) + (prop[MULT_LAM_Y][iP] * hx * hz / hy) + (prop[MULT_LAM_Z][iP] * hy*hx / hz));
	Kmatrix[3][4] = 0.0;
	Kmatrix[3][5] = 0.0;
	Kmatrix[3][6] = 0.0;
	Kmatrix[3][7] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	*/
    // 
	Kmatrix[4][0] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	Kmatrix[4][1] = 0.0;
	Kmatrix[4][2] = 0.0;
	Kmatrix[4][3] = 0.0;
	Kmatrix[4][4] = 0.25*lambda*((prop[MULT_LAM_X][iP] * hy*hz / hx) + (prop[MULT_LAM_Y][iP] * hx * hz / hy) + (prop[MULT_LAM_Z][iP] * hy*hx / hz));
	Kmatrix[4][5] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	Kmatrix[4][6] = 0.0;
	Kmatrix[4][7] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	// 
	Kmatrix[5][0] = 0.0;
	Kmatrix[5][1] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	Kmatrix[5][2] = 0.0;
	Kmatrix[5][3] = 0.0;
	Kmatrix[5][4] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	Kmatrix[5][5] = 0.25*lambda*((prop[MULT_LAM_X][iP] * hy*hz / hx) + (prop[MULT_LAM_Y][iP] * hx * hz / hy) + (prop[MULT_LAM_Z][iP] * hy*hx / hz));
	Kmatrix[5][6] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[5][7] = 0.0;
	// 
	
	Kmatrix[6][0] = 0.0;
	Kmatrix[6][1] = 0.0;
	Kmatrix[6][2] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	Kmatrix[6][3] = 0.0;
	Kmatrix[6][4] = 0.0;
	Kmatrix[6][5] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[6][6] = 0.25*lambda*((prop[MULT_LAM_X][iP]*hy*hz / hx) + (prop[MULT_LAM_Y][iP] *hx * hz / hy) + (prop[MULT_LAM_Z][iP] *hy*hx / hz));
	Kmatrix[6][7] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	// 
	Kmatrix[7][0] = 0.0;
	Kmatrix[7][1] = 0.0;
	Kmatrix[7][2] = 0.0;
	Kmatrix[7][3] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	Kmatrix[7][4] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[7][5] = 0.0;
	Kmatrix[7][6] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	Kmatrix[7][7] = 0.25*lambda*((prop[MULT_LAM_X][iP]*hy*hz / hx) + (prop[MULT_LAM_Y][iP] *hx * hz / hy) + (prop[MULT_LAM_Z][iP] *hy*hx / hz));
	
	/*
	// 
	Kmatrix[6][0] = 0.0;
	Kmatrix[6][1] = 0.0;
	Kmatrix[6][2] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	Kmatrix[6][3] = 0.0;
	Kmatrix[6][4] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[6][5] = 0.0;
	Kmatrix[6][6] = 0.25*lambda*((prop[MULT_LAM_X][iP] * hy*hz / hx) + (prop[MULT_LAM_Y][iP] * hx * hz / hy) + (prop[MULT_LAM_Z][iP] * hy*hx / hz));
	Kmatrix[6][7] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	//
	Kmatrix[7][0] = 0.0;
	Kmatrix[7][1] = 0.0;
	Kmatrix[7][2] = 0.0;
	Kmatrix[7][3] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	Kmatrix[7][4] = 0.0;
	Kmatrix[7][5] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[7][6] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	Kmatrix[7][7] = 0.25*lambda*((prop[MULT_LAM_X][iP] * hy*hz / hx) + (prop[MULT_LAM_Y][iP] * hx * hz / hy) + (prop[MULT_LAM_Z][iP] * hy*hx / hz));
	// 
	*/
	/*
	for (integer i_4 = 0; i_4 < 8; i_4++) {
		doublereal ap = Kmatrix[i_4][i_4];
		for (integer j_4 = 0; j_4 < 8; j_4++) {
			//228.51 импирически подобранный коэффициент так чтобы совпадало с ANSYS просто на деформации.
			// 0.01744841 - Чтобы совпало на термоупругости.
			Kmatrix[i_4][j_4] /= ap;
		}
	}
	*/
}



// Термоупругость сборка матрицы теплопередачи для шестигранной призмы. 4.08.2017.
// Только теплопередача в твёрдом теле на основе метода конечных элементов.
// Проверено работает 04.04.2021 для чистой теплопроводности. 
// 22.03.2021 16.09.2017. 29.09.2018 (convection UDS).
void Thermal_ALICE_assemble_only_solid(integer iP, int** nvtx,
	TOCHKA* pa, doublereal** prop, doublereal**& Kmatrix,
	int**& ptr, doublereal*& Ux_arr, doublereal*& Uy_arr,
	doublereal*& Uz_arr, doublereal*& mut_arr)
{

	//Сначала мы детектируем какая у нас нумерация  order1 или order2,
	// а потом алгоритм применяет сборку соответствующую order1 или order2 по выборую
	// Тем самым ненужны никакие перенумерации и алгоритм универсально работает вне 
	// зависимости от нумерации.


	bool border1 = check_nvtx_order1(iP, nvtx, pa);
	bool border2 = check_nvtx_order2(iP, nvtx, pa);
	//system("pause");

	doublereal Ux = Ux_arr[iP], Uy = Uy_arr[iP], Uz = Uz_arr[iP]; // Компоненты скорости в центре ячейки iP.
	doublereal mut = mut_arr[iP];

	/*
	if (ptr[0][iP] > -1) {
		Ux = f[ptr[1][iP]].potent[VX][ptr[0][iP]];
		Uy = f[ptr[1][iP]].potent[VY][ptr[0][iP]];
		Uz = f[ptr[1][iP]].potent[VZ][ptr[0][iP]];
	}
	*/
	doublereal hx = 1.0, hy = 1.0, hz = 1.0; // размеры кубика
	volume3D(iP, nvtx, pa, hx, hy, hz);
	hx = fabs(hx);
	hy = fabs(hy);
	hz = fabs(hz);
	//printf("%e %e %e\n",hx,hy,hz);

	doublereal lambda; // Коэффициент Теплопроводности.



	// стационарная задача теплопроводности с конвекцией на основе противопоточной схемы.
	doublereal rho_Cp = prop[RHO][iP] * prop[HEAT_CAPACITY][iP];

	doublereal Pr_turb = 0.85;

	lambda = prop[LAM][iP];// +prop[HEAT_CAPACITY][iP] * mut / Pr_turb;// добавлена турбулентная теплопроводность 21.11.2019
	//printf("lambda=%e lambda_turb=%e\n", prop[LAM][iP], prop[HEAT_CAPACITY][iP] * mut / Pr_turb);

	

	// z min
	// 3 2     4 3
	// 0 1 или 1 2
	// z max
	// 7 6     8 7
	// 4 5 или 5 6


	// Сборка локальной матрицы.


	int iGn = 2;// 4; //2
		// Gauss points coordinates on each direction
	doublereal GaussPoint[2] = { -1.0 / sqrt(3.0), 1.0 / sqrt(3.0) };
	doublereal GaussWeight[2] = { 1.0, 1.0 };

	//doublereal GaussPoint[4] = {-0.861136, -0.339981, 0.339981, 0.861136};
	//doublereal GaussWeight[4] = {0.347855, 0.652145, 0.652145, 0.347855};


	// Matrix of vertices coordinates. Generic element centred at the origin.
					/*doublereal coordinates[8][3] = {
						{-hx / 2.0, -hy / 2.0, -hz / 2.0},
						{ hx / 2.0, -hy / 2.0, -hz / 2.0},
						{ hx / 2.0,  hy / 2.0, -hz / 2.0},
						{-hx / 2.0,  hy / 2.0, -hz / 2.0},
						{-hx / 2.0, -hy / 2.0,  hz / 2.0},
						{ hx / 2.0, -hy / 2.0,  hz / 2.0},
						{ hx / 2.0,  hy / 2.0,  hz / 2.0},
						{-hx / 2.0,  hy / 2.0,  hz / 2.0}
					};*/

	doublereal coordinates[8][3] = {
		{-hx / 2.0, -hy / 2.0, -hz / 2.0},
		{ hx / 2.0, -hy / 2.0, -hz / 2.0},
		{-hx / 2.0,  hy / 2.0, -hz / 2.0},
		{ hx / 2.0,  hy / 2.0, -hz / 2.0},
		{-hx / 2.0, -hy / 2.0,  hz / 2.0},
		{ hx / 2.0, -hy / 2.0,  hz / 2.0},
		{-hx / 2.0,  hy / 2.0,  hz / 2.0},
		{ hx / 2.0,  hy / 2.0,  hz / 2.0}
	};

	for (int i_4 = 0; i_4 < 3; i_4++) {
		for (int i_5 = 0; i_5 < 3; i_5++) {
			Kmatrix[i_4][i_5] = 0.0;
		}
	}

	for (int i_1 = 0; i_1 < iGn; i_1++) {
		for (int i_2 = 0; i_2 < iGn; i_2++) {
			for (int i_3 = 0; i_3 < iGn; i_3++) {

				doublereal xi1 = GaussPoint[i_1];
				doublereal xi2 = GaussPoint[i_2];
				doublereal xi3 = GaussPoint[i_3];

				// Compute shape functions derivatives
			/*doublereal dShape[3][8] = {
				{-(1 - xi2) * (1 - xi3),(1 - xi2) * (1 - xi3), (1 + xi2) * (1 - xi3),-(1 + xi2) * (1 - xi3),-(1 - xi2) * (1 + xi3),(1 - xi2) * (1 + xi3),(1 + xi2) * (1 + xi3),-(1 + xi2) * (1 + xi3)},
				{-(1 - xi1) * (1 - xi3),-(1 + xi1) * (1 - xi3),(1 + xi1) * (1 - xi3), (1 - xi1) * (1 - xi3),-(1 - xi1) * (1 + xi3),-(1 + xi1) * (1 + xi3), (1 + xi1) * (1 + xi3),(1 - xi1) * (1 + xi3)},
				{-(1 - xi1) * (1 - xi2), -(1 + xi1) * (1 - xi2),-(1 + xi1) * (1 + xi2),-(1 - xi1) * (1 + xi2),(1 - xi1) * (1 - xi2),(1 + xi1) * (1 - xi2),(1 + xi1) * (1 + xi2),(1 - xi1) * (1 + xi2)}
			};*/

				

			// Compute shape functions derivatives
			/*doublereal dShape[3][8] = {
				{-(1 - xi2) * (1 - xi3),(1 - xi2) * (1 - xi3), -(1 + xi2) * (1 - xi3),(1 + xi2) * (1 - xi3),-(1 - xi2) * (1 + xi3),(1 - xi2) * (1 + xi3),-(1 + xi2) * (1 + xi3), (1 + xi2) * (1 + xi3)},
				{-(1 - xi1) * (1 - xi3),-(1 + xi1) * (1 - xi3), (1 - xi1) * (1 - xi3),(1 + xi1) * (1 - xi3),-(1 - xi1) * (1 + xi3),-(1 + xi1) * (1 + xi3), (1 - xi1) * (1 + xi3), (1 + xi1) * (1 + xi3)},
				{-(1 - xi1) * (1 - xi2), -(1 + xi1) * (1 - xi2),-(1 - xi1) * (1 + xi2),-(1 + xi1) * (1 + xi2),(1 - xi1) * (1 - xi2),(1 + xi1) * (1 - xi2),(1 - xi1) * (1 + xi2), (1 + xi1) * (1 + xi2)}
			};*/

				doublereal dShape[3][8] = {
					{-1.0 * xi2 * xi3 + 1.0 * xi2 + 1.0 * xi3 - 1.0,
					 1.0 * xi2 * xi3 - 1.0 * xi2 - 1.0 * xi3 + 1.0,
					1.0 * xi2 * xi3 - 1.0 * xi2 + 1.0 * xi3 - 1.0,
					-1.0 * xi2 * xi3 + 1.0 * xi2 - 1.0 * xi3 + 1.0,
					1.0 * xi2 * xi3 + 1.0 * xi2 - 1.0 * xi3 - 1.0,
					-1.0 * xi2 * xi3 - 1.0 * xi2 + 1.0 * xi3 + 1.0,
					-1.0 * xi2 * xi3 - 1.0 * xi2 - 1.0 * xi3 - 1.0,
					1.0 * xi2 * xi3 + 1.0 * xi2 + 1.0 * xi3 + 1.0},
					{-1.0 * xi1 * xi3 + 1.0 * xi1 + 1.0 * xi3 - 1.0,
				1.0 * xi1 * xi3 - 1.0 * xi1 + 1.0 * xi3 - 1.0,
				1.0 * xi1 * xi3 - 1.0 * xi1 - 1.0 * xi3 + 1.0,
				-1.0 * xi1 * xi3 + 1.0 * xi1 - 1.0 * xi3 + 1.0,
				1.0 * xi1 * xi3 + 1.0 * xi1 - 1.0 * xi3 - 1.0,
				-1.0 * xi1 * xi3 - 1.0 * xi1 - 1.0 * xi3 - 1.0,
				-1.0 * xi1 * xi3 - 1.0 * xi1 + 1.0 * xi3 + 1.0,
				1.0 * xi1 * xi3 + 1.0 * xi1 + 1.0 * xi3 + 1.0},
					{-1.0 * xi1 * xi2 + 1.0 * xi1 + 1.0 * xi2 - 1.0,
				1.0 * xi1 * xi2 - 1.0 * xi1 + 1.0 * xi2 - 1.0,
				1.0 * xi1 * xi2 + 1.0 * xi1 - 1.0 * xi2 - 1.0,
				-1.0 * xi1 * xi2 - 1.0 * xi1 - 1.0 * xi2 - 1.0,
				1.0 * xi1 * xi2 - 1.0 * xi1 - 1.0 * xi2 + 1.0,
				-1.0 * xi1 * xi2 + 1.0 * xi1 - 1.0 * xi2 + 1.0,
				-1.0 * xi1 * xi2 - 1.0 * xi1 + 1.0 * xi2 + 1.0,
				1.0 * xi1 * xi2 + 1.0 * xi1 + 1.0 * xi2 + 1.0}
				};


				for (int i_4 = 0; i_4 < 3; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
						dShape[i_4][i_5] *= 1.0 / 8.0;
					}
				}

				// Compute Jacobian matrix
				doublereal JacobianMatrix[3][3] = {
					{0.0, 0.0, 0.0},
					{0.0, 0.0, 0.0},
					{0.0, 0.0, 0.0}
				};

				for (int i_4 = 0; i_4 < 3; i_4++) {
					for (int i_5 = 0; i_5 < 3; i_5++) {
						for (int i_6 = 0; i_6 < 8; i_6++) {
							JacobianMatrix[i_4][i_5] += dShape[i_4][i_6] * coordinates[i_6][i_5];
						}
					}
				}

				// Compute inverse Jacobian matrix
				doublereal inverseJacobianMatrix[3][3] = {
					{0.0, 0.0, 0.0},
					{0.0, 0.0, 0.0},
					{0.0, 0.0, 0.0}
				};

				{
					/*printf("Jacobian\n");
					printf("%e %e %e \n", JacobianMatrix[0][0], JacobianMatrix[0][1], JacobianMatrix[0][2]);
					printf("%e %e %e \n", JacobianMatrix[1][0], JacobianMatrix[1][1], JacobianMatrix[1][2]);
					printf("%e %e %e \n", JacobianMatrix[2][0], JacobianMatrix[2][1], JacobianMatrix[2][2]);
					getchar();*/


					inverseJacobianMatrix[0][0] = (JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[1][2] * JacobianMatrix[2][1]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0]
						* JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0]
						* JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[0][1] = -(JacobianMatrix[0][1] * JacobianMatrix[2][2] - JacobianMatrix[0][2] * JacobianMatrix[2][1]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] -
						JacobianMatrix[0][0] * JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] *
						JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[0][2] = (JacobianMatrix[0][1] * JacobianMatrix[1][2] - JacobianMatrix[0][2] * JacobianMatrix[1][1]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0]
						* JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0]
						* JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[1][0] = -(JacobianMatrix[1][0] * JacobianMatrix[2][2] - JacobianMatrix[1][2] * JacobianMatrix[2][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0]
						* JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] *
						JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[1][1] = (JacobianMatrix[0][0] * JacobianMatrix[2][2] - JacobianMatrix[0][2] * JacobianMatrix[2][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0]
						* JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0] *
						JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[1][2] = -(JacobianMatrix[0][0] * JacobianMatrix[1][2] - JacobianMatrix[0][2] * JacobianMatrix[1][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2]
						* JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] *
						JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[2][0] = (JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[1][1] * JacobianMatrix[2][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2]
						* JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0] * JacobianMatrix[2][1] -
						JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[2][1] = -(JacobianMatrix[0][0] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[2][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2]
						* JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] *
						JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);
					inverseJacobianMatrix[2][2] = (JacobianMatrix[0][0] * JacobianMatrix[1][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0]) / (JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2]
						* JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2] + JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0] *
						JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0]);

					/*printf("%e %e %e \n", inverseJacobianMatrix[0][0], inverseJacobianMatrix[0][1], inverseJacobianMatrix[0][2]);
					printf("%e %e %e \n", inverseJacobianMatrix[1][0], inverseJacobianMatrix[1][1], inverseJacobianMatrix[1][2]);
					printf("%e %e %e \n", inverseJacobianMatrix[2][0], inverseJacobianMatrix[2][1], inverseJacobianMatrix[2][2]);
					getchar();*/

				}

				// determinant
				doublereal det = JacobianMatrix[0][0] * JacobianMatrix[1][1] * JacobianMatrix[2][2] - JacobianMatrix[0][0] * JacobianMatrix[1][2] * JacobianMatrix[2][1] - JacobianMatrix[0][1] * JacobianMatrix[1][0] * JacobianMatrix[2][2]
					+ JacobianMatrix[0][1] * JacobianMatrix[1][2] * JacobianMatrix[2][0] + JacobianMatrix[0][2] * JacobianMatrix[1][0] * JacobianMatrix[2][1] - JacobianMatrix[0][2] * JacobianMatrix[1][1] * JacobianMatrix[2][0];


				doublereal auxiliar[3][8] = {
									{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
									{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0},
									{0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0}
				};

				// Compute auxiliar matrix for construction of B-Operator

				for (int i_4 = 0; i_4 < 3; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
						for (int i_6 = 0; i_6 < 3; i_6++) {
							auxiliar[i_4][i_5] += inverseJacobianMatrix[i_4][i_6] * dShape[i_6][i_5];
						}
					}
				}

				// Материалы с ортотропной теплопроводностью.
				doublereal C[3][3] = {
									{lambda* prop[MULT_LAM_X][iP], 0.0, 0.0},
									{0.0, lambda * prop[MULT_LAM_Y][iP], 0.0},
									{0.0, 0.0, lambda * prop[MULT_LAM_Z][iP]}
				};


				// Preallocate memory for B-Operator
				doublereal M1[8][8];
				for (int i_4 = 0; i_4 < 8; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
						M1[i_4][i_5] = 0.0;
					}
				}

				/*for (int i_4 = 0; i_4 < 8; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
						for (int i_6 = 0; i_6 < 3; i_6++) {
							//M1[i_4][i_5] += dShape[i_6][i_4] * dShape[i_6][i_5];
							M1[i_4][i_5] += auxiliar[i_6][i_4] * auxiliar[i_6][i_5];
						}
					}
				}*/

				for (int i_4 = 0; i_4 < 8; i_4++) {
					for (int i_5 = 0; i_5 < 3; i_5++) {
						for (int i_6 = 0; i_6 < 3; i_6++) {
							//M1[i_4][i_5] += dShape[i_6][i_4] * dShape[i_6][i_5];
							M1[i_4][i_5] += auxiliar[i_6][i_4] * C[i_6][i_5];
						}
					}
				}

				doublereal M2[8][8];
				for (int i_4 = 0; i_4 < 8; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
						M2[i_4][i_5] = 0.0;
					}
				}

				for (int i_4 = 0; i_4 < 8; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
						for (int i_6 = 0; i_6 < 3; i_6++) {
							M2[i_4][i_5] += M1[i_4][i_6] * auxiliar[i_6][i_5];
						}
					}
				}

				for (int i_4 = 0; i_4 < 8; i_4++) {
					for (int i_5 = 0; i_5 < 8; i_5++) {
					//	Kmatrix[i_4][i_5] += GaussWeight[i_1] * GaussWeight[i_2] * GaussWeight[i_3] * lambda * M1[i_4][i_5] * det;

						Kmatrix[i_4][i_5] += GaussWeight[i_1] * GaussWeight[i_2] * GaussWeight[i_3] * M2[i_4][i_5]*det;
					}
				}

				
			}
		}
	}

	
	/*
	Kmatrix[0][0] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[0][1] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[0][2] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[0][3] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[0][4] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[0][5] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[0][6] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[0][7] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[1][0] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[1][1] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[1][2] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[1][3] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[1][4] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[1][5] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[1][6] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[1][7] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[2][0] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[2][1] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[2][2] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[2][3] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[2][4] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[2][5] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[2][6] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[2][7] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[3][0] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[3][1] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[3][2] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[3][3] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[3][4] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[3][5] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[3][6] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[3][7] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[4][0] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[4][1] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[4][2] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[4][3] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[4][4] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[4][5] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[4][6] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[4][7] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[5][0] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[5][1] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[5][2] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[5][3] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[5][4] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[5][5] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[5][6] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[5][7] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[6][0] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[6][1] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[6][2] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[6][3] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[6][4] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[6][5] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[6][6] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[6][7] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[7][0] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[7][1] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 2.0 / 9.0 / (hx * hx));
	Kmatrix[7][2] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 2.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[7][3] = 0.5 * hx * hy * hz * lambda * (-prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[7][4] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 2.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[7][5] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) - prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 4.0 / 9.0 / (hx * hx));
	Kmatrix[7][6] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 4.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 4.0 / 9.0 / (hy * hy) - prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	Kmatrix[7][7] = 0.5 * hx * hy * hz * lambda * (prop[MULT_LAM_Z][iP] * 8.0 / 9.0 / (hz * hz) + prop[MULT_LAM_Y][iP] * 8.0 / 9.0 / (hy * hy) + prop[MULT_LAM_X][iP] * 8.0 / 9.0 / (hx * hx));
	*/

	


}

// Термоупругость сборка матрицы теплопередачи для шестигранной призмы. 4.08.2017.
// Сборка на основе метода контрольного объёма не только для теплопередачи но и для конвекции.
// 16.09.2017. 29.09.2018 (convection UDS).
void Thermal_ALICE_assemble_is_true(integer iP, int** nvtx,
	TOCHKA* pa, doublereal** prop, doublereal** &Kmatrix, 
	int** &ptr, doublereal* &Ux_arr, doublereal* &Uy_arr,
	doublereal* &Uz_arr, doublereal* &mut_arr)
{

	//Сначала мы детектируем какая у нас нумерация  order1 или order2,
	// а потом алгоритм применяет сборку соответствующую order1 или order2 по выборую
	// Тем самым ненужны никакие перенумерации и алгоритм универсально работает вне 
	// зависимости от нумерации.


	bool border1=check_nvtx_order1(iP, nvtx, pa);
	bool border2=check_nvtx_order2(iP, nvtx, pa);
	//system("pause");

	doublereal Ux = Ux_arr[iP], Uy = Uy_arr[iP], Uz = Uz_arr[iP]; // Компоненты скорости в центре ячейки iP.
	doublereal mut = mut_arr[iP];

	/*
	if (ptr[0][iP] > -1) {
		Ux = f[ptr[1][iP]].potent[VX][ptr[0][iP]];
		Uy = f[ptr[1][iP]].potent[VY][ptr[0][iP]];
		Uz = f[ptr[1][iP]].potent[VZ][ptr[0][iP]];
	}
	*/
	doublereal hx = 1.0, hy = 1.0, hz = 1.0; // размеры кубика
	volume3D(iP, nvtx, pa, hx, hy, hz);
	//printf("%e %e %e\n",hx,hy,hz);

	doublereal lambda; // Коэффициент Теплопроводности.

	

	// стационарная задача теплопроводности с конвекцией на основе противопоточной схемы.
	doublereal rho_Cp = prop[RHO][iP] * prop[HEAT_CAPACITY][iP];

	doublereal Pr_turb = 0.85;

	lambda = prop[LAM][iP] + prop[HEAT_CAPACITY][iP]*mut/ Pr_turb;// добавлена турбулентная теплопроводность 21.11.2019
	//printf("lambda=%e lambda_turb=%e\n", prop[LAM][iP], prop[HEAT_CAPACITY][iP] * mut / Pr_turb);

	doublereal sign_control = 1.0;

	// z min
	// 3 2     4 3
	// 0 1 или 1 2
	// z max
	// 7 6     8 7
	// 4 5 или 5 6


	// Сборка локальной матрицы.
	Kmatrix[0][0] = 0.25*lambda*(prop[MULT_LAM_X][iP] * hy*hz / hx) +fmax(-sign_control*0.25*(rho_Cp*hz*hy*Ux),0.0)
		           +0.25*lambda*(prop[MULT_LAM_Y][iP] * hx * hz / hy) + fmax(-sign_control*0.25*(rho_Cp*hz*hx*Uy), 0.0)
		           +0.25*lambda*(prop[MULT_LAM_Z][iP] * hy*hx / hz)+fmax(-sign_control*0.25*(rho_Cp*hx*hy*Uz), 0.0);

	Kmatrix[0][1] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx - fmax(-0.25*(rho_Cp*hz*hy*Ux), 0.0);
	Kmatrix[0][2] = 0.0;
	Kmatrix[0][3] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy - fmax(-0.25*(rho_Cp*hz*hx*Uy), 0.0);
	Kmatrix[0][4] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz - fmax(-0.25*(rho_Cp*hx*hy*Uz), 0.0);
	Kmatrix[0][5] = 0.0;
	Kmatrix[0][6] = 0.0;
	Kmatrix[0][7] = 0.0;
	//
	Kmatrix[1][0] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx - fmax(0.25*(rho_Cp*hz*hy*Ux), 0.0);

	Kmatrix[1][1] = 0.25*lambda*(prop[MULT_LAM_X][iP] * hy*hz / hx) + fmax(sign_control*0.25*(rho_Cp*hz*hy*Ux), 0.0)
		          + 0.25*lambda*(prop[MULT_LAM_Y][iP] * hx * hz / hy) + fmax(-sign_control*0.25*(rho_Cp*hz*hx*Uy), 0.0)
		          + 0.25*lambda*(prop[MULT_LAM_Z][iP] * hy*hx / hz) + fmax(-sign_control*0.25*(rho_Cp*hx*hy*Uz), 0.0);

	Kmatrix[1][2] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy - fmax(-0.25*(rho_Cp*hz*hx*Uy), 0.0);
	Kmatrix[1][3] = 0.0;
	Kmatrix[1][4] = 0.0;
	Kmatrix[1][5] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz - fmax(-0.25*(rho_Cp*hx*hy*Uz), 0.0);
	Kmatrix[1][6] = 0.0;
	Kmatrix[1][7] = 0.0;
	//
	if (border2) {
		// z min
		// 3 2     4 3
		// 0 1 или 1 2
		// z max
		// 7 6     8 7
		// 4 5 или 5 6

		Kmatrix[2][0] = 0.0;
		Kmatrix[2][1] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy - fmax(0.25*(rho_Cp*hz*hx*Uy), 0.0);

		Kmatrix[2][2] = 0.25*lambda*(prop[MULT_LAM_X][iP] * hy*hz / hx) + fmax(sign_control*0.25*(rho_Cp*hz*hy*Ux), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Y][iP] * hx * hz / hy) + fmax(sign_control*0.25*(rho_Cp*hz*hx*Uy), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Z][iP] * hy*hx / hz) + fmax(-0.25*(sign_control*rho_Cp*hx*hy*Uz), 0.0);

		Kmatrix[2][3] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx - fmax(0.25*(rho_Cp*hz*hy*Ux), 0.0);
		Kmatrix[2][4] = 0.0;
		Kmatrix[2][5] = 0.0;
		Kmatrix[2][6] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz - fmax(-0.25*(rho_Cp*hx*hy*Uz), 0.0);
		Kmatrix[2][7] = 0.0;
		// 
		Kmatrix[3][0] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy - fmax(0.25*(rho_Cp*hz*hx*Uy), 0.0);
		Kmatrix[3][1] = 0.0;
		Kmatrix[3][2] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx - fmax(-0.25*(rho_Cp*hz*hy*Ux), 0.0);

		Kmatrix[3][3] = 0.25*lambda*(prop[MULT_LAM_X][iP] * hy*hz / hx) + fmax(-sign_control*0.25*(rho_Cp*hz*hy*Ux), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Y][iP] * hx * hz / hy) + fmax(sign_control*0.25*(rho_Cp*hz*hx*Uy), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Z][iP] * hy*hx / hz) + fmax(-sign_control*0.25*(rho_Cp*hx*hy*Uz), 0.0);
		Kmatrix[3][4] = 0.0;
		Kmatrix[3][5] = 0.0;
		Kmatrix[3][6] = 0.0;
		Kmatrix[3][7] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz - fmax(-0.25*(rho_Cp*hx*hy*Uz), 0.0);
	}
	if (border1) {
		// z min
		// 2 3     3 4
		// 0 1 или 1 2
		// z max
		// 6 7     7 8
		// 4 5 или 5 6

		Kmatrix[3][0] = 0.0;
		Kmatrix[3][1] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy - fmax(0.25*(rho_Cp*hz*hx*Uy), 0.0);

		Kmatrix[3][3] = 0.25*lambda*(prop[MULT_LAM_X][iP] * hy*hz / hx) + fmax(sign_control*0.25*(rho_Cp*hz*hy*Ux), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Y][iP] * hx * hz / hy) + fmax(sign_control*0.25*(rho_Cp*hz*hx*Uy), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Z][iP] * hy*hx / hz) + fmax(-0.25*(sign_control*rho_Cp*hx*hy*Uz), 0.0);

		Kmatrix[3][2] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx - fmax(0.25*(rho_Cp*hz*hy*Ux), 0.0);
		Kmatrix[3][4] = 0.0;
		Kmatrix[3][5] = 0.0;
		Kmatrix[3][6] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz - fmax(-0.25*(rho_Cp*hx*hy*Uz), 0.0);
		Kmatrix[3][7] = 0.0;
		// 
		Kmatrix[2][0] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy - fmax(0.25*(rho_Cp*hz*hx*Uy), 0.0);
		Kmatrix[2][1] = 0.0;
		Kmatrix[2][3] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx - fmax(-0.25*(rho_Cp*hz*hy*Ux), 0.0);

		Kmatrix[2][2] = 0.25*lambda*(prop[MULT_LAM_X][iP] * hy*hz / hx) + fmax(-sign_control*0.25*(rho_Cp*hz*hy*Ux), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Y][iP] * hx * hz / hy) + fmax(sign_control*0.25*(rho_Cp*hz*hx*Uy), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Z][iP] * hy*hx / hz) + fmax(-sign_control*0.25*(rho_Cp*hx*hy*Uz), 0.0);
		Kmatrix[2][4] = 0.0;
		Kmatrix[2][5] = 0.0;
		Kmatrix[2][6] = 0.0;
		Kmatrix[2][7] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz - fmax(-0.25*(rho_Cp*hx*hy*Uz), 0.0);
	}
	/*
	//
	Kmatrix[2][0] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[2][1] = 0.0;
	Kmatrix[2][2] = 0.25*lambda*((prop[MULT_LAM_X][iP] * hy*hz / hx) + (prop[MULT_LAM_Y][iP] * hx * hz / hy) + (prop[MULT_LAM_Z][iP] * hy*hx / hz));
	Kmatrix[2][3] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	Kmatrix[2][4] = 0.0;
	Kmatrix[2][5] = 0.0;
	Kmatrix[2][6] =  -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	Kmatrix[2][7] = 0.0;
	//
	Kmatrix[3][0] = 0.0;
	Kmatrix[3][1] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[3][2] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	Kmatrix[3][3] = 0.25*lambda*(prop[MULT_LAM_X][iP] * (hy*hz / hx) + (prop[MULT_LAM_Y][iP] * hx * hz / hy) + (prop[MULT_LAM_Z][iP] * hy*hx / hz));
	Kmatrix[3][4] = 0.0;
	Kmatrix[3][5] = 0.0;
	Kmatrix[3][6] = 0.0;
	Kmatrix[3][7] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	*/
	
	//
	// 
	Kmatrix[4][0] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz - fmax(0.25*(rho_Cp*hx*hy*Uz), 0.0);
	Kmatrix[4][1] = 0.0;
	Kmatrix[4][2] = 0.0;
	Kmatrix[4][3] = 0.0;
	Kmatrix[4][4] = 0.25*lambda*(prop[MULT_LAM_X][iP] * hy*hz / hx) + fmax(-sign_control*0.25*(rho_Cp*hz*hy*Ux), 0.0)
		          + 0.25*lambda*(prop[MULT_LAM_Y][iP] * hx * hz / hy)+ fmax(-sign_control*0.25*(rho_Cp*hz*hx*Uy), 0.0)
	              + 0.25*lambda*(prop[MULT_LAM_Z][iP] * hy*hx / hz)+ fmax(sign_control*0.25*(rho_Cp*hx*hy*Uz), 0.0);
	Kmatrix[4][5] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx - fmax(-0.25*(rho_Cp*hz*hy*Ux), 0.0);
	Kmatrix[4][6] = 0.0;
	Kmatrix[4][7] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy - fmax(-0.25*(rho_Cp*hz*hx*Uy), 0.0);
	
	// 
	Kmatrix[5][0] = 0.0;
	Kmatrix[5][1] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz - fmax(0.25*(rho_Cp*hx*hy*Uz), 0.0);
	Kmatrix[5][2] = 0.0;
	Kmatrix[5][3] = 0.0;
	Kmatrix[5][4] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx - fmax(0.25*(rho_Cp*hz*hy*Ux), 0.0);
	Kmatrix[5][5] = 0.25*lambda*(prop[MULT_LAM_X][iP] * hy*hz / hx) + fmax(sign_control*0.25*(rho_Cp*hz*hy*Ux), 0.0)
		          + 0.25*lambda*(prop[MULT_LAM_Y][iP] * hx * hz / hy) + fmax(-sign_control*0.25*(rho_Cp*hz*hx*Uy), 0.0)
		          + 0.25*lambda*(prop[MULT_LAM_Z][iP] * hy*hx / hz) + fmax(sign_control*0.25*(rho_Cp*hx*hy*Uz), 0.0);
	Kmatrix[5][6] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy - fmax(-0.25*(rho_Cp*hz*hx*Uy), 0.0);
	Kmatrix[5][7] = 0.0;
	
	// 
	if (border2) {
		// z min
		// 3 2     4 3
		// 0 1 или 1 2
		// z max
		// 7 6     8 7
		// 4 5 или 5 6

		Kmatrix[6][0] = 0.0;
		Kmatrix[6][1] = 0.0;
		Kmatrix[6][2] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz - fmax(0.25*(rho_Cp*hx*hy*Uz), 0.0);
		Kmatrix[6][3] = 0.0;
		Kmatrix[6][4] = 0.0;
		Kmatrix[6][5] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy - fmax(0.25*(rho_Cp*hz*hx*Uy), 0.0);
		Kmatrix[6][6] = 0.25*lambda*(prop[MULT_LAM_X][iP] * hy*hz / hx) + fmax(sign_control*0.25*(rho_Cp*hz*hy*Ux), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Y][iP] * hx * hz / hy) + fmax(sign_control*0.25*(rho_Cp*hz*hx*Uy), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Z][iP] * hy*hx / hz) + fmax(+sign_control*0.25*(rho_Cp*hx*hy*Uz), 0.0);
		Kmatrix[6][7] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx - fmax(0.25*(rho_Cp*hz*hy*Ux), 0.0);

		// 
		Kmatrix[7][0] = 0.0;
		Kmatrix[7][1] = 0.0;
		Kmatrix[7][2] = 0.0;
		Kmatrix[7][3] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz - fmax(0.25*(rho_Cp*hx*hy*Uz), 0.0);
		Kmatrix[7][4] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy - fmax(0.25*(rho_Cp*hz*hx*Uy), 0.0);
		Kmatrix[7][5] = 0.0;
		Kmatrix[7][6] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx - fmax(-0.25*(rho_Cp*hz*hy*Ux), 0.0);
		Kmatrix[7][7] = 0.25*lambda*(prop[MULT_LAM_X][iP] * hy*hz / hx) + fmax(-sign_control*0.25*(rho_Cp*hz*hy*Ux), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Y][iP] * hx * hz / hy) + fmax(sign_control*0.25*(rho_Cp*hz*hx*Uy), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Z][iP] * hy*hx / hz) + fmax(sign_control*0.25*(rho_Cp*hx*hy*Uz), 0.0);
	}
	if (border1) {
		// z min
		// 2 3     3 4
		// 0 1 или 1 2
		// z max
		// 6 7     7 8
		// 4 5 или 5 6

		Kmatrix[7][0] = 0.0;
		Kmatrix[7][1] = 0.0;
		Kmatrix[7][2] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz - fmax(0.25*(rho_Cp*hx*hy*Uz), 0.0);
		Kmatrix[7][3] = 0.0;
		Kmatrix[7][4] = 0.0;
		Kmatrix[7][5] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy - fmax(0.25*(rho_Cp*hz*hx*Uy), 0.0);
		Kmatrix[7][7] = 0.25*lambda*(prop[MULT_LAM_X][iP] * hy*hz / hx) + fmax(sign_control*0.25*(rho_Cp*hz*hy*Ux), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Y][iP] * hx * hz / hy) + fmax(sign_control*0.25*(rho_Cp*hz*hx*Uy), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Z][iP] * hy*hx / hz) + fmax(+sign_control*0.25*(rho_Cp*hx*hy*Uz), 0.0);
		Kmatrix[7][6] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx - fmax(0.25*(rho_Cp*hz*hy*Ux), 0.0);

		// 
		Kmatrix[6][0] = 0.0;
		Kmatrix[6][1] = 0.0;
		Kmatrix[6][2] = 0.0;
		Kmatrix[6][3] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz - fmax(0.25*(rho_Cp*hx*hy*Uz), 0.0);
		Kmatrix[6][4] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy - fmax(0.25*(rho_Cp*hz*hx*Uy), 0.0);
		Kmatrix[6][5] = 0.0;
		Kmatrix[6][7] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx - fmax(-0.25*(rho_Cp*hz*hy*Ux), 0.0);
		Kmatrix[6][6] = 0.25*lambda*(prop[MULT_LAM_X][iP] * hy*hz / hx) + fmax(-sign_control*0.25*(rho_Cp*hz*hy*Ux), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Y][iP] * hx * hz / hy) + fmax(sign_control*0.25*(rho_Cp*hz*hx*Uy), 0.0)
			+ 0.25*lambda*(prop[MULT_LAM_Z][iP] * hy*hx / hz) + fmax(sign_control*0.25*(rho_Cp*hx*hy*Uz), 0.0);
	}
	/*
	//
	Kmatrix[6][0] = 0.0;
	Kmatrix[6][1] = 0.0;
	Kmatrix[6][2] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	Kmatrix[6][3] = 0.0;
	Kmatrix[6][4] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[6][5] = 0.0;
	Kmatrix[6][6] = 0.25*lambda*((prop[MULT_LAM_X][iP] * hy*hz / hx) + (prop[MULT_LAM_Y][iP] * hx * hz / hy) + (prop[MULT_LAM_Z][iP] * hy*hx / hz));
	Kmatrix[6][7] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	//
	Kmatrix[7][0] = 0.0;
	Kmatrix[7][1] = 0.0;
	Kmatrix[7][2] = 0.0;
	Kmatrix[7][3] = -0.25*lambda*prop[MULT_LAM_Z][iP] * hy*hx / hz;
	Kmatrix[7][4] = 0.0;
	Kmatrix[7][5] = -0.25*lambda*prop[MULT_LAM_Y][iP] * hx*hz / hy;
	Kmatrix[7][6] = -0.25*lambda*prop[MULT_LAM_X][iP] * hy*hz / hx;
	Kmatrix[7][7] = 0.25*lambda*((prop[MULT_LAM_X][iP] * hy*hz / hx) + (prop[MULT_LAM_Y][iP] * hx * hz / hy) + (prop[MULT_LAM_Z][iP] * hy*hx / hz));
	//
	*/
	/*
	for (integer i_4 = 0; i_4 < 8; i_4++) {
	doublereal ap = Kmatrix[i_4][i_4];
	for (integer j_4 = 0; j_4 < 8; j_4++) {
	//228.51 импирически подобранный коэффициент так чтобы совпадало с ANSYS просто на деформации.
	// 0.01744841 - Чтобы совпало на термоупругости.
	Kmatrix[i_4][j_4] /= ap;
	}
	}
	*/

	// Определитель Якоби 0.5*hx*hy*hz. Ввывод надо домножить локальную 
	// матрицу жесткости на забытый коэффициент 0.5.

	for (integer i_4 = 0; i_4 < 8; i_4++) {
		for (integer i_5 = 0; i_5 < 8; i_5++) {
			// Нет совпадения с МКО.
			//Kmatrix[i_4][i_5] *= 0.5; // Умножаем на коэффициент от якобиана. 03.04.2021
		}
	}
}



// Термоупругость сборка матрицы теплопередачи для шестигранной призмы. 4.08.2017.
// Только теплопередача в твёрдом теле на основе метода конечных элементов.
// Проверено работает 04.04.2021 для чистой теплопроводности. 
// 22.03.2021 16.09.2017. 29.09.2018 (convection UDS).
void Thermal_ALICE_assemble(integer iP, int** nvtx,
	TOCHKA* pa, doublereal** prop, doublereal**& Kmatrix,
	int**& ptr, doublereal*& Ux_arr, doublereal*& Uy_arr,
	doublereal*& Uz_arr, doublereal*& mut_arr)
{

	doublereal Ux = Ux_arr[iP], Uy = Uy_arr[iP], Uz = Uz_arr[iP]; // Компоненты скорости в центре ячейки iP.

	if (b_on_adaptive_local_refinement_mesh) {

		// Та МКЭ сборка которая у меня есть дает черти что на АЛИС сетке.
		// Поэтому на АЛИС применяется МКО поэлементная сборка.

		// Поячеечная сборка на основе метода контрольного объёма.

		// Проблемы с точностью и повидимому прапвильностью.

		Thermal_ALICE_assemble_is_true(iP, nvtx,
			pa, prop, Kmatrix,
			ptr, Ux_arr, Uy_arr,
			Uz_arr, mut_arr);
	}
	else {

		if ((fabs(Ux * Ux + Uy * Uy + Uz * Uz) < 1.0e-20)) {
			// Точность проверена.

			Thermal_ALICE_assemble_only_solid(iP, nvtx,
				pa, prop, Kmatrix,
				ptr, Ux_arr, Uy_arr,
				Uz_arr, mut_arr);
		}
		else {
			// С конвекцией.
			// Поячеечная сборка на основе метода контрольного объёма.

			// Проблемы с точностью и повидимому прапвильностью.

			Thermal_ALICE_assemble_is_true(iP, nvtx,
				pa, prop, Kmatrix,
				ptr, Ux_arr, Uy_arr,
				Uz_arr, mut_arr);
		}
	}
}


// собирает одно уравнение матрицы СЛАУ для обобщенного уравнения 
// конвекции - диффузии, для определённого контрольного объёма.
// Для прямоугольной сетки.
// Для чистой теплопроводности. Только внутренние КО.
// Начинаем собирать матрицу на АЛИС сетке 26 сентября 2016. в 14_09.
// 06,10,2020 Медленная версия, возможно из-за кеша.
void my_elmatr_quad_T3D_alternative(int iP, equation3D* &sl, equation3D_bon* &slb,
	bool btimedep, doublereal tauparam, integer ishconvection,
	int** &nvtx, doublereal* &potent, TOCHKA* &pa,
	float** &prop, float** &prop_b, int*** &neighbors_for_the_internal_node,
	doublereal alpha, doublereal dbeta, bool bconvective,
	doublereal dSc_out, POWER_TIME_DEPEND ipower_time_depend, int maxelm, integer flow_interior,
	int** &ptr, BOUND* &border_neighbor, int ls, FLOW* &f,
	bool* &binternalsource, doublereal* toldtimestep,
	BLOCK*& b, int lb, TPROP*& matlist, integer inumglobaliter,
	SOURCE*& s, doublereal poweron_multiplier_sequence,
	integer *& ilevel_alice, int* &whot_is_block) {


#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (iP < 0) {
		printf("iP=%lld\n", iP);
		system("pause");
	}
#endif


	// btimedep==false - стационарный, иначе (true) нестационарный
	// tauparam - шаг по времени.
	// toldtimestep - температура с предыдущего временного слоя.
	const bool imitation_time = false; // false - псевдо время не используется, true - используется

									   // inumglobaliter номер глобальной итерации SIMPLE алгоритма.


									   // Поправка Рхи-Чоу должна быть включена иначе скорости 
									   // не будут удовлетворять уравнению несжимаемости (что недопустимо с физической точки зрения).
									   // если true то включаем поправку Рхи-Чоу.
									   //bool bRhieChowi=true, bRhieChowb=false; // i - internal, b - border
									   //doublereal RCh=1.0; // регулирование вклада поправки Рхи-Чоу См. Вабищевич.

									   // iP - номер центрального контрольного объёма
									   // iP внутренний КО 0..maxelm-1
	int iE = -1, iN = -1, iT = -1, iW = -1, iS = -1, iB = -1; // номера соседних контрольных объёмов
	iE = neighbors_for_the_internal_node[E_SIDE][0][iP]; iN = neighbors_for_the_internal_node[N_SIDE][0][iP]; iT = neighbors_for_the_internal_node[T_SIDE][0][iP];
	iW = neighbors_for_the_internal_node[W_SIDE][0][iP]; iS = neighbors_for_the_internal_node[S_SIDE][0][iP]; iB = neighbors_for_the_internal_node[B_SIDE][0][iP];


	sl[iP].iE = iE; sl[iP].iN = iN; sl[iP].iT = iT;
	sl[iP].iS = iS; sl[iP].iW = iW; sl[iP].iB = iB;
	sl[iP].iP = iP;


	// 26.09.2016 Добавок для АЛИС сетки.
	int iE2 = -1, iN2 = -1, iT2 = -1, iW2 = -1, iS2 = -1, iB2 = -1; // номера соседних контрольных объёмов
	int iE3 = -1, iN3 = -1, iT3 = -1, iW3 = -1, iS3 = -1, iB3 = -1; // номера соседних контрольных объёмов
	int iE4 = -1, iN4 = -1, iT4 = -1, iW4 = -1, iS4 = -1, iB4 = -1; // номера соседних контрольных объёмов

																		// -1 если не используется и [0..maxelm+maxbound-1] если используется.
	if (b_on_adaptive_local_refinement_mesh) {
		iE2 = neighbors_for_the_internal_node[E_SIDE][1][iP]; iN2 = neighbors_for_the_internal_node[N_SIDE][1][iP]; iT2 = neighbors_for_the_internal_node[T_SIDE][1][iP];
		iW2 = neighbors_for_the_internal_node[W_SIDE][1][iP]; iS2 = neighbors_for_the_internal_node[S_SIDE][1][iP]; iB2 = neighbors_for_the_internal_node[B_SIDE][1][iP];
		iE3 = neighbors_for_the_internal_node[E_SIDE][2][iP]; iN3 = neighbors_for_the_internal_node[N_SIDE][2][iP]; iT3 = neighbors_for_the_internal_node[T_SIDE][2][iP];
		iW3 = neighbors_for_the_internal_node[W_SIDE][2][iP]; iS3 = neighbors_for_the_internal_node[S_SIDE][2][iP]; iB3 = neighbors_for_the_internal_node[B_SIDE][2][iP];
		iE4 = neighbors_for_the_internal_node[E_SIDE][3][iP]; iN4 = neighbors_for_the_internal_node[N_SIDE][3][iP]; iT4 = neighbors_for_the_internal_node[T_SIDE][3][iP];
		iW4 = neighbors_for_the_internal_node[W_SIDE][3][iP]; iS4 = neighbors_for_the_internal_node[S_SIDE][3][iP]; iB4 = neighbors_for_the_internal_node[B_SIDE][3][iP];
	}

	sl[iP].iE2 = iE2; sl[iP].iN2 = iN2; sl[iP].iT2 = iT2;
	sl[iP].iS2 = iS2; sl[iP].iW2 = iW2; sl[iP].iB2 = iB2;

	sl[iP].iE3 = iE3; sl[iP].iN3 = iN3; sl[iP].iT3 = iT3;
	sl[iP].iS3 = iS3; sl[iP].iW3 = iW3; sl[iP].iB3 = iB3;

	sl[iP].iE4 = iE4; sl[iP].iN4 = iN4; sl[iP].iT4 = iT4;
	sl[iP].iS4 = iS4; sl[iP].iW4 = iW4; sl[iP].iB4 = iB4;

	sl[iP].b = 0.0;

	// Инициализирующее обнуление.
	sl[iP].ae = 0.0;
	sl[iP].aw = 0.0;
	sl[iP].an = 0.0;
	sl[iP].as = 0.0;
	sl[iP].at = 0.0;
	sl[iP].ab = 0.0;

	sl[iP].ae2 = 0.0;
	sl[iP].aw2 = 0.0;
	sl[iP].an2 = 0.0;
	sl[iP].as2 = 0.0;
	sl[iP].at2 = 0.0;
	sl[iP].ab2 = 0.0;

	sl[iP].ae3 = 0.0;
	sl[iP].aw3 = 0.0;
	sl[iP].an3 = 0.0;
	sl[iP].as3 = 0.0;
	sl[iP].at3 = 0.0;
	sl[iP].ab3 = 0.0;

	sl[iP].ae4 = 0.0;
	sl[iP].aw4 = 0.0;
	sl[iP].an4 = 0.0;
	sl[iP].as4 = 0.0;
	sl[iP].at4 = 0.0;
	sl[iP].ab4 = 0.0;

	// Признак присутствия связи.
	// От булевых флагов можно избавиться в целях экономии памяти ЭВМ.
	sl[iP].bE2 = false; sl[iP].bW2 = false; sl[iP].bS2 = false;
	sl[iP].bN2 = false; sl[iP].bB2 = false; sl[iP].bT2 = false;

	sl[iP].bE3 = false; sl[iP].bW3 = false; sl[iP].bS3 = false;
	sl[iP].bN3 = false; sl[iP].bB3 = false; sl[iP].bT3 = false;

	sl[iP].bE4 = false; sl[iP].bW4 = false; sl[iP].bS4 = false;
	sl[iP].bN4 = false; sl[iP].bB4 = false; sl[iP].bT4 = false;

	if (b_on_adaptive_local_refinement_mesh) {
		if (iE2 > -1) sl[iP].bE2 = true;
		if (iW2 > -1) sl[iP].bW2 = true;
		if (iN2 > -1) sl[iP].bN2 = true;
		if (iS2 > -1) sl[iP].bS2 = true;
		if (iT2 > -1) sl[iP].bT2 = true;
		if (iB2 > -1) sl[iP].bB2 = true;

		if (iE3 > -1) sl[iP].bE3 = true;
		if (iW3 > -1) sl[iP].bW3 = true;
		if (iN3 > -1) sl[iP].bN3 = true;
		if (iS3 > -1) sl[iP].bS3 = true;
		if (iT3 > -1) sl[iP].bT3 = true;
		if (iB3 > -1) sl[iP].bB3 = true;

		if (iE4 > -1) sl[iP].bE4 = true;
		if (iW4 > -1) sl[iP].bW4 = true;
		if (iN4 > -1) sl[iP].bN4 = true;
		if (iS4 > -1) sl[iP].bS4 = true;
		if (iT4 > -1) sl[iP].bT4 = true;
		if (iB4 > -1) sl[iP].bB4 = true;
	}

	// Внутренний КО.	

	// Если с одной из сторон стоит граница расчётной области
	// то соответствующая переменная равна true
	bool bE = false, bN = false, bT = false, bW = false, bS = false, bB = false;


	if (iE >= maxelm) bE = true;
	if (iN >= maxelm) bN = true;
	if (iT >= maxelm) bT = true;
	if (iW >= maxelm) bW = true;
	if (iS >= maxelm) bS = true;
	if (iB >= maxelm) bB = true;

	bool bE2 = false, bN2 = false, bT2 = false, bW2 = false, bS2 = false, bB2 = false;
	bool bE3 = false, bN3 = false, bT3 = false, bW3 = false, bS3 = false, bB3 = false;
	bool bE4 = false, bN4 = false, bT4 = false, bW4 = false, bS4 = false, bB4 = false;

	if (b_on_adaptive_local_refinement_mesh) {
		if (iE2 >= maxelm) bE2 = true;
		if (iN2 >= maxelm) bN2 = true;
		if (iT2 >= maxelm) bT2 = true;
		if (iW2 >= maxelm) bW2 = true;
		if (iS2 >= maxelm) bS2 = true;
		if (iB2 >= maxelm) bB2 = true;

		if (iE3 >= maxelm) bE3 = true;
		if (iN3 >= maxelm) bN3 = true;
		if (iT3 >= maxelm) bT3 = true;
		if (iW3 >= maxelm) bW3 = true;
		if (iS3 >= maxelm) bS3 = true;
		if (iB3 >= maxelm) bB3 = true;

		if (iE4 >= maxelm) bE4 = true;
		if (iN4 >= maxelm) bN4 = true;
		if (iT4 >= maxelm) bT4 = true;
		if (iW4 >= maxelm) bW4 = true;
		if (iS4 >= maxelm) bS4 = true;
		if (iB4 >= maxelm) bB4 = true;
	}

	/*
	if (iP==25) {
	#if doubleintprecision == 1
	printf("bE=%lld bN=%lld bT=%lld bW=%lld bS=%lld bB=%lld\n",bE,bN,bT,bW,bS,bB);
	#else
	printf("bE=%d bN=%d bT=%d bW=%d bS=%d bB=%d\n",bE,bN,bT,bW,bS,bB);
	#endif

	getchar();
	}*/

	// Разрыв связи с источником тепла в воздухе:
	bool bsE = false, bsN = false, bsT = false, bsW = false, bsS = false, bsB = false;
	bool bsE1 = false, bsN1 = false, bsT1 = false, bsW1 = false, bsS1 = false, bsB1 = false;
	// Если есть жидкие зоны и если 
	// iP принадлежит жидкой зоне и граничит с источником тепла внутри расчётной
	// области вдали от её границ, то тогда такую связь требуется порвать.
	// Случай когда источник тепла окружён двумя SOLID зонами не предусмотрен. 
	// Еще источник тепла может находится на границе расчётной области и граничить с жидкостью,
	// тогда такую связь разрывать не следует.
	// Для проверки выполнения заведём переменную 
	//bool binternalfindsituation = false;
	// здесь обрабатывается случай строго внутреннего источника тепла.
	/*
	if ((flow_interior>0)&&(ptr[1][iP]>-1)) {
	// Это означает просто что iP fluid объём.
	if (bE) {
	// граничит с источником тепла
	//if (border_neighbor[iE-maxelm].MCB<ls) bsE=true;
	// именно внутренний источник тепла между жидкостью
	// и твёрдым телом. Только в этом случае разрывается связь
	// с источником со стороны жидкости, в остальных случаях
	// если источник, например, лежит на границе расчётной области
	// и омывается жидкостью связь не прерывается. Это важно.
	if (binternalsource[iE-maxelm]) {
	bsE=true;
	//binternalfindsituation=true;
	}
	}
	if (bN) {
	//if (border_neighbor[iN-maxelm].MCB<ls) bsN=true;
	if (binternalsource[iN-maxelm]) {
	bsN=true;
	//binternalfindsituation=true;
	}
	}
	if (bT) {
	//if (border_neighbor[iT-maxelm].MCB<ls) bsT=true;
	if (binternalsource[iT-maxelm]) {
	bsT=true;
	//binternalfindsituation=true;
	}
	}
	if (bW) {
	// граничит с источником тепла
	//if (border_neighbor[iW-maxelm].MCB<ls) bsW=true;
	if (binternalsource[iW-maxelm]) {
	bsW=true;
	//binternalfindsituation=true;
	}
	}
	if (bS) {
	//if (border_neighbor[iS-maxelm].MCB<ls) bsS=true;
	if (binternalsource[iS-maxelm]) {
	bsS=true;
	//binternalfindsituation=true;
	}
	}
	if (bB) {
	//if (border_neighbor[iB-maxelm].MCB<ls) bsB=true;
	if (binternalsource[iB-maxelm]) {
	bsB=true;
	//binternalfindsituation=true;
	}
	}
	}
	*/
	//else
	/*{
	// 3 мая новая логика.
	// мы не рвём никаких внутренних связей в матрице.
	// Если мы на грани встречаем источник тепла то мы один раз (благодаря source2Dproblem)
	// выделяем мощность в объеме в ячейке примыкающей к источнику тепла.



	// Если мы идентифицировали внутренний источник тепла то мы рвём одну из связей
	// вне зависимости она solid-solid или solid-fluid.
	if (bE) {
	// граничит с источником тепла
	//if (border_neighbor[iE-maxelm].MCB<ls) bsE=true;
	// именно внутренний источник тепла между жидкостью
	// и твёрдым телом. Только в этом случае разрывается связь
	// с источником со стороны жидкости, в остальных случаях
	// если источник, например, лежит на границе расчётной области
	// и омывается жидкостью связь не прерывается. Это важно.
	if (binternalsource[iE - maxelm]) {
	if (sourse2Dproblem[iE - maxelm]) {
	//bsE = true;
	//binternalfindsituation = true;
	}
	sourse2Dproblem[iE - maxelm] = !sourse2Dproblem[iE - maxelm];
	}
	}
	if (bN) {
	//if (border_neighbor[iN-maxelm].MCB<ls) bsN=true;
	if (binternalsource[iN - maxelm]) {
	if (sourse2Dproblem[iN - maxelm]) {
	//bsN = true;
	//binternalfindsituation = true;
	}
	sourse2Dproblem[iN - maxelm] = !sourse2Dproblem[iN - maxelm];
	}
	}
	if (bT) {
	//if (border_neighbor[iT-maxelm].MCB<ls) bsT=true;
	if (binternalsource[iT - maxelm]) {
	if (sourse2Dproblem[iT - maxelm]) {
	//bsT = true;
	//binternalfindsituation = true;
	}
	}
	sourse2Dproblem[iT - maxelm] = !sourse2Dproblem[iT - maxelm];
	}
	if (bW) {
	// граничит с источником тепла
	//if (border_neighbor[iW-maxelm].MCB<ls) bsW=true;
	if (binternalsource[iW - maxelm]) {
	if (sourse2Dproblem[iW - maxelm]) {
	//bsW = true;
	//binternalfindsituation = true;
	}
	}
	sourse2Dproblem[iW - maxelm] = !sourse2Dproblem[iW - maxelm];
	}
	if (bS) {
	//if (border_neighbor[iS-maxelm].MCB<ls) bsS=true;
	if (binternalsource[iS - maxelm]) {
	if (sourse2Dproblem[iS - maxelm]) {
	//bsS = true;
	//binternalfindsituation = true;
	}
	}
	sourse2Dproblem[iS - maxelm] = !sourse2Dproblem[iS - maxelm];
	}
	if (bB) {
	//if (border_neighbor[iB-maxelm].MCB<ls) bsB=true;
	if (binternalsource[iB - maxelm]) {
	if (sourse2Dproblem[iB - maxelm]) {
	//bsB = true;
	//binternalfindsituation = true;
	}
	}
	sourse2Dproblem[iB - maxelm] = !sourse2Dproblem[iB - maxelm];
	}
	}
	//*/



	//bsE=false; bsN=false; bsT=false; bsW=false; bsS=false; bsB=false; // сброс обрыва связи !!!

	// debug.
	/*if (binternalfindsituation) {
	printf("find internal source...\n");
	getchar();
	}*/

	/*
	if ((iP>=25)&&(iP<=29)) {
	#if doubleintprecision == 1
	printf("bsE=%lld bsN=%lld bsT=%lld bsW=%lld bsS=%lld bsB=%lld\n",bsE,bsN,bsT,bsW,bsS,bsB);
	#else
	printf("bsE=%d bsN=%d bsT=%d bsW=%d bsS=%d bsB=%d\n",bsE,bsN,bsT,bsW,bsS,bsB);
	#endif

	getchar();
	}*/

	// вычисление размеров текущего контрольного объёма:
	doublereal dx = 0.0, dy = 0.0, dz = 0.0;// объём текущего контрольного объёма
	volume3D(iP, nvtx, pa, dx, dy, dz);
	dx = fabs(dx);
	dy = fabs(dy);
	dz = fabs(dz);


	TOCHKA pointP0;
	center_cord3D(iP, nvtx, pa, pointP0, 100);


	// для маркировки внутреннего тепловыделения надо: iP булев индикатор, номер источника MCB и всё.

	doublereal Sc2D = 0.0;
	{
		if (bE) {
			if (border_neighbor[iE - maxelm].MCB < ls) {

				// Разрываем связь с плоской гранью,
				// делаём обработку как будто мы строго внутренность обрабатываем.
				if ((border_neighbor[iE - maxelm].iI1>-1) && (border_neighbor[iE - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iE - maxelm].iI1] - prop[LAM][border_neighbor[iE - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iE - maxelm]) {
							Sc2D = ((dy*dz / s[border_neighbor[iE - maxelm].MCB].square)*s[border_neighbor[iE - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iE - maxelm] = !sourse2Dproblem[iE - maxelm];
					}
					else {
						if (iP == border_neighbor[iE - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iE - maxelm].iI2]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE - maxelm].MCB].square)*s[border_neighbor[iE - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iE - maxelm] = !sourse2Dproblem[iE - maxelm];
							}
						}
						if (iP == border_neighbor[iE - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iE - maxelm].iI1]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE - maxelm].MCB].square)*s[border_neighbor[iE - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iE - maxelm] = !sourse2Dproblem[iE - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iE - maxelm].iI1) {
						iE = border_neighbor[iE - maxelm].iI2;
					}
					else {
						iE = border_neighbor[iE - maxelm].iI1;
					}
					sl[iP].iE = iE;
					bE = false;
				}
				else {
					// Этого случая никогда не будет, т.к.
					// сеточный генератор работает таким образом,
					// что источник тепла всегда лежит внутри 
					// расчётной области а не на её границе.
					// Проверено 11.07.2016.
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
					if (border_neighbor[iE - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iE - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** E \n");
					//getchar();
					system("PAUSE");
#endif
				}
				//bsE1 = true;

			}

		}
		if (bW) {
			if (border_neighbor[iW - maxelm].MCB < ls) {


				if ((border_neighbor[iW - maxelm].iI1>-1) && (border_neighbor[iW - maxelm].iI2>-1)) {


					if (fabs(prop[LAM][border_neighbor[iW - maxelm].iI1] - prop[LAM][border_neighbor[iW - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iW - maxelm]) {
							Sc2D = ((dy*dz / s[border_neighbor[iW - maxelm].MCB].square)*s[border_neighbor[iW - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iW - maxelm] = !sourse2Dproblem[iW - maxelm];
					}
					else {
						if (iP == border_neighbor[iW - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iW - maxelm].iI2]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW - maxelm].MCB].square)*s[border_neighbor[iW - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iW - maxelm] = !sourse2Dproblem[iW - maxelm];
							}
						}
						if (iP == border_neighbor[iW - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iW - maxelm].iI1]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW - maxelm].MCB].square)*s[border_neighbor[iW - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iW - maxelm] = !sourse2Dproblem[iW - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}


					if (iP == border_neighbor[iW - maxelm].iI1) {
						iW = border_neighbor[iW - maxelm].iI2;
					}
					else {
						iW = border_neighbor[iW - maxelm].iI1;
					}
					sl[iP].iW = iW;
					bW = false;
				}
				else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
					if (border_neighbor[iW - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iW - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** W\n");
					//getchar();
					system("PAUSE");
#endif
				}
				//bsW1 = true;
			}

		}
		if (bN) {
			if (border_neighbor[iN - maxelm].MCB < ls) {

				if ((border_neighbor[iN - maxelm].iI1>-1) && (border_neighbor[iN - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iN - maxelm].iI1] - prop[LAM][border_neighbor[iN - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iN - maxelm]) {
							Sc2D = ((dx*dz / s[border_neighbor[iN - maxelm].MCB].square)*s[border_neighbor[iN - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iN - maxelm] = !sourse2Dproblem[iN - maxelm];
					}
					else {
						if (iP == border_neighbor[iN - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iN - maxelm].iI2]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN - maxelm].MCB].square)*s[border_neighbor[iN - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iN - maxelm] = !sourse2Dproblem[iN - maxelm];
							}
						}
						if (iP == border_neighbor[iN - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iN - maxelm].iI1]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN - maxelm].MCB].square)*s[border_neighbor[iN - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iN - maxelm] = !sourse2Dproblem[iN - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iN - maxelm].iI1) {
						iN = border_neighbor[iN - maxelm].iI2;
					}
					else {
						iN = border_neighbor[iN - maxelm].iI1;
					}
					sl[iP].iN = iN;
					bN = false;
				}
				else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
					if (border_neighbor[iN - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iN - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** N\n");
					//getchar();
					system("PAUSE");
#endif
				}
				//bsN1 = true;
			}

		}
		if (bS) {
			if (border_neighbor[iS - maxelm].MCB < ls) {



				if ((border_neighbor[iS - maxelm].iI1>-1) && (border_neighbor[iS - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iS - maxelm].iI1] - prop[LAM][border_neighbor[iS - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iS - maxelm]) {
							Sc2D = ((dx*dz / s[border_neighbor[iS - maxelm].MCB].square)*s[border_neighbor[iS - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iS - maxelm] = !sourse2Dproblem[iS - maxelm];
					}
					else {
						if (iP == border_neighbor[iS - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iS - maxelm].iI2]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS - maxelm].MCB].square)*s[border_neighbor[iS - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iS - maxelm] = !sourse2Dproblem[iS - maxelm];
							}
						}
						if (iP == border_neighbor[iS - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iS - maxelm].iI1]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS - maxelm].MCB].square)*s[border_neighbor[iS - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iS - maxelm] = !sourse2Dproblem[iS - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}



					if (iP == border_neighbor[iS - maxelm].iI1) {
						iS = border_neighbor[iS - maxelm].iI2;
					}
					else {
						iS = border_neighbor[iS - maxelm].iI1;
					}
					sl[iP].iS = iS;
					bS = false;
				}
				else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
					if (border_neighbor[iS - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iS - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** S\n");
					//getchar();
					system("PAUSE");
#endif
				}
				//bsS1 = true;
			}

		}
		if (bT) {
			if (border_neighbor[iT - maxelm].MCB < ls) {




				if ((border_neighbor[iT - maxelm].iI1>-1) && (border_neighbor[iT - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iT - maxelm].iI1] - prop[LAM][border_neighbor[iT - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iT - maxelm]) {
							Sc2D = ((dx*dy / s[border_neighbor[iT - maxelm].MCB].square)*s[border_neighbor[iT - maxelm].MCB].power) / (dx*dy*dz);

						}
						sourse2Dproblem[iT - maxelm] = !sourse2Dproblem[iT - maxelm];
					}
					else {
						if (iP == border_neighbor[iT - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iT - maxelm].iI2]) {

								Sc2D = ((dx*dy / s[border_neighbor[iT - maxelm].MCB].square)*s[border_neighbor[iT - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iT - maxelm] = !sourse2Dproblem[iT - maxelm];
							}
						}
						if (iP == border_neighbor[iT - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iT - maxelm].iI1]) {
								Sc2D = ((dx*dy / s[border_neighbor[iT - maxelm].MCB].square)*s[border_neighbor[iT - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iT - maxelm] = !sourse2Dproblem[iT - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}


					if (iP == border_neighbor[iT - maxelm].iI1) {
						iT = border_neighbor[iT - maxelm].iI2;
					}
					else {
						iT = border_neighbor[iT - maxelm].iI1;
					}
					sl[iP].iT = iT;
					bT = false;
				}
				else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
					if (border_neighbor[iT - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iT - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** T\n");
					//getchar();
					system("PAUSE");
#endif
				}
				//bsT1 = true;
			}

		}
		if (bB) {
			if (border_neighbor[iB - maxelm].MCB < ls) {


				if ((border_neighbor[iB - maxelm].iI1>-1) && (border_neighbor[iB - maxelm].iI2>-1)) {

					if (fabs(prop[LAM][border_neighbor[iB - maxelm].iI1] - prop[LAM][border_neighbor[iB - maxelm].iI2]) < 1.0e-36) {
						if (sourse2Dproblem[iB - maxelm]) {
							Sc2D = ((dx*dy / s[border_neighbor[iB - maxelm].MCB].square)*s[border_neighbor[iB - maxelm].MCB].power) / (dx*dy*dz);
						}
						sourse2Dproblem[iB - maxelm] = !sourse2Dproblem[iB - maxelm];
					}
					else {
						if (iP == border_neighbor[iB - maxelm].iI1) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iB - maxelm].iI2]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB - maxelm].MCB].square)*s[border_neighbor[iB - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iB - maxelm] = !sourse2Dproblem[iB - maxelm];
							}
						}
						if (iP == border_neighbor[iB - maxelm].iI2) {
							if (prop[LAM][iP] < prop[LAM][border_neighbor[iB - maxelm].iI1]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB - maxelm].MCB].square)*s[border_neighbor[iB - maxelm].MCB].power) / (dx*dy*dz);
								sourse2Dproblem[iB - maxelm] = !sourse2Dproblem[iB - maxelm];
							}
						}
						// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
						// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
					}

					if (iP == border_neighbor[iB - maxelm].iI1) {
						iB = border_neighbor[iB - maxelm].iI2;
					}
					else {
						iB = border_neighbor[iB - maxelm].iI1;
					}
					sl[iP].iB = iB;
					bB = false;
				}
				else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
					if (border_neighbor[iB - maxelm].iI1 > -1) {
						printf("iI1\n");
					}
					if (border_neighbor[iB - maxelm].iI2 > -1) {
						printf("iI2\n");
					}
					printf("*** B\n");
					//getchar();
					system("PAUSE");
#endif
				}
				//bsB1 = true;
			}

		}

		if (b_on_adaptive_local_refinement_mesh) {

			if (bE2) {
				if (border_neighbor[iE2 - maxelm].MCB < ls) {

					// Разрываем связь с плоской гранью,
					// делаём обработку как будто мы строго внутренность обрабатываем.
					if ((border_neighbor[iE2 - maxelm].iI1>-1) && (border_neighbor[iE2 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iE2 - maxelm].iI1] - prop[LAM][border_neighbor[iE2 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iE2 - maxelm]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE2 - maxelm].MCB].square)*s[border_neighbor[iE2 - maxelm].MCB].power) / (dx*dy*dz);

							}
							sourse2Dproblem[iE2 - maxelm] = !sourse2Dproblem[iE2 - maxelm];
						}
						else {
							if (iP == border_neighbor[iE2 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iE2 - maxelm].iI2]) {
									Sc2D = ((dy*dz / s[border_neighbor[iE2 - maxelm].MCB].square)*s[border_neighbor[iE2 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iE2 - maxelm] = !sourse2Dproblem[iE2 - maxelm];
								}
							}
							if (iP == border_neighbor[iE2 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iE2 - maxelm].iI1]) {
									Sc2D = ((dy*dz / s[border_neighbor[iE2 - maxelm].MCB].square)*s[border_neighbor[iE2 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iE2 - maxelm] = !sourse2Dproblem[iE2 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}

						if (iP == border_neighbor[iE2 - maxelm].iI1) {
							iE2 = border_neighbor[iE2 - maxelm].iI2;
						}
						else {
							iE2 = border_neighbor[iE2 - maxelm].iI1;
						}
						sl[iP].iE2 = iE2;
						bE2 = false;
					}
					else {
						// Этого случая никогда не будет, т.к.
						// сеточный генератор работает таким образом,
						// что источник тепла всегда лежит внутри 
						// расчётной области а не на её границе.
						// Проверено 11.07.2016.
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iE2 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iE2 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** E \n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsE1 = true;

				}

			}
			if (bW2) {
				if (border_neighbor[iW2 - maxelm].MCB < ls) {


					if ((border_neighbor[iW2 - maxelm].iI1>-1) && (border_neighbor[iW2 - maxelm].iI2>-1)) {


						if (fabs(prop[LAM][border_neighbor[iW2 - maxelm].iI1] - prop[LAM][border_neighbor[iW2 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iW2 - maxelm]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW2 - maxelm].MCB].square)*s[border_neighbor[iW2 - maxelm].MCB].power) / (dx*dy*dz);
							}
							sourse2Dproblem[iW2 - maxelm] = !sourse2Dproblem[iW2 - maxelm];
						}
						else {
							if (iP == border_neighbor[iW2 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iW2 - maxelm].iI2]) {
									Sc2D = ((dy*dz / s[border_neighbor[iW2 - maxelm].MCB].square)*s[border_neighbor[iW2 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iW2 - maxelm] = !sourse2Dproblem[iW2 - maxelm];
								}
							}
							if (iP == border_neighbor[iW2 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iW2 - maxelm].iI1]) {
									Sc2D = ((dy*dz / s[border_neighbor[iW2 - maxelm].MCB].square)*s[border_neighbor[iW2 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iW2 - maxelm] = !sourse2Dproblem[iW2 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}


						if (iP == border_neighbor[iW2 - maxelm].iI1) {
							iW2 = border_neighbor[iW2 - maxelm].iI2;
						}
						else {
							iW2 = border_neighbor[iW2 - maxelm].iI1;
						}
						sl[iP].iW2 = iW2;
						bW2 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iW2 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iW2 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** W\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsW1 = true;
				}

			}
			if (bN2) {
				if (border_neighbor[iN2 - maxelm].MCB < ls) {

					if ((border_neighbor[iN2 - maxelm].iI1>-1) && (border_neighbor[iN2 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iN2 - maxelm].iI1] - prop[LAM][border_neighbor[iN2 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iN2 - maxelm]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN2 - maxelm].MCB].square)*s[border_neighbor[iN2 - maxelm].MCB].power) / (dx*dy*dz);

							}
							sourse2Dproblem[iN2 - maxelm] = !sourse2Dproblem[iN2 - maxelm];
						}
						else {
							if (iP == border_neighbor[iN2 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iN2 - maxelm].iI2]) {
									Sc2D = ((dx*dz / s[border_neighbor[iN2 - maxelm].MCB].square)*s[border_neighbor[iN2 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iN2 - maxelm] = !sourse2Dproblem[iN2 - maxelm];
								}
							}
							if (iP == border_neighbor[iN2 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iN2 - maxelm].iI1]) {
									Sc2D = ((dx*dz / s[border_neighbor[iN2 - maxelm].MCB].square)*s[border_neighbor[iN2 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iN2 - maxelm] = !sourse2Dproblem[iN2 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}

						if (iP == border_neighbor[iN2 - maxelm].iI1) {
							iN2 = border_neighbor[iN2 - maxelm].iI2;
						}
						else {
							iN2 = border_neighbor[iN2 - maxelm].iI1;
						}
						sl[iP].iN2 = iN2;
						bN2 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iN2 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iN2 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** N\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsN1 = true;
				}

			}
			if (bS2) {
				if (border_neighbor[iS2 - maxelm].MCB < ls) {



					if ((border_neighbor[iS2 - maxelm].iI1>-1) && (border_neighbor[iS2 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iS2 - maxelm].iI1] - prop[LAM][border_neighbor[iS2 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iS2 - maxelm]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS2 - maxelm].MCB].square)*s[border_neighbor[iS2 - maxelm].MCB].power) / (dx*dy*dz);
							}
							sourse2Dproblem[iS2 - maxelm] = !sourse2Dproblem[iS2 - maxelm];
						}
						else {
							if (iP == border_neighbor[iS2 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iS2 - maxelm].iI2]) {
									Sc2D = ((dx*dz / s[border_neighbor[iS2 - maxelm].MCB].square)*s[border_neighbor[iS2 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iS2 - maxelm] = !sourse2Dproblem[iS2 - maxelm];
								}
							}
							if (iP == border_neighbor[iS2 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iS2 - maxelm].iI1]) {
									Sc2D = ((dx*dz / s[border_neighbor[iS2 - maxelm].MCB].square)*s[border_neighbor[iS2 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iS2 - maxelm] = !sourse2Dproblem[iS2 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}



						if (iP == border_neighbor[iS2 - maxelm].iI1) {
							iS2 = border_neighbor[iS2 - maxelm].iI2;
						}
						else {
							iS2 = border_neighbor[iS2 - maxelm].iI1;
						}
						sl[iP].iS2 = iS2;
						bS2 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iS2 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iS2 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** S\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsS1 = true;
				}

			}
			if (bT2) {
				if (border_neighbor[iT2 - maxelm].MCB < ls) {




					if ((border_neighbor[iT2 - maxelm].iI1>-1) && (border_neighbor[iT2 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iT2 - maxelm].iI1] - prop[LAM][border_neighbor[iT2 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iT2 - maxelm]) {
								Sc2D = ((dx*dy / s[border_neighbor[iT2 - maxelm].MCB].square)*s[border_neighbor[iT2 - maxelm].MCB].power) / (dx*dy*dz);

							}
							sourse2Dproblem[iT2 - maxelm] = !sourse2Dproblem[iT2 - maxelm];
						}
						else {
							if (iP == border_neighbor[iT2 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iT2 - maxelm].iI2]) {

									Sc2D = ((dx*dy / s[border_neighbor[iT2 - maxelm].MCB].square)*s[border_neighbor[iT2 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iT2 - maxelm] = !sourse2Dproblem[iT2 - maxelm];
								}
							}
							if (iP == border_neighbor[iT2 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iT2 - maxelm].iI1]) {
									Sc2D = ((dx*dy / s[border_neighbor[iT2 - maxelm].MCB].square)*s[border_neighbor[iT2 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iT2 - maxelm] = !sourse2Dproblem[iT2 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}


						if (iP == border_neighbor[iT2 - maxelm].iI1) {
							iT2 = border_neighbor[iT2 - maxelm].iI2;
						}
						else {
							iT2 = border_neighbor[iT2 - maxelm].iI1;
						}
						sl[iP].iT2 = iT2;
						bT2 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iT2 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iT2 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** T\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsT1 = true;
				}

			}
			if (bB2) {
				if (border_neighbor[iB2 - maxelm].MCB < ls) {


					if ((border_neighbor[iB2 - maxelm].iI1>-1) && (border_neighbor[iB2 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iB2 - maxelm].iI1] - prop[LAM][border_neighbor[iB2 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iB2 - maxelm]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB2 - maxelm].MCB].square)*s[border_neighbor[iB2 - maxelm].MCB].power) / (dx*dy*dz);
							}
							sourse2Dproblem[iB2 - maxelm] = !sourse2Dproblem[iB2 - maxelm];
						}
						else {
							if (iP == border_neighbor[iB2 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iB2 - maxelm].iI2]) {
									Sc2D = ((dx*dy / s[border_neighbor[iB2 - maxelm].MCB].square)*s[border_neighbor[iB2 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iB2 - maxelm] = !sourse2Dproblem[iB2 - maxelm];
								}
							}
							if (iP == border_neighbor[iB2 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iB2 - maxelm].iI1]) {
									Sc2D = ((dx*dy / s[border_neighbor[iB2 - maxelm].MCB].square)*s[border_neighbor[iB2 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iB2 - maxelm] = !sourse2Dproblem[iB2 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}

						if (iP == border_neighbor[iB2 - maxelm].iI1) {
							iB2 = border_neighbor[iB2 - maxelm].iI2;
						}
						else {
							iB2 = border_neighbor[iB2 - maxelm].iI1;
						}
						sl[iP].iB2 = iB2;
						bB2 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iB2 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iB2 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** B\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsB1 = true;
				}

			}

			if (bE3) {
				if (border_neighbor[iE3 - maxelm].MCB < ls) {

					// Разрываем связь с плоской гранью,
					// делаём обработку как будто мы строго внутренность обрабатываем.
					if ((border_neighbor[iE3 - maxelm].iI1>-1) && (border_neighbor[iE3 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iE3 - maxelm].iI1] - prop[LAM][border_neighbor[iE3 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iE3 - maxelm]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE3 - maxelm].MCB].square)*s[border_neighbor[iE3 - maxelm].MCB].power) / (dx*dy*dz);

							}
							sourse2Dproblem[iE3 - maxelm] = !sourse2Dproblem[iE3 - maxelm];
						}
						else {
							if (iP == border_neighbor[iE3 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iE3 - maxelm].iI2]) {
									Sc2D = ((dy*dz / s[border_neighbor[iE3 - maxelm].MCB].square)*s[border_neighbor[iE3 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iE3 - maxelm] = !sourse2Dproblem[iE3 - maxelm];
								}
							}
							if (iP == border_neighbor[iE3 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iE3 - maxelm].iI1]) {
									Sc2D = ((dy*dz / s[border_neighbor[iE3 - maxelm].MCB].square)*s[border_neighbor[iE3 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iE3 - maxelm] = !sourse2Dproblem[iE3 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}

						if (iP == border_neighbor[iE3 - maxelm].iI1) {
							iE3 = border_neighbor[iE3 - maxelm].iI2;
						}
						else {
							iE3 = border_neighbor[iE3 - maxelm].iI1;
						}
						sl[iP].iE3 = iE3;
						bE3 = false;
					}
					else {
						// Этого случая никогда не будет, т.к.
						// сеточный генератор работает таким образом,
						// что источник тепла всегда лежит внутри 
						// расчётной области а не на её границе.
						// Проверено 11.07.2016.
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iE3 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iE3 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** E \n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsE1 = true;

				}

			}
			if (bW3) {
				if (border_neighbor[iW3 - maxelm].MCB < ls) {


					if ((border_neighbor[iW3 - maxelm].iI1>-1) && (border_neighbor[iW3 - maxelm].iI2>-1)) {


						if (fabs(prop[LAM][border_neighbor[iW3 - maxelm].iI1] - prop[LAM][border_neighbor[iW3 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iW3 - maxelm]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW3 - maxelm].MCB].square)*s[border_neighbor[iW3 - maxelm].MCB].power) / (dx*dy*dz);
							}
							sourse2Dproblem[iW3 - maxelm] = !sourse2Dproblem[iW3 - maxelm];
						}
						else {
							if (iP == border_neighbor[iW3 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iW3 - maxelm].iI2]) {
									Sc2D = ((dy*dz / s[border_neighbor[iW3 - maxelm].MCB].square)*s[border_neighbor[iW3 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iW3 - maxelm] = !sourse2Dproblem[iW3 - maxelm];
								}
							}
							if (iP == border_neighbor[iW3 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iW3 - maxelm].iI1]) {
									Sc2D = ((dy*dz / s[border_neighbor[iW3 - maxelm].MCB].square)*s[border_neighbor[iW3 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iW3 - maxelm] = !sourse2Dproblem[iW3 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}


						if (iP == border_neighbor[iW3 - maxelm].iI1) {
							iW3 = border_neighbor[iW3 - maxelm].iI2;
						}
						else {
							iW3 = border_neighbor[iW3 - maxelm].iI1;
						}
						sl[iP].iW3 = iW3;
						bW3 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iW3 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iW3 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** W\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsW1 = true;
				}

			}
			if (bN3) {
				if (border_neighbor[iN3 - maxelm].MCB < ls) {

					if ((border_neighbor[iN3 - maxelm].iI1>-1) && (border_neighbor[iN3 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iN3 - maxelm].iI1] - prop[LAM][border_neighbor[iN3 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iN3 - maxelm]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN3 - maxelm].MCB].square)*s[border_neighbor[iN3 - maxelm].MCB].power) / (dx*dy*dz);

							}
							sourse2Dproblem[iN3 - maxelm] = !sourse2Dproblem[iN3 - maxelm];
						}
						else {
							if (iP == border_neighbor[iN3 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iN3 - maxelm].iI2]) {
									Sc2D = ((dx*dz / s[border_neighbor[iN3 - maxelm].MCB].square)*s[border_neighbor[iN3 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iN3 - maxelm] = !sourse2Dproblem[iN3 - maxelm];
								}
							}
							if (iP == border_neighbor[iN3 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iN3 - maxelm].iI1]) {
									Sc2D = ((dx*dz / s[border_neighbor[iN3 - maxelm].MCB].square)*s[border_neighbor[iN3 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iN3 - maxelm] = !sourse2Dproblem[iN3 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}

						if (iP == border_neighbor[iN3 - maxelm].iI1) {
							iN3 = border_neighbor[iN3 - maxelm].iI2;
						}
						else {
							iN3 = border_neighbor[iN3 - maxelm].iI1;
						}
						sl[iP].iN3 = iN3;
						bN3 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iN3 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iN3 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** N\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsN1 = true;
				}

			}
			if (bS3) {
				if (border_neighbor[iS3 - maxelm].MCB < ls) {



					if ((border_neighbor[iS3 - maxelm].iI1>-1) && (border_neighbor[iS3 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iS3 - maxelm].iI1] - prop[LAM][border_neighbor[iS3 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iS3 - maxelm]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS3 - maxelm].MCB].square)*s[border_neighbor[iS3 - maxelm].MCB].power) / (dx*dy*dz);
							}
							sourse2Dproblem[iS3 - maxelm] = !sourse2Dproblem[iS3 - maxelm];
						}
						else {
							if (iP == border_neighbor[iS3 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iS3 - maxelm].iI2]) {
									Sc2D = ((dx*dz / s[border_neighbor[iS3 - maxelm].MCB].square)*s[border_neighbor[iS3 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iS3 - maxelm] = !sourse2Dproblem[iS3 - maxelm];
								}
							}
							if (iP == border_neighbor[iS3 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iS3 - maxelm].iI1]) {
									Sc2D = ((dx*dz / s[border_neighbor[iS3 - maxelm].MCB].square)*s[border_neighbor[iS3 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iS3 - maxelm] = !sourse2Dproblem[iS3 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}



						if (iP == border_neighbor[iS3 - maxelm].iI1) {
							iS3 = border_neighbor[iS3 - maxelm].iI2;
						}
						else {
							iS3 = border_neighbor[iS3 - maxelm].iI1;
						}
						sl[iP].iS3 = iS3;
						bS3 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iS3 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iS3 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** S\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsS1 = true;
				}

			}
			if (bT3) {
				if (border_neighbor[iT3 - maxelm].MCB < ls) {




					if ((border_neighbor[iT3 - maxelm].iI1>-1) && (border_neighbor[iT3 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iT3 - maxelm].iI1] - prop[LAM][border_neighbor[iT3 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iT3 - maxelm]) {
								Sc2D = ((dx*dy / s[border_neighbor[iT3 - maxelm].MCB].square)*s[border_neighbor[iT3 - maxelm].MCB].power) / (dx*dy*dz);

							}
							sourse2Dproblem[iT3 - maxelm] = !sourse2Dproblem[iT3 - maxelm];
						}
						else {
							if (iP == border_neighbor[iT3 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iT3 - maxelm].iI2]) {

									Sc2D = ((dx*dy / s[border_neighbor[iT3 - maxelm].MCB].square)*s[border_neighbor[iT3 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iT3 - maxelm] = !sourse2Dproblem[iT3 - maxelm];
								}
							}
							if (iP == border_neighbor[iT3 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iT3 - maxelm].iI1]) {
									Sc2D = ((dx*dy / s[border_neighbor[iT3 - maxelm].MCB].square)*s[border_neighbor[iT3 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iT3 - maxelm] = !sourse2Dproblem[iT3 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}


						if (iP == border_neighbor[iT3 - maxelm].iI1) {
							iT3 = border_neighbor[iT3 - maxelm].iI2;
						}
						else {
							iT3 = border_neighbor[iT3 - maxelm].iI1;
						}
						sl[iP].iT3 = iT3;
						bT3 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iT3 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iT3 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** T\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsT1 = true;
				}

			}
			if (bB3) {
				if (border_neighbor[iB3 - maxelm].MCB < ls) {


					if ((border_neighbor[iB3 - maxelm].iI1>-1) && (border_neighbor[iB3 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iB3 - maxelm].iI1] - prop[LAM][border_neighbor[iB3 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iB3 - maxelm]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB3 - maxelm].MCB].square)*s[border_neighbor[iB3 - maxelm].MCB].power) / (dx*dy*dz);
							}
							sourse2Dproblem[iB3 - maxelm] = !sourse2Dproblem[iB3 - maxelm];
						}
						else {
							if (iP == border_neighbor[iB3 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iB3 - maxelm].iI2]) {
									Sc2D = ((dx*dy / s[border_neighbor[iB3 - maxelm].MCB].square)*s[border_neighbor[iB3 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iB3 - maxelm] = !sourse2Dproblem[iB3 - maxelm];
								}
							}
							if (iP == border_neighbor[iB3 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iB3 - maxelm].iI1]) {
									Sc2D = ((dx*dy / s[border_neighbor[iB3 - maxelm].MCB].square)*s[border_neighbor[iB3 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iB3 - maxelm] = !sourse2Dproblem[iB3 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}

						if (iP == border_neighbor[iB3 - maxelm].iI1) {
							iB3 = border_neighbor[iB3 - maxelm].iI2;
						}
						else {
							iB3 = border_neighbor[iB3 - maxelm].iI1;
						}
						sl[iP].iB3 = iB3;
						bB3 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iB3 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iB3 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** B\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsB1 = true;
				}

			}

			if (bE4) {
				if (border_neighbor[iE4 - maxelm].MCB < ls) {

					// Разрываем связь с плоской гранью,
					// делаём обработку как будто мы строго внутренность обрабатываем.
					if ((border_neighbor[iE4 - maxelm].iI1>-1) && (border_neighbor[iE4 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iE4 - maxelm].iI1] - prop[LAM][border_neighbor[iE4 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iE4 - maxelm]) {
								Sc2D = ((dy*dz / s[border_neighbor[iE4 - maxelm].MCB].square)*s[border_neighbor[iE4 - maxelm].MCB].power) / (dx*dy*dz);

							}
							sourse2Dproblem[iE4 - maxelm] = !sourse2Dproblem[iE4 - maxelm];
						}
						else {
							if (iP == border_neighbor[iE4 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iE4 - maxelm].iI2]) {
									Sc2D = ((dy*dz / s[border_neighbor[iE4 - maxelm].MCB].square)*s[border_neighbor[iE4 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iE4 - maxelm] = !sourse2Dproblem[iE4 - maxelm];
								}
							}
							if (iP == border_neighbor[iE4 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iE4 - maxelm].iI1]) {
									Sc2D = ((dy*dz / s[border_neighbor[iE4 - maxelm].MCB].square)*s[border_neighbor[iE4 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iE4 - maxelm] = !sourse2Dproblem[iE4 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}

						if (iP == border_neighbor[iE4 - maxelm].iI1) {
							iE4 = border_neighbor[iE4 - maxelm].iI2;
						}
						else {
							iE4 = border_neighbor[iE4 - maxelm].iI1;
						}
						sl[iP].iE4 = iE4;
						bE4 = false;
					}
					else {
						// Этого случая никогда не будет, т.к.
						// сеточный генератор работает таким образом,
						// что источник тепла всегда лежит внутри 
						// расчётной области а не на её границе.
						// Проверено 11.07.2016.
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iE4 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iE4 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** E \n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsE1 = true;

				}

			}
			if (bW4) {
				if (border_neighbor[iW4 - maxelm].MCB < ls) {


					if ((border_neighbor[iW4 - maxelm].iI1>-1) && (border_neighbor[iW4 - maxelm].iI2>-1)) {


						if (fabs(prop[LAM][border_neighbor[iW4 - maxelm].iI1] - prop[LAM][border_neighbor[iW4 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iW4 - maxelm]) {
								Sc2D = ((dy*dz / s[border_neighbor[iW4 - maxelm].MCB].square)*s[border_neighbor[iW4 - maxelm].MCB].power) / (dx*dy*dz);
							}
							sourse2Dproblem[iW4 - maxelm] = !sourse2Dproblem[iW4 - maxelm];
						}
						else {
							if (iP == border_neighbor[iW4 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iW4 - maxelm].iI2]) {
									Sc2D = ((dy*dz / s[border_neighbor[iW4 - maxelm].MCB].square)*s[border_neighbor[iW4 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iW4 - maxelm] = !sourse2Dproblem[iW4 - maxelm];
								}
							}
							if (iP == border_neighbor[iW4 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iW4 - maxelm].iI1]) {
									Sc2D = ((dy*dz / s[border_neighbor[iW4 - maxelm].MCB].square)*s[border_neighbor[iW4 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iW4 - maxelm] = !sourse2Dproblem[iW4 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}


						if (iP == border_neighbor[iW4 - maxelm].iI1) {
							iW4 = border_neighbor[iW4 - maxelm].iI2;
						}
						else {
							iW4 = border_neighbor[iW4 - maxelm].iI1;
						}
						sl[iP].iW4 = iW4;
						bW4 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iW4 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iW4 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** W\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsW1 = true;
				}

			}
			if (bN4) {
				if (border_neighbor[iN4 - maxelm].MCB < ls) {

					if ((border_neighbor[iN4 - maxelm].iI1>-1) && (border_neighbor[iN4 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iN4 - maxelm].iI1] - prop[LAM][border_neighbor[iN4 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iN4 - maxelm]) {
								Sc2D = ((dx*dz / s[border_neighbor[iN4 - maxelm].MCB].square)*s[border_neighbor[iN4 - maxelm].MCB].power) / (dx*dy*dz);

							}
							sourse2Dproblem[iN4 - maxelm] = !sourse2Dproblem[iN4 - maxelm];
						}
						else {
							if (iP == border_neighbor[iN4 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iN4 - maxelm].iI2]) {
									Sc2D = ((dx*dz / s[border_neighbor[iN4 - maxelm].MCB].square)*s[border_neighbor[iN4 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iN4 - maxelm] = !sourse2Dproblem[iN4 - maxelm];
								}
							}
							if (iP == border_neighbor[iN4 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iN4 - maxelm].iI1]) {
									Sc2D = ((dx*dz / s[border_neighbor[iN4 - maxelm].MCB].square)*s[border_neighbor[iN4 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iN4 - maxelm] = !sourse2Dproblem[iN4 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}

						if (iP == border_neighbor[iN4 - maxelm].iI1) {
							iN4 = border_neighbor[iN4 - maxelm].iI2;
						}
						else {
							iN4 = border_neighbor[iN4 - maxelm].iI1;
						}
						sl[iP].iN4 = iN4;
						bN4 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iN4 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iN4 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** N\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsN1 = true;
				}

			}
			if (bS4) {
				if (border_neighbor[iS4 - maxelm].MCB < ls) {



					if ((border_neighbor[iS4 - maxelm].iI1>-1) && (border_neighbor[iS4 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iS4 - maxelm].iI1] - prop[LAM][border_neighbor[iS4 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iS4 - maxelm]) {
								Sc2D = ((dx*dz / s[border_neighbor[iS4 - maxelm].MCB].square)*s[border_neighbor[iS4 - maxelm].MCB].power) / (dx*dy*dz);
							}
							sourse2Dproblem[iS4 - maxelm] = !sourse2Dproblem[iS4 - maxelm];
						}
						else {
							if (iP == border_neighbor[iS4 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iS4 - maxelm].iI2]) {
									Sc2D = ((dx*dz / s[border_neighbor[iS4 - maxelm].MCB].square)*s[border_neighbor[iS4 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iS4 - maxelm] = !sourse2Dproblem[iS4 - maxelm];
								}
							}
							if (iP == border_neighbor[iS4 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iS4 - maxelm].iI1]) {
									Sc2D = ((dx*dz / s[border_neighbor[iS4 - maxelm].MCB].square)*s[border_neighbor[iS4 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iS4 - maxelm] = !sourse2Dproblem[iS4 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}



						if (iP == border_neighbor[iS4 - maxelm].iI1) {
							iS4 = border_neighbor[iS4 - maxelm].iI2;
						}
						else {
							iS4 = border_neighbor[iS4 - maxelm].iI1;
						}
						sl[iP].iS4 = iS4;
						bS4 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iS4 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iS4 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** S\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsS1 = true;
				}

			}
			if (bT4) {
				if (border_neighbor[iT4 - maxelm].MCB < ls) {




					if ((border_neighbor[iT4 - maxelm].iI1>-1) && (border_neighbor[iT4 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iT4 - maxelm].iI1] - prop[LAM][border_neighbor[iT4 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iT4 - maxelm]) {
								Sc2D = ((dx*dy / s[border_neighbor[iT4 - maxelm].MCB].square)*s[border_neighbor[iT4 - maxelm].MCB].power) / (dx*dy*dz);

							}
							sourse2Dproblem[iT4 - maxelm] = !sourse2Dproblem[iT4 - maxelm];
						}
						else {
							if (iP == border_neighbor[iT4 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iT4 - maxelm].iI2]) {

									Sc2D = ((dx*dy / s[border_neighbor[iT4 - maxelm].MCB].square)*s[border_neighbor[iT4 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iT4 - maxelm] = !sourse2Dproblem[iT4 - maxelm];
								}
							}
							if (iP == border_neighbor[iT4 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iT4 - maxelm].iI1]) {
									Sc2D = ((dx*dy / s[border_neighbor[iT4 - maxelm].MCB].square)*s[border_neighbor[iT4 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iT4 - maxelm] = !sourse2Dproblem[iT4 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}


						if (iP == border_neighbor[iT4 - maxelm].iI1) {
							iT4 = border_neighbor[iT4 - maxelm].iI2;
						}
						else {
							iT4 = border_neighbor[iT4 - maxelm].iI1;
						}
						sl[iP].iT4 = iT4;
						bT4 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iT4 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iT4 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** T\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsT1 = true;
				}

			}
			if (bB4) {
				if (border_neighbor[iB4 - maxelm].MCB < ls) {


					if ((border_neighbor[iB4 - maxelm].iI1>-1) && (border_neighbor[iB4 - maxelm].iI2>-1)) {

						if (fabs(prop[LAM][border_neighbor[iB4 - maxelm].iI1] - prop[LAM][border_neighbor[iB4 - maxelm].iI2]) < 1.0e-36) {
							if (sourse2Dproblem[iB4 - maxelm]) {
								Sc2D = ((dx*dy / s[border_neighbor[iB4 - maxelm].MCB].square)*s[border_neighbor[iB4 - maxelm].MCB].power) / (dx*dy*dz);
							}
							sourse2Dproblem[iB4 - maxelm] = !sourse2Dproblem[iB4 - maxelm];
						}
						else {
							if (iP == border_neighbor[iB4 - maxelm].iI1) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iB4 - maxelm].iI2]) {
									Sc2D = ((dx*dy / s[border_neighbor[iB4 - maxelm].MCB].square)*s[border_neighbor[iB4 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iB4 - maxelm] = !sourse2Dproblem[iB4 - maxelm];
								}
							}
							if (iP == border_neighbor[iB4 - maxelm].iI2) {
								if (prop[LAM][iP] < prop[LAM][border_neighbor[iB4 - maxelm].iI1]) {
									Sc2D = ((dx*dy / s[border_neighbor[iB4 - maxelm].MCB].square)*s[border_neighbor[iB4 - maxelm].MCB].power) / (dx*dy*dz);
									sourse2Dproblem[iB4 - maxelm] = !sourse2Dproblem[iB4 - maxelm];
								}
							}
							// Иначе мы имеем ячейку с очень низкой теплопроводностью и нам нужно ждать когда iP придёт
							// в ходе сканирования в соседнюю ячейку с большой теплопроводностью.
						}

						if (iP == border_neighbor[iB4 - maxelm].iI1) {
							iB4 = border_neighbor[iB4 - maxelm].iI2;
						}
						else {
							iB4 = border_neighbor[iB4 - maxelm].iI1;
						}
						sl[iP].iB4 = iB4;
						bB4 = false;
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						if (border_neighbor[iB4 - maxelm].iI1 > -1) {
							printf("iI1\n");
						}
						if (border_neighbor[iB4 - maxelm].iI2 > -1) {
							printf("iI2\n");
						}
						printf("*** B\n");
						//getchar();
						system("PAUSE");
#endif
					}
					//bsB1 = true;
				}

			}

		}


	}
	// 11.05.2017
	if (poweron_multiplier_sequence > 0.0) {
		// Sc2D != 0.0
	}
	else {
		Sc2D *= 0.0;
	}
	//Sc2D *= poweron_multiplier_sequence; // на случай если мощность выключена (это нужно для square wave решателя).
	//printf("%e %e %e\n",dx,dy,dz); // debug GOOD
	//getchar();

	doublereal dxe = 0.5*dx, dxw = 0.5*dx, dyn = 0.5*dy, dys = 0.5*dy, dzt = 0.5*dz, dzb = 0.5*dz;

	doublereal feplus, fwplus, fnplus, fsplus, ftplus, fbplus;

	// плотность аппроксимируется средним гармоническим
	// примечание: здесь под плотностью понимается произведение плотности на теплоёмкость при постоянном давлении.
	doublereal rP, rE = 0.0, rN = 0.0, rT = 0.0, rW = 0.0, rS = 0.0, rB = 0.0;
	rP = prop[RHO][iP] * prop[HEAT_CAPACITY][iP];
	doublereal rhoe = rP, rhow = rP, rhon = rP, rhos = rP, rhot = rP, rhob = rP;
	doublereal heatP, heatE = 0.0, heatN = 0.0, heatT = 0.0, heatW = 0.0, heatS = 0.0, heatB = 0.0;
	heatP = prop[HEAT_CAPACITY][iP];

	doublereal heate = 0.0, heatw = 0.0, heatn = 0.0, heats = 0.0, heatt = 0.0, heatb = 0.0;

//#pragma omp parallel sections 
	{
//#pragma omp section 
		{
			// т.к. известна нумерация вершин куба, то здесь она используется
			// x - direction
			if (iE > -1) {
				if (!bE) dxe = 0.5 * (pa[nvtx[1][iE] - 1].x + pa[nvtx[0][iE] - 1].x);
				if (!bE) dxe -= 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
			}
			dxe = fabs(dxe);
			// x-direction
			feplus = 0.5 * dx / dxe;
			if (iE > -1) {
				if (!bE) rE = prop[RHO][iE] * prop[HEAT_CAPACITY][iE]; else rE = prop_b[RHO][iE - maxelm] * prop_b[HEAT_CAPACITY][iE - maxelm];
				// Значение плотности * теплоёмкость на грани КО:
				rhoe = rE * rP / (feplus * rE + (1.0 - feplus) * rP); // верные формы записи. проверено.

				if (!bE) heatE = prop[HEAT_CAPACITY][iE]; else heatE = prop_b[HEAT_CAPACITY][iE - maxelm];

				// Значение теплоёмкости при постоянном давлении на грани КО:

				heate = heatE * heatP / (feplus * heatE + (1.0 - feplus) * heatP);
			}
		}
//#pragma omp section 
		{
			if (iW > -1) {
				if (!bW) dxw = 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
				if (!bW) dxw -= 0.5 * (pa[nvtx[1][iW] - 1].x + pa[nvtx[0][iW] - 1].x);
			}
			dxw = fabs(dxw);
			fwplus = 0.5 * dx / dxw;
			if (iW > -1) {
				if (!bW) rW = prop[RHO][iW] * prop[HEAT_CAPACITY][iW]; else rW = prop_b[RHO][iW - maxelm] * prop_b[HEAT_CAPACITY][iW - maxelm];
				// Значение плотности * теплоёмкость на грани КО:
				rhow = rW * rP / (fwplus * rW + (1.0 - fwplus) * rP);

				if (!bW) heatW = prop[HEAT_CAPACITY][iW]; else heatW = prop_b[HEAT_CAPACITY][iW - maxelm];

				heatw = heatW * heatP / (fwplus * heatW + (1.0 - fwplus) * heatP);
			}
		}
//#pragma omp section 
		{
			// y - direction
			if (iN > -1) {
				if (!bN) dyn = 0.5 * (pa[nvtx[2][iN] - 1].y + pa[nvtx[0][iN] - 1].y);
				if (!bN) dyn -= 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
			}
			dyn = fabs(dyn);
			// y-direction
			fnplus = 0.5 * dy / dyn;
			if (iN > -1) {
				if (!bN) rN = prop[RHO][iN] * prop[HEAT_CAPACITY][iN]; else rN = prop_b[RHO][iN - maxelm] * prop_b[HEAT_CAPACITY][iN - maxelm];
				// Значение плотности * теплоёмкость на грани КО:
				rhon = rN * rP / (fnplus * rN + (1.0 - fnplus) * rP);
				if (!bN) heatN = prop[HEAT_CAPACITY][iN]; else heatN = prop_b[HEAT_CAPACITY][iN - maxelm];

				heatn = heatN * heatP / (fnplus * heatN + (1.0 - fnplus) * heatP);
			}
		}
//#pragma omp section 
		{
			if (iS > -1) {
				if (!bS) dys = 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
				if (!bS) dys -= 0.5 * (pa[nvtx[2][iS] - 1].y + pa[nvtx[0][iS] - 1].y);
			}
			dys = fabs(dys);
			fsplus = 0.5 * dy / dys;
			if (iS > -1) {
				if (!bS) rS = prop[RHO][iS] * prop[HEAT_CAPACITY][iS]; else rS = prop_b[RHO][iS - maxelm] * prop_b[HEAT_CAPACITY][iS - maxelm];
				// Значение плотности * теплоёмкость на грани КО:
				rhos = rS * rP / (fsplus * rS + (1.0 - fsplus) * rP);

				if (!bS) heatS = prop[HEAT_CAPACITY][iS]; else heatS = prop_b[HEAT_CAPACITY][iS - maxelm];

				heats = heatS * heatP / (fsplus * heatS + (1.0 - fsplus) * heatP);
			}
		}
//#pragma omp section
		{
			// z - direction
			if (iT > -1) {
				if (!bT) dzt = 0.5 * (pa[nvtx[4][iT] - 1].z + pa[nvtx[0][iT] - 1].z);
				if (!bT) dzt -= 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
			}
			dzt = fabs(dzt);
			// z-direction
			ftplus = 0.5 * dz / dzt;
			if (iT > -1) {
				if (!bT) rT = prop[RHO][iT] * prop[HEAT_CAPACITY][iT]; else rT = prop_b[RHO][iT - maxelm] * prop_b[HEAT_CAPACITY][iT - maxelm];
				// Значение плотности * теплоёмкость на грани КО:
				rhot = rT * rP / (ftplus * rT + (1.0 - ftplus) * rP);

				if (!bT) heatT = prop[HEAT_CAPACITY][iT]; else heatT = prop_b[HEAT_CAPACITY][iT - maxelm];

				heatt = heatT * heatP / (ftplus * heatT + (1.0 - ftplus) * heatP);
			}
		}
//#pragma omp section 
		{
			if (iB > -1) {
				if (!bB) dzb = 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
				if (!bB) dzb -= 0.5 * (pa[nvtx[4][iB] - 1].z + pa[nvtx[0][iB] - 1].z);
			}
			dzb = fabs(dzb);
			fbplus = 0.5 * dz / dzb;
			if (iB > -1) {
				if (!bB) rB = prop[RHO][iB] * prop[HEAT_CAPACITY][iB]; else rB = prop_b[RHO][iB - maxelm] * prop_b[HEAT_CAPACITY][iB - maxelm];
				// Значение плотности * теплоёмкость на грани КО:
				rhob = rB * rP / (fbplus * rB + (1.0 - fbplus) * rP);

				if (!bB) heatB = prop[HEAT_CAPACITY][iB]; else heatB = prop_b[HEAT_CAPACITY][iB - maxelm];

				heatb = heatB * heatP / (fbplus * heatB + (1.0 - fbplus) * heatP);
			}
		}
	}

	doublereal dxe2 = 0.5*dx, dxw2 = 0.5*dx, dyn2 = 0.5*dy, dys2 = 0.5*dy, dzt2 = 0.5*dz, dzb2 = 0.5*dz;
	doublereal dxe3 = 0.5*dx, dxw3 = 0.5*dx, dyn3 = 0.5*dy, dys3 = 0.5*dy, dzt3 = 0.5*dz, dzb3 = 0.5*dz;
	doublereal dxe4 = 0.5*dx, dxw4 = 0.5*dx, dyn4 = 0.5*dy, dys4 = 0.5*dy, dzt4 = 0.5*dz, dzb4 = 0.5*dz;

	//printf("%e %e %e %e %e %e\n",feplus, fwplus, fnplus, fsplus, ftplus, fbplus);
	//getchar();

	/*
	if ((iP>=25)&&(iP<=29)) {
	printf("dxe=%e dxw=%e dyn=%e dys=%e dzt=%e dzb=%e\n",dxe, dxw, dyn, dys, dzt, dzb);
	printf("feplus=%e fwplus=%e fnplus=%e fsplus=%e ftplus=%e fbplus=%e\n",feplus, fwplus, fnplus, fsplus, ftplus, fbplus);
	getchar();
	}
	*/


	//printf("%e %e %e %e %e\n",rP, rE, rN, rT, rW);
	//getchar();



#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (rhoe != rhoe) {
		printf("rhoe = %e in function my_elmatr_quad_T3D\n", rhoe);
		system("pause");
	}
	if (rhow != rhow) {
		printf("rhow = %e in function my_elmatr_quad_T3D\n", rhow);
		system("pause");
	}
	if (rhon != rhon) {
		printf("rhon = %e in function my_elmatr_quad_T3D\n", rhon);
		system("pause");
	}
	if (rhos != rhos) {
		printf("rhos = %e in function my_elmatr_quad_T3D\n", rhos);
		system("pause");
	}
	if (rhot != rhot) {
		printf("rhot = %e in function my_elmatr_quad_T3D\n", rhot);
		system("pause");
	}
	if (rhob != rhob) {
		printf("rhob = %e in function my_elmatr_quad_T3D\n", rhob);
		system("pause");
	}
#endif
	// Здесь используется алгоритм при котором массовый поток через
	// грани КО, вычисленный на основе скорректированной скорости и давления,
	// запоминается в памяти и потом используется. Но дело в том что в уравнении теплопроводности массовый поток
	// на грани требуется домножать на значение теплоёмкости при постоянном давлении на грани.
	// Поэтому здесь приводится вычисление теплоёмкости.

	// теплоёмкость (heat) аппроксимируется средним гармоническим
	// примечание: здесь под теплоёмкостью понимается только теплоёмкость при постоянном давлении.



	//printf("%e %e %e %e %e\n",heatP, heatE, heatN, heatT, heatW);
	//getchar();


	if (b_on_adaptive_local_refinement_mesh) {

		// т.к. известна нумерация вершин куба, то здесь она используется
		// x - direction
		if (iE2 > -1) {
			if (!bE2) dxe2 = 0.5 * (pa[nvtx[1][iE2] - 1].x + pa[nvtx[0][iE2] - 1].x);
			if (!bE2) dxe2 -= 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
		}
		if (iW2 > -1) {
			if (!bW2) dxw2 = 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
			if (!bW2) dxw2 -= 0.5 * (pa[nvtx[1][iW2] - 1].x + pa[nvtx[0][iW2] - 1].x);
		}
		// y - direction
		if (iN2 > -1) {
			if (!bN2) dyn2 = 0.5 * (pa[nvtx[2][iN2] - 1].y + pa[nvtx[0][iN2] - 1].y);
			if (!bN2) dyn2 -= 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
		}
		if (iS2 > -1) {
			if (!bS2) dys2 = 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
			if (!bS2) dys2 -= 0.5 * (pa[nvtx[2][iS2] - 1].y + pa[nvtx[0][iS2] - 1].y);
		}
		// z - direction
		if (iT2 > -1) {
			if (!bT2) dzt2 = 0.5 * (pa[nvtx[4][iT2] - 1].z + pa[nvtx[0][iT2] - 1].z);
			if (!bT2) dzt2 -= 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
		}
		if (iB2 > -1) {
			if (!bB2) dzb2 = 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
			if (!bB2) dzb2 -= 0.5 * (pa[nvtx[4][iB2] - 1].z + pa[nvtx[0][iB2] - 1].z);
		}

		// т.к. известна нумерация вершин куба, то здесь она используется
		// x - direction
		if (iE3 > -1) {
			if (!bE3) dxe3 = 0.5 * (pa[nvtx[1][iE3] - 1].x + pa[nvtx[0][iE3] - 1].x);
			if (!bE3) dxe3 -= 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
		}
		if (iW3 > -1) {
			if (!bW3) dxw3 = 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
			if (!bW3) dxw3 -= 0.5 * (pa[nvtx[1][iW3] - 1].x + pa[nvtx[0][iW3] - 1].x);
		}
		// y - direction
		if (iN3 > -1) {
			if (!bN3) dyn3 = 0.5 * (pa[nvtx[2][iN3] - 1].y + pa[nvtx[0][iN3] - 1].y);
			if (!bN3) dyn3 -= 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
		}
		if (iS3 > -1) {
			if (!bS3) dys3 = 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
			if (!bS3) dys3 -= 0.5 * (pa[nvtx[2][iS3] - 1].y + pa[nvtx[0][iS3] - 1].y);
		}
		// z - direction
		if (iT3 > -1) {
			if (!bT3) dzt3 = 0.5 * (pa[nvtx[4][iT3] - 1].z + pa[nvtx[0][iT3] - 1].z);
			if (!bT3) dzt3 -= 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
		}
		if (iB3 > -1) {
			if (!bB3) dzb3 = 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
			if (!bB3) dzb3 -= 0.5 * (pa[nvtx[4][iB3] - 1].z + pa[nvtx[0][iB3] - 1].z);
		}

		// т.к. известна нумерация вершин куба, то здесь она используется
		// x - direction
		if (iE4 > -1) {
			if (!bE4) dxe4 = 0.5 * (pa[nvtx[1][iE4] - 1].x + pa[nvtx[0][iE4] - 1].x);
			if (!bE4) dxe4 -= 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
		}
		if (iW4 > -1) {
			if (!bW4) dxw4 = 0.5 * (pa[nvtx[1][iP] - 1].x + pa[nvtx[0][iP] - 1].x);
			if (!bW4) dxw4 -= 0.5 * (pa[nvtx[1][iW4] - 1].x + pa[nvtx[0][iW4] - 1].x);
		}
		// y - direction
		if (iN4 > -1) {
			if (!bN4) dyn4 = 0.5 * (pa[nvtx[2][iN4] - 1].y + pa[nvtx[0][iN4] - 1].y);
			if (!bN4) dyn4 -= 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
		}
		if (iS4 > -1) {
			if (!bS4) dys4 = 0.5 * (pa[nvtx[2][iP] - 1].y + pa[nvtx[0][iP] - 1].y);
			if (!bS4) dys4 -= 0.5 * (pa[nvtx[2][iS4] - 1].y + pa[nvtx[0][iS4] - 1].y);
		}
		// z - direction
		if (iT4 > -1) {
			if (!bT4) dzt4 = 0.5 * (pa[nvtx[4][iT4] - 1].z + pa[nvtx[0][iT4] - 1].z);
			if (!bT4) dzt4 -= 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
		}
		if (iB4 > -1) {
			if (!bB4) dzb4 = 0.5 * (pa[nvtx[4][iP] - 1].z + pa[nvtx[0][iP] - 1].z);
			if (!bB4) dzb4 -= 0.5 * (pa[nvtx[4][iB4] - 1].z + pa[nvtx[0][iB4] - 1].z);
		}


		dxe2 = fabs(dxe2);
		dxe3 = fabs(dxe3);
		dxe4 = fabs(dxe4);

		dxw2 = fabs(dxw2);
		dxw3 = fabs(dxw3);
		dxw4 = fabs(dxw4);

		dyn2 = fabs(dyn2);
		dyn3 = fabs(dyn3);
		dyn4 = fabs(dyn4);

		dys2 = fabs(dys2);
		dys3 = fabs(dys3);
		dys4 = fabs(dys4);

		dzt2 = fabs(dzt2);
		dzt3 = fabs(dzt3);
		dzt4 = fabs(dzt4);

		dzb2 = fabs(dzb2);
		dzb3 = fabs(dzb3);
		dzb4 = fabs(dzb4);


		doublereal feplus2, fwplus2, fnplus2, fsplus2, ftplus2, fbplus2;
		doublereal feplus3, fwplus3, fnplus3, fsplus3, ftplus3, fbplus3;
		doublereal feplus4, fwplus4, fnplus4, fsplus4, ftplus4, fbplus4;



		// x-direction
		feplus2 = 0.5 * dx / dxe2;
		fwplus2 = 0.5 * dx / dxw2;
		// y-direction
		fnplus2 = 0.5 * dy / dyn2;
		fsplus2 = 0.5 * dy / dys2;
		// z-direction
		ftplus2 = 0.5 * dz / dzt2;
		fbplus2 = 0.5 * dz / dzb2;

		// x-direction
		feplus3 = 0.5 * dx / dxe3;
		fwplus3 = 0.5 * dx / dxw3;
		// y-direction
		fnplus3 = 0.5 * dy / dyn3;
		fsplus3 = 0.5 * dy / dys3;
		// z-direction
		ftplus3 = 0.5 * dz / dzt3;
		fbplus3 = 0.5 * dz / dzb3;


		// x-direction
		feplus4 = 0.5 * dx / dxe4;
		fwplus4 = 0.5 * dx / dxw4;
		// y-direction
		fnplus4 = 0.5 * dy / dyn4;
		fsplus4 = 0.5 * dy / dys4;
		// z-direction
		ftplus4 = 0.5 * dz / dzt4;
		fbplus4 = 0.5 * dz / dzb4;


		doublereal  rE2 = 0.0, rN2 = 0.0, rT2 = 0.0, rW2 = 0.0, rS2 = 0.0, rB2 = 0.0;
		doublereal  rE3 = 0.0, rN3 = 0.0, rT3 = 0.0, rW3 = 0.0, rS3 = 0.0, rB3 = 0.0;
		doublereal  rE4 = 0.0, rN4 = 0.0, rT4 = 0.0, rW4 = 0.0, rS4 = 0.0, rB4 = 0.0;

		if (iE2 > -1) {
			if (!bE2) rE2 = prop[RHO][iE2] * prop[HEAT_CAPACITY][iE2]; else rE2 = prop_b[RHO][iE2 - maxelm] * prop_b[HEAT_CAPACITY][iE2 - maxelm];
		}
		if (iN2 > -1) {
			if (!bN2) rN2 = prop[RHO][iN2] * prop[HEAT_CAPACITY][iN2]; else rN2 = prop_b[RHO][iN2 - maxelm] * prop_b[HEAT_CAPACITY][iN2 - maxelm];
		}
		if (iT2 > -1) {
			if (!bT2) rT2 = prop[RHO][iT2] * prop[HEAT_CAPACITY][iT2]; else rT2 = prop_b[RHO][iT2 - maxelm] * prop_b[HEAT_CAPACITY][iT2 - maxelm];
		}
		if (iW2 > -1) {
			if (!bW2) rW2 = prop[RHO][iW2] * prop[HEAT_CAPACITY][iW2]; else rW2 = prop_b[RHO][iW2 - maxelm] * prop_b[HEAT_CAPACITY][iW2 - maxelm];
		}
		if (iS2 > -1) {
			if (!bS2) rS2 = prop[RHO][iS2] * prop[HEAT_CAPACITY][iS2]; else rS2 = prop_b[RHO][iS2 - maxelm] * prop_b[HEAT_CAPACITY][iS2 - maxelm];
		}
		if (iB2 > -1) {
			if (!bB2) rB2 = prop[RHO][iB2] * prop[HEAT_CAPACITY][iB2]; else rB2 = prop_b[RHO][iB2 - maxelm] * prop_b[HEAT_CAPACITY][iB2 - maxelm];
		}


		if (iE3 > -1) {
			if (!bE3) rE3 = prop[RHO][iE3] * prop[HEAT_CAPACITY][iE3]; else rE3 = prop_b[RHO][iE3 - maxelm] * prop_b[HEAT_CAPACITY][iE3 - maxelm];
		}
		if (iN3 > -1) {
			if (!bN3) rN3 = prop[RHO][iN3] * prop[HEAT_CAPACITY][iN3]; else rN3 = prop_b[RHO][iN3 - maxelm] * prop_b[HEAT_CAPACITY][iN3 - maxelm];
		}
		if (iT3 > -1) {
			if (!bT3) rT3 = prop[RHO][iT3] * prop[HEAT_CAPACITY][iT3]; else rT3 = prop_b[RHO][iT3 - maxelm] * prop_b[HEAT_CAPACITY][iT3 - maxelm];
		}
		if (iW3 > -1) {
			if (!bW3) rW3 = prop[RHO][iW3] * prop[HEAT_CAPACITY][iW3]; else rW3 = prop_b[RHO][iW3 - maxelm] * prop_b[HEAT_CAPACITY][iW3 - maxelm];
		}
		if (iS3 > -1) {
			if (!bS3) rS3 = prop[RHO][iS3] * prop[HEAT_CAPACITY][iS3]; else rS3 = prop_b[RHO][iS3 - maxelm] * prop_b[HEAT_CAPACITY][iS3 - maxelm];
		}
		if (iB3 > -1) {
			if (!bB3) rB3 = prop[RHO][iB3] * prop[HEAT_CAPACITY][iB3]; else rB3 = prop_b[RHO][iB3 - maxelm] * prop_b[HEAT_CAPACITY][iB3 - maxelm];
		}


		if (iE4 > -1) {
			if (!bE4) rE4 = prop[RHO][iE4] * prop[HEAT_CAPACITY][iE4]; else rE4 = prop_b[RHO][iE4 - maxelm] * prop_b[HEAT_CAPACITY][iE4 - maxelm];
		}
		if (iN4 > -1) {
			if (!bN4) rN4 = prop[RHO][iN4] * prop[HEAT_CAPACITY][iN4]; else rN4 = prop_b[RHO][iN4 - maxelm] * prop_b[HEAT_CAPACITY][iN4 - maxelm];
		}
		if (iT4 > -1) {
			if (!bT4) rT4 = prop[RHO][iT4] * prop[HEAT_CAPACITY][iT4]; else rT4 = prop_b[RHO][iT4 - maxelm] * prop_b[HEAT_CAPACITY][iT4 - maxelm];
		}
		if (iW4 > -1) {
			if (!bW4) rW4 = prop[RHO][iW4] * prop[HEAT_CAPACITY][iW4]; else rW4 = prop_b[RHO][iW4 - maxelm] * prop_b[HEAT_CAPACITY][iW4 - maxelm];
		}
		if (iS4 > -1) {
			if (!bS4) rS4 = prop[RHO][iS4] * prop[HEAT_CAPACITY][iS4]; else rS4 = prop_b[RHO][iS4 - maxelm] * prop_b[HEAT_CAPACITY][iS4 - maxelm];
		}
		if (iB4 > -1) {
			if (!bB4) rB4 = prop[RHO][iB4] * prop[HEAT_CAPACITY][iB4]; else rB4 = prop_b[RHO][iB4 - maxelm] * prop_b[HEAT_CAPACITY][iB4 - maxelm];
		}


		doublereal rhoe2 = rP, rhow2 = rP, rhon2 = rP, rhos2 = rP, rhot2 = rP, rhob2 = rP;
		doublereal rhoe3 = rP, rhow3 = rP, rhon3 = rP, rhos3 = rP, rhot3 = rP, rhob3 = rP;
		doublereal rhoe4 = rP, rhow4 = rP, rhon4 = rP, rhos4 = rP, rhot4 = rP, rhob4 = rP;


		if (iE2 > -1) {
			rhoe2 = rE2 * rP / (feplus2 * rE2 + (1.0 - feplus2) * rP);
		}
		if (iW2 > -1) {
			rhow2 = rW2 * rP / (fwplus2 * rW2 + (1.0 - fwplus2) * rP);
		}
		if (iN2 > -1) {
			rhon2 = rN2 * rP / (fnplus2 * rN2 + (1.0 - fnplus2) * rP);
		}
		if (iS2 > -1) {
			rhos2 = rS2 * rP / (fsplus2 * rS2 + (1.0 - fsplus2) * rP);
		}
		if (iT2 > -1) {
			rhot2 = rT2 * rP / (ftplus2 * rT2 + (1.0 - ftplus2) * rP);
		}
		if (iB2 > -1) {
			rhob2 = rB2 * rP / (fbplus2 * rB2 + (1.0 - fbplus2) * rP);
		}

		if (iE3 > -1) {
			rhoe3 = rE3 * rP / (feplus3 * rE3 + (1.0 - feplus3) * rP);
		}
		if (iW3 > -1) {
			rhow3 = rW3 * rP / (fwplus3 * rW3 + (1.0 - fwplus3) * rP);
		}
		if (iN3 > -1) {
			rhon3 = rN3 * rP / (fnplus3 * rN3 + (1.0 - fnplus3) * rP);
		}
		if (iS3 > -1) {
			rhos3 = rS3 * rP / (fsplus3 * rS3 + (1.0 - fsplus3) * rP);
		}
		if (iT3 > -1) {
			rhot3 = rT3 * rP / (ftplus3 * rT3 + (1.0 - ftplus3) * rP);
		}
		if (iB3 > -1) {
			rhob3 = rB3 * rP / (fbplus3 * rB3 + (1.0 - fbplus3) * rP);
		}

		if (iE4 > -1) {
			rhoe4 = rE4 * rP / (feplus4 * rE4 + (1.0 - feplus4) * rP);
		}
		if (iW4 > -1) {
			rhow4 = rW4 * rP / (fwplus4 * rW4 + (1.0 - fwplus4) * rP);
		}
		if (iN4 > -1) {
			rhon4 = rN4 * rP / (fnplus4 * rN4 + (1.0 - fnplus4) * rP);
		}
		if (iS4 > -1) {
			rhos4 = rS4 * rP / (fsplus4 * rS4 + (1.0 - fsplus4) * rP);
		}
		if (iT4 > -1) {
			rhot4 = rT4 * rP / (ftplus4 * rT4 + (1.0 - ftplus4) * rP);
		}
		if (iB4 > -1) {
			rhob4 = rB4 * rP / (fbplus4 * rB4 + (1.0 - fbplus4) * rP);
		}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
		if (rhoe2 != rhoe2) {
			printf("rhoe2 = %e in function my_elmatr_quad_T3D\n", rhoe2);
			system("pause");
		}
		if (rhow2 != rhow2) {
			printf("rhow2 = %e in function my_elmatr_quad_T3D\n", rhow2);
			system("pause");
		}
		if (rhon2 != rhon2) {
			printf("rhon2 = %e in function my_elmatr_quad_T3D\n", rhon2);
			system("pause");
		}
		if (rhos2 != rhos2) {
			printf("rhos2 = %e in function my_elmatr_quad_T3D\n", rhos2);
			system("pause");
		}
		if (rhot2 != rhot2) {
			printf("rhot2 = %e in function my_elmatr_quad_T3D\n", rhot2);
			system("pause");
		}
		if (rhob2 != rhob2) {
			printf("rhob2 = %e in function my_elmatr_quad_T3D\n", rhob2);
			system("pause");
		}
		if (rhoe3 != rhoe3) {
			printf("rhoe3 = %e in function my_elmatr_quad_T3D\n", rhoe3);
			system("pause");
		}
		if (rhow3 != rhow3) {
			printf("rhow3 = %e in function my_elmatr_quad_T3D\n", rhow3);
			system("pause");
		}
		if (rhon3 != rhon3) {
			printf("rhon3 = %e in function my_elmatr_quad_T3D\n", rhon3);
			system("pause");
		}
		if (rhos3 != rhos3) {
			printf("rhos3 = %e in function my_elmatr_quad_T3D\n", rhos3);
			system("pause");
		}
		if (rhot3 != rhot3) {
			printf("rhot3 = %e in function my_elmatr_quad_T3D\n", rhot3);
			system("pause");
		}
		if (rhob3 != rhob3) {
			printf("rhob3 = %e in function my_elmatr_quad_T3D\n", rhob3);
			system("pause");
		}
		if (rhoe4 != rhoe4) {
			printf("rhoe4 = %e in function my_elmatr_quad_T3D\n", rhoe4);
			system("pause");
		}
		if (rhow4 != rhow4) {
			printf("rhow4 = %e in function my_elmatr_quad_T3D\n", rhow4);
			system("pause");
		}
		if (rhon4 != rhon4) {
			printf("rhon4 = %e in function my_elmatr_quad_T3D\n", rhon4);
			system("pause");
		}
		if (rhos4 != rhos4) {
			printf("rhos4 = %e in function my_elmatr_quad_T3D\n", rhos4);
			system("pause");
		}
		if (rhot4 != rhot4) {
			printf("rhot4 = %e in function my_elmatr_quad_T3D\n", rhot4);
			system("pause");
		}
		if (rhob4 != rhob4) {
			printf("rhob4 = %e in function my_elmatr_quad_T3D\n", rhob4);
			system("pause");
		}
#endif

		// Поправка Рхи-Чоу добавлена в интерполяцию скорости на грань КО
		// для уравнения теплопередачи в жидкости 12 января 2012 года.
		// Возможно скорости на грани ещё понадобяться для полного учёта диссипативного источникового члена (см. обобщённые уравнения Ньютона). 

		/*
		// линейная интерполяция скорости на грань КО.
		doublereal ue=0.0, uw=0.0, vn=0.0, vs=0.0, wt=0.0, wb=0.0;
		if (bconvective) {
		doublereal velP, velS;
		if (!bE) {
		bool bsolidP=false, bsolidS=false;
		if (ptr[1][iE]==-1) {
		// принадлежит твёрдому телу:
		velS=0.0;
		bsolidS=true;
		}
		else velS=f[ptr[1][iE]].potent[VX][ptr[0][iE]];

		if (ptr[1][iP]==-1) {
		// принадлежит твёрдому телу:
		velP=0.0;
		bsolidP=true;
		}
		else velP=f[ptr[1][iP]].potent[VX][ptr[0][iP]];

		if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
		if (bsolidS) {
		// E граница жидкой зоны
		ue=f[ptr[1][iP]].potent[VX][f[ptr[1][iP]].neighbors_for_the_internal_node[ESIDE][0][ptr[0][iP]]];
		// Рхи-Чоу original interpolation method:
		if (bRhieChowb) {
		ue+=RCh*ugRhieChow_internal_border(ptr[ENUMERATECONTVOL][iP], ESIDE, f[ptr[1][iP]].alpha[VX], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		else {
		// W граница жидкой зоны
		ue=f[ptr[1][iE]].potent[VX][f[ptr[1][iE]].neighbors_for_the_internal_node[WSIDE][0][ptr[0][iE]]];
		// ENUMERATECONTVOL == 0
		// Рхи-Чоу original interpolation method:
		if (bRhieChowb) {
		ue+=RCh*ugRhieChow_internal_border(ptr[ENUMERATECONTVOL][iE], WSIDE, f[ptr[1][iE]].alpha[VX], f[ptr[1][iE]].nvtx, f[ptr[1][iE]].neighbors_for_the_internal_node, f[ptr[1][iE]].maxelm, f[ptr[1][iE]].potent[PRESS], f[ptr[1][iE]].pa, f[ptr[1][iE]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}
		else if (!(bsolidS && bsolidP)) {
		// E Грань внутри жидкости
		ue=feplus*velS+(1.0-feplus)*velP;
		// Рхи-Чоу original interpolation method:
		if (bRhieChowi) {
		ue+=RCh*ugRhieChow_internal(ptr[ENUMERATECONTVOL][iP], ESIDE, f[ptr[1][iP]].alpha[VX], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		} else ue=0; // в твёрдом теле
		}
		else  {
		if (ptr[1][iP]==-1) ue=0.0;
		else {
		// E граница жидкой зоны.
		ue=f[ptr[1][iP]].potent[VX][f[ptr[1][iP]].neighbors_for_the_internal_node[ESIDE][0][ptr[0][iP]]];
		// Рхи-Чоу original interpolation method:
		if (bRhieChowb) {
		ue+=RCh*ugRhieChow_internal_border(ptr[ENUMERATECONTVOL][iP], ESIDE, f[ptr[1][iP]].alpha[VX], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}

		if (!bW) {
		bool bsolidP=false, bsolidS=false;
		if (ptr[1][iW]==-1) {
		// принадлежит твёрдому телу:
		velS=0.0;
		bsolidS=true;
		}
		else velS=f[ptr[1][iW]].potent[VX][ptr[0][iW]];

		if (ptr[1][iP]==-1) {
		// принадлежит твёрдому телу:
		velP=0.0;
		bsolidP=true;
		}
		else velP=f[ptr[1][iP]].potent[VX][ptr[0][iP]];

		if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
		if (bsolidS) {
		// W граница жидкой зоны
		uw=f[ptr[1][iP]].potent[VX][f[ptr[1][iP]].neighbors_for_the_internal_node[WSIDE][0][ptr[0][iP]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		uw+=RCh*ugRhieChow_internal_border(ptr[0][iP], WSIDE, f[ptr[1][iP]].alpha[VX], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		else {
		// E граница жидкой зоны
		uw=f[ptr[1][iW]].potent[VX][f[ptr[1][iW]].neighbors_for_the_internal_node[ESIDE][0][ptr[0][iW]]];
		// Рхи-Чоу original interpolation method:
		if (bRhieChowb) {
		uw+=RCh*ugRhieChow_internal_border(ptr[0][iW], ESIDE, f[ptr[1][iW]].alpha[VX], f[ptr[1][iW]].nvtx, f[ptr[1][iW]].neighbors_for_the_internal_node, f[ptr[1][iW]].maxelm, f[ptr[1][iW]].potent[PRESS], f[ptr[1][iW]].pa, f[ptr[1][iW]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}
		else if (!(bsolidS && bsolidP)) {
		// W грань внутри жидкости
		uw=fwplus*velS+(1.0-fwplus)*velP;
		//Rhie-Chow original interpolation method
		if (bRhieChowi) {
		uw+=RCh*ugRhieChow_internal(ptr[0][iP], WSIDE, f[ptr[1][iP]].alpha[VX], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		} else uw=0.0;
		}
		else  {
		if (ptr[1][iP]==-1) uw=0.0;
		else {
		// W граница жидкой зоны
		uw=f[ptr[1][iP]].potent[VX][f[ptr[1][iP]].neighbors_for_the_internal_node[WSIDE][0][ptr[0][iP]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		uw+=RCh*ugRhieChow_internal_border(ptr[0][iP], WSIDE, f[ptr[1][iP]].alpha[VX], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}

		if (!bN) {
		bool bsolidP=false, bsolidS=false;
		if (ptr[1][iN]==-1) {
		velS=0.0;
		bsolidS=true;
		}
		else velS=f[ptr[1][iN]].potent[VY][ptr[0][iN]];

		if (ptr[1][iP]==-1) {
		velP=0.0;
		bsolidP=true;
		}
		else velP=f[ptr[1][iP]].potent[VY][ptr[0][iP]];

		if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
		if (bsolidS) {
		// N граница жидкой зоны
		vn=f[ptr[1][iP]].potent[VY][f[ptr[1][iP]].neighbors_for_the_internal_node[NSIDE][0][ptr[0][iP]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		vn+=RCh*ugRhieChow_internal_border(ptr[0][iP], N,  f[ptr[1][iP]].alpha[VY], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		else {
		// S граница жидкой зоны
		vn=f[ptr[1][iN]].potent[VY][f[ptr[1][iN]].neighbors_for_the_internal_node[SSIDE][0][ptr[0][iN]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		vn+=RCh*ugRhieChow_internal_border(ptr[0][iN], S,  f[ptr[1][iN]].alpha[VY], f[ptr[1][iN]].nvtx, f[ptr[1][iN]].neighbors_for_the_internal_node, f[ptr[1][iN]].maxelm, f[ptr[1][iN]].potent[PRESS], f[ptr[1][iN]].pa, f[ptr[1][iN]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}
		else if (!(bsolidS && bsolidP)) {
		// N грань внутри жидкости
		vn=fnplus*velS+(1.0-fnplus)*velP;
		// Rhie-Chow original interpolation method
		if (bRhieChowi) {
		vn+=RCh*ugRhieChow_internal(ptr[0][iP], N, f[ptr[1][iP]].alpha[VY], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		} else vn=0.0;
		}
		else  {
		if (ptr[1][iP]==-1) vn=0.0;
		else {
		// N граница жидкой зоны
		vn=f[ptr[1][iP]].potent[VY][f[ptr[1][iP]].neighbors_for_the_internal_node[NSIDE][0][ptr[0][iP]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		vn+=RCh*ugRhieChow_internal_border(ptr[0][iP], N,  f[ptr[1][iP]].alpha[VY], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}

		if (!bS) {
		bool bsolidP=false, bsolidS=false;
		if (ptr[1][iS]==-1) {
		// принадлежит твёрдому телу:
		velS=0.0;
		bsolidS=true;
		}
		else velS=f[ptr[1][iS]].potent[VY][ptr[0][iS]];

		if (ptr[1][iP]==-1) {
		// принадлежит твёрдому телу:
		velP=0.0;
		bsolidP=true;
		}
		else velP=f[ptr[1][iP]].potent[VY][ptr[0][iP]];

		if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
		if (bsolidS) {
		// S граница жидкой зоны
		vs=f[ptr[1][iP]].potent[VY][f[ptr[1][iP]].neighbors_for_the_internal_node[SSIDE][0][ptr[0][iP]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		vs+=RCh*ugRhieChow_internal_border(ptr[0][iP], S,  f[ptr[1][iP]].alpha[VY], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		else {
		// N граница жидкой зоны
		vs=f[ptr[1][iS]].potent[VY][f[ptr[1][iS]].neighbors_for_the_internal_node[NSIDE][0][ptr[0][iS]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		vs+=RCh*ugRhieChow_internal_border(ptr[0][iS], N,  f[ptr[1][iS]].alpha[VY], f[ptr[1][iS]].nvtx, f[ptr[1][iS]].neighbors_for_the_internal_node, f[ptr[1][iS]].maxelm, f[ptr[1][iS]].potent[PRESS], f[ptr[1][iS]].pa, f[ptr[1][iS]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}
		else {
		// S грань внутри жидкости
		vs=fsplus*velS+(1.0-fsplus)*velP;
		// Rhie-Chow original interpolation method
		if (bRhieChowi) {
		vs+=RCh*ugRhieChow_internal(ptr[0][iP], S, f[ptr[1][iP]].alpha[VY], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}
		else  {
		if (ptr[1][iP]==-1) vs=0.0;
		else {
		// S граница жидкой зоны
		vs=f[ptr[1][iP]].potent[VY][f[ptr[1][iP]].neighbors_for_the_internal_node[SSIDE][0][ptr[0][iP]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		vs+=RCh*ugRhieChow_internal_border(ptr[0][iP], S,  f[ptr[1][iP]].alpha[VY], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}

		if (!bT) {
		bool bsolidP=false, bsolidS=false;
		if (ptr[1][iT]==-1) {
		velS=0.0;
		bsolidS=true;
		}
		else velS=f[ptr[1][iT]].potent[VZ][ptr[0][iT]];

		if (ptr[1][iP]==-1) {
		velP=0.0;
		bsolidP=true;
		}
		else velP=f[ptr[1][iP]].potent[VZ][ptr[0][iP]];

		if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
		if (bsolidS) {
		// T граница жидкой зоны
		wt=f[ptr[1][iP]].potent[VZ][f[ptr[1][iP]].neighbors_for_the_internal_node[TSIDE][0][ptr[0][iP]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		wt+=RCh*ugRhieChow_internal_border(ptr[0][iP], TSIDE, f[ptr[1][iP]].alpha[VZ], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		else {
		// B граница жидкой зоны
		wt=f[ptr[1][iT]].potent[VZ][f[ptr[1][iT]].neighbors_for_the_internal_node[BSIDE][0][ptr[0][iT]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		wt+=RCh*ugRhieChow_internal_border(ptr[0][iT], B, f[ptr[1][iT]].alpha[VZ], f[ptr[1][iT]].nvtx, f[ptr[1][iT]].neighbors_for_the_internal_node, f[ptr[1][iT]].maxelm, f[ptr[1][iT]].potent[PRESS], f[ptr[1][iT]].pa, f[ptr[1][iT]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}
		else if (!(bsolidS && bsolidP)) {
		// T грань внутри жидкости
		wt=ftplus*velS+(1.0-ftplus)*velP;
		// Rhie-Chow original interpolation method
		if (bRhieChowi) {
		wt+=RCh*ugRhieChow_internal(ptr[0][iP], TSIDE, f[ptr[1][iP]].alpha[VZ], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		} else wt=0.0;
		}
		else  {
		if (ptr[1][iP]==-1) wt=0.0;
		else {
		// T граница жидкой зоны
		wt=f[ptr[1][iP]].potent[VZ][f[ptr[1][iP]].neighbors_for_the_internal_node[TSIDE][0][ptr[0][iP]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		wt+=RCh*ugRhieChow_internal_border(ptr[0][iP], TSIDE, f[ptr[1][iP]].alpha[VZ], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}

		if (!bB) {
		bool bsolidP=false, bsolidS=false;
		if (ptr[1][iB]==-1) {
		// принадлежит твёрдому телу:
		velS=0.0;
		bsolidS=true;
		}
		else velS=f[ptr[1][iB]].potent[VZ][ptr[0][iB]];

		if (ptr[1][iP]==-1) {
		// принадлежит твёрдому телу:
		velP=0.0;
		bsolidP=true;
		}
		else velP=f[ptr[1][iP]].potent[VZ][ptr[0][iP]];

		if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
		if (bsolidS) {
		// B граница жидкой зоны
		wb=f[ptr[1][iP]].potent[VZ][f[ptr[1][iP]].neighbors_for_the_internal_node[BSIDE][0][ptr[0][iP]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		wb+=RCh*ugRhieChow_internal_border(ptr[0][iP], B, f[ptr[1][iP]].alpha[VZ], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		else {
		// T граница жидкой зоны
		wb=f[ptr[1][iB]].potent[VZ][f[ptr[1][iB]].neighbors_for_the_internal_node[TSIDE][0][ptr[0][iB]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		wb+=RCh*ugRhieChow_internal_border(ptr[0][iB], TSIDE, f[ptr[1][iB]].alpha[VZ], f[ptr[1][iB]].nvtx, f[ptr[1][iB]].neighbors_for_the_internal_node, f[ptr[1][iB]].maxelm, f[ptr[1][iB]].potent[PRESS], f[ptr[1][iB]].pa, f[ptr[1][iB]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}
		else if (!(bsolidS && bsolidP)) {
		// B грань внутри жидкости
		wb=fbplus*velS+(1.0-fbplus)*velP;
		// Rhie-Chow original interpolation method
		if (bRhieChowi) {
		wb+=RCh*ugRhieChow_internal(ptr[0][iP], B, f[ptr[1][iP]].alpha[VZ], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		} else wb=0.0;
		}
		else  {
		if (ptr[1][iP]==-1) wb=0.0;
		else {
		// B граница жидкой зоны
		wb=f[ptr[1][iP]].potent[VZ][f[ptr[1][iP]].neighbors_for_the_internal_node[BSIDE][0][ptr[0][iP]]];
		// Rhie-Chow original interpolation method
		if (bRhieChowb) {
		wb+=RCh*ugRhieChow_internal_border(ptr[0][iP], B, f[ptr[1][iP]].alpha[VZ], f[ptr[1][iP]].nvtx, f[ptr[1][iP]].neighbors_for_the_internal_node, f[ptr[1][iP]].maxelm, f[ptr[1][iP]].potent[PRESS], f[ptr[1][iP]].pa, f[ptr[1][iP]].diag_coef); // Вклад поправки Рхи-Чоу
		}
		}
		}

		} // end if (bconvective)

		//printf("%e %e %e %e %e %e\n",ue, uw, vn, vs, wt, wb);
		//getchar();
		*/



		doublereal  heatE2 = 0.0, heatN2 = 0.0, heatT2 = 0.0, heatW2 = 0.0, heatS2 = 0.0, heatB2 = 0.0;
		doublereal  heatE3 = 0.0, heatN3 = 0.0, heatT3 = 0.0, heatW3 = 0.0, heatS3 = 0.0, heatB3 = 0.0;
		doublereal  heatE4 = 0.0, heatN4 = 0.0, heatT4 = 0.0, heatW4 = 0.0, heatS4 = 0.0, heatB4 = 0.0;


		if (iE2 > -1) {
			if (!bE2) heatE2 = prop[HEAT_CAPACITY][iE2]; else heatE2 = prop_b[HEAT_CAPACITY][iE2 - maxelm];
		}
		if (iN2 > -1) {
			if (!bN2) heatN2 = prop[HEAT_CAPACITY][iN2]; else heatN2 = prop_b[HEAT_CAPACITY][iN2 - maxelm];
		}
		if (iT2 > -1) {
			if (!bT2) heatT2 = prop[HEAT_CAPACITY][iT2]; else heatT2 = prop_b[HEAT_CAPACITY][iT2 - maxelm];
		}
		if (iW2 > -1) {
			if (!bW2) heatW2 = prop[HEAT_CAPACITY][iW2]; else heatW2 = prop_b[HEAT_CAPACITY][iW2 - maxelm];
		}
		if (iS2 > -1) {
			if (!bS2) heatS2 = prop[HEAT_CAPACITY][iS2]; else heatS2 = prop_b[HEAT_CAPACITY][iS2 - maxelm];
		}
		if (iB2 > -1) {
			if (!bB2) heatB2 = prop[HEAT_CAPACITY][iB2]; else heatB2 = prop_b[HEAT_CAPACITY][iB2 - maxelm];
		}


		if (iE3 > -1) {
			if (!bE3) heatE3 = prop[HEAT_CAPACITY][iE3]; else heatE3 = prop_b[HEAT_CAPACITY][iE3 - maxelm];
		}
		if (iN3 > -1) {
			if (!bN3) heatN3 = prop[HEAT_CAPACITY][iN3]; else heatN3 = prop_b[HEAT_CAPACITY][iN3 - maxelm];
		}
		if (iT3 > -1) {
			if (!bT3) heatT3 = prop[HEAT_CAPACITY][iT3]; else heatT3 = prop_b[HEAT_CAPACITY][iT3 - maxelm];
		}
		if (iW3 > -1) {
			if (!bW3) heatW3 = prop[HEAT_CAPACITY][iW3]; else heatW3 = prop_b[HEAT_CAPACITY][iW3 - maxelm];
		}
		if (iS3 > -1) {
			if (!bS3) heatS3 = prop[HEAT_CAPACITY][iS3]; else heatS3 = prop_b[HEAT_CAPACITY][iS3 - maxelm];
		}
		if (iB3 > -1) {
			if (!bB3) heatB3 = prop[HEAT_CAPACITY][iB3]; else heatB3 = prop_b[HEAT_CAPACITY][iB3 - maxelm];
		}

		if (iE4 > -1) {
			if (!bE4) heatE4 = prop[HEAT_CAPACITY][iE4]; else heatE4 = prop_b[HEAT_CAPACITY][iE4 - maxelm];
		}
		if (iN4 > -1) {
			if (!bN4) heatN4 = prop[HEAT_CAPACITY][iN4]; else heatN4 = prop_b[HEAT_CAPACITY][iN4 - maxelm];
		}
		if (iT4 > -1) {
			if (!bT4) heatT4 = prop[HEAT_CAPACITY][iT4]; else heatT4 = prop_b[HEAT_CAPACITY][iT4 - maxelm];
		}
		if (iW4 > -1) {
			if (!bW4) heatW4 = prop[HEAT_CAPACITY][iW4]; else heatW4 = prop_b[HEAT_CAPACITY][iW4 - maxelm];
		}
		if (iS4 > -1) {
			if (!bS4) heatS4 = prop[HEAT_CAPACITY][iS4]; else heatS4 = prop_b[HEAT_CAPACITY][iS4 - maxelm];
		}
		if (iB4 > -1) {
			if (!bB4) heatB4 = prop[HEAT_CAPACITY][iB4]; else heatB4 = prop_b[HEAT_CAPACITY][iB4 - maxelm];
		}

		doublereal heate2 = 0.0, heatw2 = 0.0, heatn2 = 0.0, heats2 = 0.0, heatt2 = 0.0, heatb2 = 0.0;
		doublereal heate3 = 0.0, heatw3 = 0.0, heatn3 = 0.0, heats3 = 0.0, heatt3 = 0.0, heatb3 = 0.0;
		doublereal heate4 = 0.0, heatw4 = 0.0, heatn4 = 0.0, heats4 = 0.0, heatt4 = 0.0, heatb4 = 0.0;

		// Значение теплоёмкости при постоянном давлении на грани КО:
		if (iE2 > -1) {
			heate2 = heatE2 * heatP / (feplus2 * heatE2 + (1.0 - feplus2) * heatP);
		}
		if (iW2 > -1) {
			heatw2 = heatW2 * heatP / (fwplus2 * heatW2 + (1.0 - fwplus2) * heatP);
		}
		if (iN2 > -1) {
			heatn2 = heatN2 * heatP / (fnplus2 * heatN2 + (1.0 - fnplus2) * heatP);
		}
		if (iS2 > -1) {
			heats2 = heatS2 * heatP / (fsplus2 * heatS2 + (1.0 - fsplus2) * heatP);
		}
		if (iT2 > -1) {
			heatt2 = heatT2 * heatP / (ftplus2 * heatT2 + (1.0 - ftplus2) * heatP);
		}
		if (iB2 > -1) {
			heatb2 = heatB2 * heatP / (fbplus2 * heatB2 + (1.0 - fbplus2) * heatP);
		}

		// Значение теплоёмкости при постоянном давлении на грани КО:
		if (iE3 > -1) {
			heate3 = heatE3 * heatP / (feplus3 * heatE3 + (1.0 - feplus3) * heatP);
		}
		if (iW3 > -1) {
			heatw3 = heatW3 * heatP / (fwplus3 * heatW3 + (1.0 - fwplus3) * heatP);
		}
		if (iN3 > -1) {
			heatn3 = heatN3 * heatP / (fnplus3 * heatN3 + (1.0 - fnplus3) * heatP);
		}
		if (iS3 > -1) {
			heats3 = heatS3 * heatP / (fsplus3 * heatS3 + (1.0 - fsplus3) * heatP);
		}
		if (iT3 > -1) {
			heatt3 = heatT3 * heatP / (ftplus3 * heatT3 + (1.0 - ftplus3) * heatP);
		}
		if (iB3 > -1) {
			heatb3 = heatB3 * heatP / (fbplus3 * heatB3 + (1.0 - fbplus3) * heatP);
		}

		// Значение теплоёмкости при постоянном давлении на грани КО:
		if (iE4 > -1) {
			heate4 = heatE4 * heatP / (feplus4 * heatE4 + (1.0 - feplus4) * heatP);
		}
		if (iW4 > -1) {
			heatw4 = heatW4 * heatP / (fwplus4 * heatW4 + (1.0 - fwplus4) * heatP);
		}
		if (iN4 > -1) {
			heatn4 = heatN4 * heatP / (fnplus4 * heatN4 + (1.0 - fnplus4) * heatP);
		}
		if (iS4 > -1) {
			heats4 = heatS4 * heatP / (fsplus4 * heatS4 + (1.0 - fsplus4) * heatP);
		}
		if (iT4 > -1) {
			heatt4 = heatT4 * heatP / (ftplus4 * heatT4 + (1.0 - ftplus4) * heatP);
		}
		if (iB4 > -1) {
			heatb4 = heatB4 * heatP / (fbplus4 * heatB4 + (1.0 - fbplus4) * heatP);
		}


		// конвективные потоки
		doublereal Fe = 0.0, Fw = 0.0, Fn = 0.0, Fs = 0.0, Ft = 0.0, Fb = 0.0;
		// Для АЛИС сетки.
		doublereal Fe1 = 0.0, Fe2 = 0.0, Fe3 = 0.0, Fe4 = 0.0;
		doublereal Fw1 = 0.0, Fw2 = 0.0, Fw3 = 0.0, Fw4 = 0.0;
		doublereal Fn1 = 0.0, Fn2 = 0.0, Fn3 = 0.0, Fn4 = 0.0;
		doublereal Fs1 = 0.0, Fs2 = 0.0, Fs3 = 0.0, Fs4 = 0.0;
		doublereal Ft1 = 0.0, Ft2 = 0.0, Ft3 = 0.0, Ft4 = 0.0;
		doublereal Fb1 = 0.0, Fb2 = 0.0, Fb3 = 0.0, Fb4 = 0.0;


		if ((ptr != nullptr) && (bconvective))
		{
			// Если ptr==nullptr то отсутствует связь с гидродинамической частью и это означает
			// просто то что гидродинамической части нет как таковой и мы находимся в условиях
			// чистой теплопередачи внутри твёрдого тела.

			if (ptr[1][iP] != -1) {

				// АЛИС сетка !!! 9 августа 2017.
				// Используется простая линейная интерполяция, на первых порах совсем без использования поправки Рхи-Чоу.

				if (ptr[0][iP] > -1) {

					// ВНИМАНИЕ !!! Fg нужно позже домножить на площадь соответствующей грани контрольного объёма.

					if ((iE > -1) && (!bE) && (ptr[0][iE] > -1)) {
						// Внутренний узел if (!bE).
						Fe1 = heate*(feplus*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iE]] + (1.0 - feplus)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bE) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
							Fe1 = heate * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]];
						}
					}
					if ((iW > -1) && (!bW) && (ptr[0][iW] > -1)) {
						// Внутренний узел if (!bW).
						Fw1 = heatw*(fwplus*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iW]] + (1.0 - fwplus)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bW) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]>-1) {
							Fw1 = heatw * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]];
						}
					}
					if ((iN > -1) && (!bN) && (ptr[0][iN] > -1)) {
						Fn1 = heatn*(fnplus*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iN]] + (1.0 - fnplus)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bN) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]>-1) {
							Fn1 = heatn * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]];
						}
					}
					if ((iS > -1) && (!bS) && (ptr[0][iS] > -1)) {
						Fs1 = heats*(fsplus*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iS]] + (1.0 - fsplus)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bS) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]>-1) {
							Fs1 = heats * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]];
						}
					}
					if ((iT > -1) && (!bT) && (ptr[0][iT] > -1)) {
						Ft1 = heatt*(ftplus*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iT]] + (1.0 - ftplus)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bT) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]>-1) {
							Ft1 = heatt * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]];
						}
					}
					if ((iB > -1) && (!bB) && (ptr[0][iB] > -1)) {
						Fb1 = heatb*(fbplus*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iB]] + (1.0 - fbplus)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bB) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]>-1) {
							Fb1 = heatb * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]];
						}
					}
					//***
					if ((iE2 > -1) && (!bE2) && (ptr[0][iE2] > -1)) {
						Fe2 = heate2*(feplus2*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iE2]] + (1.0 - feplus2)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bE2) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
							Fe2 = heate2 * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]];
						}
					}
					if ((iW2 > -1) && (!bW2) && (ptr[0][iW2] > -1)) {
						Fw2 = heatw2*(fwplus2*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iW2]] + (1.0 - fwplus2)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bW2) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
							Fw2 = heatw2 * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]];
						}
					}
					if ((iN2 > -1) && (!bN2) && (ptr[0][iN2] > -1)) {
						Fn2 = heatn2*(fnplus2*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iN2]] + (1.0 - fnplus2)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bN2) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
							Fn2 = heatn2 * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]];
						}
					}
					if ((iS2 > -1) && (!bS2) && (ptr[0][iS2] > -1)) {
						Fs2 = heats2*(fsplus2*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iS2]] + (1.0 - fsplus2)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bS2) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
							Fs2 = heats2 * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]];
						}
					}
					if ((iT2 > -1) && (!bT2) && (ptr[0][iT2] > -1)) {
						Ft2 = heatt2*(ftplus2*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iT2]] + (1.0 - ftplus2)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bT2) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]>-1) {
							Ft2 = heatt2 * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]];
						}
					}
					if ((iB2 > -1) && (!bB2) && (ptr[0][iB2] > -1)) {
						Fb2 = heatb2*(fbplus2*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iB2]] + (1.0 - fbplus2)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bB2) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
							Fb2 = heatb2 * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]];
						}
					}
					//***
					if ((iE3 > -1) && (!bE3) && (ptr[0][iE3] > -1)) {
						Fe3 = heate3*(feplus3*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iE3]] + (1.0 - feplus3)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bE3) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]>-1) {
							Fe3 = heate3 * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]];
						}
					}
					if ((iW3 > -1) && (!bW3) && (ptr[0][iW3] > -1)) {
						Fw3 = heatw3*(fwplus3*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iW3]] + (1.0 - fwplus3)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bW3) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]>-1) {
							Fw3 = heatw3 * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]];
						}
					}
					if ((iN3 > -1) && (!bN3) && (ptr[0][iN3] > -1)) {
						Fn3 = heatn3*(fnplus3*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iN3]] + (1.0 - fnplus3)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bN3) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]>-1) {
							Fn3 = heatn3 * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]];
						}
					}
					if ((iS3 > -1) && (!bS3) && (ptr[0][iS3] > -1)) {
						Fs3 = heats3*(fsplus3*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iS3]] + (1.0 - fsplus3)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bS3) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]>-1) {
							Fs3 = heats3 * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]];
						}
					}
					if ((iT3 > -1) && (!bT3) && (ptr[0][iT3] > -1)) {
						Ft3 = heatt3*(ftplus3*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iT3]] + (1.0 - ftplus3)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bT3) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]>-1) {
							Ft3 = heatt3 * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]];
						}
					}
					if ((iB3 > -1) && (!bB3) && (ptr[0][iB3] > -1)) {
						Fb3 = heatb3*(fbplus3*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iB3]] + (1.0 - ftplus3)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bB3) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]>-1) {
							Fb3 = heatb3 * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]];
						}
					}
					//***
					if ((iE4 > -1) && (!bE4) && (ptr[0][iE4] > -1)) {
						Fe4 = heate4*(feplus4*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iE4]] + (1.0 - feplus4)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bE4) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]>-1) {
							Fe4 = heate4 * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]];
						}
					}
					if ((iW4 > -1) && (!bW4) && (ptr[0][iW4] > -1)) {
						Fw4 = heatw4*(fwplus4*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iW4]] + (1.0 - fwplus4)*f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][ptr[0][iP]]);
					}
					else if (bW4) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]>-1) {
							Fw4 = heatw4 * f[ptr[1][iP]].potent[VELOCITY_X_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]];
						}
					}
					if ((iN4 > -1) && (!bN4) && (ptr[0][iN4] > -1)) {
						Fn4 = heatn4*(fnplus4*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iN4]] + (1.0 - fnplus4)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bN4) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]>-1) {
							Fn4 = heatn4 * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]];
						}
					}
					if ((iS4 > -1) && (!bS4) && (ptr[0][iS4] > -1)) {
						Fs4 = heats4*(fsplus4*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iS4]] + (1.0 - fsplus4)*f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][ptr[0][iP]]);
					}
					else if (bS4) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]>-1) {
							Fs4 = heats4 * f[ptr[1][iP]].potent[VELOCITY_Y_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]];
						}
					}
					if ((iT4 > -1) && (!bT4) && (ptr[0][iT4] > -1)) {
						Ft4 = heatt4*(ftplus4*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iT4]] + (1.0 - ftplus4)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bT4) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]>-1) {
							Ft4 = heatt4 * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]];
						}
					}
					if ((iB4 > -1) && (!bB4) && (ptr[0][iB4] > -1)) {
						Fb4 = heatb4*(fbplus4*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iB4]] + (1.0 - fbplus4)*f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][ptr[0][iP]]);
					}
					else if (bB4) {
						if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]>-1) {
							Fb4 = heatb4 * f[ptr[1][iP]].potent[VELOCITY_Z_COMPONENT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]];
						}
					}
					// patch 08.01.2020
					Fe *= rhoe; Fe1 *= rhoe; Fe2 *= rhoe2; Fe3 *= rhoe3; Fe4 *= rhoe4;
					Fn *= rhon; Fn1 *= rhon; Fn2 *= rhon2; Fn3 *= rhon3; Fn4 *= rhon4;
					Fw *= rhow; Fw1 *= rhow; Fw2 *= rhow2; Fw3 *= rhow3; Fw4 *= rhow4;
					Fs *= rhos; Fs1 *= rhos; Fs2 *= rhos2; Fs3 *= rhos3; Fs4 *= rhos4;
					Ft *= rhot; Ft1 *= rhot; Ft2 *= rhot2; Ft3 *= rhot3; Ft4 *= rhot4;
					Fb *= rhob; Fb1 *= rhob; Fb2 *= rhob2; Fb3 *= rhob3; Fb4 *= rhob4;

					/*// debug сюда заходит при АЛИС сетке. И значения не нулевые Ок.
					if (fabs(Fe1) + fabs(Fe2) + fabs(Fe3) + fabs(Fe4) + fabs(Fw1) + fabs(Fw2) + fabs(Fw3) + fabs(Fw4) +
					fabs(Fn1) + fabs(Fn2) + fabs(Fn3) + fabs(Fn4) + fabs(Fs1) + fabs(Fs2) + fabs(Fs3) + fabs(Fs4) +
					fabs(Ft1) + fabs(Ft2) + fabs(Ft3) + fabs(Ft4) + fabs(Fb1) + fabs(Fb2) + fabs(Fb3) + fabs(Fb4) > 0.1) {
					printf("Fe1=%e Fe2=%e Fe3=%e Fe4=%e Fw=%e Fw2=%e Fw3=%e Fw4=%e \n",Fe1,Fe2,Fe3,Fe4, Fw1, Fw2, Fw3, Fw4);
					printf("Fn1=%e Fn2=%e Fn3=%e Fn4=%e Fs=%e Fs2=%e Fs3=%e Fs4=%e \n", Fn1, Fn2, Fn3, Fn4, Fs1, Fs2, Fs3, Fs4);
					printf("Fe1=%e Fe2=%e Fe3=%e Fe4=%e Fw=%e Fw2=%e Fw3=%e Fw4=%e \n", Ft1, Ft2, Ft3, Ft4, Fb1, Fb2, Fb3, Fb4);
					getchar();
					}
					*/

				}


#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				// Для АЛИС сетки.
				if (Fe1 != Fe1) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fe1=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fe1);
					system("PAUSE");
				}
				if (Fw1 != Fw1) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fw1=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fw1);
					system("PAUSE");
				}
				if (Fn1 != Fn1) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fn1=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fn1);
					system("PAUSE");
				}
				if (Fs1 != Fs1) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fs1=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fs1);
					system("PAUSE");
				}
				if (Ft1 != Ft1) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Ft1=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ft1);
					system("PAUSE");
				}
				if (Fb1 != Fb1) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fb1=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fb1);
					system("PAUSE");
				}
				if (Fe2 != Fe2) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fe2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fe2);
					system("PAUSE");
				}
				if (Fw2 != Fw2) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fw2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fw2);
					system("PAUSE");
				}
				if (Fn2 != Fn2) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fn2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fn2);
					system("PAUSE");
				}
				if (Fs2 != Fs2) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fs2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fs2);
					system("PAUSE");
				}
				if (Ft2 != Ft2) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Ft2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ft2);
					system("PAUSE");
				}
				if (Fb2 != Fb2) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fb2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fb2);
					system("PAUSE");
				}
				if (Fe3 != Fe3) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fe3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fe3);
					system("PAUSE");
				}
				if (Fw3 != Fw3) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fw3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fw3);
					system("PAUSE");
				}
				if (Fn3 != Fn3) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fn3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fn3);
					system("PAUSE");
				}
				if (Fs3 != Fs3) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fs3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fs3);
					system("PAUSE");
				}
				if (Ft3 != Ft3) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Ft3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ft3);
					system("PAUSE");
				}
				if (Fb3 != Fb3) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fb3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fb3);
					system("PAUSE");
				}
				if (Fe4 != Fe4) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fe4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fe4);
					system("PAUSE");
				}
				if (Fw4 != Fw4) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fw4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fw4);
					system("PAUSE");
				}
				if (Fn4 != Fn4) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fn4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fn4);
					system("PAUSE");
				}
				if (Fs4 != Fs4) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fs4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fs4);
					system("PAUSE");
				}
				if (Ft4 != Ft4) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Ft4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ft4);
					system("PAUSE");
				}
				if (Fb4 != Fb4) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fb4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fb4);
					system("PAUSE");
				}
#endif
			}
		}


		// коэффициенты диффузии:
		doublereal GP = 0.0, GE = 0.0, GW = 0.0, GN = 0.0, GS = 0.0, GT = 0.0, GB = 0.0;

		GP = prop[LAM][iP];
		if (iE > -1) {
			if (!bE) GE = prop[LAM][iE]; else GE = prop_b[LAM][iE - maxelm];
		}
		if (iN > -1) {
			if (!bN) GN = prop[LAM][iN]; else GN = prop_b[LAM][iN - maxelm];
		}
		if (iT > -1) {
			if (!bT) GT = prop[LAM][iT]; else GT = prop_b[LAM][iT - maxelm];
		}
		if (iW > -1) {
			if (!bW) GW = prop[LAM][iW]; else GW = prop_b[LAM][iW - maxelm];
		}
		if (iS > -1) {
			if (!bS) GS = prop[LAM][iS]; else GS = prop_b[LAM][iS - maxelm];
		}
		if (iB > -1) {
			if (!bB) GB = prop[LAM][iB]; else GB = prop_b[LAM][iB - maxelm];
		}

		doublereal GE2 = 0.0, GW2 = 0.0, GN2 = 0.0, GS2 = 0.0, GT2 = 0.0, GB2 = 0.0;
		doublereal GE3 = 0.0, GW3 = 0.0, GN3 = 0.0, GS3 = 0.0, GT3 = 0.0, GB3 = 0.0;
		doublereal GE4 = 0.0, GW4 = 0.0, GN4 = 0.0, GS4 = 0.0, GT4 = 0.0, GB4 = 0.0;

		if (b_on_adaptive_local_refinement_mesh) {

			if (iE2 > -1) {
				if (!bE2) GE2 = prop[LAM][iE2]; else GE2 = prop_b[LAM][iE2 - maxelm];
			}
			if (iN2 > -1) {
				if (!bN2) GN2 = prop[LAM][iN2]; else GN2 = prop_b[LAM][iN2 - maxelm];
			}
			if (iT2 > -1) {
				if (!bT2) GT2 = prop[LAM][iT2]; else GT2 = prop_b[LAM][iT2 - maxelm];
			}
			if (iW2 > -1) {
				if (!bW2) GW2 = prop[LAM][iW2]; else GW2 = prop_b[LAM][iW2 - maxelm];
			}
			if (iS2 > -1) {
				if (!bS2) GS2 = prop[LAM][iS2]; else GS2 = prop_b[LAM][iS2 - maxelm];
			}
			if (iB2 > -1) {
				if (!bB2) GB2 = prop[LAM][iB2]; else GB2 = prop_b[LAM][iB2 - maxelm];
			}

			if (iE3 > -1) {
				if (!bE3) GE3 = prop[LAM][iE3]; else GE3 = prop_b[LAM][iE3 - maxelm];
			}
			if (iN3 > -1) {
				if (!bN3) GN3 = prop[LAM][iN3]; else GN3 = prop_b[LAM][iN3 - maxelm];
			}
			if (iT3 > -1) {
				if (!bT3) GT3 = prop[LAM][iT3]; else GT3 = prop_b[LAM][iT3 - maxelm];
			}
			if (iW3 > -1) {
				if (!bW3) GW3 = prop[LAM][iW3]; else GW3 = prop_b[LAM][iW3 - maxelm];
			}
			if (iS3 > -1) {
				if (!bS3) GS3 = prop[LAM][iS3]; else GS3 = prop_b[LAM][iS3 - maxelm];
			}
			if (iB3 > -1) {
				if (!bB3) GB3 = prop[LAM][iB3]; else GB3 = prop_b[LAM][iB3 - maxelm];
			}

			if (iE4 > -1) {
				if (!bE4) GE4 = prop[LAM][iE4]; else GE4 = prop_b[LAM][iE4 - maxelm];
			}
			if (iN4 > -1) {
				if (!bN4) GN4 = prop[LAM][iN4]; else GN4 = prop_b[LAM][iN4 - maxelm];
			}
			if (iT4 > -1) {
				if (!bT4) GT4 = prop[LAM][iT4]; else GT4 = prop_b[LAM][iT4 - maxelm];
			}
			if (iW4 > -1) {
				if (!bW4) GW4 = prop[LAM][iW4]; else GW4 = prop_b[LAM][iW4 - maxelm];
			}
			if (iS4 > -1) {
				if (!bS4) GS4 = prop[LAM][iS4]; else GS4 = prop_b[LAM][iS4 - maxelm];
			}
			if (iB4 > -1) {
				if (!bB4) GB4 = prop[LAM][iB4]; else GB4 = prop_b[LAM][iB4 - maxelm];
			}
		}

		/* // Экспериментальный и не рабочий вариант.
		if (!bE) GE=prop[LAM][iE]; else GE=GP;
		if (!bN) GN=prop[LAM][iN]; else GN=GP;
		if (!bT) GT=prop[LAM][iT]; else GT=GP;
		if (!bW) GW=prop[LAM][iW]; else GW=GP;
		if (!bS) GS=prop[LAM][iS]; else GS=GP;
		if (!bB) GB=prop[LAM][iB]; else GB=GP;
		*/

		doublereal Ge = 0.0, Gw = 0.0, Gn = 0.0, Gs = 0.0, Gt = 0.0, Gb = 0.0;

		// Теплопроводность на гранях внутреннего КО:
		if (iE > -1) {
			Ge = GE*GP / (feplus*GE + (1 - feplus)*GP);
		}
		if (iW > -1) {
			Gw = GW*GP / (fwplus*GW + (1 - fwplus)*GP);
		}
		if (iN > -1) {
			Gn = GN*GP / (fnplus*GN + (1 - fnplus)*GP);
		}
		if (iS > -1) {
			Gs = GS*GP / (fsplus*GS + (1 - fsplus)*GP);
		}
		if (iT > -1) {
			Gt = GT*GP / (ftplus*GT + (1 - ftplus)*GP);
		}
		if (iB > -1) {
			Gb = GB*GP / (fbplus*GB + (1 - fbplus)*GP);
		}

		doublereal Ge2 = 0.0, Gw2 = 0.0, Gn2 = 0.0, Gs2 = 0.0, Gt2 = 0.0, Gb2 = 0.0;
		doublereal Ge3 = 0.0, Gw3 = 0.0, Gn3 = 0.0, Gs3 = 0.0, Gt3 = 0.0, Gb3 = 0.0;
		doublereal Ge4 = 0.0, Gw4 = 0.0, Gn4 = 0.0, Gs4 = 0.0, Gt4 = 0.0, Gb4 = 0.0;

		if (b_on_adaptive_local_refinement_mesh) {

			// Теплопроводность на гранях внутреннего КО:
			if (iE2 > -1) {
				Ge2 = GE2 * GP / (feplus2 * GE2 + (1 - feplus2) * GP);
			}
			if (iW2 > -1) {
				Gw2 = GW2 * GP / (fwplus2 * GW2 + (1 - fwplus2) * GP);
			}
			if (iN2 > -1) {
				Gn2 = GN2 * GP / (fnplus2 * GN2 + (1 - fnplus2) * GP);
			}
			if (iS2 > -1) {
				Gs2 = GS2 * GP / (fsplus2 * GS2 + (1 - fsplus2) * GP);
			}
			if (iT2 > -1) {
				Gt2 = GT2 * GP / (ftplus2 * GT2 + (1 - ftplus2) * GP);
			}
			if (iB2 > -1) {
				Gb2 = GB2 * GP / (fbplus2 * GB2 + (1 - fbplus2) * GP);
			}

			// Теплопроводность на гранях внутреннего КО:
			if (iE3 > -1) {
				Ge3 = GE3 * GP / (feplus3 * GE3 + (1 - feplus3) * GP);
			}
			if (iW3 > -1) {
				Gw3 = GW3 * GP / (fwplus3 * GW3 + (1 - fwplus3) * GP);
			}
			if (iN3 > -1) {
				Gn3 = GN3 * GP / (fnplus3 * GN3 + (1 - fnplus3) * GP);
			}
			if (iS3 > -1) {
				Gs3 = GS3 * GP / (fsplus3 * GS3 + (1 - fsplus3) * GP);
			}
			if (iT3 > -1) {
				Gt3 = GT3 * GP / (ftplus3 * GT3 + (1 - ftplus3) * GP);
			}
			if (iB3 > -1) {
				Gb3 = GB3 * GP / (fbplus3 * GB3 + (1 - fbplus3) * GP);
			}

			// Теплопроводность на гранях внутреннего КО:
			if (iE4 > -1) {
				Ge4 = GE4 * GP / (feplus4 * GE4 + (1 - feplus4) * GP);
			}
			if (iW4 > -1) {
				Gw4 = GW4 * GP / (fwplus4 * GW4 + (1 - fwplus4) * GP);
			}
			if (iN4 > -1) {
				Gn4 = GN4 * GP / (fnplus4 * GN4 + (1 - fnplus4) * GP);
			}
			if (iS4 > -1) {
				Gs4 = GS4 * GP / (fsplus4 * GS4 + (1 - fsplus4) * GP);
			}
			if (iT4 > -1) {
				Gt4 = GT4 * GP / (ftplus4 * GT4 + (1 - ftplus4) * GP);
			}
			if (iB4 > -1) {
				Gb4 = GB4 * GP / (fbplus4 * GB4 + (1 - fbplus4) * GP);
			}

		}

		bool bortho86 = false;
		// Теплопроводность на грани является ортотропной 
		// если два контрольных объёма окружающие грань 
		// имеют одинаковый коэффициент ортотропности.
		if ((ptr != nullptr) && (ptr[1][iP] == -1)) {
			bortho86 = true;
		}
		else if ((ptr != nullptr) && (ptr[1][iP] != -1)) {
			// Жидкая зона ортотропности просто нет.
			bortho86 = false;
		}
		else {
			bortho86 = true;
		}

		if (bortho86) {
			// Корректировка за счёт ортотропности:
			if (iE > -1) {
				if (iE >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iE - maxelm]) < 1.0e-23) {
						Ge *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					//if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iE]) < 1.0e-23) {
					//Ge *= prop[MULT_LAM_X][iP];
					//}
					// Дает температуру более близкую к истинной.
					//Ge *= 2.0*(prop[MULT_LAM_X][iE])*(prop[MULT_LAM_X][iP]) / (prop[MULT_LAM_X][iP] + prop[MULT_LAM_X][iE]);
					Ge *= fmax(prop[MULT_LAM_X][iE], prop[MULT_LAM_X][iP]);
				}
			}
			if (iW > -1) {
				if (iW >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iW - maxelm]) < 1.0e-23) {
						Gw *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					//if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iW]) < 1.0e-23) {
					//Gw *= prop[MULT_LAM_X][iP];
					//}
					// Дает температуру более близкую к истинной.
					//Gw *= 2.0*(prop[MULT_LAM_X][iW])*(prop[MULT_LAM_X][iP]) / (prop[MULT_LAM_X][iP] + prop[MULT_LAM_X][iW]);
					Gw *= fmax(prop[MULT_LAM_X][iW], prop[MULT_LAM_X][iP]);
				}
			}
			if (iN > -1) {
				if (iN >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iN - maxelm]) < 1.0e-23) {
						Gn *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					//if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iN]) < 1.0e-23) {
					//Gn *= prop[MULT_LAM_Y][iP];
					//}
					// Дает температуру более близкую к истинной.
					//Gn *= 2.0*(prop[MULT_LAM_Y][iN])*(prop[MULT_LAM_Y][iP]) / (prop[MULT_LAM_Y][iP] + prop[MULT_LAM_Y][iN]);
					Gn *= fmax(prop[MULT_LAM_Y][iN], prop[MULT_LAM_Y][iP]);
				}
			}
			if (iS > -1) {
				if (iS >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iS - maxelm]) < 1.0e-23) {
						Gs *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					//if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iS]) < 1.0e-23) {
					//Gs *= prop[MULT_LAM_Y][iP];
					//}
					// Дает температуру более близкую к истинной.
					//Gs *= 2.0*(prop[MULT_LAM_Y][iS])*(prop[MULT_LAM_Y][iP]) / (prop[MULT_LAM_Y][iP] + prop[MULT_LAM_Y][iS]);
					Gs *= fmax(prop[MULT_LAM_Y][iS], prop[MULT_LAM_Y][iP]);
				}
			}
			if (iT > -1) {
				if (iT >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iT - maxelm]) < 1.0e-23) {
						Gt *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					//if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iT]) < 1.0e-23) {
					//Gt *= prop[MULT_LAM_Z][iP];
					//}
					// Дает температуру более близкую к истинной.
					//Gt *= 2.0*(prop[MULT_LAM_Z][iT])*(prop[MULT_LAM_Z][iP]) / (prop[MULT_LAM_Z][iP] + prop[MULT_LAM_Z][iT]);
					Gt *= fmax(prop[MULT_LAM_Z][iT], prop[MULT_LAM_Z][iP]);
				}
			}
			if (iB > -1) {
				if (iB >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iB - maxelm]) < 1.0e-23) {
						Gb *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					// Занижено, температура будет повыше.
					//if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iB]) < 1.0e-23) {
					//Gb *= prop[MULT_LAM_Z][iP];
					//}
					// Дает температуру более близкую к истинной.
					//Gb *= 2.0*(prop[MULT_LAM_Z][iB])*(prop[MULT_LAM_Z][iP]) / (prop[MULT_LAM_Z][iP]+ prop[MULT_LAM_Z][iB]);
					Gb *= fmax(prop[MULT_LAM_Z][iB], prop[MULT_LAM_Z][iP]);
				}
			}


			// Корректировка за счёт ортотропности:
			if (iE2 > -1) {
				if (iE2 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iE2 - maxelm]) < 1.0e-23) {
						Ge2 *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iE2]) < 1.0e-23) {
						Ge2 *= prop[MULT_LAM_X][iP];
					}
				}
			}
			if (iW2 > -1) {
				if (iW2 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iW2 - maxelm]) < 1.0e-23) {
						Gw2 *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iW2]) < 1.0e-23) {
						Gw2 *= prop[MULT_LAM_X][iP];
					}
				}
			}
			if (iN2 > -1) {
				if (iN2 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iN2 - maxelm]) < 1.0e-23) {
						Gn2 *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iN2]) < 1.0e-23) {
						Gn2 *= prop[MULT_LAM_Y][iP];
					}
				}
			}
			if (iS2 > -1) {
				if (iS2 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iS2 - maxelm]) < 1.0e-23) {
						Gs2 *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iS2]) < 1.0e-23) {
						Gs2 *= prop[MULT_LAM_Y][iP];
					}
				}
			}
			if (iT2 > -1) {
				if (iT2 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iT2 - maxelm]) < 1.0e-23) {
						Gt2 *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iT2]) < 1.0e-23) {
						Gt2 *= prop[MULT_LAM_Z][iP];
					}
				}
			}
			if (iB2 > -1) {
				if (iB2 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iB2 - maxelm]) < 1.0e-23) {
						Gb2 *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iB2]) < 1.0e-23) {
						Gb2 *= prop[MULT_LAM_Z][iP];
					}
				}
			}


			// Корректировка за счёт ортотропности:
			if (iE3 > -1) {
				if (iE3 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iE3 - maxelm]) < 1.0e-23) {
						Ge3 *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iE3]) < 1.0e-23) {
						Ge3 *= prop[MULT_LAM_X][iP];
					}
				}
			}
			if (iW3 > -1) {
				if (iW3 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iW3 - maxelm]) < 1.0e-23) {
						Gw3 *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iW3]) < 1.0e-23) {
						Gw3 *= prop[MULT_LAM_X][iP];
					}
				}
			}
			if (iN3 > -1) {
				if (iN3 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iN3 - maxelm]) < 1.0e-23) {
						Gn3 *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iN3]) < 1.0e-23) {
						Gn3 *= prop[MULT_LAM_Y][iP];
					}
				}
			}
			if (iS3 > -1) {
				if (iS3 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iS3 - maxelm]) < 1.0e-23) {
						Gs3 *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iS3]) < 1.0e-23) {
						Gs3 *= prop[MULT_LAM_Y][iP];
					}
				}
			}
			if (iT3 > -1) {
				if (iT3 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iT3 - maxelm]) < 1.0e-23) {
						Gt3 *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iT3]) < 1.0e-23) {
						Gt3 *= prop[MULT_LAM_Z][iP];
					}
				}
			}
			if (iB3 > -1) {
				if (iB3 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iB3 - maxelm]) < 1.0e-23) {
						Gb3 *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iB3]) < 1.0e-23) {
						Gb3 *= prop[MULT_LAM_Z][iP];
					}
				}
			}

			// Корректировка за счёт ортотропности:
			if (iE4 > -1) {
				if (iE4 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iE4 - maxelm]) < 1.0e-23) {
						Ge4 *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iE4]) < 1.0e-23) {
						Ge4 *= prop[MULT_LAM_X][iP];
					}
				}
			}
			if (iW4 > -1) {
				if (iW4 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iW4 - maxelm]) < 1.0e-23) {
						Gw4 *= prop[MULT_LAM_X][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iW4]) < 1.0e-23) {
						Gw4 *= prop[MULT_LAM_X][iP];
					}
				}
			}
			if (iN4 > -1) {
				if (iN4 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iN4 - maxelm]) < 1.0e-23) {
						Gn4 *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iN4]) < 1.0e-23) {
						Gn4 *= prop[MULT_LAM_Y][iP];
					}
				}
			}
			if (iS4 > -1) {
				if (iS4 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iS4 - maxelm]) < 1.0e-23) {
						Gs4 *= prop[MULT_LAM_Y][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iS4]) < 1.0e-23) {
						Gs4 *= prop[MULT_LAM_Y][iP];
					}
				}
			}
			if (iT4 > -1) {
				if (iT4 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iT4 - maxelm]) < 1.0e-23) {
						Gt4 *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iT4]) < 1.0e-23) {
						Gt4 *= prop[MULT_LAM_Z][iP];
					}
				}
			}
			if (iB4 > -1) {
				if (iB4 >= maxelm) {
					// Граничный узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iB4 - maxelm]) < 1.0e-23) {
						Gb4 *= prop[MULT_LAM_Z][iP];
					}
				}
				else {
					// Внутренний узел.
					if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iB4]) < 1.0e-23) {
						Gb4 *= prop[MULT_LAM_Z][iP];
					}
				}
			}

		}

		// до.
		// контроль коэффициента теплопроводности:
		//printf("Ge=%e, Gw=%e, Gn=%e, Gs=%e, Gt=%e, Gb=%e\n",Ge,Gw,Gn,Gs,Gt,Gb);

		// Добавляем турбулентную теплопроводность.
		if (bconvective) {
			if (ptr != nullptr) {

				// закомментировано 15.04.2019.
				//if (!b_on_adaptive_local_refinement_mesh) 
				{

					// Если мы имеем чисто твёрдотельную задачу, то в ней данный код не участвует,
					// так как связан с турбулентным добавком к теплопроводности.
					const doublereal dTurbulentPrandtlNumber = 0.85;

					if (iE > -1) {
						if (!bE) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iE] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iE] * f[ptr[1][iE]].potent[MUT][ptr[0][iE]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpe = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iE] / ((1.0 - feplus)*prop[HEAT_CAPACITY][iP] + feplus*prop[HEAT_CAPACITY][iE]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]>-1) {
										Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]>-1) {
										Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]>-1) {
										Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]>-1) {
										Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}

								}
								else if ((bsolidP) && ((f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE]]>-1) {
										Ge += cpe*f[ptr[1][iE]].potent[MUT][f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE]]>-1) {
										Ge += cpe*f[ptr[1][iE]].potent[MUT][f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE]]>-1) {
										Ge += cpe*f[ptr[1][iE]].potent[MUT][f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE]]>-1) {
										Ge += cpe*f[ptr[1][iE]].potent[MUT][f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE]]] / dTurbulentPrandtlNumber;
									}

								}

							}
							else if (!(bsolidS && bsolidP)) {
								Ge += feplus*turblamS + (1.0 - feplus)*turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpe = prop_b[HEAT_CAPACITY][iE - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]>-1) {
										Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]>-1) {
										Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]>-1) {
										Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]>-1) {
										Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}



					if (iE2 > -1) {
						if (!bE2) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iE2] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iE2] * f[ptr[1][iE2]].potent[MUT][ptr[0][iE2]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpe = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iE2] / ((1.0 - feplus2) * prop[HEAT_CAPACITY][iP] + feplus2 * prop[HEAT_CAPACITY][iE2]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE2]] > -1) {
										Ge2 += cpe * f[ptr[1][iE2]].potent[MUT][f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE2]] > -1) {
										Ge2 += cpe * f[ptr[1][iE2]].potent[MUT][f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE2]] > -1) {
										Ge2 += cpe * f[ptr[1][iE2]].potent[MUT][f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE2]] > -1) {
										Ge2 += cpe * f[ptr[1][iE2]].potent[MUT][f[ptr[1][iE2]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE2]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Ge2 += feplus2 * turblamS + (1.0 - feplus2) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpe = prop_b[HEAT_CAPACITY][iE2 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
										Ge2 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iE3 > -1) {
						if (!bE3) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iE3] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iE3] * f[ptr[1][iE3]].potent[MUT][ptr[0][iE3]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpe = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iE3] / ((1.0 - feplus3) * prop[HEAT_CAPACITY][iP] + feplus3 * prop[HEAT_CAPACITY][iE3]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}

								}
								else if ((bsolidP) && ((f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE3]] > -1) {
										Ge3 += cpe * f[ptr[1][iE3]].potent[MUT][f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE3]] > -1) {
										Ge3 += cpe * f[ptr[1][iE3]].potent[MUT][f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE3]] > -1) {
										Ge3 += cpe * f[ptr[1][iE3]].potent[MUT][f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE3]] > -1) {
										Ge3 += cpe * f[ptr[1][iE3]].potent[MUT][f[ptr[1][iE3]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE3]]] / dTurbulentPrandtlNumber;
									}

								}

							}
							else if (!(bsolidS && bsolidP)) {
								Ge3 += feplus3 * turblamS + (1.0 - feplus3) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpe = prop_b[HEAT_CAPACITY][iE3 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
										Ge3 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iE4 > -1) {
						if (!bE4) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iE4] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iE4] * f[ptr[1][iE4]].potent[MUT][ptr[0][iE4]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpe = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iE4] / ((1.0 - feplus4) * prop[HEAT_CAPACITY][iP] + feplus4 * prop[HEAT_CAPACITY][iE4]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}

								}
								else if ((bsolidP) && ((f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iE4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE4]] > -1) {
										Ge4 += cpe * f[ptr[1][iE4]].potent[MUT][f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE4]] > -1) {
										Ge4 += cpe * f[ptr[1][iE4]].potent[MUT][f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE4]] > -1) {
										Ge4 += cpe * f[ptr[1][iE4]].potent[MUT][f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE4]] > -1) {
										Ge4 += cpe * f[ptr[1][iE4]].potent[MUT][f[ptr[1][iE4]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE4]]] / dTurbulentPrandtlNumber;
									}

								}

							}
							else if (!(bsolidS && bsolidP)) {
								Ge4 += feplus4 * turblamS + (1.0 - feplus4) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpe = prop_b[HEAT_CAPACITY][iE4 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
										Ge4 += cpe * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}


					if (iN2 > -1) {
						if (!bN2) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iN2] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iN2] * f[ptr[1][iN2]].potent[MUT][ptr[0][iN2]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpn = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iN2] / ((1.0 - fnplus2) * prop[HEAT_CAPACITY][iP] + fnplus2 * prop[HEAT_CAPACITY][iN2]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN2]] > -1) {
										Gn2 += cpn * f[ptr[1][iN2]].potent[MUT][f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN2]] > -1) {
										Gn2 += cpn * f[ptr[1][iN2]].potent[MUT][f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN2]] > -1) {
										Gn2 += cpn * f[ptr[1][iN2]].potent[MUT][f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN2]] > -1) {
										Gn2 += cpn * f[ptr[1][iN2]].potent[MUT][f[ptr[1][iN2]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN2]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gn2 += fnplus2 * turblamS + (1.0 - fnplus2) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpn = prop_b[HEAT_CAPACITY][iN2 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn2 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iN3 > -1) {
						if (!bN3) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iN3] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iN3] * f[ptr[1][iN3]].potent[MUT][ptr[0][iN3]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpn = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iN3] / ((1.0 - fnplus3) * prop[HEAT_CAPACITY][iP] + fnplus3 * prop[HEAT_CAPACITY][iN3]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN3]] > -1) {
										Gn3 += cpn * f[ptr[1][iN3]].potent[MUT][f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN3]] > -1) {
										Gn3 += cpn * f[ptr[1][iN3]].potent[MUT][f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN3]] > -1) {
										Gn3 += cpn * f[ptr[1][iN3]].potent[MUT][f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN3]] > -1) {
										Gn3 += cpn * f[ptr[1][iN3]].potent[MUT][f[ptr[1][iN3]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN3]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gn3 += fnplus3 * turblamS + (1.0 - fnplus3) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpn = prop_b[HEAT_CAPACITY][iN3 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn3 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iN4 > -1) {
						if (!bN4) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iN4] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iN4] * f[ptr[1][iN4]].potent[MUT][ptr[0][iN4]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpn = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iN4] / ((1.0 - fnplus4) * prop[HEAT_CAPACITY][iP] + fnplus4 * prop[HEAT_CAPACITY][iN4]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN4]] > -1) {
										Gn4 += cpn * f[ptr[1][iN4]].potent[MUT][f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN4]] > -1) {
										Gn4 += cpn * f[ptr[1][iN4]].potent[MUT][f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN4]] > -1) {
										Gn4 += cpn * f[ptr[1][iN4]].potent[MUT][f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN4]] > -1) {
										Gn4 += cpn * f[ptr[1][iN4]].potent[MUT][f[ptr[1][iN4]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN4]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gn4 += fnplus4 * turblamS + (1.0 - fnplus4) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpn = prop_b[HEAT_CAPACITY][iN4 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn4 += cpn * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}


					if (iT2 > -1) {
						if (!bT2) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iT2] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iT2] * f[ptr[1][iT2]].potent[MUT][ptr[0][iT2]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpt = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iT2] / ((1.0 - ftplus2) * prop[HEAT_CAPACITY][iP] + ftplus2 * prop[HEAT_CAPACITY][iT2]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT2]] > -1) {
										Gt2 += cpt * f[ptr[1][iT2]].potent[MUT][f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT2]] > -1) {
										Gt2 += cpt * f[ptr[1][iT2]].potent[MUT][f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT2]] > -1) {
										Gt2 += cpt * f[ptr[1][iT2]].potent[MUT][f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT2]] > -1) {
										Gt2 += cpt * f[ptr[1][iT2]].potent[MUT][f[ptr[1][iT2]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT2]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gt2 += ftplus2 * turblamS + (1.0 - ftplus2) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpt = prop_b[HEAT_CAPACITY][iT2 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt2 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iT3 > -1) {
						if (!bT3) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iT3] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iT3] * f[ptr[1][iT3]].potent[MUT][ptr[0][iT3]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpt = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iT3] / ((1.0 - ftplus3) * prop[HEAT_CAPACITY][iP] + ftplus3 * prop[HEAT_CAPACITY][iT3]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT3]] > -1) {
										Gt3 += cpt * f[ptr[1][iT3]].potent[MUT][f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT3]] > -1) {
										Gt3 += cpt * f[ptr[1][iT3]].potent[MUT][f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT3]] > -1) {
										Gt3 += cpt * f[ptr[1][iT3]].potent[MUT][f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT3]] > -1) {
										Gt3 += cpt * f[ptr[1][iT3]].potent[MUT][f[ptr[1][iT3]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT3]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gt3 += ftplus3 * turblamS + (1.0 - ftplus3) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpt = prop_b[HEAT_CAPACITY][iT3 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt3 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iT4 > -1) {
						if (!bT4) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iT4] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iT4] * f[ptr[1][iT4]].potent[MUT][ptr[0][iT4]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpt = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iT4] / ((1.0 - ftplus4) * prop[HEAT_CAPACITY][iP] + ftplus4 * prop[HEAT_CAPACITY][iT4]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT4]] > -1) {
										Gt4 += cpt * f[ptr[1][iT4]].potent[MUT][f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT4]] > -1) {
										Gt4 += cpt * f[ptr[1][iT4]].potent[MUT][f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT4]] > -1) {
										Gt4 += cpt * f[ptr[1][iT4]].potent[MUT][f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT4]] > -1) {
										Gt4 += cpt * f[ptr[1][iT4]].potent[MUT][f[ptr[1][iT4]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT4]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gt4 += ftplus4 * turblamS + (1.0 - ftplus4) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpt = prop_b[HEAT_CAPACITY][iT4 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt4 += cpt * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}


					if (iW2 > -1) {
						if (!bW2) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iW2] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iW2] * f[ptr[1][iW2]].potent[MUT][ptr[0][iW2]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpw = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iW2] / ((1.0 - fwplus2) * prop[HEAT_CAPACITY][iP] + fwplus2 * prop[HEAT_CAPACITY][iW2]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW2]] > -1) {
										Gw2 += cpw * f[ptr[1][iW2]].potent[MUT][f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW2]] > -1) {
										Gw2 += cpw * f[ptr[1][iW2]].potent[MUT][f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW2]] > -1) {
										Gw2 += cpw * f[ptr[1][iW2]].potent[MUT][f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW2]] > -1) {
										Gw2 += cpw * f[ptr[1][iW2]].potent[MUT][f[ptr[1][iW2]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW2]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gw2 += fwplus2 * turblamS + (1.0 - fwplus2) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpw = prop_b[HEAT_CAPACITY][iW2 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw2 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iW3 > -1) {
						if (!bW3) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iW3] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iW3] * f[ptr[1][iW3]].potent[MUT][ptr[0][iW3]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpw = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iW3] / ((1.0 - fwplus3) * prop[HEAT_CAPACITY][iP] + fwplus3 * prop[HEAT_CAPACITY][iW3]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW3]] > -1) {
										Gw3 += cpw * f[ptr[1][iW3]].potent[MUT][f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW3]] > -1) {
										Gw3 += cpw * f[ptr[1][iW3]].potent[MUT][f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW3]] > -1) {
										Gw3 += cpw * f[ptr[1][iW3]].potent[MUT][f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW3]] > -1) {
										Gw3 += cpw * f[ptr[1][iW3]].potent[MUT][f[ptr[1][iW3]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW3]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gw3 += fwplus3 * turblamS + (1.0 - fwplus3) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpw = prop_b[HEAT_CAPACITY][iW3 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw3 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iW4 > -1) {
						if (!bW4) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iW4] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iW4] * f[ptr[1][iW4]].potent[MUT][ptr[0][iW4]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpw = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iW4] / ((1.0 - fwplus4) * prop[HEAT_CAPACITY][iP] + fwplus4 * prop[HEAT_CAPACITY][iW4]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW4]] > -1) {
										Gw4 += cpw * f[ptr[1][iW4]].potent[MUT][f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW4]] > -1) {
										Gw4 += cpw * f[ptr[1][iW4]].potent[MUT][f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW4]] > -1) {
										Gw4 += cpw * f[ptr[1][iW4]].potent[MUT][f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW4]] > -1) {
										Gw4 += cpw * f[ptr[1][iW4]].potent[MUT][f[ptr[1][iW4]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW4]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gw4 += fwplus4 * turblamS + (1.0 - fwplus4) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpw = prop_b[HEAT_CAPACITY][iW4 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw4 += cpw * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}


					if (iS2 > -1) {
						if (!bS2) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iS2] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iS2] * f[ptr[1][iS2]].potent[MUT][ptr[0][iS2]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cps = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iS2] / ((1.0 - fsplus2) * prop[HEAT_CAPACITY][iP] + fsplus2 * prop[HEAT_CAPACITY][iS2]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS2]] > -1) {
										Gs2 += cps * f[ptr[1][iS2]].potent[MUT][f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS2]] > -1) {
										Gs2 += cps * f[ptr[1][iS2]].potent[MUT][f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS2]] > -1) {
										Gs2 += cps * f[ptr[1][iS2]].potent[MUT][f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS2]] > -1) {
										Gs2 += cps * f[ptr[1][iS2]].potent[MUT][f[ptr[1][iS2]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS2]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gs2 += fsplus2 * turblamS + (1.0 - fsplus2) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cps = prop_b[HEAT_CAPACITY][iS2 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
										Gs2 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}

								}
							}
						}
					}

					if (iS3 > -1) {
						if (!bS3) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iS3] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iS3] * f[ptr[1][iS3]].potent[MUT][ptr[0][iS3]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cps = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iS3] / ((1.0 - fsplus3) * prop[HEAT_CAPACITY][iP] + fsplus3 * prop[HEAT_CAPACITY][iS3]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS3]] > -1) {
										Gs3 += cps * f[ptr[1][iS3]].potent[MUT][f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS3]] > -1) {
										Gs3 += cps * f[ptr[1][iS3]].potent[MUT][f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS3]] > -1) {
										Gs3 += cps * f[ptr[1][iS3]].potent[MUT][f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS3]] > -1) {
										Gs3 += cps * f[ptr[1][iS3]].potent[MUT][f[ptr[1][iS3]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS3]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gs3 += fsplus3 * turblamS + (1.0 - fsplus3) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cps = prop_b[HEAT_CAPACITY][iS3 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
										Gs3 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}

								}
							}
						}
					}

					if (iS4 > -1) {
						if (!bS4) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iS4] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iS4] * f[ptr[1][iS4]].potent[MUT][ptr[0][iS4]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cps = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iS4] / ((1.0 - fsplus4) * prop[HEAT_CAPACITY][iP] + fsplus4 * prop[HEAT_CAPACITY][iS4]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS4]] > -1) {
										Gs4 += cps * f[ptr[1][iS4]].potent[MUT][f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS4]] > -1) {
										Gs4 += cps * f[ptr[1][iS4]].potent[MUT][f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS4]] > -1) {
										Gs4 += cps * f[ptr[1][iS4]].potent[MUT][f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS4]] > -1) {
										Gs4 += cps * f[ptr[1][iS4]].potent[MUT][f[ptr[1][iS4]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS4]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gs4 += fsplus4 * turblamS + (1.0 - fsplus4) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cps = prop_b[HEAT_CAPACITY][iS4 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
										Gs4 += cps * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}

								}
							}
						}
					}


					if (iB2 > -1) {
						if (!bB2) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iB2] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iB2] * f[ptr[1][iB2]].potent[MUT][ptr[0][iB2]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpb = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iB2] / ((1.0 - fbplus2) * prop[HEAT_CAPACITY][iP] + fbplus2 * prop[HEAT_CAPACITY][iB2]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB2]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB2]] > -1) {
										Gb2 += cpb * f[ptr[1][iB2]].potent[MUT][f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB2]] > -1) {
										Gb2 += cpb * f[ptr[1][iB2]].potent[MUT][f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB2]] > -1) {
										Gb2 += cpb * f[ptr[1][iB2]].potent[MUT][f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB2]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB2]] > -1) {
										Gb2 += cpb * f[ptr[1][iB2]].potent[MUT][f[ptr[1][iB2]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB2]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gb2 += fbplus2 * turblamS + (1.0 - fbplus2) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpb = prop_b[HEAT_CAPACITY][iB2 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
										Gb2 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iB3 > -1) {
						if (!bB3) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iB3] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iB3] * f[ptr[1][iB3]].potent[MUT][ptr[0][iB3]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpb = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iB3] / ((1.0 - fbplus3) * prop[HEAT_CAPACITY][iP] + fbplus3 * prop[HEAT_CAPACITY][iB3]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB3]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB3]] > -1) {
										Gb3 += cpb * f[ptr[1][iB3]].potent[MUT][f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB3]] > -1) {
										Gb3 += cpb * f[ptr[1][iB3]].potent[MUT][f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB3]] > -1) {
										Gb3 += cpb * f[ptr[1][iB3]].potent[MUT][f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB3]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB3]] > -1) {
										Gb3 += cpb * f[ptr[1][iB3]].potent[MUT][f[ptr[1][iB3]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB3]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gb3 += fbplus3 * turblamS + (1.0 - fbplus3) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpb = prop_b[HEAT_CAPACITY][iB3 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
										Gb3 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}

					if (iB4 > -1) {
						if (!bB4) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iB4] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iB4] * f[ptr[1][iB4]].potent[MUT][ptr[0][iB4]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpb = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iB4] / ((1.0 - fbplus4) * prop[HEAT_CAPACITY][iP] + fbplus4 * prop[HEAT_CAPACITY][iB4]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB4]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB4]] > -1) {
										Gb4 += cpb * f[ptr[1][iB4]].potent[MUT][f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB4]] > -1) {
										Gb4 += cpb * f[ptr[1][iB4]].potent[MUT][f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB4]] > -1) {
										Gb4 += cpb * f[ptr[1][iB4]].potent[MUT][f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB4]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB4]] > -1) {
										Gb4 += cpb * f[ptr[1][iB4]].potent[MUT][f[ptr[1][iB4]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB4]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gb4 += fbplus4 * turblamS + (1.0 - fbplus4) * turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpb = prop_b[HEAT_CAPACITY][iB4 - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
										Gb4 += cpb * f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}





					if (iN > -1) {
						if (!bN) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iN] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iN] * f[ptr[1][iN]].potent[MUT][ptr[0][iN]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpn = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iN] / ((1.0 - fnplus)*prop[HEAT_CAPACITY][iP] + fnplus*prop[HEAT_CAPACITY][iN]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]>-1) {
										Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]>-1) {
										Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]>-1) {
										Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]>-1) {
										Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN]]>-1) {
										Gn += cpn*f[ptr[1][iN]].potent[MUT][f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN]]>-1) {
										Gn += cpn*f[ptr[1][iN]].potent[MUT][f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN]]>-1) {
										Gn += cpn*f[ptr[1][iN]].potent[MUT][f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN]]>-1) {
										Gn += cpn*f[ptr[1][iN]].potent[MUT][f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gn += fnplus*turblamS + (1.0 - fnplus)*turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpn = prop_b[HEAT_CAPACITY][iN - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
										Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
										Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
										Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
										Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}



					if (iT > -1) {
						if (!bT) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iT] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iT] * f[ptr[1][iT]].potent[MUT][ptr[0][iT]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpt = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iT] / ((1.0 - ftplus)*prop[HEAT_CAPACITY][iP] + ftplus*prop[HEAT_CAPACITY][iT]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]>-1) {
										Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]>-1) {
										Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]>-1) {
										Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]>-1) {
										Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT]] > -1) {
										Gt += cpt*f[ptr[1][iT]].potent[MUT][f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT]] > -1) {
										Gt += cpt*f[ptr[1][iT]].potent[MUT][f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT]] > -1) {
										Gt += cpt*f[ptr[1][iT]].potent[MUT][f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT]] > -1) {
										Gt += cpt*f[ptr[1][iT]].potent[MUT][f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gt += ftplus*turblamS + (1.0 - ftplus)*turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpt = prop_b[HEAT_CAPACITY][iT - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
										Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
										Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
										Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
										Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}



					if (iW > -1) {
						if (!bW) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iW] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iW] * f[ptr[1][iW]].potent[MUT][ptr[0][iW]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpw = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iW] / ((1.0 - fwplus)*prop[HEAT_CAPACITY][iP] + fwplus*prop[HEAT_CAPACITY][iW]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]>-1) {
										Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]>-1) {
										Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]>-1) {
										Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]>-1) {
										Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW]] > -1) {
										Gw += cpw*f[ptr[1][iW]].potent[MUT][f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW]] > -1) {
										Gw += cpw*f[ptr[1][iW]].potent[MUT][f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW]] > -1) {
										Gw += cpw*f[ptr[1][iW]].potent[MUT][f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW]] > -1) {
										Gw += cpw*f[ptr[1][iW]].potent[MUT][f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gw += fwplus*turblamS + (1.0 - fwplus)*turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpw = prop_b[HEAT_CAPACITY][iW - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
										Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
										Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
										Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
										Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}



					if (iS > -1) {
						if (!bS) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iS] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iS] * f[ptr[1][iS]].potent[MUT][ptr[0][iS]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cps = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iS] / ((1.0 - fsplus)*prop[HEAT_CAPACITY][iP] + fsplus*prop[HEAT_CAPACITY][iS]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]>-1) {
										Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]>-1) {
										Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]>-1) {
										Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]>-1) {
										Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS]]>-1) {
										Gs += cps*f[ptr[1][iS]].potent[MUT][f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS]]>-1) {
										Gs += cps*f[ptr[1][iS]].potent[MUT][f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS]]>-1) {
										Gs += cps*f[ptr[1][iS]].potent[MUT][f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS]]>-1) {
										Gs += cps*f[ptr[1][iS]].potent[MUT][f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS]]] / dTurbulentPrandtlNumber;
									}
								}

							}
							else if (!(bsolidS && bsolidP)) {
								Gs += fsplus*turblamS + (1.0 - fsplus)*turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cps = prop_b[HEAT_CAPACITY][iS - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]>-1) {
										Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]>-1) {
										Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]>-1) {
										Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]>-1) {
										Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}

								}
							}
						}
					}



					if (iB > -1) {
						if (!bB) {
							bool bsolidP = false, bsolidS = false;
							doublereal turblamS = 0.0, turblamP = 0.0;

							if (ptr[1][iB] == -1) {
								// принадлежит твёрдому телу
								turblamS = 0.0;
								bsolidS = true;
							}
							else {
								if ((f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamS = prop[HEAT_CAPACITY][iB] * f[ptr[1][iB]].potent[MUT][ptr[0][iB]] / dTurbulentPrandtlNumber;
								}
							}

							if (ptr[1][iP] == -1) {
								// принадлежит твёрдому телу
								turblamP = 0.0;
								bsolidP = true;
							}
							else {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
								}
							}

							if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
								doublereal cpb = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iB] / ((1.0 - fbplus)*prop[HEAT_CAPACITY][iP] + fbplus*prop[HEAT_CAPACITY][iB]);
								if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]>-1) {
										Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]>-1) {
										Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]>-1) {
										Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]>-1) {
										Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
								else if ((bsolidP) && ((f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
									if (f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB]]>-1) {
										Gb += cpb*f[ptr[1][iB]].potent[MUT][f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB]]>-1) {
										Gb += cpb*f[ptr[1][iB]].potent[MUT][f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB]]>-1) {
										Gb += cpb*f[ptr[1][iB]].potent[MUT][f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB]]>-1) {
										Gb += cpb*f[ptr[1][iB]].potent[MUT][f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB]]] / dTurbulentPrandtlNumber;
									}
								}
							}
							else if (!(bsolidS && bsolidP)) {
								Gb += fbplus*turblamS + (1.0 - fbplus)*turblamP;
							}

						}
						else {
							if (ptr[1][iP] != -1) {
								if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
									(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
									doublereal cpb = prop_b[HEAT_CAPACITY][iB - maxelm];
									if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]>-1) {
										Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]>-1) {
										Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]>-1) {
										Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
									else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]>-1) {
										Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
									}
								}
							}
						}
					}


				}
			}
		}  // Турбулентная теплопроводность.



#ifdef DEBUG_MY_ELMATR_QUAD_T3D
		if (Ge2 != Ge2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Ge2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ge2);
			system("pause");
		}
		if (Gw2 != Gw2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gw2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gw2);
			system("pause");
		}
		if (Gn2 != Gn2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gn2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gn2);
			system("pause");
		}
		if (Gs2 != Gs2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gs2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gs2);
			system("pause");
		}
		if (Gt2 != Gt2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gt2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gt2);
			system("pause");
		}
		if (Gb2 != Gb2) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gb2=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gb2);
			system("pause");
		}
		if (Ge3 != Ge3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Ge3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ge3);
			system("pause");
		}
		if (Gw3 != Gw3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gw3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gw3);
			system("pause");
		}
		if (Gn3 != Gn3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gn3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gn3);
			system("pause");
		}
		if (Gs3 != Gs3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gs3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gs3);
			system("pause");
		}
		if (Gt3 != Gt3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gt3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gt3);
			system("pause");
		}
		if (Gb3 != Gb3) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gb3=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gb3);
			system("pause");
		}
		if (Ge4 != Ge4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Ge4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ge4);
			system("pause");
		}
		if (Gw4 != Gw4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gw4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gw4);
			system("pause");
		}
		if (Gn4 != Gn4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gn4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gn4);
			system("pause");
		}
		if (Gs4 != Gs4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gs4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gs4);
			system("pause");
		}
		if (Gt4 != Gt4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gt4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gt4);
			system("pause");
		}
		if (Gb4 != Gb4) {
			std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
			printf("Gb4=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gb4);
			system("pause");
		}
#endif


		// Инициализирующее обнуление.
		sl[iP].ae = 0.0;
		sl[iP].aw = 0.0;
		sl[iP].an = 0.0;
		sl[iP].as = 0.0;
		sl[iP].at = 0.0;
		sl[iP].ab = 0.0;

		sl[iP].ae2 = 0.0;
		sl[iP].aw2 = 0.0;
		sl[iP].an2 = 0.0;
		sl[iP].as2 = 0.0;
		sl[iP].at2 = 0.0;
		sl[iP].ab2 = 0.0;

		sl[iP].ae3 = 0.0;
		sl[iP].aw3 = 0.0;
		sl[iP].an3 = 0.0;
		sl[iP].as3 = 0.0;
		sl[iP].at3 = 0.0;
		sl[iP].ab3 = 0.0;

		sl[iP].ae4 = 0.0;
		sl[iP].aw4 = 0.0;
		sl[iP].an4 = 0.0;
		sl[iP].as4 = 0.0;
		sl[iP].at4 = 0.0;
		sl[iP].ab4 = 0.0;


		// Ещё надо предусмотреть случаи iE2, iE3, iE4.
		// А потом тоже самое для граней WSIDE, S, N, B, T.

		// На каждой грани все коэффициенты диффузии участвующие в дискретизации
		// равны одному и тому-же среднему арифметическому значению.
		// Одинаковый коэффициент диффузии на грани.
		// Но никто не отменял что у разных фейсов разные площади.
		//AVERAGE_DIFFUSION(iE, iE2, iE3, iE4, Ge, Ge2, Ge3, Ge4);
		//AVERAGE_DIFFUSION(iW, iW2, iW3, iW4, Gw, Gw2, Gw3, Gw4);
		//AVERAGE_DIFFUSION(iN, iN2, iN3, iN4, Gn, Gn2, Gn3, Gn4);
		//AVERAGE_DIFFUSION(iS, iS2, iS3, iS4, Gs, Gs2, Gs3, Gs4);
		//AVERAGE_DIFFUSION(iT, iT2, iT3, iT4, Gt, Gt2, Gt3, Gt4);
		//AVERAGE_DIFFUSION(iB, iB2, iB3, iB4, Gb, Gb2, Gb3, Gb4);


		// Неортогональная коррекция. 
		// Начало разработки 1 июля 2017.
		// С включенной неортогональной коррекцией на АЛИС сетке 
		// полученной по fine сетке для задачи
		// Максимова Анатолия Нестеровича наблюдалась расходимость.
		// С включенной неортогональной коррекцией на  АЛИС на базе
		// coarse сетке наблюдалась сходимость, 
		// но решение было найдено с 7% погрешностью. 
		const bool bcorrection_ALICE = false;

		// Сборка матрицы на АЛИС сетке:
		if (iE > -1) {
			if (bE) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ae += (Ge*border_neighbor[iE - maxelm].dS / dxe)*ApproxConvective(fabs((Fe1*border_neighbor[iE - maxelm].dS) / (Ge*border_neighbor[iE - maxelm].dS / dxe)), ishconvection) + fmax(-Fe1*border_neighbor[iE - maxelm].dS, 0);
						//printf("popal Fe1=%e\n",Fe1); getchar();
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe1.1.\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].ae += Ge*border_neighbor[iE - maxelm].dS / dxe;
				}

			}
			else {
				// iE внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iE]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae += (Ge*dy*dz / dxe)*ApproxConvective(fabs((Fe1*dy*dz) / (Ge*dy*dz / dxe)), ishconvection) + fmax(-Fe1*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe1.2.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ae += Ge*dy*dz / dxe;
					}
				}
				else if (ilevel_alice[iE] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iE, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae += (Ge*dy_loc*dz_loc / dxe)*ApproxConvective(fabs((Fe1*dy_loc*dz_loc) / (Ge*dy_loc*dz_loc / dxe)), ishconvection) + fmax(-Fe1*dy_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe1.3.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ae += Ge*dy_loc*dz_loc / dxe;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge*dy_loc*dz_loc / dxe)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z));
					}


				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iE).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae += (Ge*dy*dz / dxe)*ApproxConvective(fabs((Fe1*dy*dz) / (Ge*dy*dz / dxe)), ishconvection) + fmax(-Fe1*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe1.4.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ae += Ge*dy*dz / dxe;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge*dy*dz / dxe)*(potent[iE] - mnk(iE, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z));
					}
				}
			}
		}

		if (iE2 > -1) {
			if (bE2) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ae2 += (Ge2*border_neighbor[iE2 - maxelm].dS / dxe2)*ApproxConvective(fabs((Fe2*border_neighbor[iE2 - maxelm].dS) / (Ge2*border_neighbor[iE2 - maxelm].dS / dxe2)), ishconvection) + fmax(-Fe2*border_neighbor[iE2 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe2.1.\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].ae2 += Ge2*border_neighbor[iE2 - maxelm].dS / dxe2;
				}
			}
			else {
				// iE2 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iE2]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae2 += (Ge2*dy*dz / dxe2)*ApproxConvective(fabs((Fe2*dy*dz) / (Ge2*dy*dz / dxe2)), ishconvection) + fmax(-Fe2*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe2.2.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ae2 += Ge2*dy*dz / dxe2;
					}
				}
				else if (ilevel_alice[iE2] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iE2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae2 += (Ge2*dy_loc*dz_loc / dxe2)*ApproxConvective(fabs((Fe2*dy_loc*dz_loc) / (Ge2*dy_loc*dz_loc / dxe2)), ishconvection) + fmax(-Fe2*dy_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe2.3.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ae2 += Ge2*dy_loc*dz_loc / dxe2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge2*dy_loc*dz_loc / dxe2)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z));
					}


				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iE2).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae2 += (Ge2*dy*dz / dxe2)*ApproxConvective(fabs((Fe2*dy*dz) / (Ge2*dy*dz / dxe2)), ishconvection) + fmax(-Fe2*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe2.4.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ae2 += Ge2*dy*dz / dxe2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge2*dy*dz / dxe2)*(potent[iE2] - mnk(iE2, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z));
					}
				}
			}
		}

		if (iE3 > -1) {
			if (bE3) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ae3 += (Ge3*border_neighbor[iE3 - maxelm].dS / dxe3)*ApproxConvective(fabs((Fe3*border_neighbor[iE3 - maxelm].dS) / (Ge3*border_neighbor[iE3 - maxelm].dS / dxe3)), ishconvection) + fmax(-Fe3*border_neighbor[iE3 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe3.1.\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].ae3 += Ge3*border_neighbor[iE3 - maxelm].dS / dxe3;
				}
			}
			else {
				// iE3 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iE3]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae3 += (Ge3*dy*dz / dxe3)*ApproxConvective(fabs((Fe3*dy*dz) / (Ge3*dy*dz / dxe3)), ishconvection) + fmax(-Fe3*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe3.2.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ae3 += Ge3*dy*dz / dxe3;
					}
				}
				else if (ilevel_alice[iE3] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iE3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae3 += (Ge3*dy_loc*dz_loc / dxe3)*ApproxConvective(fabs((Fe3*dy_loc*dz_loc) / (Ge3*dy_loc*dz_loc / dxe3)), ishconvection) + fmax(-Fe3*dy_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe3.3.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ae3 += Ge3*dy_loc*dz_loc / dxe3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge3*dy_loc*dz_loc / dxe3)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iE3).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae3 += (Ge3*dy*dz / dxe3)*ApproxConvective(fabs((Fe3*dy*dz) / (Ge3*dy*dz / dxe3)), ishconvection) + fmax(-Fe3*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh.Fe3.4.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ae3 += Ge3*dy*dz / dxe3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge3*dy*dz / dxe3)*(potent[iE3] - mnk(iE3, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z));
					}

				}
			}
		}

		if (iE4 > -1) {
			if (bE4) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ae4 += (Ge4*border_neighbor[iE4 - maxelm].dS / dxe4)*ApproxConvective(fabs((Fe4*border_neighbor[iE4 - maxelm].dS) / (Ge4*border_neighbor[iE4 - maxelm].dS / dxe4)), ishconvection) + fmax(-Fe4*border_neighbor[iE4 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe4.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].ae4 += Ge4*border_neighbor[iE4 - maxelm].dS / dxe4;
				}
			}
			else {
				// iE4 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iE4]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae4 += (Ge4*dy*dz / dxe4)*ApproxConvective(fabs((Fe4*dy*dz) / (Ge4*dy*dz / dxe4)), ishconvection) + fmax(-Fe4*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe4.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ae4 += Ge4*dy*dz / dxe4;
					}
				}
				else if (ilevel_alice[iE4] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iE4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae4 += (Ge4*dy_loc*dz_loc / dxe4)*ApproxConvective(fabs((Fe4*dy_loc*dz_loc) / (Ge4*dy_loc*dz_loc / dxe4)), ishconvection) + fmax(-Fe4*dy_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh. Fe4.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ae4 += Ge4*dy_loc*dz_loc / dxe4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge4*dy_loc*dz_loc / dxe4)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iE).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ae4 += (Ge4*dy*dz / dxe4)*ApproxConvective(fabs((Fe4*dy*dz) / (Ge4*dy*dz / dxe4)), ishconvection) + fmax(-Fe4*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fe4.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ae4 += Ge4*dy*dz / dxe4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iE4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Ge4*dy*dz / dxe4)*(potent[iE4] - mnk(iE4, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z));
					}
				}
			}
		}

		// Грань Е завершена.

		if (iW > -1) {
			if (bW) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].aw += (Gw*border_neighbor[iW - maxelm].dS / dxw)*ApproxConvective(fabs((Fw1*border_neighbor[iW - maxelm].dS) / (Gw*border_neighbor[iW - maxelm].dS / dxw)), ishconvection) + fmax(Fw1*border_neighbor[iW - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw1.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].aw += Gw*border_neighbor[iW - maxelm].dS / dxw;
				}
			}
			else {
				// iW внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iW]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw += (Gw*dy*dz / dxw)*ApproxConvective(fabs((Fw1*dy*dz) / (Gw*dy*dz / dxw)), ishconvection) + fmax(Fw1*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw1.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].aw += Gw*dy*dz / dxw;
					}
				}
				else if (ilevel_alice[iW] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iW, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw += (Gw*dy_loc*dz_loc / dxw)*ApproxConvective(fabs((Fw1*dy_loc*dz_loc) / (Gw*dy_loc*dz_loc / dxw)), ishconvection) + fmax(Fw1*dy_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw1.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].aw += Gw*dy_loc*dz_loc / dxw;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw*dy_loc*dz_loc / dxw)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iW).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw += (Gw*dy*dz / dxw)*ApproxConvective(fabs((Fw1*dy*dz) / (Gw*dy*dz / dxw)), ishconvection) + fmax(Fw1*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw1.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].aw += Gw*dy*dz / dxw;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw*dy*dz / dxw)*(mnk(iW, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z) - potent[iW]);
					}

				}
			}
		}

		if (iW2 > -1) {
			if (bW2) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].aw2 += (Gw2*border_neighbor[iW2 - maxelm].dS / dxw2)*ApproxConvective(fabs((Fw2*border_neighbor[iW2 - maxelm].dS) / (Gw2*border_neighbor[iW2 - maxelm].dS / dxw2)), ishconvection) + fmax(Fw2*border_neighbor[iW2 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw2.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].aw2 += Gw2*border_neighbor[iW2 - maxelm].dS / dxw2;
				}
			}
			else {
				// iW2 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iW2]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw2 += (Gw2*dy*dz / dxw2)*ApproxConvective(fabs((Fw2*dy*dz) / (Gw2*dy*dz / dxw2)), ishconvection) + fmax(Fw2*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw2.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].aw2 += Gw2*dy*dz / dxw2;
					}
				}
				else if (ilevel_alice[iW2] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iW2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw2 += (Gw2*dy_loc*dz_loc / dxw2)*ApproxConvective(fabs((Fw2*dy_loc*dz_loc) / (Gw2*dy_loc*dz_loc / dxw2)), ishconvection) + fmax(Fw2*dy_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw2.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].aw2 += Gw2*dy_loc*dz_loc / dxw2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw2*dy_loc*dz_loc / dxw2)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iW2).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw2 += (Gw2*dy*dz / dxw2)*ApproxConvective(fabs((Fw2*dy*dz) / (Gw2*dy*dz / dxw2)), ishconvection) + fmax(Fw2*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw2.4.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].aw2 += Gw2*dy*dz / dxw2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw2*dy*dz / dxw2)*(mnk(iW2, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z) - potent[iW2]);
					}
				}
			}
		}

		if (iW3 > -1) {
			if (bW3) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].aw3 += (Gw3*border_neighbor[iW3 - maxelm].dS / dxw3)*ApproxConvective(fabs((Fw3*border_neighbor[iW3 - maxelm].dS) / (Gw3*border_neighbor[iW3 - maxelm].dS / dxw3)), ishconvection) + fmax(Fw3*border_neighbor[iW3 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw3.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].aw3 += Gw3*border_neighbor[iW3 - maxelm].dS / dxw3;
				}
			}
			else {
				// iW3 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iW3]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw3 += (Gw3*dy*dz / dxw3)*ApproxConvective(fabs((Fw3*dy*dz) / (Gw3*dy*dz / dxw3)), ishconvection) + fmax(Fw3*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw3.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].aw3 += Gw3*dy*dz / dxw3;
					}
				}
				else if (ilevel_alice[iW3] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iW3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw3 += (Gw3*dy_loc*dz_loc / dxw3)*ApproxConvective(fabs((Fw3*dy_loc*dz_loc) / (Gw3*dy_loc*dz_loc / dxw3)), ishconvection) + fmax(Fw3*dy_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw3.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].aw3 += Gw3*dy_loc*dz_loc / dxw3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw3*dy_loc*dz_loc / dxw3)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iW).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw3 += (Gw3*dy*dz / dxw3)*ApproxConvective(fabs((Fw3*dy*dz) / (Gw3*dy*dz / dxw3)), ishconvection) + fmax(Fw3*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw3.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].aw3 += Gw3*dy*dz / dxw3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw3*dy*dz / dxw3)*(mnk(iW3, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z) - potent[iW3]);
					}

				}
			}
		}

		if (iW4 > -1) {
			if (bW4) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].aw4 += (Gw4*border_neighbor[iW4 - maxelm].dS / dxw4)*ApproxConvective(fabs((Fw4*border_neighbor[iW4 - maxelm].dS) / (Gw4*border_neighbor[iW4 - maxelm].dS / dxw4)), ishconvection) + fmax(Fw4*border_neighbor[iW4 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw4.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].aw4 += Gw4*border_neighbor[iW4 - maxelm].dS / dxw4;
				}
			}
			else {
				// iW4 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iW4]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw4 += (Gw4*dy*dz / dxw4)*ApproxConvective(fabs((Fw4*dy*dz) / (Gw4*dy*dz / dxw4)), ishconvection) + fmax(Fw4*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw4.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].aw4 += Gw4*dy*dz / dxw4;
					}
				}
				else if (ilevel_alice[iW4] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iW4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw4 += (Gw4*dy_loc*dz_loc / dxw4)*ApproxConvective(fabs((Fw4*dy_loc*dz_loc) / (Gw4*dy_loc*dz_loc / dxw4)), ishconvection) + fmax(Fw4*dy_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw4.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].aw4 += Gw4*dy_loc*dz_loc / dxw4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw4*dy_loc*dz_loc / dxw4)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iW4).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].aw4 += (Gw4*dy*dz / dxw4)*ApproxConvective(fabs((Fw4*dy*dz) / (Gw4*dy*dz / dxw4)), ishconvection) + fmax(Fw4*dy*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fw4.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].aw4 += Gw4*dy*dz / dxw4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iW4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gw4*dy*dz / dxw4)*(mnk(iW4, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP0.z) - potent[iW4]);
					}

				}
			}
		}

		// Грань W завершена.

		if (iN > -1) {
			if (bN) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].an += (Gn*border_neighbor[iN - maxelm].dS / dyn)*ApproxConvective(fabs((Fn1*border_neighbor[iN - maxelm].dS) / (Gn*border_neighbor[iN - maxelm].dS / dyn)), ishconvection) + fmax(-Fn1*border_neighbor[iN - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn1.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].an += Gn*border_neighbor[iN - maxelm].dS / dyn;
				}
			}
			else {
				// iN внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iN]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an += (Gn*dx*dz / dyn)*ApproxConvective(fabs((Fn1*dx*dz) / (Gn*dx*dz / dyn)), ishconvection) + fmax(-Fn1*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn1.2.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].an += Gn*dx*dz / dyn;
					}
				}
				else if (ilevel_alice[iN] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iN, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an += (Gn*dx_loc*dz_loc / dyn)*ApproxConvective(fabs((Fn1*dx_loc*dz_loc) / (Gn*dx_loc*dz_loc / dyn)), ishconvection) + fmax(-Fn1*dx_loc*dz_loc, 0); ;
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn1.3.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].an += Gn*dx_loc*dz_loc / dyn;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn*dx_loc*dz_loc / dyn)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iN).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an += (Gn*dx*dz / dyn)*ApproxConvective(fabs((Fn1*dx*dz) / (Gn*dx*dz / dyn)), ishconvection) + fmax(-Fn1*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn1.4.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].an += Gn*dx*dz / dyn;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn*dx*dz / dyn)*(potent[iN] - mnk(iN, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z));
					}

				}
			}
		}


		if (iN2 > -1) {
			if (bN2) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].an2 += (Gn2*border_neighbor[iN2 - maxelm].dS / dyn2)*ApproxConvective(fabs((Fn2*border_neighbor[iN2 - maxelm].dS) / (Gn2*border_neighbor[iN2 - maxelm].dS / dyn2)), ishconvection) + fmax(-Fn2*border_neighbor[iN2 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn2.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].an2 += Gn2*border_neighbor[iN2 - maxelm].dS / dyn2;
				}
			}
			else {
				// iN2 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iN2]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an2 += (Gn2*dx*dz / dyn2)*ApproxConvective(fabs((Fn2*dx*dz) / (Gn2*dx*dz / dyn2)), ishconvection) + fmax(-Fn2*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn2.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].an2 += Gn2*dx*dz / dyn2;
					}
				}
				else if (ilevel_alice[iN2] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iN2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an2 += (Gn2*dx_loc*dz_loc / dyn2)*ApproxConvective(fabs((Fn2*dx_loc*dz_loc) / (Gn2*dx_loc*dz_loc / dyn2)), ishconvection) + fmax(-Fn2*dx_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn2.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].an2 += Gn2*dx_loc*dz_loc / dyn2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn2*dx_loc*dz_loc / dyn2)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iN2).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an2 += (Gn2*dx*dz / dyn2)*ApproxConvective(fabs((Fn2*dx*dz) / (Gn2*dx*dz / dyn2)), ishconvection) + fmax(-Fn2*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn2.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].an2 += Gn2*dx*dz / dyn2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn2*dx*dz / dyn2)*(potent[iN2] - mnk(iN2, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z));
					}

				}
			}
		}


		if (iN3 > -1) {
			if (bN3) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].an3 += (Gn3*border_neighbor[iN3 - maxelm].dS / dyn3)*ApproxConvective(fabs((Fn3*border_neighbor[iN3 - maxelm].dS) / (Gn3*border_neighbor[iN3 - maxelm].dS / dyn3)), ishconvection) + fmax(-Fn3*border_neighbor[iN3 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn3.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].an3 += Gn3*border_neighbor[iN3 - maxelm].dS / dyn3;
				}
			}
			else {
				// iN внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iN3]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an3 += (Gn3*dx*dz / dyn3)*ApproxConvective(fabs((Fn3*dx*dz) / (Gn3*dx*dz / dyn3)), ishconvection) + fmax(-Fn3*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn3.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].an3 += Gn3*dx*dz / dyn3;
					}
				}
				else if (ilevel_alice[iN3] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iN3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an3 += (Gn3*dx_loc*dz_loc / dyn3)*ApproxConvective(fabs((Fn3*dx_loc*dz_loc) / (Gn3*dx_loc*dz_loc / dyn3)), ishconvection) + fmax(-Fn3*dx_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn3.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].an3 += Gn3*dx_loc*dz_loc / dyn3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn3*dx_loc*dz_loc / dyn3)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iN3).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an3 += (Gn3*dx*dz / dyn3)*ApproxConvective(fabs((Fn3*dx*dz) / (Gn3*dx*dz / dyn3)), ishconvection) + fmax(-Fn3*dx*dz, 0); ;
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn3.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].an3 += Gn3*dx*dz / dyn3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn3*dx*dz / dyn3)*(potent[iN3] - mnk(iN3, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z));
					}

				}
			}
		}

		if (iN4 > -1) {
			if (bN4) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].an4 += (Gn4*border_neighbor[iN4 - maxelm].dS / dyn4)*ApproxConvective(fabs((Fn4*border_neighbor[iN4 - maxelm].dS) / (Gn4*border_neighbor[iN4 - maxelm].dS / dyn4)), ishconvection) + fmax(-Fn4*border_neighbor[iN4 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn4.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].an4 += Gn4*border_neighbor[iN4 - maxelm].dS / dyn4;
				}
			}
			else {
				// iN4 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iN4]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an4 += (Gn4*dx*dz / dyn4)*ApproxConvective(fabs((Fn4*dx*dz) / (Gn4*dx*dz / dyn4)), ishconvection) + fmax(-Fn4*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn4.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].an4 += Gn4*dx*dz / dyn4;
					}
				}
				else if (ilevel_alice[iN4] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iN4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an4 += (Gn4*dx_loc*dz_loc / dyn4)*ApproxConvective(fabs((Fn4*dx_loc*dz_loc) / (Gn4*dx_loc*dz_loc / dyn4)), ishconvection) + fmax(-Fn4*dx_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn4.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].an4 += Gn4*dx_loc*dz_loc / dyn4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn4*dx_loc*dz_loc / dyn4)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iN4).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].an4 += (Gn4*dx*dz / dyn4)*ApproxConvective(fabs((Fn4*dx*dz) / (Gn4*dx*dz / dyn4)), ishconvection) + fmax(-Fn4*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fn4.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].an4 += Gn4*dx*dz / dyn4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iN4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gn4*dx*dz / dyn4)*(potent[iN4] - mnk(iN4, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z));
					}

				}
			}
		}

		// Грань N завершена.

		if (iS > -1) {
			if (bS) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].as += (Gs*border_neighbor[iS - maxelm].dS / dys)*ApproxConvective(fabs((Fs1*border_neighbor[iS - maxelm].dS) / (Gs*border_neighbor[iS - maxelm].dS / dys)), ishconvection) + fmax(Fs1*border_neighbor[iS - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs1.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].as += Gs*border_neighbor[iS - maxelm].dS / dys;
				}
			}
			else {
				// iS внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iS]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as += (Gs*dx*dz / dys)*ApproxConvective(fabs((Fs1*dx*dz) / (Gs*dx*dz / dys)), ishconvection) + fmax(Fs1*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs1.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].as += Gs*dx*dz / dys;
					}
				}
				else if (ilevel_alice[iS] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iS, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as += (Gs*dx_loc*dz_loc / dys)*ApproxConvective(fabs((Fs1*dx_loc*dz_loc) / (Gs*dx_loc*dz_loc / dys)), ishconvection) + fmax(Fs1*dx_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs1.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].as += Gs*dx_loc*dz_loc / dys;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs*dx_loc*dz_loc / dys)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iS).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as += (Gs*dx*dz / dys)*ApproxConvective(fabs((Fs1*dx*dz) / (Gs*dx*dz / dys)), ishconvection) + fmax(Fs1*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs1.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].as += Gs*dx*dz / dys;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs*dx*dz / dys)*(mnk(iS, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z) - potent[iS]);
					}

				}
			}
		}

		if (iS2 > -1) {
			if (bS2) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].as2 += (Gs2*border_neighbor[iS2 - maxelm].dS / dys2)*ApproxConvective(fabs((Fs2*border_neighbor[iS2 - maxelm].dS) / (Gs2*border_neighbor[iS2 - maxelm].dS / dys2)), ishconvection) + fmax(Fs2*border_neighbor[iS2 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs2.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].as2 += Gs2*border_neighbor[iS2 - maxelm].dS / dys2;
				}
			}
			else {
				// iS2 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iS2]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as2 += (Gs2*dx*dz / dys2)*ApproxConvective(fabs((Fs2*dx*dz) / (Gs2*dx*dz / dys2)), ishconvection) + fmax(Fs2*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs2.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].as2 += Gs2*dx*dz / dys2;
					}
				}
				else if (ilevel_alice[iS2] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iS2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as2 += (Gs2*dx_loc*dz_loc / dys2)*ApproxConvective(fabs((Fs2*dx_loc*dz_loc) / (Gs2*dx_loc*dz_loc / dys2)), ishconvection) + fmax(Fs2*dx_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs2.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].as2 += Gs2*dx_loc*dz_loc / dys2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs2*dx_loc*dz_loc / dys2)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z) - potent[iP]);
					}
				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iS2).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as2 += (Gs2*dx*dz / dys2)*ApproxConvective(fabs((Fs2*dx*dz) / (Gs2*dx*dz / dys2)), ishconvection) + fmax(Fs2*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs2.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].as2 += Gs2*dx*dz / dys2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs2*dx*dz / dys2)*(mnk(iS2, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z) - potent[iS2]);
					}
				}
			}
		}

		if (iS3 > -1) {
			if (bS3) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].as3 += (Gs3*border_neighbor[iS3 - maxelm].dS / dys3)*ApproxConvective(fabs((Fs3*border_neighbor[iS3 - maxelm].dS) / (Gs3*border_neighbor[iS3 - maxelm].dS / dys3)), ishconvection) + fmax(Fs3*border_neighbor[iS3 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs3.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].as3 += Gs3*border_neighbor[iS3 - maxelm].dS / dys3;
				}
			}
			else {
				// iS3 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iS3]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as3 += (Gs3*dx*dz / dys3)*ApproxConvective(fabs((Fs3*dx*dz) / (Gs3*dx*dz / dys3)), ishconvection) + fmax(Fs3*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs3.2.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].as3 += Gs3*dx*dz / dys3;
					}
				}
				else if (ilevel_alice[iS3] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iS3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as3 += (Gs3*dx_loc*dz_loc / dys3)*ApproxConvective(fabs((Fs3*dx_loc*dz_loc) / (Gs3*dx_loc*dz_loc / dys3)), ishconvection) + fmax(Fs3*dx_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs3.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].as3 += Gs3*dx_loc*dz_loc / dys3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs3*dx_loc*dz_loc / dys3)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iS3).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as3 += (Gs3*dx*dz / dys3)*ApproxConvective(fabs((Fs3*dx*dz) / (Gs3*dx*dz / dys3)), ishconvection) + fmax(Fs3*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs3.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].as3 += Gs3*dx*dz / dys3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs3*dx*dz / dys3)*(mnk(iS3, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z) - potent[iS3]);
					}
				}
			}
		}

		if (iS4 > -1) {
			if (bS4) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].as4 += (Gs4*border_neighbor[iS4 - maxelm].dS / dys4)*ApproxConvective(fabs((Fs4*border_neighbor[iS4 - maxelm].dS) / (Gs4*border_neighbor[iS4 - maxelm].dS / dys4)), ishconvection) + fmax(Fs4*border_neighbor[iS4 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs4.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].as4 += Gs4*border_neighbor[iS4 - maxelm].dS / dys4;
				}
			}
			else {
				// iS4 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iS4]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as4 += (Gs4*dx*dz / dys4)*ApproxConvective(fabs((Fs4*dx*dz) / (Gs4*dx*dz / dys4)), ishconvection) + fmax(Fs4*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs4.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].as4 += Gs4*dx*dz / dys4;
					}
				}
				else if (ilevel_alice[iS4] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iS4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as4 += (Gs4*dx_loc*dz_loc / dys4)*ApproxConvective(fabs((Fs4*dx_loc*dz_loc) / (Gs4*dx_loc*dz_loc / dys4)), ishconvection) + fmax(Fs4*dx_loc*dz_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs4.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].as4 += Gs4*dx_loc*dz_loc / dys4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs4*dx_loc*dz_loc / dys4)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP0.y, pointP1.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iS4).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].as4 += (Gs4*dx*dz / dys4)*ApproxConvective(fabs((Fs4*dx*dz) / (Gs4*dx*dz / dys4)), ishconvection) + fmax(Fs4*dx*dz, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fs4.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].as4 += Gs4*dx*dz / dys4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iS4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gs4*dx*dz / dys4)*(mnk(iS4, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP1.y, pointP0.z) - potent[iS4]);
					}
				}
			}
		}

		// Грань S завершена.

		if (iT > -1) {
			if (bT) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].at += (Gt*border_neighbor[iT - maxelm].dS / dzt)*ApproxConvective(fabs((Ft1*border_neighbor[iT - maxelm].dS) / (Gt*border_neighbor[iT - maxelm].dS / dzt)), ishconvection) + fmax(-Ft1*border_neighbor[iT - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft1.1.\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].at += Gt*border_neighbor[iT - maxelm].dS / dzt;
				}
			}
			else {
				// iT внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iT]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at += (Gt*dx*dy / dzt)*ApproxConvective(fabs((Ft1*dx*dy) / (Gt*dx*dy / dzt)), ishconvection) + fmax(-Ft1*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft1.2.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].at += Gt*dx*dy / dzt;
					}
				}
				else if (ilevel_alice[iT] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iT, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at += (Gt*dx_loc*dy_loc / dzt)*ApproxConvective(fabs((Ft1*dx_loc*dy_loc) / (Gt*dx_loc*dy_loc / dzt)), ishconvection) + fmax(-Ft1*dx_loc*dy_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft1.3.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].at += Gt*dx_loc*dy_loc / dzt;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt*dx_loc*dy_loc / dzt)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iT).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at += (Gt*dx*dy / dzt)*ApproxConvective(fabs((Ft1*dx*dy) / (Gt*dx*dy / dzt)), ishconvection) + fmax(-Ft1*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft1.4.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].at += Gt*dx*dy / dzt;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt*dx*dy / dzt)*(potent[iT] - mnk(iT, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z));
					}
				}
			}
		}


		if (iT2 > -1) {
			if (bT2) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].at2 += (Gt2*border_neighbor[iT2 - maxelm].dS / dzt2)*ApproxConvective(fabs((Ft2*border_neighbor[iT2 - maxelm].dS) / (Gt2*border_neighbor[iT2 - maxelm].dS / dzt2)), ishconvection) + fmax(-Ft2*border_neighbor[iT2 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft2.1.\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].at2 += Gt2*border_neighbor[iT2 - maxelm].dS / dzt2;
				}
			}
			else {
				// iT2 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iT2]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at2 += (Gt2*dx*dy / dzt2)*ApproxConvective(fabs((Ft2*dx*dy) / (Gt2*dx*dy / dzt2)), ishconvection) + fmax(-Ft2*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft2.2.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].at2 += Gt2*dx*dy / dzt2;
					}
				}
				else if (ilevel_alice[iT2] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iT2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at2 += (Gt2*dx_loc*dy_loc / dzt2)*ApproxConvective(fabs((Ft2*dx_loc*dy_loc) / (Gt2*dx_loc*dy_loc / dzt2)), ishconvection) + fmax(-Ft2*dx_loc*dy_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft2.3.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].at2 += Gt2*dx_loc*dy_loc / dzt2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt2*dx_loc*dy_loc / dzt2)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iT2).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at2 += (Gt2*dx*dy / dzt2)*ApproxConvective(fabs((Ft2*dx*dy) / (Gt2*dx*dy / dzt2)), ishconvection) + fmax(-Ft2*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft2.4.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].at2 += Gt2*dx*dy / dzt2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt2*dx*dy / dzt2)*(potent[iT2] - mnk(iT2, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z));
					}

				}
			}
		}


		if (iT3 > -1) {
			if (bT3) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].at3 += (Gt3*border_neighbor[iT3 - maxelm].dS / dzt3)*ApproxConvective(fabs((Ft3*border_neighbor[iT3 - maxelm].dS) / (Gt3*border_neighbor[iT3 - maxelm].dS / dzt3)), ishconvection) + fmax(-Ft3*border_neighbor[iT3 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft3.1.\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].at3 += Gt3*border_neighbor[iT3 - maxelm].dS / dzt3;
				}
			}
			else {
				// iT3 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iT3]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at3 += (Gt3*dx*dy / dzt3)*ApproxConvective(fabs((Ft3*dx*dy) / (Gt3*dx*dy / dzt3)), ishconvection) + fmax(-Ft3*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft3.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].at3 += Gt3*dx*dy / dzt3;
					}
				}
				else if (ilevel_alice[iT3] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iT3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at3 += (Gt3*dx_loc*dy_loc / dzt3)*ApproxConvective(fabs((Ft3*dx_loc*dy_loc) / (Gt3*dx_loc*dy_loc / dzt3)), ishconvection) + fmax(-Ft3*dx_loc*dy_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft3.3.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].at3 += Gt3*dx_loc*dy_loc / dzt3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt3*dx_loc*dy_loc / dzt3)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iT3).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at3 += (Gt3*dx*dy / dzt3)*ApproxConvective(fabs((Ft3*dx*dy) / (Gt3*dx*dy / dzt3)), ishconvection) + fmax(-Ft3*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft3.4.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].at3 += Gt3*dx*dy / dzt3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt3*dx*dy / dzt3)*(potent[iT3] - mnk(iT3, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z));
					}

				}
			}
		}

		if (iT4 > -1) {
			if (bT4) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].at4 += (Gt4*border_neighbor[iT4 - maxelm].dS / dzt4)*ApproxConvective(fabs((Ft4*border_neighbor[iT4 - maxelm].dS) / (Gt4*border_neighbor[iT4 - maxelm].dS / dzt4)), ishconvection) + fmax(-Ft4*border_neighbor[iT4 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft4.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].at4 += Gt4*border_neighbor[iT4 - maxelm].dS / dzt4;
				}
			}
			else {
				// iT4 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iT4]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at4 += (Gt4*dx*dy / dzt4)*ApproxConvective(fabs((Ft4*dx*dy) / (Gt4*dx*dy)), ishconvection) + fmax(-Ft4*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft4.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].at4 += Gt4*dx*dy / dzt4;
					}
				}
				else if (ilevel_alice[iT4] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iT4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at4 += (Gt4*dx_loc*dy_loc / dzt4)*ApproxConvective(fabs((Ft4*dx_loc*dy_loc) / (Gt4*dx_loc*dy_loc / dzt4)), ishconvection) + fmax(-Ft4*dx_loc*dy_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft4.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].at4 += Gt4*dx_loc*dy_loc / dzt4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt4*dx_loc*dy_loc / dzt4)*(potent[iP] - mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z));
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iT4).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].at4 += (Gt4*dx*dy / dzt4)*ApproxConvective(fabs((Ft4*dx*dy) / (Gt4*dx*dy / dzt4)), ishconvection) + fmax(-Ft4*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Ft4.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].at4 += Gt4*dx*dy / dzt4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iT4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gt4*dx*dy / dzt4)*(potent[iT4] - mnk(iT4, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z));
					}

				}
			}
		}

		// Грань T завершена.

		if (iB > -1) {
			if (bB) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ab += (Gb*border_neighbor[iB - maxelm].dS / dzb)*ApproxConvective(fabs((Fb1*border_neighbor[iB - maxelm].dS) / (Gb*border_neighbor[iB - maxelm].dS / dzb)), ishconvection) + fmax(Fb1*border_neighbor[iB - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb1.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].ab += Gb*border_neighbor[iB - maxelm].dS / dzb;
				}
			}
			else {
				// iB внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iB]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab += (Gb*dx*dy / dzb)*ApproxConvective(fabs((Fb1*dx*dy) / (Gb*dx*dy / dzb)), ishconvection) + fmax(Fb1*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb1.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ab += Gb*dx*dy / dzb;
					}
				}
				else if (ilevel_alice[iB] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iB, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab += (Gb*dx_loc*dy_loc / dzb)*ApproxConvective(fabs((Fb1*dx_loc*dy_loc) / (Gb*dx_loc*dy_loc / dzb)), ishconvection) + fmax(Fb1*dx_loc*dy_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb1.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ab += Gb*dx_loc*dy_loc / dzb;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb*dx_loc*dy_loc / dzb)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iB).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab += (Gb*dx*dy / dzb)*ApproxConvective(fabs((Fb1*dx*dy) / (Gb*dx*dy / dzb)), ishconvection) + fmax(Fb1*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb1.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ab += Gb*dx*dy / dzb;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb*dx*dy / dzb)*(mnk(iB, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z) - potent[iB]);
					}
				}
			}
		}

		if (iB2 > -1) {
			if (bB2) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ab2 += (Gb2*border_neighbor[iB2 - maxelm].dS / dzb2)*ApproxConvective(fabs((Fb2*border_neighbor[iB2 - maxelm].dS) / (Gb2*border_neighbor[iB2 - maxelm].dS / dzb2)), ishconvection) + fmax(Fb2*border_neighbor[iB2 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb2.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].ab2 += Gb2*border_neighbor[iB2 - maxelm].dS / dzb2;
				}
			}
			else {
				// iB2 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iB2]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab2 += (Gb2*dx*dy / dzb2)*ApproxConvective(fabs((Fb2*dx*dy) / (Gb2*dx*dy / dzb2)), ishconvection) + fmax(Fb2*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb2.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ab2 += Gb2*dx*dy / dzb2;
					}
				}
				else if (ilevel_alice[iB2] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iB2, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab2 += (Gb2*dx_loc*dy_loc / dzb2)*ApproxConvective(fabs((Fb2*dx_loc*dy_loc) / (Gb2*dx_loc*dy_loc / dzb2)), ishconvection) + fmax(Fb2*dx_loc*dy_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb2.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ab2 += Gb2*dx_loc*dy_loc / dzb2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb2*dx_loc*dy_loc / dzb2)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iB2).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab2 += (Gb2*dx*dy / dzb2)*ApproxConvective(fabs((Fb2*dx*dy) / (Gb2*dx*dy / dzb2)), ishconvection) + fmax(Fb2*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb2.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ab2 += Gb2*dx*dy / dzb2;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB2, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb2*dx*dy / dzb2)*(mnk(iB2, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z) - potent[iB2]);
					}

				}
			}
		}

		if (iB3 > -1) {
			if (bB3) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ab3 += (Gb3*border_neighbor[iB3 - maxelm].dS / dzb3)*ApproxConvective(fabs((Fb3*border_neighbor[iB3 - maxelm].dS) / (Gb3*border_neighbor[iB3 - maxelm].dS / dzb3)), ishconvection) + fmax(Fb3*border_neighbor[iB3 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb3.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].ab3 += Gb3*border_neighbor[iB3 - maxelm].dS / dzb3;
				}
			}
			else {
				// iB3 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iB3]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab3 += (Gb3*dx*dy / dzb3)*ApproxConvective(fabs((Fb3*dx*dy) / (Gb3*dx*dy / dzb3)), ishconvection) + fmax(Fb3*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb3.2\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ab3 += Gb3*dx*dy / dzb3;
					}
				}
				else if (ilevel_alice[iB3] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iB3, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab3 += (Gb3*dx_loc*dy_loc / dzb3)*ApproxConvective(fabs((Fb3*dx_loc*dy_loc) / (Gb3*dx_loc*dy_loc / dzb3)), ishconvection) + fmax(Fb3*dx_loc*dy_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb3.3.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ab3 += Gb3*dx_loc*dy_loc / dzb3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb3*dx_loc*dy_loc / dzb3)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iB3).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab3 += (Gb3*dx*dy / dzb3)*ApproxConvective(fabs((Fb3*dx*dy) / (Gb3*dx*dy / dzb3)), ishconvection) + fmax(Fb3*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb3.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ab3 += Gb3*dx*dy / dzb3;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB3, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb3*dx*dy / dzb3)*(mnk(iB3, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z) - potent[iB3]);
					}
				}
			}
		}

		if (iB4 > -1) {
			if (bB4) {
				// граничный узел.
				if (bconvective)
				{
					if (ishconvection < distsheme) {
						sl[iP].ab4 += (Gb4*border_neighbor[iB4 - maxelm].dS / dzb4)*ApproxConvective(fabs((Fb4*border_neighbor[iB4 - maxelm].dS) / (Gb4*border_neighbor[iB4 - maxelm].dS / dzb4)), ishconvection) + fmax(Fb4*border_neighbor[iB4 - maxelm].dS, 0);
					}
					else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
						printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb4.1\n");
						system("pause");
						exit(1);
#endif
					}
				}
				else {
					sl[iP].ab4 += Gb4*border_neighbor[iB4 - maxelm].dS / dzb4;
				}
			}
			else {
				// iB4 внутренний узел.
				// Возможны 3 случая:
				// 1. уровни совпадают.
				// 2. уровень соседа выше (и тогда это дробление на 2, 3 или 4 соседа).
				// 3. Уровень соседа ниже (Самый сложный случай тут отсутствует диагональное преобладание).
				if (ilevel_alice[iP] == ilevel_alice[iB4]) {
					// уровни равны:
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab4 += (Gb4*dx*dy / dzb4)*ApproxConvective(fabs((Fb4*dx*dy) / (Gb4*dx*dy / dzb4)), ishconvection) + fmax(Fb4*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb4.2.\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ab4 += Gb4*dx*dy / dzb4;
					}
				}
				else if (ilevel_alice[iB4] > ilevel_alice[iP]) {
					// Это только один из вкладов.
					// Также необходимы вклады от ae2, ae3, ae4. Они будут обработаны ниже по тексту.

					// Сосед лежит на уровне выше:
					// дробление.
					// вычисление размеров соседнего контрольного объёма:
					doublereal dx_loc = 0.0, dy_loc = 0.0, dz_loc = 0.0;// объём текущего контрольного объёма
					volume3D(iB4, nvtx, pa, dx_loc, dy_loc, dz_loc);
					// Площадь соседа по общей рани меньше чем площадь грани всей ячейки iP.
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab4 += (Gb4*dx_loc*dy_loc / dzb4)*ApproxConvective(fabs((Fb4*dx_loc*dy_loc) / (Gb4*dx_loc*dy_loc / dzb4)), ishconvection) + fmax(Fb4*dx_loc*dy_loc, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb4.3\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ab4 += Gb4*dx_loc*dy_loc / dzb4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb4*dx_loc*dy_loc / dzb4)*(mnk(iP, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP1.x, pointP1.y, pointP0.z) - potent[iP]);
					}

				}
				else {
					// Уровень iP выше уровня соседа.
					// Отсутствие диагонального преобладания.
					// самый сложный случай. (24 случая для грани iB4).
					if (bconvective)
					{
						if (ishconvection < distsheme) {
							sl[iP].ab4 += (Gb4*dx*dy / dzb4)*ApproxConvective(fabs((Fb4*dx*dy) / (Gb4*dx*dy / dzb4)), ishconvection) + fmax(Fb4*dx*dy, 0);
						}
						else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							printf("convective scheme my be only first order, becouse using  ALICE Mesh Fb4.4\n");
							system("pause");
							exit(1);
#endif
						}
					}
					else {
						sl[iP].ab4 += Gb4*dx*dy / dzb4;
					}

					if (bcorrection_ALICE) {
						// здесь реализован метод отложенной коррекции,
						// он выравнивает геометрические позиции базовых точек
						// используемых при сборке матрицы. 
						// Это повышает точность аппроксимации на АЛИС сетке.
						// 01.07.2017.

						TOCHKA pointP1;
						center_cord3D(iB4, nvtx, pa, pointP1, 100);

						sl[iP].b += (Gb4*dx*dy / dzb4)*(mnk(iB4, maxelm, potent, nvtx, pa, neighbors_for_the_internal_node, pointP0.x, pointP0.y, pointP1.z) - potent[iB4]);
					}

				}
			}
		}

		//  Грань B завершена.
		// 28 сентября 2016. 10_51.
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
		if (sl[iP].ae < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative ae=%e\n", sl[iP].ae);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].aw < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative aw=%e\n", sl[iP].aw);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].an < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative an=%e\n", sl[iP].an);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].as < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative as=%e\n", sl[iP].as);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].at < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative at=%e\n", sl[iP].at);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].ab < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative ab=%e\n", sl[iP].ab);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}

		if (sl[iP].ae2 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative ae2=%e\n", sl[iP].ae2);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].aw2 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative aw2=%e\n", sl[iP].aw2);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].an2 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative an2=%e\n", sl[iP].an2);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].as2 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative as2=%e\n", sl[iP].as2);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].at2 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative at2=%e\n", sl[iP].at2);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].ab2 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative ab2=%e\n", sl[iP].ab2);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}

		if (sl[iP].ae3 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative ae3=%e\n", sl[iP].ae3);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].aw3 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative aw3=%e\n", sl[iP].aw3);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].an3 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative an3=%e\n", sl[iP].an3);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].as3 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative as3=%e\n", sl[iP].as3);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].at3 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative at3=%e\n", sl[iP].at3);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].ab3 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative ab3=%e\n", sl[iP].ab3);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}

		if (sl[iP].ae4 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative ae4=%e\n", sl[iP].ae4);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].aw4 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative aw4=%e\n", sl[iP].aw4);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].an4 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative an4=%e\n", sl[iP].an4);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].as4 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative as4=%e\n", sl[iP].as4);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].at4 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative at4=%e\n", sl[iP].at4);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
		if (sl[iP].ab4 < 0.0) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error UDS negative ab4=%e\n", sl[iP].ab4);
			printf("in my_elmatr_quad_T3D function\n");
			system("pause");
		}
#endif

	}

	// конвективные потоки
	doublereal Fe = 0.0, Fw = 0.0, Fn = 0.0, Fs = 0.0, Ft = 0.0, Fb = 0.0;
	doublereal De = 1.0, Dw = 1.0, Dn = 1.0, Ds = 1.0, Dt = 1.0, Db = 1.0;
	// Числа Пекле:
	doublereal Pe = 0.0, Pw = 0.0, Pn = 0.0, Ps = 0.0, Pt = 0.0, Pb = 0.0;
	// Добавка в правую часть при использовании схемы Леонарда QUICK
	// в силу использования метода отложенной коррекции.
	// addition to the right side QUICK Leonard.
	doublereal attrs = 0.0;

	if (!b_on_adaptive_local_refinement_mesh) {


		// коэффициенты диффузии:
		doublereal GP = 0.0, GE = 0.0, GW = 0.0, GN = 0.0, GS = 0.0, GT = 0.0, GB = 0.0;
		doublereal Ge = 0.0, Gw = 0.0, Gn = 0.0, Gs = 0.0, Gt = 0.0, Gb = 0.0;

		bool bortho86 = false;
		// Теплопроводность на грани является ортотропной 
		// если два контрольных объёма окружающие грань 
		// имеют одинаковый коэффициент ортотропности.
		if ((ptr != nullptr) && (ptr[1][iP] == -1)) {
			bortho86 = true;
		}
		else if ((ptr != nullptr) && (ptr[1][iP] != -1)) {
			// Жидкая зона ортотропности просто нет.
			bortho86 = false;
		}
		else {
			bortho86 = true;
		}

		GP = prop[LAM][iP];

		/*
		if (bconvective)
		{
		Fe=rhoe*ue*dy*dz;
		Fw=rhow*uw*dy*dz;
		Fn=rhon*vn*dx*dz;
		Fs=rhos*vs*dx*dz;
		Ft=rhot*wt*dx*dy;
		Fb=rhob*wb*dx*dy;
		}
		*/

//#pragma omp parallel sections 
		{

			// коэффициенты диффузии:
//#pragma omp section 
			{
				if ((ptr != nullptr) && (bconvective))
				{
					// Если ptr==nullptr то отсутствует связь с гидродинамической частью и это означает
					// просто то что гидродинамической части нет как таковой и мы находимся в условиях
					// чистой теплопередачи внутри твёрдого тела.

					if (ptr[1][iP] != -1) {
						// контрольный объём принадлежит жидкой зоне.



						if (ptr[0][iP] > -1) {
							Fe = heate * f[ptr[1][iP]].mf[ptr[0][iP]][E_SIDE];

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							if (Fe != Fe) {
								std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
								printf("Fe=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fe);
								//printf("heate=%e ptr[1][iP]=%lld ptr[0][iP]=%lld mf=%e", heate, ptr[1][iP], ptr[0][iP], f[ptr[1][iP]].mf[ptr[0][iP]][E_SIDE]);
								std::cout << "heate=" << heate << " ptr[1][iP]=" << ptr[1][iP] << " ptr[0][iP]=" << ptr[0][iP] << " mf=" << f[ptr[1][iP]].mf[ptr[0][iP]][E_SIDE];
								system("PAUSE");
							}
#endif


						}

						//if (fabs(Ft)+fabs(Fb) > 0.0) {
#if doubleintprecision == 1
						//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%lld iP=%lld\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#else
						//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%d iP=%d\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#endif

						//getchar();
						//}


					}
					else {

						// контрольный объём iP принадлежит твёрдому телу.
						if (!bE) {
							if (ptr[1][iE] != -1) Fe = heate * f[ptr[1][iE]].mf[ptr[0][iE]][W_SIDE]; // контрольный объём iE принадлежит жидкости, а КО iP принадлежит твёрдому телу.
							else Fe = 0.0; // iP && iE принадлежат твёрдому телу.
						}
						else Fe = 0.0; // грань КО iP принадлежит твёрдотельной со стороны твёрдого тела границе расчётной области.

					}

					/*
					doublereal ts = Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb;
					if (ts != ts) {
					if (Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb > 1.0e-36) {
					printf("%d Fe=%e Fw=%e Fn=%e Fs=%e Ft=%e Fb=%e\n", iP, Fe, Fw, Fn, Fs, Ft, Fb);
					getchar();
					}
					}
					*/
				} // bconvective 
				  // конвективные потоки
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Fe != Fe) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fe=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fe);
					system("PAUSE");
				}
#endif
				if (iE > -1) {
					if (!bE) GE = prop[LAM][iE]; else GE = prop_b[LAM][iE - maxelm];
				}
				//if (!bE) GE=prop[LAM][iE]; else GE=GP;
				if (iE > -1) {
					Ge = GE * GP / (feplus * GE + (1 - feplus) * GP);
				}
				if (bortho86) {
					// Корректировка за счёт ортотропности:
					if (iE > -1) {
						if (iE >= maxelm) {
							// Граничный узел.
							if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iE - maxelm]) < 1.0e-23) {
								Ge *= prop[MULT_LAM_X][iP];
							}
						}
						else {
							// Внутренний узел.
							//if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iE]) < 1.0e-23) {
							//Ge *= prop[MULT_LAM_X][iP];
							//}
							// Дает температуру более близкую к истинной.
							//Ge *= 2.0*(prop[MULT_LAM_X][iE])*(prop[MULT_LAM_X][iP]) / (prop[MULT_LAM_X][iP] + prop[MULT_LAM_X][iE]);
							Ge *= fmax(prop[MULT_LAM_X][iE], prop[MULT_LAM_X][iP]);
						}
					}
				}
			}
//#pragma omp section 
			{
				if ((ptr != nullptr) && (bconvective))
				{
					// Если ptr==nullptr то отсутствует связь с гидродинамической частью и это означает
					// просто то что гидродинамической части нет как таковой и мы находимся в условиях
					// чистой теплопередачи внутри твёрдого тела.

					if (ptr[1][iP] != -1) {
						// контрольный объём принадлежит жидкой зоне.



						if (ptr[0][iP] > -1) {

							Fn = heatn * f[ptr[1][iP]].mf[ptr[0][iP]][N_SIDE];


#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							if (Fn != Fn) {
								std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
								printf("Fn=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fn);
								//printf("heatn=%e ptr[1][iP]=%lld ptr[0][iP]=%lld mf=%e", heatn, ptr[1][iP], ptr[0][iP], f[ptr[1][iP]].mf[ptr[0][iP]][N_SIDE]);
								std::cout << "heatn=" << heatn << " ptr[1][iP]=" << ptr[1][iP] << " ptr[0][iP]=" << ptr[0][iP] << " mf=" << f[ptr[1][iP]].mf[ptr[0][iP]][N_SIDE];
								system("PAUSE");
							}
#endif

						}

						//if (fabs(Ft)+fabs(Fb) > 0.0) {
#if doubleintprecision == 1
						//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%lld iP=%lld\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#else
						//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%d iP=%d\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#endif

						//getchar();
						//}


					}
					else {

						// контрольный объём iP принадлежит твёрдому телу.


						if (!bN) {
							if (ptr[1][iN] != -1) Fn = heatn * f[ptr[1][iN]].mf[ptr[0][iN]][S_SIDE];
							else Fn = 0.0;
						}
						else Fn = 0.0;

					}

					/*
					doublereal ts = Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb;
					if (ts != ts) {
					if (Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb > 1.0e-36) {
					printf("%d Fe=%e Fw=%e Fn=%e Fs=%e Ft=%e Fb=%e\n", iP, Fe, Fw, Fn, Fs, Ft, Fb);
					getchar();
					}
					}
					*/
				} // bconvective 
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Fn != Fn) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fn=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fn);
					system("PAUSE");
				}
#endif
				if (iN > -1) {
					if (!bN) GN = prop[LAM][iN]; else GN = prop_b[LAM][iN - maxelm];
				}
				//if (!bN) GN=prop[LAM][iN]; else GN=GP;
				if (iN > -1) {
					Gn = GN * GP / (fnplus * GN + (1 - fnplus) * GP);
				}
				if (bortho86) {
					// Корректировка за счёт ортотропности:
					if (iN > -1) {
						if (iN >= maxelm) {
							// Граничный узел.
							if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iN - maxelm]) < 1.0e-23) {
								Gn *= prop[MULT_LAM_Y][iP];
							}
						}
						else {
							// Внутренний узел.
							//if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iN]) < 1.0e-23) {
							//Gn *= prop[MULT_LAM_Y][iP];
							//}
							// Дает температуру более близкую к истинной.
							//Gn *= 2.0*(prop[MULT_LAM_Y][iN])*(prop[MULT_LAM_Y][iP]) / (prop[MULT_LAM_Y][iP] + prop[MULT_LAM_Y][iN]);
							Gn *= fmax(prop[MULT_LAM_Y][iN], prop[MULT_LAM_Y][iP]);
						}
					}
				}
			}
//#pragma omp section 
			{
				if ((ptr != nullptr) && (bconvective))
				{
					// Если ptr==nullptr то отсутствует связь с гидродинамической частью и это означает
					// просто то что гидродинамической части нет как таковой и мы находимся в условиях
					// чистой теплопередачи внутри твёрдого тела.

					if (ptr[1][iP] != -1) {
						// контрольный объём принадлежит жидкой зоне.			   

						if (ptr[0][iP] > -1) {

							Ft = heatt * f[ptr[1][iP]].mf[ptr[0][iP]][T_SIDE];

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							if (Ft != Ft) {
								std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
								printf("Ft=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ft);
								//printf("heatt=%e ptr[1][iP]=%lld ptr[0][iP]=%lld mf=%e", heatt, ptr[1][iP], ptr[0][iP], f[ptr[1][iP]].mf[ptr[0][iP]][T_SIDE]);
								std::cout << "heatt=" << heatt << " ptr[1][iP]=" << ptr[1][iP] << " ptr[0][iP]=" << ptr[0][iP] << " mf=" << f[ptr[1][iP]].mf[ptr[0][iP]][T_SIDE];
								system("PAUSE");
							}
#endif

						}

						//if (fabs(Ft)+fabs(Fb) > 0.0) {
#if doubleintprecision == 1
						//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%lld iP=%lld\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#else
						//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%d iP=%d\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#endif

						//getchar();
						//}


					}
					else {
						// контрольный объём iP принадлежит твёрдому телу.

						if (!bT) {
							if (ptr[1][iT] != -1) Ft = heatt * f[ptr[1][iT]].mf[ptr[0][iT]][B_SIDE];
							else Ft = 0.0;
						}
						else Ft = 0.0;
					}

					/*
					doublereal ts = Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb;
					if (ts != ts) {
					if (Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb > 1.0e-36) {
					printf("%d Fe=%e Fw=%e Fn=%e Fs=%e Ft=%e Fb=%e\n", iP, Fe, Fw, Fn, Fs, Ft, Fb);
					getchar();
					}
					}
					*/
				} // bconvective 
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Ft != Ft) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Ft=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ft);
					system("PAUSE");
				}
#endif
				if (iT > -1) {
					if (!bT) GT = prop[LAM][iT]; else GT = prop_b[LAM][iT - maxelm];
				}
				//if (!bT) GT=prop[LAM][iT]; else GT=GP;
				if (iT > -1) {
					Gt = GT * GP / (ftplus * GT + (1 - ftplus) * GP);
				}
				if (bortho86) {
					// Корректировка за счёт ортотропности:
					if (iT > -1) {
						if (iT >= maxelm) {
							// Граничный узел.
							if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iT - maxelm]) < 1.0e-23) {
								Gt *= prop[MULT_LAM_Z][iP];
							}
						}
						else {
							// Внутренний узел.
							//if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iT]) < 1.0e-23) {
							//Gt *= prop[MULT_LAM_Z][iP];
							//}
							// Дает температуру более близкую к истинной.
							//Gt *= 2.0*(prop[MULT_LAM_Z][iT])*(prop[MULT_LAM_Z][iP]) / (prop[MULT_LAM_Z][iP] + prop[MULT_LAM_Z][iT]);
							Gt *= fmax(prop[MULT_LAM_Z][iT], prop[MULT_LAM_Z][iP]);
						}
					}
				}
			}
//#pragma omp section 
			{
				if ((ptr != nullptr) && (bconvective))
				{
					// Если ptr==nullptr то отсутствует связь с гидродинамической частью и это означает
					// просто то что гидродинамической части нет как таковой и мы находимся в условиях
					// чистой теплопередачи внутри твёрдого тела.

					if (ptr[1][iP] != -1) {
						// контрольный объём принадлежит жидкой зоне.



						if (ptr[0][iP] > -1) {

							Fw = heatw * f[ptr[1][iP]].mf[ptr[0][iP]][W_SIDE];

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							if (Fw != Fw) {
								std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
								printf("Fw=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fw);
								//printf("heatw=%e ptr[1][iP]=%lld ptr[0][iP]=%lld mf=%e", heatw, ptr[1][iP], ptr[0][iP], f[ptr[1][iP]].mf[ptr[0][iP]][W_SIDE]);
								std::cout << "heatw=" << heatw << " ptr[1][iP]=" << ptr[1][iP] << " ptr[0][iP]=" << ptr[0][iP] << " mf=" << f[ptr[1][iP]].mf[ptr[0][iP]][W_SIDE];
								system("PAUSE");
							}
#endif

						}

						//if (fabs(Ft)+fabs(Fb) > 0.0) {
#if doubleintprecision == 1
						//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%lld iP=%lld\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#else
						//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%d iP=%d\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#endif

						//getchar();
						//}


					}
					else {



						// контрольный объём iP принадлежит твёрдому телу.

						if (!bW) {
							if (ptr[1][iW] != -1) Fw = heatw * f[ptr[1][iW]].mf[ptr[0][iW]][E_SIDE];
							else Fw = 0.0;
						}
						else Fw = 0.0;



					}

					/*
					doublereal ts = Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb;
					if (ts != ts) {
					if (Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb > 1.0e-36) {
					printf("%d Fe=%e Fw=%e Fn=%e Fs=%e Ft=%e Fb=%e\n", iP, Fe, Fw, Fn, Fs, Ft, Fb);
					getchar();
					}
					}
					*/
				} // bconvective 
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Fw != Fw) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fw=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fw);
					system("PAUSE");
				}
#endif
				if (iW > -1) {
					if (!bW) GW = prop[LAM][iW]; else GW = prop_b[LAM][iW - maxelm];
				}
				//if (!bW) GW=prop[LAM][iW]; else GW=GP;
				if (iW > -1) {
					Gw = GW * GP / (fwplus * GW + (1 - fwplus) * GP);
				}
				if (bortho86) {
					// Корректировка за счёт ортотропности:
					if (iW > -1) {
						if (iW >= maxelm) {
							// Граничный узел.
							if (fabs(prop[MULT_LAM_X][iP] - prop_b[MULT_LAM_X][iW - maxelm]) < 1.0e-23) {
								Gw *= prop[MULT_LAM_X][iP];
							}
						}
						else {
							// Внутренний узел.
							//if (fabs(prop[MULT_LAM_X][iP] - prop[MULT_LAM_X][iW]) < 1.0e-23) {
							//Gw *= prop[MULT_LAM_X][iP];
							//}
							// Дает температуру более близкую к истинной.
							//Gw *= 2.0*(prop[MULT_LAM_X][iW])*(prop[MULT_LAM_X][iP]) / (prop[MULT_LAM_X][iP] + prop[MULT_LAM_X][iW]);
							Gw *= fmax(prop[MULT_LAM_X][iW], prop[MULT_LAM_X][iP]);
						}
					}
				}
			}
//#pragma omp section 
			{
				if ((ptr != nullptr) && (bconvective))
				{
					// Если ptr==nullptr то отсутствует связь с гидродинамической частью и это означает
					// просто то что гидродинамической части нет как таковой и мы находимся в условиях
					// чистой теплопередачи внутри твёрдого тела.

					if (ptr[1][iP] != -1) {
						// контрольный объём принадлежит жидкой зоне.

						if (!b_on_adaptive_local_refinement_mesh) {

							if (ptr[0][iP] > -1) {

								Fs = heats * f[ptr[1][iP]].mf[ptr[0][iP]][S_SIDE];


#ifdef DEBUG_MY_ELMATR_QUAD_T3D
								if (Fs != Fs) {
									std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
									printf("Fs=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fs);
									//printf("heats=%e ptr[1][iP]=%lld ptr[0][iP]=%lld mf=%e", heats, ptr[1][iP], ptr[0][iP], f[ptr[1][iP]].mf[ptr[0][iP]][S_SIDE]);
									std::cout << "heats=" << heats << " ptr[1][iP]=" << ptr[1][iP] << " ptr[0][iP]=" << ptr[0][iP] << " mf=" << f[ptr[1][iP]].mf[ptr[0][iP]][S_SIDE];
									system("PAUSE");
								}
#endif

							}

							//if (fabs(Ft)+fabs(Fb) > 0.0) {
#if doubleintprecision == 1
							//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%lld iP=%lld\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#else
							//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%d iP=%d\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#endif

							//getchar();
							//}
						}

					}
					else {



						// контрольный объём iP принадлежит твёрдому телу.


						if (!bS) {
							if (ptr[1][iS] != -1) Fs = heats * f[ptr[1][iS]].mf[ptr[0][iS]][N_SIDE];
							else Fs = 0.0;
						}
						else Fs = 0.0;



					}

					/*
					doublereal ts = Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb;
					if (ts != ts) {
					if (Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb > 1.0e-36) {
					printf("%d Fe=%e Fw=%e Fn=%e Fs=%e Ft=%e Fb=%e\n", iP, Fe, Fw, Fn, Fs, Ft, Fb);
					getchar();
					}
					}
					*/
				} // bconvective 

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Fs != Fs) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fs=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fs);
					system("PAUSE");
				}
#endif
				if (iS > -1) {
					if (!bS) GS = prop[LAM][iS]; else GS = prop_b[LAM][iS - maxelm];
				}
				//if (!bS) GS=prop[LAM][iS]; else GS=GP;
				if (iS > -1) {
					Gs = GS * GP / (fsplus * GS + (1 - fsplus) * GP);
				}
				if (bortho86) {
					// Корректировка за счёт ортотропности:
					if (iS > -1) {
						if (iS >= maxelm) {
							// Граничный узел.
							if (fabs(prop[MULT_LAM_Y][iP] - prop_b[MULT_LAM_Y][iS - maxelm]) < 1.0e-23) {
								Gs *= prop[MULT_LAM_Y][iP];
							}
						}
						else {
							// Внутренний узел.
							//if (fabs(prop[MULT_LAM_Y][iP] - prop[MULT_LAM_Y][iS]) < 1.0e-23) {
							//Gs *= prop[MULT_LAM_Y][iP];
							//}
							// Дает температуру более близкую к истинной.
							//Gs *= 2.0*(prop[MULT_LAM_Y][iS])*(prop[MULT_LAM_Y][iP]) / (prop[MULT_LAM_Y][iP] + prop[MULT_LAM_Y][iS]);
							Gs *= fmax(prop[MULT_LAM_Y][iS], prop[MULT_LAM_Y][iP]);
						}
					}
				}
			}
//#pragma omp section
			{
				if ((ptr != nullptr) && (bconvective))
				{
					// Если ptr==nullptr то отсутствует связь с гидродинамической частью и это означает
					// просто то что гидродинамической части нет как таковой и мы находимся в условиях
					// чистой теплопередачи внутри твёрдого тела.

					if (ptr[1][iP] != -1) {
						// контрольный объём принадлежит жидкой зоне.



						if (ptr[0][iP] > -1) {

							Fb = heatb * f[ptr[1][iP]].mf[ptr[0][iP]][B_SIDE];

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
							if (Fb != Fb) {
								std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
								printf("Fb=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fb);
								//printf("heatb=%e ptr[1][iP]=%lld ptr[0][iP]=%lld mf=%e", heatb, ptr[1][iP], ptr[0][iP], f[ptr[1][iP]].mf[ptr[0][iP]][B_SIDE]);
								std::cout << "heatb=" << heatb << " ptr[1][iP]=" << ptr[1][iP] << " ptr[0][iP]=" << ptr[0][iP] << " mf=" << f[ptr[1][iP]].mf[ptr[0][iP]][B_SIDE];
								system("PAUSE");
							}
#endif
						}

						//if (fabs(Ft)+fabs(Fb) > 0.0) {
#if doubleintprecision == 1
						//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%lld iP=%lld\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#else
						//printf("fluid heatb=%e heatt=%e Fb=%e Ft=%e iflow=%d iP=%d\n", heatb, heatt, Fb, Ft, ptr[1][iP], ptr[0][iP]);
#endif

						//getchar();
						//}


					}
					else {

						// контрольный объём iP принадлежит твёрдому телу.
						if (!bB) {
							if (ptr[1][iB] != -1) Fb = heatb * f[ptr[1][iB]].mf[ptr[0][iB]][T_SIDE];
							else Fb = 0.0;
						}
						else Fb = 0.0;

					}

					/*
					doublereal ts = Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb;
					if (ts != ts) {
					if (Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb > 1.0e-36) {
					printf("%d Fe=%e Fw=%e Fn=%e Fs=%e Ft=%e Fb=%e\n", iP, Fe, Fw, Fn, Fs, Ft, Fb);
					getchar();
					}
					}
					*/
				} // bconvective

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Fb != Fb) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Fb=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Fb);
					system("PAUSE");
				}
#endif

				if (iB > -1) {
					if (!bB) GB = prop[LAM][iB]; else GB = prop_b[LAM][iB - maxelm];
				}
				// Экспериментальный и не рабочий вариант.	   
				//if (!bB) GB=prop[LAM][iB]; else GB=GP;

				// Теплопроводность на гранях внутреннего КО:	  
				if (iB > -1) {
					Gb = GB * GP / (fbplus * GB + (1 - fbplus) * GP);
				}

				if (bortho86) {
					// Корректировка за счёт ортотропности:
					if (iB > -1) {
						if (iB >= maxelm) {
							// Граничный узел.
							if (fabs(prop[MULT_LAM_Z][iP] - prop_b[MULT_LAM_Z][iB - maxelm]) < 1.0e-23) {
								Gb *= prop[MULT_LAM_Z][iP];
							}
						}
						else {
							// Внутренний узел.
							// Занижено, температура будет повыше.
							//if (fabs(prop[MULT_LAM_Z][iP] - prop[MULT_LAM_Z][iB]) < 1.0e-23) {
							//Gb *= prop[MULT_LAM_Z][iP];
							//}
							// Дает температуру более близкую к истинной.
							//Gb *= 2.0*(prop[MULT_LAM_Z][iB])*(prop[MULT_LAM_Z][iP]) / (prop[MULT_LAM_Z][iP]+ prop[MULT_LAM_Z][iB]);
							Gb *= fmax(prop[MULT_LAM_Z][iB], prop[MULT_LAM_Z][iP]);
						}
					}
				}

				// до.
				// контроль коэффициента теплопроводности:
				//printf("Ge=%e, Gw=%e, Gn=%e, Gs=%e, Gt=%e, Gb=%e\n",Ge,Gw,Gn,Gs,Gt,Gb);

			}
		}



		// Добавляем турбулентную теплопроводность.
		if (bconvective) {
			if (ptr != nullptr) {

				// закомментировано 15.04.2019.
				//if (!b_on_adaptive_local_refinement_mesh) 
				{

					if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
						(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
						(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
						(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {

						// Если мы имеем чисто твёрдотельную задачу, то в ней данный код не участвует,
						// так как связан с турбулентным добавком к теплопроводности.
						const doublereal dTurbulentPrandtlNumber = 0.85;

						if (iE > -1) {
							if (!bE) {
								bool bsolidP = false, bsolidS = false;
								doublereal turblamS = 0.0, turblamP = 0.0;

								if (ptr[1][iE] == -1) {
									// принадлежит твёрдому телу
									turblamS = 0.0;
									bsolidS = true;
								}
								else {
									if ((f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										turblamS = prop[HEAT_CAPACITY][iE] * f[ptr[1][iE]].potent[MUT][ptr[0][iE]] / dTurbulentPrandtlNumber;
									}
								}

								if (ptr[1][iP] == -1) {
									// принадлежит твёрдому телу
									turblamP = 0.0;
									bsolidP = true;
								}
								else {
									if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
									}
								}

								if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
									doublereal cpe = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iE] / ((1.0 - feplus)*prop[HEAT_CAPACITY][iP] + feplus*prop[HEAT_CAPACITY][iE]);
									if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
										if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
											Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
											Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
											Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
											Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}

									}
									else if ((bsolidP) && ((f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iE]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
										if (f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE]] > -1) {
											Ge += cpe*f[ptr[1][iE]].potent[MUT][f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iE]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE]] > -1) {
											Ge += cpe*f[ptr[1][iE]].potent[MUT][f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iE]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE]] > -1) {
											Ge += cpe*f[ptr[1][iE]].potent[MUT][f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iE]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE]] > -1) {
											Ge += cpe*f[ptr[1][iE]].potent[MUT][f[ptr[1][iE]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iE]]] / dTurbulentPrandtlNumber;
										}

									}

								}
								else if (!(bsolidS && bsolidP)) {
									Ge += feplus*turblamS + (1.0 - feplus)*turblamP;
								}

							}
							else {
								if (ptr[1][iP] != -1) {
									if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										doublereal cpe = prop_b[HEAT_CAPACITY][iE - maxelm];
										if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]] > -1) {
											Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]] > -1) {
											Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]] > -1) {
											Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]] > -1) {
											Ge += cpe*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
									}
								}
							}
						}


						if (iN > -1) {
							if (!bN) {
								bool bsolidP = false, bsolidS = false;
								doublereal turblamS = 0.0, turblamP = 0.0;

								if (ptr[1][iN] == -1) {
									// принадлежит твёрдому телу
									turblamS = 0.0;
									bsolidS = true;
								}
								else {
									if ((f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										turblamS = prop[HEAT_CAPACITY][iN] * f[ptr[1][iN]].potent[MUT][ptr[0][iN]] / dTurbulentPrandtlNumber;
									}
								}

								if (ptr[1][iP] == -1) {
									// принадлежит твёрдому телу
									turblamP = 0.0;
									bsolidP = true;
								}
								else {
									if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
									}
								}

								if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
									doublereal cpn = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iN] / ((1.0 - fnplus)*prop[HEAT_CAPACITY][iP] + fnplus*prop[HEAT_CAPACITY][iN]);
									if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
										if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
											Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
											Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
											Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
											Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
									}
									else if ((bsolidP) && ((f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iN]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
										if (f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN]] > -1) {
											Gn += cpn*f[ptr[1][iN]].potent[MUT][f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iN]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN]] > -1) {
											Gn += cpn*f[ptr[1][iN]].potent[MUT][f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iN]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN]] > -1) {
											Gn += cpn*f[ptr[1][iN]].potent[MUT][f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iN]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN]] > -1) {
											Gn += cpn*f[ptr[1][iN]].potent[MUT][f[ptr[1][iN]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iN]]] / dTurbulentPrandtlNumber;
										}
									}

								}
								else if (!(bsolidS && bsolidP)) {
									Gn += fnplus*turblamS + (1.0 - fnplus)*turblamP;
								}

							}
							else {
								if (ptr[1][iP] != -1) {
									if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										doublereal cpn = prop_b[HEAT_CAPACITY][iN - maxelm];
										if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]] > -1) {
											Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]] > -1) {
											Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]] > -1) {
											Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]] > -1) {
											Gn += cpn*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
									}
								}
							}
						}



						if (iT > -1) {
							if (!bT) {
								bool bsolidP = false, bsolidS = false;
								doublereal turblamS = 0.0, turblamP = 0.0;

								if (ptr[1][iT] == -1) {
									// принадлежит твёрдому телу
									turblamS = 0.0;
									bsolidS = true;
								}
								else {
									if ((f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										turblamS = prop[HEAT_CAPACITY][iT] * f[ptr[1][iT]].potent[MUT][ptr[0][iT]] / dTurbulentPrandtlNumber;
									}
								}

								if (ptr[1][iP] == -1) {
									// принадлежит твёрдому телу
									turblamP = 0.0;
									bsolidP = true;
								}
								else {
									if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
									}
								}

								if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
									doublereal cpt = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iT] / ((1.0 - ftplus)*prop[HEAT_CAPACITY][iP] + ftplus*prop[HEAT_CAPACITY][iT]);
									if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
										if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
											Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
											Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
											Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
											Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
									}
									else if ((bsolidP) && ((f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iT]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
										if (f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT]] > -1) {
											Gt += cpt*f[ptr[1][iT]].potent[MUT][f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iT]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT]] > -1) {
											Gt += cpt*f[ptr[1][iT]].potent[MUT][f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iT]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT]] > -1) {
											Gt += cpt*f[ptr[1][iT]].potent[MUT][f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iT]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT]] > -1) {
											Gt += cpt*f[ptr[1][iT]].potent[MUT][f[ptr[1][iT]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iT]]] / dTurbulentPrandtlNumber;
										}
									}
								}
								else if (!(bsolidS && bsolidP)) {
									Gt += ftplus*turblamS + (1.0 - ftplus)*turblamP;
								}

							}
							else {
								if (ptr[1][iP] != -1) {
									if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										doublereal cpt = prop_b[HEAT_CAPACITY][iT - maxelm];
										if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]] > -1) {
											Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]] > -1) {
											Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]] > -1) {
											Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]] > -1) {
											Gt += cpt*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
									}
								}
							}
						}



						if (iW > -1) {
							if (!bW) {
								bool bsolidP = false, bsolidS = false;
								doublereal turblamS = 0.0, turblamP = 0.0;

								if (ptr[1][iW] == -1) {
									// принадлежит твёрдому телу
									turblamS = 0.0;
									bsolidS = true;
								}
								else {
									if ((f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										turblamS = prop[HEAT_CAPACITY][iW] * f[ptr[1][iW]].potent[MUT][ptr[0][iW]] / dTurbulentPrandtlNumber;
									}
								}

								if (ptr[1][iP] == -1) {
									// принадлежит твёрдому телу
									turblamP = 0.0;
									bsolidP = true;
								}
								else {
									if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
									}
								}

								if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
									doublereal cpw = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iW] / ((1.0 - fwplus)*prop[HEAT_CAPACITY][iP] + fwplus*prop[HEAT_CAPACITY][iW]);
									if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
										if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
											Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
											Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
											Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
											Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
									}
									else if ((bsolidP) && ((f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iW]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
										if (f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW]] > -1) {
											Gw += cpw*f[ptr[1][iW]].potent[MUT][f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][0][ptr[0][iW]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW]] > -1) {
											Gw += cpw*f[ptr[1][iW]].potent[MUT][f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][1][ptr[0][iW]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW]] > -1) {
											Gw += cpw*f[ptr[1][iW]].potent[MUT][f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][2][ptr[0][iW]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW]] > -1) {
											Gw += cpw*f[ptr[1][iW]].potent[MUT][f[ptr[1][iW]].neighbors_for_the_internal_node[E_SIDE][3][ptr[0][iW]]] / dTurbulentPrandtlNumber;
										}
									}
								}
								else if (!(bsolidS && bsolidP)) {
									Gw += fwplus*turblamS + (1.0 - fwplus)*turblamP;
								}

							}
							else {
								if (ptr[1][iP] != -1) {
									if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										doublereal cpw = prop_b[HEAT_CAPACITY][iW - maxelm];
										if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]] > -1) {
											Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]] > -1) {
											Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]] > -1) {
											Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]] > -1) {
											Gw += cpw*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[W_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
									}
								}
							}
						}



						if (iS > -1) {
							if (!bS) {
								bool bsolidP = false, bsolidS = false;
								doublereal turblamS = 0.0, turblamP = 0.0;

								if (ptr[1][iS] == -1) {
									// принадлежит твёрдому телу
									turblamS = 0.0;
									bsolidS = true;
								}
								else {
									if ((f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										turblamS = prop[HEAT_CAPACITY][iS] * f[ptr[1][iS]].potent[MUT][ptr[0][iS]] / dTurbulentPrandtlNumber;
									}
								}

								if (ptr[1][iP] == -1) {
									// принадлежит твёрдому телу
									turblamP = 0.0;
									bsolidP = true;
								}
								else {
									if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
									}
								}

								if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
									doublereal cps = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iS] / ((1.0 - fsplus)*prop[HEAT_CAPACITY][iP] + fsplus*prop[HEAT_CAPACITY][iS]);
									if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
										if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
											Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
											Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
											Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
											Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
									}
									else if ((bsolidP) && ((f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iS]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
										if (f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS]] > -1) {
											Gs += cps*f[ptr[1][iS]].potent[MUT][f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][0][ptr[0][iS]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS]] > -1) {
											Gs += cps*f[ptr[1][iS]].potent[MUT][f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][1][ptr[0][iS]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS]] > -1) {
											Gs += cps*f[ptr[1][iS]].potent[MUT][f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][2][ptr[0][iS]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS]] > -1) {
											Gs += cps*f[ptr[1][iS]].potent[MUT][f[ptr[1][iS]].neighbors_for_the_internal_node[N_SIDE][3][ptr[0][iS]]] / dTurbulentPrandtlNumber;
										}
									}

								}
								else if (!(bsolidS && bsolidP)) {
									Gs += fsplus*turblamS + (1.0 - fsplus)*turblamP;
								}

							}
							else {
								if (ptr[1][iP] != -1) {
									if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										doublereal cps = prop_b[HEAT_CAPACITY][iS - maxelm];
										if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]] > -1) {
											Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]] > -1) {
											Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]] > -1) {
											Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]] > -1) {
											Gs += cps*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[S_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}

									}
								}
							}
						}



						if (iB > -1) {
							if (!bB) {
								bool bsolidP = false, bsolidS = false;
								doublereal turblamS = 0.0, turblamP = 0.0;

								if (ptr[1][iB] == -1) {
									// принадлежит твёрдому телу
									turblamS = 0.0;
									bsolidS = true;
								}
								else {
									if ((f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										turblamS = prop[HEAT_CAPACITY][iB] * f[ptr[1][iB]].potent[MUT][ptr[0][iB]] / dTurbulentPrandtlNumber;
									}
								}

								if (ptr[1][iP] == -1) {
									// принадлежит твёрдому телу
									turblamP = 0.0;
									bsolidP = true;
								}
								else {
									if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										turblamP = prop[HEAT_CAPACITY][iP] * f[ptr[1][iP]].potent[MUT][ptr[0][iP]] / dTurbulentPrandtlNumber;
									}
								}

								if ((bsolidS || bsolidP) && (!(bsolidS && bsolidP))) {
									doublereal cpb = prop[HEAT_CAPACITY][iP] * prop[HEAT_CAPACITY][iB] / ((1.0 - fbplus)*prop[HEAT_CAPACITY][iP] + fbplus*prop[HEAT_CAPACITY][iB]);
									if ((bsolidS) && ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
										if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
											Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
											Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
											Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
											Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
									}
									else if ((bsolidP) && ((f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iB]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS))) {
										if (f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB]] > -1) {
											Gb += cpb*f[ptr[1][iB]].potent[MUT][f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][0][ptr[0][iB]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB]] > -1) {
											Gb += cpb*f[ptr[1][iB]].potent[MUT][f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][1][ptr[0][iB]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB]] > -1) {
											Gb += cpb*f[ptr[1][iB]].potent[MUT][f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][2][ptr[0][iB]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB]] > -1) {
											Gb += cpb*f[ptr[1][iB]].potent[MUT][f[ptr[1][iB]].neighbors_for_the_internal_node[T_SIDE][3][ptr[0][iB]]] / dTurbulentPrandtlNumber;
										}
									}
								}
								else if (!(bsolidS && bsolidP)) {
									Gb += fbplus*turblamS + (1.0 - fbplus)*turblamP;
								}

							}
							else {
								if (ptr[1][iP] != -1) {
									if ((f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::ZEROEQMOD) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_SPALART_ALLMARES) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_MENTER_SST) ||
										(f[ptr[1][iP]].iflowregime == VISCOSITY_MODEL::RANS_STANDART_K_EPS)) {
										doublereal cpb = prop_b[HEAT_CAPACITY][iB - maxelm];
										if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]] > -1) {
											Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][0][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]] > -1) {
											Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][1][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]] > -1) {
											Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][2][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
										else if (f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]] > -1) {
											Gb += cpb*f[ptr[1][iP]].potent[MUT][f[ptr[1][iP]].neighbors_for_the_internal_node[B_SIDE][3][ptr[0][iP]]] / dTurbulentPrandtlNumber;
										}
									}
								}
							}
						}

					}
				}
			}
		}  // Турбулентная теплопроводность.



//#pragma omp parallel sections
		{
//#pragma omp section
			{
				// Это не помогло не капли.
				// Здесь я просто хотел чтобы навнутренней грани источника тепла 
				// теплопроводность была одинаковой с обоих сторон и в граничной сборке
				// и для сборки во внутренности расчётной области.
				if (bsT1) {
					Gt = conductivity2Dinsource[iT - maxelm];
					Gt *= prop[MULT_LAM_Z][iP];
				}

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Gt != Gt) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Gt=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gt);
					system("pause");
				}
#endif
				if (!bT) {
					if (bB) Dt = dbeta * Gt * dx * dy / dzt;
					else Dt = Gt * dx * dy / dzt;
				}
				else Dt = dbeta * Gt * dx * dy / dzt;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Dt <= 0.0) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error negative or zero Dt=%e\n", Dt);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (Dt != Dt) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error  Dt=%e is NAN or INF\n", Dt);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif
				Pt = Ft / Dt;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Pt != Pt) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error  Pt=%e is NAN or INF\n", Pt);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif
			}
//#pragma omp section
			{
				if (bsB1) {
					Gb = conductivity2Dinsource[iB - maxelm];
					Gb *= prop[MULT_LAM_Z][iP];
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Gb != Gb) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Gb=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gb);
					system("pause");
				}
#endif
				if (!bB) {
					if (bT) Db = dbeta * Gb * dx * dy / dzb;
					else Db = Gb * dx * dy / dzb;
				}
				else Db = dbeta * Gb * dx * dy / dzb;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Db <= 0.0) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error negative or zero Db=%e\n", Db);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (Db != Db) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error  Db=%e is NAN or INF\n", Db);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif
				Pb = -Fb / Db;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Pb != Pb) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error  Pb=%e is NAN or INF\n", Pb);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif
			}
//#pragma omp section 
			{
				if (bsN1) {
					Gn = conductivity2Dinsource[iN - maxelm];
					Gn *= prop[MULT_LAM_Y][iP];
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Gn != Gn) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Gn=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gn);
					system("pause");
				}
#endif
				if (!bN) {
					if (bS) Dn = dbeta * Gn * dx * dz / dyn;
					else Dn = Gn * dx * dz / dyn;
				}
				else Dn = dbeta * Gn * dx * dz / dyn;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Dn <= 0.0) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error negative or zero Dn=%e\n", Dn);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (Dn != Dn) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error  Dn=%e is NAN or INF\n", Dn);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif
				Pn = Fn / Dn;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Pn != Pn) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error  Pn=%e is NAN or INF\n", Pn);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif
			}
//#pragma omp section
			{
				if (bsS1) {
					Gs = conductivity2Dinsource[iS - maxelm];
					Gs *= prop[MULT_LAM_Y][iP];
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Gs != Gs) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Gs=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gs);
					system("pause");
				}
#endif
				if (!bS) {
					if (bN) Ds = dbeta * Gs * dx * dz / dys;
					else Ds = Gs * dx * dz / dys;
				}
				else Ds = dbeta * Gs * dx * dz / dys;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Ds <= 0.0) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error negative or zero Ds=%e\n", Ds);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (Ds != Ds) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error  Ds=%e is NAN or INF\n", Ds);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif
				Ps = -Fs / Ds;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Ps != Ps) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error  Ps=%e is NAN or INF\n", Ps);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif
			}
//#pragma omp section
			{
				if (bsE1) {
					Ge = conductivity2Dinsource[iE - maxelm];
					Ge *= prop[MULT_LAM_X][iP];
				}
				// Поверка коэффициента диффузии.
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Ge != Ge) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Ge=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Ge);
					system("pause");
				}
#endif
				if (!bE) {
					if (bW) De = dbeta * Ge * dy * dz / dxe;
					else De = Ge * dy * dz / dxe;
				}
				else De = dbeta * Ge * dy * dz / dxe;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (De <= 0.0) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error negative or zero De=%e\n", De);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (De != De) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error  De=%e is NAN or INF\n", De);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif
				// Внимание!!! Вычисление чисел Пекле здесь годится только для
				// структурированной сетки. Для АЛИС см. реализацию ниже где
				// правильно учитывается домножение на площадь.

				Pe = Fe / De;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Pe != Pe) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error  Pe=%e is NAN or INF\n", Pe);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif
			}
//#pragma omp section
			{
				if (bsW1) {
					Gw = conductivity2Dinsource[iW - maxelm];
					Gw *= prop[MULT_LAM_X][iP];
				}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Gw != Gw) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Gw=%e in function my_elmatr_quad_T3D. Error NAN or INF.\n", Gw);
					system("pause");
				}
#endif
				if (!bW) {
					if (bE) Dw = dbeta * Gw * dy * dz / dxw;
					else Dw = Gw * dy * dz / dxw;
				}
				else Dw = dbeta * Gw * dy * dz / dxw;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Dw <= 0.0) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error negative or zero Dw=%e\n", Dw);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (Dw != Dw) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error  Dw=%e is NAN or INF\n", Dw);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif
				Pw = -Fw / Dw;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (Pw != Pw) {
					std::cout << b[whot_is_block[iP]].name << " is fluid type." << std::endl;
					printf("Error  Pw=%e is NAN or INF\n", Pw);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif
			}
		}



		// после.
		// контроль коэффициента теплопроводности:
		//printf("Ge=%e, Gw=%e, Gn=%e, Gs=%e, Gt=%e, Gb=%e\n",Ge,Gw,Gn,Gs,Gt,Gb);
		//getchar();

		// Диффузионная составляющая потока:
		// Если источник лежит на границе расчётной области, 
		// то порядок аппроксимации на границе можно повысить с помощью 
		// задания коэффициента beta отличного от единицы.






		doublereal baddDFLUX2 = 0.0;
		// Этот более высокий порядок аппроксимации вызывает осцилляции с шагом сетки.
		bool bhighorder = false; // включает или выключает добавок увеличивающий порядок точности.



		if (ishconvection < distsheme) {
			// Вычисление коэффициентов дискретного аналога:
			if (bconvective)
			{
				if (!bsE) sl[iP].ae = De*ApproxConvective(fabs(Pe), ishconvection) + fmax(-Fe, 0); else sl[iP].ae = 0.0;
				if (!bsW) sl[iP].aw = Dw*ApproxConvective(fabs(Pw), ishconvection) + fmax(Fw, 0);  else sl[iP].aw = 0.0;
				if (!bsN) sl[iP].an = Dn*ApproxConvective(fabs(Pn), ishconvection) + fmax(-Fn, 0); else sl[iP].an = 0.0;
				if (!bsS) sl[iP].as = Ds*ApproxConvective(fabs(Ps), ishconvection) + fmax(Fs, 0); else sl[iP].as = 0.0;
				if (!bsT) sl[iP].at = Dt*ApproxConvective(fabs(Pt), ishconvection) + fmax(-Ft, 0); else sl[iP].at = 0.0;
				if (!bsB) sl[iP].ab = Db*ApproxConvective(fabs(Pb), ishconvection) + fmax(Fb, 0); else sl[iP].ab = 0.0;

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
				if (sl[iP].ae < 0.0) {
					std::cout << b[whot_is_block[iP]].name << std::endl;
					printf("Error UDS negative ae=%e\n", sl[iP].ae);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (sl[iP].aw < 0.0) {
					std::cout << b[whot_is_block[iP]].name << std::endl;
					printf("Error UDS negative aw=%e\n", sl[iP].aw);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (sl[iP].an < 0.0) {
					std::cout << b[whot_is_block[iP]].name << std::endl;
					printf("Error UDS negative an=%e\n", sl[iP].an);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (sl[iP].as < 0.0) {
					std::cout << b[whot_is_block[iP]].name << std::endl;
					printf("Error UDS negative as=%e\n", sl[iP].as);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (sl[iP].at < 0.0) {
					std::cout << b[whot_is_block[iP]].name << std::endl;
					printf("Error UDS negative at=%e\n", sl[iP].at);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
				if (sl[iP].ab < 0.0) {
					std::cout << b[whot_is_block[iP]].name << std::endl;
					printf("Error UDS negative ab=%e\n", sl[iP].ab);
					printf("in my_elmatr_quad_T3D function\n");
					system("pause");
				}
#endif

			}
			else
			{

				// Вычисление 
				// коэффициентов
				// дискретного аналога:
				if (!bsE) sl[iP].ae = De; else sl[iP].ae = 0.0;
				if (!bsW) sl[iP].aw = Dw; else sl[iP].aw = 0.0;
				if (!bsN) sl[iP].an = Dn; else sl[iP].an = 0.0;
				if (!bsS) sl[iP].as = Ds; else sl[iP].as = 0.0;
				if (!bsT) sl[iP].at = Dt; else sl[iP].at = 0.0;
				if (!bsB) sl[iP].ab = Db; else sl[iP].ab = 0.0;

				baddDFLUX2 = 0.0; // инициализация.
				if (bhighorder) { // проверено !
								  // если bborder == false то узел строго внутренний.
								  // если bborder   то мы находимся вблизи граничного узла.
					bool bborder = false;
					doublereal myflux = 0.0;
					//myflux=De*(dxe*DFDXiP(potent, iP, ESIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iE]));
					//baddDFLUX2+=myflux;
					//myflux=Dw*(-dxw*DFDXiP(potent, iP, WSIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iW]));
					//baddDFLUX2+=myflux;
					//myflux=Dn*(dyn*DFDXiP(potent, iP, N, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iN]));
					//baddDFLUX2+=myflux;
					//myflux=Ds*(-dys*DFDXiP(potent, iP, S, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iS]));
					//baddDFLUX2+=myflux;
					//myflux=Dt*(dzt*DFDXiP(potent, iP, TSIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iT]));
					//baddDFLUX2+=myflux;
					//myflux=Db*(-dzb*DFDXiP(potent, iP, B, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iB]));
					//baddDFLUX2+=myflux;
					//baddDFLUX2*=-1.0;
					myflux = De*(dxe*DFDXiP(potent, iP, E_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iE]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dw*(-dxw*DFDXiP(potent, iP, W_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iW]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dn*(dyn*DFDXiP(potent, iP, N_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iN]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Ds*(-dys*DFDXiP(potent, iP, S_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iS]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dt*(dzt*DFDXiP(potent, iP, T_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iT]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Db*(-dzb*DFDXiP(potent, iP, B_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iB]));
					if (!bborder) baddDFLUX2 += myflux;
					//baddDFLUX2*=-1.0;  // проверено нужно именно +1.0.
				}

			}
		}
		else if (ishconvection < QUICK)
		{
			// Вычисление коэффициентов дискретного аналога:
			if (bconvective)
			{
				if (!bsE) sl[iP].ae = -Fe*fC(Pe, ishconvection, true, feplus) + De*fD(Pe, ishconvection, true, feplus); else sl[iP].ae = 0.0;
				if (!bsW) sl[iP].aw = Fw*fC(Pw, ishconvection, true, fwplus) + Dw*fD(Pw, ishconvection, true, fwplus); else sl[iP].aw = 0.0;
				if (!bsN) sl[iP].an = -Fn*fC(Pn, ishconvection, true, fnplus) + Dn*fD(Pn, ishconvection, true, fnplus); else sl[iP].an = 0.0;
				if (!bsS) sl[iP].as = Fs*fC(Ps, ishconvection, true, fsplus) + Ds*fD(Ps, ishconvection, true, fsplus); else sl[iP].as = 0.0;
				if (!bsT) sl[iP].at = -Ft*fC(Pt, ishconvection, true, ftplus) + Dt*fD(Pt, ishconvection, true, ftplus); else sl[iP].at = 0.0;
				if (!bsB) sl[iP].ab = Fb*fC(Pb, ishconvection, true, fbplus) + Db*fD(Pb, ishconvection, true, fbplus); else sl[iP].ab = 0.0;
			}
			else
			{
				// число Пекле равно 0.
				// fD(Pe) возвращает 1.0.

				// Вычисление 
				// коэффициентов
				// дискретного аналога:
				if (!bsE) sl[iP].ae = De; else sl[iP].ae = 0.0;
				if (!bsW) sl[iP].aw = Dw; else sl[iP].aw = 0.0;
				if (!bsN) sl[iP].an = Dn; else sl[iP].an = 0.0;
				if (!bsS) sl[iP].as = Ds; else sl[iP].as = 0.0;
				if (!bsT) sl[iP].at = Dt; else sl[iP].at = 0.0;
				if (!bsB) sl[iP].ab = Db; else sl[iP].ab = 0.0;

				baddDFLUX2 = 0.0; // инициализация.
				if (bhighorder) { // проверено !
								  // если bborder == false то узел строго внутренний.
								  // если bborder   то мы находимся вблизи граничного узла.
					bool bborder = false;
					doublereal myflux = 0.0;/*
											myflux=De*(dxe*DFDXiP(potent, iP, ESIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iE]));
											baddDFLUX2+=myflux;
											myflux=Dw*(-dxw*DFDXiP(potent, iP, WSIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iW]));
											baddDFLUX2+=myflux;
											myflux=Dn*(dyn*DFDXiP(potent, iP, N, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iN]));
											baddDFLUX2+=myflux;
											myflux=Ds*(-dys*DFDXiP(potent, iP, S, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iS]));
											baddDFLUX2+=myflux;
											myflux=Dt*(dzt*DFDXiP(potent, iP, TSIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iT]));
											baddDFLUX2+=myflux;
											myflux=Db*(-dzb*DFDXiP(potent, iP, B, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iB]));
											baddDFLUX2+=myflux;
											//baddDFLUX2*=-1.0;*/
					myflux = De*(dxe*DFDXiP(potent, iP, E_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iE]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dw*(-dxw*DFDXiP(potent, iP, W_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iW]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dn*(dyn*DFDXiP(potent, iP, N_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iN]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Ds*(-dys*DFDXiP(potent, iP, S_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iS]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dt*(dzt*DFDXiP(potent, iP, T_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iT]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Db*(-dzb*DFDXiP(potent, iP, B_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iB]));
					if (!bborder) baddDFLUX2 += myflux;
					//baddDFLUX2*=-1.0;  // проверено нужно именно +1.0.
				}
			}
		}
		else if (ishconvection >= QUICK)
		{

			// С учётом конвекции.
			bool berrE = false, berrW = false, berrN = false, berrS = false, berrT = false, berrB = false;
			bool bpatch = true;

			// В 3D пространстве данная схема расщепляется на три одномерных схемы.
			// Схема Леонарда имеет второй порядок и реализуется с помощью механизма отложенной коррекции.

			TOCHKA pointP;
			center_cord3D(iP, nvtx, pa, pointP, 100);

			// X - direction
			doublereal positionxP = pointP.x, positionxE = pointP.x, positionxW = pointP.x, positionxEE = pointP.x, positionxWW = pointP.x, positionxe = pointP.x, positionxw = pointP.x;
			doublereal FiP = 0.0, FiE = 0.0, FiW = 0.0, FiEE = 0.0, FiWW = 0.0, FiN = 0.0, FiS = 0.0;
			doublereal FiNN = 0.0, FiSS = 0.0, FiT = 0.0, FiB = 0.0, FiTT = 0.0, FiBB = 0.0;
			doublereal Fie = 0.0, Fiw = 0.0, Fin = 0.0, Fis = 0.0, Fit = 0.0, Fib = 0.0;
			// Y - direction
			doublereal positionyP = pointP.y, positionyN = pointP.y, positionyS = pointP.y, positionyNN = pointP.y, positionySS = pointP.y, positionyn = pointP.y, positionys = pointP.y;
			// Z - direction
			doublereal positionzP = pointP.z, positionzT = pointP.z, positionzB = pointP.z, positionzTT = pointP.z, positionzBB = pointP.z, positionzt = pointP.z, positionzb = pointP.z;


			if (bconvective)
			{




				
				//printf("iP");
				//system("pause");
				positionxP = pointP.x; positionyP = pointP.y; positionzP = pointP.z;
				FiP = potent[iP];
				// X - direction
				if (!bE) {
					FiE = potent[iE];
					center_cord3D(iE, nvtx, pa, pointP, E_SIDE);
					//printf("iE");
					//system("pause");
					positionxE = pointP.x;
					positionxe = positionxP + 0.5*dx;

					integer iEE = neighbors_for_the_internal_node[EE_SIDE][0][iP];
					if ((iEE >= 0) && (iEE < maxelm)) {
						// внутренний узел
						FiEE = potent[iEE];
						center_cord3D(iEE, nvtx, pa, pointP, EE_SIDE);
						//printf("iEE");
						//system("pause");
						positionxEE = pointP.x;
						integer ib_1, ib_2, ib_3, ib_4;
						ib_1 = whot_is_block[iP];
						ib_2 = whot_is_block[iE];
						ib_3 = whot_is_block[iEE];
						if (!bW) ib_4 = whot_is_block[iW];
						if ((!bW) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

						}
						else {
							if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
								//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
								//getchar();
								//FiEE = 0.0;
								berrE = true;
							}
						}
					}
					else
					{
						integer ib_1 = whot_is_block[iP];
						integer ib_2 = whot_is_block[iE];
						if ((b[ib_1].itype != b[ib_2].itype)) {
							//printf("problem found\n");
							//getchar();
							berrE = true;
						}

						// граничный узел
						FiEE = potent[iEE];
						volume3D(iE, nvtx, pa, pointP.x, pointP.y, pointP.z);
						positionxEE = positionxE + 0.5*pointP.x;
					}
				}
				else {
					// это граничный узел
					FiE = potent[iE];
					FiEE = potent[iE];
					positionxe = positionxP + 0.5*dx;
					positionxE = positionxP + 0.5*dx;
					positionxEE = positionxP + dx; // этого узла не существует !
				}

				if (!bW) {
					center_cord3D(iW, nvtx, pa, pointP, W_SIDE);
					//printf("iW");
					//system("pause");
					positionxW = pointP.x;
					positionxw = positionxP - 0.5*dx;
					FiW = potent[iW];

					integer iWW = neighbors_for_the_internal_node[WW_SIDE][0][iP];
					if ((iWW >= 0) && (iWW < maxelm)) {
						// внутренний узел
						FiWW = potent[iWW];
						center_cord3D(iWW, nvtx, pa, pointP, WW_SIDE);
						//printf("iWW");
						//system("pause");
						positionxWW = pointP.x;

						integer ib_1, ib_2, ib_3, ib_4;
						ib_1 = whot_is_block[iP];
						ib_2 = whot_is_block[iW];
						ib_3 = whot_is_block[iWW];
						if (!bE) ib_4 = whot_is_block[iE];
						if ((!bE) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

						}
						else {
							if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
								//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
								//getchar();
								//FiWW = 0.0;
								berrW = true;
							}
						}
					}
					else
					{
						integer ib_1 = whot_is_block[iP];
						integer ib_2 = whot_is_block[iW];
						if ((b[ib_1].itype != b[ib_2].itype)) {
							//printf("problem found\n");
							//getchar();
							berrW = true;
						}

						// граничный узел
						FiWW = potent[iWW];
						volume3D(iW, nvtx, pa, pointP.x, pointP.y, pointP.z);
						positionxWW = positionxW - 0.5*pointP.x;
					}
				}
				else {
					// это граничный узел
					FiW = potent[iW];
					FiWW = potent[iW];
					positionxw = positionxP - 0.5*dx;
					positionxW = positionxP - 0.5*dx;
					positionxWW = positionxP - dx; // этого узла не существует !
				}

				// Y - direction
				if (!bN) {
					FiN = potent[iN];
					center_cord3D(iN, nvtx, pa, pointP, N_SIDE);
					//printf("iN");
					//system("pause");
					positionyN = pointP.y;
					positionyn = positionxP + 0.5*dy;

					integer iNN = neighbors_for_the_internal_node[NN_SIDE][0][iP];
					if ((iNN >= 0) && (iNN < maxelm)) {
						// внутренний узел
						FiNN = potent[iNN];
						center_cord3D(iNN, nvtx, pa, pointP, NN_SIDE);
						//printf("iNN");
						//system("pause");
						positionyNN = pointP.y;

						integer ib_1, ib_2, ib_3, ib_4;
						ib_1 = whot_is_block[iP];
						ib_2 = whot_is_block[iN];
						ib_3 = whot_is_block[iNN];
						if (!bS) ib_4 = whot_is_block[iS];
						if ((!bS) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

						}
						else {
							if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
								//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
								//getchar();
								//FiNN = 0.0;
								berrN = true;
							}
						}
					}
					else
					{
						integer ib_1 = whot_is_block[iP];
						integer ib_2 = whot_is_block[iN];
						if ((b[ib_1].itype != b[ib_2].itype)) {
							//printf("problem found\n");
							//getchar();
							berrN = true;
						}

						// граничный узел
						FiNN = potent[iNN];
						volume3D(iN, nvtx, pa, pointP.x, pointP.y, pointP.z);
						positionyNN = positionyN + 0.5*pointP.y;
					}
				}
				else {
					// это граничный узел
					FiN = potent[iN];
					FiNN = potent[iN];
					positionyn = positionyP + 0.5*dy;
					positionyN = positionyP + 0.5*dy;
					positionyNN = positionyP + dy; // этого узла не существует !
				}

				if (!bS) {
					FiS = potent[iS];
					center_cord3D(iS, nvtx, pa, pointP, S_SIDE);
					//printf("iS");
					//system("pause");
					positionyS = pointP.y;
					positionys = positionyP - 0.5*dy;

					integer iSS = neighbors_for_the_internal_node[SS_SIDE][0][iP];
					if ((iSS >= 0) && (iSS < maxelm)) {
						// внутренний узел
						FiSS = potent[iSS];
						center_cord3D(iSS, nvtx, pa, pointP, SS_SIDE);
						//printf("iSS");
						//system("pause");
						positionySS = pointP.y;

						integer ib_1, ib_2, ib_3, ib_4;
						ib_1 = whot_is_block[iP];
						ib_2 = whot_is_block[iS];
						ib_3 = whot_is_block[iSS];
						if (!bN) ib_4 = whot_is_block[iN];
						if ((!bN) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

						}
						else {
							if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
								//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
								//getchar();
								//FiSS = 0.0;
								berrS = true;
							}
						}
					}
					else
					{
						integer ib_1 = whot_is_block[iP];
						integer ib_2 = whot_is_block[iS];
						if ((b[ib_1].itype != b[ib_2].itype)) {
							//printf("problem found\n");
							//getchar();
							berrS = true;
						}

						// граничный узел
						FiSS = potent[iSS];
						volume3D(iS, nvtx, pa, pointP.x, pointP.y, pointP.z);
						positionySS = positionyS - 0.5*pointP.y;
					}
				}
				else {
					// это граничный узел
					FiS = potent[iS]; // ATTANTION !!!! 
					FiSS = potent[iS]; // нулевая скорость внутри твёрдого тела.
					positionys = positionyP - 0.5*dy;
					positionyS = positionyP - 0.5*dy;
					positionySS = positionyP - dy; // этого узла не существует !
				}

				// Z - direction
				if (!bT) {
					FiT = potent[iT];
					center_cord3D(iT, nvtx, pa, pointP, T_SIDE);
					//printf("iT");
					//system("pause");
					positionzT = pointP.z;
					positionzt = positionzP + 0.5*dz;

					integer iTT = neighbors_for_the_internal_node[TT_SIDE][0][iP];
					if ((iTT >= 0) && (iTT < maxelm)) {
						// внутренний узел
						FiTT = potent[iTT];
						center_cord3D(iTT, nvtx, pa, pointP, TT_SIDE);
						//printf("iTT");
						//system("pause");
						positionzTT = pointP.z;

						integer ib_1, ib_2, ib_3, ib_4;
						ib_1 = whot_is_block[iP];
						ib_2 = whot_is_block[iT];
						ib_3 = whot_is_block[iTT];
						if (!bB) ib_4 = whot_is_block[iB];
						if ((!bB) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

						}
						else {
							if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
								//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
								//getchar();
								//FiTT = 0.0;
								berrT = true;
							}
						}
					}
					else
					{
						integer ib_1 = whot_is_block[iP];
						integer ib_2 = whot_is_block[iT];
						if ((b[ib_1].itype != b[ib_2].itype)) {
							//printf("problem found\n");
							//getchar();
							berrT = true;
						}
						// граничный узел
						FiTT = potent[iTT];
						volume3D(iT, nvtx, pa, pointP.x, pointP.y, pointP.z);
						positionzTT = positionzT + 0.5*pointP.z;
					}
				}
				else {
					// это граничный узел
					FiT = potent[iT];
					FiTT = potent[iT]; // скорость внутри твёрдого тела
					positionzt = positionzP + 0.5*dz;
					positionzT = positionzP + 0.5*dz;
					positionzTT = positionzP + dz; // этого узла не существует !
				}

				if (!bB) {
					FiB = potent[iB];
					center_cord3D(iB, nvtx, pa, pointP, B_SIDE);
					//printf("iB");
					//system("pause");
					positionzB = pointP.z;
					positionzb = positionzP - 0.5*dz;

					integer iBB = neighbors_for_the_internal_node[BB_SIDE][0][iP];
					if ((iBB >= 0) && (iBB < maxelm)) {
						// внутренний узел
						FiBB = potent[iBB];
						center_cord3D(iBB, nvtx, pa, pointP, BB_SIDE);
						//printf("iBB");
						//system("pause");
						positionzBB = pointP.z;

						integer ib_1, ib_2, ib_3, ib_4;
						ib_1 = whot_is_block[iP];
						ib_2 = whot_is_block[iB];
						ib_3 = whot_is_block[iBB];
						if (!bT) ib_4 = whot_is_block[iT];
						if ((!bT) && (b[ib_1].itype == b[ib_2].itype) && (b[ib_1].itype == b[ib_3].itype) && (b[ib_1].itype == b[ib_4].itype)) {

						}
						else {
							if ((bpatch) || ((b[ib_2].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib_3].itype == PHYSICS_TYPE_IN_BODY::FLUID))) {
								//printf("06.01.2018 FLUID SOLID FLUID sequence\n");
								//getchar();
								//FiBB = 0.0;
								berrB = true;
							}
						}
					}
					else
					{
						integer ib_1 = whot_is_block[iP];
						integer ib_2 = whot_is_block[iB];
						if ((b[ib_1].itype != b[ib_2].itype)) {
							//printf("problem found\n");
							//getchar();
							berrB = true;
						}
						// граничный узел
						FiBB = potent[iBB];
						volume3D(iB, nvtx, pa, pointP.x, pointP.y, pointP.z);
						positionzBB = positionzB - 0.5*pointP.z;
					}
				}
				else {
					// это граничный узел
					FiB = potent[iB];
					FiBB = potent[iB]; // скорость внутри твёрдого тела
					positionzb = positionzP - 0.5*dz;
					positionzB = positionzP - 0.5*dz;
					positionzBB = positionzP - dz; // этого узла не существует !
				}

				if ((ishconvection >= QUICK) && (ishconvection <= FROMM)) {
					// X - direction
					Fie = cell_face_value_global(ishconvection, (Fe), FiW, FiP, FiE, FiEE);
					Fiw = cell_face_value_global(ishconvection, (Fw), FiWW, FiW, FiP, FiE);
					// Y - direction
					Fin = cell_face_value_global(ishconvection, (Fn), FiS, FiP, FiN, FiNN);
					Fis = cell_face_value_global(ishconvection, (Fs), FiSS, FiS, FiP, FiN);
					// Z - direction
					Fit = cell_face_value_global(ishconvection, (Ft), FiB, FiP, FiT, FiTT);
					Fib = cell_face_value_global(ishconvection, (Fb), FiBB, FiB, FiP, FiT);

				}



				if (ishconvection >= UNEVENQUICK) {


					/*
					// закомментированный фрагмент относится к одной устаревшей реализации схемы QUICK на неравномерной сетке.
					// Реализация была заимствована из статьи: ...
					// В данный момент данная реализация не используется.
					//doublereal gamma1E, gamma2E, gamma1W, gamma2W, delta1E, delta2E, delta1W, delta2W;
					//doublereal gamma1N, gamma2N, gamma1S, gamma2S, delta1N, delta2N, delta1S, delta2S;
					//doublereal gamma1T, gamma2T, gamma1B, gamma2B, delta1T, delta2T, delta1B, delta2B;
					// X - direction
					// gamma
					//gamma1E=((positionxe-positionxE)*(positionxe-positionxP))/((positionxW-positionxE)*(positionxW-positionxP));
					//gamma2E=((positionxe-positionxP)*(positionxe-positionxW))/((positionxE-positionxP)*(positionxE-positionxW));
					//gamma1W=((positionxw-positionxP)*(positionxw-positionxW))/((positionxWW-positionxP)*(positionxWW-positionxW));
					//gamma2W=((positionxw-positionxW)*(positionxw-positionxWW))/((positionxP-positionxW)*(positionxP-positionxWW));
					// delta
					//delta1E=((positionxe-positionxEE)*(positionxe-positionxE))/((positionxP-positionxEE)*(positionxP-positionxE));
					//delta2E=((positionxe-positionxE)*(positionxe-positionxP))/((positionxEE-positionxE)*(positionxEE-positionxP));
					//delta1W=((positionxw-positionxE)*(positionxw-positionxP))/((positionxW-positionxE)*(positionxW-positionxP));
					//delta2W=((positionxw-positionxP)*(positionxw-positionxW))/((positionxE-positionxP)*(positionxE-positionxW));
					// Y - direction
					// gamma
					//gamma1N=((positionyn-positionyN)*(positionyn-positionyP))/((positionyS-positionyN)*(positionyS-positionyP));
					//gamma2N=((positionyn-positionyP)*(positionyn-positionyS))/((positionyN-positionyP)*(positionyN-positionyS));
					//gamma1S=((positionys-positionyP)*(positionys-positionyS))/((positionySS-positionyP)*(positionySS-positionyS));
					//gamma2S=((positionys-positionyS)*(positionys-positionySS))/((positionyP-positionyS)*(positionyP-positionySS));
					// delta
					//delta1N=((positionyn-positionyNN)*(positionyn-positionyN))/((positionyP-positionyNN)*(positionyP-positionyN));
					//delta2N=((positionyn-positionyN)*(positionyn-positionyP))/((positionyNN-positionyN)*(positionyNN-positionyP));
					//delta1S=((positionys-positionyN)*(positionys-positionyP))/((positionyS-positionyN)*(positionyS-positionyP));
					//delta2S=((positionys-positionyP)*(positionys-positionyS))/((positionyN-positionyP)*(positionyN-positionyS));
					// Z - direction
					// gamma
					//gamma1T=((positionzt-positionzT)*(positionzt-positionzP))/((positionzB-positionzT)*(positionzB-positionzP));
					//gamma2T=((positionzt-positionzP)*(positionzt-positionzB))/((positionzT-positionzP)*(positionzT-positionzB));
					//gamma1B=((positionzb-positionzP)*(positionzb-positionzB))/((positionzBB-positionzP)*(positionzBB-positionzB));
					//gamma2B=((positionzb-positionzB)*(positionzb-positionzBB))/((positionzP-positionzB)*(positionzP-positionzBB));
					// delta
					//delta1T=((positionzt-positionzTT)*(positionzt-positionzT))/((positionzP-positionzTT)*(positionzP-positionzT));
					//delta2T=((positionzt-positionzT)*(positionzt-positionzP))/((positionzTT-positionzT)*(positionzTT-positionzP));
					//delta1B=((positionzb-positionzT)*(positionzb-positionzP))/((positionzB-positionzT)*(positionzB-positionzP));
					//delta2B=((positionzb-positionzP)*(positionzb-positionzB))/((positionzT-positionzP)*(positionzT-positionzB));
					*/



					// Вычисление искомой величины на грани КО
					// используется схема Леонарда QUICK.
					/* таблица соответствия:
					*  A	B	C	D	e	+/-
					*  W	P	E	-	e	+
					*  -	P	E	EE  e   -
					*  WW   W	P	-	w	+
					*  -	W	P	E	w	-
					*  S	P	N	-	n	+
					*  -	P	N	NN  n	-
					*  SS   S	P	-	s	+
					*  -	S	P	N	s	-
					*  B	P	T	-	t	+
					*  -	P	T	TT  t	-
					*  BB   B	P	-	b	+
					*  -	B	P	T	b	-
					*/

					if (ishconvection == UNEVENQUICK)
					{
						// X - direction
						Fie = workQUICK(dx, 2.0*(positionxE - positionxe), positionxW, positionxP, positionxE, positionxEE, FiW, FiP, FiE, FiEE, (Fe));
						Fiw = workQUICK(2.0*(positionxw - positionxW), dx, positionxWW, positionxW, positionxP, positionxE, FiWW, FiW, FiP, FiE, (Fw));
						// Y - direction
						Fin = workQUICK(dy, 2.0*(positionyN - positionyn), positionyS, positionyP, positionyN, positionyNN, FiS, FiP, FiN, FiNN, (Fn));
						Fis = workQUICK(2.0*(positionys - positionyS), dy, positionySS, positionyS, positionyP, positionyN, FiSS, FiS, FiP, FiN, (Fs));
						// Z - direction
						Fit = workQUICK(dz, 2.0*(positionzT - positionzt), positionzB, positionzP, positionzT, positionzTT, FiB, FiP, FiT, FiTT, (Ft));
						Fib = workQUICK(2.0*(positionzb - positionzB), dz, positionzBB, positionzB, positionzP, positionzT, FiBB, FiB, FiP, FiT, (Fb));
					}

					if ((ishconvection > UNEVENQUICK) && (ishconvection <= UNEVEN_CUBISTA))
					{
						// Пока на данный момент рекомендуется попробовать использовать только первые четыре схемы:
						// 1. UNEVEN_MUSCL, 2. UNEVEN_SOUCUP, 3. UNEVEN_HLPA, 4. UNEVEN_SMART.
						// перечисленные схемы прошли предварительную проверку.

						// X - direction
						Fie = workKN_VOLKOV(positionxW, positionxP, positionxE, positionxEE, FiW, FiP, FiE, FiEE, (Fe), ishconvection);
						Fiw = workKN_VOLKOV(positionxWW, positionxW, positionxP, positionxE, FiWW, FiW, FiP, FiE, (Fw), ishconvection);
						// Y - direction
						Fin = workKN_VOLKOV(positionyS, positionyP, positionyN, positionyNN, FiS, FiP, FiN, FiNN, (Fn), ishconvection);
						Fis = workKN_VOLKOV(positionySS, positionyS, positionyP, positionyN, FiSS, FiS, FiP, FiN, (Fs), ishconvection);
						// Z - direction
						Fit = workKN_VOLKOV(positionzB, positionzP, positionzT, positionzTT, FiB, FiP, FiT, FiTT, (Ft), ishconvection);
						Fib = workKN_VOLKOV(positionzBB, positionzB, positionzP, positionzT, FiBB, FiB, FiP, FiT, (Fb), ishconvection);

					}

				}
			}



			// Ссылка: SIMPLE method for the solution of incompressible flows on non-staggered grids
			// I. Sezai - Eastern Mediterranean University, Mechanical Engineering Department, Mersin 10-Turkey Revised in 
			// January, 2011.

			// Вычисление коэффициентов дискретного аналога:
			// Реализуется метод отложенной коррекции:
			// неявно реализуется только противопоточная часть, 
			// а уточняющие члены записываются в правую часть 
			// линейной системы уравнений.
			if (bconvective)
			{

				//if (!bsE) sl[iP].ae = De*fD(Pe, EXP2, true, feplus) + fmax(-(Fe), 0); else sl[iP].ae = 0.0;
				//if (!bsW) sl[iP].aw = Dw*fD(Pw, EXP2, true, fwplus) + fmax((Fw), 0); else sl[iP].aw = 0.0;
				//if (!bsN) sl[iP].an = Dn*fD(Pn, EXP2, true, fnplus) + fmax(-(Fn), 0); else sl[iP].an = 0.0;
				//if (!bsS) sl[iP].as = Ds*fD(Ps, EXP2, true, fsplus) + fmax((Fs), 0); else sl[iP].as = 0.0;
				//if (!bsT) sl[iP].at = Dt*fD(Pt, EXP2, true, ftplus) + fmax(-(Ft), 0); else sl[iP].at = 0.0;
				//if (!bsB) sl[iP].ab = Db*fD(Pb, EXP2, true, fbplus) + fmax((Fb), 0);  else sl[iP].ab = 0.0;

				// Нужно просто UDS.
				// так рекомендуют в интернетах.

				if (!bsE) sl[iP].ae = De + fmax(-(Fe), 0); else sl[iP].ae = 0.0;
				if (!bsW) sl[iP].aw = Dw + fmax((Fw), 0); else sl[iP].aw = 0.0;
				if (!bsN) sl[iP].an = Dn + fmax(-(Fn), 0); else sl[iP].an = 0.0;
				if (!bsS) sl[iP].as = Ds + fmax((Fs), 0); else sl[iP].as = 0.0;
				if (!bsT) sl[iP].at = Dt + fmax(-(Ft), 0); else sl[iP].at = 0.0;
				if (!bsB) sl[iP].ab = Db + fmax((Fb), 0);  else sl[iP].ab = 0.0;

				attrs = 0.0;

				// 6.01.2018
				if (!bsE)  if (!berrE) attrs += -fmax((Fe), 0)*(Fie - FiP) + fmax(-(Fe), 0)*(Fie - FiE);
				if (!bsW)  if (!berrW) attrs += -fmax(-(Fw), 0)*(Fiw - FiP) + fmax((Fw), 0)*(Fiw - FiW);
				if (!bsN)  if (!berrN) attrs += -fmax((Fn), 0)*(Fin - FiP) + fmax(-(Fn), 0)*(Fin - FiN);
				if (!bsS)  if (!berrS) attrs += -fmax(-(Fs), 0)*(Fis - FiP) + fmax((Fs), 0)*(Fis - FiS);
				if (!bsT)  if (!berrT) attrs += -fmax((Ft), 0)*(Fit - FiP) + fmax(-(Ft), 0)*(Fit - FiT);
				if (!bsB)  if (!berrB) attrs += -fmax(-(Fb), 0)*(Fib - FiP) + fmax((Fb), 0)*(Fib - FiB);

				//attrs=0.0; // сброс схемы Леонарда.
			}
			else
			{
				// Вычисление 
				// коэффициентов
				// дискретного аналога:
				if (!bsE) sl[iP].ae = De; else sl[iP].ae = 0.0;
				if (!bsW) sl[iP].aw = Dw; else sl[iP].aw = 0.0;
				if (!bsN) sl[iP].an = Dn; else sl[iP].an = 0.0;
				if (!bsS) sl[iP].as = Ds; else sl[iP].as = 0.0;
				if (!bsT) sl[iP].at = Dt; else sl[iP].at = 0.0;
				if (!bsB) sl[iP].ab = Db; else sl[iP].ab = 0.0;

				attrs = 0.0; // только диффузия.

				baddDFLUX2 = 0.0; // инициализация.
				if (bhighorder) { // проверено !
								  // если bborder == false то узел строго внутренний.
								  // если bborder   то мы находимся вблизи граничного узла.
					bool bborder = false;
					doublereal myflux = 0.0;/*
											myflux=De*(dxe*DFDXiP(potent, iP, ESIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iE]));
											baddDFLUX2+=myflux;
											myflux=Dw*(-dxw*DFDXiP(potent, iP, WSIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iW]));
											baddDFLUX2+=myflux;
											myflux=Dn*(dyn*DFDXiP(potent, iP, N, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iN]));
											baddDFLUX2+=myflux;
											myflux=Ds*(-dys*DFDXiP(potent, iP, S, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iS]));
											baddDFLUX2+=myflux;
											myflux=Dt*(dzt*DFDXiP(potent, iP, TSIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iT]));
											baddDFLUX2+=myflux;
											myflux=Db*(-dzb*DFDXiP(potent, iP, B, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder)+(potent[iP]-potent[iB]));
											baddDFLUX2+=myflux;
											//baddDFLUX2*=-1.0;*/
					myflux = De*(dxe*DFDXiP(potent, iP, E_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iE]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dw*(-dxw*DFDXiP(potent, iP, W_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iW]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dn*(dyn*DFDXiP(potent, iP, N_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iN]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Ds*(-dys*DFDXiP(potent, iP, S_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iS]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Dt*(dzt*DFDXiP(potent, iP, T_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iT]));
					if (!bborder) baddDFLUX2 += myflux;
					myflux = Db*(-dzb*DFDXiP(potent, iP, B_SIDE, neighbors_for_the_internal_node, maxelm, nvtx, pa, bborder) + (potent[iP] - potent[iB]));
					if (!bborder) baddDFLUX2 += myflux;
					//baddDFLUX2*=-1.0; // проверено нужно именно +1.0.
				}
			}


		}

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
		if (attrs != attrs) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: attrs=%e in function my_elmatr_quad_T3D\n", attrs);
			system("pause");
		}
#endif

		//printf("%e %e %e %e %e %e\n",sl[iP].ae,sl[iP].aw, sl[iP].an, sl[iP].as, sl[iP].at, sl[iP].ab);
		//getchar(); // GOOD

	}

	doublereal tau, apzero1, apzero0;
	doublereal Fold = 0.0; // значение функции с предыдущего временного слоя
	if (btimedep) {
		// нестационарный
		tau = tauparam; // шаг по времени
		if (toldtimestep != nullptr) {
			Fold = toldtimestep[iP]; // температура с предыдущего временного шага по времени.
		}
		else {
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
			printf("Fatal error!!! in function my_elmatr_quad_T3D. toldtimestep == nullptr in unsteady modelling...");
			system("PAUSE");
			exit(1);
#endif
		}
	}
	else {
		// стационарный

		// введём псевдовремя:
		// Согласно Гаврилову Андрею псевдо время для SIMPLE процедуры вычисляется
		// по формуле (Ч5.1.12) которая приведена в части 5 описания на sigmaflow.
		if (b_on_adaptive_local_refinement_mesh) {
			doublereal sum_2 = sl[iP].ae2 + sl[iP].aw2 + sl[iP].an2 + sl[iP].as2 + sl[iP].at2 + sl[iP].ab2;
			doublereal sum_3 = sl[iP].ae3 + sl[iP].aw3 + sl[iP].an3 + sl[iP].as3 + sl[iP].at3 + sl[iP].ab3;
			doublereal sum_4 = sl[iP].ae4 + sl[iP].aw4 + sl[iP].an4 + sl[iP].as4 + sl[iP].at4 + sl[iP].ab4;
			tau = rP*dx*dy*dz*alpha / ((sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab + sum_2 + sum_3 + sum_4));
		}
		else {
			tau = rP*dx*dy*dz*alpha / ((sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab));
		}
		Fold = potent[iP];
	}

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (sl[iP].ae != sl[iP].ae) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: sl[iP].ae=%e in function my_elmatr_quad_T3D\n", sl[iP].ae);
		system("pause");
	}
	if (sl[iP].aw != sl[iP].aw) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: sl[iP].aw=%e in function my_elmatr_quad_T3D\n", sl[iP].aw);
		system("pause");
	}
	if (sl[iP].an != sl[iP].an) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: sl[iP].an=%e in function my_elmatr_quad_T3D\n", sl[iP].an);
		system("pause");
	}
	if (sl[iP].as != sl[iP].as) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: sl[iP].as=%e in function my_elmatr_quad_T3D\n", sl[iP].as);
		system("pause");
	}
	if (sl[iP].at != sl[iP].at) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: sl[iP].at=%e in function my_elmatr_quad_T3D\n", sl[iP].at);
		system("pause");
	}
	if (sl[iP].ab != sl[iP].ab) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: sl[iP].ab=%e in function my_elmatr_quad_T3D\n", sl[iP].ab);
		system("pause");
	}
	if (b_on_adaptive_local_refinement_mesh) {
		if (sl[iP].ae2 != sl[iP].ae2) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].ae2=%e in function my_elmatr_quad_T3D\n", sl[iP].ae2);
			system("pause");
		}
		if (sl[iP].aw2 != sl[iP].aw2) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].aw2=%e in function my_elmatr_quad_T3D\n", sl[iP].aw2);
			system("pause");
		}
		if (sl[iP].an2 != sl[iP].an2) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].an2=%e in function my_elmatr_quad_T3D\n", sl[iP].an2);
			system("pause");
		}
		if (sl[iP].as2 != sl[iP].as2) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].as2=%e in function my_elmatr_quad_T3D\n", sl[iP].as2);
			system("pause");
		}
		if (sl[iP].at2 != sl[iP].at2) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].at2=%e in function my_elmatr_quad_T3D\n", sl[iP].at2);
			system("pause");
		}
		if (sl[iP].ab2 != sl[iP].ab2) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].ab2=%e in function my_elmatr_quad_T3D\n", sl[iP].ab2);
			system("pause");
		}
		if (sl[iP].ae3 != sl[iP].ae3) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].ae3=%e in function my_elmatr_quad_T3D\n", sl[iP].ae3);
			system("pause");
		}
		if (sl[iP].aw3 != sl[iP].aw3) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].aw3=%e in function my_elmatr_quad_T3D\n", sl[iP].aw3);
			system("pause");
		}
		if (sl[iP].an3 != sl[iP].an3) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].an3=%e in function my_elmatr_quad_T3D\n", sl[iP].an3);
			system("pause");
		}
		if (sl[iP].as3 != sl[iP].as3) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].as3=%e in function my_elmatr_quad_T3D\n", sl[iP].as3);
			system("pause");
		}
		if (sl[iP].at3 != sl[iP].at3) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].at3=%e in function my_elmatr_quad_T3D\n", sl[iP].at3);
			system("pause");
		}
		if (sl[iP].ab3 != sl[iP].ab3) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].ab3=%e in function my_elmatr_quad_T3D\n", sl[iP].ab3);
			system("pause");
		}
		if (sl[iP].ae4 != sl[iP].ae4) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].ae4=%e in function my_elmatr_quad_T3D\n", sl[iP].ae4);
			system("pause");
		}
		if (sl[iP].aw4 != sl[iP].aw4) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].aw4=%e in function my_elmatr_quad_T3D\n", sl[iP].aw4);
			system("pause");
		}
		if (sl[iP].an4 != sl[iP].an4) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].an4=%e in function my_elmatr_quad_T3D\n", sl[iP].an4);
			system("pause");
		}
		if (sl[iP].as4 != sl[iP].as4) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].as4=%e in function my_elmatr_quad_T3D\n", sl[iP].as4);
			system("pause");
		}
		if (sl[iP].at4 != sl[iP].at4) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].at4=%e in function my_elmatr_quad_T3D\n", sl[iP].at4);
			system("pause");
		}
		if (sl[iP].ab4 != sl[iP].ab4) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("Error NAN or INF: sl[iP].ab4=%e in function my_elmatr_quad_T3D\n", sl[iP].ab4);
			system("pause");
		}
	}
#endif

	// Внимание! при решении уравнений Навье-Стокса в нестационарной постановке давление нужно будет
	// брать с предыдущего временного шага. 
	if ((!btimedep) && (!imitation_time)) {
		// стационарный и имитация шагов по времени не используется
		apzero1 = 0.0; // с нового временного слоя.
		apzero0 = 0.0; // с предыдущего временного слоя
	}
	else {
		// Это неактивно, проверено 7 августа 2016.
		// 15 сентября 2016 Это активно при нестационарной теплопередаче в твёрдом теле.
		//printf("Told comming\n");
		//getchar();

		apzero0 = apzero1 = rP*dx*dy*dz / tau; // rho1*cp1*dx*dy*dz/tau. // ap01

											   /*
											   ВНИМАНИЕ!!! Так делать нельзя никогда.
											   TOCHKA p; // координаты центра КО.
											   integer ib; // номер блока которому принадлежит КО.
											   doublereal rho=1.1614, cp=1005; // инициализация default  dry air 300K 1atm properties
											   center_cord3D(iP, nvtx, pa, p,100); // вычисление координат центра КО.
											   in_model_temp(p,ib,b,lb); // возвращает номер блока ib которому принадлежит контрольный объём с номером iP.

											   if (matlist[b[ib].imatid].blibmat==1) {
											   // библиотечный, внутрипрограммный материал.
											   if (b[ib].itype== PHYSICS_TYPE_IN_BODY::SOLID) {
											   doublereal lam=0.0; // не используемое далее значение.
											   my_solid_properties(Fold, rho, cp, lam, matlist[b[ib].imatid].ilibident);
											   } // SOLID
											   if (b[ib].itype== PHYSICS_TYPE_IN_BODY::FLUID) {
											   doublereal mu, beta_t, lam; // значения не используются но требуются.
											   doublereal pressure;
											   if (ptr != nullptr) {
											   if (ptr[1][iP] == -1) {
											   pressure = 0.0; // давление внутри твёрдого тела (этого не может быть, т.к. здесь обязательно жидкость).
											   }
											   else pressure = f[ptr[1][iP]].potent[PRESS][ptr[0][iP]];
											   }
											   else {
											   // ptr==nullptr
											   pressure = 0.0;
											   }
											   my_fluid_properties(Fold, pressure, rho, cp, lam, mu, beta_t, matlist[b[ib].imatid].ilibident);
											   } // FLUID
											   }
											   else if (matlist[b[ib].imatid].blibmat==0) {
											   // материал определённый пользователем:
											   // постоянные свойства.
											   rho=matlist[b[ib].imatid].rho;
											   //cp=matlist[b[ib].imatid].cp;
											   cp = get_lam(matlist[b[ib].imatid].n_cp, matlist[b[ib].imatid].temp_cp, matlist[b[ib].imatid].arr_cp, Fold);

											   }
											   */
											   // Наверно нехорошо если apzero0 и apzero1 вычисляются по разным формулам.
											   // ГИПОТЕЗА: это может приводить к потери консервативности схемы.
											   // Консервативность схемы теряется. НИКОГДА не делать их разными. Они 
											   // должны быть абсолютно одинаковыми.
											   //apzero0=rho*cp*dx*dy*dz/tau; // ap00

											   //printf("apzero0=%e, apzero1=%e\n",apzero0,apzero1);
											   //getchar();
	}

	// Теперь т.к. теплоёмкость и плотность зависят от температуры,
	// необходимо также вычислить коээфициент ap00 с предыдущего временного слоя:

	/*if (iP==20) {
	printf("tau=%e\n",tau);
	getchar();
	}*/

	// источниковый член
	doublereal dSc = Sc2D;
	doublereal dSp = 0.0;
	if (btimedep) {
		//if (ipower_time_depend > 0) {
		//if (poweron_multiplier_sequence > 0.1) {
		//printf("%d %e\n", ipower_time_depend, poweron_multiplier_sequence);
		//getchar();
		//}
		//}

		// нестационарный решатель.
		if (ipower_time_depend == POWER_TIME_DEPEND::CONST_POWER) {
			// Мощность внутри блока не зависит от времени и выделяется постоянно.
			dSc += dSc_out;
		}
		else if (ipower_time_depend == POWER_TIME_DEPEND::SQUARE_WAVE) {
			// Мощность выделяется только в моменты отличности от нуля multiplyera.
			if (poweron_multiplier_sequence > 0.0) {
				dSc += dSc_out;
			}
		}
		else if (ipower_time_depend == POWER_TIME_DEPEND::SQUARE_WAVE2) {
			// Square Wave Apparat.
			// Мощность выделяется только в моменты отличности от нуля multiplyera
			// с учётом значения константы multiplyer.
			if (poweron_multiplier_sequence > 0.0) {
				dSc += dSc_out*poweron_multiplier_sequence;
			}
		}
		else if (ipower_time_depend == POWER_TIME_DEPEND::HOT_COLD) {
			// Мощность выделяется только в моменты отличности от нуля multiplyera.
			if (poweron_multiplier_sequence > 0.0) {
				dSc += dSc_out;
			}
		}
		else if (ipower_time_depend == POWER_TIME_DEPEND::PIECEWISE_CONST) {
			// piecewise const
			if (poweron_multiplier_sequence > 0.0) {
				dSc += dSc_out * poweron_multiplier_sequence;

			}
		}
	}
	else {
		dSc += dSc_out;
	}

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (dSc != dSc) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: dSc=%e in function my_elmatr_quad_T3D\n", dSc);
		system("pause");
	}
#endif
	/*if (iP==23901) {
	printf("ae=%e, aw=%e, an=%e, as=%e, at=%e, ab=%e\n",sl[iP].ae,sl[iP].aw,sl[iP].an,sl[iP].as,sl[iP].at,sl[iP].ab);
	printf("ap01=%e, source=%e\n",apzero1,dSp*dx*dy*dz);
	getchar();
	}
	*/

	// Учтём энергию диссипируемую в виде тепла благодаря вязкости:
	doublereal rbdissipate = 0.0;
	if ((ptr != nullptr) && (ptr[1][iP] != -1)) {
		// контрольный объём принадлежит жидкой зоне.
		rbdissipate += f[ptr[1][iP]].prop[MU_DYNAMIC_VISCOSITY][ptr[0][iP]] * f[ptr[1][iP]].SInvariantStrainRateTensor[ptr[0][iP]] * f[ptr[1][iP]].SInvariantStrainRateTensor[ptr[0][iP]];
		/*if (inumglobaliter>=66) {
		printf("mu=%e, tensor=%e\n",f[ptr[1][iP]].prop[MU][ptr[0][iP]], f[ptr[1][iP]].SInvariantStrainRateTensor[ptr[0][iP]]);
		}*/
	}
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (rbdissipate != rbdissipate) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: rbdissipate=%e in function my_elmatr_quad_T3D\n", rbdissipate);
		system("pause");
	}
#endif
	//printf("rbdissipate=%e\n",rbdissipate);
	//getchar();

	// проверка источникового члена.
	//printf("dSp=%e, dSc=%e\n",dSp,dSc);
	//getchar();
	if (b_on_adaptive_local_refinement_mesh) {
		doublereal sum_2 = sl[iP].ae2 + sl[iP].aw2 + sl[iP].an2 + sl[iP].as2 + sl[iP].at2 + sl[iP].ab2;
		doublereal sum_3 = sl[iP].ae3 + sl[iP].aw3 + sl[iP].an3 + sl[iP].as3 + sl[iP].at3 + sl[iP].ab3;
		doublereal sum_4 = sl[iP].ae4 + sl[iP].aw4 + sl[iP].an4 + sl[iP].as4 + sl[iP].at4 + sl[iP].ab4;
		sl[iP].ap = sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab;
		if (bconvective) {
			// С конвекцией
			// Стационарный гидродинамический решатель
			if (!btimedep) {
				sl[iP].ap += sum_2 + sum_3 + sum_4 - dSp * dx * dy * dz;
			}
			else {
				sl[iP].ap += sum_2 + sum_3 + sum_4 + apzero1 - dSp * dx * dy * dz;
			}
		}
		else {
			sl[iP].ap += sum_2 + sum_3 + sum_4 + apzero1 - dSp * dx* dy* dz;//+apzero1-dSp*dx*dy*dz; // диагональный элемент матрицы
		}
	}
	else {

		if (bconvective) {
			if (ishconvection < distsheme) {
				// 07.05.2017
				// Моя наработка:
				// ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).
				//sl[iP].ap = sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].ab + sl[iP].at;
				
				if (!bsE) {
					sl[iP].ap = De*ApproxConvective(fabs(Pe), ishconvection) + fmax(+(Fe), 0);
				}
				else {
					sl[iP].ap = 0.0;
				}
				if (!bsW) {
					sl[iP].ap += Dw*ApproxConvective(fabs(Pw), ishconvection) + fmax(-(Fw), 0);
				}
				if (!bsN) {
					sl[iP].ap += Dn*ApproxConvective(fabs(Pn), ishconvection) + fmax(+(Fn), 0);
				}
				if (!bsS) {
					sl[iP].ap += Ds*ApproxConvective(fabs(Ps), ishconvection) + fmax(-(Fs), 0);
				}
				if (!bsT) {
					sl[iP].ap += Dt*ApproxConvective(fabs(Pt), ishconvection) + fmax(+(Ft), 0);
				}
				if (!bsB) {
					sl[iP].ap += Db*ApproxConvective(fabs(Pb), ishconvection) + fmax(-(Fb), 0);
				}
				
			}
			else if (ishconvection < QUICK)
			{
				//  8.05.2017
				// Моя наработка:
				// ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).

				if (!bsE) sl[iP].ap = +Fe*fC(Pe, ishconvection, true, feplus) + De*fD(Pe, ishconvection, true, feplus); else sl[iP].ap = 0.0;
				if (!bsW) sl[iP].ap += -Fw*fC(Pw, ishconvection, true, fwplus) + Dw*fD(Pw, ishconvection, true, fwplus); else sl[iP].ap += 0.0;
				if (!bsN) sl[iP].ap += +Fn*fC(Pn, ishconvection, true, fnplus) + Dn*fD(Pn, ishconvection, true, fnplus); else sl[iP].ap += 0.0;
				if (!bsS) sl[iP].ap += -Fs*fC(Ps, ishconvection, true, fsplus) + Ds*fD(Ps, ishconvection, true, fsplus); else sl[iP].ap += 0.0;
				if (!bsT) sl[iP].ap += +Ft*fC(Pt, ishconvection, true, ftplus) + Dt*fD(Pt, ishconvection, true, ftplus); else sl[iP].ap += 0.0;
				if (!bsB) sl[iP].ap += -Fb*fC(Pb, ishconvection, true, fbplus) + Db*fD(Pb, ishconvection, true, fbplus); else sl[iP].ap += 0.0;

			}
			else if (ishconvection >= QUICK)
			{

				//  8.05.2017
				// Моя наработка:
				// ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).
				//if (!bsE) sl[iP].ap = De*fD(Pe, EXP2, true, feplus) + fmax(+(Fe), 0); else sl[iP].ap = 0.0;
				//if (!bsW) sl[iP].ap += Dw*fD(Pw, EXP2, true, fwplus) + fmax(-(Fw), 0); else sl[iP].ap += 0.0;
				//if (!bsN) sl[iP].ap += Dn*fD(Pn, EXP2, true, fnplus) + fmax(+(Fn), 0); else sl[iP].ap += 0.0;
				//if (!bsS) sl[iP].ap += Ds*fD(Ps, EXP2, true, fsplus) + fmax(-(Fs), 0); else sl[iP].ap += 0.0;
				//if (!bsT) sl[iP].ap += Dt*fD(Pt, EXP2, true, ftplus) + fmax(+(Ft), 0); else sl[iP].ap += 0.0;
				//if (!bsB) sl[iP].ap += Db*fD(Pb, EXP2, true, fbplus) + fmax(-(Fb), 0);  else sl[iP].ap += 0.0;

				// Нужно просто UDS.
				// так рекомендуют в интернетах.
				// Моя наработка:
				// ЗНАКИ РЕВЕРСИРОВАНЫ !!! (опробовано на ПТБШ).
				if (!bsE) sl[iP].ap = De + fmax(+(Fe), 0); else sl[iP].ap = 0.0;
				if (!bsW) sl[iP].ap += Dw + fmax(-(Fw), 0); else sl[iP].ap += 0.0;
				if (!bsN) sl[iP].ap += Dn + fmax(+(Fn), 0); else sl[iP].ap += 0.0;
				if (!bsS) sl[iP].ap += Ds + fmax(-(Fs), 0); else sl[iP].ap += 0.0;
				if (!bsT) sl[iP].ap += Dt + fmax(+(Ft), 0); else sl[iP].ap += 0.0;
				if (!bsB) sl[iP].ap += Db + fmax(-(Fb), 0); else sl[iP].ap += 0.0;

			}
			//sl[iP].ap += apzero1 - dSp*dx*dy*dz;
			// Только так и никак иначе проверено на opening тесте.
			sl[iP].ap = sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab + apzero1 - dSp*dx*dy*dz;//+apzero1-dSp*dx*dy*dz; // диагональный элемент матрицы



		}
		else {
			sl[iP].ap = sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab + apzero1 - dSp*dx*dy*dz;//+apzero1-dSp*dx*dy*dz; // диагональный элемент матрицы
		}




	}



	doublereal ts = sl[iP].ae + sl[iP].aw + sl[iP].an + sl[iP].as + sl[iP].at + sl[iP].ab;
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (ts != ts) {
		//if (Fe*Fe + Fw*Fw + Fn*Fn + Fs*Fs + Ft*Ft + Fb*Fb > 1.0e-36) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("PEREPOLNENIE iP==%lld ae=%e aw=%e an=%e as=%e at=%e ab=%e\n", iP, Fe, Fw, Fn, Fs, Ft, Fb);
		system("pause");
		//}
	}
#endif

	doublereal rpower_diss = dSc;
	//6.10.2018
	/*
	// Не проходит валидации, тепловая мощность занижена !!!
	if (!bE && !bW) {
	rpower_diss *= dx;
	}
	else {
	rpower_diss *= 0.5*dx;
	}
	if (!bN && !bS) {
	rpower_diss *= dy;
	}
	else {
	rpower_diss *= 0.5*dy;
	}
	if (!bT && !bB) {
	rpower_diss *= dz;
	}
	else {
	rpower_diss *= 0.5*dz;
	}
	*/

	// 23.12.2018
	// Проходит валидацию.
	rpower_diss *= dx*dy*dz;

#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (apzero0 != apzero0) {
		std::cout << b[whot_is_block[iP]].name << std::endl;
		printf("Error NAN or INF: apzero0=%e in function my_elmatr_quad_T3D\n", apzero0);
		system("pause");
	}
#endif
	// 3.07.2017. 
	// ВНИМАНИЕ !!! заменить на обычное присваивание если ненужна ортогональная коррекция.
	if ((b_on_adaptive_local_refinement_mesh) && ((bconvective))) {
		sl[iP].b += rpower_diss + apzero0 * Fold;
	}
	else {
		sl[iP].b += rpower_diss/*dSc*dx*dy*dz*/ + apzero0 * Fold;//+apzero0*Fold;// правая часть //-Fold*(Fe-Fw+Fn-Fs); // этот член вызывает нефизичное решение
	}
	// Если рассчитывается схема высокой разрешающей способности то этот член обязательно должен быть включён.
	sl[iP].b += attrs; // Схема высокой разрешающей способности для конвекции. Например, SMARTER 3 порядка.
					   // Усиление диагонального преобладания в случае невыполнения уравнения неразрывности,
					   // на сошедшемся решении (удовлетворяющем уравнению неразрывности) вклад этого члена исчезает.
					   // Ни в коем случае не включать (Fe-Fw+Fn-Fs+Ft-Fb), т.к. приводит к сильно нефизичному решению в opening тесте.
					   //sl[iP].ap += fabs(Fe-Fw+Fn-Fs+Ft-Fb);
					   //sl[iP].ap += Fe - Fw + Fn - Fs + Ft - Fb;
					   //sl[iP].b+=rbdissipate*dx*dy*dz; // можно оставить
					   //sl[iP].b+=baddDFLUX2; // можно оставить.
					   /*if (inumglobaliter>=66) {
					   printf("dSc=%e, apzero0=%e, Fold=%e, rbdissipate=%e, vol=%e\n",dSc,apzero0, Fold,rbdissipate, dx*dy*dz);
					   getchar();
					   }
					   */

					   /*
					   if (iP==26) {
					   #if doubleintprecision == 1
					   printf("numberCV=%lld ap=%1.4e ae=%1.4e aw=%1.4e an=%1.4e as=%1.4e at=%1.4e ab=%1.4e b=%1.4e\n",
					   #else
					   printf("numberCV=%d ap=%1.4e ae=%1.4e aw=%1.4e an=%1.4e as=%1.4e at=%1.4e ab=%1.4e b=%1.4e\n",
					   #endif

					   iP,sl[iP].ap,sl[iP].ae,sl[iP].aw,sl[iP].an,sl[iP].as,sl[iP].at,sl[iP].ab,sl[iP].b);
					   getchar();
					   }*/

					   // debug
#ifdef DEBUG_MY_ELMATR_QUAD_T3D
	if (0) {
		// Исследовал одну ошибку.
		// Она была вызвана неконсервативностью схемы из-за различных значений apzero 0!=1.
		if ((iP > 302940) && (iP <= 302951)) {
			std::cout << b[whot_is_block[iP]].name << std::endl;
			printf("b=%e ap=%e ae=%e aw=%e an=%e as=%e at=%e ab=%e\n", sl[iP].b, sl[iP].ap, sl[iP].ae, sl[iP].aw, sl[iP].an, sl[iP].as, sl[iP].at, sl[iP].ab);
			printf("ae2=%e aw2=%e an2=%e as2=%e at2=%e ab2=%e\n", sl[iP].ae2, sl[iP].aw2, sl[iP].an2, sl[iP].as2, sl[iP].at2, sl[iP].ab2);
			printf("ae3=%e aw3=%e an3=%e as3=%e at3=%e ab3=%e\n", sl[iP].ae2, sl[iP].aw2, sl[iP].an2, sl[iP].as2, sl[iP].at2, sl[iP].ab2);
			printf("ae4=%e aw4=%e an4=%e as4=%e at4=%e ab4=%e\n", sl[iP].ae2, sl[iP].aw2, sl[iP].an2, sl[iP].as2, sl[iP].at2, sl[iP].ab2);
			printf("b: attrs=%e apzero0=%e Fold=%e rpower_diss=%e ap: apzero1=%e dSp*dx*dy*dz=%e\n",
				attrs, apzero0, Fold, rpower_diss, apzero1, dSp * dx * dy * dz);
			system("pause");
		}
	}
#endif

	// Симметризация матрицы СЛАУ:
	// Граничные узлы обязательно должны собираться в первую очередь.
	// В теории должно получаться эллиптическое уравнение с SPD матрицей.
	/*
	// Строка матрицы выглядит примерно следующим образом:
	// -ab ... -as ... -aw ... +ap ... -ae ... -an ... -at == b


	// Учёт краевых условий Дирихле:
	if ((iE>maxelm) && (slb[iE-maxelm].iI==(-1))) {
	sl[iP].b+=sl[iP].ae*slb[iE-maxelm].b/slb[iE-maxelm].aw;
	sl[iP].ae=0.0;
	sl[iP].iE=-1;
	}

	if ((iW>maxelm) && (slb[iW-maxelm].iI==(-1))) {
	sl[iP].b+=sl[iP].aw*slb[iW-maxelm].b/slb[iW-maxelm].aw;
	sl[iP].aw=0.0;
	sl[iP].iW=-1;
	}

	if ((iN>maxelm) && (slb[iN-maxelm].iI==(-1))) {
	sl[iP].b+=sl[iP].an*slb[iN-maxelm].b/slb[iN-maxelm].aw;
	sl[iP].an=0.0;
	sl[iP].iN=-1;
	}

	if ((iS>maxelm) && (slb[iS-maxelm].iI==(-1))) {
	sl[iP].b+=sl[iP].as*slb[iS-maxelm].b/slb[iS-maxelm].aw;
	sl[iP].as=0.0;
	sl[iP].iS=-1;
	}

	if ((iT>maxelm) && (slb[iT-maxelm].iI==(-1))) {
	sl[iP].b+=sl[iP].at*slb[iT-maxelm].b/slb[iT-maxelm].aw;
	sl[iP].at=0.0;
	sl[iP].iT=-1;
	}

	if ((iB>maxelm) && (slb[iB-maxelm].iI==(-1))) {
	sl[iP].b+=sl[iP].ab*slb[iB-maxelm].b/slb[iB-maxelm].aw;
	sl[iP].ab=0.0;
	sl[iP].iB=-1;
	}

	*/

	/*
	if (iP==26) {
	#if doubleintprecision == 1
	printf("numberCV=%lld ap=%1.4e ae=%1.4e aw=%1.4e an=%1.4e as=%1.4e at=%1.4e ab=%1.4e b=%1.4e\n",
	iP,sl[iP].ap,sl[iP].ae,sl[iP].aw,sl[iP].an,sl[iP].as,sl[iP].at,sl[iP].ab,sl[iP].b);
	#else
	printf("numberCV=%d ap=%1.4e ae=%1.4e aw=%1.4e an=%1.4e as=%1.4e at=%1.4e ab=%1.4e b=%1.4e\n",
	iP,sl[iP].ap,sl[iP].ae,sl[iP].aw,sl[iP].an,sl[iP].as,sl[iP].at,sl[iP].ab,sl[iP].b);
	#endif

	getchar();
	}
	*/

	if (fabs(sl[iP].ap) < 1.0e-30) {
		sl[iP].ap = 1.0;
		sl[iP].b = Fold; // температура с предыдущей итерации.
	}

} // my_elmatr_quad_T3D



#endif