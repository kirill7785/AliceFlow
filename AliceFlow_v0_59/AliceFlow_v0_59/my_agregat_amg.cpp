
// my_cl_agl_amg_0_13.cpp: определяет точку входа для консольного приложения.
//
//
// classical aglomeration algebraic multigrid method.
// классический агломеративный алгебраический многосеточный метод.
//
// 8 января 2018 года. (см. classic_aglomerative_amg4).
// Направления дальнейшего развития: Более тонкая настройка доступная из интерфейса.
// Одна из целей: увеличение быстродействия и сильная экономия памяти в ущерб сходимости.
// Комплекс мер по увеличению быстродействия: 
// Обязательное сохранение работоспособности того что есть, доработка того что есть.
//
// 8 января 2018 года. (см. classic_aglomerative_amg4).
// Между январём 2016 и январём 2018 года была проделана работа по дальнейшему 
// развитию алгоритма и его тестированию. 
// Перечень произведённых изменений не описывается. Сделано много небольших
// модификаций. Главное это то, что алгоритм теперь мыслится 
// как предобуславливатель к Крыловскому алгоритму BiCGStab. Это плодотворно
// сказалось на его сходимости во многих случаях важных для практики.
// В основе нахождения C/F разбиения лежит АВЛ, SPLAY, BinaryHeap или Дерамида.
// На будущее стоит рассмотреть Фибоначчиеву кучу и поддержать работоспособность
// и улучшение ранее предложенных вариантов. В использовании сглаживателей есть 
// продвижения. Введен в эксплуатацию ilu(0) сглаживатель, алгоритм Юсефа Саада при этом
//  специальным образом модифицирован (устранен линейный поиск). Положительно
// использован сглаживатель на основе метода Рунге-Кутта. Полезным оказалось 
// использование C/F-порядка обхода узлов при сглаживании. Испробованы сглаживатели
// gmres и bicgstab. От них пришлось отказаться - потеря сходимости, серьёзное 
// ухудшение быстродействия. Алгоритм успешно использовался
// во многих важных для практики случаях. Есть задачи с которыми он ещё не справляется. 
// Есть проблемы с быстродействием если говорить о рекордах скорости. 
// Алгоритм потребляет много оперативной памяти.
//
// 6 января 2016. Версия 0.13.  (см. classic_aglomerative_amg2).
// АВЛ деревья во многих местах заменены на более быструю комбинацию хеш-таблицы (поиск и вставка)
// и стека (стек для очистки хеш-таблицы).
// Время счёта реальной тепловой задачи в 3.2М неизвестных составило 1мин 51с т.е.
// удалось догнать BiCGStab+ILU(2) из SPARSKIT2 со временем счёта 1мин 50с.
// Ю. Саада. Догнать amg1r5 с временем счёта 1мин пока не представилось возможным.
// 5 января 2016. Сделан sor сглаживатель на основе формулы  из книги Патрика Роуча
// дающий сокращение итераций на 28%,
// я исходил из того что оптимальный параметр верхней релаксации зависит только от 
// числа уравнений в СЛАУ на каждом уровне вложенности.
// Также немного доработаны процедуры интерполяции (рабочих насчитывается 4 штуки).
// Время счёта задачи с 3.2M неизвестными составляет 2мин 25с.
// что в 1.3раза медленнее чем у BiCGStab+ILU(2).
// 4 января 2016. Проблемы с ipool больше нет, он заменён на АВЛ дерево. На задаче 
// с размерностью в 3.2M неизвестных оптимальное
// значение barjer=1e-8 что дало сокращение итераций с 1003 до 213. (Время счёта с 
// 9мин до 4мин. Потребляет 2.4Гб ОЗУ). 
// У BiCGStab+ILU(2) всего 1мин 50с т.е.он в 2.2 раза быстрее.
// 3 января 2016. Версия 0.12. (см. classic_aglomerative_amg2).
// Протестированная на некоторых реальных задачах теплопередачи в программе AliceFlow&&AliceMesh.
// Для одного миллиона неизвестных время решения составляет 40с. Это время такое-же как и время 
// алгоритма BiCGStab+ILU(2). Ещё раз подчёркиваю что задача реальная. Также решалась задача 
// в 3.2М неизвестных (заняло 2Гб ОЗУ), время решения
// которой составило 8мин 27с что 4.6раза медленнее алгоритма BiCGStab+ILU(2) время которого 1мин 50с.
// В версии 0.12 произведены следующие улучшения: код очищен от устаревшего, в качестве сглаживателя
// (как пре так и пост) используется SOR с параметром omega=1.15 он чуть чуть быстрее.
// Если будут проблемы можно переключить на надежный Зейдель. см. seidelq.
// В residualq избавились от деления на элемент обратный диагональному, заменив эту операцию на более
// быстрое умножение. Добавлен W цикл, см переключатель igam, впрочем W оказался медленнее примерно 
// вдвое. 6 января 2016. W цикл запрограммирован неверно.
// Нельзя вызывать V повторно на глубоких уровнях надо делать глубину повторных вызовов не более 
// 2 или 3 тогда W цикл может ускорить вычисление до 3 раз по данным статей в интернете.
// Исправления будут в версии 0.14.Подобраны оптимальные параметры V цикла равные
// одному предсглаживанию и двум пост сглаживаниям. Есть возможность настроить количество
// пред и пост сглаживаний, в частности исследовался
// вариант когда количество сглаживаний при погружении на глубокие уровни увеличивается.
// Этот вариант не дал выигрыша в скорости.
// В данный момент разрабатывается "идеальный" алгоритм интерполяции. Помимо стандартного,
// в данный момент добавлена непрямая интерполяция, а
// также гибрид стандартной и непрямой интерполяции. От интерполяции зависит количество 
// итераций а значит и время счёта а также память. Разработка 
// интерполяции ведётся в настоящий момент. 
// Введена отсечка малых элементов в операторах Галёркина. Установлено оптимальное значение 
// в 0.0001 умноженное на максимальный элемент в строке
// быстродействие при котором наиболее велико (компромисс) по замерам на задаче в 1M неизвестных.
// Недостатком программы в данный момент является чрезвычайно большое число итераций нужных для 
// сходимости. Для 3.2М неизвестных их число составило 1000.
// Реализована сортировка с подсчётом как и намечалось ранее. АВЛ дерево сохранено и доказало 
// свою эффективность.
// 21 декабря 2015. Версия 0.11 была протестирована на реальной задаче в 3D. Размерность реальной
// задачи 1М неизвестных. Вывод состоит в том что метод 0.11 ещё не готов к реальным задачам,
// число ненулевых элементов  в матрицах грубосеточных уровней растёт катострофическим образом. 
// Время счёта настолько велико что ждать просто нет смысла.
// В то время как amg1r5 справился с этой реальной задачей за 17с. В следующей версии 0.12 будут
// предприняты шаги по улучшению работоспособности данного программного решения. 
// 13 декабря 2015. Версия 0.11. C/F разбиение выполнено на основе АВЛ дерева. Г.М. Адельсон-Вельский 
// и Е.М. Ландис 1962.
// теперь оно существенно доработано, исправлены ошибки и быстродействие алгоритма по сравнению с версией 0.10 на
// на трёхмерном уравнении Пуассона в кубе 120х120х120 1.7М неизвестных увеличилось в 11 раз!!! время решения 1мин.
// Версия 0.11 полностью переведена на быструю сортировку Ч.Хоара 1960 т.к. она обгоняет пирамидальную сортировку в 5 раз.
// В предыдущей версии кода в быстрой сортировке содержалась ошибка.См новые реализации qs, qsj.
// Сортировка Ч. Хоара не требует дополнительной памяти. Размер стека программы увеличен до 4Мб в студии. 
// Версия 0.11 полностью свободна от нумерации неизвестных в исходной матрице Это значит что версия 0.11 данного многосеточного
// метода одинаково эффективно работает с любой нумерацией неизвестных !!! Никакой головной боли с шириной ленты матрицы,
// нумеруйте как хотите, т.е. как удобно генератору сетки. 
// Мысли о том то возможно будет реализовано в слудующей версии.
// Если количество оперативной памяти не проблема для пользователя то есть возможность ускорить данную программу
// за счёт применения сортировки с подсчётом которая выполняется асимптотически за O(n) операций на одном потоке, но потребляет при этом 
// дополнительные массивы памяти.
// АВЛ деревья были изобретены более 40 лет назад, возможно их можно заменить современными более быстродействующими структурами данных.
// Алгоритм Фреда Густавсона разреженного матричного умножения по прежнему функционирует в данном коде, возможно можно улучшить и его
// характеристики быстродействия если на это укажет профилировщик.
// А да, кого интересует 2D: двумерная задача 1000х1000 1М неизвестных решается данным кодом за 18с. Подробные данные ждите в файле замеры
// времени .doc который будет приложен к проекту позднее.
// О том как использовать данное программное решение в своих проектах см. тело функции main.
// По всем вопросам о использовании данной программы писать на kirill7785@mail.ru.
//  ***---***      ***---***      ***---***
// 9 декабря 2015. Версия 0.10. Существенно ускорено построение C/F разбиения. Threshold = 0.25 
// единый и для 2D и для 3D это подтверждается анализом статей в интернете. Задача Пуассона
// в 3D кубе размерностью 120х120х120 решается теперь за 11минут вместо 25 мин.Ускорение более чем в двое в 3D.
// 6 декабря 2015. Версия 0.09. Улучшения в решении 3D задач по сравнению с версией 0.08. 
// Задача Пуассона в 3D кубе 120х120х120 решается за 25мин. Потребляет 1.86Гб оперативной памяти.
// Это 1.7М неизвестных. Количество итераций при этом 317.
// Алгоритмически версия 0.09 отличается от версии 0.08 тем что в ней предприняты шаги по сохранению разреженности
// оператора Галёркина. Это главным образом дало возможность решать 3D задачи.
// Параметры алгоритма: nu1, nu2 (количество итераций пред и пост сглаживания), mul_tolerance, theta
// параметры отсечения малых элементов в матрице требуют подбора. Подбор пока произведен вручную на глазок. 
// Также в версии 0.09 изменён принцип поиска соседей новых F узлов: оно запрограммировано теперь на двухсвязном 
// списке без band_sizei, что дало существенное ускорение в 3D и небольшое замедление в 2D.
// Построение CF разбиения по прежнему испытывает существенные проблемы с быстродействием, поиск максимума в 3D 
// задачах занимает львиную долю времени. Матричное умножение после сохранения разреженности оператора Галёркина
// выполняется достаточно быстро и с ним всё в порядке.
// Код работает на любых размерностях влизающих в оперативную память до 300М ненулевых элементов в матрице СЛАУ.
// Работы по тестированию алгоритма на реальных задачах ведутся достаточно успешно, но показывать их пока рано.
// 15 ноября 2015. Версия 0.08 в которой исправлены ошибки версии 0.07. Ошибки были в организации двусвязного линейного
// списка.
// 8 ноября 2015. Версия 0.07 в которой выполнена работа по дальнейшему улучшению быстродействия
// алгоритма. Задача Пуассона на сетке 800х800 теперь решается за 49с. Это не предел, у аналогов
// например у amg1r5 быстродействие оценивается в 8с для данной задачи. Для трёхмерного Пуассона 
// с быстродействием в версии 0.07 лучше чем в версии 0.06 но очень плохо по сравнению с 
// коммерческими аналогами. В версии 0.07 сделан прорыв в разреженном матричном умножении,алгоритм
//  Фреда Густавсона существенно ускорен. Тестирование алгоритма на реальных задачах практически 
// не было произведено по причине отсутствия реализации  Катхилла-Маки в реальном тестируемом
// приложении (AliceFlow) а данный метод my_amg_v0.07  очень чувствителен  к ширине ленты матрицы.
// 31 - октября 2015. Версия 0.06 в которой выполнена работа по дальнейшему улучшению
// быстродействия алгоритма. Исправлен ряд ошибок. Задача Пуассона на сетке 800х800 
// решается за 9мин 32с.
// Данная версия алгоритма содержит очень большое количество оптимизирующих патчей и 
// поэтому код стало очень сложно сопровождать. Надо провести реальное тестирование 
// в следующей версии кода.
// 22-23 октября 2015. Версия 0.05 в которой запрограммирована идея Писсанецки для
// разреженного матричного умножения. Реализация идеи Писсанецки ускорила код на 15%
// по сравнению с версией 0.04. Также в версии 0.05 реализован алгоритм Густавсона для
// разреженного матричного умножения Gustavson sparse matrix multiplication IBM 1978.
// Алгоритм Густавсона ускорил код по сравнению с версией 0.04 более чем вдвое.
// 18 октября 2015. Полностью работоспособный мультигрид.
// Тестировалось на условиях Дирихле но должно работать на любых 
// краевых задачах. 18 октября датируется версия 0.04. Версия 0.04 на треть
// быстрее версии 0_03. Были ускорены как операции построения C/F разбиения, 
// так и нахождение оператора Галёркина. При нахождении С-F разбиения 
// учитывается уже построенная его часть и поэтому число сканирований на
// на поздних циклах сокращается охватывая только не построенную часть.
// При нахождении произведения Галёркина получена самая оптимальная по быстродействию версия,
// Основанная на алгоритме слияния отсортированных списков.
// version 0.03 15 october 2015. (Успешное построение иерархии сеток, операторов restriction,
// interpolation.) По сравнению с версией 0.01 исправлены: бинарный поиск, нахождение
// оператора Галеркина. Внесены прочие мелкие исправления.
// По сравнению с версией 0.02 код стал быстрее, продуманнее. Найдена ошибка в MergeSort
//  поэтому от неё полностью отказались в пользу HeapSort.
// Код работает на любых размерностях до 10млн ненулевых элементов но очень медленно на
// высоких размерностях.
// Код быстрее версии 0.02 на 50%.
/*    ###     ##    ###   ####
*    #  #    #  #  # ##  #
*   #####   #    #   ##  #   ##  for AliceFlowv0_22 AliceMeshv_0_34 DavisTestDelphi and anather products...
*  #    #  #         ##   ####
*    solution time 3.2M unknowns is ONE MINUTE and 51 second  in one thread 2.2GHz processor
*   (требуется 2.3Gb ОЗУ без учёта памяти которую дополнительно съест Windows).
*/

#pragma once
#ifndef MY_AGREGAT_AMG_CPP
#define MY_AGREGAT_AMG_CPP 1

//#include "cuda_runtime.h"
//#include "device_launch_parameters.h"

//#include "stdafx.h"
#include <stdio.h>
#include <math.h>
//#include <stdlib.h>
//#include <windows.h>
#include <float.h>
#include <time.h>
//#include <omp.h>
//#include <windows.h>
//#pragma comment(linker, "/STACK:16777216") // увеличение размера стека для быстрой сортировки


#include "gmres.cpp" // Алгоритм Юсефа Саада и Мартина Г. Шульца FGMRes [1986]



// Очередь по приоритетам на основе сортирующего дерева 
//#include "priority_queue.cpp"

// Объявление модели вещественной арифметики содержится в самом начале программы в главно модуле 
// AliceFlow_v0_27
//#define doublerealT double
//#define integer int // 32 bit
//#define integer int64_t

/*
// Объявлено в глобальном модуле:

// Управление алгебраическим многосеточным методом из интерфейса.
typedef struct TMY_AMG_MANAGER {
	integer maximum_levels; // максимальное количество уровней вложенности (уровни выше редуцируются).
	integer number_interpolation_procedure; // идентификатор процедуры интерполяции.
	integer nFinnest, nu1, nu2; // Количества сглаживаний.
	integer memory_size; // В размерах матрицы А.
} MY_AMG_MANAGER;

MY_AMG_MANAGER my_amg_manager;

// amg default settings:
// Параметры собственного многосеточного метода о умолчанию.
my_amg_manager.maximum_levels = 20; // максимальное число уровней начиная с которого начинается усечение.
my_amg_manager.number_interpolation_procedure = 0; // номер интерполяционной процедуры.
my_amg_manager.nFinnest = 2; // число итераций на подробной сетке.
my_amg_manager.nu1 = 1; // число предсглаживаний.
my_amg_manager.nu2 = 2; // число пост сглаживаний.
my_amg_manager.memory_size = 9; // количество оперативной памяти в размерностях матрицы А.

*/


typedef struct TAk {
	integer i, j;
	doublereal aij;
	//float aij;
	//в последней версии алгоритма ind не используется.
	integer ind; // позиция в первоначальной сортировке.
} Ak;

typedef struct TAk1 {
	// 12 байт на одно ненулевое значение.
	integer_mix_precision i, j;
	real_mix_precision aij;
	//float aij;
	//в последней версии алгоритма ind не используется.
	//integer ind; // позиция в первоначальной сортировке.
} Ak1;

// 03.02.2019
// Разреженная матрица СЛАУ в CRS или COO форматах.
typedef struct TAk2 {
	// 16 байт на одно ненулевое значение.
	// Раздельное хранение массивов.
	integer_mix_precision *i, *j;
	real_mix_precision *aij;
	real_mix_precision *abs_aij; // Для ускорения вычислений предварительно вычисляем модуль.
	//float *aij;
	//integer *row_ptr_start, *row_ptr_end;

	TAk2() {
		// Раздельное хранение массивов.
		i=nullptr; j=nullptr;
		aij=nullptr;
		abs_aij=nullptr; // Для ускорения вычислений предварительно вычисляем модуль.
		//float *aij;
		//integer *row_ptr_start, *row_ptr_end;
	}
} Ak2;


#include "My_Handle_Error.cpp"

typedef struct Taccumulqtor_list {
	integer ikey;
	Taccumulqtor_list* next;

	Taccumulqtor_list() {
		ikey=-1;
		next=nullptr;
	}
} accumulqtor_list;

// Найти в линейном односвязном списке значение.
bool isfound(Taccumulqtor_list* &root, integer key) {
	Taccumulqtor_list* mem = root;
	while (mem != nullptr) {
		if (mem->ikey == key) {
			mem = nullptr;
			return true;
		}
		mem = mem->next;
	}
	return false;
}

// Быстрая вставка за O(1) операций.
// Размер структуры динамический - ровно столько сколько нужно. 
void insert_list(Taccumulqtor_list* &root, integer key) {
	if (root == nullptr) {
		root = new Taccumulqtor_list;
		root->ikey = key;
		root->next = nullptr;
	}
	else {
		Taccumulqtor_list* candidate = nullptr;
		candidate= new Taccumulqtor_list;
		candidate->ikey = key;
		candidate->next = root->next;
		root->next = candidate;
		candidate = nullptr;
	}
} // insert_list

// Полная очистка линейного списка-хранилища.
void clear_list(Taccumulqtor_list* &root) {
	Taccumulqtor_list* buf = nullptr;
	while (root != nullptr) {
		buf = root; // 54404 0.4%
		root = root->next;
		buf->next = nullptr;
		delete buf;
		buf = nullptr;
	}
} // clear_list

 

typedef struct Thashlist {
	Ak Amat;
	Thashlist* next;
	Thashlist* prev;

	Thashlist() {
		Amat.aij = 0.0;
		Amat.i = -1;
		Amat.j = -1;
		Amat.ind = -1;
		next=nullptr;
		prev=nullptr;
	}
} hashlist;

// вставка ключа в список
void insertion_hash(hashlist* p, Ak d) {
	if (p == 0) {
		p = new hashlist;
		if (p == 0) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for p in insertion hash my_agregat_amg...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		p->prev = 0;
		p->next = 0;
		p->Amat = d;
	}
	else {
		hashlist* scanner = p;
		while (scanner->next != 0) scanner = scanner->next;
		hashlist* r = nullptr;
		r=new hashlist;
		if (r == 0) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for r in insertion hash my_agregat_amg...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		r->prev = scanner;
		r->next = 0;
		r->Amat = d;
		scanner->next = r;
		r = 0;
		scanner = 0;
	}
}

// очистка списка
// Вероятно содержит ошибку потому что память не освобождается.
// TODO 17 dec 2015
void clear_hash(hashlist* p) {
	if (p != 0) {
		hashlist* head = p;
		p = 0;

		hashlist* r = head;
		while (r != 0) {
			head = head->next;
			if (head != 0)  head->prev = 0;
			r->next = 0;
			r->prev = 0;
			delete r;
			r = head;
		}
	}
}

typedef struct TList {
	integer ii, i, count_neighbour;
	TList* next;
	TList* prev;

	TList() {
        ii=-1; i=-1; count_neighbour=-1;
	    next=nullptr;
	    prev=nullptr;
	}
} List;

// Сбалансированные двоичные деревья поиска.
#include "Balanced_Tree.cpp"


// Вставка и поиск на основе быстродействующей хеш-таблицы.
// начало.

bool* ihash_table_Gus_struct01 = nullptr;
integer isize_hash_table_Gus_struct01 = 0;
integer* istack_pool_hash_table_Gus_struct01 = nullptr;
// Внимание заполняется при инициализации, см. значение 52.5 подобранное экспериментально.
integer isize_stack_pool_hash_table_Gus_struct01 = 0; // достаточно 10000000 (10млн) для 2.1М.
integer ipointer_pool_hash_table_Gus_struct01 = 0;

// Полное освобождение оперативной памяти из под хеш-таблицы.
void free_hash_table_Gus_struct01() {
	if (ihash_table_Gus_struct01 != nullptr) {
		delete[] ihash_table_Gus_struct01;
		ihash_table_Gus_struct01 = nullptr;
		isize_hash_table_Gus_struct01 = 0;
	}
	if (istack_pool_hash_table_Gus_struct01 != nullptr) {
		delete[] istack_pool_hash_table_Gus_struct01;
		istack_pool_hash_table_Gus_struct01 = nullptr;
	}
	isize_stack_pool_hash_table_Gus_struct01 = 10000000;
} // free_hash_table_Gus_struct01();

bool isfound_hash_table_Gus_struct01(integer id) {
	return ihash_table_Gus_struct01[id];
} // isfound_hash_table_Gus_struct01

// Осторожнее с операцией вставки нового элемента, модификация istack_pool_hash_table_Gus_struct01.
void insert_hash_table_Gus_struct01(integer id) {
	ihash_table_Gus_struct01[id]=true;
	if (ipointer_pool_hash_table_Gus_struct01 < isize_stack_pool_hash_table_Gus_struct01) {
		istack_pool_hash_table_Gus_struct01[ipointer_pool_hash_table_Gus_struct01++] = id;
	}
	else {
		printf("fatal error in function insert_hash_table_Gus_struct01\n");
		printf("ipointer_pool_hash_table_Gus_struct01 >= isize_stack_pool_hash_table_Gus_struct01\n");
		system("pause");
		exit(1);
	}
} // insert_hash_table_Gus_struct01

// Быстрая очистка хеш-таблицы.
void clear_hash_table_Gus_struct01() {
	for (integer i_2 = 0; i_2 < ipointer_pool_hash_table_Gus_struct01; i_2++) {
		ihash_table_Gus_struct01[istack_pool_hash_table_Gus_struct01[i_2]] = false;
	}
	ipointer_pool_hash_table_Gus_struct01 = 0;
} // clear_hash_table_Gus_struct01

  // Передача списка Si Transpose из АВЛ дерева в hash_table_Gus_struct01.
  // перекачка данных из сбалансированного дерева в хеш-таблицу.
void formirate_F_SiTranspose_hash_table_Gus_struct01(node_AVLST* &p, integer &imarker75_scan)
{
	if (p != nullptr) {
		formirate_F_SiTranspose_hash_table_Gus_struct01(p->left, imarker75_scan);
		formirate_F_SiTranspose_hash_table_Gus_struct01(p->right, imarker75_scan);
		insert_hash_table_Gus_struct01(p->key.i);
		imarker75_scan++;
	}
} // formirate_F_SiTranspose_hash_table_Gus_struct01


  // Передача списка Si Transpose из АВЛ дерева в hash_table_Gus_struct01.
  // перекачка данных из сбалансированного дерева в хеш-таблицу.
void formirate_F_SiTranspose_hash_table_Gus_struct02(Taccumulqtor_list* &p, integer &imarker75_scan)
{
	Taccumulqtor_list* buf = p;
	while (buf != nullptr) {

		insert_hash_table_Gus_struct01(buf->ikey);
		imarker75_scan++;

		buf = buf->next;
	}
} // formirate_F_SiTranspose_hash_table_Gus_struct01


  // Передача списка Si Transpose из АВЛ дерева в множество root_Gus_set.
  // перекачка данных из одного дерева в другое.
void formirate_F_SiTranspose_hash_table_Gus2_struct02(Taccumulqtor_list* &p,  integer &imarker75_scan,
	bool* &this_is_F_node, bool* &this_is_C_node)
{

	Taccumulqtor_list* buf = p;
	while (buf != nullptr) {

		if ((this_is_F_node[buf->ikey] == false) && (this_is_C_node[buf->ikey] == false)) {
			insert_hash_table_Gus_struct01(buf->ikey);
			imarker75_scan++;
		}
		buf = buf->next;
	}
} // formirate_F_SiTranspose_hash_table_Gus2_struct01

// Передача списка Si Transpose из АВЛ дерева в множество root_Gus_set.
  // перекачка данных из одного дерева в другое.
void formirate_F_SiTranspose_hash_table_Gus2_struct03(Taccumulqtor_list*& p, integer isize75, integer& imarker75_scan,
	bool*& this_is_F_node, bool*& this_is_C_node)
{

	Taccumulqtor_list* buf = p;
	integer i75 = 0;
	while ((i75 < isize75) && (buf != nullptr)) {

		if ((this_is_F_node[buf->ikey] == false) && (this_is_C_node[buf->ikey] == false)) {
			insert_hash_table_Gus_struct01(buf->ikey);
			imarker75_scan++;
		}
		buf = buf->next;
		i75++;
	}
} // formirate_F_SiTranspose_hash_table_Gus2_struct01

// Передача списка Si Transpose из АВЛ дерева в множество root_Gus_set.
  // перекачка данных из одного дерева в другое.
// Вместо деревьев теперь используется хеш таблица p.
// 10.06.2021
void formirate_F_SiTranspose_hash_table_Gus2_struct04(integer*& p, integer idstr, integer n_a, integer isize75, integer& imarker75_scan,
	bool*& this_is_F_node, bool*& this_is_C_node)
{

	integer i75 = 0;
	while (i75 < isize75) {

		integer ikey = p[i75*n_a+ idstr];

		if ((this_is_F_node[ikey] == false) && (this_is_C_node[ikey] == false)) {
			insert_hash_table_Gus_struct01(ikey);
			imarker75_scan++;
		}
		i75++;
	}
} // formirate_F_SiTranspose_hash_table_Gus2_struct01

// Передача списка Si Transpose из АВЛ дерева в множество root_Gus_set.
// перекачка данных из одного дерева в другое.
void formirate_F_SiTranspose_hash_table_Gus2_struct01(node_AVLST* &p,  integer &imarker75_scan,
	bool* &this_is_F_node, bool* &this_is_C_node)
{
	if (p != nullptr) {
		formirate_F_SiTranspose_hash_table_Gus2_struct01(p->left,  imarker75_scan, this_is_F_node, this_is_C_node);
		formirate_F_SiTranspose_hash_table_Gus2_struct01(p->right,  imarker75_scan, this_is_F_node, this_is_C_node);
		if ((this_is_F_node[p->key.i] == false) && (this_is_C_node[p->key.i] == false)) {
			insert_hash_table_Gus_struct01(p->key.i);
			imarker75_scan++;
		}
	}
} // formirate_F_SiTranspose_hash_table_Gus2_struct01

// Перезаливка данных из хранилища хеш-таблицы в множество set.
void formirate_hash_table_Gus_struct01__2__set(integer* &set, integer &ic_986) {
	for (integer i_2 = 0; i_2 < ipointer_pool_hash_table_Gus_struct01; i_2++) {
		set[ic_986] = istack_pool_hash_table_Gus_struct01[i_2];
		ic_986++;
	}
} // formirate_hash_table_Gus_struct01__2__set

// Выделение оперативной памяти под хеш-таблицу.
void construct_hash_table_Gus_struct01(integer isize) {
	// Освобождение оперативной памяти, на тот случай если 
	// память почему-то уже была выделена.
	if (ihash_table_Gus_struct01 != nullptr) {
		delete[] ihash_table_Gus_struct01;
		ihash_table_Gus_struct01 = nullptr;
		isize_hash_table_Gus_struct01 = 0;
	}
	if (istack_pool_hash_table_Gus_struct01 != nullptr) {
		delete[] istack_pool_hash_table_Gus_struct01;
		istack_pool_hash_table_Gus_struct01 = nullptr;
	}

	// Выделение оперативной памяти и инициализация.
	isize_hash_table_Gus_struct01 = isize;
	ihash_table_Gus_struct01 = new bool[isize_hash_table_Gus_struct01 + 2];
	if (ihash_table_Gus_struct01 == nullptr) {
		printf("error in function construct_hash_table_Gus_struct01\n");
		printf("error memory allocate for ihash_table_Gus_struct01\n");
		system("pause");
		exit(1);
	}
	for (integer i_2 = 0; i_2 < isize_hash_table_Gus_struct01 + 2; i_2++) {
		ihash_table_Gus_struct01[i_2] = false;
	}
	ipointer_pool_hash_table_Gus_struct01 = 0;
	// Значение 52.5 найдено экспериментально, в случае нехватки памяти под пул его можно уменьшить немного,
	// только очень незначительно и очень осторожно.
	//isize_stack_pool_hash_table_Gus_struct01 = (integer)(1.0*isize / 20);
	//isize_stack_pool_hash_table_Gus_struct01 = 10000000; // 10млн.
	isize_stack_pool_hash_table_Gus_struct01 = isize + 2;
	istack_pool_hash_table_Gus_struct01 = new integer[isize_stack_pool_hash_table_Gus_struct01];
	if (istack_pool_hash_table_Gus_struct01 == nullptr) {
		printf("error in function construct_hash_table_Gus_struct01\n");
		printf("error memory allocate for istack_pool_hash_table_Gus_struct01\n");
		system("pause");
		exit(1);
	}
} // construct_hash_table_Gus_struct01

// конец.

// Алгоритмы сортировки.
#include "my_sort_algorithm.cpp"

  /*
  // Это исторически первоначальный код содержащий лишь построение последовательности
  // вложенных матриц и не содержащий построения операторов restriction и prolongation.
  // создание этого кода завершено 1 сентября 2015 года.
  template <typename doublerealT>
  integer aggregative_amg(Ak* &Amat, integer nnz, integer n, doublerealT* &x, doublerealT* &b) {


  // нумерация начинается с единицы.

  const integer maxlevel = 30;
  integer ilevel = 1;
  integer nnz_a[maxlevel];
  integer n_a[maxlevel];
  nnz_a[0] = nnz;
  n_a[0] = n;
  bool* flag = new bool[n + 1];
  integer iadd = 0;

  while ((ilevel<maxlevel-1)&&(n_a[ilevel - 1] > 50)) {
  //heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
  QuickSort(Amat, n_a[ilevel - 1], 1 + iadd, nnz_a[ilevel - 1] + iadd);

  for (integer ii = 1+iadd; ii <= nnz_a[ilevel - 1]+iadd; ii++) {
  #if doubleintprecision == 1
  //	printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
  #else
  //	printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
  #endif
  
  //if (ii % 20 == 0) getchar();
  }

  for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
  flag[ii] = false;
  }
  for (integer ii = 1+iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
  Amat[ii].ind = ii-iadd;
  }



  // Copy(Amat) на nnz ячеек правее.
  for (integer ii = nnz_a[ilevel - 1] + 1 + iadd; ii <= 2 * nnz_a[ilevel - 1] + iadd; ii++) {
  Amat[ii] = Amat[ii - nnz_a[ilevel - 1]];
  }

  integer n_coarce = 1; // номер агрегата.
  const integer max_neighbour = 20;
  const integer NULL_NEIGHBOUR = -1;
  integer vacant = NULL_NEIGHBOUR;
  for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
  if (flag[Amat[ii].i] == false) {
  // Вычисляем по немодифиуцированной матрице А (хранящейся слева).

  integer set[max_neighbour]; // не более 20 узлов в одном агрегате.
  for (integer js = 0; js < max_neighbour; js++) {
  set[js] = NULL_NEIGHBOUR;
  }
  integer ic = 0;
  set[ic] = Amat[ii].i;
  ic++;

  // если узел j ещё не был добавлен в агрегат.
  if (flag[Amat[ii].j] == false) {
  vacant = Amat[ii].j;
  for (integer js = 0; js < ic; js++) {
  if (vacant == set[js]) {
  vacant = NULL_NEIGHBOUR;
  }
  }
  if (vacant != NULL_NEIGHBOUR) {
  set[ic] = vacant;
  ic++;
  }
  }
  integer iscan = ii + 1;
  while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set[0])) {
  // если узел j ещё не был добавлен в агрегат.
  if (flag[Amat[iscan].j] == false) {
  vacant = Amat[iscan].j;
  for (integer js = 0; js < ic; js++) {
  if (vacant == set[js]) {
  vacant = NULL_NEIGHBOUR;
  }
  }
  if (vacant != NULL_NEIGHBOUR) {
  set[ic] = vacant;
  ic++;

  }
  }

  iscan++;

  } // while


  // (i,j) -> (I,J)
  // модифицируем копию Amat находящуюся справа.
  for (integer k = nnz_a[ilevel - 1] + 1 + iadd; k <= 2 * nnz_a[ilevel - 1] + iadd; k++) {
  bool found = false;
  for (integer k1 = 0; k1 < ic; k1++) {
  if (Amat[k - nnz_a[ilevel - 1]].i == set[k1]) found = true;
  }
  if (found) Amat[k].i = n_coarce;
  found = false;
  for (integer k1 = 0; k1 < ic; k1++) {
  if (Amat[k - nnz_a[ilevel - 1]].j == set[k1]) found = true;
  }
  if (found) Amat[k].j = n_coarce;
  }

  // Помечаем узлы как включённые в агрегат.
  for (integer js = 0; js < ic; js++) {
  flag[set[js]] = true;
  }

  n_coarce++;

  // Один агрегат создан.



  } // узел не был ещё включён в агрегат.
  } // агрегаты созданы.

  #if doubleintprecision == 1
		//printf("%lld %lld\n",n,n_coarce-1);
  #else
		//printf("%d %d\n",n,n_coarce-1);
  #endif
  
  //getchar();
  n_a[ilevel] = n_coarce - 1;

  // сортировка по новому ключу key=i*(iglcoarce_number-1)+j;
  // в позиции ind сохранён индекс предыдущей позиции.
  //heapsort(Amat, key = i*(n_coarce - 1) + j, nnz + 1, 2 * nnz);
  QuickSort(Amat, n_coarce - 1, nnz_a[ilevel-1] + 1 + iadd, 2 * nnz_a[ilevel-1] + iadd);


  for (integer ii = 1+nnz_a[ilevel-1]+iadd; ii <= 2*nnz_a[ilevel - 1]+iadd; ii++) {
  #if doubleintprecision == 1
		 //	printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
  #else
		//	printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
  #endif
  
  //if (ii % 20 == 0) getchar();
  }



  // копирование в третью часть матрицы Слау на coarce сетке.
  // инициализация.
  // запас памяти 1 nnz на fine уровне.
  for (integer ii = 2 * nnz_a[ilevel - 1]+1 + iadd; ii <= 3 * nnz_a[ilevel - 1] + iadd; ii++) {
  Amat[ii].aij = 0.0;
  Amat[ii].ind = NULL_NEIGHBOUR;
  Amat[ii].i = NULL_NEIGHBOUR;
  Amat[ii].j = NULL_NEIGHBOUR;
  }

  for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) flag[ii] = false;


  integer ic1 = 2 * nnz_a[ilevel - 1] + 1 + iadd;
  integer im = 1;
  integer im0 = 0;
  for (integer ii = nnz_a[ilevel - 1] + 1 + iadd; ii <= 2 * nnz_a[ilevel - 1] + iadd; ii++) {
  if (flag[Amat[ii].i] == false) {
  integer istr = Amat[ii].i;
  while ((ii + im0 <= 2 * nnz_a[ilevel - 1] + iadd)&&(istr==Amat[ii+im0].i)) {

  if (ic1 <= 3 * nnz_a[ilevel - 1] + iadd) {
  Amat[ic1].i = Amat[ii + im0].i;
  Amat[ic1].j = Amat[ii + im0].j;
  Amat[ic1].aij += Amat[ii + im0].aij;
  while ((ii + im <= 2 * nnz_a[ilevel - 1] + iadd) && (Amat[ii + im0].i == Amat[ii + im].i) && (Amat[ii + im0].j == Amat[ii + im].j))
  {
  Amat[ic1].aij += Amat[ii + im].aij;
  im++;
  }
  ic1++;
  im0 = im;
  im++;
  }
  else {
  printf("error 1\n");
  getchar();
  }
  }
  flag[Amat[ii].i] = true;
  im = 1;
  im0 = 0;
  }
  }

  nnz_a[ilevel] = ic1 - 1 - 2 * nnz_a[ilevel - 1] - iadd;
  iadd += 2 * nnz_a[ilevel - 1];

  #if doubleintprecision == 1
		 printf("nnz: fine=%lld, coarse=%lld, operator complexity=%e. n: fine=%lld, coarse=%lld grid complexity=%e.\n", nnz_a[ilevel - 1], nnz_a[ilevel], (doubleT)(nnz_a[ilevel])/(doubleT)( nnz_a[ilevel - 1]), n_a[ilevel - 1], n_a[ilevel], (doubleT)(n_a[ilevel])/ (doubleT)(n_a[ilevel - 1]));
  #else
		printf("nnz: fine=%d, coarse=%d, operator complexity=%e. n: fine=%d, coarse=%d grid complexity=%e.\n", nnz_a[ilevel - 1], nnz_a[ilevel], (doubleT)(nnz_a[ilevel])/(doubleT)( nnz_a[ilevel - 1]), n_a[ilevel - 1], n_a[ilevel], (doubleT)(n_a[ilevel])/ (doubleT)(n_a[ilevel - 1]));
  #endif
   getchar();

  ilevel++;// грубосеточная матрица построена.

  } // иерархия сеток построена.

  return 0;

  } // aggregative_amg


  */

  // seidel и residual вся информация  хранится в индексах i, j поэтому вектор х обрабатывается верно в плане нумерации,
  // но для порядка обхода матрицы важно чтобы она была упорядочена по индексу i.


  // smoother.
  // 1 september 2015.
template <typename doublerealT>
void seidel1(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else ap = Amat[ic].aij;
				ic++;
			}
			/*
			if (fabs(ap) < 1.0e-30) {
			#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld",istr);
			#else
				printf("zero diagonal elements in string %d",istr);
			#endif
			
			getchar();
			exit(1);
			}
			else */ {
				x[istr] /= ap;
			}
			flag[Amat[ii].i] = true;
		}
	}


} // seidel1

// smoother.
// 1 september 2015.
template <typename doublerealT>
void seidel1(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else ap = Amat[ic].aij;
				ic++;
			}
			/*
			if (fabs(ap) < 1.0e-30) {
			#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld",istr);
			#else
				printf("zero diagonal elements in string %d",istr);
			#endif
			
			getchar();
			exit(1);
			}
			else */ {
				x[istr] /= ap;
			}
			flag[Amat[ii].i] = true;
		}
	}


} // seidel1

bool signal_omega_correct = false;
bool bproblem_amg_convergence1 = false;
bool bproblem_amg_convergence2 = false;
bool bproblem_amg_convergence3 = false;
doublereal buffers1omega, buffers2omega, buffers3omega;
doublereal gold_const = 0.2; // 0.2 default
doublereal gold_linear;

// Мысль. Омегу вычислить заранее и считывать из хеш-таблицы.
// rn - число уравнений в СЛАУ.
template <typename doublerealT>
void optimal_omega(doublerealT rn, doublerealT &omega) {
	
	doublerealT rarg = powf((float)(rn), 0.333333f);
	doublerealT ksi = cosf((float)(M_PI) / ((float)( rarg)));
	ksi *= ksi; // pow(ksi,2.0);
	if (ksi < 1.0) {
		omega = (doublerealT)(2.0*(1.0 - sqrtf((float)(1.0 - ksi))) / ksi);// лучший выбор.
		// Для стабильности 0.2.
		if (bPhysics_PTBSH_memory) {
			// 0.2 6
			// 0.28 6
			// 0.36 6
			gold_const = (doublerealT)(0.175);
			//if (rn<5000) gold_const = 0.08;
			//if (rn>100000) gold_const = 0.28;
		}
		//--->//omega = 1.0 + gold_const*(omega - 1.0); // optimum zero init 0.75
		//omega = 1.0 + 0.5*(omega - 1.0); // 0.7 0.5
		//omega = 1.0; // Seidel

		// 26_10_2016 gold_const передаётся пользователем из графического интерфейса.
		if (my_amg_manager.gold_const >= 0.0) {
			if ((rn > 3.5e6) /*&& (rn < 5.5e6)*/) {
				omega = (doublerealT)(1.0 + 0.08 * (omega - 1.0)); // optimum zero init 0.08
			}
			else if ((rn > 1.8e6) && (rn < 3.5e6)) {
				omega = (doublerealT)(1.0 + 0.21 * (omega - 1.0)); // optimum zero init 0.21
			}
			else {
				omega = (doublerealT)(1.0 + my_amg_manager.gold_const * (omega - 1.0)); // optimum zero init 0.75
			}
		}
		else {
			// Если значение отрицательно то мы передаём просто omega из диапазона 0 < omega < 2:
			// При меньших 1.0 имеем нижнюю релаксацию, при больших 1.0 имеем верхнюю релаксацию.
			if ((fabs(my_amg_manager.gold_const) < 2.0) && (fabs(my_amg_manager.gold_const)>0.0)) {
				omega = (doublerealT)(fabs(my_amg_manager.gold_const));
			}
			else omega = (doublerealT)(0.6667); //Jacobi - так рекомендует теория.
		}
	}
	else {
		printf("problem define optimum omega\n");
		omega = (doublerealT)(1.15);
	}
	// 17 августа 2016
	if (0&&signal_omega_correct) {
		printf("omega=%e gold_const=%e\n", omega, gold_const);
		printf("please enter gold_const:\n");
		printf("0 - 0.22 1-0.24  2-0.26 3 - 0.28 4 - 0.3 5 - 0.32 6-0.34 7-0.36\n");
		char ch;// = 'd';
		ch=getchar();
		switch (ch) {
		case '0': gold_const = (doublerealT)(0.22); break;
		case '1': gold_const = (doublerealT)(0.24); break;
		case '2': gold_const = (doublerealT)(0.26); break;
		case '3': gold_const = (doublerealT)(0.28); break;
		case '4': gold_const = (doublerealT)(0.3); break;
		case '5': gold_const = (doublerealT)(0.32); break;
		case '6': gold_const = (doublerealT)(0.34); break;
		case '7': gold_const = (doublerealT)(0.36); break;
		default: gold_const = (doublerealT)(0.2); break;
		}
		omega = (doublerealT)(2.0*(1.0 - sqrt(1.0 - ksi)) / ksi);// лучший выбор.
		// Для стабильности.
		omega = (doublerealT)(1.0 + gold_const*(omega - 1.0)); // optimum zero init 0.75
		printf("omega=%e gold_const=%e\n", omega, gold_const);
		 ch = getchar();
		 signal_omega_correct = false;
	}
	/*
	// Seidel значительно хуже по быстродействию.
	if (bproblem_amg_convergence1) {
		if (bproblem_amg_convergence2) {
			if (bproblem_amg_convergence3) {
				// Квадратичный прогноз на основе параболы.
				doublerealT a, b, c;
				a = (buffers3omega - (gold_linear*(buffers2omega - buffers1omega) + gold_const*0.75*buffers1omega - gold_const*buffers2omega) / (gold_const*0.75 - gold_const)) / (gold_linear*(gold_linear - gold_const*0.75 - gold_const) + gold_const*gold_const*0.75);
				b = ((buffers2omega - buffers1omega) / (gold_const*0.75 - gold_const)) - a*(gold_const + gold_const*0.75);
				c = (gold_const*0.75*buffers1omega - gold_const*buffers2omega) / (gold_const*0.75 - gold_const) + a*gold_const*gold_const*0.75;
			
				doublerealT gold_const_x = 0.02;
				gold_const_x = -0.32; // TODO
				doublerealT foptimum = 1.0e36;
				//for (integer iscan = 0; iscan < 97; iscan++) {
				for (integer iscan = 0; iscan < 131; iscan++) {
					doublerealT xgold = gold_const_x + iscan*0.01;
					if ((a*xgold*xgold + b*xgold + c>1.0e-7) && (a*xgold*xgold + b*xgold + c < foptimum)) {
						foptimum = a*xgold*xgold + b*xgold + c;
						gold_const = xgold;
					}
				}

				//gold_const = 0.05; // 4 июня 2016
				omega = 2.0*(1.0 - sqrt(1.0 - ksi)) / ksi;// лучший выбор.
				omega = 1.0 + gold_const*(omega - 1.0);
				//printf("r1=%e, r2=%e, r3=%e, alpha=%e\n", buffers1omega, buffers2omega, buffers3omega, gold_const);
				//getchar();

				
				// лучше когда постоянно идёт квадратичный прогноз,
				// т.к. при вычислении оптимального коэффициента верхней
				// релаксации учитывается вся предыстория подборов оптимального параметра
				// верхней релаксации непрерывным образом.
				// но конечно-же этот подход требует проверки.
				bproblem_amg_convergence1 = false;
				bproblem_amg_convergence2 = false;
				bproblem_amg_convergence3 = false;
				// 4 июня 2016
				// Квадратичный прогноз будет идти постоянно.
				//buffers1omega = buffers2omega;
				//buffers2omega = buffers3omega;
			}
			else {
				// Линейный прогноз.
				//omega = 2.0/3.0;
				doublerealT a, b;
				a = (buffers1omega - buffers2omega) / (gold_const-0.75*gold_const);
				b = buffers2omega - a*0.75*gold_const;
				if (ksi < 1.0) {
					omega = 2.0*(1.0 - sqrt(1.0 - ksi)) / ksi;// лучший выбор.
					// Для стабильности.

					doublerealT gold_const_x = 0.02;
					gold_const_x = -0.32; // TODO
					doublerealT foptimum = 1.0e36;
					//for (integer iscan = 0; iscan < 97; iscan++) {
					for (integer iscan = 0; iscan < 131; iscan++) {
						doublerealT xgold = gold_const_x + iscan*0.01;
						if ((a*xgold+ b>1.0e-7) && (a*xgold + b < foptimum)) {
							foptimum = a*xgold + b;
							gold_linear = xgold;
						}
					}

					
					//gold_linear = 0.1;//4 июня 2016
					omega = 1.0 + (gold_linear)*(omega - 1.0); // optimum zero init 0.75
					//printf("alpha=%e\n", gold_linear);
					//getchar();
					//omega = 1.0 + 0.5*(omega - 1.0); // 0.7 0.5
					//omega = 1.0; // Seidel
					// Раскоментировать если использовать лишь линейное предсказание.
					//gold_const = (0.9 - b) / a;
					//bproblem_amg_convergence1 = false;
					//bproblem_amg_convergence2 = false;
				}
				else {
					printf("problem define optimum omega\n");
					omega = 1.15;
				}
			}
		}
		else {
			//omega = 1.0;
			if (ksi < 1.0) {
				omega = 2.0*(1.0 - sqrt(1.0 - ksi)) / ksi;// лучший выбор.
				// Для стабильности.
				// 0.15/0.2==0.75;
				omega = 1.0 + (gold_const*0.75)*(omega - 1.0); // optimum zero init 0.75
				//omega = 1.0 + 0.5*(omega - 1.0); // 0.7 0.5
				//omega = 1.0; // Seidel
			}
			else {
				printf("problem define optimum omega\n");
				omega = 1.15;
			}
		}
	}
	//omega = 1.0; // seidel
	*/
  //  omega = 1.0; // seidel

}

// smoother.
// 5 jan 2016.
// 1 september 2015.
template <typename doublerealT>
void seidelsor(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{

	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	doublerealT rn = 1.0;
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			flag[Amat[ii].i] = true;
			rn += 1.0;
		}
	}

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	optimal_omega(rn, omega); // 28.07.2016.
	//omega = 0.7;

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			doublerealT rold = x[istr];
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					if (Amat[ic].aij < 0.0) {
						x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else{
						ap += Amat[ic].aij; // усиление диагонали 16. 08 .2016
					}
				}
				else ap += Amat[ic].aij;
				ic++;
			}
			/*
			if (fabs(ap) < 1.0e-30) {
			#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld",istr);
			#else
					printf("zero diagonal elements in string %d",istr);
			#endif
			
			getchar();
			exit(1);
			}
			else */ {
				x[istr] /= ap;
				x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
			}
			flag[Amat[ii].i] = true;
		}
	}


} // seidelsor



// smoother.
// 5 jan 2016.
// 1 september 2015.
template <typename doublerealT>
void seidelsor(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{

	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	doublerealT rn = 1.0;
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			flag[Amat[ii].i] = true;
			rn += 1.0;
		}
	}

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	optimal_omega(rn, omega);//28.07.2016
	//omega = 0.7;

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			doublerealT rold = x[istr];
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					if (Amat[ic].aij < 0.0) {
						x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap += Amat[ic].aij;
					}
				}
				else ap += Amat[ic].aij;
				ic++;
			}
			/*
			if (fabs(ap) < 1.0e-30) {
			#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld",istr);
			#else
					printf("zero diagonal elements in string %d",istr);
			#endif
			
			getchar();
			exit(1);
			}
			else */ {
				x[istr] /= ap;
				x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
			}
			flag[Amat[ii].i] = true;
		}
	}


} // seidelsor


// smoother.
// 5 jan 2016.
// 1 september 2015.
// 9 июня 2016.
// early_naive_relaxation_method.
// Этот код (данная функция) больше не используется. Это одна из ранних
// наивных попыток написать метод релаксации.
template <typename doublerealT>
void early_naive_relaxation_method(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{

	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	doublerealT rn = 1.0;
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			flag[Amat[ii].i] = true;
			rn += 1.0;
		}
	}

	doublerealT omega = 1.0; // initialize.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}

	// это нужне сделать единожды на фазе препроцессинга.
	doublerealT* diagonal = new doublerealT[(integer)(rn)];
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			doublerealT mult=0.0;
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					if (Amat[ic].j < istr) {
						// aij*aji/djj;
						// найти aji;
						doublerealT aji = 0.0;
						// линейный поиск очень медленный особенно на каждой итерации.
						for (integer ii1 = istart; ii1 <= iend; ii1++) {
							if (Amat[ii1].i == Amat[ic].j) {
								integer ic1 = ii1;
								while (Amat[ic1].i == Amat[ic].j) {
									if (Amat[ic1].j != Amat[ic].j) {
										if (Amat[ic1].j == istr) {
											aji = Amat[ic1].aij;
										}
									}
								}
								break;
							}
						}
						mult += (Amat[ic].aij*aji) / diagonal[Amat[ic].j];
					}
				}
				else ap = Amat[ic].aij;
				ic++;
			}
			diagonal[istr] = ap - mult;
			flag[Amat[ii].i] = true;
		}
	}


	// За подробностями смотри книгу Патрика Роуча стр. 183.
	optimal_omega(rn, omega);
	omega = 1.0;

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			doublerealT rold = x[istr];
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else ap = Amat[ic].aij;
				ic++;
			}
			/*
			if (fabs(ap) < 1.0e-30) {
			#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld",istr);
			#else
					printf("zero diagonal elements in string %d",istr);
			#endif
			
			getchar();
			exit(1);
			}
			else */ {
				//x[istr] /= ap;
				x[istr] /= diagonal[istr];
				//x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
			}
			flag[Amat[ii].i] = true;
		}
	}

	delete[] diagonal;

} // early_naive_relaxation_method


// smoother.
// 5 jan 2016.
// 1 september 2015.
// 9 июня 2016.
// early_naive_relaxation_method.
// Этот код (данная функция) больше не используется. Это одна из ранних
// наивных попыток написать метод релаксации.
template <typename doublerealT>
void early_naive_relaxation_method(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{

	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	doublerealT rn = 1.0;
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			flag[Amat[ii].i] = true;
			rn += 1.0;
		}
	}

	doublerealT omega = 1.0; // initialize.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}

	doublerealT* diagonal = new doublerealT[(integer)(rn)];
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			doublerealT mult = 0.0;
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					if (Amat[ic].j < istr) {
						// aij*aji/djj;
						// найти aji;
						doublerealT aji = 0.0;
						// Здесь нужно сделать хеш-таблицу которая позволяет избавиться от линейного поиска.
						// линейный поиск очень медленный особенно на каждой итерации.
						for (integer ii1 = istart; ii1 <= iend; ii1++) {
							if (Amat[ii1].i == Amat[ic].j) {
								integer ic1 = ii1;
								while (Amat[ic1].i == Amat[ic].j) {
									if (Amat[ic1].j != Amat[ic].j) {
										if (Amat[ic1].j == istr) {
											aji = Amat[ic1].aij;
										}
									}
								}
								break;
							}
						}
						mult += (Amat[ic].aij*aji) / diagonal[Amat[ic].j];
					}
				}
				else ap = Amat[ic].aij;
				ic++;
			}
			diagonal[istr] = ap - mult;
			flag[Amat[ii].i] = true;
		}
	}


	// За подробностями смотри книгу Патрика Роуча стр. 183.
	optimal_omega(rn, omega);
	omega = 1.0;

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			doublerealT rold = x[istr];
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else ap = Amat[ic].aij;
				ic++;
			}
			/*
			if (fabs(ap) < 1.0e-30) {
			#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld",istr);
			#else
				printf("zero diagonal elements in string %d",istr);
			#endif
			
			getchar();
			exit(1);
			}
			else */ {
				//x[istr] /= ap;
				x[istr] /= diagonal[istr];
				//x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
			}
			flag[Amat[ii].i] = true;
		}
	}

	delete[] diagonal;

} // early_naive_relaxation_method

// smoother.
// 5 jan 2016.
// 1 september 2015.
template <typename doublerealT>
void seidel(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{
	//seidel1<doublerealT>(Amat,  istart,  iend, x, b, flag, n);
	seidelsor<doublerealT>(Amat, istart, iend, x, b, flag, n);
	// низкое быстродействие из-за линейного поиска, нужна хеш-таблица.
	//classic_ilu<doublerealT>(Amat, istart, iend, x, b, flag, n);
}

// smoother.
// 5 jan 2016.
// 1 september 2015.
template <typename doublerealT>
void seidel(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{
	//seidel1<doublerealT>(Amat,  istart,  iend, x, b, flag, n);
	seidelsor<doublerealT>(Amat, istart, iend, x, b, flag, n);
	//classic_ilu<doublerealT>(Amat, istart, iend, x, b, flag, n);
}


  /*
  integer *row_ptr_start = new integer[4 * n_a[0] + 1];
  integer *row_ptr_end = new integer[4 * n_a[0] + 1];
  // istart - начальная позиция ненулевых элементов в матрице А.
  // iend - конечная позиция ненулевых элементов в матрице А.
  for (integer i = 1; i <= n; i++) {
  flag[i] = false;
  }
  for (integer ii = 1; ii <= nnz_a[0]; ii++) {
  if (flag[Amat[ii].i] == false) {
  integer istr = Amat[ii].i;
  integer ic = ii;
  integer icdiag = ii;
  row_ptr_start[istr] = ii;
  doublerealT ap = 0.0;
  //x[istr] = b[istr];
  while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
  if (Amat[ic].j != istr) {
  //x[istr] += -Amat[ic].aij*x[Amat[ic].j];
  }
  else {
  ap = Amat[ic].aij;
  icdiag = ic;
  }
  ic++;
  }
  row_ptr_end[istr] = ic - 1;
  if (fabs(ap) < 1.0e-30) {
  #if doubleintprecision == 1
		printf("zero diagonal elements in string %lld", istr);
  #else
		printf("zero diagonal elements in string %d", istr);
  #endif
 
  getchar();
  exit(1);
  }
  else {
  //x[istr] /= ap;
  }

  flag[Amat[ii].i] = true;
  Ak temp = Amat[ii];
  Amat[ii] = Amat[icdiag];
  Amat[icdiag] = temp;
  Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
  }
  }
  */

  // smoother.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void seidelqstable(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		x[istr] = b[istr];

		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
		{
			x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
		}
		x[istr] *= Amat[row_ptr_start[ii]].aij;
	}


} // seidelq

// smoother.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqstable(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		x[istr] = b[istr];

		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
		{
			x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
		}
		x[istr] *= Amat[row_ptr_start[ii]].aij;
	}


} // seidelq

integer isorintmemo = -1;
  // smoother.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void seidelqsor(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

    // BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.15; // лучший выбор.
	bool bfirst = false;
	//if (isorintmemo == iadd) {
		// Это точно не первый раз
		//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		doublerealT rold = x[istr];

		x[istr] = b[istr];

		doublerealT rsum = 0.0;
		// Параллельность почему-то тормозит очень сильно.
//#pragma omp parallel for reduction(+:rsum)
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
		{
			rsum += -Amat[ii1].aij*x[Amat[ii1].j];
			//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
		}
		x[istr] += rsum;

		x[istr] *= Amat[row_ptr_start[ii]].aij;
		if (bfirst) {
			bfirst = false;
		}
		else {
			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}


} // seidelqsor

template <typename doublerealT>
void seidelqsor(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.15; // лучший выбор.
	bool bfirst = false;
	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		doublerealT rold = x[istr];

		x[istr] = b[istr];

		doublerealT rsum = 0.0;
		// Параллельность почему-то тормозит очень сильно.
		//#pragma omp parallel for reduction(+:rsum)
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
		{
			rsum += -Amat[ii1].aij*x[Amat[ii1].j];
			//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
		}
		x[istr] += rsum;

		x[istr] *= Amat[row_ptr_start[ii]].aij;
		if (bfirst) {
			bfirst = false;
		}
		else {
			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}


} // seidelqsor


// smoother.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor2(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.
	
	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);
    //omega = 0.7;

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		doublerealT rold = x[istr];

		x[istr] = b[istr];

		doublerealT rsum = 0.0;
		integer is1 = row_ptr_start[ii] + 1;
		integer is2 = row_ptr_end[ii];
		// Распараллеливание почемуто тормозит очень сильно.
         //#pragma omp parallel for reduction(+:rsum)
		for (integer ii1 = is1; ii1 <=is2; ii1++)
		{
			//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
			integer ipos = Amat[ii1].j;
			rsum += -Amat[ii1].aij*x[ipos];
		}
		x[istr] += rsum;
		x[istr] *= Amat[row_ptr_start[ii]].aij;
		
			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
	}


} // seidelqsor2


bool bfirst_jacoby_start = true;
doublereal * x_jacoby_buffer = nullptr;
integer i_x_jacoby_buffer_pool_size = 0;
integer isimmetricGS_switch = 0;

// smoother.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor2(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega); //28.07.2016
	//omega = 0.7;

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;

	if (omega < 1.0) {
		if (bfirst_jacoby_start) {
			x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
			i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
			bfirst_jacoby_start = false;
		}
		else {
			// Перевыделение оперативной памяти в случае nu1==0.
			if (i_x_jacoby_buffer_pool_size < 3 * (endpos - startpos + 1)) {
				if (x_jacoby_buffer != nullptr) {
					delete[] x_jacoby_buffer;
					x_jacoby_buffer = nullptr;
					x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
					i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
					bfirst_jacoby_start = false;
			    }
			}
		}
		// copy

		if (x_jacoby_buffer == nullptr) {
			printf("ERROR: x_jacoby_buffer == nullptr.\n");
			system("PAUSE");
			exit(1);
		}


//#pragma loop(hint_parallel(8))
#pragma omp parallel for
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			x_jacoby_buffer[istr] = x[istr];
		}


//#pragma loop(hint_parallel(8))
#pragma omp parallel for
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			doublerealT rold = (doublerealT)(x_jacoby_buffer[istr]);

			// 13.07.2016
			doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				// 13.07.2016
				// игнорирование positive connections.
				//if ((Amat[ii1].aij < 0.0)) {
				rsum += (doublerealT)(-Amat[ii1].aij*x_jacoby_buffer[ipos]);
				//}
				//else {
				// не рабтает.
				//	ap_now += Amat[ii1].aij;
				//}
			}
			x[istr] += rsum;
			//x[istr] *= Amat[row_ptr_start[ii]].aij;
			// 13.07.2016
			x[istr] /= ap_now;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
		}
	}
	else {

		// 3 ноября 2016. Симметричный метод Гаусса-Зейделя.
		if (isimmetricGS_switch == 0) {
			// 3 ноября 2016 было экспериментально доказано на BSKDmitrii что симметричный метод Гаусса - Зейделя РАСХОДИТСЯ.
			// НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ СИММЕТРИЧНЫЙ МЕТОД ГАУССА -ЗЕЙДЕЛЯ. ИСПОЛЬЗУЙТЕ ОБЫЧНЫЙ МЕТОД ЗЕЙДЕЛЯ.


#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				integer istr = ii - iadd;
				doublerealT rold = x[istr];

				// 13.07.2016
				doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);
				// 28.01.2017
				//ap_now = 0.0;

				x[istr] = b[istr];

				doublerealT rsum = 0.0;
				integer is1 = row_ptr_start[ii] + 1;
				integer is2 = row_ptr_end[ii];
				// Распараллеливание почемуто тормозит очень сильно.
				//#pragma omp parallel for reduction(+:rsum)
				for (integer ii1 = is1; ii1 <= is2; ii1++)
				{
					//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
					integer ipos = Amat[ii1].j;
					// 13.07.2016
					if (1) {
						// игнорирование positive connections.
						//if ((Amat[ii1].aij < 0.0)) {
						// Здесь всё в каше и позитив и негатив коннектионшс.
						rsum += -Amat[ii1].aij*x[ipos];
						//}
						//else {
						// не работает.
						//	ap_now += Amat[ii1].aij;
						//}
					}
					else {
						// Здесь я перемудрил. По видимому нужен Крукиер: TKM, TKM1, TKM2.

						// игнорирование positive connections.
						if ((Amat[ii1].aij < 0.0)) {
						    rsum += -Amat[ii1].aij*x[ipos];
							//ap_now += fabs(Amat[ii1].aij);
						}
						else {
						   // не работает.
							// Вероятно из-за того что так нарушен баланс.
						    //ap_now += fabs(Amat[ii1].aij);
							if (fabs(x[ipos]) > fabs(x[istr])) {
								ap_now += fabs(Amat[ii1].aij);
							}
							else rsum += -Amat[ii1].aij*x[ipos];
						}
					}
				}
				x[istr] += rsum;
				//x[istr] *= Amat[row_ptr_start[ii]].aij;
				// 13.07.2016
				x[istr] /= ap_now;

				// Запускается только после первого раза сразу запускать нельзя
				// т.к. начальное значение не является адекватным.
				x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
			}
			// Ни в коем случае не переключать. 3 ноября 2016.
			//isimmetricGS_switch = 1;

		}
		else {

#pragma omp parallel for
			for (integer ii = endpos; ii >= startpos; ii--) {
				integer istr = ii - iadd;
				doublerealT rold = x[istr];

				// 13.07.2016
				doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

				x[istr] = b[istr];

				doublerealT rsum = 0.0;
				integer is1 = row_ptr_start[ii] + 1;
				integer is2 = row_ptr_end[ii];
				// Распараллеливание почемуто тормозит очень сильно.
				//#pragma omp parallel for reduction(+:rsum)
				for (integer ii1 = is1; ii1 <= is2; ii1++)
				{
					//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
					integer ipos = Amat[ii1].j;
					// 13.07.2016
					// игнорирование positive connections.
					//if ((Amat[ii1].aij < 0.0)) {
					rsum += -Amat[ii1].aij*x[ipos];
					//}
					//else {
					// не рабтает.
					//	ap_now += Amat[ii1].aij;
					//}
				}
				x[istr] += rsum;
				//x[istr] *= Amat[row_ptr_start[ii]].aij;
				// 13.07.2016
				x[istr] /= ap_now;

				// Запускается только после первого раза сразу запускать нельзя
				// т.к. начальное значение не является адекватным.
				x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
			}
			//isimmetricGS_switch = 0;
		}
	}


} // seidelqsor2

  // smoother.
  // 6 июня 2017 Трёхшаговый метод Рунге-Кутты, параметры взяты из литературы.
// Достоинство в том что оптимальные параметры известны из литературы и не надо
// ничего вручную подбирать.
// Методы Рунге-Кутты в качестве сглаживателей рекомендованы для очень плохообусловленных задач,
// что вызвано отчасти плохими сетками (например, АЛИС сетками).
  // 5 января 2016 с использованием формулы из книги Патрика Роуча.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void Runge_Kutt_3or5(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, integer iorder)
{
	// iorder == 3 or 5. Трёхшаговый или пятишаговый методы Рунге - Кутты.

	if ((iorder == 3) || (iorder == 5)) {

		// Трёхшаговый метод Рунге - Кутты.

		// Методы ускорения газодинамических расчётов на неструктурированных сетках. К.Н.Волков, под редакцией проф. В.Н.Емельянова
		// Москва ФИЗМАТЛИТ 2014.
		doublerealT m[5];
		if (iorder == 3) {
			if (1) {
				// ПИОНЕР - 1 лучший выбор.
				// Полное огрубление.
				m[0] = 0.2075;
				m[1] = 0.5915;
				m[2] = 1.0;
				m[3] = 0.0; // не используется в трёхшаговом методе.
				m[4] = 0.0; // не используется в трёхшаговом методе.
			}
			else {
				// Направленное огрубление.
				m[0] = 0.2239;
				m[1] = 0.5653;
				m[2] = 1.0;
				m[3] = 0.0; // не используется в трёхшаговом методе.
				m[4] = 0.0; // не используется в трёхшаговом методе.
			}
		}

		if (iorder == 5) {
			if (0) {
				// ПИОНЕР - 1 лучший выбор.
				// Полное огрубление.
				m[0] = 0.0962;
				m[1] = 0.2073;
				m[2] = 0.3549;
				m[3] = 0.6223;
				m[4] = 1.0;
			}
			else {
				// Направленное огрубление.
				m[0] = 0.0870;
				m[1] = 0.1892;
				m[2] = 0.3263;
				m[3] = 0.5558;
				m[4] = 1.0;
			}
		}

		// istart - начальная позиция ненулевых элементов в матрице А.
		// iend - конечная позиция ненулевых элементов в матрице А.


		doublerealT rn = (doublerealT)(iendq - istartq + 1);

		integer startpos = istartq + iadd;
		integer endpos = iendq + iadd;


		if (bfirst_jacoby_start) {
			x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
			i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
			bfirst_jacoby_start = false;
		}
		else {
			// Перевыделение оперативной памяти в случае nu1==0.
			if (i_x_jacoby_buffer_pool_size < 3 * (endpos - startpos + 1)) {
				if (x_jacoby_buffer != nullptr) {
					delete[] x_jacoby_buffer;
					x_jacoby_buffer = nullptr;
					x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
					i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
					bfirst_jacoby_start = false;
				}
			}
		}
		// copy

		
		if (x_jacoby_buffer == nullptr) {
			printf("ERROR: x_jacoby_buffer == nullptr.\n");
			system("PAUSE");
			exit(1);
		}


		for (integer inumber_step_Runge_Kutt = 0; inumber_step_Runge_Kutt < iorder-1; inumber_step_Runge_Kutt++) {

			
				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					integer istr = ii - iadd;
					x_jacoby_buffer[istr] = x[istr];
				}
			

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {

				integer istr = ii - iadd;
				doublerealT rold = (doublerealT)(x_jacoby_buffer[istr]);

				// 13.07.2016
				doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

				x[istr] = b[istr];

				doublerealT rsum = 0.0;
				integer is1 = row_ptr_start[ii] + 1;
				integer is2 = row_ptr_end[ii];
				// Распараллеливание почемуто тормозит очень сильно.
				//#pragma omp parallel for reduction(+:rsum)
				for (integer ii1 = is1; ii1 <= is2; ii1++)
				{
					//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
					integer ipos = Amat[ii1].j;
					// 13.07.2016
					// игнорирование positive connections.
					//if ((Amat[ii1].aij < 0.0)) {
					rsum += (doublerealT)(-Amat[ii1].aij*x_jacoby_buffer[ipos]);

					//rsum += -Amat[ii1].aij*x[ipos]; // experiment
					//}
					//else {
					// не рабтает.
					//	ap_now += Amat[ii1].aij;
					//}
				}
				x[istr] += rsum;
				//x[istr] *= Amat[row_ptr_start[ii]].aij;
				// 13.07.2016
				x[istr] /= ap_now;


				x[istr] = (doublerealT)((1.0 - m[inumber_step_Runge_Kutt])*x[istr] + m[inumber_step_Runge_Kutt] * rold); // 21
				//x[istr] = m[inumber_step_Runge_Kutt]*x[istr] + (1.0-m[inumber_step_Runge_Kutt]) * rold; // 23
				
				//x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
				//x[istr] = x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
			}

		}

	}
	else {
		// Неправильный порядок метода Рунге - Кутты. 
		// Предусмотрены только третий и пятый порядки.
		printf("order Runge Kutt method is bad...\n ");
		system("pause");
		exit(1);
	}


} // Runge_Kutt_3or5

  // smoother.
  // 6 июня 2017 Трёхшаговый метод Рунге-Кутты, параметры взяты из литературы.
  // Достоинство в том что оптимальные параметры известны из литературы и не надо
  // ничего вручную подбирать.
  // Методы Рунге-Кутты в качестве сглаживателей рекомендованы для очень плохообусловленных задач,
  // что вызвано отчасти плохими сетками (например, АЛИС сетками).
  // 5 января 2016 с использованием формулы из книги Патрика Роуча.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void Runge_Kutt_3or5(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, 
	integer* &row_ptr_end, integer iadd, integer iorder, bool* &F_false_C_true, integer idirect)
{
	// iorder == 3 or 5. Трёхшаговый или пятишаговый методы Рунге - Кутты.

	if ((iorder == 3) || (iorder == 5)) {

		// Трёхшаговый метод Рунге - Кутты.

		// Методы ускорения газодинамических расчётов на неструктурированных сетках. К.Н.Волков, под редакцией проф. В.Н.Емельянова
		// Москва ФИЗМАТЛИТ 2014.
		doublerealT m[5];
		if (iorder == 3) {
			if (1) {
				// ПИОНЕР - 1 лучший выбор.
				// Полное огрубление.
				m[0] = 0.2075;
				m[1] = 0.5915;
				m[2] = 1.0;
				m[3] = 0.0; // не используется в трёхшаговом методе.
				m[4] = 0.0; // не используется в трёхшаговом методе.
			}
			else {
				// Направленное огрубление.
				m[0] = 0.2239;
				m[1] = 0.5653;
				m[2] = 1.0;
				m[3] = 0.0; // не используется в трёхшаговом методе.
				m[4] = 0.0; // не используется в трёхшаговом методе.
			}
		}

		if (iorder == 5) {
			if (0) {
				// ПИОНЕР - 1 лучший выбор.
				// Полное огрубление.
				m[0] = 0.0962;
				m[1] = 0.2073;
				m[2] = 0.3549;
				m[3] = 0.6223;
				m[4] = 1.0;
			}
			else {
				// Направленное огрубление.
				m[0] = 0.0870;
				m[1] = 0.1892;
				m[2] = 0.3263;
				m[3] = 0.5558;
				m[4] = 1.0;
			}
		}

		// istart - начальная позиция ненулевых элементов в матрице А.
		// iend - конечная позиция ненулевых элементов в матрице А.


		doublerealT rn = (doublerealT)(iendq - istartq + 1);

		integer startpos = istartq + iadd;
		integer endpos = iendq + iadd;


		if (bfirst_jacoby_start) {
			x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
			i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
			bfirst_jacoby_start = false;
		}
		else {
			// Перевыделение оперативной памяти в случае nu1==0.
			if (i_x_jacoby_buffer_pool_size < 3 * (endpos - startpos + 1)) {
				if (x_jacoby_buffer != nullptr) {
					delete[] x_jacoby_buffer;
					x_jacoby_buffer = nullptr;
					x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
					i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
					bfirst_jacoby_start = false;
				}
			}
		}
		// copy





		for (integer inumber_step_Runge_Kutt = 0; inumber_step_Runge_Kutt < iorder - 1; inumber_step_Runge_Kutt++) {

			if (idirect == 1) {

				// Восходящая ветвь: сначала F потом C.

				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					integer istr = ii - iadd;
					x_jacoby_buffer[istr] = x[istr];
				}

				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii] == false) {

						integer istr = ii - iadd;
						doublerealT rold = (doublerealT)(x_jacoby_buffer[istr]);

						// 13.07.2016
						doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += (doublerealT)(-Amat[ii1].aij*x_jacoby_buffer[ipos]);

							//rsum += -Amat[ii1].aij*x[ipos]; // experiment
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;


						x[istr] = (doublerealT)((1.0 - m[inumber_step_Runge_Kutt])*x[istr] + m[inumber_step_Runge_Kutt] * rold); // 21
						//x[istr] = m[inumber_step_Runge_Kutt]*x[istr] + (1.0-m[inumber_step_Runge_Kutt]) * rold; // 23

						//x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
						//x[istr] = x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
					}
				}


				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					integer istr = ii - iadd;
					x_jacoby_buffer[istr] = x[istr];
				}

				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii]  ) {

						integer istr = ii - iadd;
						doublerealT rold = (doublerealT)(x_jacoby_buffer[istr]);

						// 13.07.2016
						doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += (doublerealT)(-Amat[ii1].aij*x_jacoby_buffer[ipos]);

							//rsum += -Amat[ii1].aij*x[ipos]; // experiment
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;


						x[istr] = (doublerealT)((1.0 - m[inumber_step_Runge_Kutt])*x[istr] + m[inumber_step_Runge_Kutt] * rold); // 21
						//x[istr] = m[inumber_step_Runge_Kutt]*x[istr] + (1.0-m[inumber_step_Runge_Kutt]) * rold; // 23

						//x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
						//x[istr] = x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];

					}
				}

			}
			else {
				// Нисходящая ветвь: сначала C потом F.

				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					integer istr = ii - iadd;
					x_jacoby_buffer[istr] = x[istr];
				}

				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii]  ) {

						integer istr = ii - iadd;
						doublerealT rold = (doublerealT)(x_jacoby_buffer[istr]);

						// 13.07.2016
						doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += (doublerealT)(-Amat[ii1].aij*x_jacoby_buffer[ipos]);

							//rsum += -Amat[ii1].aij*x[ipos]; // experiment
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;


						x[istr] = (doublerealT)((1.0 - m[inumber_step_Runge_Kutt])*x[istr] + m[inumber_step_Runge_Kutt] * rold); // 21
						//x[istr] = m[inumber_step_Runge_Kutt]*x[istr] + (1.0-m[inumber_step_Runge_Kutt]) * rold; // 23

						//x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
						//x[istr] = x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
					}
				}


				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					integer istr = ii - iadd;
					x_jacoby_buffer[istr] = x[istr];
				}

				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii] == false) {

						integer istr = ii - iadd;
						doublerealT rold = (doublerealT)(x_jacoby_buffer[istr]);

						// 13.07.2016
						doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += (doublerealT)(-Amat[ii1].aij*x_jacoby_buffer[ipos]);

							//rsum += -Amat[ii1].aij*x[ipos]; // experiment
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;


						x[istr] = (doublerealT)((1.0 - m[inumber_step_Runge_Kutt])*x[istr] + m[inumber_step_Runge_Kutt] * rold); // 21
						//x[istr] = m[inumber_step_Runge_Kutt]*x[istr] + (1.0-m[inumber_step_Runge_Kutt]) * rold; // 23

						//x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
						//x[istr] = x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];

					}
				}


			}

		}

	}
	else {
		// Неправильный порядок метода Рунге - Кутты. 
		// Предусмотрены только третий и пятый порядки.
		printf("order Runge Kutt method is bad...\n ");
		system("pause");
		exit(1);
	}


} // Runge_Kutt_3or5

// smoother.
// 5 июня 2017 добавлено CF-Jacobi smoothing (F - smoothing).
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor2(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, bool* &F_false_C_true, integer idirect)
{
	// F_false_C_true - нумерация начинается с 1.
	// idirect==0 douwn
	// idirect==1 up

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

							// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega); //28.07.2016
							  //omega = 0.7;

							  //if (isorintmemo == iadd) {
							  // Это точно не первый раз
							  //bfirst = false;
							  //}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;

	if (omega < 1.0) {
		if (bfirst_jacoby_start) {
			x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
			i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
			bfirst_jacoby_start = false;
		}
		else {
			// Перевыделение оперативной памяти в случае nu1==0.
			if (i_x_jacoby_buffer_pool_size < 3 * (endpos - startpos + 1)) {
				if (x_jacoby_buffer != nullptr) {
					delete[] x_jacoby_buffer;
					x_jacoby_buffer = nullptr;
					x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
					i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
					bfirst_jacoby_start = false;
				}
			}
		}
		// copy

		

		if (idirect == 1) {
			// Восходящая ветвь.

			// Сначала F потом C.

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				integer istr = ii - iadd;
				x_jacoby_buffer[istr] = x[istr];
			}

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				if (F_false_C_true[ii] == false) { // F nodes

					integer istr = ii - iadd;
					doublerealT rold = (doublerealT)(x_jacoby_buffer[istr]);

					// 13.07.2016
					doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

					x[istr] = b[istr];

					doublerealT rsum = 0.0;
					integer is1 = row_ptr_start[ii] + 1;
					integer is2 = row_ptr_end[ii];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii1 = is1; ii1 <= is2; ii1++)
					{
						//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
						integer ipos = Amat[ii1].j;
						// 13.07.2016
						// игнорирование positive connections.
						//if ((Amat[ii1].aij < 0.0)) {
						rsum += (doublerealT)(-Amat[ii1].aij*x_jacoby_buffer[ipos]);
						//}
						//else {
						// не рабтает.
						//	ap_now += Amat[ii1].aij;
						//}
					}
					x[istr] += rsum;
					//x[istr] *= Amat[row_ptr_start[ii]].aij;
					// 13.07.2016
					x[istr] /= ap_now;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					//if (is1 <= is2) {
						// Только если это не условие Дирихле применяем релаксацию.
						x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
					//}
				}
			}

			// update.
			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				integer istr = ii - iadd;
				x_jacoby_buffer[istr] = x[istr];
			}

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				if (F_false_C_true[ii]  ) { // C nodes

					integer istr = ii - iadd;
					doublerealT rold = (doublerealT)(x_jacoby_buffer[istr]);

					// 13.07.2016
					doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

					x[istr] = b[istr];

					doublerealT rsum = 0.0;
					integer is1 = row_ptr_start[ii] + 1;
					integer is2 = row_ptr_end[ii];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii1 = is1; ii1 <= is2; ii1++)
					{
						//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
						integer ipos = Amat[ii1].j;
						// 13.07.2016
						// игнорирование positive connections.
						//if ((Amat[ii1].aij < 0.0)) {
						rsum += (doublerealT)(-Amat[ii1].aij*x_jacoby_buffer[ipos]);
						//}
						//else {
						// не рабтает.
						//	ap_now += Amat[ii1].aij;
						//}
					}
					x[istr] += rsum;
					//x[istr] *= Amat[row_ptr_start[ii]].aij;
					// 13.07.2016
					x[istr] /= ap_now;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					//if (is1 <= is2) {
						// Только если это не условие Дирихле применяем релаксацию.
						x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
					//}
				}
			}



		}
		else {
			// idirect==0
			// Сначала С потом F.

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				integer istr = ii - iadd;
				x_jacoby_buffer[istr] = x[istr];
			}

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				if (F_false_C_true[ii]  ) { // C nodes

					integer istr = ii - iadd;
					doublerealT rold = (doublerealT)(x_jacoby_buffer[istr]);

					// 13.07.2016
					doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

					x[istr] = b[istr];

					doublerealT rsum = 0.0;
					integer is1 = row_ptr_start[ii] + 1;
					integer is2 = row_ptr_end[ii];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii1 = is1; ii1 <= is2; ii1++)
					{
						//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
						integer ipos = Amat[ii1].j;
						// 13.07.2016
						// игнорирование positive connections.
						//if ((Amat[ii1].aij < 0.0)) {
						rsum += (doublerealT)(-Amat[ii1].aij*x_jacoby_buffer[ipos]);
						//}
						//else {
						// не рабтает.
						//	ap_now += Amat[ii1].aij;
						//}
					}
					x[istr] += rsum;
					//x[istr] *= Amat[row_ptr_start[ii]].aij;
					// 13.07.2016
					x[istr] /= ap_now;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					//if (is1 <= is2) {
						// Только если это не условие Дирихле применяем релаксацию.
						x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
					//}
				}
			}


			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				integer istr = ii - iadd;
				x_jacoby_buffer[istr] = x[istr];
			}

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				if (F_false_C_true[ii] == false) { // F nodes

					integer istr = ii - iadd;
					doublerealT rold = (doublerealT)(x_jacoby_buffer[istr]);

					// 13.07.2016
					doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

					x[istr] = b[istr];

					doublerealT rsum = 0.0;
					integer is1 = row_ptr_start[ii] + 1;
					integer is2 = row_ptr_end[ii];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii1 = is1; ii1 <= is2; ii1++)
					{
						//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
						integer ipos = Amat[ii1].j;
						// 13.07.2016
						// игнорирование positive connections.
						//if ((Amat[ii1].aij < 0.0)) {
						rsum += (doublerealT)(-Amat[ii1].aij*x_jacoby_buffer[ipos]);
						//}
						//else {
						// не рабтает.
						//	ap_now += Amat[ii1].aij;
						//}
					}
					x[istr] += rsum;
					//x[istr] *= Amat[row_ptr_start[ii]].aij;
					// 13.07.2016
					x[istr] /= ap_now;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					//if (is1 <= is2) {
						// Только если это не условие Дирихле применяем релаксацию.
						x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
					//}
				}
			}

		}


	}
	else {

		// 3 ноября 2016. Симметричный метод Гаусса-Зейделя.
		if (isimmetricGS_switch == 0) {
			// 3 ноября 2016 было экспериментально доказано на BSKDmitrii что симметричный метод Гаусса - Зейделя РАСХОДИТСЯ.
			// НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ СИММЕТРИЧНЫЙ МЕТОД ГАУССА -ЗЕЙДЕЛЯ. ИСПОЛЬЗУЙТЕ ОБЫЧНЫЙ МЕТОД ЗЕЙДЕЛЯ.

			if (idirect == 1) {
				// Восходящая ветвь.

				

				// Сначала F потом C.

//----->#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii] == false) { // F nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);
						// 28.01.2017
						//ap_now = 0.0;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							if (1) {
								// игнорирование positive connections.
								//if ((Amat[ii1].aij < 0.0)) {
								// Здесь всё в каше и позитив и негатив коннектионшс.
								rsum += -Amat[ii1].aij*x[ipos];
								//}
								//else {
								// не работает.
								//	ap_now += Amat[ii1].aij;
								//}
							}
							else {
								// Здесь я перемудрил. По видимому нужен Крукиер: TKM, TKM1, TKM2.

								// игнорирование positive connections.
								if ((Amat[ii1].aij < 0.0)) {
									rsum += -Amat[ii1].aij*x[ipos];
									//ap_now += fabs(Amat[ii1].aij);
								}
								else {
									// не работает.
									// Вероятно из-за того что так нарушен баланс.
									//ap_now += fabs(Amat[ii1].aij);
									if (fabs(x[ipos]) > fabs(x[istr])) {
										ap_now += fabs(Amat[ii1].aij);
									}
									else rsum += -Amat[ii1].aij*x[ipos];
								}
							}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
						//}
					}
				}

//---->#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii]  ) { // C nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);
						// 28.01.2017
						//ap_now = 0.0;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							if (1) {
								// игнорирование positive connections.
								//if ((Amat[ii1].aij < 0.0)) {
								// Здесь всё в каше и позитив и негатив коннектионшс.
								rsum += -Amat[ii1].aij*x[ipos];
								//}
								//else {
								// не работает.
								//	ap_now += Amat[ii1].aij;
								//}
							}
							else {
								// Здесь я перемудрил. По видимому нужен Крукиер: TKM, TKM1, TKM2.

								// игнорирование positive connections.
								if ((Amat[ii1].aij < 0.0)) {
									rsum += -Amat[ii1].aij*x[ipos];
									//ap_now += fabs(Amat[ii1].aij);
								}
								else {
									// не работает.
									// Вероятно из-за того что так нарушен баланс.
									//ap_now += fabs(Amat[ii1].aij);
									if (fabs(x[ipos]) > fabs(x[istr])) {
										ap_now += fabs(Amat[ii1].aij);
									}
									else rsum += -Amat[ii1].aij*x[ipos];
								}
							}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
						//}
					}
				}

			}
			else {

				// idirect==0
				// Сначала С потом F.

//---->#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii]  ) { // C nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);
						// 28.01.2017
						//ap_now = 0.0;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							if (1) {
								// игнорирование positive connections.
								//if ((Amat[ii1].aij < 0.0)) {
								// Здесь всё в каше и позитив и негатив коннектионшс.
								rsum += -Amat[ii1].aij*x[ipos];
								//}
								//else {
								// не работает.
								//	ap_now += Amat[ii1].aij;
								//}
							}
							else {
								// Здесь я перемудрил. По видимому нужен Крукиер: TKM, TKM1, TKM2.

								// игнорирование positive connections.
								if ((Amat[ii1].aij < 0.0)) {
									rsum += -Amat[ii1].aij*x[ipos];
									//ap_now += fabs(Amat[ii1].aij);
								}
								else {
									// не работает.
									// Вероятно из-за того что так нарушен баланс.
									//ap_now += fabs(Amat[ii1].aij);
									if (fabs(x[ipos]) > fabs(x[istr])) {
										ap_now += fabs(Amat[ii1].aij);
									}
									else rsum += -Amat[ii1].aij*x[ipos];
								}
							}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
						//}
					}
				}

//---->#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii] == false) { // F nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);
						// 28.01.2017
						//ap_now = 0.0;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							if (1) {
								// игнорирование positive connections.
								//if ((Amat[ii1].aij < 0.0)) {
								// Здесь всё в каше и позитив и негатив коннектионшс.
								rsum += -Amat[ii1].aij*x[ipos];
								//}
								//else {
								// не работает.
								//	ap_now += Amat[ii1].aij;
								//}
							}
							else {
								// Здесь я перемудрил. По видимому нужен Крукиер: TKM, TKM1, TKM2.

								// игнорирование positive connections.
								if ((Amat[ii1].aij < 0.0)) {
									rsum += -Amat[ii1].aij*x[ipos];
									//ap_now += fabs(Amat[ii1].aij);
								}
								else {
									// не работает.
									// Вероятно из-за того что так нарушен баланс.
									//ap_now += fabs(Amat[ii1].aij);
									if (fabs(x[ipos]) > fabs(x[istr])) {
										ap_now += fabs(Amat[ii1].aij);
									}
									else rsum += -Amat[ii1].aij*x[ipos];
								}
							}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
						//}
					}
				}

			}

			// Ни в коем случае не переключать. 3 ноября 2016.
			//isimmetricGS_switch = 1;

		}
		else {

			if (idirect == 1) {
				// Восходящая ветвь.

				// Сначала F потом C.

//---->#pragma omp parallel for
				for (integer ii = endpos; ii >= startpos; ii--) {
					if (F_false_C_true[ii] == false) { // F nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += -Amat[ii1].aij*x[ipos];
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
						//}
					}
				}


//----->#pragma omp parallel for
				for (integer ii = endpos; ii >= startpos; ii--) {
					if (F_false_C_true[ii]  ) { // C nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += -Amat[ii1].aij*x[ipos];
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
						//}
					}
				}



			}
			else {
				// idirect==0
				// Сначала С потом F.

//--->#pragma omp parallel for
				for (integer ii = endpos; ii >= startpos; ii--) {
					if (F_false_C_true[ii]  ) { // C nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += -Amat[ii1].aij*x[ipos];
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
						//}
					}
				}


//--->#pragma omp parallel for
				for (integer ii = endpos; ii >= startpos; ii--) {
					if (F_false_C_true[ii] == false) { // F nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = (doublerealT)(1.0 / Amat[row_ptr_start[ii]].aij);

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += -Amat[ii1].aij*x[ipos];
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
						//}
					}
				}

			}

			//isimmetricGS_switch = 0;  // смена направления.
		}
	}


} // seidelqsor2


// smoother.
// 16 января 2016 распараллеливание на центральном процессоре.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor2Pcpu(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;

	const integer inumcore_loc = 2;

if (inumcore_loc == 1) 
	{

		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			doublerealT rold = x[istr];

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				rsum += -Amat[ii1].aij*x[ipos];
			}
			x[istr] += rsum;
			x[istr] *= Amat[row_ptr_start[ii]].aij;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}

	}

if (inumcore_loc == 2)
	{

		// Здесь отсутствует информация о nested_desection
		// поэтому куча времени тратится на барьерную синхронизацию.

		integer middle = (startpos + endpos)/2;
		integer iadd1 = iadd;
		integer iadd2 = iadd;
		integer middle1 = middle;

#pragma omp parallel sections
		{
#pragma omp section
			{
				// работа первого потока.
				for (integer ii = startpos; ii <= middle; ii++) {
					integer istr = ii - iadd1;
					doublerealT rold = x[istr];

					doublerealT x1buf = 0.0;
					x1buf = b[istr];

					doublerealT rsum1 = 0.0;
					integer is1 = row_ptr_start[ii] + 1;
					integer is2 = row_ptr_end[ii];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii1 = is1; ii1 <= is2; ii1++)
					{
						//x1buf += -Amat[ii1].aij*x[Amat[ii1].j];
						integer ipos = Amat[ii1].j;
						rsum1 = rsum1 - Amat[ii1].aij*x[ipos];
					}
					x1buf = x1buf + rsum1;
					x1buf = x1buf * Amat[row_ptr_start[ii]].aij;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					x1buf = omega*x1buf + (1.0 - omega)*rold; // this is SOR
					x[istr] = x1buf;
				}
			}

#pragma omp section
			{
				// работа второго потока. 
				for (integer ii_1 = middle1 + 1; ii_1 <= endpos; ii_1++) {
					integer istr1 = ii_1 - iadd2;
					doublerealT rold1 = x[istr1];

					doublerealT x2buf = 0.0;
					x2buf = b[istr1];

					doublerealT rsum2 = 0.0;
					integer is3 = row_ptr_start[ii_1] + 1;
					integer is4 = row_ptr_end[ii_1];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii2 = is3; ii2 <= is4; ii2++)
					{
						//x[istr1] += -Amat[ii2].aij*x[Amat[ii2].j];
						integer ipos = Amat[ii2].j;
						rsum2 = rsum2 - Amat[ii2].aij*x[ipos];
					}
					x2buf = x2buf + rsum2;
					x2buf = x2buf*Amat[row_ptr_start[ii_1]].aij;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					x2buf = omega*x2buf + (1.0 - omega)*rold1; // this is SOR
					x[istr1]=x2buf;
				}
			}
		}

	}



} // seidelqsor2Pcpu


bool* bnested_desection_global_amg = nullptr;

// smoother.
// 16 января 2016 распараллеливание на центральном процессоре.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor2Pcpu(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, bool* &bnested_desection, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;

	const integer inumcore_loc = 1;

if (inumcore_loc == 1) 
	{

		// Однопоточный вариант программы.
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			doublerealT rold = x[istr];

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				rsum += -Amat[ii1].aij*x[ipos];
			}
			x[istr] += rsum;
			x[istr] *= Amat[row_ptr_start[ii]].aij;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
		}

	}


if (inumcore_loc == 2)
	{

		integer middle = (integer)(0.5*(startpos + endpos));
		doublerealT omega1 = omega;
		doublerealT omega2 = omega;
		integer iadd1 = iadd;
		integer iadd2 = iadd;
		integer middle1 = middle;
		doublerealT ic_all = 0.0;
		doublerealT ic_separator = 0.0;
		for (integer i_51 = startpos - iadd1; i_51 <= endpos - iadd1; i_51++) {
			bnested_desection_global_amg[i_51] = bnested_desection[i_51];
			ic_all+=1.0;
			if (!bnested_desection_global_amg[i_51]) ic_separator+=1.0;
		}
		//printf("all=%e separator=%e\n",ic_all,ic_separator);
		//system("pause");

		if (2.0*ic_separator < ic_all) {
			// параллельно только при хорошем делении.



			//#pragma omp parallel sections num_threads(4)
			//{

			//printf_s("Hello from thread %d\n", omp_get_thread_num());
			//#pragma omp section
			//	printf_s("Hello from thread %d\n", omp_get_thread_num());
			///}

			// Версия с nesteddesection избавляет от барьерных синхронизаций и мы
			// получаем линейное ускорение производительности при увеличении числа ядер.

			//default(shared)

#pragma omp parallel  shared(bnested_desection_global_amg, bnested_desection,x,row_ptr_start,row_ptr_end,b,Amat)
			{
			#pragma omp	sections
				{
			#pragma omp section
					{
//#pragma omp parallel sections num_threads(2)
	//	{

			// работа первого потока.
			for (integer ii = startpos; ii <= middle; ii++) {
				integer istr = ii - iadd1;
				if (bnested_desection_global_amg[istr]) {
					doublerealT rold = x[istr];

					doublerealT x1buf = 0.0;
					x1buf = b[istr];

					doublerealT rsum1 = 0.0;
					integer is1 = row_ptr_start[ii] + 1;
					integer is2 = row_ptr_end[ii];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii1 = is1; ii1 <= is2; ii1++)
					{
						//x1buf += -Amat[ii1].aij*x[Amat[ii1].j];
						integer ipos = Amat[ii1].j;
						rsum1 = rsum1 - Amat[ii1].aij*x[ipos];
					}
					x1buf = x1buf + rsum1;
					x1buf = x1buf * Amat[row_ptr_start[ii]].aij;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					x1buf = (doublerealT)(omega1*x1buf + (1.0 - omega1)*rold); // this is SOR
					x[istr] = x1buf;
				}
			}
			}

#pragma omp section
			{
				// работа второго потока. 
				for (integer ii_1 = middle1 + 1; ii_1 <= endpos; ii_1++) {
					integer istr1 = ii_1 - iadd2;
					if (bnested_desection[istr1]) {
						doublerealT rold1 = x[istr1];

						doublerealT x2buf = 0.0;
						x2buf = b[istr1];

						doublerealT rsum2 = 0.0;
						integer is3 = row_ptr_start[ii_1] + 1;
						integer is4 = row_ptr_end[ii_1];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii2 = is3; ii2 <= is4; ii2++)
						{
							//x[istr1] += -Amat[ii2].aij*x[Amat[ii2].j];
							integer ipos = Amat[ii2].j;
							rsum2 = rsum2 - Amat[ii2].aij*x[ipos];
						}
						x2buf = x2buf + rsum2;
						x2buf = x2buf*Amat[row_ptr_start[ii_1]].aij;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						x2buf = (doublerealT)(omega2*x2buf + (1.0 - omega2)*rold1); // this is SOR
						x[istr1] = x2buf;
					}
				}
			}
		}
		}

		// Однопоточный смыкающий кусок.
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			if (!bnested_desection[istr]) {
				doublerealT rold = x[istr];

				x[istr] = b[istr];

				doublerealT rsum = 0.0;
				integer is1 = row_ptr_start[ii] + 1;
				integer is2 = row_ptr_end[ii];
				// Распараллеливание почемуто тормозит очень сильно.
				//#pragma omp parallel for reduction(+:rsum)
				for (integer ii1 = is1; ii1 <= is2; ii1++)
				{
					//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
					integer ipos = Amat[ii1].j;
					rsum += -Amat[ii1].aij*x[ipos];
				}
				x[istr] += rsum;
				x[istr] *= Amat[row_ptr_start[ii]].aij;

				// Запускается только после первого раза сразу запускать нельзя
				// т.к. начальное значение не является адекватным.
				x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
			}
		}
		}
		else {
			// серийно
			// Однопоточный вариант программы.
			for (integer ii = startpos; ii <= endpos; ii++) {
				integer istr = ii - iadd;
				doublerealT rold = x[istr];

				x[istr] = b[istr];

				doublerealT rsum = 0.0;
				integer is1 = row_ptr_start[ii] + 1;
				integer is2 = row_ptr_end[ii];
				// Распараллеливание почемуто тормозит очень сильно.
				//#pragma omp parallel for reduction(+:rsum)
				for (integer ii1 = is1; ii1 <= is2; ii1++)
				{
					//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
					integer ipos = Amat[ii1].j;
					rsum += -Amat[ii1].aij*x[ipos];
				}
				x[istr] += rsum;
				x[istr] *= Amat[row_ptr_start[ii]].aij;

				// Запускается только после первого раза сразу запускать нельзя
				// т.к. начальное значение не является адекватным.
				x[istr] = (doublerealT)(omega*x[istr] + (1.0 - omega)*rold); // this is SOR
			}
		}

	}



} // seidelqsor2Pcpu+nested desection


bool bswitch_direct_seidelqsor3 = false;
// smoother.
// 14 января 2015 каждый раз осуществляется смена направления сканирования.
// Работает только с ноой логикой: nFinestSweeps=2, nPreSweeps=0, nPostSweeps=2.
// Смена направлений оказалась значительно хуже по быстродействию.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor3(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	if (bswitch_direct_seidelqsor3) {
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			doublerealT rold = x[istr];

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				rsum += -Amat[ii1].aij*x[ipos];
			}
			x[istr] += rsum;
			x[istr] *= Amat[row_ptr_start[ii]].aij;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}
	else {
		// другое направление сканирования.

		for (integer ii = endpos; ii >= startpos; ii--) {
			integer istr = ii - iadd;
			doublerealT rold = x[istr];

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				rsum += -Amat[ii1].aij*x[ipos];
			}
			x[istr] += rsum;
			x[istr] *= Amat[row_ptr_start[ii]].aij;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}

	// смена направления сканирования на обратное.
	bswitch_direct_seidelqsor3 = !bswitch_direct_seidelqsor3;

} // seidelqsor3

// smoother.
// 14 января 2015 каждый раз осуществляется смена направления сканирования.
// Работает только с ноой логикой: nFinestSweeps=2, nPreSweeps=0, nPostSweeps=2.
// Смена направлений оказалась значительно хуже по быстродействию.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor3(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	if (bswitch_direct_seidelqsor3) {
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			doublerealT rold = x[istr];

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				rsum += -Amat[ii1].aij*x[ipos];
			}
			x[istr] += rsum;
			x[istr] *= Amat[row_ptr_start[ii]].aij;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}
	else {
		// другое направление сканирования.

		for (integer ii = endpos; ii >= startpos; ii--) {
			integer istr = ii - iadd;
			doublerealT rold = x[istr];

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				rsum += -Amat[ii1].aij*x[ipos];
			}
			x[istr] += rsum;
			x[istr] *= Amat[row_ptr_start[ii]].aij;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}

	// смена направления сканирования на обратное.
	bswitch_direct_seidelqsor3 = !bswitch_direct_seidelqsor3;

} // seidelqsor3


// smoother.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
// 9 июня 2016. 
// early_naive_relaxation_method2.
// Этот код (данная функция) больше не используется. Это одна из ранних
// наивных попыток написать метод релаксации.
template <typename doublerealT>
void early_naive_relaxation_method2(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);
	omega = 1.0;

	// это нужне сделать единожды на фазе препроцессинга.
	doublerealT* diagonal = nullptr;
	diagonal = new doublerealT[(integer)(rn)+1];
	if (diagonal == nullptr) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem: not enough memory on your equipment for diagonal in classical_ilu2...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	// initialization:
	for (integer i_6 = 0; i_6 < (integer)(rn)+1; i_6++) diagonal[i_6] = 1.0;

	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		{
			integer istr = ii-iadd;
			integer ic = ii;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			doublerealT ap = 0.0;
			doublerealT mult = 0.0;
			for (ic = is1; ic <= is2; ic++) {
				if (Amat[ic].j != istr) {
					if (Amat[ic].j < istr) {
						// aij*aji/djj;
						// найти aji;
						doublerealT aji = 0.0;
						// линейный поиск очень медленный особенно на каждой итерации.
						integer ii1 = iadd + Amat[ic].j;
						//for (integer ii1 = startpos; ii1 <= endpos; ii1++) {
							if (Amat[ii1].i == Amat[ic].j) {
								integer ic1 = ii1;
								integer is11 = row_ptr_start[ii1] + 1;
								integer is21 = row_ptr_end[ii1];
								for (ic1 = is11; ic1 <= is21; ic1++) {
									if (Amat[ic1].j != Amat[ic].j) {
										if (Amat[ic1].j == istr) {
											aji = Amat[ic1].aij;
										}
									}
								}
								break;
							}
						//}
						mult += (Amat[ic].aij*aji) / diagonal[Amat[ic].j];
					}
				}
			}
			ap = 1.0 / Amat[is1 - 1].aij;
			diagonal[istr] = ap - mult;
		}
	}

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	 startpos = istartq + iadd;
	 endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		doublerealT rold = x[istr];

		x[istr] = b[istr];

		doublerealT rsum = 0.0;
		integer is1 = row_ptr_start[ii] + 1;
		integer is2 = row_ptr_end[ii];
		// Распараллеливание почемуто тормозит очень сильно.
		//#pragma omp parallel for reduction(+:rsum)
		for (integer ii1 = is1; ii1 <= is2; ii1++)
		{
			//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
			integer ipos = Amat[ii1].j;
			rsum += -Amat[ii1].aij*x[ipos];
		}
		x[istr] += rsum;
		//x[istr] *= Amat[row_ptr_start[ii]].aij;
		// incomplete lower upwer decomposition.
		x[istr] /= diagonal[istr];

		// Запускается только после первого раза сразу запускать нельзя
		// т.к. начальное значение не является адекватным.
		//x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
	}

	delete[] diagonal;


} // early_naive_relaxation_method2

// smoother.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
// 9 июня 2016. 
// early_naive_relaxation_method2.
// Этот код (данная функция) больше не используется. Это одна из ранних
// наивных попыток написать метод релаксации.
template <typename doublerealT>
void early_naive_relaxation_method2(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);
	omega = 1.0;

	// это нужне сделать единожды на фазе препроцессинга.
	doublerealT* diagonal = nullptr;
	diagonal = new doublerealT[(integer)(rn)+1];
	if (diagonal == nullptr) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem: not enough memory on your equipment for diagonal in classical_ilu2...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	// initialization:
	for (integer i_6 = 0; i_6 < (integer)(rn)+1; i_6++) diagonal[i_6] = 1.0;
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		{
			integer istr = ii - iadd;
			integer ic = ii;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			doublerealT ap = 0.0;
			doublerealT mult = 0.0;
			for (ic = is1; ic <= is2; ic++) {
				if (Amat[ic].j != istr) {
					if (Amat[ic].j < istr) {
						// aij*aji/djj;
						// найти aji;
						doublerealT aji = 0.0;
						// линейный поиск очень медленный особенно на каждой итерации.
						//for (integer ii1 = startpos; ii1 <= endpos; ii1++) {
						integer ii1 = iadd + Amat[ic].j;
							if (Amat[ii1].i == Amat[ic].j) {
								integer ic1 = ii1;
								integer is11 = row_ptr_start[ii1] + 1;
								integer is21 = row_ptr_end[ii1];
								for (ic1 = is11; ic1 <= is21; ic1++) {
									if (Amat[ic1].j != Amat[ic].j) {
										if (Amat[ic1].j == istr) {
											aji = Amat[ic1].aij;
										}
									}
								}
								break;
							}
						//}
						mult += (Amat[ic].aij*aji) / diagonal[Amat[ic].j];
					}
				}
			}
			ap = 1.0 / Amat[is1 - 1].aij;
			diagonal[istr] = ap - mult;
		}
	}

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	startpos = istartq + iadd;
	endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		doublerealT rold = x[istr];

		x[istr] = b[istr];

		doublerealT rsum = 0.0;
		integer is1 = row_ptr_start[ii] + 1;
		integer is2 = row_ptr_end[ii];
		// Распараллеливание почемуто тормозит очень сильно.
		//#pragma omp parallel for reduction(+:rsum)
		for (integer ii1 = is1; ii1 <= is2; ii1++)
		{
			//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
			integer ipos = Amat[ii1].j;
			rsum += -Amat[ii1].aij*x[ipos];
		}
		x[istr] += rsum;
		//x[istr] *= Amat[row_ptr_start[ii]].aij;
		// incomplete lower upwer decomposition.
		x[istr] /= diagonal[istr];

		// Запускается только после первого раза сразу запускать нельзя
		// т.к. начальное значение не является адекватным.
		//x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
	}

	delete[] diagonal;

} // early_naive_relaxation_method2


  // smoother.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void seidelq(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	
	//seidelqstable(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);

	// SOR!!!
	// 3 jan 2016
	//seidelqsor(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// лучший выбор:
	seidelqsor2(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// 14 января 2016 смена направлений сканирования.
	// оказалось значительно хуже.
	//seidelqsor3(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// early_naive_relaxation_method2
	//early_naive_relaxation_method2(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);

	
} // seidelq



// smoother.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{

	//seidelqstable<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);

	// SOR!!!
	// 3 jan 2016
	//seidelqsor(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// лучший выбор
	seidelqsor2(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// 14 января 2016 смена направлений сканирования.
	// оказалось значительно хуже.
	//seidelqsor3(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	//seidelqsor2Pcpu(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// early_naive_relaxation_method2.
	//early_naive_relaxation_method2(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// Экспериментальный вариант слишком медленный:
    //bool* flag = new bool[iendq - istartq + 2];
	//early_naive_relaxation_method(Amat, istartq, iendq, x, b, flag, iendq - istartq + 1);
	//delete[] flag;

} // seidelq

// См. файл gmres.cpp
template <typename doublerealT>
integer  gmres(integer n, doublerealT *val, integer* col_ind, integer* row_ptr, doublerealT *dV, doublerealT* &dX0,
	integer maxit, integer &m_restart);
//integer  gmres(integer n, double *val, integer* col_ind, integer* row_ptr, double *dV, double* &dX0,
	//integer maxit, integer &m_restart);
//integer  gmres(integer n, float *val, integer* col_ind, integer* row_ptr, float *dV, float* &dX0,
	//integer maxit, integer &m_restart);
//my_linalg.cpp
void Bi_CGStabCRS_smoother(integer n, doublereal *val, integer* col_ind, integer* row_ptr, doublereal *dV, doublereal* &dX0, integer maxit);

// 13.09.2017.
template <typename doublerealT>
void gmres_smoother(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b,
	integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	integer n = iendq - istartq + 1;

	// Разреженная матрица СЛАУ
	// в CRS формате.

	doublerealT* val;
	integer* col_ind, *row_ptr;
	doublerealT* dX0 = new doublerealT[n];
	doublerealT* dV = new doublerealT[n];

	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		dX0[ii - startpos] = x[istr];
		dV[ii - startpos] = b[istr];
	}

	integer nnz = row_ptr_end[endpos] - row_ptr_start[startpos] + 1;
	val = new doublerealT[nnz];
	col_ind = new integer[nnz];
	row_ptr = new integer[n + 1];
	for (integer i_1 = 0; i_1 <= n; i_1++) row_ptr[i_1] = nnz;

	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		integer is1 = row_ptr_start[ii];// +1;
		integer is2 = row_ptr_end[ii];


		// Распараллеливание почемуто тормозит очень сильно.
		//#pragma omp parallel for reduction(+:rsum)
		for (integer ii1 = is1; ii1 <= is2; ii1++)
		{
			///printf("is1=%d is2=%d\n",is1,is2);
			if (iadd > 20) {
				//printf("i==%d j==%d\n", Amat[ii1].i, Amat[ii1].j); getchar();
				
				//printf("%d \n", ii1 - row_ptr_start[startpos]);
				//getchar();
			}
			col_ind[ii1 - row_ptr_start[startpos]] = Amat[ii1].j - 1;
			val[ii1 - row_ptr_start[startpos]] = Amat[ii1].aij;
			if (Amat[ii1].j != Amat[ii1].i) {
				val[ii1 - row_ptr_start[startpos]] *= 1.0;
			}
			else {
				val[ii1 - row_ptr_start[startpos]] = (doublerealT)(1.0 / val[ii1 - row_ptr_start[startpos]]);
			}
			row_ptr[Amat[ii1].i - 1] = (row_ptr[Amat[ii1].i - 1] < ii1 - row_ptr_start[startpos] ? row_ptr[Amat[ii1].i - 1] : ii1 - row_ptr_start[startpos]);
		}
	}

	/*
	if (0&&(iadd < -40)) {
		// 14.07.2019 Эта ветка кода никогда не выполняется.
		if ((val != nullptr) && (col_ind != nullptr) && (row_ptr != nullptr)) {
			for (integer i_1 = 0; i_1 < nnz; i_1++) {
				// debug message
				printf("val=%e col_ind=%lld row_ptr=\n", val[i_1], col_ind[i_1]);
				system("PAUSE");
			}
			for (integer i_1 = 0; i_1 < 400; i_1++) {
				printf("%lld \n", row_ptr[i_1]);
			}
			//system("pause");
		}
		else {
			printf("val || col_ind || row_ptr == nullptr\n");
			printf("in function gmres smoother...\n");
			system("PAUSE");
		}
	}
	*/

	if (0) {
		// Матрица col_ind, row_ptr, val собрана верно!!! 14 сентября 2017.

		doublerealT omega = 1.0; // initialize.

		// За подробностями смотри книгу Патрика Роуча стр. 183.
		doublerealT rn = (doublerealT)(iendq - istartq + 1);
		optimal_omega(rn, omega);

		for (integer i_1 = 0; i_1 < n; i_1++) {
			doublerealT r = dV[i_1];
			doublerealT ap = 0.0;
			for (integer j_1 = row_ptr[i_1]; j_1 <= row_ptr[i_1 + 1] - 1; j_1++) {
				if (i_1 != col_ind[j_1]) {
					r += -val[j_1] * dX0[col_ind[j_1]];
					//printf("%e ",);
				}
				else {
					ap = val[j_1];
				}
			}
			dX0[i_1] = (doublerealT)((1.0 - omega)*dX0[i_1] + ((omega)*(r)) / ap);
		}
	}


	// Методы GMRES и BiCGStab расходятся в качестве сглаживателей и 
	// не обеспечивают не то что сглаживания а даже дают расходимость.
	// GMRES Саад и Шульц. [1986]
	integer maxit = 20;
	integer m_restart = 20; // Так рекомендовано в статье.
	gmres(n, val, col_ind, row_ptr, dV, dX0, maxit, m_restart);
	//Bi_CGStabCRS_smoother(n, val, col_ind, row_ptr, dV, dX0, maxit);


	// Возвращение результата расчёта.
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		 x[istr]= dX0[ii - startpos];
	}

	delete[] dX0;
	delete[] dV;
	delete[] val;
	delete[] col_ind;
	delete[] row_ptr;
}


  // smoother.
  // 9 september 2015 and 4 june 2017.
  // q - quick.
template <typename doublerealT>
void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, bool* &F_false_C_true, integer idirect)
{	
	if (my_amg_manager.b_gmres) {
		// gmres smoother
		gmres_smoother<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	}
	else {
		// лучший выбор
		if (my_amg_manager.bCFJacoby  ) {
			if ((my_amg_manager.iRunge_Kutta_smoother == 3) || (my_amg_manager.iRunge_Kutta_smoother == 5)) {
				// Трёхшаговый метод Рунге-Кутты.
				integer iorder = my_amg_manager.iRunge_Kutta_smoother;
				Runge_Kutt_3or5<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd, iorder, F_false_C_true, idirect);
			}
			else {

				seidelqsor2<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd, F_false_C_true, idirect);
			}
		}
		else {
			if ((my_amg_manager.iRunge_Kutta_smoother == 3) || (my_amg_manager.iRunge_Kutta_smoother == 5)) {
				// Трёхшаговый метод Рунге-Кутты.
				integer iorder = my_amg_manager.iRunge_Kutta_smoother;
				Runge_Kutt_3or5<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd, iorder);
			}
			else {

				seidelqsor2<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
			}

		}
	}

} // seidelq


// smoother.
// 16 jan 2016.  Seidel q -quick SOR + parallel
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, bool* &bnested_desection, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
{
	seidelqsor2Pcpu<doublerealT>(Amat, istartq, iendq, x, b, bnested_desection,  row_ptr_start, row_ptr_end, iadd);
	//seidelqsor2Pcpu(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);

} // seidelq

  // smoother.
  // 16 jan 2016.  Seidel q -quick SOR + parallel
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, bool* &bnested_desection, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, bool* &F_false_C_true, integer idirect)
{
	// , bool* &F_false_C_true, integer idirect Заглушка, параметры не используются.
	// Внимание обратная совместимость.

	seidelqsor2Pcpu<doublerealT>(Amat, istartq, iendq, x, b, bnested_desection, row_ptr_start, row_ptr_end, iadd);
	//seidelqsor2Pcpu<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);

} // seidelq


  /*
  // smoother.
  // 9 september 2015.
  // q - quick.
  // Якоби расходится.
  template <typename doublerealT>
  void seidelq(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
  {
  // istart - начальная позиция ненулевых элементов в матрице А.
  // iend - конечная позиция ненулевых элементов в матрице А.
  integer startpos = istartq + iadd;
  integer endpos = iendq + iadd;

  //doublerealT *sum=new doublerealT[endpos-startpos+1];

  #pragma omp parallel for
  for (integer ii = startpos; ii <= endpos; ii++) {
  integer istr = ii - iadd;
  x[istr] = b[istr];
  //	doublerealT sum = 0.0;
  //#pragma omp parallel for reduction(+:sum)
  for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
  {
  x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
  //sum = sum - Amat[ii1].aij*x[Amat[ii1].j];
  }
  //x[istr] += sum;
  x[istr] *= Amat[row_ptr_start[ii]].aij;
  }


  //for (integer ii = startpos; ii <= endpos; ii++) {
  //	integer istr = ii - iadd;
  //	x[istr] = sum[istr]*Amat[row_ptr_start[ii]].aij;
  //}


  //delete[] sum;
  } // seidelq
  */


  // residual.
  // 2 september 2014
template <typename doublerealT>
void residual(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n, doublerealT* &residual)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
		residual[i] = 0.0;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			residual[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr)  residual[istr] += -Amat[ic].aij*x[Amat[ic].j];
				else residual[istr] += -Amat[ic].aij*x[istr];
				ic++;
			}
			flag[Amat[ii].i] = true;
		}
	}


} // residual

// residual.
// 2 september 2014
template <typename doublerealT>
void residual(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n, doublerealT* &residual)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
		residual[i] = 0.0;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			residual[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr)  residual[istr] += -Amat[ic].aij*x[Amat[ic].j];
				else residual[istr] += -Amat[ic].aij*x[istr];
				ic++;
			}
			flag[Amat[ii].i] = true;
		}
	}


} // residual

  // residual.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void residualq(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, doublerealT* &residual)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) { residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; }
		residual[istr] += (-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr];
	}


} // residualq

// residual.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void residualq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, doublerealT* &residual)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) { residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; }
		residual[istr] += (-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr];
	}


} // residualq

  // residual.
// 3 jan 2016 ещё быстрее.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void residualq2(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, doublerealT* &residual, doublerealT* &my_diag)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) { residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; }
		//residual[istr] += (-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr];
		//residual[istr] -= my_diag[Amat[row_ptr_start[ii]].i] * x[istr]; // 3 jan 2016
		residual[istr] -= my_diag[istr] * x[istr]; // 3 feb 2019
	}


} // residualq2

// Эквивалентный клон функции 13.01.2018
template <typename doublerealT>
void residualq2(Ak* &Amat, integer istartq, integer iendq, doublereal* &x, doublereal* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, doublerealT* &residual, doublerealT* &my_diag)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) { residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; }
		//residual[istr] += (-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr];
		//residual[istr] -= my_diag[Amat[row_ptr_start[ii]].i] * x[istr]; // 3 jan 2016
		residual[istr] -= my_diag[istr] * x[istr]; // 3 feb 2019
	}


} // residualq2

// residual.
// 3 jan 2016 ещё быстрее.
// 9 september 2015.
// q - quick.
template <typename doublerealT1, typename doublerealT2>
void residualq2(Ak1* &Amat, integer istartq, integer iendq, doublerealT1* &x, doublerealT1* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, doublerealT2* &residual, doublerealT2* &my_diag)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	doublerealT2 dsum = 0.0;

#pragma omp parallel for 
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = (doublerealT2)(b[istr]);
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) {
			if (1||(Amat[ii1].aij < 0.0)) {
				residual[istr] += (doublerealT2)(-Amat[ii1].aij*x[Amat[ii1].j]);
			}
			else {
				// 16 августа 2016.
				// не работает.
				//dsum += Amat[ii1].aij;
			}
		}
		residual[istr] -= (doublerealT2)((1.0 / Amat[row_ptr_start[ii]].aij)*x[istr]);  // 1 april 2017
		//residual[istr] -= (my_diag[Amat[row_ptr_start[ii]].i] + dsum)* x[istr]; // 3 jan 2016
	}


} // residualq2

 


  // residual.
// Анализ структуры невязки в случае проблемы с солвером.
  // 3 jan 2016 ещё быстрее.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT1, typename doublerealT2>
void residualq2_analysys(Ak1* &Amat, integer istartq, integer iendq, doublerealT1* &x, doublerealT1* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, doublerealT2* &residual, doublerealT2* &my_diag)
{
	// Анализ структуры невязки.
	// Мы делим вектор невязки на 20 равных частей и смотрим где невязка наиболее велика.



	printf("residual2 analysys start:\n");
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	doublerealT2 dsum = 0.0;
	doublerealT2 statistics_sum = 0.0;
	integer icount_log = 1;
	integer i_srez = (endpos-startpos)/20;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = (doublerealT2)(b[istr]);
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) {
			if (1 || (Amat[ii1].aij < 0.0)) {
				residual[istr] += (doublerealT2)(-Amat[ii1].aij*x[Amat[ii1].j]);
			}
			else {
				// 16 августа 2016.
				// не работает.
				//dsum += Amat[ii1].aij;
			}
		}
		//residual[istr] += (-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr];
		residual[istr] -= (doublerealT2)((my_diag[Amat[row_ptr_start[ii]].i] + dsum)* x[istr]); // 3 jan 2016
		statistics_sum += fabs(residual[istr]);
		if ((ii-startpos+1) % i_srez == 0) {
#if doubleintprecision == 1
			printf("%lld %e ", icount_log++, statistics_sum);
#else
			printf("%d %e ", icount_log++, statistics_sum);
#endif
			
			statistics_sum = 0.0;
		}
	}
	printf("\n");

} // residualq2_analysys

 


  // smoother.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void residualqspeshial(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, doublerealT* &residual)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) { residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; }
		//residual[istr] -=  Amat[row_ptr_start[ii]].aij*x[istr];
		// 2.0 2.441 2.543 2.546
		//residual[istr] -= 2.0*Amat[row_ptr_start[ii]].aij*x[istr];
		//doublerealT omega = 1.855; // SOR
		//residual[istr] += ((-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr]); // верный вариант.
		residual[istr] += ((-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr]) / 16.0;
		//residual[istr] *= omega;
		// 2.423
		// 1.855 4.448
		// 1.0  5.074
		// 8.713 5.706
	}


} // residualqspeshial

// smoother.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void residualqspeshial(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, doublerealT* &residual)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) { residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; }
		//residual[istr] -=  Amat[row_ptr_start[ii]].aij*x[istr];
		// 2.0 2.441 2.543 2.546
		//residual[istr] -= 2.0*Amat[row_ptr_start[ii]].aij*x[istr];
		//doublerealT omega = 1.855; // SOR
		//residual[istr] += ((-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr]); // верный вариант.
		residual[istr] += ((-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr]) / 16.0;
		//residual[istr] *= omega;
		// 2.423
		// 1.855 4.448
		// 1.0  5.074
		// 8.713 5.706
	}


} // residualqspeshial


typedef struct TQuickProlongation {

	doublereal** tmp;
	integer** tmp_i;
	bool* hash;
	integer* tmp_i_ic;

} QuickProlongation;


QuickProlongation my_quick_prolongation;

void initQuickProlongation(integer isize) {

	const int tid_max = number_cores();


	my_quick_prolongation.tmp = new doublereal * [tid_max];
	for (integer tid = 0; tid < tid_max; ++tid) {
		my_quick_prolongation.tmp[tid] = new doublereal[isize + 1];
	}

	my_quick_prolongation.tmp_i_ic = new integer[tid_max];

	my_quick_prolongation.tmp_i = new integer * [tid_max];
	for (integer tid = 0; tid < tid_max; ++tid) {
		my_quick_prolongation.tmp_i[tid] = new integer[isize + 1];
		my_quick_prolongation.tmp_i_ic[tid] = 0;
	}

#pragma omp parallel for
	for (integer tid = 0; tid < tid_max; ++tid) {
		for (integer i = 1; i <= isize; ++i) {
			my_quick_prolongation.tmp[tid][i] = 0.0;
			my_quick_prolongation.tmp_i[tid][i] = -1;// позиция несуществует
		}
	}

	my_quick_prolongation.hash = new bool[isize + 1];

#pragma omp parallel for
	for (integer i = 1; i <= isize; ++i) {
		my_quick_prolongation.hash[i] = false;
	}



}


void freeQuickProlongation() {

	const int tid_max = number_cores();

	for (integer i = 0; i < tid_max; i++) {
		delete[]	my_quick_prolongation.tmp[i];
		delete[]	my_quick_prolongation.tmp_i[i];
	}

	delete[]	my_quick_prolongation.tmp;
	delete[]	my_quick_prolongation.tmp_i;
	delete[] my_quick_prolongation.tmp_i_ic;
	delete[] my_quick_prolongation.hash;
}


  // restriction
  // 3 september 2015.
  // 6 september 2015.
  // 31.07.2021 Распараллеливание по OpenMP.Версия устарела.
  // должна быть отсортирована по i, порядок по j неважен.
template <typename doublerealT>
void restriction(Ak* &R, integer istart, integer iend, bool* &flag, doublerealT* &x_fine, doublerealT* &x_coarse, integer n_fine, integer n_coarse) {
	// x_coarse[1..n_coarse]=R n_coarse x n_fine*x_fine[1..n_fine];

	const int tid_max = number_cores();

	if (tid_max == 1) {



		for (integer i = 1; i <= n_coarse; i++) {
			flag[i] = false;
			x_coarse[i] = 0.0;
		}

		for (integer ii = istart; ii <= iend; ii++) {
			if (flag[R[ii].i] == false) {
				integer istr = R[ii].i;
				integer ic = ii;
				
				while ((ic <= iend) && (R[ic].i == istr)) {
					x_coarse[istr] += R[ic].aij * x_fine[R[ic].j];
					ic++;
				}
				flag[R[ii].i] = true;
			}
		}

	}
	else {


		// Паралельный restriction на OpenMP: 31.07.2021.

#ifdef _OPENMP
		omp_set_num_threads(tid_max); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#endif

#pragma omp parallel for
		for (integer i = 1; i <= n_coarse; ++i) {
			flag[i] = false;
			x_coarse[i] = 0.0;
		}

		doublerealT** tmp = new doublerealT * [tid_max];
		for (integer tid = 0; tid < tid_max; ++tid) {
			tmp[tid] = new doublerealT[n_coarse + 1];
		}

#pragma omp parallel for
		for (integer tid = 0; tid < tid_max; ++tid) {
			for (integer i = 1; i <= n_coarse; ++i) {
				tmp[tid][i] = 0.0;
			}
		}

#pragma omp parallel for
		for (integer ii = istart; ii <= iend; ii++) {

			int tid = omp_get_thread_num();

			if (flag[R[ii].i] == false) {
#pragma omp critical
				{
					integer istr = R[ii].i;
					integer ic = ii;

					while ((ic <= iend) && (R[ic].i == istr)) {
						tmp[tid][istr] += R[ic].aij * x_fine[R[ic].j];
						ic++;
					}


					flag[R[ii].i] = true;
				}
			}
		}

#pragma omp parallel for
		for (integer i = 1; i <= n_coarse; ++i) {
			for (integer tid = 0; tid < tid_max; ++tid) {
				x_coarse[i] += tmp[tid][i];
			}
		}

		for (integer i = 0; i < tid_max; i++) {
			delete[]	tmp[i];
		}

		delete[]	tmp;

	}

} // restriction

// restriction
// 3 september 2015.
// 6 september 2015.
// 31.07.2021 Распараллеливание по OpenMP.Версия устарела.
// должна быть отсортирована по i, порядок по j неважен.
template <typename doublerealT>
void restriction(Ak1* &R, integer istart, integer iend, bool* &flag, doublerealT* &x_fine,
	doublerealT* &x_coarse, integer n_fine, integer n_coarse) {
	// x_coarse[1..n_coarse]=R n_coarse x n_fine*x_fine[1..n_fine];

	const int tid_max = number_cores();

	if (tid_max == 1) {

		for (integer i = 1; i <= n_coarse; i++) {
			flag[i] = false;
			x_coarse[i] = 0.0;
		}
		
		for (integer ii = istart; ii <= iend; ii++) {
			if (flag[R[ii].i] == false) {
				integer istr = R[ii].i;
				integer ic = ii;
				
				while ((ic <= iend) && (R[ic].i == istr)) {
					x_coarse[istr] += R[ic].aij * x_fine[R[ic].j];
					ic++;
				}

				flag[R[ii].i] = true;
			}
		}
	}
	else {


		// Паралельный restriction на OpenMP: 31.07.2021.

#ifdef _OPENMP
		omp_set_num_threads(tid_max); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#endif

#pragma omp parallel for
		for (integer i = 1; i <= n_coarse; ++i) {
			flag[i] = false;
			x_coarse[i] = 0.0;
		}

		doublerealT** tmp = new doublerealT * [tid_max];
		for (integer tid = 0; tid < tid_max; ++tid) {
			tmp[tid] = new doublerealT[n_coarse + 1];
		}

#pragma omp parallel for
		for (integer tid = 0; tid < tid_max; ++tid) {
			for (integer i = 1; i <= n_coarse; ++i) {
				tmp[tid][i] = 0.0;
			}
		}


#pragma omp parallel for
		for (integer ii = istart; ii <= iend; ii++) {

			int tid = omp_get_thread_num();

			if (flag[R[ii].i] == false) {

#pragma omp critical
				{

					integer istr = R[ii].i;
					integer ic = ii;

					while ((ic <= iend) && (R[ic].i == istr)) {
						tmp[tid][istr] += R[ic].aij * x_fine[R[ic].j];
						ic++;
					}

					flag[R[ii].i] = true;
				}
			}
		}

#pragma omp parallel for
		for (integer i = 1; i <= n_coarse; ++i) {
			for (integer tid = 0; tid < tid_max; ++tid) {
				x_coarse[i] += tmp[tid][i];
			}
		}

		for (integer i = 0; i < tid_max; i++) {
			delete[]	tmp[i];
		}

		delete[]	tmp;

	}

} // restriction


// restriction
// 3 september 2015.
// 6 september 2015.
// 10 february 2019 - нашел более компактную форму записи.
// 31.07.2021 Распараллеливание по OpenMP. Рабочая версия.
// должна быть отсортирована по i, порядок по j неважен.
template <typename doublerealT>
void restriction(Ak1*& R, integer istart, integer iend, doublerealT*& x_fine, doublerealT*& x_coarse, integer n_coarse) {
	// x_coarse[1..n_coarse]=R n_coarse x n_fine*x_fine[1..n_fine];

	const int tid_max = number_cores();

	if (true||(tid_max == 1)) {

		
#pragma omp parallel for
		for (integer i = 1; i <= n_coarse; i++) {
			x_coarse[i] = 0.0;
		}
		
		for (integer ii = istart; ii <= iend; ii++) {
			x_coarse[R[ii].i] += R[ii].aij * x_fine[R[ii].j];
		}
	}
	else {

		// Паралельный restriction на OpenMP: 31.07.2021.

#ifdef _OPENMP
		omp_set_num_threads(number_cores()); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#endif

		/*
		* 100% рабочий, но очень медленный вариант.
#pragma omp parallel for
		for (integer i = 1; i <= n_coarse; i++) {
			x_coarse[i] = 0.0;
		}


		doublerealT** tmp = new doublerealT * [tid_max];
		for (integer tid = 0; tid < tid_max; ++tid) {
			tmp[tid] = new doublerealT[n_coarse + 1];			
		}

#pragma omp parallel for
		for (integer tid = 0; tid < tid_max; ++tid) {
			for (integer i = 1; i <= n_coarse; ++i) {
				tmp[tid][i] = 0.0;
			}
		}

#pragma omp parallel for
		for (integer ii = istart; ii <= iend; ii++) {
			//x_coarse[R[ii].i] += R[ii].aij * x_fine[R[ii].j];
			int tid= omp_get_thread_num();
			tmp[tid][R[ii].i] += R[ii].aij * x_fine[R[ii].j];
		}

#pragma omp parallel for
		for (integer i = 1; i <= n_coarse; ++i) {
			for (integer tid = 0; tid < tid_max; ++tid) {
				x_coarse[i] += tmp[tid][i];
			}
		}

		for (integer i = 0; i < tid_max; i++) {
			delete[]	tmp[i];
		}

		delete[]	tmp;*/

#pragma omp parallel for
		for (integer j = 1; j <= n_coarse; ++j) {
			x_coarse[j] = 0.0;
		}


#pragma omp parallel for 
		for (integer ii = istart; ii <= iend; ++ii) {
			int tid = omp_get_thread_num();
			my_quick_prolongation.tmp[tid][R[ii].i] += R[ii].aij * x_fine[R[ii].j];
			my_quick_prolongation.tmp_i[tid][my_quick_prolongation.tmp_i_ic[tid]] = R[ii].i;
			++my_quick_prolongation.tmp_i_ic[tid];
		}

		// Ресурсоемкое умножение мы выполнили паралельно, а здесь просто однопоточное копирование.
//#pragma omp parallel for
		for (integer tid = 0; tid < tid_max; ++tid) {
			integer ic_tid_pos = 0;
			while (my_quick_prolongation.tmp_i[tid][ic_tid_pos] != -1) {
				if (my_quick_prolongation.hash[my_quick_prolongation.tmp_i[tid][ic_tid_pos]] == false) {
					x_coarse[my_quick_prolongation.tmp_i[tid][ic_tid_pos]] += my_quick_prolongation.tmp[tid][my_quick_prolongation.tmp_i[tid][ic_tid_pos]];
					my_quick_prolongation.hash[my_quick_prolongation.tmp_i[tid][ic_tid_pos]] = true;
				}
				++ic_tid_pos;
			}
			ic_tid_pos = 0;
			while (my_quick_prolongation.tmp_i[tid][ic_tid_pos] != -1) {
				my_quick_prolongation.hash[my_quick_prolongation.tmp_i[tid][ic_tid_pos]] = false;
				my_quick_prolongation.tmp[tid][my_quick_prolongation.tmp_i[tid][ic_tid_pos]] = 0.0;
				my_quick_prolongation.tmp_i[tid][ic_tid_pos] = -1;
				++ic_tid_pos;
			}
		}

#pragma omp parallel for
		for (integer tid = 0; tid < tid_max; ++tid) {
			my_quick_prolongation.tmp_i_ic[tid] = 0;
		}

	}
} // restriction


  // prolongation
  // 3 september 2015.
  // 6 september 2015.
  // 31.07.2021 Распараллеливание по OpenMP. Версия устарела.
  // должна быть отсортирована по j, порядок по i неважен.
  // P=transpose(R).
template <typename doublerealT>
void prolongation(Ak* &P, integer istart, integer iend, bool* &flag, doublerealT* &x_fine, doublerealT* &x_coarse, integer n_fine, integer n_coarse) {
	// x_fine[1..n_fine]=P n_fine x n_coarse*x_coarse[1..n_coarse];
	// P=c*transpose(R); Pij=c*Rji;

	const int tid_max = number_cores();

	if (tid_max == 1) {


		for (integer j = 1; j <= n_fine; j++) {
			flag[j] = false;
			x_fine[j] = 0.0;
		}
		for (integer ii = istart; ii <= iend; ii++) {
			if (flag[P[ii].j] == false) {
				integer jstr = P[ii].j;
				integer ic = ii;
				
				while ((ic <= iend) && (P[ic].j == jstr)) {
					x_fine[jstr] += P[ic].aij * x_coarse[P[ic].i];
					ic++;
				}

				flag[P[ii].j] = true;
			}
		}

	}
	else {

		// Паралельный restriction на OpenMP: 31.07.2021.

#ifdef _OPENMP
		omp_set_num_threads(tid_max); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#endif

#pragma omp parallel for
		for (integer j = 1; j <= n_fine; j++) {
			flag[j] = false;
			x_fine[j] = 0.0;
		}

		doublerealT** tmp = new doublerealT * [tid_max];
		for (integer tid = 0; tid < tid_max; ++tid) {
			tmp[tid] = new doublerealT[n_fine + 1];
		}

#pragma omp parallel for
		for (integer tid = 0; tid < tid_max; ++tid) {
			for (integer i = 1; i <= n_fine; ++i) {
				tmp[tid][i] = 0.0;
			}
		}


#pragma omp parallel for
		for (integer ii = istart; ii <= iend; ii++) {

			int tid = omp_get_thread_num();

			if (flag[P[ii].j] == false) {

#pragma omp critical
				{

					integer jstr = P[ii].j;
					integer ic = ii;

					while ((ic <= iend) && (P[ic].j == jstr)) {
						tmp[tid][jstr] += P[ic].aij * x_coarse[P[ic].i];
						ic++;
					}

					flag[P[ii].j] = true;

				}

			}
		}

#pragma omp parallel for
		for (integer i = 1; i <= n_fine; ++i) {
			for (integer tid = 0; tid < tid_max; ++tid) {
				x_fine[i] += tmp[tid][i];
			}
		}

		for (integer i = 0; i < tid_max; i++) {
			delete[]	tmp[i];
		}

		delete[]	tmp;

	}

} // prolongation

// prolongation
// 3 september 2015.
// 6 september 2015.
// 31.07.2021 Распараллеливание по OpenMP. Версия устарела.
// должна быть отсортирована по j, порядок по i неважен.
// P=transpose(R).
template <typename doublerealT>
void prolongation(Ak1* &P, integer istart, integer iend, bool* &flag, doublerealT* &x_fine, doublerealT* &x_coarse, integer n_fine, integer n_coarse) {
	// x_fine[1..n_fine]=P n_fine x n_coarse*x_coarse[1..n_coarse];
	// P=c*transpose(R); Pij=c*Rji;

	const int tid_max = number_cores();

	if (tid_max == 1) {

		for (integer j = 1; j <= n_fine; j++) {
			flag[j] = false;
			x_fine[j] = 0.0;
		}
		
		for (integer ii = istart; ii <= iend; ii++) {
			if (flag[P[ii].j] == false) {
				integer jstr = P[ii].j;
				integer ic = ii;
				
				while ((ic <= iend) && (P[ic].j == jstr)) {
					x_fine[jstr] += P[ic].aij * x_coarse[P[ic].i];
					ic++;
				}

				flag[P[ii].j] = true;
			}
		}

	}
	else {

		// Паралельный restriction на OpenMP: 31.07.2021.

#ifdef _OPENMP
		omp_set_num_threads(tid_max); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#endif

#pragma omp parallel for
		for (integer j = 1; j <= n_fine; j++) {
			flag[j] = false;
			x_fine[j] = 0.0;
		}

		doublerealT** tmp = new doublerealT * [tid_max];
		for (integer tid = 0; tid < tid_max; ++tid) {
			tmp[tid] = new doublerealT[n_fine + 1];
		}

#pragma omp parallel for
		for (integer tid = 0; tid < tid_max; ++tid) {
			for (integer i = 1; i <= n_fine; ++i) {
				tmp[tid][i] = 0.0;
			}
		}

#pragma omp parallel for
		for (integer ii = istart; ii <= iend; ii++) {

			int tid = omp_get_thread_num();

			if (flag[P[ii].j] == false) {

#pragma omp critical
				{

					integer jstr = P[ii].j;
					integer ic = ii;

					while ((ic <= iend) && (P[ic].j == jstr)) {
						tmp[tid][jstr] += P[ic].aij * x_coarse[P[ic].i];
						ic++;
					}

					flag[P[ii].j] = true;

				}

			}
		}


#pragma omp parallel for
		for (integer i = 1; i <= n_fine; ++i) {
			for (integer tid = 0; tid < tid_max; ++tid) {
				x_fine[i] += tmp[tid][i];
			}
		}

		for (integer i = 0; i < tid_max; i++) {
			delete[]	tmp[i];
		}

		delete[]	tmp;

	}




} // prolongation

// prolongation
// 3 september 2015.
// 6 september 2015.
// 31.07.2021 Распараллеливание по OpenMP.Рабочая версия.
// должна быть отсортирована по j, порядок по i неважен.
// P=transpose(R).
template <typename doublerealT>
void prolongation(Ak1* &P, integer istart, integer iend, doublerealT* &x_fine, doublerealT* &x_coarse, integer n_fine) {
	// x_fine[1..n_fine]=P n_fine x n_coarse*x_coarse[1..n_coarse];
	// P=c*transpose(R); Pij=c*Rji;

	const int tid_max = number_cores();

	if (true||(tid_max == 1)) {

#pragma omp parallel for
		for (integer j = 1; j <= n_fine; ++j) {
			x_fine[j] = 0.0;
		}
		
		for (integer ii = istart; ii <= iend; ++ii) {
			x_fine[P[ii].j] += P[ii].aij * x_coarse[P[ii].i];
		}

	}
	else {

		// Паралельный restriction на OpenMP: 31.07.2021.

#ifdef _OPENMP
		omp_set_num_threads(number_cores()); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#endif
	
		/*
		* 100% рабочий, но очень медленный вариант.
#pragma omp parallel for
		for (integer j = 1; j <= n_fine; ++j) {
			x_fine[j] = 0.0;
		}

		
		doublerealT** tmp = new doublerealT * [tid_max];
		for (integer tid = 0; tid < tid_max; ++tid) {
			tmp[tid] = new doublerealT[n_fine + 1];
		}

#pragma omp parallel for
		for (integer tid = 0; tid < tid_max; ++tid) {
			for (integer i = 1; i <= n_fine; ++i) {
				tmp[tid][i] = 0.0;
			}
		}

#pragma omp parallel for
		for (integer ii = istart; ii <= iend; ++ii) {
			int tid = omp_get_thread_num();
			tmp[tid][P[ii].j] += P[ii].aij * x_coarse[P[ii].i];
		}

#pragma omp parallel for
		for (integer i = 1; i <= n_fine; ++i) {
			for (integer tid = 0; tid < tid_max; ++tid) {
				x_fine[i] += tmp[tid][i];
			}
		}

		for (integer i = 0; i < tid_max; i++) {
			delete[]	tmp[i];
		}

		delete[]	tmp;
		*/

#pragma omp parallel for
		for (integer j = 1; j <= n_fine; ++j) {
			x_fine[j] = 0.0;
		}
		

#pragma omp parallel for 
		for (integer ii = istart; ii <= iend; ++ii) {
			int tid = omp_get_thread_num();
			my_quick_prolongation.tmp[tid][P[ii].j] += P[ii].aij * x_coarse[P[ii].i];
			my_quick_prolongation.tmp_i[tid][my_quick_prolongation.tmp_i_ic[tid]] = P[ii].j;
			++my_quick_prolongation.tmp_i_ic[tid];
		}

/*#pragma omp parallel for
		for (integer i = 1; i <= n_fine; ++i) {
			for (integer tid = 0; tid < tid_max; ++tid) {
				x_fine[i] += tmp[tid][i];
			}
		}*/



		

		// Ресурсоемкое умножение мы выполнили паралельно, а здесь просто однопоточное копирование.
//#pragma omp parallel for
		for (integer tid = 0; tid < tid_max; ++tid) {
			integer ic_tid_pos = 0;
			while (my_quick_prolongation.tmp_i[tid][ic_tid_pos] != -1) {
				if (my_quick_prolongation.hash[my_quick_prolongation.tmp_i[tid][ic_tid_pos]] == false) {
					x_fine[my_quick_prolongation.tmp_i[tid][ic_tid_pos]] += my_quick_prolongation.tmp[tid][my_quick_prolongation.tmp_i[tid][ic_tid_pos]];
					my_quick_prolongation.hash[my_quick_prolongation.tmp_i[tid][ic_tid_pos]] = true;
				}
				++ic_tid_pos;
			}
			ic_tid_pos = 0;
			while (my_quick_prolongation.tmp_i[tid][ic_tid_pos] != -1) {
				my_quick_prolongation.hash[my_quick_prolongation.tmp_i[tid][ic_tid_pos]] = false;
				my_quick_prolongation.tmp[tid][my_quick_prolongation.tmp_i[tid][ic_tid_pos]] = 0.0;
				my_quick_prolongation.tmp_i[tid][ic_tid_pos] = -1;
				++ic_tid_pos;
			}
		}

#pragma omp parallel for
		for (integer tid = 0; tid < tid_max; ++tid) {
			my_quick_prolongation.tmp_i_ic[tid] = 0;
		}

		/*
		* 
		* Так не работает, ни в коем случае не раскоментировать 
		* данный код. Это пример того как делать ненадо.
#pragma omp parallel for
		for (integer j = 1; j <= n_fine; ++j) {
			x_fine[j] = 0.0;
		}

		doublerealT*  tmp = new doublerealT[n_fine + 1];

#pragma omp parallel private(tmp) shared(x_fine) 
		{

			for (integer j = 1; j <= n_fine; ++j) {
				tmp[j] = 0.0;
			}

#pragma omp  for
			for (integer ii = istart; ii <= iend; ++ii) {

				tmp[P[ii].j] += P[ii].aij * x_coarse[P[ii].i];
			}


#pragma omp critical
			{
				for (integer j = 1; j <= n_fine; ++j) {
					x_fine[j] += tmp[j];
				}
			}
		}

		delete[] tmp;*/
	}

} // prolongation

// Evklid norma of vector r in size n.
template <typename doublerealT>
doublerealT norma(doublerealT* &r, integer n) {
	doublerealT ret = 0.0;

#pragma omp parallel for  /*schedule (guided)*/ reduction (+:ret)
	for (integer ii = 1; ii <= n; ii++) {
		//ret += r[ii] * r[ii] / n;
		// 13 февраля 2016 года.
		ret += r[ii] * r[ii]; // L2 norm (classical definition).
	}

#if doubleprecision == 1
		ret = sqrt(ret);
#else	
		ret = sqrtf(ret);
#endif

	return ret;
} // L2 norm

// экспорт полевой величины u в программу tecplot 360.
template <typename doublerealT>
void exporttecplot(doublerealT* u, integer n_size) {
	FILE* fp = nullptr;

#ifdef MINGW_COMPILLER
	int err = 0;
	fp = fopen64("fedorenko1.PLT", "w");
	if (fp == NULL) {
		err = 1;
    }
#else
	errno_t err = 0;
	err = fopen_s(&fp, "fedorenko1.PLT", "w");
#endif
	// создание файла для записи.
	if ((err) != 0) {
		printf("Create File Error\n");
	}
	else {
		if (fp != nullptr) {
#ifdef MINGW_COMPILLER
			// запись имён переменных
			fprintf(fp, "VARIABLES = x y u\n");
			fprintf(fp, "zone\n");
			integer m = (integer)(sqrt((double)(1.0*n_size)));
			integer n = m;
			doublerealT h = 1.0 / (m - 1);
#if doubleintprecision == 1
			fprintf(fp, "I=%lld, J=%lld, K=1, F=TOCHKA\n", m, n);
#else
			fprintf(fp, "I=%d, J=%d, K=1, F=TOCHKA\n", m, n);
#endif

			for (integer j = 0; j < n; j++) for (integer i = 0; i < m; i++)   fprintf(fp, "%e %e %e\n", i*h, j*h, u[i*m + j + 1]);

#else // MINGW_COMPILLER OFF
			// запись имён переменных
			fprintf_s(fp, "VARIABLES = x y u\n");
			fprintf_s(fp, "zone\n");
			integer m = (integer)(sqrt((double)(1.0*n_size)));
			integer n = m;
			doublerealT h = 1.0 / (m - 1);
#if doubleintprecision == 1
			fprintf_s(fp, "I=%lld, J=%lld, K=1, F=TOCHKA\n", m, n);
#else
			fprintf_s(fp, "I=%d, J=%d, K=1, F=TOCHKA\n", m, n);
#endif
			
			for (integer j = 0; j < n; j++) for (integer i = 0; i < m; i++)   fprintf_s(fp, "%e %e %e\n", i*h, j*h, u[i*m + j + 1]);
#endif		
			
			fclose(fp);
			//WinExec("C:\\Program Files\\Tecplot\\Tecplot 360 EX 2014 R1\\bin\\tec360.exe fedorenko1.PLT", SW_NORMAL);
			//WinExec("C:\\Program\ Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT", SW_NORMAL);
		}
		else {
			printf("Create File Error\n");
		}
	}

	system("PAUSE");

} // exporttecplot

  // Быстрая сортировка Ч. Хоара. Время n*log2(n).
void quickSort_set(integer* &ifrQ, integer left, integer right)
{
	integer i = left, j = right;
	integer tmp;
	integer pivot = ifrQ[(left + right) / 2];

	/* partition */
	while (i <= j) {
		while (ifrQ[i]<pivot)
			i++;
		while (ifrQ[j]>pivot)
			j--;
		if (i <= j) {
			tmp = ifrQ[i];
			ifrQ[i] = ifrQ[j];
			ifrQ[j] = tmp;
			i++;
			j--;
		}
	};

	/* recursion */
	if (left<j)
		quickSort_set(ifrQ, left, j);
	if (i<right)
		quickSort_set(ifrQ, i, right);


}

// Двоичный поиск.
// Массив Amat[0..n], по n включительно, отсортированный в порядке возрастания.
integer BinarySearch(integer* &Amat, integer key, integer n)
{
	integer left = 0, right = n, mid;
	while (left <= right)
	{
		mid = left + (right - left) / 2;
		if (key<Amat[mid]) right = mid - 1;
		else if (key>Amat[mid]) left = mid + 1;
		else {
			// надо обязательно убедиться что mid самый левый представитель.
			while ((mid > 0) && (Amat[mid - 1] == Amat[mid])) {
				mid--;
			}
			return mid;
		}
	}
	return -1;
}


// Двоичный поиск.
integer BinarySearchAi(Ak* &Amat, integer key, integer istart, integer iend)
{
	integer left = istart, right = iend, mid;
	while (left <= right)
	{
		mid = left + (right - left) / 2;
		if (key<Amat[mid].i) right = mid - 1;
		else if (key>Amat[mid].i) left = mid + 1;
		else {
			// надо обязательно убедиться что mid самый левый представитель.
			while ((mid > istart) && (Amat[mid - 1].i == Amat[mid].i)) {
				mid--;
			}
			return mid;
		}
	}
	return -1;
}

// Двоичный поиск.
integer BinarySearchAi(Ak1* &Amat, integer key, integer istart, integer iend)
{
	integer left = istart, right = iend, mid;
	while (left <= right)
	{
		mid = left + (right - left) / 2;
		if (key<Amat[mid].i) right = mid - 1;
		else if (key>Amat[mid].i) left = mid + 1;
		else {
			// надо обязательно убедиться что mid самый левый представитель.
			while ((mid > istart) && (Amat[mid - 1].i == Amat[mid].i)) {
				mid--;
			}
			return mid;
		}
	}
	return -1;
}

// Двоичный поиск.
integer BinarySearchAj(Ak* &Amat, integer key, integer istart, integer iend)
{
	integer left = istart, right = iend, mid;
	while (left <= right)
	{
		mid = left + (right - left) / 2;
		if (key<Amat[mid].j) right = mid - 1;
		else if (key>Amat[mid].j) left = mid + 1;
		else {
			// надо обязательно убедиться что mid самый левый представитель.
			while ((mid > istart) && (Amat[mid - 1].j == Amat[mid].j)) {
				mid--;
			}
			return mid;
		};
	}
	return -1;
}

// Двоичный поиск.
integer BinarySearchAj(Ak1* &Amat, integer key, integer istart, integer iend)
{
	integer left = istart, right = iend, mid;
	while (left <= right)
	{
		mid = left + (right - left) / 2;
		if (key<Amat[mid].j) right = mid - 1;
		else if (key>Amat[mid].j) left = mid + 1;
		else {
			// надо обязательно убедиться что mid самый левый представитель.
			while ((mid > istart) && (Amat[mid - 1].j == Amat[mid].j)) {
				mid--;
			}
			return mid;
		};
	}
	return -1;
}

// 16 сентября 2015 года обнаружено что операции 
// сгрубления и интерполяции сделаны совершенно неверно,
// и если сгрубление еще в какой-то мере проецирует то интерполяция просто никакая.
// Операции сгрубления и интерполяции будут сделаны заново на основе статьи К.Н. Волкова в новой версии солвера.
// 3 september 2015 Villa Borgese.
template <typename doublerealT>
integer aggregative_amg(Ak* &Amat, integer nnz,
	integer n,
	Ak* &R, // restriction
	Ak* &P, // prolongation
	doublereal* &x, doublereal* &b) {

	// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
	bool bquicktypesort = false;


	// x_coarse[1..n_coarse]=R n_coarse x n_fine*x_fine[1..n_fine];
	// x_fine[1..n_fine]=P n_fine x n_coarse*x_coarse[1..n_coarse];

	// нумерация начинается с единицы.

	const integer maxlevel = 30;
	integer ilevel = 1;
	integer nnz_a[maxlevel];
	integer n_a[maxlevel];
	nnz_a[0] = nnz;
	n_a[0] = n;
	bool* flag = new bool[n + 1];
	bool* flag_ = new bool[n + 1];
	integer iadd = 0;
	integer nnzR = 1;
	integer iaddR = 0;
	integer nnz_aRP[maxlevel];
	bool bcontinue = true;

	while ((ilevel<maxlevel - 1) && (n_a[ilevel - 1] > 50) && (bcontinue)) {


		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		if (bquicktypesort) {
			QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
			if (nnz_a[ilevel - 1] < 100000) {
				HeapSort(Amat, /*n_a[ilevel - 1],*/ 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);
			}
			else {
				Ak* Aorig = &Amat[1 + iadd];
				MergeSort(Aorig, nnz_a[ilevel - 1], comparei);
				Aorig = nullptr;
			}
		}

		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
#if doubleintprecision == 1
			//	printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
#else
			//	printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
#endif
			
			//if (ii % 20 == 0) getchar();
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			Amat[ii].ind = ii - iadd;
		}



		// Copy(Amat) на nnz ячеек правее.
		for (integer ii = nnz_a[ilevel - 1] + 1 + iadd; ii <= 2 * nnz_a[ilevel - 1] + iadd; ii++) {
			Amat[ii] = Amat[ii - nnz_a[ilevel - 1]];
		}

		// сделаем копию А упорядочим её по j 
		for (integer k = 1 + iadd; k <= nnz_a[ilevel - 1] + iadd; k++) {
			Amat[k + 2 * nnz_a[ilevel - 1]] = Amat[k]; // copy
			Amat[k + 2 * nnz_a[ilevel - 1]].ind = k; // запоминаем номер до сортировки.
		}
		// сортировка по j.
		if (nnz_a[ilevel - 1] < 100000) {
			HeapSort(Amat,/* n_a[ilevel - 1]*/ 1 + iadd + 2 * nnz_a[ilevel - 1], nnz_a[ilevel - 1] + iadd + 2 * nnz_a[ilevel - 1], comparej);
		}
		else {
			Ak* Aorig = &Amat[1 + iadd + 2 * nnz_a[ilevel - 1]];
			MergeSort(Aorig, nnz_a[ilevel - 1], comparej);
			Aorig = nullptr;
		}


		integer n_coarce = 1; // номер агрегата.
		nnzR = 1;
		const integer max_neighbour = 27850;
		const integer NULL_NEIGHBOUR = -1;
		integer vacant = NULL_NEIGHBOUR;
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				// Вычисляем по немодифиуцированной матрице А (хранящейся слева).

				doublerealT sum = 0.0;
				integer nnzRl = nnzR + iaddR;

				integer set[max_neighbour]; // не более 20 узлов в одном агрегате.
										// инициализация убрана потомучто она не нужна и она сильно тормозит быстродействие.
										//for (integer js = 0; js < max_neighbour; js++) {
										//set[js] = NULL_NEIGHBOUR;
										//}
				integer ic = 0;
				set[ic] = Amat[ii].i;
				doublerealT theta = 0.25; // контроль числа сильных связей между переменными.
				doublerealT max_vnediagonal = -1.0; // максимальное значение модуля вне диагонального элемента. 
											 // добавляем диагональный элемент.
				for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
					if (Amat[is0].j == set[0]) {
						sum += fabs(Amat[is0].aij);
						R[nnzRl].aij = fabs(Amat[is0].aij);
						R[nnzRl].i = n_coarce; // индекс грубой сетки
						R[nnzRl].j = set[0]; //индекс на подробной сетке.
						nnzRl++;
						break;
					}
					else {
						if (fabs(Amat[is0].aij) > max_vnediagonal) {
							max_vnediagonal = fabs(Amat[is0].aij);
						}
					}
				}

				ic++;



				// если узел j ещё не был добавлен в агрегат.
				if (flag[Amat[ii].j] == false) {
					if ((Amat[ii].j != set[0]) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
						vacant = Amat[ii].j;
						for (integer js = 0; js < ic; js++) {
							if (vacant == set[js]) {
								vacant = NULL_NEIGHBOUR;
							}
						}
						if (vacant != NULL_NEIGHBOUR) {
							set[ic] = vacant;
							sum += fabs(Amat[ii].aij);
							R[nnzRl].aij = fabs(Amat[ii].aij);
							R[nnzRl].i = n_coarce;
							R[nnzRl].j = vacant;
							nnzRl++;
							ic++;
						}
					}
				}
				integer iscan = ii + 1;
				while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set[0])) {
					// если узел j ещё не был добавлен в агрегат.
					if (flag[Amat[iscan].j] == false) {
						if ((Amat[iscan].j != set[0]) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
							vacant = Amat[iscan].j;
							for (integer js = 0; js < ic; js++) {
								if (vacant == set[js]) {
									vacant = NULL_NEIGHBOUR;
								}
							}
							if (vacant != NULL_NEIGHBOUR) {
								set[ic] = vacant;
								sum += fabs(Amat[iscan].aij);
								R[nnzRl].aij = fabs(Amat[iscan].aij);
								R[nnzRl].i = n_coarce;
								R[nnzRl].j = vacant;
								nnzRl++;
								ic++;

							}
						}
					}

					iscan++;

				} // while

				  // R restriction.
				for (integer k1 = 0; k1 < ic; k1++) {
					R[nnzR + iaddR].aij /= sum;
					nnzR++;
				}


				//{
				//integer* Aset = new integer[ic];
				//for (integer ii3 = 0; ii3 < ic; ii3++) Aset[ii3] = set[ii3]; // copy
				// HeapSort(Aset,0,ic-1);
				//quickSort_set(Aset, 0, ic - 1);

				// bynarySearh 88.56%
				// aggregativeamg 8.89%
				// seidel 0.87%
				// (i,j) -> (I,J)
				// модифицируем копию Amat находящуюся справа.
				//for (integer k = nnz_a[ilevel - 1] + 1 + iadd; k <= 2 * nnz_a[ilevel - 1] + iadd; k++) {
				//bool found = false;

				//if (BinarySearch(Aset, Amat[k - nnz_a[ilevel - 1]].i, ic - 1) > -1) found = true;
				//for (integer k1 = 0; k1 < ic; k1++) {
				//	if (Amat[k - nnz_a[ilevel - 1]].i == set[k1]) found = true;
				//	}
				//if (found) Amat[k].i = n_coarce;
				//found = false;
				//if (BinarySearch(Aset, Amat[k - nnz_a[ilevel - 1]].j, ic - 1) > -1) found = true;

				//for (integer k1 = 0; k1 < ic; k1++) {
				//if (Amat[k - nnz_a[ilevel - 1]].j == set[k1]) found = true;
				//}

				//if (found) Amat[k].j = n_coarce;

				//}

				//delete[] Aset;
				//}


				{
					// 7 сентября 2015.
					// мы воспользовались тем что А упорядочена по i.
					for (integer k1 = 0; k1 < ic; k1++) {
						integer key = set[k1];
						integer ifound = BinarySearchAi(Amat, key, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						if (ifound > -1) {
							integer if1 = ifound;
							while ((if1 <= nnz_a[ilevel - 1] + iadd) && (Amat[if1].i == key)) {
								Amat[if1 + nnz_a[ilevel - 1]].i = n_coarce;
								if1++;
							}
							if1 = ifound - 1;
							while ((if1 >= 1 + iadd) && (Amat[if1].i == key)) {
								Amat[if1 + nnz_a[ilevel - 1]].i = n_coarce;
								if1--;
							}

						}
					}
					// копирование А на третью позицию и сортировка по j. Делается единожды в самом начале.
					// и сделаем тоже самое для j.
					// мы воспользовались тем что А упорядочена по j.
					for (integer k1 = 0; k1 < ic; k1++) {
						integer key = set[k1];
						integer ifound = BinarySearchAj(Amat, key, 1 + iadd + 2 * nnz_a[ilevel - 1], nnz_a[ilevel - 1] + iadd + 2 * nnz_a[ilevel - 1]);
						if (ifound > -1) {
							integer if1 = ifound;
							while ((if1 <= nnz_a[ilevel - 1] + iadd + 2 * nnz_a[ilevel - 1]) && (Amat[if1].j == key)) {
								Amat[Amat[if1].ind + nnz_a[ilevel - 1]].j = n_coarce;
								if1++;
							}
							if1 = ifound - 1;
							while ((if1 >= 1 + iadd + 2 * nnz_a[ilevel - 1]) && (Amat[if1].j == key)) {
								Amat[Amat[if1].ind + nnz_a[ilevel - 1]].j = n_coarce;
								if1--;
							}

						}
					}
					// Временная память в разделе 1 + iadd + 2 * nnz_a[ilevel - 1]..nnz_a[ilevel - 1] + iadd + 2 * nnz_a[ilevel - 1]
					// больше ненужна.

				}


				// Помечаем узлы как включённые в агрегат.
				for (integer js = 0; js < ic; js++) {
					flag[set[js]] = true;
				}

				n_coarce++;

				// Один агрегат создан.



			} // узел не был ещё включён в агрегат.
		} // агрегаты созданы.


		  // отладочная печать в рабочей версии требуется закомментировать.
		  //for (integer ii = 1; ii <= n; ii++) {
		  //flag_[ii] = false;
		  //}
		  //for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
		  //if (flag_[R[ii].i] == false) {
		  //integer istr = R[ii].i;
		  //integer ic7 = ii;
		  //while ((ic7 <= iaddR + nnzR - 1) && (R[ic7].i == istr)) {
		  //printf("%e ", R[ic7].aij);
		  //ic7++;
		  //}
		  //printf("\n");
		  //system("pause");
		  //flag_[R[ii].i] = true;
		  //}
		  //}


		  // оператор restriction построен и он упорядочен по i.
		  // число ненулевых элементов nnzR-1.
		  // P=Copy(R);
		for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
			P[ii] = R[ii];
#if doubleintprecision == 1
			//printf("ii=%lld aij=%e, i=%lld j=%lld\n",ii,P[ii].aij,P[ii].i,P[ii].j);
#else
			//printf("ii=%d aij=%e, i=%d j=%d\n",ii,P[ii].aij,P[ii].i,P[ii].j);
#endif
			
			//getchar();
		}

		// heapsort(P,key==j,iaddR+1,iaddR+nnzR - 1);
		if (bquicktypesort) {
			QuickSort(P, 1 + iaddR, iaddR + nnzR - 1, comparej);
		}
		else {
			HeapSort(P, /*n_a[ilevel-1]*/ 1 + iaddR, iaddR + nnzR - 1, comparej);
		}

		// оператор интерполяции это не просто транспонированный оператор проекции а
		// а транспонированный оператор проекции умноженный на константу. Константа 
		// определяется из следующего соображения: если сумма элементов оператора рестрикции в стоке единица,
		// то соответственно в столбце у оператора интерполяции максимальный элемент равен единица.
		// этот код обязательно должен быть включён чтобы пара рестрикция-интерполяция была верна.

		for (integer ii = 1; ii <= n; ii++) {
			flag_[ii] = false;
		}
		doublerealT mul = -1.e30;
		for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
			if (flag_[P[ii].j] == false) {
				integer jstr = P[ii].j;
				integer ic7 = ii;
				mul = -1.e30;
				while ((ic7 <= iaddR + nnzR - 1) && (P[ic7].j == jstr)) {
					if (fabs(P[ic7].aij) > mul) {
						mul = fabs(P[ic7].aij);
					}
					ic7++;
				}
				ic7 = ii;
				while ((ic7 <= iaddR + nnzR - 1) && (P[ic7].j == jstr)) {
					P[ic7].aij /= mul; // максимальный элемент единица.
					ic7++;
				}
				flag_[P[ii].j] = true;
			}
		}

		//for (integer ii = 1; ii <= n; ii++) {
		//flag_[ii] = false;
		//}
		//for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
		//if (flag_[P[ii].j] == false) {
		//integer jstr = P[ii].j;
		//integer ic7 = ii;
		//while ((ic7 <= iaddR + nnzR - 1) && (P[ic7].j == jstr)) {
		//printf("%e ",P[ic7].aij);
		//ic7++;
		//}
		//printf("\n");
		//system("pause");
		//flag_[P[ii].j] = true;
		//}
		//}




		nnz_aRP[ilevel - 1] = nnzR - 1;
		iaddR += nnzR - 1;

#if doubleintprecision == 1
		//printf("%lld %lld\n",n,n_coarce-1);
#else
		//printf("%d %d\n",n,n_coarce-1);
#endif
		
		//getchar();
		n_a[ilevel] = n_coarce - 1;

		// сортировка по новому ключу key=i*(iglcoarce_number-1)+j;
		// в позиции ind сохранён индекс предыдущей позиции.
		//heapsort(Amat, key = i*(n_coarce - 1) + j, nnz + 1, 2 * nnz);
		if (bquicktypesort) {
			QuickSort(Amat, /*n_coarce - 1,*/ nnz_a[ilevel - 1] + 1 + iadd, 2 * nnz_a[ilevel - 1] + iadd, comparei);
		}
		else {
			if (nnz_a[ilevel - 1] < 100000) {
				HeapSort(Amat, /*n_coarce - 1,*/ nnz_a[ilevel - 1] + 1 + iadd, 2 * nnz_a[ilevel - 1] + iadd, comparei);
			}
			else {
				Ak* Aorig = &Amat[nnz_a[ilevel - 1] + 1 + iadd];
				MergeSort(Aorig, nnz_a[ilevel - 1], comparei);
				Aorig = nullptr;
			}
		}

		for (integer ii = 1 + nnz_a[ilevel - 1] + iadd; ii <= 2 * nnz_a[ilevel - 1] + iadd; ii++) {
#if doubleintprecision == 1
			//	printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
#else
			//	printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
#endif
			
			//if (ii % 20 == 0) getchar();
		}



		// копирование в третью часть матрицы Слау на coarce сетке.
		// инициализация.
		// запас памяти 1 nnz на fine уровне.
		for (integer ii = 2 * nnz_a[ilevel - 1] + 1 + iadd; ii <= 3 * nnz_a[ilevel - 1] + iadd; ii++) {
			Amat[ii].aij = 0.0;
			Amat[ii].ind = NULL_NEIGHBOUR;
			Amat[ii].i = NULL_NEIGHBOUR;
			Amat[ii].j = NULL_NEIGHBOUR;
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) flag[ii] = false;


		integer ic1 = 2 * nnz_a[ilevel - 1] + 1 + iadd;
		integer im = 1;
		integer im0 = 0;
		for (integer ii = nnz_a[ilevel - 1] + 1 + iadd; ii <= 2 * nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				while ((ii + im0 <= 2 * nnz_a[ilevel - 1] + iadd) && (istr == Amat[ii + im0].i)) {

					if (ic1 <= 3 * nnz_a[ilevel - 1] + iadd) {
						Amat[ic1].i = Amat[ii + im0].i;
						Amat[ic1].j = Amat[ii + im0].j;
						Amat[ic1].aij += Amat[ii + im0].aij;
						while ((ii + im <= 2 * nnz_a[ilevel - 1] + iadd) && (Amat[ii + im0].i == Amat[ii + im].i) && (Amat[ii + im0].j == Amat[ii + im].j))
						{
							Amat[ic1].aij += Amat[ii + im].aij;
							im++;
						}
						ic1++;
						im0 = im;
						im++;
					}
					else {
						printf("error 1\n");
						system("PAUSE");
					}
				}
				flag[Amat[ii].i] = true;
				im = 1;
				im0 = 0;
			}
		}

		nnz_a[ilevel] = ic1 - 1 - 2 * nnz_a[ilevel - 1] - iadd;
		iadd += 2 * nnz_a[ilevel - 1];

#if doubleintprecision == 1
		printf("nnz: fine=%lld, coarse=%lld, operator complexity=%e. \n", nnz_a[ilevel - 1], nnz_a[ilevel], (doublerealT)(nnz_a[ilevel]) / (doublerealT)(nnz_a[ilevel - 1]));
		printf("n: fine=%lld, coarse=%lld grid complexity=%e.\n", n_a[ilevel - 1], n_a[ilevel], (doublerealT)(n_a[ilevel]) / (doublerealT)(n_a[ilevel - 1]));
		printf("nnz_aRP = %lld\n", nnz_aRP[ilevel - 1]);
#else
		printf("nnz: fine=%d, coarse=%d, operator complexity=%e. \n", nnz_a[ilevel - 1], nnz_a[ilevel], (doublerealT)(nnz_a[ilevel]) / (doublerealT)(nnz_a[ilevel - 1]));
		printf("n: fine=%d, coarse=%d grid complexity=%e.\n", n_a[ilevel - 1], n_a[ilevel], (doublerealT)(n_a[ilevel]) / (doublerealT)(n_a[ilevel - 1]));
		printf("nnz_aRP = %d\n", nnz_aRP[ilevel - 1]);
#endif

		
		//getchar();

		ilevel++;// грубосеточная матрица построена.
		if (ilevel >= 2) {
			if (n_a[ilevel - 2] <= n_a[ilevel - 1]) bcontinue = false;
		}

	} // иерархия сеток построена.

#if doubleintprecision == 1
	  //for (integer ii = 1; ii <= nnz_aRP[0] + nnz_aRP[1]; ii++) {
	  //printf("ii=%lld aij=%e, i=%lld j=%lld\n", ii, R[ii].aij, R[ii].i, R[ii].j);
	  //getchar();
	  //}
#else
	  //for (integer ii = 1; ii <= nnz_aRP[0] + nnz_aRP[1]; ii++) {
	  //printf("ii=%d aij=%e, i=%d j=%d\n", ii, R[ii].aij, R[ii].i, R[ii].j);
	  //getchar();
	  //}
#endif
	 


	  //exporttecplot(b,n);

	  //doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

	  // restriction
	  //restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
	  //for (integer ii = 1; ii <= n_a[0]; ii++) {
	  //b[ii] = 0.0;
	  //}

	  //{
	  //doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

	  // restriction
	  //restriction(R, 1+nnz_aRP[0], nnz_aRP[0]+nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	  //for (integer ii = 1; ii <= n_a[1]; ii++) {
	  //test_coarse[ii] = 0.0;
	  //}

	  //{
	  //	doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

	  // restriction
	  //restriction(R, 1 + nnz_aRP[0]+nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1]+nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	  //for (integer ii = 1; ii <= n_a[2]; ii++) {
	  //test_coarse1[ii] = 0.0;
	  //}

	  //prolongation(P, 1 + nnz_aRP[0]+ nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	  //}

	  //prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	  //}

	  //prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

	  //exporttecplot(b, n);


	  // подготовка матрицы к cycling:

	  // smoother.
	  // 1 september 2015.
	  //void seidel(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
	  //{
	  // istart - начальная позиция ненулевых элементов в матрице А.
	  // iend - конечная позиция ненулевых элементов в матрице А.
	  //for (integer i = 1; i <= n; i++) {
	  //flag[i] = false;
	  //}
	  //for (integer ii = istart; ii <= iend; ii++) {
	  //if (flag[Amat[ii].i] == false) {
	  //integer istr = Amat[ii].i;
	  //integer ic = ii;
	  //doublerealT ap = 0.0;
	  //x[istr] = b[istr];
	  //while ((ic<=iend)&&(Amat[ic].i == istr)) {
	  //if (Amat[ic].j != istr) {
	  //x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	  //}
	  //else ap = Amat[ic].aij;
	  //ic++;
	  //}
	  //if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
	  //printf("zero diagonal elements in string %lld",istr);
#else
	  //printf("zero diagonal elements in string %d",istr);
#endif
	  
	  //getchar();
	  //exit(1);
	  //}
	  //else {
	  //x[istr] /= ap;
	  //}
	  //flag[Amat[ii].i] = true;
	  //}
	  //}


	  //} // seidel


	integer *row_ptr_start = new integer[4 * n_a[0] + 1];
	integer *row_ptr_end = new integer[4 * n_a[0] + 1];
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = 1; ii <= nnz_a[0]; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			integer icdiag = ii;
			row_ptr_start[istr] = ii;
			doublerealT ap = 0.0;
			//x[istr] = b[istr];
			while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else {
					ap = Amat[ic].aij;
					icdiag = ic;
				}
				ic++;
			}
			row_ptr_end[istr] = ic - 1;
			if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld", istr);
#else
				printf("zero diagonal elements in string %d", istr);
#endif
				
				system("PAUSE");
				exit(1);
			}
			else {
				//x[istr] /= ap;
			}

			flag[Amat[ii].i] = true;
			Ak temp = Amat[ii];
			Amat[ii] = Amat[icdiag];
			Amat[icdiag] = temp;
			Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
		}
	}
	// первый уровень вложенности.
	if (ilevel > 1) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = 2 * nnz_a[0] + 1; ii <= 2 * nnz_a[0] + nnz_a[1]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= 2 * nnz_a[0] + nnz_a[1]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0]] = ic - 1;
				if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld", istr);
#else
					printf("zero diagonal elements in string %d", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}

	// второй уровень вложенности.

	if (ilevel > 2) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = 2 * nnz_a[0] + 2 * nnz_a[1] + 1; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1]] = ic - 1;
				if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld", istr);
#else
					printf("zero diagonal elements in string %d", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// третий уровень вложенности.

	if (ilevel > 3) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 1; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2]] = ic - 1;
				if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld", istr);
#else
					printf("zero diagonal elements in string %d", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// 14 сентября 2015 понедельник
	// четвёртый уровень вложенности.

	if (ilevel > 4) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 1;
		integer iend = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3]] = ic - 1;
				if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld", istr);
#else
					printf("zero diagonal elements in string %d", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// пятый уровень вложенности.

	if (ilevel > 5) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 1;
		integer iend = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]] = ic - 1;
				if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld", istr);
#else
					printf("zero diagonal elements in string %d", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}

	// шестой уровень вложенности.

	if (ilevel > 6) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 1;
		integer iend = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]] = ic - 1;
				if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld", istr);
#else
					printf("zero diagonal elements in string %d", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}




	// smoother.
	// 9 september 2015.
	// q - quick.
	// seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
	//void seidelq(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
	//{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	//integer startpos = istartq + iadd;
	//integer endpos = iendq+iadd;
	//for (integer ii = startpos; ii <= endpos; ii++) {
	//integer istr = ii - iadd;
	//x[istr] = b[istr];
	//for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
	//{
	//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; 
	//}
	//x[istr] *= Amat[row_ptr_start[ii]].aij;
	//}


	//} // seidelq



	printf("cycling: V cycle.\n");
#if doubleintprecision == 1
	printf("level=%lld\n", ilevel);
#else
	printf("level=%d\n", ilevel);
#endif
	
	printf("multigrid R.P.Fedorenko 1961.\n");
	printf("aggregative algebraic multigrid method.\n");
	//system("pause");

	// 10 11 21 multigrid tutorial Вильм Бригг.

	integer nu1 = 4;
	integer nu2 = 3;

	//ilevel = 1; //debug
	doublerealT rho = 1.0;
	doublerealT dres = 1.0;
	integer iiter = 1;
	//const doublerealT tolerance = 1.0e-12;
	// 13 февраля 2016 калибруем точность солвера с целью ускорения получения результата.
	// Т.к. нам ненужна точность выше чем десятая доля градуса по температуре.
	// начальное значение невязки составляет примерно 7000.0.
	const doublerealT tolerance = 0.003; // точность выхода по классическому определению L2 нормы.

	doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
	doublerealT *residual_coarse = nullptr;
	doublerealT* error_approx_coarse = nullptr;
	doublerealT *residual_fine1 = nullptr;
	doublerealT *residual_coarse1 = nullptr;
	doublerealT* error_approx_coarse1 = nullptr;
	doublerealT *error_approx_fine1 = nullptr;
	doublerealT *residual_fine2 = nullptr;
	doublerealT *residual_coarse2 = nullptr;
	doublerealT* error_approx_coarse2 = nullptr;
	doublerealT *error_approx_fine2 = nullptr;
	doublerealT *residual_fine3 = nullptr;
	doublerealT *residual_coarse3 = nullptr;
	doublerealT* error_approx_coarse3 = nullptr;
	doublerealT *error_approx_fine3 = nullptr;
	doublerealT *residual_fine4 = nullptr;
	doublerealT *residual_coarse4 = nullptr;
	doublerealT *error_approx_coarse4 = nullptr;
	doublerealT *error_approx_fine4 = nullptr;
	doublerealT *residual_fine5 = nullptr;
	doublerealT *residual_coarse5 = nullptr;
	doublerealT* error_approx_coarse5 = nullptr;
	doublerealT *error_approx_fine5 = nullptr;
	doublerealT *residual_fine6 = nullptr;
	doublerealT *residual_coarse6 = nullptr;
	doublerealT* error_approx_coarse6 = nullptr;
	doublerealT *error_approx_fine6 = nullptr;

	if (ilevel > 1) {
		residual_coarse = new doublerealT[n_a[1] + 1];
		error_approx_coarse = new doublerealT[n_a[1] + 1];
		if (ilevel > 2) {
			// residual
			residual_fine1 = new doublerealT[n_a[1] + 1];
			residual_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_fine1 = new doublerealT[n_a[1] + 1];
			if (ilevel > 3) {
				// residual
				residual_fine2 = new doublerealT[n_a[2] + 1];
				residual_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_fine2 = new doublerealT[n_a[2] + 1];
				if (ilevel > 4) {
					// residual
					residual_fine3 = new doublerealT[n_a[3] + 1];
					residual_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_fine3 = new doublerealT[n_a[3] + 1];
					if (ilevel > 5) {
						// residual
						residual_fine4 = new doublerealT[n_a[4] + 1];
						residual_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_fine4 = new doublerealT[n_a[4] + 1];
						if (ilevel > 6) {
							// residual
							residual_fine5 = new doublerealT[n_a[5] + 1];
							residual_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_fine5 = new doublerealT[n_a[5] + 1];
							if (ilevel > 7) {
								// residual
								residual_fine6 = new doublerealT[n_a[6] + 1];
								residual_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_fine6 = new doublerealT[n_a[6] + 1];
							}
						}
					}
				}
			}
		}
	}
	doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];


	//for (integer iprohod = 0; iprohod < 20; iprohod++) {
	while (dres>tolerance) {

		// smother
		for (integer iter = 0; iter < nu1; iter++) {
			//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
			//quick seidel
			seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);

		}

		//exporttecplot(x, n);

		// residual_r
		//doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
		//residual<doublereal>(Amat, 1, nnz_a[0], x, b, flag, n_a[0], residual_fine);
		residualq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
		dres = norma(residual_fine, n_a[0]);

		// номер V цикла, L2 норма невязки, локальная скорость изменения невязки.
#if doubleintprecision == 1
		printf("%lld %e rho=%e\n", iiter, dres, dres / rho);
#else
		printf("%d %e rho=%e\n", iiter, dres, dres / rho);
#endif
		
		iiter++;
		//rho=norma(residual_fine, n_a[0]);
		rho = dres;
		//if (iprohod%5==0) getchar();
		if (ilevel > 1) {

			//doublerealT *residual_coarse = new doublerealT[n_a[1] + 1];

			// restriction
			restriction(R, 1, nnz_aRP[0], flag, residual_fine, residual_coarse, n_a[0], n_a[1]);

			// Amat*e=r;
			//doublerealT* error_approx_coarse = new doublerealT[n_a[1] + 1];
			for (integer ii = 1; ii <= n_a[1]; ii++) {
				error_approx_coarse[ii] = 0.0;
			}
			// pre smothing
			for (integer iter = 0; iter < nu1; iter++) {
				//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
				seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
			}

			if (ilevel > 2) {
				// residual
				//doublerealT *residual_fine1 = new doublerealT[n_a[1] + 1];
				//residual(Amat, 1+2*nnz_a[0], 2*nnz_a[0]+nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1], residual_fine1);
				//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
				residualqspeshial(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);


				//doublerealT *residual_coarse1 = new doublerealT[n_a[2] + 1];

				// restriction
				restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, residual_fine1, residual_coarse1, n_a[1], n_a[2]);

				// Amat*e=r;
				//doublerealT* error_approx_coarse1 = new doublerealT[n_a[2] + 1];
				for (integer ii = 1; ii <= n_a[2]; ii++) {
					error_approx_coarse1[ii] = 0.0;
				}
				// pre smothing
				for (integer iter = 0; iter < nu1; iter++) {
					//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
					seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
				}
				if (ilevel > 3) {
					// residual
					//doublerealT *residual_fine2 = new doublerealT[n_a[2] + 1];
					//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2], residual_fine2);
					//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0]+n_a[1], residual_fine2);
					residualqspeshial(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);

					//doublerealT *residual_coarse2 = new doublerealT[n_a[3] + 1];

					// restriction
					restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, residual_fine2, residual_coarse2, n_a[2], n_a[3]);

					// Amat*e=r;
					//doublerealT* error_approx_coarse2 = new doublerealT[n_a[3] + 1];
					for (integer ii = 1; ii <= n_a[3]; ii++) {
						error_approx_coarse2[ii] = 0.0;
					}
					// pre smothing
					for (integer iter = 0; iter < nu1; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
						seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);

					}
					if (ilevel > 4) {
						// residual
						//doublerealT *residual_fine3 = new doublerealT[n_a[3] + 1];
						//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3], residual_fine3);
						//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
						//speshial
						residualqspeshial(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);



						//doublerealT *residual_coarse3 = new doublerealT[n_a[4] + 1];

						// restriction
						restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, residual_fine3, residual_coarse3, n_a[3], n_a[4]);

						// Amat*e=r;
						//doublerealT* error_approx_coarse3 = new doublerealT[n_a[4] + 1];
						for (integer ii = 1; ii <= n_a[4]; ii++) {
							error_approx_coarse3[ii] = 0.0;
						}
						// pre smothing
						for (integer iter = 0; iter < nu1; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
							seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
						}
						if (ilevel > 5) {
							// residual
							//doublerealT *residual_fine4 = new doublerealT[n_a[4] + 1];
							//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4], residual_fine4);
							//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
							//speshial 14 september 2015.
							residualqspeshial(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);


							//doublerealT *residual_coarse4 = new doublerealT[n_a[5] + 1];

							// restriction
							restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, residual_fine4, residual_coarse4, n_a[4], n_a[5]);

							// Amat*e=r;
							//doublerealT* error_approx_coarse4 = new doublerealT[n_a[5] + 1];
							for (integer ii = 1; ii <= n_a[5]; ii++) {
								error_approx_coarse4[ii] = 0.0;
							}
							// pre smothing
							for (integer iter = 0; iter < nu1; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
								seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
							}
							if (ilevel > 6) {
								// residual
								//doublerealT *residual_fine5 = new doublerealT[n_a[5] + 1];
								//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5], residual_fine5);
								//if (ilevel <= 15) {
								residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
								//}
								//else {
								// приводит к расходимости.
								//speshial 14 september 2015.
								// это уже приводит к увеличению числа итераций на примере сетки в 1млн узлов. остановимся.
								//residualqspeshial(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
								//}

								//doublerealT *residual_coarse5 = new doublerealT[n_a[6] + 1];

								// restriction
								restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, residual_fine5, residual_coarse5, n_a[5], n_a[6]);

								// Amat*e=r;
								//doublerealT* error_approx_coarse5 = new doublerealT[n_a[6] + 1];
								for (integer ii = 1; ii <= n_a[6]; ii++) {
									error_approx_coarse5[ii] = 0.0;
								}
								// pre smothing
								for (integer iter = 0; iter < nu1; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
									seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
								}

								if (ilevel > 7) {
									// residual
									//doublerealT *residual_fine6 = new doublerealT[n_a[6] + 1];
									//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] +2*nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6], residual_fine6);
									residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);

									//doublerealT *residual_coarse6 = new doublerealT[n_a[7] + 1];

									// restriction
									restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, residual_fine6, residual_coarse6, n_a[6], n_a[7]);

									// Amat*e=r;
									//doublerealT* error_approx_coarse6 = new doublerealT[n_a[7] + 1];
									for (integer ii = 1; ii <= n_a[7]; ii++) {
										error_approx_coarse6[ii] = 0.0;
									}
									// pre smothing
									for (integer iter = 0; iter < nu1; iter++) {
										seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7]);
									}

									if (ilevel > 8) {
										// residual
										doublerealT *residual_fine7 = new doublerealT[n_a[7] + 1];
										residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7], residual_fine7);


										doublerealT *residual_coarse7 = new doublerealT[n_a[8] + 1];

										// restriction
										restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, residual_fine7, residual_coarse7, n_a[7], n_a[8]);

										// Amat*e=r;
										doublerealT* error_approx_coarse7 = new doublerealT[n_a[8] + 1];
										for (integer ii = 1; ii <= n_a[8]; ii++) {
											error_approx_coarse7[ii] = 0.0;
										}
										// pre smothing
										for (integer iter = 0; iter < nu1; iter++) {
											seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
										}


										if (ilevel > 9) {
											// residual
											doublerealT *residual_fine8 = new doublerealT[n_a[8] + 1];
											integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7];
											integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + nnz_a[8];
											residual(Amat, n1, n2, error_approx_coarse7, residual_coarse7, flag, n_a[8], residual_fine8);


											doublerealT *residual_coarse8 = new doublerealT[n_a[9] + 1];

											// restriction
											integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
											integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
											restriction(R, n3, n4, flag, residual_fine8, residual_coarse8, n_a[8], n_a[9]);

											// Amat*e=r;
											doublerealT* error_approx_coarse8 = new doublerealT[n_a[9] + 1];
											for (integer ii = 1; ii <= n_a[9]; ii++) {
												error_approx_coarse8[ii] = 0.0;
											}
											// pre smothing
											for (integer iter = 0; iter < nu1; iter++) {
												integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8];
												integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + nnz_a[9];
												seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
											}

											if (ilevel > 10) {
												// 8 сентября 2015 РИМИНИ пляж 

												// residual
												doublerealT *residual_fine9 = new doublerealT[n_a[9] + 1];
												integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8];
												integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + nnz_a[9];
												residual(Amat, n1, n2, error_approx_coarse8, residual_coarse8, flag, n_a[9], residual_fine9);


												doublerealT *residual_coarse9 = new doublerealT[n_a[10] + 1];

												// restriction
												integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
												integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
												restriction(R, n3, n4, flag, residual_fine9, residual_coarse9, n_a[9], n_a[10]);

												// Amat*e=r;
												doublerealT* error_approx_coarse9 = new doublerealT[n_a[10] + 1];
												for (integer ii = 1; ii <= n_a[10]; ii++) {
													error_approx_coarse9[ii] = 0.0;
												}
												// pre smothing
												for (integer iter = 0; iter < nu1; iter++) {
													integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9];
													integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + nnz_a[10];
													seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
												}

												if (ilevel > 11) {
													// 8 сентября 2015 РИМИНИ пляж 

													// residual
													doublerealT *residual_fine10 = new doublerealT[n_a[10] + 1];
													integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9];
													integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + nnz_a[10];
													residual(Amat, n1, n2, error_approx_coarse9, residual_coarse9, flag, n_a[10], residual_fine10);


													doublerealT *residual_coarse10 = new doublerealT[n_a[11] + 1];

													// restriction
													integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
													integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
													restriction(R, n3, n4, flag, residual_fine10, residual_coarse10, n_a[10], n_a[11]);

													// Amat*e=r;
													doublerealT* error_approx_coarse10 = new doublerealT[n_a[11] + 1];
													for (integer ii = 1; ii <= n_a[11]; ii++) {
														error_approx_coarse10[ii] = 0.0;
													}
													// pre smothing
													for (integer iter = 0; iter < nu1; iter++) {
														integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10];
														integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + nnz_a[11];
														seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
													}

													if (ilevel > 12) {
														// 11 сентября 2015 РИМИНИ пляж 

														// residual
														doublerealT *residual_fine11 = new doublerealT[n_a[11] + 1];
														integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10];
														integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + nnz_a[11];
														residual(Amat, n1, n2, error_approx_coarse10, residual_coarse10, flag, n_a[11], residual_fine11);


														doublerealT *residual_coarse11 = new doublerealT[n_a[12] + 1];

														// restriction
														integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
														integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
														restriction(R, n3, n4, flag, residual_fine11, residual_coarse11, n_a[11], n_a[12]);

														// Amat*e=r;
														doublerealT* error_approx_coarse11 = new doublerealT[n_a[12] + 1];
														for (integer ii = 1; ii <= n_a[12]; ii++) {
															error_approx_coarse11[ii] = 0.0;
														}
														// pre smothing
														for (integer iter = 0; iter < nu1; iter++) {
															integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11];
															integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + nnz_a[12];
															seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
														}

														if (ilevel > 13) {
															// 11 сентября 2015 РИМИНИ пляж 

															// residual
															doublerealT *residual_fine12 = new doublerealT[n_a[12] + 1];
															integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11];
															integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + nnz_a[12];
															residual(Amat, n1, n2, error_approx_coarse11, residual_coarse11, flag, n_a[12], residual_fine12);


															doublerealT *residual_coarse12 = new doublerealT[n_a[13] + 1];

															// restriction
															integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
															integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
															restriction(R, n3, n4, flag, residual_fine12, residual_coarse12, n_a[12], n_a[13]);

															// Amat*e=r;
															doublerealT* error_approx_coarse12 = new doublerealT[n_a[13] + 1];
															for (integer ii = 1; ii <= n_a[13]; ii++) {
																error_approx_coarse12[ii] = 0.0;
															}
															// pre smothing
															for (integer iter = 0; iter < nu1; iter++) {
																integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12];
																integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + nnz_a[13];
																seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
															}


															if (ilevel > 14) {
																// 11 сентября 2015 РИМИНИ пляж 

																// residual
																doublerealT *residual_fine13 = new doublerealT[n_a[13] + 1];
																integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12];
																integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + nnz_a[13];
																residual(Amat, n1, n2, error_approx_coarse12, residual_coarse12, flag, n_a[13], residual_fine13);


																doublerealT *residual_coarse13 = new doublerealT[n_a[14] + 1];

																// restriction
																integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																restriction(R, n3, n4, flag, residual_fine13, residual_coarse13, n_a[13], n_a[14]);

																// Amat*e=r;
																doublerealT* error_approx_coarse13 = new doublerealT[n_a[14] + 1];
																for (integer ii = 1; ii <= n_a[14]; ii++) {
																	error_approx_coarse13[ii] = 0.0;
																}
																// pre smothing
																for (integer iter = 0; iter < nu1; iter++) {
																	integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13];
																	integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + nnz_a[14];
																	seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																}

																if (ilevel > 15) {
																	// 14 сентября 2015 Москва на работе в пн. 

																	// residual
																	doublerealT *residual_fine14 = new doublerealT[n_a[14] + 1];
																	integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13];
																	integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + nnz_a[14];
																	residual(Amat, n1, n2, error_approx_coarse13, residual_coarse13, flag, n_a[14], residual_fine14);


																	doublerealT *residual_coarse14 = new doublerealT[n_a[15] + 1];

																	// restriction
																	integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																	integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																	restriction(R, n3, n4, flag, residual_fine14, residual_coarse14, n_a[14], n_a[15]);

																	// Amat*e=r;
																	doublerealT* error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																	for (integer ii = 1; ii <= n_a[15]; ii++) {
																		error_approx_coarse14[ii] = 0.0;
																	}
																	// pre smothing
																	for (integer iter = 0; iter < nu1; iter++) {
																		integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + 2 * nnz_a[14];
																		integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + 2 * nnz_a[14] + nnz_a[15];
																		seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																	}

																	// post smothing
																	for (integer iter = 0; iter < nu2; iter++) {
																		integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + 2 * nnz_a[14];
																		integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + 2 * nnz_a[14] + nnz_a[15];
																		seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																	}


																	// prolongation
																	// residual_r
																	doublerealT *error_approx_fine14 = new doublerealT[n_a[14] + 1];
																	for (integer ii = 1; ii <= n_a[14]; ii++) {
																		error_approx_fine14[ii] = 0.0;
																	}

#if doubleintprecision == 1
																	//for (integer ii = 1; ii <= n_a[15]; ii++) {// debug
																	//printf("error_approx_coarse14[%lld]=%e\n",ii, error_approx_coarse14[ii]);

																	//printf("residual_coarse14[%lld]=%e\n", ii, residual_coarse14[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]+2*nnz_a[14]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+2*nnz_a[14]+ nnz_a[15]; ii++) {// debug
																	//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#else
																	//for (integer ii = 1; ii <= n_a[15]; ii++) {// debug
																	//printf("error_approx_coarse14[%d]=%e\n",ii, error_approx_coarse14[ii]);

																	//printf("residual_coarse14[%d]=%e\n", ii, residual_coarse14[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]+2*nnz_a[14]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+2*nnz_a[14]+ nnz_a[15]; ii++) {// debug
																	//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#endif
																	

																	integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																	integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																	prolongation(P, n7, n8, flag, error_approx_fine14, error_approx_coarse14, n_a[14], n_a[15]);

																	// correction
																	for (integer ii = 1; ii <= n_a[14]; ii++) {
																		error_approx_coarse13[ii] += error_approx_fine14[ii];
																	}

																	// free
																	delete[] error_approx_fine14;
																	delete[] error_approx_coarse14;
																	delete[] residual_coarse14;
																	delete[] residual_fine14;

																}


																// post smothing
																for (integer iter = 0; iter < nu2; iter++) {
																	integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13];
																	integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + nnz_a[14];
																	seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																}


																// prolongation
																// residual_r
																doublerealT *error_approx_fine13 = new doublerealT[n_a[13] + 1];
																for (integer ii = 1; ii <= n_a[13]; ii++) {
																	error_approx_fine13[ii] = 0.0;
																}

#if doubleintprecision == 1
																//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																//printf("error_approx_coarse13[%lld]=%e\n",ii, error_approx_coarse13[ii]);

																//printf("residual_coarse13[%lld]=%e\n", ii, residual_coarse13[ii]);
																//getchar();
																//}
																//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																//if (ii % 20 == 0) getchar();
																//}
#else
																//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																//printf("error_approx_coarse13[%d]=%e\n",ii, error_approx_coarse13[ii]);

																//printf("residual_coarse13[%d]=%e\n", ii, residual_coarse13[ii]);
																//getchar();
																//}
																//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																//if (ii % 20 == 0) getchar();
																//}
#endif
																

																integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																prolongation(P, n7, n8, flag, error_approx_fine13, error_approx_coarse13, n_a[13], n_a[14]);

																// correction
																for (integer ii = 1; ii <= n_a[13]; ii++) {
																	error_approx_coarse12[ii] += error_approx_fine13[ii];
																}

																// free
																delete[] error_approx_fine13;
																delete[] error_approx_coarse13;
																delete[] residual_coarse13;
																delete[] residual_fine13;

															}


															// post smothing
															for (integer iter = 0; iter < nu2; iter++) {
																integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12];
																integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + nnz_a[13];
																seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
															}


															// prolongation
															// residual_r
															doublerealT *error_approx_fine12 = new doublerealT[n_a[12] + 1];
															for (integer ii = 1; ii <= n_a[12]; ii++) {
																error_approx_fine12[ii] = 0.0;
															}

#if doubleintprecision == 1
															//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
															//printf("error_approx_coarse12[%lld]=%e\n",ii, error_approx_coarse12[ii]);

															//printf("residual_coarse12[%lld]=%e\n", ii, residual_coarse12[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
															//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#else
															//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
															//printf("error_approx_coarse12[%d]=%e\n",ii, error_approx_coarse12[ii]);

															//printf("residual_coarse12[%d]=%e\n", ii, residual_coarse12[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
															//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#endif
															

															integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
															integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
															prolongation(P, n7, n8, flag, error_approx_fine12, error_approx_coarse12, n_a[12], n_a[13]);

															// correction
															for (integer ii = 1; ii <= n_a[12]; ii++) {
																error_approx_coarse11[ii] += error_approx_fine12[ii];
															}

															// free
															delete[] error_approx_fine12;
															delete[] error_approx_coarse12;
															delete[] residual_coarse12;
															delete[] residual_fine12;

														}



														// post smothing
														for (integer iter = 0; iter < nu2; iter++) {
															integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11];
															integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + nnz_a[12];
															seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
														}


														// prolongation
														// residual_r
														doublerealT *error_approx_fine11 = new doublerealT[n_a[11] + 1];
														for (integer ii = 1; ii <= n_a[11]; ii++) {
															error_approx_fine11[ii] = 0.0;
														}

#if doubleintprecision == 1
														//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
														//printf("error_approx_coarse11[%lld]=%e\n",ii, error_approx_coarse11[ii]);

														//printf("residual_coarse11[%lld]=%e\n", ii, residual_coarse11[ii]);
														//getchar();
														//}
														//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
														//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
														//if (ii % 20 == 0) getchar();
														//}
#else
														//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
														//printf("error_approx_coarse11[%d]=%e\n",ii, error_approx_coarse11[ii]);

														//printf("residual_coarse11[%d]=%e\n", ii, residual_coarse11[ii]);
														//getchar();
														//}
														//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
														//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
														//if (ii % 20 == 0) getchar();
														//}
#endif
														

														integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
														integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
														prolongation(P, n7, n8, flag, error_approx_fine11, error_approx_coarse11, n_a[11], n_a[12]);

														// correction
														for (integer ii = 1; ii <= n_a[11]; ii++) {
															error_approx_coarse10[ii] += error_approx_fine11[ii];
														}

														// free
														delete[] error_approx_fine11;
														delete[] error_approx_coarse11;
														delete[] residual_coarse11;
														delete[] residual_fine11;

													}


													// post smothing
													for (integer iter = 0; iter < nu2; iter++) {
														integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10];
														integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + nnz_a[11];
														seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
													}


													// prolongation
													// residual_r
													doublerealT *error_approx_fine10 = new doublerealT[n_a[10] + 1];
													for (integer ii = 1; ii <= n_a[10]; ii++) {
														error_approx_fine10[ii] = 0.0;
													}

#if doubleintprecision == 1
													//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
													//printf("error_approx_coarse10[%lld]=%e\n",ii, error_approx_coarse10[ii]);

													//printf("residual_coarse10[%lld]=%e\n", ii, residual_coarse10[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
													//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#else
													//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
													//printf("error_approx_coarse10[%d]=%e\n",ii, error_approx_coarse10[ii]);

													//printf("residual_coarse10[%d]=%e\n", ii, residual_coarse10[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
													//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#endif
													

													integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
													integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
													prolongation(P, n7, n8, flag, error_approx_fine10, error_approx_coarse10, n_a[10], n_a[11]);

													// correction
													for (integer ii = 1; ii <= n_a[10]; ii++) {
														error_approx_coarse9[ii] += error_approx_fine10[ii];
													}

													// free
													delete[] error_approx_fine10;
													delete[] error_approx_coarse10;
													delete[] residual_coarse10;
													delete[] residual_fine10;

												}



												// post smothing
												for (integer iter = 0; iter < nu2; iter++) {
													integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9];
													integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + nnz_a[10];
													seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
												}


												// prolongation
												// residual_r
												doublerealT *error_approx_fine9 = new doublerealT[n_a[9] + 1];
												for (integer ii = 1; ii <= n_a[9]; ii++) {
													error_approx_fine9[ii] = 0.0;
												}

#if doubleintprecision == 1
												//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
												//printf("error_approx_coarse9[%lld]=%e\n",ii, error_approx_coarse9[ii]);

												//printf("residual_coarse9[%lld]=%e\n", ii, residual_coarse9[ii]);
												//getchar();
												//}
												//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
												//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
												//if (ii % 20 == 0) getchar();
												//}
#else
												//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
												//printf("error_approx_coarse9[%d]=%e\n",ii, error_approx_coarse9[ii]);

												//printf("residual_coarse9[%d]=%e\n", ii, residual_coarse9[ii]);
												//getchar();
												//}
												//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
												//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
												//if (ii % 20 == 0) getchar();
												//}
#endif
												

												integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
												integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
												prolongation(P, n7, n8, flag, error_approx_fine9, error_approx_coarse9, n_a[9], n_a[10]);

												// correction
												for (integer ii = 1; ii <= n_a[9]; ii++) {
													error_approx_coarse8[ii] += error_approx_fine9[ii];
												}

												// free
												delete[] error_approx_fine9;
												delete[] error_approx_coarse9;
												delete[] residual_coarse9;
												delete[] residual_fine9;

											}

											// post smothing
											for (integer iter = 0; iter < nu2; iter++) {
												integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8];
												integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + nnz_a[9];
												seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
											}


											// prolongation
											// residual_r
											doublerealT *error_approx_fine8 = new doublerealT[n_a[8] + 1];
											for (integer ii = 1; ii <= n_a[8]; ii++) {
												error_approx_fine8[ii] = 0.0;
											}

#if doubleintprecision == 1
											//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
											//printf("error_approx_coarse8[%lld]=%e\n",ii, error_approx_coarse8[ii]);

											//printf("residual_coarse8[%lld]=%e\n", ii, residual_coarse8[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
											//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#else
											//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
											//printf("error_approx_coarse8[%d]=%e\n",ii, error_approx_coarse8[ii]);

											//printf("residual_coarse8[%d]=%e\n", ii, residual_coarse8[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
											//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#endif
											

											integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
											integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
											prolongation(P, n7, n8, flag, error_approx_fine8, error_approx_coarse8, n_a[8], n_a[9]);

											// correction
											for (integer ii = 1; ii <= n_a[8]; ii++) {
												error_approx_coarse7[ii] += error_approx_fine8[ii];
											}

											// free
											delete[] error_approx_fine8;
											delete[] error_approx_coarse8;
											delete[] residual_coarse8;
											delete[] residual_fine8;

										}

										// post smothing
										for (integer iter = 0; iter < nu2; iter++) {
											seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
										}


										// prolongation
										// residual_r
										doublerealT *error_approx_fine7 = new doublerealT[n_a[7] + 1];
										for (integer ii = 1; ii <= n_a[7]; ii++) {
											error_approx_fine7[ii] = 0.0;
										}

#if doubleintprecision == 1
										//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
										//printf("error_approx_coarse7[%lld]=%e\n",ii, error_approx_coarse7[ii]);

										//printf("residual_coarse7[%lld]=%e\n", ii, residual_coarse7[ii]);
										//getchar();
										//}
										//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
										//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
										//if (ii % 20 == 0) getchar();
										//}
#else
										//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
										//printf("error_approx_coarse7[%d]=%e\n",ii, error_approx_coarse7[ii]);

										//printf("residual_coarse7[%d]=%e\n", ii, residual_coarse7[ii]);
										//getchar();
										//}
										//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
										//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
										//if (ii % 20 == 0) getchar();
										//}
#endif
										

										prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, error_approx_fine7, error_approx_coarse7, n_a[7], n_a[8]);

										// correction
										for (integer ii = 1; ii <= n_a[7]; ii++) {
											error_approx_coarse6[ii] += error_approx_fine7[ii];
										}

										// free
										delete[] error_approx_fine7;
										delete[] error_approx_coarse7;
										delete[] residual_coarse7;
										delete[] residual_fine7;

									}


									// post smothing
									for (integer iter = 0; iter < nu2; iter++) {
										seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7]);
									}


									// prolongation
									// residual_r
									//doublerealT *error_approx_fine6 = new doublerealT[n_a[6] + 1];
									for (integer ii = 1; ii <= n_a[6]; ii++) {
										error_approx_fine6[ii] = 0.0;
									}

#if doubleintprecision == 1
									//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
									//printf("error_approx_coarse6[%lld]=%e\n",ii, error_approx_coarse6[ii]);

									//printf("residual_coarse6[%lld]=%e\n", ii, residual_coarse6[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#else
									//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
									//printf("error_approx_coarse6[%d]=%e\n",ii, error_approx_coarse6[ii]);

									//printf("residual_coarse6[%d]=%e\n", ii, residual_coarse6[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#endif
									

									prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, error_approx_fine6, error_approx_coarse6, n_a[6], n_a[7]);

									// correction
									for (integer ii = 1; ii <= n_a[6]; ii++) {
										error_approx_coarse5[ii] += error_approx_fine6[ii];
									}

									// free
									//delete[] error_approx_fine6;
									//delete[] error_approx_coarse6;
									//delete[] residual_coarse6;
									//delete[] residual_fine6;

								}

								// post smothing
								for (integer iter = 0; iter < nu2; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
									seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
								}

								// prolongation
								// residual_r
								//doublerealT *error_approx_fine5 = new doublerealT[n_a[5] + 1];
								for (integer ii = 1; ii <= n_a[5]; ii++) {
									error_approx_fine5[ii] = 0.0;
								}

#if doubleintprecision == 1
								//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
								//printf("error_approx_coarse5[%lld]=%e\n",ii, error_approx_coarse5[ii]);

								//printf("residual_coarse5[%lld]=%e\n", ii, residual_coarse5[ii]);
								//getchar();
								//}
								//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
								//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
								//if (ii % 20 == 0) getchar();
								//}
#else
								//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
								//printf("error_approx_coarse5[%d]=%e\n",ii, error_approx_coarse5[ii]);

								//printf("residual_coarse5[%d]=%e\n", ii, residual_coarse5[ii]);
								//getchar();
								//}
								//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
								//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
								//if (ii % 20 == 0) getchar();
								//}
#endif
								

								prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, error_approx_fine5, error_approx_coarse5, n_a[5], n_a[6]);

								// correction
								for (integer ii = 1; ii <= n_a[5]; ii++) {
									error_approx_coarse4[ii] += error_approx_fine5[ii];
								}

								// free
								//delete[] error_approx_fine5;
								//delete[] error_approx_coarse5;
								//delete[] residual_coarse5;
								//delete[] residual_fine5;

							}
							// post smothing
							for (integer iter = 0; iter < nu2; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
								seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
							}

							// prolongation
							// residual_r
							//doublerealT *error_approx_fine4 = new doublerealT[n_a[4] + 1];
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_fine4[ii] = 0.0;
							}

#if doubleintprecision == 1
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%lld]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%lld]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#else
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%d]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%d]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#endif
							

							prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, error_approx_fine4, error_approx_coarse4, n_a[4], n_a[5]);

							// correction
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] += error_approx_fine4[ii];
							}

							// free
							//delete[] error_approx_fine4;
							//delete[] error_approx_coarse4;
							//delete[] residual_coarse4;
							//delete[] residual_fine4;

						}
						// post smothing
						for (integer iter = 0; iter < nu2; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
							seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
						}

						// prolongation
						// residual_r
						//doublerealT *error_approx_fine3 = new doublerealT[n_a[3] + 1];
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_fine3[ii] = 0.0;
						}

#if doubleintprecision == 1
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%lld]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%lld]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#else
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%d]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%d]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#endif
						

						prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, error_approx_fine3, error_approx_coarse3, n_a[3], n_a[4]);

						// correction
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] += error_approx_fine3[ii];
						}

						// free
						//delete[] error_approx_fine3;
						//delete[] error_approx_coarse3;
						//delete[] residual_coarse3;
						//delete[] residual_fine3;

					}
					// post smothing
					for (integer iter = 0; iter < nu2; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
						seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);

					}

					// prolongation
					// residual_r
					//doublerealT *error_approx_fine2 = new doublerealT[n_a[2] + 1];
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_fine2[ii] = 0.0;
					}

#if doubleintprecision == 1
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%lld]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%lld]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#else
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%d]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%d]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#endif
					

					prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, error_approx_fine2, error_approx_coarse2, n_a[2], n_a[3]);

					// correction
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] += error_approx_fine2[ii];
					}

					// free
					//delete[] error_approx_fine2;
					//delete[] error_approx_coarse2;
					//delete[] residual_coarse2;
					//delete[] residual_fine2;

				}
				// post smothing
				for (integer iter = 0; iter < nu2; iter++) {
					//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
					seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
				}

				// prolongation
				// residual_r
				//doublerealT *error_approx_fine1 = new doublerealT[n_a[1] + 1];
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_fine1[ii] = 0.0;
				}

#if doubleintprecision == 1
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%lld]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%lld]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#else
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%d]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%d]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#endif
				

				prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, error_approx_fine1, error_approx_coarse1, n_a[1], n_a[2]);

				// correction
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] += error_approx_fine1[ii];
				}

				// free
				//delete[] error_approx_fine1;
				//delete[] error_approx_coarse1;
				//delete[] residual_coarse1;
				//delete[] residual_fine1;

			}

			// post smothing
			for (integer iter = 0; iter < nu2; iter++) {
				//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
				seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
			}

			// prolongation
			// residual_r
			//doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				error_approx_fine[ii] = 0.0;
			}

			prolongation(P, 1, nnz_aRP[0], flag, error_approx_fine, error_approx_coarse, n_a[0], n_a[1]);

			// correction
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				x[ii] += error_approx_fine[ii];
			}

			// free
			//delete[] error_approx_fine;
			//delete[] error_approx_coarse;
			//delete[] residual_coarse;
			//delete[] residual_fine;
		}
		// post smother
		for (integer iter = 0; iter < nu2; iter++) {
			//seidel<doublereal>(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
			//quick seidel
			seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
		}
	}

	system("pause");

	// free
	delete[] error_approx_fine;
	if (ilevel > 1) {
		delete[] error_approx_coarse;
		delete[] residual_coarse;
		if (ilevel > 2) {
			// free
			delete[] error_approx_fine1;
			delete[] error_approx_coarse1;
			delete[] residual_coarse1;
			delete[] residual_fine1;
			if (ilevel > 3) {
				// free
				delete[] error_approx_fine2;
				delete[] error_approx_coarse2;
				delete[] residual_coarse2;
				delete[] residual_fine2;
				if (ilevel > 4) {
					// free
					delete[] error_approx_fine3;
					delete[] error_approx_coarse3;
					delete[] residual_coarse3;
					delete[] residual_fine3;
					if (ilevel > 5) {
						// free
						delete[] error_approx_fine4;
						delete[] error_approx_coarse4;
						delete[] residual_coarse4;
						delete[] residual_fine4;
						if (ilevel > 6) {
							// free
							delete[] error_approx_fine5;
							delete[] error_approx_coarse5;
							delete[] residual_coarse5;
							delete[] residual_fine5;
							if (ilevel > 7) {
								// free
								delete[] error_approx_fine6;
								delete[] error_approx_coarse6;
								delete[] residual_coarse6;
								delete[] residual_fine6;
							}
						}
					}
				}
			}
		}
	}
	delete[] residual_fine;

	delete[] row_ptr_start;
	delete[] row_ptr_end;
	delete[] flag_;
	return 0;

} // aggregative_amg

  // возвращает максимум из двух целых чисел.
integer i_my_max(integer ia, integer ib) {
	if (ia > ib) {
		return ia;
	}
	else {
		return ib;
	}
}

// возвращает минимум из двух целых чисел.
integer i_my_min(integer ia, integer ib) {
	if (ia > ib) {
		return ib;
	}
	else {
		return ia;
	}
}

// 13 декабря 2015. Внедрено АВЛ дерево. При внедрении АВЛ дерева исправлена логическая ошибка в
// построении С/F разбиения, теперь C/F разбиение строится корректно.
// Исправлен и внедрён quicksort (qs,qsj)
// который в пять раз быстрее пирамидальной сортировки.
// Полный отказ от band_size!!!.
// Время работы алгоритма на 1.7М неизвестных в 3D составило ровно 1 минуту.
// 18 октября 2015. Полностью работоспособный мультигрид.
// Тестировалось на условиях Дирихле но должно работать на любых 
// краевых задачах. 18 октября датируется версия 0.04. Версия 0.04 на треть
// быстрее версии 0_03. Были ускорены как операции построения C/F разбиения, 
// так и нахождение оператора Галёркина. При нахождении С/F разбиения 
// учитывается уже построенная его часть и поэтому число сканирований на
// на поздних циклах сокращается охватывая только не построенную часть.
// При нахождении произведения Галёркина получена самая оптимальная по быстродействию версия,
// Основанная на алгоритме слияния отсортированных списков.
// 4 октября правильное построение последовательности вложенных графов.
// 30 сентября продолжаем исправление метода. Делаем классический 
// алгебраический многосеточный метод на основе  C/F разбиения.
// 16 сентября 2015 года обнаружено что операции 
// сгрубления и интерполяции сделаны совершенно неверно,
// и если сгрубление еще в какой-то мере проецирует то интерполяция просто никакая.
// Операции сгрубления и интерполяции будут сделаны заново на основе статьи К.Н. Волкова в новой версии солвера.
// 3 september 2015 Villa Borgese.
template <typename doublerealT>
integer classic_aglomerative_amg1(Ak* &Amat, integer nnz,
	integer n, // dimension of vectors x and b.
	Ak* &R, // restriction
	Ak* &P, // prolongation
	Ak* &Atemp,
	Ak* &Atemp2,
	doublereal* &x, doublereal* &b,
	doublerealT theta,
	integer dim_2D
	/*,
	doublerealT mul_theta3D*/
	) {


	//const doublerealT mul_theta3D = 0.13;

	// контроль числа сильных связей между переменными.
	// doublerealT theta = 0.25;  // 0.25 for 2D and 0.5 for 3D 


	bool bqs = true; // Использовать ли quicksort qs and qsj.
					 // Сортировка с подсчётом быстрее quickSort.
	bool bCounting_Sort = true; // Использовать ли сортировку подсчётом которая потребляет килотонну памяти (Короче для машин у которых море оперативки).
	bool blite_and_quick_version = false;
	// false даёт более качественное построение иерархии матриц, 
	// с ним количество итераций сокращается.
	const integer heapsortsizelimit = 200000000; // 200M Достаточно для 3D с размерностью 300х300х300 189М ненулевых элементов.

	const doublereal RealZERO = 1.0e-300;// 1.0e-10;
	const doublereal divisionZERO = 1.0e-300;
	const doublereal RealMAXIMUM = 1.0e300;
	// включение/отключение отладочного режима.
	bool debug_reshime = false;

	const integer max_neighbour = 27850;
	// Мы будем поддерживать информацию о максимальном количестве соседей.
	integer Maximumneighbourcount = -1;
	// мы получим порядковый номер элемента с максимальным число соседей в матрице А,
	// прямо в результате построения C/F разбиения.
	integer icandidate_shadow = -1;
	bool bmaxneighbourinfoactive = false;

	// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
	bool bquicktypesort = false;


	// x_coarse[1..n_coarse]=R n_coarse x n_fine*x_fine[1..n_fine];
	// x_fine[1..n_fine]=P n_fine x n_coarse*x_coarse[1..n_coarse];

	// нумерация начинается с единицы.

	const integer maxlevel = 30;
	integer ilevel = 1;
	integer nnz_a[maxlevel];
	integer n_a[maxlevel];
	nnz_a[0] = nnz;
	n_a[0] = n;
	bool* flag = new bool[n + 1];
	//bool* flag_ = new bool[n + 1];
	bool* flag_shadow = new bool[n + 1];
	integer iadd = 0;
	integer nnzR = 1;
	integer iaddR = 0;
	integer nnz_aRP[maxlevel];
	bool bcontinue = true;
	bool* this_is_C_node = new bool[n + 1];
	bool* this_is_F_node = new bool[n + 1];

	// храним соседей новых F узлов
	const integer imaxpoolsize = 2000;
	integer pool_neighbour[imaxpoolsize];
	integer imax_pool_ind;

	while ((ilevel < maxlevel - 1) && (n_a[ilevel - 1] > 50) && (bcontinue)) {

		Maximumneighbourcount = -1;
		bmaxneighbourinfoactive = false;

		//if (ilevel > 1) {
		//if (n_a[ilevel - 2] == n_a[ilevel - 1]) break;
		//}

		if (ilevel > 1) {
			doublerealT procent = (100.0*(abs(n_a[ilevel - 1] - n_a[ilevel - 2]))) / (1.0*n_a[ilevel - 2]);
			if (procent<2.0) break;
		}

		if (((ilevel > 1) && (nnz_a[ilevel - 1] > nnz_a[ilevel - 2]))) {
			//break;
		}

#if doubleintprecision == 1
		// level info.
		if (ilevel == 2) {
			printf("ilevel=%lld", ilevel);
			printf("n_a[0]=%lld n_a[1]=%lld nnz_a[0]=%lld nnz_a[1]=%lld iadd=%lld\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
			if (debug_reshime) system("pause");
		}
		if (ilevel == 3) {
			printf("ilevel=%lld", ilevel);
			printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld iadd=%lld\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
			if (debug_reshime) system("pause");
		}
		if (ilevel == 4) {
			printf("ilevel=%lld", ilevel);
			printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld n_a[3]=%lld \n", n_a[0], n_a[1], n_a[2], n_a[3]);
			printf("nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld nnz_a[3]=%lld iadd=%lld\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}
#else
		// level info.
		if (ilevel == 2) {
			printf("ilevel=%d", ilevel);
			printf("n_a[0]=%d n_a[1]=%d nnz_a[0]=%d nnz_a[1]=%d iadd=%d\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
			if (debug_reshime) system("pause");
		}
		if (ilevel == 3) {
			printf("ilevel=%d", ilevel);
			printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d iadd=%d\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
			if (debug_reshime) system("pause");
		}
		if (ilevel == 4) {
			printf("ilevel=%d", ilevel);
			printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d n_a[3]=%d \n", n_a[0], n_a[1], n_a[2], n_a[3]);
			printf("nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d nnz_a[3]=%d iadd=%d\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}
#endif
		

		if (ilevel > 17) {
			printf("very big matrix (mesh). no programming.\n");
			system("pause");
			exit(1);
		}

		//nnzR = 1;

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		for (integer ii = n_a[ilevel - 1]; ii <= n; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		// сортировка исходной  А  по i.
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1], comparei);
		if (bquicktypesort) {
			QuickSort(Amat, /*n_a[ilevel - 1],*/ 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);
		}
		else {
			if (nnz_a[ilevel - 1] < heapsortsizelimit) {
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparei);
					}
					else {
						// quicksort
						qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparei);
					}
				}
				else {
					HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);
				}
				//QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);

			}
			else {
				Ak* Aorig = &Amat[1 + iadd];
				MergeSort(Aorig, nnz_a[ilevel - 1], comparei);
				Aorig = nullptr;
			}
		}

		// Экономично вычисляет полуширину ленты матрицы.
		integer band_size = -1;
		integer band_size_i = -1;
		/*
		for (integer i_1 = 1; i_1 <= n; i_1++) {
		flag[i_1] = false;
		}
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		if (!flag[Amat[ii].i]) {
		flag[Amat[ii].i] = true;
		integer istart = ii;
		while ((istart <= nnz_a[ilevel - 1] + iadd) && (Amat[istart].i == Amat[ii].i) && (Amat[istart].j != Amat[ii].i)) istart++;
		if ((istart <= nnz_a[ilevel - 1] + iadd) && (Amat[istart].i == Amat[ii].i)) {
		integer ifound = istart;
		istart = ii;
		while ((istart <= nnz_a[ilevel - 1] + iadd) && (Amat[istart].i == Amat[ii].i)) {

		if (Amat[istart].j != Amat[ii].i) {
		integer ij = BinarySearchAi(Amat, Amat[istart].j, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		while ((ij <= nnz_a[ilevel - 1] + iadd) && (Amat[ij].i == Amat[istart].j) && (Amat[ij].j != Amat[istart].j)) ij++;
		if ((ij <= nnz_a[ilevel - 1] + iadd) && (Amat[ij].i == Amat[istart].j) && (Amat[ij].j == Amat[istart].j)) {
		if (abs(ij - ifound) > band_size) band_size = abs(ij - ifound);
		if (abs(Amat[ij].j - Amat[ifound].i) > band_size_i) band_size_i = abs(Amat[ij].j - Amat[ifound].i);
		}
		}
		istart++;
		}
		}
		}
		}
		#if doubleintprecision == 1
				printf("bandsize=%lld\n", band_size);
		#else
				printf("bandsize=%d\n", band_size);
		#endif
		
		*/
		// заглушка для совместимости с устаревшим кодом.
		// 13 декабря 2015.
		band_size = 100;
		band_size_i = 100;
		printf("no band_size definition\n");
		//band_size = -1; // OFF band_size acselerator.

		// Создаём копию в Atemp, копия будет отсортирована по j.
		for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
			Atemp[i_1 - iadd] = Amat[i_1];
			Atemp[i_1 - iadd].ind = i_1; // запоминаем первоначальную позицию в А.
		}
		// Сортируем копию по j.
		// Мы сортируем по j, чтобы потом быстро искать по j.
		if (bqs) {
			if (bCounting_Sort) {
				// Сортировка с подсчётом за линейное время.
				Counting_Sort(Atemp, 1, nnz_a[ilevel - 1], indx_comparej);
			}
			else {
				// Быстрая сортировка Чарльза Хоара.
				qs(Atemp, 1, nnz_a[ilevel - 1], indx_comparej);
			}
		}
		else {
			HeapSort(Atemp, 1, nnz_a[ilevel - 1], comparej);
		}

		// Экономично вычисляет полуширину ленты матрицы.
		integer band_sizej = -1;
		for (integer i_1 = 1; i_1 <= n; i_1++) {
			flag[i_1] = false;
		}
		/*
		for (integer ii = 1; ii <= nnz_a[ilevel - 1]; ii++) {
		if (!flag[Atemp[ii].j]) {
		flag[Atemp[ii].j] = true;
		integer istart = ii;
		while ((istart <= nnz_a[ilevel - 1]) && (Atemp[istart].j == Atemp[ii].j) && (Atemp[istart].i != Atemp[ii].j)) istart++;
		if ((istart <= nnz_a[ilevel - 1]) && (Atemp[istart].j == Atemp[ii].j)) {
		integer ifound = istart;
		istart = ii;
		while ((istart <= nnz_a[ilevel - 1]) && (Atemp[istart].j == Atemp[ii].j)) {

		if (Atemp[istart].i != Atemp[ii].j) {
		integer ij = BinarySearchAj(Atemp, Atemp[istart].i, 1, nnz_a[ilevel - 1]);
		while ((ij <= nnz_a[ilevel - 1]) && (Atemp[ij].j == Atemp[istart].i) && (Atemp[ij].i != Atemp[istart].i)) ij++;
		if ((ij <= nnz_a[ilevel - 1]) && (Atemp[ij].j == Atemp[istart].i) && (Atemp[ij].i == Atemp[istart].i)) {
		if (abs(ij - ifound) > band_sizej) band_sizej = abs(ij - ifound);
		}
		}
		istart++;
		}
		}
		}
		}
		#if doubleintprecision == 1
				printf("bandsizej=%lld\n", band_sizej);
		#else
				printf("bandsizej=%d\n", band_sizej);
		#endif
		
		if ((band_size == -1) && (band_sizej == -1)) {
		bcontinue = false;
		// Судя по всему иерархия матриц уже построена.
		// Досрочный выход из этпа конструирования по причине
		// отсутствия связей в матрице... ?
		// Возможно эта неопределённость была причиной сбоя на реальном тестировании.
		break;
		}
		*/
		// Заглушки для совместимости с устаревшим кодом.
		band_sizej = 100;
		printf("no band size use. 12 dec 2015\n");
		//getchar();
		//band_size = -1; // OFF band_size acselerator.


		//if (ilevel == 2) {
		// Матрица второго уровня составлена совершенно неверно.
		// Возможно неверно было составлено произведение Галёркина RAP.
		//for (integer ii7 = 1 + iadd; ii7 <= iadd + nnz_a[ilevel - 1]; ii7++) {
		//if (Amat[ii7].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
#if doubleintprecision == 1
		//if (Amat[ii7].j > n_a[ilevel - 1]) {
		//	printf("%lld ",Amat[ii7].j);
		//}
		//	printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", ii7, Amat[ii7].i, ii7, Amat[ii7].j, ii7, Amat[ii7].aij);
		//system("pause");
		//}
		//}

		//for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		//	printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
		//if (ii % 20 == 0) getchar();
		//}
#else
		//if (Amat[ii7].j > n_a[ilevel - 1]) {
		//	printf("%d ",Amat[ii7].j);
		//}
		//	printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", ii7, Amat[ii7].i, ii7, Amat[ii7].j, ii7, Amat[ii7].aij);
		//system("pause");
		//}
		//}

		//for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		//	printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
		//if (ii % 20 == 0) getchar();
		//}
#endif
		

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}

		// позиция начала каждой строки в матрице.
		integer* row_startA = new integer[n_a[ilevel - 1] + 1];
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				flag[Amat[ii].i] = true;
				row_startA[Amat[ii].i] = ii;
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}


		// вычисляем для кадого узла число его соседей.
		integer* count_neighbour = new integer[n_a[ilevel - 1] + 1];
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			count_neighbour[ii] = 0; // нет соседей.
		}

		if (blite_and_quick_version)
		{
			// А при таком определении узел Дирихле имеет ноль соседей.
			// Соседей вычисляем на самой первой матрице А (самой левой).
			for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
				if (flag[Amat[ii].i] == false) {
					integer ic = -1;
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						ic++; //i,j
					}
					count_neighbour[Amat[ii].i] = ic;
					if (ic > Maximumneighbourcount) {
						Maximumneighbourcount = ic;
						icandidate_shadow = ii;
						bmaxneighbourinfoactive = true;
					}
					flag[Amat[ii].i] = true;
				}
			}
		}
		else {


			// При таком коде узел Дирихле тоже имеет соседа, сосед это 
			// внутренний узел который связан с этим узлом Дирихле.
			// Соседей вычисляем на самой первой матрице А (самой левой).
			for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
				if (flag[Amat[ii].i] == false) {
					integer ic = -1;
					integer cand[max_neighbour];
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						ic++; //i,j
						cand[ic] = Amat[is0].j;
					}
					integer len_neighbour = ic;
					// Найти столбец j который равен индексу Amat[ii].i
					//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
					//if (Amat[ii1].i != Amat[ii].i) {
					//	if (Amat[ii1].j == Amat[ii].i) {
					// j,i
					//		bool foundneighbour = false;
					//		for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
					//			if (Amat[ii1].j == cand[i_1]) foundneighbour = true;
					//		}
					//		if (!foundneighbour) {
					//			ic++;
					//			cand[ic] = Amat[ii1].j;
					//			len_neighbour++;
					//		}
					//	}
					//}
					//}
					// Ускоренная версия с бинарным поиском по j.
					integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
					for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == Amat[ii].i); ii1++) {
						if (Atemp[ii1].i != Amat[ii].i) {
							// j,i
							bool foundneighbour = false;
							for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
								if (Atemp[ii1].j == cand[i_1]) foundneighbour = true;
							}
							if (!foundneighbour) {
								ic++;
								cand[ic] = Atemp[ii1].j;
								len_neighbour++;
							}
						}
					}


					count_neighbour[Amat[ii].i] = ic;
					if (ic > Maximumneighbourcount) {
						Maximumneighbourcount = ic;
						icandidate_shadow = ii;
						bmaxneighbourinfoactive = true;
					}
					flag[Amat[ii].i] = true;
				}
			}
		}


		integer maxneighbour = 0;
		integer icandidate = 0;
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}
		// Находим узел с наибольшим числом соседей и запоминаем его.
		// Это первый встретившийся узел с наибольшим числом соседей.
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				if (count_neighbour[Amat[ii].i] > maxneighbour) {
					maxneighbour = count_neighbour[Amat[ii].i];
					icandidate = ii;
					if (bmaxneighbourinfoactive) {
						// организуем досрочный выход из цикла for.
						// Это должно сильно сокращать количество сканирований.
						if (maxneighbour == Maximumneighbourcount) break;
					}
				}
				flag[Amat[ii].i] = true;
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}


		// нужно выделить кто попал в coarse, а кто в этот раз попал в Fine Выделить всех кто соседствует
		// с новыми Fine увеличить им счётчик соседей.

		integer n_coarce = 1; // начальный номер C узла.
		nnzR = 1;

		const integer NULL_NEIGHBOUR = -1;
		integer vacant = NULL_NEIGHBOUR;
		bool bcontinue = true;

		// Построение C/F разбиения.
		//while (icandidate != 0)
		integer icountprohod = 0;
		// Мы будем заоминать с какой позиции начинаются ещё не помеченные узлы,
		// это сократит количество перебираемых элементов в поиске узла с максимальным 
		// количеством соседей.
		integer ibegining_start_index_found_maximum = 1 + iadd;
		// храним те узлы которые уже были пройдены при конструировании.
		bool *bmarkervisit = new bool[n + 1];
		// поначалу все узлы помечены как непосещенные.
		for (integer i_1 = 1; i_1 <= n; i_1++) bmarkervisit[i_1] = false;

		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
			Atemp2[i_1] = Amat[i_1 + iadd]; // copy
			Atemp2[i_1].ind = i_1 + iadd;
			Amat[i_1 + iadd].ind = i_1; // запоминаем обратную связь.
									 //if (ilevel == 2) {
#if doubleintprecision == 1
									 //printf("%e %lld %lld %lld\n", Atemp2[i_1].aij, Atemp2[i_1].i, Atemp2[i_1].j, Atemp2[i_1].ind);
#else
									 //printf("%e %d %d %d\n", Atemp2[i_1].aij, Atemp2[i_1].i, Atemp2[i_1].j, Atemp2[i_1].ind);
#endif
									
									 //getchar();
									 //}
		}

		// увеличение быстродействия достигается 
		// сокращением пределов сканирования
		// здесь хранится индекс начала сканирования flag.
		integer istartflag_scan = 1;

		//if (bmaxneighbourinfoactive  ) {
		//printf("bmaxneighbourinfoactive==true\n");
		//getchar();
		//}
		List* plist = nullptr;
		List* plist_current = nullptr;
		// if (bAVL) работа на основе АВЛ дерева.
		bool bAVL = true;
		bool bAVL_deb = false;
		node_AVL* root = 0;

		integer istat_old = 0;
		integer istat_new = 0;
		integer istat_new2 = 0;


		while (bcontinue)
		{



			imax_pool_ind = 1;
#if doubleintprecision == 1
			//printf("prohod count number %lld\n", icountprohod);
#else
			//printf("prohod count number %d\n", icountprohod);
#endif
			


			integer set[max_neighbour]; // не более 20 узлов в одном агрегате.
									// инициализация убрана потому что она не нужна и она сильно тормозит быстродействие.
									//for (integer js = 0; js < max_neighbour; js++) {
									//set[js] = NULL_NEIGHBOUR;
									//}
			integer ic = 0;

			integer ii = icandidate;
			if (flag[Amat[ii].i] == false) {
				// Вычисляем по немодифицированной матрице А (хранящейся слева).
				integer nnzRl = nnzR + iaddR;


				ic = 0; // Обязательная инициализация.
				set[ic] = Amat[ii].i;


				doublerealT max_vnediagonal = -1.0; // максимальное значение модуля вне диагонального элемента. 
											 // добавляем диагональный элемент.
											 // узел set[0]==Amat[is0].i.
											 // Нахождение значения максимального внедиагольного элемента, с 
											 // учётом того что даже узел Дирихле связан с одним внутренним узлом расчётной области.
				this_is_C_node[set[0]] = true;
				bmarkervisit[set[0]] = true;
				pool_neighbour[0] = ii;
				for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
					if (Amat[is0].j == set[0]) {

						nnzRl++;
						break;
					}
					else {
						if (fabs(Amat[is0].aij) > max_vnediagonal) {
							max_vnediagonal = fabs(Amat[is0].aij); //i,j
						}
					}
					if (!blite_and_quick_version) {
						// Этот цикл является добавочным.
						// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
						// Медленный линейный поиск.
						//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
						//if (Amat[ii1].i != set[0]) {
						//if (!flag[Amat[ii1].i]) {
						//	if (Amat[ii1].j == set[0]) {
						//		if (fabs(Amat[ii1].aij) > max_vnediagonal) {
						//			max_vnediagonal = fabs(Amat[ii1].aij); //j,i
						//		}
						//	}
						//}
						//}
						//}

						// Этот цикл является добавочным.
						// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
						// Ускоренная версия на основе двоичного поиска.
						integer ii2 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
						for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == set[0]); ii1++)
						{
							if (Atemp[ii1].i != set[0]) {
								if (!flag[Atemp[ii1].i]) {
									if (fabs(Atemp[ii1].aij) > max_vnediagonal) {
										max_vnediagonal = fabs(Atemp[ii1].aij); //j,i
									}
								}
							}
						}

					}
				}

				ic++;



				// если узел j ещё не был добавлен в агрегат.
				if (flag[Amat[ii].j] == false) {
					if ((Amat[ii].j != set[0]) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
						vacant = Amat[ii].j;
						pool_neighbour[imax_pool_ind] = ii;
						for (integer js = 0; js < ic; js++) {
							if (vacant == set[js]) {
								vacant = NULL_NEIGHBOUR;
							}
						}
						if (vacant != NULL_NEIGHBOUR) {
							set[ic] = vacant;
							imax_pool_ind++;
							if (imax_pool_ind > imaxpoolsize) {
								printf("pool index incorrupt: pool ind > pool_size\n");
								//getchar();
								system("pause");
							}
							nnzRl++;
							ic++;
						}
					}
				}
				integer iscan = ii + 1;
				while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set[0])) {
					// если узел j ещё не был добавлен в агрегат.
					if (flag[Amat[iscan].j] == false) {
						if ((Amat[iscan].j != set[0]) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
							vacant = Amat[iscan].j;
							pool_neighbour[imax_pool_ind] = iscan;
							for (integer js = 0; js < ic; js++) {
								if (vacant == set[js]) {
									vacant = NULL_NEIGHBOUR;
								}
							}
							if (vacant != NULL_NEIGHBOUR) {
								set[ic] = vacant;
								imax_pool_ind++;
								if (imax_pool_ind > imaxpoolsize) {
									printf("pool index incorrupt: pool ind > pool_size\n");
									//getchar();
									system("pause");
								}
								nnzRl++;
								ic++;

							}
						}
					}

					iscan++;

				} // while

				  // Это была учтена только связь i,j

				if (!blite_and_quick_version) {

					// Учёт свяи j,i
					//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
					//if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
					//if (!flag[Amat[ii1].i]) {
					//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
					//	vacant = Amat[ii1].i;
					//	for (integer js = 0; js < ic; js++) {
					//		if (vacant == set[js]) {
					//			vacant = NULL_NEIGHBOUR;
					//		}
					//	}
					//	if (vacant != NULL_NEIGHBOUR) {
					//		set[ic] = vacant; // j,i связь.

					//		nnzRl++;
					//		ic++;
					//	}
					//	}
					//}
					//}
					//}

					// Учёт связи j,i
					// Медленная версия на основе линейного поиска.
					//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
					//if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
					//if (!flag[Amat[ii1].i]) {
					//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
					//	vacant = Amat[ii1].i;
					//	for (integer js = 0; js < ic; js++) {
					//		if (vacant == set[js]) {
					//			vacant = NULL_NEIGHBOUR;
					//		}
					//	}
					//	if (vacant != NULL_NEIGHBOUR) {
					//		set[ic] = vacant; // j,i связь.

					//		nnzRl++;
					//		ic++;
					//	}
					//}
					//}
					//}
					//}

					// Учёт свяи j,i
					// Более быстрая версия на основе двоичного поиска.
					integer ii1 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
					for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1]) && (Atemp[ii2].j == set[0]); ii2++) {
						if ((Atemp[ii2].i != set[0]) && (!flag[Atemp[ii2].i])) {
							if (fabs(Atemp[ii2].aij) >= theta*max_vnediagonal) {
								vacant = Atemp[ii2].i;
								pool_neighbour[imax_pool_ind] = Atemp[ii2].ind; // Позиция в А.
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_NEIGHBOUR;
									}
								}
								if (vacant != NULL_NEIGHBOUR) {
									set[ic] = vacant; // j,i связь.
									imax_pool_ind++;
									if (imax_pool_ind > imaxpoolsize) {
										printf("pool index incorrupt: pool ind > pool_size\n");
										//getchar();
										system("pause");
									}
									nnzRl++;
									ic++;
								}
							}
						}
					}


				}


				for (integer isc = 1; isc < ic; isc++) {
					this_is_F_node[set[isc]] = true; // это только новые F узлы.
					bmarkervisit[set[isc]] = true;
				}




				// Помечаем узлы как включённые в агрегат.
				for (integer js = 0; js < ic; js++) {
					flag[set[js]] = true;
				}
				/*
				for (integer isc = 1; isc < n_a[ilevel - 1]; isc++) {
				if (flag[isc] == false) {
				// найти соседей узла isc
				integer ii1 = BinarySearchAi(Amat, isc, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//	if (Amat[ii1].i == isc) {
				integer ic2 = 0;
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				for (integer js = 1; js < ic; js++) {
				if (Amat[is0].j == set[js]) {
				ic2++;
				}
				}
				}
				count_neighbour[isc] += ic2;
				//	}
				//}
				// если среди них окажется из set[1..ic-1]
				// значит увеличиваем счётчик count_neighbour[isc] на единицу.
				}
				}
				*/

				//if (1) {
				if (band_size == -1) {

					// Нет никакой информации о ширине ленты.

					for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
						flag_shadow[i_1] = flag[i_1];
					}
					// Модификация счётчиков для соседей новых F узлов.
					// j есть новый F тогда i счетчик меняется. // ij связь.
					//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
					// Более быстрый вариант кода.
					for (integer ii_2 = ibegining_start_index_found_maximum; ii_2 <= nnz_a[ilevel - 1] + iadd; ii_2++) {
						integer ii1 = Atemp2[ii_2 - iadd].ind;
						integer isc = Amat[ii1].i;
						if ((flag_shadow[isc] == false) && ((!bmarkervisit[isc]))) {
							flag_shadow[isc] = true;
							integer ic2 = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								for (integer js = 1; js < ic; js++) {
									if (Amat[is0].j == set[js]) {
										ic2++;
									}
								}
							}
							count_neighbour[isc] += ic2;
							if (bmaxneighbourinfoactive) {
								// Обновляем информацию о максимальном количестве соседей.
								if (count_neighbour[isc] >= Maximumneighbourcount) {
									Maximumneighbourcount = count_neighbour[isc];
									icandidate_shadow = ii1;

									if (plist == nullptr) {
										plist = new List;
										plist->next = nullptr;
										plist->prev = nullptr;
										plist->ii = ii1;
										plist->count_neighbour = count_neighbour[isc];
										plist->i = isc;
										plist_current = plist;
									}
									else {
										List *ptemp = new List;
										ptemp->ii = ii1;
										ptemp->i = isc;
										ptemp->count_neighbour = count_neighbour[isc];
										ptemp->next = nullptr;
										ptemp->prev = plist_current;
										plist_current->next = ptemp;
										plist_current = ptemp;
										ptemp = nullptr;
									}
								}
							}
						}
					}

				}
				else {

					// Здесь в полной мере используется гипотеза локальности.
					// Она состоит в следующем: узел с порядковым номером в матрице ii 
					// имеет соседей лишь в окрестности +- band_size.


					// Ширина ленты равна band_size
					//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
					//flag_shadow[i_1] = flag[i_1];
					//}
					if (ic <= 0) {
						// Проверено ic не может быть нулём, а случай ic==1 
						// ничем не отличается от общего случая где прекрасно работает гипотеза локальности.
						// Выключим данную ветвь кода перенеся её в общий случай, т.к. данная 
						// ветвь очень медленная т.к. в ней не используется гипотеза локальности.
						// 7 ноября 2015.


						if (ic == 0) {
							printf("ic==0 iformation\n");
							//getchar();
							system("pause");
						}
						// На завершающей стадии соседей нет поэтому должен работать
						// код которому ничего неизвестно о ширине ленты.


						// Нет никакой информации о ширине ленты.

						for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
							flag_shadow[i_1] = flag[i_1];
						}
						// Модификация счётчиков для соседей новых F узлов.
						// j есть новый F тогда i счетчик меняется. // ij связь.
						//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
						// Более быстрый вариант кода.
						for (integer ii_2 = ibegining_start_index_found_maximum; ii_2 <= nnz_a[ilevel - 1] + iadd; ii_2++) {
							integer ii1 = Atemp2[ii_2 - iadd].ind;
							integer isc = Amat[ii1].i;
							if ((flag_shadow[isc] == false) && ((!bmarkervisit[isc]))) {
								flag_shadow[isc] = true;
								integer ic2 = 0;
								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									for (integer js = 1; js < ic; js++) {
										if (Amat[is0].j == set[js]) {
											ic2++;
										}
									}
								}
								count_neighbour[isc] += ic2;
								if (bmaxneighbourinfoactive) {
									// Обновляем информацию о максимальном количестве соседей.
									if (count_neighbour[isc] >= Maximumneighbourcount) {
										Maximumneighbourcount = count_neighbour[isc];
										icandidate_shadow = ii1;

										if (plist == nullptr) {
											plist = new List;
											plist->next = nullptr;
											plist->prev = nullptr;
											plist->ii = ii1;
											plist->count_neighbour = count_neighbour[isc];
											plist->i = isc;
											plist_current = plist;
										}
										else {
											List *ptemp = new List;
											ptemp->ii = ii1;
											ptemp->i = isc;
											ptemp->count_neighbour = count_neighbour[isc];
											ptemp->next = nullptr;
											ptemp->prev = plist_current;
											plist_current->next = ptemp;
											plist_current = ptemp;
											ptemp = nullptr;
										}
									}
								}
							}
						}

					}
					else {

						if (0) {
							// медленный вариант кода.


							for (integer js = 1; js < ic; js++) {
								for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
									flag_shadow[i_1] = flag[i_1];
								}

								integer istart = i_my_max(1 + iadd, pool_neighbour[js] - band_size - 1);
								integer iend = i_my_min(nnz_a[ilevel - 1] + iadd, pool_neighbour[js] + band_size + 1);
								// Ищем только среди ближайшего окружения вновь добавленного F узла.
								for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {
									integer isc = Amat[ii_2].i;
									if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
										flag_shadow[isc] = true;
										integer ic2 = 0;
										integer iend2 = i_my_min(nnz_a[ilevel - 1] + iadd, ii_2 + band_size + 1);
										integer istart2 = ii_2;
										while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
										istart2++;
										for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_2].i); is0++) {
											if (Amat[is0].j == set[js]) {
												ic2++;
											}
										}

										count_neighbour[isc] += ic2;
										if (bmaxneighbourinfoactive) {
											// Обновляем информацию о максимальном количестве соседей.
											if (count_neighbour[isc] >= Maximumneighbourcount) {
												Maximumneighbourcount = count_neighbour[isc];
												icandidate_shadow = ii_2;

												if (plist == nullptr) {
													plist = new List;
													plist->next = nullptr;
													plist->prev = nullptr;
													plist->ii = ii_2;
													plist->count_neighbour = count_neighbour[isc];
													plist->i = isc;
													plist_current = plist;
												}
												else {
													List *ptemp = new List;
													ptemp->ii = ii_2;
													ptemp->i = isc;
													ptemp->count_neighbour = count_neighbour[isc];
													ptemp->next = nullptr;
													ptemp->prev = plist_current;
													plist_current->next = ptemp;
													plist_current = ptemp;
													ptemp = nullptr;
												}
											}
										}
									}
								}
							}
						}
						else {

							// Алгоритм (4 декабря 2015). {Занимает 20% времени от времени алгоритма в 2D,
							// В 3D ситуация должна быть сильно хуже. }
							// 1. Сканируем все F которые соседи данного С на данном проходе.
							// 2. Для каждого фиксированного F сканируем его Bandsize_i окрестность.
							// 3. Если узел еще не был включён в агрегат то ищем всех соседей данного узла на предмет 
							// соседства с фиксированным набором F из пункта 1.


							/*
							for (integer js = 1; js < ic; js++) {
							//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
							//flag_shadow[i_1] = flag[i_1];
							//}

							//integer istart = i_my_max(1 + iadd, pool_neighbour[js] - band_size - 1);
							//integer iend = i_my_min(nnz_a[ilevel - 1] + iadd, pool_neighbour[js] + band_size + 1);

							//integer i3 = 1;
							//while ((i3 <= n_a[ilevel - 1]) && (row_startA[i3] < istart)) i3++;
							//integer i4 = n_a[ilevel - 1];
							//while ((i4 >= 1) && (row_startA[i4]>iend)) i4--;

							integer i3 = i_my_max(1, set[js] - band_size_i - 1);
							integer i4 = i_my_min(n_a[ilevel - 1], set[js] + band_size_i + 1);

							// Ищем только среди ближайшего окружения вновь добавленного F узла.
							//for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {

							// ищем соседа узла set[js].
							for (integer i5 = i3; i5 <= i4; i5++) {
							//integer isc = Amat[ii_2].i;
							integer ii_2 = row_startA[i5];
							//integer ii_2 = BinarySearchAi(Amat, i5, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer isc = i5;
							if (flag[isc] == false) {
							//flag_shadow[isc] = true;
							integer ic2 = 0;
							integer iend2 = i_my_min(nnz_a[ilevel - 1] + iadd, ii_2 + band_size + 1);
							integer istart2 = ii_2;
							while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
							istart2++;
							for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_2].i); is0++) {
							if (Amat[is0].j == set[js]) {
							ic2++;
							}
							}

							count_neighbour[isc] += ic2;
							if (bmaxneighbourinfoactive) {
							// Обновляем информацию о максимальном количестве соседей.
							if (count_neighbour[isc] >= Maximumneighbourcount) {
							Maximumneighbourcount = count_neighbour[isc];
							icandidate_shadow = ii_2;

							if (plist == nullptr) {
							plist = new List;
							plist->next = nullptr;
							plist->prev = nullptr;
							plist->ii = ii_2;
							plist->count_neighbour = count_neighbour[isc];
							plist->i = isc;
							plist_current = plist;
							}
							else {
							List *ptemp = new List;
							ptemp->ii = ii_2;
							ptemp->i = isc;
							ptemp->count_neighbour = count_neighbour[isc];
							ptemp->next = nullptr;
							ptemp->prev = plist_current;
							plist_current->next = ptemp;
							plist_current = ptemp;
							ptemp = nullptr;
							}
							}
							}
							}
							}
							}
							*/

							// Алгоритм (5 декабря 2015 revised) 
							// 1. Сканируем все F которые соседи данного С на данном проходе.
							// 2. Для каждого фиксированного F сканируем его "строчных" соседей.
							// 3. Если узел еще не был включён в агрегат то ищем всех соседей данного узла на предмет 
							// соседства с фиксированным набором F из пункта 1.
							// В этом коде нет очень длинных сканирований связанных с band_size, 
							// есть надежда что этот код существенно более эффективен в 3D.


							if (bAVL) {
								// 12 декабря 2015.
								// Надо удалить из АВЛ дерева C и F узлы.
								// Это удаление очищает АВЛ дерево и приводит его к
								// рабочему состоянию. Удаление несуществующих в дереве узлов
								// производится корректно. Удаление производится за логарифмическое
								// по основанию 2  время от количества элементов в дереве
								// сбалансированность дерева при этом сохраняется.
								for (integer js = 0; js < ic; js++) {
									data_BalTree ddel;
									ddel.i = set[js];
									ddel.count_neighbour = count_neighbour[set[js]];
									//ddel.ii = row_startA[ddel.i];
									root = remove_AVL(root, ddel);
									if (bAVL_deb)
									{
										printf("remove\n");
									}
								}
							}

							for (integer js = 1; js < ic; js++) {
								//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
								//flag_shadow[i_1] = flag[i_1];
								//}

								//integer istart = i_my_max(1 + iadd, pool_neighbour[js] - band_size - 1);
								//integer iend = i_my_min(nnz_a[ilevel - 1] + iadd, pool_neighbour[js] + band_size + 1);

								//integer i3 = 1;
								//while ((i3 <= n_a[ilevel - 1]) && (row_startA[i3] < istart)) i3++;
								//integer i4 = n_a[ilevel - 1];
								//while ((i4 >= 1) && (row_startA[i4]>iend)) i4--;

								//--->//	integer i3 = i_my_max(1, set[js] - band_size_i - 1);
								//---->//   integer i4 = i_my_min(n_a[ilevel - 1], set[js] + band_size_i + 1);

								// Ищем только среди ближайшего окружения вновь добавленного F узла.
								//for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {

								// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
								// элемент lsos_head;
								List *lsos = nullptr;
								List *lsos_head = nullptr;
								lsos = new List;
								lsos->prev = nullptr;
								lsos_head = lsos;
								{
									integer i_11 = set[js];
									integer ii_11 = row_startA[i_11];
									//integer iend2 = i_my_min(nnz_a[ilevel - 1] + iadd, ii_11 + band_size + 1);
									integer iend2 = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_11;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_11].i)) istart2--;
									istart2++;
									bool bvisitsos = false;
									for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
										if (flag[Amat[is0].j] == false) {
											lsos->next = nullptr;
											lsos->i = Amat[is0].j;
											lsos->ii = row_startA[lsos->i];
											// lsos->count_neighbour // не используется.
											List *newnodesos = new List;
											newnodesos->prev = lsos;
											lsos->next = newnodesos;
											newnodesos->next = nullptr;
											lsos = lsos->next;
											newnodesos = nullptr;
											bvisitsos = true;
										}
									}
									if (bvisitsos) {

										List *delsos = lsos;
										lsos = lsos->prev;
										lsos->next = nullptr;
										delsos->prev = nullptr;
										delete delsos;
										delsos = nullptr;
									}
									else {
										// Нет ни одного соседа
										lsos_head = nullptr;
										delete lsos;
										lsos = nullptr;
									}
								}

								lsos = lsos_head;
								// ищем соседа узла set[js].
								//for (integer i5 = i3; i5 <= i4; i5++) {
								while (lsos != nullptr) {


									//integer isc = Amat[ii_2].i;
									//integer ii_2 = row_startA[i5];
									//integer ii_2 = BinarySearchAi(Amat, i5, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									//integer isc = i5;

									integer isc = lsos->i;
									integer ii_2 = lsos->ii;


									//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
									//if (flag[isc] == false) {
									//flag_shadow[isc] = true;
									integer ic2 = 0;
									//integer iend2 = i_my_min(nnz_a[ilevel - 1] + iadd, ii_2 + band_size + 1);
									integer iend2 = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									istart2++;
									for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_2].i); is0++) {
										if (Amat[is0].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.count_neighbour = count_neighbour[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									count_neighbour[isc] += ic2;
									data_BalTree dadd;
									dadd.count_neighbour = count_neighbour[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;
									if (bmaxneighbourinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_neighbour[isc] >= Maximumneighbourcount) {
											Maximumneighbourcount = count_neighbour[isc];
											icandidate_shadow = ii_2;
										}

										// Добавляем соседа в любом случае
										// позволило существенным образом 
										// ускорить алгоритм. Если раньше 
										// old = 48595  | 21229
										// new = 433315 | 63031
										// new2 = 19434 | 3698
										// и основное время уходило на old
										// то теперь
										// old = 1449 | 1466
										// new = 472600 | 64525
										// new2= 56544 | 18431
										// Время решения 3D задачи с 1M неизвестными 
										// сократилось с 6мин 48с до 4мин 45с.

										if (bAVL) {
											// добавляем элемент в АВЛ дерево,
											// причём если элемент уже находился в дереве то он модифицируется.
											// 12 декабря 2015.
											// Добавление узла происходит за логарифмическое по основанию 2 время,
											// причём после добавления дерево остаётся сбалансированным.
											// Г.М. Адельсон-Вельский и Е.М. Ландис 1962.
											root = insert_and_modify(root, dadd, dsearch);
											if (bAVL_deb)
											{
												printf("insert and modify\n");
											}
										}
										else {
											// Добавляем элемент в список.

											if (plist == nullptr) {
												plist = new List;
												plist->next = nullptr;
												plist->prev = nullptr;
												plist->ii = ii_2;
												plist->count_neighbour = count_neighbour[isc];
												plist->i = isc;
												plist_current = plist;
											}
											else {
												List *ptemp = new List;
												ptemp->ii = ii_2;
												ptemp->i = isc;
												ptemp->count_neighbour = count_neighbour[isc];
												ptemp->next = nullptr;
												ptemp->prev = plist_current;
												plist_current->next = ptemp;
												plist_current = ptemp;
												ptemp = nullptr;
											}
										}

									}
									//}
									lsos = lsos->next;
								}

								// Уничтожение lsos
								// Список постепенно уничтожается с головы.
								lsos = lsos_head;
								while (lsos != nullptr) {
									lsos_head = lsos_head->next;
									if (lsos_head != nullptr) {
										lsos_head->prev = nullptr;
									}
									lsos->next = nullptr;
									delete lsos;
									lsos = lsos_head;
								}


							}



						}
					}

				}




				n_coarce++; // Увеличено количество С узлов.

							// Один агрегат создан.

			} // узел не был ещё включён в агрегат.



			bcontinue = false;
			for (integer i_1 = istartflag_scan; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (flag[i_1] == false) {
					bcontinue = true;
					istartflag_scan = i_1; // сокращаем пределы сканирования.
					break; // досрочный выход из цикла for.
						   //if (maxneighbour == -1) {
#if doubleintprecision == 1
						   //printf("ERROR!!!!  i_1=%lld\n", i_1);
#else
						   //printf("ERROR!!!!  i_1=%d\n", i_1);
#endif
						  
						   //system("pause");
						   //}
				}
			}

			// Вычисление узла с максимальным количеством соседей.
			maxneighbour = -1;
			icandidate = 0;


			// TODO 6 november

			const integer ipool_size_limit = 128000;
			integer ipool[ipool_size_limit];
			integer isize_p = -1;
			for (integer isc = 0; isc < ic; isc++) {
				//integer ii_s = pool_neighbour[isc];// позиция в А.
				integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
				integer ii_c = ii_s;
				//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
				//ii_c++;
				// Вся строка матрицы начиная с позиции ii_c должна быть помещена в Atemp2;
				while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
					integer icandidateq = ii_c;
					bool found1 = false;
					for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
						if (i_7 < ipool_size_limit) {
							if (ipool[i_7] == icandidateq) {
								found1 = true;
							}
						}
						else {
#if doubleintprecision == 1
							printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
#else
							printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
#endif
							
							system("pause");
							exit(1);
						}
					}
					// элемент в списке не обнаружен, поэтому запомним индекс.
					if (found1 == false) {
						isize_p++;
						if (isize_p < ipool_size_limit) {
							ipool[isize_p] = icandidateq;
						}
						else {
#if doubleintprecision == 1
							printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
#else
							printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
#endif
							
							system("pause");
							exit(1);
						}
					}
					ii_c++;
				}
			}
			// ipool хранит кандидатов для добавления в Atemp2.
			for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
				// Позиции элементов в А остаются на месте, поэтому коллизий быть не должно.

				Ak temp = Atemp2[ibegining_start_index_found_maximum - iadd + i_7];
				Atemp2[ibegining_start_index_found_maximum - iadd + i_7] = Amat[ipool[i_7]];
				Atemp2[ibegining_start_index_found_maximum - iadd + i_7].ind = ipool[i_7];

				Atemp2[Amat[ipool[i_7]].ind] = temp;
				Amat[temp.ind].ind = Amat[ipool[i_7]].ind;
				Amat[ipool[i_7]].ind = ibegining_start_index_found_maximum - iadd + i_7;
			}
			ibegining_start_index_found_maximum += isize_p + 1;

			if (bAVL) {
				if (bAVL_deb)
				{
					printf("found max");
				}
				// Данный код чрезвычайно компактен.
				bmaxneighbourinfoactive = true;
				// Надо найти максимальный элемент в АВЛ дереве.
				node_AVL* emax = 0;
				emax = findmax(root);
				if (emax != 0) {
					if (bAVL_deb)
					{
						print_AVL(root);
						system("pause");
					}

					// 23 jan 2016
					//icandidate = emax->key.ii;
					icandidate=BinarySearchAi(Amat, emax->key.i, 1 + iadd, iadd + nnz_a[ilevel - 1]);
					//icandidate = row_startA[emax->key.i];
					emax = 0;
					if (bAVL_deb)
					{
						printf("find max\n");
					}
				}
				else {
					root = 0;
					icandidate = 0;
					maxneighbour = -1;
					bcontinue = false;

				}

			}
			else {

				// Судя по тестам в 3D этот кусок кода очень тормозит,
				// поэтому было введено АВЛ дерево чтобы существенно улучшить характеристики 
				// быстродействия.

				// Мы будем делать досрочный выход из цикла for 19 раз из 20,
				// и лишь один раз обновлять информацию о максимальном количестве соседей.
				// Данная модификация придумана 17 октября 2015 года.
				// Эта эвристика обеспечила ускорение на 8% от суммарного времени исполнения 
				// всего алгоритма.
				if (icountprohod % 200 == 0) {



					// TODO 6november start delete code
					/*
					// Сначала пишем те узлы которые были посещены.
					integer i_2 = 1;
					for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
					if (bmarkervisit[Amat[i_1].i]) {
					Atemp2[i_2] = Amat[i_1];
					Atemp2[i_2].ind = i_1; // обязательно запоминаем первоначальный индекс.
					i_2++;
					}
					}
					// Потом пишем все другие узлы.
					for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
					if (!bmarkervisit[Amat[i_1].i]) {
					Atemp2[i_2] = Amat[i_1];
					Atemp2[i_2].ind = i_1; // обязательно запоминаем первоначальный индекс.
					i_2++;
					}
					}
					// TODO 6 november end delete code.
					*/

					/* // 7 novemver 2015.
					bool bfirst_loc = true; // нам нужно именно первое значение позиции.

					for (integer i_2 = ibegining_start_index_found_maximum; i_2 <= nnz_a[ilevel - 1] + iadd; i_2++) {
					integer  i_1 = i_2 - iadd;


					if (!bmarkervisit[Atemp2[i_1].i]) {
					// Мы запоминаем стартовую позицию начиная с которой начинаются ещё
					// непомеченные узлы.
					if (bfirst_loc) {
					ibegining_start_index_found_maximum = i_1 + iadd;
					bfirst_loc = false;
					break;
					#if doubleintprecision == 1
						//printf("diagnostic =%lld\n",i_1);
					#else
						//printf("diagnostic =%d\n",i_1);
					#endif
					
					//getchar();
					}
					}
					}
					*/


					if ((flag[Amat[icandidate_shadow].i] == false) && (count_neighbour[Amat[icandidate_shadow].i] == Maximumneighbourcount)) {
						// Дело в том что мы уже нашли узел с наибольшим числом соседей прямо в ходе
						// модификации счётчиков соседей новых F узлов.
						// просто сразу это было не очевидно, поэтому мы организовали поиски.
						icandidate = icandidate_shadow;
						istat_new++;
					}
					else {

						istat_old++;

						for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
							flag_shadow[i_1] = flag[i_1];
						}


						for (integer i_2 = ibegining_start_index_found_maximum; i_2 <= nnz_a[ilevel - 1] + iadd; i_2++) {
							integer  i_1 = i_2 - iadd;



							if (flag_shadow[Atemp2[i_1].i] == false) {
								if (count_neighbour[Atemp2[i_1].i] > maxneighbour) {
									maxneighbour = count_neighbour[Atemp2[i_1].i];
									//icandidate = i_1;
									icandidate = Atemp2[i_1].ind;
								}
								flag_shadow[Atemp2[i_1].i] = true;
							}
						}

						Maximumneighbourcount = maxneighbour;
						bmaxneighbourinfoactive = true;
					}

				}
				else {

					if ((flag[Amat[icandidate_shadow].i] == false) &&
						(count_neighbour[Amat[icandidate_shadow].i] == Maximumneighbourcount)) {
						// Дело в том что мы уже нашли узел с наибольшим числом соседей прямо в ходе
						// модификации счётчиков соседей новых F узлов.
						// просто сразу это было неочевидно поэтому мы организовали поиски.
						icandidate = icandidate_shadow;

						istat_new++;
					}
					else {

						//List* pp7=nullptr;
						bool found_candidate = false;
						//while (found_candidate == false) {
						if (plist != nullptr) {

							List *phvost = plist_current;
							bool bflag11 = false;
							bool bhvostready = true;

							// Сканируем короткий пулл кандидатов
							//while (plist_current != nullptr) {
							while ((plist_current != nullptr) && (!(((flag[Amat[plist_current->ii].i] == false) &&
								(count_neighbour[Amat[plist_current->ii].i] == Maximumneighbourcount))))) {
								// первый элемент удалён и на него ссылаться нельзя.

								//while (plist_current != nullptr) {
								//	if (flag[Amat[plist_current->ii].i]==true) {
								// удаляем только соседей которые уже были включены в агломераты ранее.
								if (flag[Amat[plist_current->ii].i]  ) {
									if (bflag11 == false) bhvostready = false;

									List* temp;
									temp = plist_current;
									plist_current = plist_current->prev;
									if (plist_current != nullptr) {
										plist_current->next = temp->next;
										if (temp->next != nullptr) {
											List* temp2 = temp->next;
											temp2->prev = plist_current;
										}
									}
									temp->prev = nullptr;
									temp->next = nullptr;
									if (plist != temp) {
										delete temp;
									}
									else {
										plist = nullptr;
										delete temp;
									}
								}
								else {
									// можно ссылаться на первый элемент.
									bflag11 = true;
									// проматываем.
									// соседа который ещё не был помечен (включён в агломерат),
									// но у которого число соседей меньше максимального.
									plist_current = plist_current->prev;
								}
							}
							//if (plist_current != nullptr) {
							//pp7 = plist_current;
							//plist_current = plist_current->prev;
							//}
							//}
							//plist_current = pp7;
							if (plist != nullptr) {
								if (plist_current != nullptr) {
									phvost = nullptr;
									icandidate_shadow = plist_current->ii;
									icandidate = icandidate_shadow;
									found_candidate = true;
									while (plist_current->next != nullptr) plist_current = plist_current->next;
								}
								else {
									plist_current = plist;
									if (bhvostready) {
										plist_current = phvost;
										phvost = nullptr;
										// перемотка ненужна
									}
									else {
										phvost = nullptr;
										while (plist_current->next != nullptr) plist_current = plist_current->next;
									}
								}
							}
							// Рабочий вариант.
							// Определение максимума (максимального числа соседей).
							// Данное сканирование ожидает быть существенно более быстрым на глубоких уровнях
							// вложенности т.к. мы сканируем не все узлы а лишь всех соседей еще не помещенных в агрегаты.
							List* pscan = plist_current;
							integer icountsosmax = -1; // Максимальное число соседей.
							integer candidatestart = -1;
							if (pscan != nullptr) {
								while (pscan != nullptr) {
									if (icountsosmax < pscan->count_neighbour) {
										icountsosmax = pscan->count_neighbour;
										candidatestart = pscan->ii;
									}
									pscan = pscan->prev;
								}
								if (candidatestart != -1) {
									found_candidate = true;
									icandidate = candidatestart;
								}
							}
							// Окончание экспирементального добавления.

						}
						//if (found_candidate == false) {
						//Maximumneighbourcount--;
						//if (Maximumneighbourcount < 3) break; // досрочный выход из прерывателя.
						//}
						//}


						/*
						// TODO 09_11_2015
						bool found_candidate = false;
						if (plist != nullptr) {
						// Сканируем короткий пулл кандидатов.
						//while ((plist_current != nullptr) && (!(((flag[Amat[plist_current->ii].i] == false) &&
						//	(count_neighbour[Amat[plist_current->ii].i] == Maximumneighbourcount))))) {
						while (plist_current != nullptr) {
						if (flag[Amat[plist_current->ii].i]  ) {
						// удаляем
						List* temp;
						temp = plist_current;
						plist_current = plist_current->prev;
						if (plist_current != nullptr) {
						plist_current->next = nullptr;
						}
						temp->prev = nullptr;
						if (plist != temp) {
						delete temp;
						}
						else {
						plist = nullptr;
						delete temp;
						}
						}
						}
						if (plist_current != nullptr) {
						icandidate_shadow = plist_current->ii;
						icandidate = icandidate_shadow;
						found_candidate = true;
						}
						}
						*/

						if (found_candidate == false)
						{
							istat_old++;
							for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
								flag_shadow[i_1] = flag[i_1];
							}




							// если это не так мы всегда можем запустить старый проверенный код.

							//bool bfirst_loc = true; // нам нужно именно первое значение позиции.

							integer min_stat = 10000000;
							integer max_stat = -1;

							for (integer i_2 = ibegining_start_index_found_maximum; i_2 <= nnz_a[ilevel - 1] + iadd; i_2++) {


								integer i_1 = i_2 - iadd;
								// слишком частые коректировки начала списка замедляют код вдвое.
								// мы будем коректировать начальную позицию раз в 20 раз.
								//if (!bmarkervisit[Atemp2[i_1].i]) {
								// Мы запоминаем стартовую позицию начиная с которой начинаются ещё
								// непомеченные узлы.
								//if (bfirst_loc) {
								//	ibegining_start_index_found_maximum = i_1+iadd;
								//	bfirst_loc = false;
								//}
								//}

								if (flag_shadow[Atemp2[i_1].i] == false) {

									if (count_neighbour[Atemp2[i_1].i] < min_stat) {
										min_stat = count_neighbour[Atemp2[i_1].i];
									}
									if (count_neighbour[Atemp2[i_1].i] > max_stat) {
										max_stat = count_neighbour[Atemp2[i_1].i];
									}


									if (count_neighbour[Atemp2[i_1].i] > maxneighbour) {
										maxneighbour = count_neighbour[Atemp2[i_1].i];
										//icandidate = i_1;
										// icandidate номер элемента в матрице А отвечающий за найбольшее число соседей.
										icandidate = Atemp2[i_1].ind;
										if (bmaxneighbourinfoactive) {
											// Организуем досрочный выход из цикла,
											// это длжно ускорить построение C/F разбиения.
											if (maxneighbour == Maximumneighbourcount) break;
										}

									}
									flag_shadow[Atemp2[i_1].i] = true;
								}
							}

#if doubleintprecision == 1
							//printf("%lld %lld", Maximumneighbourcount, max_stat);
#else
							//printf("%d %d", Maximumneighbourcount, max_stat);
#endif
							
							//system("pause");
							Maximumneighbourcount = max_stat;
#if doubleintprecision == 1
							//printf("min=%lld max=%lld M=%lld\n", min_stat, max_stat, Maximumneighbourcount);
#else
							//printf("min=%d max=%d M=%d\n", min_stat, max_stat, Maximumneighbourcount);
#endif
							
							//system("pause");

							// statistics
							//integer i_11 = 0;
							//for (integer i_10 = 1; i_10 <= n_a[ilevel - 1]; i_10++) {
							//if (flag[i_10] == false) i_11++;
							//}
#if doubleintprecision == 1
							//printf("%lld %lld\n", Amat[icandidate_shadow].i, icandidate); // 99%
#else
							//printf("%d %d\n", Amat[icandidate_shadow].i, icandidate); // 99%
#endif
							
							//printf("procent %f\n",(float)(100*i_11/n_a[ilevel-1]));
							//getchar();
						}
						else {
							istat_new2++;
						}

					}
				}

			}

#if doubleintprecision == 1
			//printf("maximum number of neighbour=%lld\n",maxneighbour);
#else
			//printf("maximum number of neighbour=%d\n",maxneighbour);
#endif
			
			if (maxneighbour == -1) if (debug_reshime) system("pause");
			//getchar();

			if ((icandidate == 0) && (maxneighbour == -1)) {
				bcontinue = false;
			}

			if (bAVL_deb)
			{
				print_AVL(root);
				system("pause");
			}

			icountprohod++;

		} // Построение C/F разбиения. создано.

		delete[] bmarkervisit;
		// Уничтожение памяти из по пула кандидатов.
		if (plist != nullptr) {

			while (plist != nullptr) {
				plist_current = plist;
				plist->prev = nullptr;
				plist = plist->next;
				plist_current->next = nullptr;
				plist->prev = nullptr;
				delete plist_current;
			}
		}

		if (bAVL)
		{
			// Освобождение оперативной памяти из под АВЛ дерева.
			// 12 декабря 2015.
			clear_AVL(root);
			root = 0;
		}


		// В методе стандартной интерполяции присутствует шаг уменьшения разреженности,
		// для того чтобы правильно аппроксимировать все F переменные C переменными надо
		// увеличить количество С переменных.
		integer ipromah = 0;
		integer ipromah_one = 0;
		bool bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]  ) {
				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);

				bool bvisit = false;
				for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
					if (Amat[is0].j != Amat[i_2].i) {
						bvisit = true;
						if (this_is_C_node[Amat[is0].j]  ) {
							icsos++;
						}
						else {
							ipromah++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.
											   // Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
				if ((icsos == 0) && (bvisit)) {

					// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
					// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
					// поглощены агломератами внутренних узлов и всё было впорядке.
					// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

					// Нет С соседей, этот узел станет С узлом.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					// F node стал C_node!!! Идея стандартной интерполяции 
					// приводит к уменьшению разреженности оператора Галёркина.
					bweSholdbeContinue = true;
				}

			}

			if (bweSholdbeContinue) {
				printf(" prohod succseful\n");
			}
			else {
				printf("prohod empty\n");
			}

		}

#if doubleintprecision == 1
		printf("old=%lld, new1=%lld, new2=%lld\n", istat_old, istat_new, istat_new2);
#else
		printf("old=%d, new1=%d, new2=%d\n", istat_old, istat_new, istat_new2);
#endif
		
		//system("pause");

		// Нужно корректно обработать узлы Дирихле,
		// Если F узел окажется узлом Дирихле без соседей то его надо сделать С узлом,
		// Но узнать такой узел можно лишь в процессе выполнения алгоритма дальше по ходу исполнения.
		// Поэтому может потребоваться вернуться и начать заново (обратная связь).


		integer* C_numerate = new integer[n_a[ilevel - 1] + 1];
		integer icounter = 1;
		integer icount1;
		integer numberofcoarcenodes;
		doublerealT* ap_coarse = nullptr;

		bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) { n_coarce++; }
			n_coarce--;


			// debug
			// проверка качества C/F разбиения.
			//doublerealT* exp1 = new doublerealT[n_a[ilevel - 1] + 1];
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) exp1[i_1] = 0.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) exp1[i_1] = 2.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]) exp1[i_1] = 1.0;
			//exporttecplot(exp1,n);
			//delete[] exp1;

			//printf("export ready");

			//system("pause");


			// C/F разбиение построено, самое время построить оператор интерполяции.
			// потом найти оператор проекции, как транспонированный оператор интерполяции.
			// Всё завершает построение матрицы нового сеточного уровня и можно запускать новый уровень.

			// Построение оператора интерполяции: 
			// coarse 2 fine.
			//P*coarse==fine

			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) C_numerate[i_1] = 0;
			icounter = 1;
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]  ) {
#if doubleintprecision == 1
				//printf("C ind= %lld", i_1); getchar();
#else
				//printf("C ind= %d", i_1); getchar();
#endif
				
				C_numerate[i_1] = icounter;
				icounter++;
			}




			// C_numerate - перенумерация на множестве Coarse узлов.
			// Построение пролонгации для узлов которые составляют грубую сетку.
			icount1 = 1 + iaddR; // nnz_R
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]  ) {
				P[icount1].aij = 1.0;
				P[icount1].i = C_numerate[i_1]; // coarse number
				P[icount1].j = i_1; // fine number.
				icount1++;
			}

			// значение icount1 нужно далее.НЕ трогать !!!.
			numberofcoarcenodes = icount1 - 1 - iaddR;

			// Для модификации R  надо transpose(P)/ap.
#if doubleintprecision == 1
			printf("countloc=%lld\n", numberofcoarcenodes);
#else
			printf("countloc=%d\n", numberofcoarcenodes);
#endif
			
			if (debug_reshime) system("pause");

			if (ap_coarse!=nullptr) {
				delete[] ap_coarse;
				ap_coarse = nullptr;
			}
			ap_coarse = new doublerealT[numberofcoarcenodes + 1];
			if (ap_coarse == nullptr) {
				printf("error cannot memory allocate.");
				system("pause");
			}
			ap_coarse[0] = 0.0;
			//integer countloc = 1;
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_C_node[i8]  ) {
				integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				//integer ii2 = ii1 - 1;
				//if ((ii2 >= 1 + iadd) && (Amat[ii2].i == Amat[ii1].i)) {
				//printf("koren zla\n"); // бинарный поиск должен гарантированно находить самого левого представителя.
				//getchar();
				//}
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
#if doubleintprecision == 1
					//printf("i=%lld j=%lld Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#else
					//printf("i=%d j=%d Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#endif
					
					if (Amat[is0].j == Amat[ii1].i) {
						//if (countloc > icount1 - 1) { printf("system error\n"); getchar(); }
						if (fabs(Amat[is0].aij) > RealMAXIMUM) {
							printf("perepolnenie error!");
							//getchar();
							system("pause");
						}
						ap_coarse[C_numerate[i8]] = fabs(Amat[is0].aij);
						//printf("find = %e", fabs(Amat[is0].aij));
					}
				}
				//printf("\n");
				//getchar();

				//countloc++;
			}

			// верно 2 октября.
			//for (integer i25 = 1; i25 < icount1; i25++) {
			//if (ap_coarse[i25]>1) {
#if doubleintprecision == 1
			//printf("ap_coarse[%lld]=%e\n", i25, ap_coarse[i25]);
#else
			//printf("ap_coarse[%d]=%e\n", i25, ap_coarse[i25]);
#endif
			
			//getchar();
			//}
			//}

			ipromah = 0;
			ipromah_one = 0;
			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполяции а значит и оператора Галёркина.
				doublerealT maxelem_threshold = -1.0;
				integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j]  ) {
							if (fabs(Amat[is0].aij) > maxelem_threshold) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
						}
					}
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;

				doublerealT sumP = 0.0;
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j]  ) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
							icsos++;
							//}
						}
						else {
							ipromah++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.



				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j]  ) {


							if (fabs(sumP) < RealZERO) {
								printf("error interpolation zero diagonal sumP.\n");
								printf("Fnode all neighbour is F");
								//system("pause");
								printf("i8 is Dirichlet node\n");
								this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								//exit(1);
								// здесь нужна непрямая интерполяция.
							}
							else {

								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								P[icount1].j = i8;
								P[icount1].i = C_numerate[Amat[is0].j];
								P[icount1].aij = fabs(Amat[is0].aij) / sumP;
								icount1++;
								//}

							}

						}
					}
				}


			}

			if (bweSholdbeContinue) {
				delete[] ap_coarse;
				ap_coarse = nullptr;
				printf("obratnaq svqz restart...\n");
			}

		}

		nnzR = icount1 - iaddR;



		// нужно определить nnzR количество ненулевых элементов в матрице R и P.

		// оператор restriction построен и он упорядочен по i.
		// число ненулевых элементов nnzR-1.
		// P=Copy(R);
		for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
			R[ii] = P[ii];
			//if ((ilevel == 2) && (ii >= iaddR + nnzR - 1-30)) {
#if doubleintprecision == 1
			//printf("ii=%lld aij=%e, i=%lld j=%lld\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#else
			//printf("ii=%d aij=%e, i=%d j=%d\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#endif
			
			//getchar();
			//}
		}

		// heapsort(P,key==j,iaddR+1,iaddR+nnzR - 1, comparej);
		if (bquicktypesort) {
			QuickSort(P, 1 + iaddR, iaddR + nnzR - 1, comparej);
		}
		else {
			if (bqs) {
				if (bCounting_Sort) {
					Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
				}
				else {
					// Быстрая сортировка Хоара.
					qs(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
				}
			}
			else {
				HeapSort(P, 1 + iaddR, iaddR + nnzR - 1, comparej);
			}
		}

		/*
		if (bquicktypesort) {
		QuickSort(R,  1 + iaddR, iaddR + nnzR - 1, comparej);
		}
		else {
		HeapSort(R, n_a[ilevel - 1], 1 + iaddR, iaddR + nnzR - 1, comparej);
		}

		printf("start now\n");
		for (integer ii5 = 1 + iaddR; ii5 <= iaddR + nnzR - 1; ii5++) {
		#if doubleintprecision == 1
			printf("R[%lld].i=%lld R[%lld].j=%lld R[%lld].aij=%e\n", ii5, R[ii5].i, ii5, R[ii5].j, ii5, R[ii5].aij);
		#else
			printf("R[%d].i=%d R[%d].j=%d R[%d].aij=%e\n", ii5, R[ii5].i, ii5, R[ii5].j, ii5, R[ii5].aij);
		#endif
		
		system("pause");
		}
		*/
		// где то надо разделить на ap, т.к. 
		// R=P/ap.


		// heapsort(R,key==i,iaddR+1,iaddR+nnzR - 1, comparei);
		if (bquicktypesort) {
			QuickSort(R, 1 + iaddR, iaddR + nnzR - 1, comparei);
		}
		else {
			if (bqs) {
				if (bCounting_Sort) {
					Counting_Sort(R, 1 + iaddR, iaddR + nnzR - 1, indx_comparei);
				}
				else {
					qs(R, 1 + iaddR, iaddR + nnzR - 1, indx_comparei);
				}
			}
			else {
				HeapSort(R, 1 + iaddR, iaddR + nnzR - 1, comparei);
			}
		}

#if doubleintprecision == 1
		printf("first level size n=%lld numberofcoarcenodes=%lld\n", n, numberofcoarcenodes);
#else
		printf("first level size n=%d numberofcoarcenodes=%d\n", n, numberofcoarcenodes);
#endif
		
		if (debug_reshime) system("pause");
		for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			flag[i_1] = false; // init flag.
		}

		for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
			if (flag[R[i_1].i] == false)
			{
				for (integer i_2 = i_1; (i_2 <= iaddR + nnzR - 1) && (R[i_2].i == R[i_1].i); i_2++) {
					if ((R[i_1].i<1) || (R[i_1].i>numberofcoarcenodes)) {
#if doubleintprecision == 1
						printf("error R[%lld].i=%lld\n", i_1, R[i_1].i);
#else
						printf("error R[%d].i=%d\n", i_1, R[i_1].i);
#endif
						
						system("pause");
					}
					if (fabs(ap_coarse[R[i_1].i]) < divisionZERO) {
						printf("error division by zero\n");
						system("pause");
					}
					doublerealT delitel;
					if (ap_coarse[R[i_1].i] > 1.0) {
						// internal node
						delitel = 0.5*ap_coarse[R[i_1].i];
					}
					else {
						// Dirichlet
						delitel = ap_coarse[R[i_1].i];
					}
					R[i_2].aij = R[i_2].aij / (delitel);
				}
				flag[R[i_1].i] = true;
			}
		}


		delete[] ap_coarse;


		// debug.
		//for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
#if doubleintprecision == 1
		//printf("R[%lld].i=%lld R[%lld].j=%lld R[%lld].aij=%e\n", i_1, R[i_1].i, i_1, R[i_1].j, i_1, R[i_1].aij);
#else
		//printf("R[%d].i=%d R[%d].j=%d R[%d].aij=%e\n", i_1, R[i_1].i, i_1, R[i_1].j, i_1, R[i_1].aij);
#endif
		
		//system("pause");
		//}


		//for (integer i_1 = iaddR + nnzR - 1-20; i_1 <= iaddR + nnzR - 1; i_1++) {
#if doubleintprecision == 1
		//printf("R[%lld].i=%lld R[%lld].j=%lld R[%lld].aij=%e\n", i_1, R[i_1].i, i_1, R[i_1].j, i_1, R[i_1].aij);
#else
		//printf("R[%d].i=%d R[%d].j=%d R[%d].aij=%e\n", i_1, R[i_1].i, i_1, R[i_1].j, i_1, R[i_1].aij);
#endif
		
		//system("pause");
		//}



		//for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
#if doubleintprecision == 1
		//printf("P[%lld].i=%lld P[%lld].j=%lld P[%lld].aij=%e\n", i_1, P[i_1].i, i_1, P[i_1].j, i_1, P[i_1].aij);
#else
		//printf("P[%d].i=%d P[%d].j=%d P[%d].aij=%e\n", i_1, P[i_1].i, i_1, P[i_1].j, i_1, P[i_1].aij);
#endif
		
		//system("pause");
		//}


		// Сортировка А по j.
		//heapsort(Amat, key=j*n_a[ilevel - 1] + i, 1, nnz_a[ilevel - 1], comparej);
		if (bquicktypesort) {
			QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, comparej);
		}
		else {
			if (nnz_a[ilevel - 1] < heapsortsizelimit) {
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparej);
					}
					else {
						qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparej);
					}
				}
				else {
					HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, comparej);
				}
			}
			else {
				Ak* Aorig = &Amat[1 + iadd];
				MergeSort(Aorig, nnz_a[ilevel - 1], comparej);
				Aorig = nullptr;
			}
		}

		// Нахождение матрицы грубосеточного уровня:
		// Acorse=R*Afine*P;
		// часть 1: R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]
		/*
		integer istartAnew = nnz_a[ilevel - 1] + 1+iadd;
		for (integer jstr = 1; jstr <= n_a[ilevel - 1]; jstr++) {
		// jstr - столбец матрицы А.
		// icounter-1 - число узлов на грубом уровне.
		for (integer i = 1; i <= icounter - 1; i++) {
		flag[i] = false;
		}
		// А (на первой позиции) должна быть отсортирована по j.
		integer ii1 = BinarySearchAj(Amat, jstr, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		// это справедливо только для первого уровня.
		integer istart = 1 + iaddR;
		integer iend = nnzR - 1 + iaddR;
		for (integer ii = istart; ii <= iend; ii++) {
		if (flag[R[ii].i] == false) {
		integer istr = R[ii].i;
		integer ic = ii;
		// i-coarse, j-fine
		doublerealT sum1 = 0.0;
		while ((ic <= iend) && (R[ic].i == istr)) {
		// R[R[ii].i][R[ic].j]*Amat[R[ic].j][jstr]

		for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1] + iadd) && (Amat[ii2].j == jstr); ii2++) {
		// (Amat[ii2].j == jstr) {
		if (Amat[ii2].i == R[ic].j) {
		sum1 += R[ic].aij*Amat[ii2].aij;
		}
		//}
		}
		ic++;
		}
		if (fabs(sum1) > RealZERO) {
		Amat[istartAnew].aij = sum1;
		Amat[istartAnew].i = istr;
		Amat[istartAnew].j = jstr;
		if (jstr < 0) {
		printf("fatal error");
		#if doubleintprecision == 1
			printf("i=%lld j=%lld aij=%e\n", istr, jstr, sum1);
		#else
			printf("i=%d j=%d aij=%e\n", istr, jstr, sum1);
		#endif
		
		system("pause");
		}
		istartAnew++;
		}
		flag[R[ii].i] = true;
		}
		}
		}
		*/

		// Идея droptolerance состоит в отсечении в матрице элементов 
		// которые меньше чем одна тысячная от диагонального
		// А если диагонального элемента нет то берётся норма Чебышева строки.
		//
		//
		//

		// часть 1: R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]
		//integer istartAnew = nnz_a[ilevel - 1] + 1 + iadd;
		//for (integer jstr = 1; jstr <= n_a[ilevel - 1]; jstr++) {
		// jstr - столбец матрицы А.
		// icounter-1 - число узлов на грубом уровне.
		//if ((icounter - 1 > n) || (icounter - 1 < 0)) {
		//printf("flag incorrupt 4...\n");
		//system("pause");
		//exit(1);
		//}
		//for (integer i = 1; i <= icounter - 1; i++) {
		//flag[i] = false;
		//}
		// А (на первой позиции) должна быть отсортирована по j.
		//integer ii1 = BinarySearchAj(Amat, jstr, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		// это справедливо только для первого уровня.
		//integer istart = 1 + iaddR;
		//integer iend = nnzR - 1 + iaddR;
		//for (integer ii = istart; ii <= iend; ii++) {
		//if ((R[ii].i > n) || (R[ii].i < 0)) {
		//printf("flag incorrupt 3...\n");
		//system("pause");
		//exit(1);
		//}
		//if (flag[R[ii].i] == false) {
		//integer istr = R[ii].i;
		//integer ic = ii;
		// i-coarse, j-fine
		//doublerealT sum1 = 0.0;

		// это медленная версия кода.
		//while ((ic <= iend) && (R[ic].i == istr)) {
		// R[R[ii].i][R[ic].j]*Amat[R[ic].j][jstr]

		//for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1] + iadd) && (Amat[ii2].j == jstr); ii2++) {

		//if (Amat[ii2].i == R[ic].j) {
		//sum1 += R[ic].aij*Amat[ii2].aij;
		//}

		//}
		//ic++;
		//}

		// Это более быстрый код.
		//integer ks = ic;
		//integer ls = ii1;
		//integer kf = ic;
		//bool bvis = false;
		//doublerealT retalon = 0.0;
		//while ((kf <= iend) && (R[kf].i == istr)) {
		//if (R[kf].j == istr) {
		//	retalon = fabs(R[kf].aij);
		//	bvis = true;
		//}
		//kf++;
		//}
		//kf--;

		//if (bvis == false) {
		//kf = ic;
		//while ((kf <= iend) && (R[kf].i == istr)) {
		//	if (fabs(R[kf].aij) > retalon) retalon = fabs(R[kf].aij);
		//	kf++;
		//}
		//kf--;
		//}

		//integer lf = ii1;
		//for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1] + iadd) && (Amat[ii2].j == jstr); ii2++) {
		//if (fabs(Amat[ii2].aij) > retalon) retalon = fabs(Amat[ii2].aij);
		//if (Amat[ii2].i == istr) retalon *= fabs(Amat[ii2].aij);
		//lf++;
		//}
		//lf--;

		//while ((ks <= kf) && (ls <= lf)) {
		//if (Amat[ls].i < R[ks].j) {
		//	ls++;
		//}
		//else if (Amat[ls].i > R[ks].j) {
		//	ks++;
		//}
		//else {
		//	sum1 += R[ks].aij*Amat[ls].aij;
		//	ks++;
		//	ls++;
		//}
		//}




		//if (fabs(sum1) > 0.001*retalon) {
		//if (fabs(sum1)>1.0e-30) {
		//Amat[istartAnew].aij = sum1;
		//Amat[istartAnew].i = istr;
		//Amat[istartAnew].j = jstr;
		//if (jstr < 0) {
		//	printf("fatal error");
#if doubleintprecision == 1
		//	printf("i=%lld j=%lld aij=%e\n", istr, jstr, sum1);
#else
		//	printf("i=%d j=%d aij=%e\n", istr, jstr, sum1);
#endif
		
		//	system("pause");
		//}
		//istartAnew++;
		//}
		//flag[R[ii].i] = true;
		//}
		//}
		//}

#if doubleintprecision == 1
	printf("nnz left operand=%lld, nnz right operand=%lld\n", nnzR, nnz_a[ilevel - 1]);
#else
	printf("nnz left operand=%d, nnz right operand=%d\n", nnzR, nnz_a[ilevel - 1]);
#endif
		

		integer istartAnew;
		integer* kf_array;

		const integer IALGORITHM_MATRIX_MULT_1 = 2;

		if (0 == IALGORITHM_MATRIX_MULT_1) {

			// Самая быстрая версия на основе слияния упорядоченных массивов.

			//Более быстрый вариант алгоритма.
			// Быстрее этого кода на основе идеи слияния списков уже не будет.
			// 17 октября 2015. Нужно двигаться в сторону Писсанецки.
			// часть 1: R*Afine.
			//         xxxxxx
			//         xxxxxx
			//  xxxxxx xxxxxx xxxxxx
			//  xxxxxx xxxxxx xxxxxx
			//         xxxxxx
			//         xxxxxx
			//    R       Amat     [RA]
			kf_array = new integer[numberofcoarcenodes + 1];
			integer istart1 = 1 + iaddR;
			integer iend1 = nnzR - 1 + iaddR;
			for (integer i = 1; i <= icounter - 1; i++) {
				flag[i] = false;
			}
			for (integer ii = istart1; ii <= iend1; ii++) {
				if (flag[R[ii].i] == false) {
					integer istr = R[ii].i;
					integer ic = ii;
					integer kf = ic;

					while ((kf <= iend1) && (R[kf].i == istr)) {
						kf++;
					}
					kf--;
					kf_array[istr] = kf;
					flag[R[ii].i] = true;
				}
			}

			integer *start_position_i_string_in_R = new integer[numberofcoarcenodes + 1];
			for (integer i = 1; i <= icounter - 1; i++) {
				flag[i] = false;
			}
			integer istart3 = 1 + iaddR;
			integer iend3 = nnzR - 1 + iaddR;
			for (integer ii = istart3; ii <= iend3; ii++) {
				if (flag[R[ii].i] == false) {
					start_position_i_string_in_R[R[ii].i] = ii;
					flag[R[ii].i] = true;
				}
			}


			istartAnew = nnz_a[ilevel - 1] + 1 + iadd;
			for (integer jstr = 1; jstr <= n_a[ilevel - 1]; jstr++) {
				// jstr - столбец матрицы А.
				// icounter-1 - число узлов на грубом уровне.
				//if ((icounter - 1 > n) || (icounter - 1 < 0)) {
				//printf("flag incorrupt 4...\n");
				//system("pause");
				//exit(1);
				//}
				for (integer i = 1; i <= icounter - 1; i++) {
					flag[i] = false;
				}
				// А (на первой позиции) должна быть отсортирована по j.
				integer ii1 = BinarySearchAj(Amat, jstr, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer lf = ii1;
				for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1] + iadd) && (Amat[ii2].j == jstr); ii2++) {
					lf++;
				}
				lf--;

				// это справедливо  для любого  уровня.
				//integer istart = 1 + iaddR;
				//integer iend = nnzR - 1 + iaddR;
				//for (integer ii = istart; ii <= iend; ii++) {

				//if (flag[R[ii].i] == false) {
				// Внимание не забыть или открыть флаг.
				//flag[R[ii].i] = true;

				for (integer i_2 = 1; i_2 <= numberofcoarcenodes; i_2++) {
					//integer istr = R[ii].i;
					//integer ic = ii;

					integer istr = i_2;
					integer ic = start_position_i_string_in_R[i_2];

					// i-coarse, j-fine
					doublerealT sum1 = 0.0;

					// это медленная версия кода.
					//while ((ic <= iend) && (R[ic].i == istr)) {
					// R[R[ii].i][R[ic].j]*Amat[R[ic].j][jstr]

					//for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1] + iadd) && (Amat[ii2].j == jstr); ii2++) {

					//if (Amat[ii2].i == R[ic].j) {
					//sum1 += R[ic].aij*Amat[ii2].aij;
					//}

					//}
					//ic++;
					//}

					// Это более быстрый код.
					integer ks = ic;

					//integer kf = ic;

					//while ((kf <= iend) && (R[kf].i == istr)) {
					//kf++;
					//}
					//kf--;

					integer kf = kf_array[istr];

					integer ls = ii1;



					while ((ks <= kf) && (ls <= lf)) {

						if (Amat[ls].i < R[ks].j) {
							ls++;
						}
						else if (Amat[ls].i > R[ks].j) {
							ks++;
						}
						else /*if (Amat[ls].i == R[ks].j)*/ {
							sum1 += R[ks].aij*Amat[ls].aij;
							ks++;
							ls++;
						}

					}




					if (fabs(sum1) > 1.0e-30) {
						Amat[istartAnew].aij = sum1;
						Amat[istartAnew].i = istr;
						Amat[istartAnew].j = jstr;
						if (jstr < 0) {
							printf("fatal error");
#if doubleintprecision == 1
							printf("i=%lld j=%lld aij=%e\n", istr, jstr, sum1);
#else
							printf("i=%d j=%d aij=%e\n", istr, jstr, sum1);
#endif
							
							system("pause");
						}
						istartAnew++;
					}

					//}
				}
			}


			delete[] kf_array;
			delete[] start_position_i_string_in_R;

		}
		else if (1 == IALGORITHM_MATRIX_MULT_1) {

			// Идея Писсанецки.

			//Более быстрый вариант алгоритма.
			// Быстрее этого кода на основе идеи слияния списков уже не будет.
			// 22 октября 2015. Нужно двигаться в сторону Писсанецки.
			// часть 1: R*Afine.
			//         xxxxxx
			//         xxxxxx
			//  xxxxxx xxxxxx xxxxxx
			//  xxxxxx xxxxxx xxxxxx
			//         xxxxxx
			//         xxxxxx
			//    R       Amat     [RA]
			kf_array = new integer[numberofcoarcenodes + 1];
			integer istart1 = 1 + iaddR;
			integer iend1 = nnzR - 1 + iaddR;
			for (integer i = 1; i <= icounter - 1; i++) {
				flag[i] = false;
			}
			for (integer ii = istart1; ii <= iend1; ii++) {
				if (flag[R[ii].i] == false) {
					integer istr = R[ii].i;
					integer ic = ii;
					integer kf = ic;

					while ((kf <= iend1) && (R[kf].i == istr)) {
						kf++;
					}
					kf--;
					kf_array[istr] = kf;
					flag[R[ii].i] = true;
				}
			}

			integer *start_position_i_string_in_R = new integer[numberofcoarcenodes + 1];
			for (integer i = 1; i <= icounter - 1; i++) {
				flag[i] = false;
			}
			integer istart3 = 1 + iaddR;
			integer iend3 = nnzR - 1 + iaddR;
			for (integer ii = istart3; ii <= iend3; ii++) {
				if (flag[R[ii].i] == false) {
					start_position_i_string_in_R[R[ii].i] = ii;
					flag[R[ii].i] = true;
				}
			}

			integer* ind = new integer[n_a[ilevel - 1] + 1];


			istartAnew = nnz_a[ilevel - 1] + 1 + iadd;
			for (integer jstr = 1; jstr <= n_a[ilevel - 1]; jstr++) {
				// jstr - столбец матрицы А.
				// icounter-1 - число узлов на грубом уровне.
				//if ((icounter - 1 > n) || (icounter - 1 < 0)) {
				//printf("flag incorrupt 4...\n");
				//system("pause");
				//exit(1);
				//}

				for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
					ind[i] = -1; // инициализация.
				}

				for (integer i = 1; i <= icounter - 1; i++) {
					flag[i] = false;
				}
				// А (на первой позиции) должна быть отсортирована по j.
				integer ii1 = BinarySearchAj(Amat, jstr, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				//integer lf = ii1;
				for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1] + iadd) && (Amat[ii2].j == jstr); ii2++) {
					ind[Amat[ii2].i] = ii2; // запоминание индекса.
										 //lf++;
				}
				//lf--;

				// это справедливо  для любого  уровня.
				//integer istart = 1 + iaddR;
				//integer iend = nnzR - 1 + iaddR;
				//for (integer ii = istart; ii <= iend; ii++) {

				//if (flag[R[ii].i] == false) {
				// Внимание не забыть или открыть флаг.
				//flag[R[ii].i] = true;

				for (integer i_2 = 1; i_2 <= numberofcoarcenodes; i_2++) {
					//integer istr = R[ii].i;
					//integer ic = ii;

					integer istr = i_2;
					integer ic = start_position_i_string_in_R[i_2];

					// i-coarse, j-fine
					doublerealT sum1 = 0.0;



					// Это более быстрый код.
					integer ks = ic;


					integer kf = kf_array[istr];

					//integer ls = ii1;


					while (ks <= kf) {
						if (ind[R[ks].j] != -1) {
							sum1 += R[ks].aij*Amat[ind[R[ks].j]].aij;
						}
						ks++;
					}

					/*
					while ((ks <= kf) && (ls <= lf)) {

					if (Amat[ls].i < R[ks].j) {
					ls++;
					}
					else if (Amat[ls].i > R[ks].j) {
					ks++;
					}
					else {
					sum1 += R[ks].aij*Amat[ls].aij;
					ks++;
					ls++;
					}

					}
					*/



					if (fabs(sum1) > 1.0e-30) {
						Amat[istartAnew].aij = sum1;
						Amat[istartAnew].i = istr;
						Amat[istartAnew].j = jstr;
						if (jstr < 0) {
							printf("fatal error");
#if doubleintprecision == 1
							printf("i=%lld j=%lld aij=%e\n", istr, jstr, sum1);
#else
							printf("i=%d j=%d aij=%e\n", istr, jstr, sum1);
#endif
							
							system("pause");
						}
						istartAnew++;
					}

					//}
				}
			}


			delete[] kf_array;
			delete[] start_position_i_string_in_R;
			delete[] ind;
		}
		else {

			if (0) {

				// Фред Густавсон IBM 1978.
				// 23 октября 2015 года.

				// часть 1: R*Afine.
				//         xxxxxx
				//         xxxxxx
				//  xxxxxx xxxxxx xxxxxx
				//  xxxxxx xxxxxx xxxxxx
				//         xxxxxx
				//         xxxxxx
				//    R       Amat     [RA]
				// Сортировка А по строкам.
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparei);
					}
					else {
						qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparei);
					}
				}
				else {
					HeapSort(Amat, /*n_a[ilevel - 1],*/ 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);
				}

				// Преобразование к формату CRS.

				integer* row_ind_SR = new integer[numberofcoarcenodes + 1];
				integer* row_ind_ER = new integer[numberofcoarcenodes + 1];
				for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
					row_ind_SR[i_1] = -1;
					row_ind_ER[i_1] = -2;
				}
				integer istart1 = 1 + iaddR;
				integer iend1 = nnzR - 1 + iaddR;
				for (integer i = 1; i <= icounter - 1; i++) {
					flag[i] = false;
				}
				for (integer ii = istart1; ii <= iend1; ii++) {
					if (flag[R[ii].i] == false) {
						integer istr = R[ii].i;
						integer ic = ii;
						integer kf = ic;

						while ((kf <= iend1) && (R[kf].i == istr)) {
							kf++;
						}
						kf--;
						row_ind_SR[istr] = ic;
						row_ind_ER[istr] = kf;
						flag[R[ii].i] = true;
					}
				}

				// Пустые строки просто отсутствуют.
				//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				//if (row_ind_SR[i_1] == -1) {
#if doubleintprecision == 1
				//printf("empty string %lld\n", row_ind_ER[i_1]);
#else
				//printf("empty string %d\n", row_ind_ER[i_1]);
#endif
				
				//}
				//}

				integer* row_ind_SA = new integer[n_a[ilevel - 1] + 1];
				integer* row_ind_EA = new integer[n_a[ilevel - 1] + 1];
				integer istart3 = 1 + iadd;
				integer iend3 = nnz_a[ilevel - 1] + iadd;
				for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
					flag[i] = false;
				}
				for (integer ii = istart3; ii <= iend3; ii++) {
					if (flag[Amat[ii].i] == false) {
						integer istr = Amat[ii].i;
						integer ic = ii;
						integer kf = ic;

						while ((kf <= iend3) && (Amat[kf].i == istr)) {
							kf++;
						}
						kf--;
						row_ind_SA[istr] = ic;
						row_ind_EA[istr] = kf;
						flag[Amat[ii].i] = true;
					}
				}

				istartAnew = nnz_a[ilevel - 1] + 1 + iadd;

				// Данные используемые для частичного формирователя суммы.
				doublerealT* vector_sum = new doublerealT[n_a[ilevel - 1] + 1];
				//bool* b_visit_vec_sum = new bool[n_a[ilevel - 1] + 1];
				//integer size_v = sizeof(doublerealT)*(1 + n_a[ilevel - 1]);

				// Сканируем первый операнд построчно.
				for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

					// Начинаем обрабатывать новую строку.
					// Сброс формирователя суммы в ноль.
					//#pragma omp parallel for
					for (integer i_2 = 1; i_2 <= n_a[ilevel - 1]; i_2++) {
						vector_sum[i_2] = 0.0; // инициализация // 18.5
											   //b_visit_vec_sum[i_2] = false;
					}
					// Более быстрое обнуление
					// По времени в лучшем случае также. Но может сильно ухудшиться из-за занятости системной dll-ки.
					//memset(vector_sum, 0,size_v );

					// Сканируем текущую i-ую строку поэлементно
					for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
						integer col_ind = R[ii].j;
						// Сканируем col_ind строку второго операнда

						for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
							doublerealT left_operand = R[ii].aij;
							doublerealT right_operand = Amat[i_1].aij;
							vector_sum[Amat[i_1].j] += left_operand*right_operand;
							//b_visit_vec_sum[Amat[i_1].j] = true;
						}
					}

					for (integer jstr = 1; jstr <= n_a[ilevel - 1]; jstr++) {
						// сначала быстрая проверка 
						//if (b_visit_vec_sum[jstr]) {
						// а потом медленная.
						if (fabs(vector_sum[jstr]) > 1.0e-30) { // 36.3
							Amat[istartAnew].aij = vector_sum[jstr];
							Amat[istartAnew].i = istr;
							Amat[istartAnew].j = jstr;
							istartAnew++;
						}
						//}
					}
				}

				delete[] row_ind_SR;
				delete[] row_ind_ER;
				delete[] row_ind_SA;
				delete[] row_ind_EA;
				delete[] vector_sum;
				//delete[] b_visit_vec_sum;

			}
			else {
				// Фред Густавсон IBM 1978.
				// 23 октября 2015 года.

				// часть 1: R*Afine.
				//         xxxxxx
				//         xxxxxx
				//  xxxxxx xxxxxx xxxxxx
				//  xxxxxx xxxxxx xxxxxx
				//         xxxxxx
				//         xxxxxx
				//    R       Amat     [RA]
				// Сортировка А по строкам.
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparei);
					}
					else {
						qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparei);
					}
				}
				else {
					HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);
				}

				// Преобразование к формату CRS.

				integer* row_ind_SR = new integer[numberofcoarcenodes + 1];
				integer* row_ind_ER = new integer[numberofcoarcenodes + 1];
				for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
					row_ind_SR[i_1] = -1;
					row_ind_ER[i_1] = -2;
				}
				integer istart1 = 1 + iaddR;
				integer iend1 = nnzR - 1 + iaddR;
				for (integer i = 1; i <= icounter - 1; i++) {
					flag[i] = false;
				}
				for (integer ii = istart1; ii <= iend1; ii++) {
					if (flag[R[ii].i] == false) {
						integer istr = R[ii].i;
						integer ic = ii;
						integer kf = ic;

						while ((kf <= iend1) && (R[kf].i == istr)) {
							kf++;
						}
						kf--;
						row_ind_SR[istr] = ic;
						row_ind_ER[istr] = kf;
						flag[R[ii].i] = true;
					}
				}

				// Пустые строки просто отсутствуют.
				//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				//if (row_ind_SR[i_1] == -1) {
#if doubleintprecision == 1
				//printf("empty string %lld\n", row_ind_ER[i_1]);
#else
				//printf("empty string %d\n", row_ind_ER[i_1]);
#endif
				
				//}
				//}

				integer* row_ind_SA = new integer[n_a[ilevel - 1] + 1];
				integer* row_ind_EA = new integer[n_a[ilevel - 1] + 1];
				integer istart3 = 1 + iadd;
				integer iend3 = nnz_a[ilevel - 1] + iadd;
				for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
					flag[i] = false;
				}
				for (integer ii = istart3; ii <= iend3; ii++) {
					if (flag[Amat[ii].i] == false) {
						integer istr = Amat[ii].i;
						integer ic = ii;
						integer kf = ic;

						while ((kf <= iend3) && (Amat[kf].i == istr)) {
							kf++;
						}
						kf--;
						row_ind_SA[istr] = ic;
						row_ind_EA[istr] = kf;
						flag[Amat[ii].i] = true;
					}
				}

				istartAnew = nnz_a[ilevel - 1] + 1 + iadd;

				// Данные используемые для частичного формирователя суммы.
				doublerealT* vector_sum = new doublerealT[n_a[ilevel - 1] + 1];
				//bool* b_visit_vec_sum = new bool[n_a[ilevel - 1] + 1];
				//integer size_v = sizeof(doublerealT)*(1 + n_a[ilevel - 1]);
				// Храним индексы ненулевых элементов в отсортированном порядке.
				integer* index_visit = new integer[n_a[ilevel - 1] + 1];
				integer index_size = 0;

				// Сканируем первый операнд построчно.
				for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

					// Начинаем обрабатывать новую строку.
					// Сброс формирователя суммы в ноль.
					//#pragma omp parallel for
					//for (integer i_2 = 1; i_2 <= n_a[ilevel - 1]; i_2++) {
					//vector_sum[i_2] = 0.0; // инициализация // 18.5
					//b_visit_vec_sum[i_2] = false;
					//}
					// Более быстрое обнуление
					// По времени в лучшем случае также. Но может сильно ухудшиться из-за занятости системной dll-ки.
					//memset(vector_sum, 0,size_v );

					// Сканируем текущую i-ую строку поэлементно
					for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
						integer col_ind = R[ii].j;
						// Сканируем col_ind строку второго операнда

						for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
							doublerealT left_operand = R[ii].aij;
							doublerealT right_operand = Amat[i_1].aij;
							integer iaddind = Amat[i_1].j;
							bool foundnow = false;
							integer ifoundind = -1;
							// линейный поиск позиции в массиве на добавление.
							for (integer i_6 = 1; i_6 <= index_size; i_6++) {
								if (index_visit[i_6] == iaddind) {
									foundnow = true;
									ifoundind = i_6;
									break;
								}
							}
							if (foundnow) {
								vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							}
							else {
								// Первое добавление.
								index_size++;
								index_visit[index_size] = iaddind;
								ifoundind = index_size;
								vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							}

							//vector_sum[Amat[i_1].j] += left_operand*right_operand;
							//b_visit_vec_sum[Amat[i_1].j] = true;
						}
					}

					// 5 декабря 2015 Избирательность приводящая к сохранению разреженности.
					/*
					doublerealT threshhold_maxelem_in_string = -1.0;
					for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					if (jstr != istr) {
					if (fabs(vector_sum[jstr]) > threshhold_maxelem_in_string) {
					threshhold_maxelem_in_string = fabs(vector_sum[jstr]);
					}
					}
					}
					*/

					// 5 декабря 2015 
					// магический параметр отсечения mul_theta приводящий к сохранению разреженности оператора 
					// Галёркина а значит ускорению времени счёта.
					// Требуется определить оптимальное значение этого параметра.
					//doublerealT mul_theta = 0.111;
					//switch (dim_2D) {
					//case 0: // 3D
					//mul_theta = mul_theta3D;  // 0.13;
					//break;
					//case 1: // 2D
					//mul_theta = 0.008;
					//break;
					//};


					for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						integer jstr = index_visit[i_6];
						if (istr != jstr) {
							// 5 декабря 2015. threshold.
							if (fabs(vector_sum[jstr]) > 1.0e-30) {
								//if (fabs(vector_sum[jstr]) > mul_theta*theta*threshhold_maxelem_in_string) {
								Amat[istartAnew].aij = vector_sum[jstr];
								Amat[istartAnew].i = istr;
								Amat[istartAnew].j = jstr;
								istartAnew++;
							}
						}
						else {
							// диагональный элемент записываем обязательно.
							Amat[istartAnew].aij = vector_sum[jstr];
							Amat[istartAnew].i = istr;
							Amat[istartAnew].j = jstr;
							istartAnew++;
						}
					}
					index_size = 0;


				}
				delete[] index_visit;
				delete[] row_ind_SR;
				delete[] row_ind_ER;
				delete[] row_ind_SA;
				delete[] row_ind_EA;
				delete[] vector_sum;
			}

		}

		// Сортировка А по i (оригинала.).
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1], comparei);
		if (bquicktypesort) {
			QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);
		}
		else {
			if (nnz_a[ilevel - 1] < heapsortsizelimit) {
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparei);
					}
					else {
						qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparei);
					}
				}
				else
				{
					HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);
				}
			}
			else {
				Ak* Aorig = &Amat[1 + iadd];
				MergeSort(Aorig, nnz_a[ilevel - 1], comparei);
				Aorig = nullptr;
			}
		}

		// Проверка пройдена успешно.
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
			if (Amat[i_1].j < 0) {
				printf("error: negativ j index\n");
				system("pause");
			}
#if doubleintprecision == 1
			//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
			//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
			
			//system("pause");
		}



		// Часть 2. [R*Afine]*P=Abuf*P.
		// Сортировка [R*А] по i.
		//heapsort(Amat, key=i*n_coarce + j, 1, nnz_a[ilevel - 1], comparei);
		if (bquicktypesort) {
			QuickSort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1, comparei);
		}
		else {
			if (nnz_a[ilevel - 1] < heapsortsizelimit) {
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1, indx_comparei);
					}
					else {
						qs(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1, indx_comparei);
					}
				}
				else {
					HeapSort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1, comparei);
				}
			}
			else {
				Ak* Aorig = &Amat[nnz_a[ilevel - 1] + 1 + iadd];
				MergeSort(Aorig, istartAnew - 1 - (nnz_a[ilevel - 1] + 1 + iadd) + 1, comparei);
				Aorig = nullptr;
			}
		}


		// Проверка пройдена успешно.
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
			if (Amat[i_1].j < 0) {
				printf("error: negativ j index\n");
				system("pause");
			}
#if doubleintprecision == 1
			//-->	//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
			//-->	//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
			
			//system("pause");
		}

		// Самый медленный в мире BubbleSort.
		// нужен для проверки более быстрых алгоритмов сортировки.
		//integer k3 = 0;
		//for (integer k1 = nnz_a[ilevel - 1] + 1 + iadd; k1 < istartAnew - 1; k1++,k3++) {
		//for (integer k2 = nnz_a[ilevel - 1] + 1 + iadd; k2 < istartAnew - 1 - k3; k2++) {
		//if (Amat[k2].i>Amat[k2 + 1].i) {
		// change
		//Ak Temp = Amat[k2];
		//	Amat[k2] = Amat[k2 + 1];
		//Amat[k2 + 1] = Temp;
		//}
		//else if (Amat[k2].i == Amat[k2 + 1].i) {
		//if (Amat[k2].j>Amat[k2 + 1].j) {
		// change
		//Ak Temp = Amat[k2];
		//Amat[k2] = Amat[k2 + 1];
		//Amat[k2 + 1] = Temp;
		//}
		//}
		//}
		//}

		// Контроль [R*A] debug
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
#if doubleintprecision == 1
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}

		if (bquicktypesort) {
			QuickSort(P, 1 + iaddR, iaddR + nnzR - 1, comparei);
		}
		else {
			if (bqs) {
				if (bCounting_Sort) {
					Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparei);
				}
				else {
					qs(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparei);
				}
			}
			else {
				HeapSort(P, 1 + iaddR, iaddR + nnzR - 1, comparei);
			}
		}

		// Prolongation должна быть упорядочена по j.
		// Начальная позиция элементов матрицы грубосеточного уровня.
		integer istartAnew2 = istartAnew;

		/*
		// icounter - 1; // Количество узлов на грубосеточном уровне.
		for (integer i = 1; i <= n_coarce; i++) {
		flag[i] = false;
		}
		// P должен быть упорядочен по строкам.
		// проверка диагонали в P
		for (integer ii77 = 1; ii77 <= nnzR; ii77++) {
		#if doubleintprecision == 1
			printf("i=%lld j=%lld %e\n",P[ii77].i,P[ii77].j,P[ii77].aij);
		#else
			printf("i=%d j=%d %e\n",P[ii77].i,P[ii77].j,P[ii77].aij);
		#endif
		
		getchar();
		}
		*/

		//begin medlennji
		/*
		// сканируем по столбцам
		for (integer jstr = 1; jstr <= icounter-1; jstr++) {
		for (integer i = 1; i <= n_coarce; i++) {
		flag[i] = false;
		}
		//integer ii1 = BinarySearchAj(P, jstr, 1+iaddR, nnzR - 1+iaddR);
		// Дело в том что у матрицы P всё хранится в перепутанном (с точностью до транспонирования виде).
		integer ii1 = BinarySearchAi(P, jstr, 1 + iaddR, nnzR - 1 + iaddR);
		// это справедливо только для первого уровня.
		integer istart = nnz_a[ilevel - 1] + 1 + iadd;
		integer iend = istartAnew - 1;
		for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
		// сканируем построчно.
		integer istr = Amat[ii].i;
		integer ic = ii;
		// i-coarse, j-fine
		doublerealT sum1 = 0.0;
		while ((ic <= iend) && (Amat[ic].i == istr)) {
		// [R*A][Amat[ii].i][Amat[ic].j]*P[Amat[ic].j][jstr]
		// у матрицы P всё перепутано с точностью до транспонирования.
		// [R*A][Amat[ii].i][Amat[ic].j]*P[jstr][Amat[ic].j]
		for (integer ii2 = ii1; (ii2 <= nnzR- 1+iaddR) && (P[ii2].i == jstr); ii2++) {

		if (P[ii2].j == Amat[ic].j) {
		sum1 += Amat[ic].aij*P[ii2].aij;
		#if doubleintprecision == 1
			//printf("%e i=%lld j=%lld k=%lld\n", Amat[ic].aij*P[ii2].aij,istr,P[ii2].j,jstr);
		#else
			//printf("%e i=%d j=%d k=%d\n", Amat[ic].aij*P[ii2].aij,istr,P[ii2].j,jstr);
		#endif
		
		//getchar();
		}
		}

		ic++;
		}

		if (fabs(sum1) > RealZERO) {
		Amat[istartAnew2].aij = sum1;
		Amat[istartAnew2].i = istr;
		Amat[istartAnew2].j = jstr;
		istartAnew2++;
		}
		flag[Amat[ii].i] = true;
		}
		}
		}
		*/




		// сканируем по столбцам
		//for (integer jstr = 1; jstr <= icounter - 1; jstr++) {

		//for (integer i = 1; i <= n; i++) {
		//flag[i] = false;
		//}
		//integer ii1 = BinarySearchAj(P, jstr, 1+iaddR, nnzR - 1+iaddR);
		// Дело в том что у матрицы P всё хранится в перепутанном (с точностью до транспонирования виде).
		//integer ii1 = BinarySearchAi(P, jstr, 1 + iaddR, nnzR - 1 + iaddR);
		// это справедливо только для первого уровня.
		//integer istart = nnz_a[ilevel - 1] + 1 + iadd;
		//integer iend = istartAnew - 1;
		//for (integer ii = istart; ii <= iend; ii++) {
		//if ((Amat[ii].i > n)||(Amat[ii].i<0)) {
		//printf("flag incorrupt 1...\n");
		//system("pause");
		//exit(1);
		//}
		//if (flag[Amat[ii].i] == false) {
		// сканируем построчно.
		//integer istr = Amat[ii].i;
		//integer ic = ii;
		// i-coarse, j-fine
		//	doublerealT sum1 = 0.0;

		// Заменим медленный двойной цикл на слияние.
		//while ((ic <= iend) && (Amat[ic].i == istr)) {
		// [R*A][Amat[ii].i][Amat[ic].j]*P[Amat[ic].j][jstr]
		// у матрицы P всё перепутано с точностью до транспонирования.
		// [R*A][Amat[ii].i][Amat[ic].j]*P[jstr][Amat[ic].j]
		//for (integer ii2 = ii1; (ii2 <= nnzR - 1 + iaddR) && (P[ii2].i == jstr); ii2++) {

		//	if (P[ii2].j == Amat[ic].j) {
		//sum1 += Amat[ic].aij*P[ii2].aij;
		//	}
		//}

		//ic++;
		//}

		// Более быстрый код на основе слияния.
		//integer ks = ic;
		//integer ls = ii1;
		//integer kf = ic;
		//doublerealT retalon = 0.0;
		//bool bvis = false;
		//while ((kf <= iend) && (Amat[kf].i == istr)) {
		//if (fabs(Amat[kf].aij) > retalon) retalon = fabs(Amat[kf].aij);
		//if (Amat[kf].j == istr) {
		//	retalon = fabs(Amat[kf].aij);
		//	bvis = true;
		//}
		///kf++;
		//}
		//kf--;
		//if (bvis == false) {
		//kf = ic;
		//while ((kf <= iend) && (Amat[kf].i == istr)) {
		//	if (fabs(Amat[kf].aij) > retalon) retalon = fabs(Amat[kf].aij);
		//	kf++;
		//}
		//kf--;
		//}
		//integer lf = ii1;
		//for (integer ii2 = ii1; (ii2 <= nnzR - 1 + iaddR) && (P[ii2].i == jstr); ii2++) {
		//if (P[ii2].j == istr) retalon *= fabs(P[ii2].aij); // это диагональный элемент.
		//lf++;
		//}
		//lf--;
		//while ((ks <= kf) && (ls <= lf)) {
		//if (P[ls].j<Amat[ks].j) {
		//	ls++;
		//}
		//else if (P[ls].j > Amat[ks].j) {
		//	ks++;
		//}
		//else {
		//	sum1 += Amat[ks].aij*P[ls].aij;
		//	ks++;
		//	ls++;
		//}
		//}
		//if (fabs(retalon) < 1.0e-30) {
#if doubleintprecision == 1
		//printf("RAP retalon=%e string %lld is zero\n",retalon,istr);
#else
		//printf("RAP retalon=%e string %d is zero\n",retalon,istr);
#endif
		
		//getchar();
		//}

		//---//if (fabs(sum1) > 0.001*retalon) {
		//if (fabs(sum1)>1.0e-30) {
		//Amat[istartAnew2].aij = sum1;
		//Amat[istartAnew2].i = istr;
		//Amat[istartAnew2].j = jstr;
		//istartAnew2++;
		//}
		//flag[Amat[ii].i] = true;
		//}
		//}
		//}

		// Быстрее этого кода на основе идеи слияния списков уже не будет.
		// 17 октября 2015. Нужно двигаться в сторону Писсанецки.
#if doubleintprecision == 1
		printf("nnz left operand=%lld, nnz right operand=%lld\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#else
		printf("nnz left operand=%d, nnz right operand=%d\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#endif
		
		const integer IALGORITHM_MATRIX_MULT_2 = 2;

		if (0 == IALGORITHM_MATRIX_MULT_2) {

			// Код на основе слияния упорядоченных массивов.

			kf_array = new integer[numberofcoarcenodes + 1];
			integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
			integer iend2 = istartAnew - 1;
			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}
			for (integer ii = istart2; ii <= iend2; ii++) {
				if (flag[Amat[ii].i] == false) {
					// сканируем построчно.
					integer istr = Amat[ii].i;
					integer ic = ii;

					integer kf = ic;

					while ((kf <= iend2) && (Amat[kf].i == istr)) {
						kf++;
					}
					kf--;
					kf_array[istr] = kf;
					flag[Amat[ii].i] = true;

				}
			}

			// Количество строк в матрице А есть точно numberofcoarcenodes
			integer *start_position_i_string_in_RA = new integer[numberofcoarcenodes + 1];
			for (integer i = 1; i <= icounter - 1; i++) {
				flag[i] = false;
			}
			integer istart4 = nnz_a[ilevel - 1] + 1 + iadd;
			integer iend4 = istartAnew - 1;
			for (integer ii = istart4; ii <= iend4; ii++) {
				if (flag[Amat[ii].i] == false) {
					start_position_i_string_in_RA[Amat[ii].i] = ii;
					flag[Amat[ii].i] = true;
				}
			}


			// Более быстрая версия кода: 15 октября 2015
			// сканируем по столбцам
			for (integer jstr = 1; jstr <= icounter - 1; jstr++) {

				for (integer i = 1; i <= n; i++) {
					flag[i] = false;
				}
				//integer ii1 = BinarySearchAj(P, jstr, 1+iaddR, nnzR - 1+iaddR);
				// Дело в том что у матрицы P всё хранится в перепутанном (с точностью до транспонирования виде).
				integer ii1 = BinarySearchAi(P, jstr, 1 + iaddR, nnzR - 1 + iaddR);

				integer lf = ii1;
				for (integer ii2 = ii1; (ii2 <= nnzR - 1 + iaddR) && (P[ii2].i == jstr); ii2++) {
					lf++;
				}
				lf--;

				// это справедливо только для первого уровня.
				//integer istart = nnz_a[ilevel - 1] + 1 + iadd;
				//integer iend = istartAnew - 1;
				//for (integer ii = istart; ii <= iend; ii++) {

				//if (flag[Amat[ii].i] == false) {
				// Ни в коем случае не забываем модифицировать флаг.
				//flag[Amat[ii].i] = true;
				// сканируем построчно.
				//integer istr = Amat[ii].i;
				//integer ic = ii;

				for (integer i_2 = 1; i_2 <= numberofcoarcenodes; i_2++) {

					integer istr = i_2;
					integer ic = start_position_i_string_in_RA[i_2];

					// i-coarse, j-fine
					doublerealT sum1 = 0.0;

					// Заменим медленный двойной цикл на слияние.
					//while ((ic <= iend) && (Amat[ic].i == istr)) {
					// [R*A][Amat[ii].i][Amat[ic].j]*P[Amat[ic].j][jstr]
					// у матрицы P всё перепутано с точностью до транспонирования.
					// [R*A][Amat[ii].i][Amat[ic].j]*P[jstr][Amat[ic].j]
					//for (integer ii2 = ii1; (ii2 <= nnzR - 1 + iaddR) && (P[ii2].i == jstr); ii2++) {

					//	if (P[ii2].j == Amat[ic].j) {
					//sum1 += Amat[ic].aij*P[ii2].aij;
					//	}
					//}

					//ic++;
					//}

					// Более быстрый код на основе слияния.
					integer ks = ic;

					//integer kf = ic;

					//while ((kf <= iend) && (Amat[kf].i == istr)) {
					//kf++;
					//}
					//kf--;
					integer kf = kf_array[istr];

					integer ls = ii1;

					while ((ks <= kf) && (ls <= lf)) {

						if (P[ls].j < Amat[ks].j) {
							ls++;
						}
						else if (P[ls].j > Amat[ks].j) {
							ks++;
						}
						else /*if (P[ls].j==Amat[ks].j)*/ {
							sum1 += Amat[ks].aij*P[ls].aij;
							ks++;
							ls++;
						}

					}

					if (fabs(sum1) > 1.0e-30) {
						Amat[istartAnew2].aij = sum1;
						Amat[istartAnew2].i = istr;
						Amat[istartAnew2].j = jstr;
						istartAnew2++;
					}

					//}
				}
			}

			delete[] kf_array;
			delete[] start_position_i_string_in_RA;

		}
		else if (1 == IALGORITHM_MATRIX_MULT_2) {
			// Идея Писсанецки 22 октября 2015.

			kf_array = new integer[numberofcoarcenodes + 1];
			integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
			integer iend2 = istartAnew - 1;
			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}
			for (integer ii = istart2; ii <= iend2; ii++) {
				if (flag[Amat[ii].i] == false) {
					// сканируем построчно.
					integer istr = Amat[ii].i;
					integer ic = ii;

					integer kf = ic;

					while ((kf <= iend2) && (Amat[kf].i == istr)) {
						kf++;
					}
					kf--;
					kf_array[istr] = kf;
					flag[Amat[ii].i] = true;

				}
			}

			// Количество строк в матрице А есть точно numberofcoarcenodes
			integer *start_position_i_string_in_RA = new integer[numberofcoarcenodes + 1];
			for (integer i = 1; i <= icounter - 1; i++) {
				flag[i] = false;
			}
			integer istart4 = nnz_a[ilevel - 1] + 1 + iadd;
			integer iend4 = istartAnew - 1;
			for (integer ii = istart4; ii <= iend4; ii++) {
				if (flag[Amat[ii].i] == false) {
					start_position_i_string_in_RA[Amat[ii].i] = ii;
					flag[Amat[ii].i] = true;
				}
			}

			integer *ind = new integer[n_a[ilevel - 1] + 1];


			// Более быстрая версия кода: 15 октября 2015
			// сканируем по столбцам
			for (integer jstr = 1; jstr <= icounter - 1; jstr++) {

				for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
					ind[i] = -1; // инициализация.
				}

				for (integer i = 1; i <= n; i++) {
					flag[i] = false;
				}
				//integer ii1 = BinarySearchAj(P, jstr, 1+iaddR, nnzR - 1+iaddR);
				// Дело в том что у матрицы P всё хранится в перепутанном (с точностью до транспонирования виде).
				integer ii1 = BinarySearchAi(P, jstr, 1 + iaddR, nnzR - 1 + iaddR);

				//integer lf = ii1;
				for (integer ii2 = ii1; (ii2 <= nnzR - 1 + iaddR) && (P[ii2].i == jstr); ii2++) {
					ind[P[ii2].j] = ii2;
					//lf++;
				}
				//lf--;

				// это справедливо только для первого уровня.
				//integer istart = nnz_a[ilevel - 1] + 1 + iadd;
				//integer iend = istartAnew - 1;
				//for (integer ii = istart; ii <= iend; ii++) {

				//if (flag[Amat[ii].i] == false) {
				// Ни в коем случае не забываем модифицировать флаг.
				//flag[Amat[ii].i] = true;
				// сканируем построчно.
				//integer istr = Amat[ii].i;
				//integer ic = ii;

				for (integer i_2 = 1; i_2 <= numberofcoarcenodes; i_2++) {

					integer istr = i_2;
					integer ic = start_position_i_string_in_RA[i_2];

					// i-coarse, j-fine
					doublerealT sum1 = 0.0;



					// Более быстрый код на основе слияния.
					integer ks = ic;


					integer kf = kf_array[istr];

					//integer ls = ii1;

					while (ks <= kf) {
						if (ind[Amat[ks].j] != -1) {
							sum1 += Amat[ks].aij*P[ind[Amat[ks].j]].aij;
						}
						ks++;
					}

					//while ((ks <= kf) && (ls <= lf)) {

					//if (P[ls].j < Amat[ks].j) {
					//ls++;
					//}
					//else if (P[ls].j > Amat[ks].j) {
					//ks++;
					//}
					//else /*if (P[ls].j==Amat[ks].j)*/ {
					//sum1 += Amat[ks].aij*P[ls].aij;
					//ks++;
					//ls++;
					//}

					//}

					if (fabs(sum1) > 1.0e-30) {
						Amat[istartAnew2].aij = sum1;
						Amat[istartAnew2].i = istr;
						Amat[istartAnew2].j = jstr;
						istartAnew2++;
					}

					//}
				}
			}

			delete[] kf_array;
			delete[] start_position_i_string_in_RA;
			delete[] ind;

		}
		else {
			// Фред Густавсон IBM 1978
			// В ядре кода Густавсона нету ни одного ветвления,
			// а мы знаем что в результате профайлинга предыдущих версий кода:
			// (наивный, слияние, Писсанецки) львиная доля вычислительной работы уходила
			// на сравнения (ветвления) в отношении примерно 30 к 1. 30 сравнений на одно суммирование.
			// 23 октября 2015 года.

			if (0) {
				// Преобразование обоих матриц в формат CRS.
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
					}
					else {
						qs(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
					}
				}
				else {
					HeapSort(P, 1 + iaddR, iaddR + nnzR - 1, comparej);
				}

				integer* row_ind_AS = new integer[numberofcoarcenodes + 1];
				integer* row_ind_AE = new integer[numberofcoarcenodes + 1];
				integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
				integer iend2 = istartAnew - 1;
				for (integer i = 1; i <= n; i++) {
					flag[i] = false;
				}
				for (integer ii = istart2; ii <= iend2; ii++) {
					if (flag[Amat[ii].i] == false) {
						// сканируем построчно.
						integer istr = Amat[ii].i;
						integer ic = ii;

						integer kf = ic;

						while ((kf <= iend2) && (Amat[kf].i == istr)) {
							kf++;
						}
						kf--;
						row_ind_AS[istr] = ic;
						row_ind_AE[istr] = kf;
						flag[Amat[ii].i] = true;

					}
				}

				integer* row_ind_PS = new integer[n_a[ilevel - 1] + 1];
				integer* row_ind_PE = new integer[n_a[ilevel - 1] + 1];
				// Инициализация чрезвычайно важна, т.к. 
				// обязательно присутствуют пустые строки которые
				// надо корректно обрабатывать.
				for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
					row_ind_PS[ii] = -1; // инициализация.
					row_ind_PE[ii] = -2;
				}
				integer istart4 = 1 + iaddR;
				integer iend4 = nnzR - 1 + iaddR;
				for (integer i = 1; i <= n; i++) {
					flag[i] = false;
				}
				for (integer ii = istart4; ii <= iend4; ii++) {
					if (flag[P[ii].j] == false) {
						// сканируем построчно.
						integer istr = P[ii].j;
						integer ic = ii;

						integer kf = ic;

						while ((kf <= iend4) && (P[kf].j == istr)) {
							kf++;
						}
						kf--;
						row_ind_PS[istr] = ic;
						row_ind_PE[istr] = kf;
						flag[P[ii].j] = true;

					}
				}

				// Данный код подтверждает что обязательно присутствуют
				// пустые строки.
				//for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
				//if (row_ind_PS[ii] == -1) {
#if doubleintprecision == 1
				//printf("propusk string %lld\n", row_ind_PE[ii]);
#else
				//printf("propusk string %d\n", row_ind_PE[ii]);
#endif
				
				//getchar();
				//}
				//}

				// Накопитель результата.
				doublerealT* vector_sum = new doublerealT[numberofcoarcenodes + 1];
				//integer size_v = sizeof(doublerealT)*(1 + numberofcoarcenodes);

				// Мы будем сканировать левый операнд построчно, а
				// после окончания обработки одной строки левого операнда
				// получать готовую строку результата.

				for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

					// Переход к новой строке, сброс накопителя результата.
					//#pragma omp parallel for
					for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
						vector_sum[i_1] = 0.0; // обнуление.
					}
					// хоть профайлер и показывает что на memset тратиться меньше процессорного времени,
					// но там возникает системный вызов на который тратиться столько же времени что и раньше.
					// работа перекочевала из одного места в другое.
					// Более быстрое обнуление.
					//memset(vector_sum, 0, size_v);

					// сканируем все элементы строки левого операнда.
					for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
						integer col_ind = Amat[ii1].j;

						// Сканируем col_ind строку правого операнда накапливая сумму.
						for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
							doublerealT rleft = Amat[ii1].aij;
							doublerealT rright = P[ii2].aij;

							vector_sum[P[ii2].i] += rleft*rright;
						}
					}

					for (integer jstr = 1; jstr <= numberofcoarcenodes; jstr++) {
						if (fabs(vector_sum[jstr]) > 1.0e-30) {
							Amat[istartAnew2].aij = vector_sum[jstr];
							Amat[istartAnew2].i = istr;
							Amat[istartAnew2].j = jstr;
							istartAnew2++;
						}
					}

				}

				delete[] vector_sum;



				delete[] row_ind_AS;
				delete[] row_ind_AE;
				delete[] row_ind_PS;
				delete[] row_ind_PE;
			}
			else {

				// Рабочая версия алгоритма Фреда Густавсона.
				// IBM 1978 Sparse Matrix multiplication.

				// Преобразование обоих матриц в формат CRS.
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
					}
					else {
						qs(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
					}
				}
				else {
					HeapSort(P, 1 + iaddR, iaddR + nnzR - 1, comparej);
				}

				integer* row_ind_AS = new integer[numberofcoarcenodes + 1];
				integer* row_ind_AE = new integer[numberofcoarcenodes + 1];
				integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
				integer iend2 = istartAnew - 1;
				for (integer i = 1; i <= n; i++) {
					flag[i] = false;
				}
				for (integer ii = istart2; ii <= iend2; ii++) {
					if (flag[Amat[ii].i] == false) {
						// сканируем построчно.
						integer istr = Amat[ii].i;
						integer ic = ii;

						integer kf = ic;

						while ((kf <= iend2) && (Amat[kf].i == istr)) {
							kf++;
						}
						kf--;
						row_ind_AS[istr] = ic;
						row_ind_AE[istr] = kf;
						flag[Amat[ii].i] = true;

					}
				}

				integer* row_ind_PS = new integer[n_a[ilevel - 1] + 1];
				integer* row_ind_PE = new integer[n_a[ilevel - 1] + 1];
				// Инициализация чрезвычайно важна, т.к. 
				// обязательно присутствуют пустые строки которые
				// надо корректно обрабатывать.
				for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
					row_ind_PS[ii] = -1; // инициализация.
					row_ind_PE[ii] = -2;
				}
				integer istart4 = 1 + iaddR;
				integer iend4 = nnzR - 1 + iaddR;
				for (integer i = 1; i <= n; i++) {
					flag[i] = false;
				}
				for (integer ii = istart4; ii <= iend4; ii++) {
					if (flag[P[ii].j] == false) {
						// сканируем построчно.
						integer istr = P[ii].j;
						integer ic = ii;

						integer kf = ic;

						while ((kf <= iend4) && (P[kf].j == istr)) {
							kf++;
						}
						kf--;
						row_ind_PS[istr] = ic;
						row_ind_PE[istr] = kf;
						flag[P[ii].j] = true;

					}
				}

				// Данный код подтверждает что обязательно присутствуют
				// пустые строки.
				//for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
				//if (row_ind_PS[ii] == -1) {
#if doubleintprecision == 1
				//printf("propusk string %lld\n", row_ind_PE[ii]);
#else
				//printf("propusk string %d\n", row_ind_PE[ii]);
#endif
				
				//getchar();
				//}
				//}

				// Накопитель результата.
				doublerealT* vector_sum = new doublerealT[numberofcoarcenodes + 1];
				//integer size_v = sizeof(doublerealT)*(1 + numberofcoarcenodes);
				// Храним индексы ненулевых элементов в отсортированном порядке.
				integer* index_visit = new integer[n_a[ilevel - 1] + 1];
				integer index_size = 0;

				// Мы будем сканировать левый операнд построчно, а
				// после окончания обработки одной строки левого операнда
				// получать готовую строку результата.

				for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

					// Переход к новой строке, сброс накопителя результата.
					//#pragma omp parallel for
					//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
					//vector_sum[i_1] = 0.0; // обнуление.
					//}
					// хоть профайлер и показывает что на memset тратиться меньше процессорного времени,
					// но там возникает системный вызов на который тратиться столько же времени что и раньше.
					// работа перекочевала из одного места в другое.
					// Более быстрое обнуление.
					//memset(vector_sum, 0, size_v);

					// сканируем все элементы строки левого операнда.
					for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
						integer col_ind = Amat[ii1].j;

						// Сканируем col_ind строку правого операнда накапливая сумму.
						for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
							doublerealT left_operand = Amat[ii1].aij;
							doublerealT right_operand = P[ii2].aij;

							integer iaddind = P[ii2].i;
							bool foundnow = false;
							integer ifoundind = -1;
							// линейный поиск позиции в массиве на добавление.
							for (integer i_6 = 1; i_6 <= index_size; i_6++) {
								if (index_visit[i_6] == iaddind) {
									foundnow = true;
									ifoundind = i_6;
									break;
								}
							}
							if (foundnow) {
								vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							}
							else {
								// Первое добавление.
								index_size++;
								index_visit[index_size] = iaddind;
								ifoundind = index_size;
								vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							}



							//vector_sum[P[ii2].i] += rleft*rright;
						}
					}

					// 5 декабря 2015 Избирательность приводящая к сохранению разреженности.
					/*
					doublerealT threshhold_maxelem_in_string = -1.0;
					for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					if (jstr != istr) {
					if (fabs(vector_sum[jstr]) > threshhold_maxelem_in_string) {
					threshhold_maxelem_in_string = fabs(vector_sum[jstr]);
					}
					}
					}
					*/

					//doublerealT mul_theta = 0.008;
					//switch (dim_2D) {
					//case 0: // 3D
					//mul_theta = mul_theta3D;// 0.13;
					//break;
					//case 1: // 2D
					//mul_theta = 0.008;
					//break;
					//};

					for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						integer jstr = index_visit[i_6];
						if (istr != jstr) {
							// 5 декабря 2015 года. Сохранение разреженности.
							if (fabs(vector_sum[jstr]) > 1.0e-30) {
								//if (fabs(vector_sum[jstr]) > mul_theta*theta*threshhold_maxelem_in_string) {
								Amat[istartAnew2].aij = vector_sum[jstr];
								Amat[istartAnew2].i = istr;
								Amat[istartAnew2].j = jstr;
								istartAnew2++;
							}
						}
						else {
							Amat[istartAnew2].aij = vector_sum[jstr];
							Amat[istartAnew2].i = istr;
							Amat[istartAnew2].j = jstr;
							istartAnew2++;
						}
					}
					index_size = 0;

				}

				delete[] vector_sum;
				delete[] index_visit;


				delete[] row_ind_AS;
				delete[] row_ind_AE;
				delete[] row_ind_PS;
				delete[] row_ind_PE;
			}

		}


		// Есть подозрение что это избыточный код и его не надо вызывать.
		// 13  декабря 2015.
		// Это полностью подтвердилось 13 декабря 2015 года.
		/*
		if (bquicktypesort) {
		QuickSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
		if (bqs)
		{
		if (bCounting_Sort) {
		Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else
		{
		// Быстрая сортировка Хоара.
		qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		*/

		// Копируем матрицу А следующего уровня влево вплотную к матице первоначального уровня.
		//integer icounter3 = 1;
		integer nsize = istartAnew2 - (istartAnew);
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd, i_2 = 1; i_2 <= nsize; i_1++, i_2++) {
			integer i_right_position = istartAnew - 1 + i_2;
			Amat[i_1] = Amat[i_right_position];
		}


		printf("Prolongation is construct.\n");
#if doubleintprecision == 1
		printf("Error interpolation is count %lld\n", ipromah);
		printf("diagnostic ipromah_one=%lld\n", ipromah_one);
#else
		printf("Error interpolation is count %d\n", ipromah);
		printf("diagnostic ipromah_one=%d\n", ipromah_one);
#endif
		
		if (debug_reshime) system("pause");

		delete[] C_numerate;

		nnz_aRP[ilevel - 1] = nnzR - 1;
		iaddR += nnzR - 1;
		n_a[ilevel] = icounter - 1;
		nnz_a[ilevel] = nsize;
		iadd += nnz_a[ilevel - 1];


		ilevel++;

		// сортировка А по i.
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		/*
		if (bquicktypesort) {
		QuickSort(Amat,  1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		if (nnz_a[ilevel - 1] < heapsortsizelimit) {
		HeapSort(Amat, n_a[ilevel - 1], 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		Ak* Aorig = &Amat[1 + iadd];
		MergeSort(Aorig, nnz_a[ilevel - 1]);
		Aorig = nullptr;
		}
		}
		*/

#if doubleintprecision == 1
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%lld ",Amat[i_1].j);
		//}
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#else
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%d ",Amat[i_1].j);
		//}
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#endif
		


		//exit(1);
		printf("one level construct OK.\n");
		if (debug_reshime) system("pause");


		//printf("export b\n");
		//exporttecplot(b,n);

		//doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

		// restriction
		//restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
		//for (integer ii = 1; ii <= n_a[0]; ii++) {
		//b[ii] = 0.0;
		//}

		/*{
		doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		for (integer ii = 1; ii <= n_a[1]; ii++) {
		test_coarse[ii] = 0.0;
		}

		{
		doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		for (integer ii = 1; ii <= n_a[2]; ii++) {
		test_coarse1[ii] = 0.0;
		}

		prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		}

		prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		}
		*/
		//prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

		//exporttecplot(b, n);
		// proverka start
		// на сетке 81х81 проверка успешно проходится.


		printf("proverka start\n");
		// первый уровень вложенности.
		if (ilevel > 1) {
			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}

			for (integer ii77 = nnz_a[0] + 1; ii77 <= nnz_a[0] + nnz_a[1]; ii77++) {
				if (flag[Amat[ii77].i] == false) {
					integer istr77 = Amat[ii77].i;
					integer ic77 = ii77;
					//integer icdiag = ii77;
					doublerealT ap = 0.0;
					//x[istr] = b[istr];
					while ((ic77 <= nnz_a[0] + nnz_a[1]) && (Amat[ic77].i == istr77)) {
						if (Amat[ic77].j != istr77) {
							//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
						}
						else {
							ap = Amat[ic77].aij;
							//icdiag = ic77;
						}
						ic77++;
					}
					if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
						printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr77);
#else
						printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr77);
#endif
						
						system("PAUSE");
						//exit(1);
					}

					flag[Amat[ii77].i] = true;

				}
			}
		}


		//проверка конец

		delete[] count_neighbour;
		delete[] row_startA;

	}// иерархия сеток построена.

	ilevel--;

	// 31.224s [50.986] 2D m=81 debug x64 acumulqtor
	// 13.792 [18.156] 2D m=81 realese x64 acumulqtor
	// 8.028s 2D m=81 debug x64 rozetka
	// 3.827 2D m=81 realese x64 rozetka

#if doubleintprecision == 1
	printf("ilevel=%lld\n", ilevel);
	for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
		printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
	}
#else
	printf("ilevel=%d\n", ilevel);
	for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
		printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
	}
#endif
	
	printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	if (debug_reshime) system("pause");
	//system("pause");
	//exit(1);

	/*
	// отладочная печать в рабочей версии требуется закомментировать.
	for (integer ii = 1; ii <= n; ii++) {
	flag_[ii] = false;
	}
	for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
	if (flag_[R[ii].i] == false) {
	integer istr = R[ii].i;
	integer ic7 = ii;
	while ((ic7 <= iaddR + nnzR - 1) && (R[ic7].i == istr)) {
	printf("%e ", R[ic7].aij);
	ic7++;
	}
	printf("\n");
	system("pause");
	flag_[R[ii].i] = true;
	}
	}
	*/



	/*
	//exporttecplot(b,n);

	doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

	// restriction
	restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
	for (integer ii = 1; ii <= n_a[0]; ii++) {
	b[ii] = 0.0;
	}

	{
	doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

	// restriction
	restriction(R, 1+nnz_aRP[0], nnz_aRP[0]+nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	for (integer ii = 1; ii <= n_a[1]; ii++) {
	test_coarse[ii] = 0.0;
	}

	{
	doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

	// restriction
	restriction(R, 1 + nnz_aRP[0]+nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1]+nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	for (integer ii = 1; ii <= n_a[2]; ii++) {
	test_coarse1[ii] = 0.0;
	}

	prolongation(P, 1 + nnz_aRP[0]+ nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	}

	prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	}

	prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

	exporttecplot(b, n);
	*/

	// подготовка матрицы к cycling:
	/*
	// smoother.
	// 1 september 2015.
	void seidel(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
	{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	doublerealT ap = 0.0;
	x[istr] = b[istr];
	while ((ic<=iend)&&(Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else ap = Amat[ic].aij;
	ic++;
	}
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld",istr);
	#else
		printf("zero diagonal elements in string %d",istr);
	#endif
	
	getchar();
	exit(1);
	}
	else {
	x[istr] /= ap;
	}
	flag[Amat[ii].i] = true;
	}
	}


	} // seidel

	*/
	integer *row_ptr_start = new integer[4 * n_a[0] + 1];
	integer *row_ptr_end = new integer[4 * n_a[0] + 1];
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = 1; ii <= nnz_a[0]; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			integer icdiag = ii;
			row_ptr_start[istr] = ii;
			doublerealT ap = 0.0;
			//x[istr] = b[istr];
			while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else {
					ap = Amat[ic].aij;
					icdiag = ic;
				}
				ic++;
			}
			row_ptr_end[istr] = ic - 1;
			if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld in basic matrix", istr);
#else
				printf("zero diagonal elements in string %d in basic matrix", istr);
#endif
				
				system("PAUSE");
				exit(1);
			}
			else {
				//x[istr] /= ap;
			}

			flag[Amat[ii].i] = true;
			Ak temp = Amat[ii];
			Amat[ii] = Amat[icdiag];
			Amat[icdiag] = temp;
			Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
		}
	}

	bool bstop = false;
	// первый уровень вложенности.
	if (ilevel > 1) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}

		for (integer ii = nnz_a[0] + 1; ii <= nnz_a[0] + nnz_a[1]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= nnz_a[0] + nnz_a[1]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr);
#else
					printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr);
#endif
					
					system("PAUSE");
					//exit(1);
					bstop = true;
				}
				else {

					flag[Amat[ii].i] = true;
					Ak temp = Amat[ii];
					Amat[ii] = Amat[icdiag];
					Amat[icdiag] = temp;
					Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.

				}


			}
		}
	}

	if (bstop) exit(1);

	// второй уровень вложенности.

	if (ilevel > 2) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = nnz_a[0] + nnz_a[1] + 1; ii <= nnz_a[0] + nnz_a[1] + nnz_a[2]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= nnz_a[0] + nnz_a[1] + nnz_a[2]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 2 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 2 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// третий уровень вложенности.

	if (ilevel > 3) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = nnz_a[0] + nnz_a[1] + nnz_a[2] + 1; ii <= nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 3 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 3 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// 14 сентября 2015 понедельник
	// четвёртый уровень вложенности.

	if (ilevel > 4) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 4 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 4 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// пятый уровень вложенности.

	if (ilevel > 5) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 5 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 5 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}

	// шестой уровень вложенности.

	if (ilevel > 6) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 6 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 6 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}




	// smoother.
	// 9 september 2015.
	// q - quick.
	// seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
	//void seidelq(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
	//{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	//integer startpos = istartq + iadd;
	//integer endpos = iendq+iadd;
	//for (integer ii = startpos; ii <= endpos; ii++) {
	//integer istr = ii - iadd;
	//x[istr] = b[istr];
	//for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
	//{
	//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
	//}
	//x[istr] *= Amat[row_ptr_start[ii]].aij;
	//}


	//} // seidelq


	delete[] this_is_C_node;
	delete[] this_is_F_node;


	printf("cycling: V cycle.\n");
#if doubleintprecision == 1
	printf("level=%lld\n", ilevel);
#else
	printf("level=%d\n", ilevel);
#endif
	
	printf("multigrid R.P.Fedorenko 1961.\n");
	printf("standart aglomerative algebraic multigrid method.\n");
	if (debug_reshime) system("pause");
	//exit(1);

	// 10 11 21 multigrid tutorial Вильм Бригг.
	// Высокорейнольдсовое обтекание квадрата в DavisTest,
	// решатель работал на x-компоненте скорости. Сетка сгущалась
	// к поверхности квадрата достаточно сильно. Это дало расходимость
	// amg v0.08 решателя на данной задаче с параметрами nu1=4, nu2=3.
	// Параметры nu1=8, nu2=7 обеспечили сходимость вычислительного процесса.

	// Возможно имеет смысл сделать управляемый выход из сглаживателя, допустим
	// если невязка опустилась ниже первоначальной в 0.1 раз то имеет смысл досрочно 
	// оборвать итерации сглаживателя.


	integer nu1 = 9;  // 4 // 8
	integer nu2 = 8;  // 3 // 7

	if (dim_2D == 0) {
		// 3D
		nu1 = 9;
		nu2 = 8;
	}

#if doubleintprecision == 1
	printf("nu1=%lld, nu2=%lld\n", nu1, nu2);
#else
	printf("nu1=%d, nu2=%d\n", nu1, nu2);
#endif
	

	//ilevel = 1; //debug
	doublerealT rho = 1.0;
	doublerealT dres = 1.0;
	integer iiter = 1;
	//const doublerealT tolerance = 1.0e-12;
	// 13 февраля 2016 калибруем точность солвера с целью ускорения получения результата.
	// Т.к. нам ненужна точность выше чем десятая доля градуса по температуре.
	// начальное значение невязки составляет примерно 7000.0.
	const doublerealT tolerance = 0.003; // точность выхода по классическому определению L2 нормы.

	doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
	doublerealT *residual_coarse = nullptr;
	doublerealT* error_approx_coarse = nullptr;
	doublerealT *residual_fine1 = nullptr;
	doublerealT *residual_coarse1 = nullptr;
	doublerealT* error_approx_coarse1 = nullptr;
	doublerealT *error_approx_fine1 = nullptr;
	doublerealT *residual_fine2 = nullptr;
	doublerealT *residual_coarse2 = nullptr;
	doublerealT* error_approx_coarse2 = nullptr;
	doublerealT *error_approx_fine2 = nullptr;
	doublerealT *residual_fine3 = nullptr;
	doublerealT *residual_coarse3 = nullptr;
	doublerealT* error_approx_coarse3 = nullptr;
	doublerealT *error_approx_fine3 = nullptr;
	doublerealT *residual_fine4 = nullptr;
	doublerealT *residual_coarse4 = nullptr;
	doublerealT *error_approx_coarse4 = nullptr;
	doublerealT *error_approx_fine4 = nullptr;
	doublerealT *residual_fine5 = nullptr;
	doublerealT *residual_coarse5 = nullptr;
	doublerealT* error_approx_coarse5 = nullptr;
	doublerealT *error_approx_fine5 = nullptr;
	doublerealT *residual_fine6 = nullptr;
	doublerealT *residual_coarse6 = nullptr;
	doublerealT* error_approx_coarse6 = nullptr;
	doublerealT *error_approx_fine6 = nullptr;

	if (ilevel > 1) {
		residual_coarse = new doublerealT[n_a[1] + 1];
		error_approx_coarse = new doublerealT[n_a[1] + 1];
		if (ilevel > 2) {
			// residual
			residual_fine1 = new doublerealT[n_a[1] + 1];
			residual_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_fine1 = new doublerealT[n_a[1] + 1];
			if (ilevel > 3) {
				// residual
				residual_fine2 = new doublerealT[n_a[2] + 1];
				residual_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_fine2 = new doublerealT[n_a[2] + 1];
				if (ilevel > 4) {
					// residual
					residual_fine3 = new doublerealT[n_a[3] + 1];
					residual_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_fine3 = new doublerealT[n_a[3] + 1];
					if (ilevel > 5) {
						// residual
						residual_fine4 = new doublerealT[n_a[4] + 1];
						residual_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_fine4 = new doublerealT[n_a[4] + 1];
						if (ilevel > 6) {
							// residual
							residual_fine5 = new doublerealT[n_a[5] + 1];
							residual_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_fine5 = new doublerealT[n_a[5] + 1];
							if (ilevel > 7) {
								// residual
								residual_fine6 = new doublerealT[n_a[6] + 1];
								residual_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_fine6 = new doublerealT[n_a[6] + 1];
							}
						}
					}
				}
			}
		}
	}
	doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];



	// Для поправки давления возникает задача когда на всех границах стоит условие Неймана,
	// это приводит к тому что метод работает бесконечно долго и не может сойтись, поэтому нужно 
	// заложить критерий останова по превышению количества допустимых итераций (не более 1000 итераций).
	// 1000 итераций это очень долго поэтому для поправки давления надо подобрать разумное количество 
	// итераций т.к. от этого существенным образом зависит быстродействие гидродинамического алгоритма.
	integer iter_limit = 0;

	//for (integer iprohod = 0; iprohod < 20; iprohod++) {
	while (dres>tolerance) {

		if (iter_limit > 1000) {
			printf("may be Neimann in the all boundares.\n");
			break; // досрочный выход из while цикла.
		}
		iter_limit++;

#ifdef MY_DEBUG_NOT_NUMBER
		if (dres!=dres) {
			printf("divergence AMG detected\n");
			printf("\a\a\a\a\a\a\a\a");
			system("pause");
			exit(1);
		}
#endif

		// smother
		for (integer iter = 0; iter < nu1; iter++) {
			//seidel<doublereal>(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
			//quick seidel
			seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);

		}

		//exporttecplot(x, n);

		// residual_r
		//doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
		//residual(Amat, 1, nnz_a[0], x, b, flag, n_a[0], residual_fine);
		residualq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
		dres = norma(residual_fine, n_a[0]);
#if doubleintprecision == 1
		printf("%lld %e rho=%e\n", iiter, dres, dres / rho);
#else
		printf("%d %e rho=%e\n", iiter, dres, dres / rho);
#endif
		
		iiter++;
		//rho=norma(residual_fine, n_a[0]);
		rho = dres;
		//if (iprohod%5==0) getchar();
		if (ilevel > 1) {

			//doublerealT *residual_coarse = new doublerealT[n_a[1] + 1];

			// restriction
			restriction(R, 1, nnz_aRP[0], flag, residual_fine, residual_coarse, n_a[0], n_a[1]);

			// Amat*e=r;
			//doublerealT* error_approx_coarse = new doublerealT[n_a[1] + 1];
			for (integer ii = 1; ii <= n_a[1]; ii++) {
				error_approx_coarse[ii] = 0.0;
			}
			// pre smothing
			for (integer iter = 0; iter < nu1; iter++) {
				//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
				seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
			}

			if (ilevel > 2) {
				// residual
				//doublerealT *residual_fine1 = new doublerealT[n_a[1] + 1];
				//residual(Amat, 1+2*nnz_a[0], 2*nnz_a[0]+nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1], residual_fine1);
				residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
				//residualqspeshial(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);


				//doublerealT *residual_coarse1 = new doublerealT[n_a[2] + 1];

				// restriction
				restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, residual_fine1, residual_coarse1, n_a[1], n_a[2]);

				// Amat*e=r;
				//doublerealT* error_approx_coarse1 = new doublerealT[n_a[2] + 1];
				for (integer ii = 1; ii <= n_a[2]; ii++) {
					error_approx_coarse1[ii] = 0.0;
				}
				// pre smothing
				for (integer iter = 0; iter < nu1; iter++) {
					//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
					seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
				}
				if (ilevel > 3) {
					// residual
					//doublerealT *residual_fine2 = new doublerealT[n_a[2] + 1];
					//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2], residual_fine2);
					residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
					//residualqspeshial(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);

					//doublerealT *residual_coarse2 = new doublerealT[n_a[3] + 1];

					// restriction
					restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, residual_fine2, residual_coarse2, n_a[2], n_a[3]);

					// Amat*e=r;
					//doublerealT* error_approx_coarse2 = new doublerealT[n_a[3] + 1];
					for (integer ii = 1; ii <= n_a[3]; ii++) {
						error_approx_coarse2[ii] = 0.0;
					}
					// pre smothing
					for (integer iter = 0; iter < nu1; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
						seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);

					}
					if (ilevel > 4) {
						// residual
						//doublerealT *residual_fine3 = new doublerealT[n_a[3] + 1];
						//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3], residual_fine3);
						residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
						//speshial
						//residualqspeshial(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);



						//doublerealT *residual_coarse3 = new doublerealT[n_a[4] + 1];

						// restriction
						restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, residual_fine3, residual_coarse3, n_a[3], n_a[4]);

						// Amat*e=r;
						//doublerealT* error_approx_coarse3 = new doublerealT[n_a[4] + 1];
						for (integer ii = 1; ii <= n_a[4]; ii++) {
							error_approx_coarse3[ii] = 0.0;
						}
						// pre smothing
						for (integer iter = 0; iter < nu1; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
							seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
						}
						if (ilevel > 5) {
							// residual
							//doublerealT *residual_fine4 = new doublerealT[n_a[4] + 1];
							//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4], residual_fine4);
							residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
							//speshial 14 september 2015.
							//residualqspeshial(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);


							//doublerealT *residual_coarse4 = new doublerealT[n_a[5] + 1];

							// restriction
							restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, residual_fine4, residual_coarse4, n_a[4], n_a[5]);

							// Amat*e=r;
							//doublerealT* error_approx_coarse4 = new doublerealT[n_a[5] + 1];
							for (integer ii = 1; ii <= n_a[5]; ii++) {
								error_approx_coarse4[ii] = 0.0;
							}
							// pre smothing
							for (integer iter = 0; iter < nu1; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
								seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
							}
							if (ilevel > 6) {
								// residual
								//doublerealT *residual_fine5 = new doublerealT[n_a[5] + 1];
								//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5], residual_fine5);
								//if (ilevel <= 15) {
								residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
								//}
								//else {
								// приводит к расходимости.
								//speshial 14 september 2015.
								// это уже приводит к увеличению числа итераций на примере сетки в 1млн узлов. остановимся.
								//residualqspeshial(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
								//}

								//doublerealT *residual_coarse5 = new doublerealT[n_a[6] + 1];

								// restriction
								restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, residual_fine5, residual_coarse5, n_a[5], n_a[6]);

								// Amat*e=r;
								//doublerealT* error_approx_coarse5 = new doublerealT[n_a[6] + 1];
								for (integer ii = 1; ii <= n_a[6]; ii++) {
									error_approx_coarse5[ii] = 0.0;
								}
								// pre smothing
								for (integer iter = 0; iter < nu1; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
									seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
								}

								if (ilevel > 7) {
									// residual
									//doublerealT *residual_fine6 = new doublerealT[n_a[6] + 1];
									//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] +2*nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6], residual_fine6);
									residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);

									//doublerealT *residual_coarse6 = new doublerealT[n_a[7] + 1];

									// restriction
									restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, residual_fine6, residual_coarse6, n_a[6], n_a[7]);

									// Amat*e=r;
									//doublerealT* error_approx_coarse6 = new doublerealT[n_a[7] + 1];
									for (integer ii = 1; ii <= n_a[7]; ii++) {
										error_approx_coarse6[ii] = 0.0;
									}
									// pre smothing
									for (integer iter = 0; iter < nu1; iter++) {
										seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7]);
									}

									if (ilevel > 8) {
										// residual
										doublerealT *residual_fine7 = new doublerealT[n_a[7] + 1];
										residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7], residual_fine7);


										doublerealT *residual_coarse7 = new doublerealT[n_a[8] + 1];

										// restriction
										restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, residual_fine7, residual_coarse7, n_a[7], n_a[8]);

										// Amat*e=r;
										doublerealT* error_approx_coarse7 = new doublerealT[n_a[8] + 1];
										for (integer ii = 1; ii <= n_a[8]; ii++) {
											error_approx_coarse7[ii] = 0.0;
										}
										// pre smothing
										for (integer iter = 0; iter < nu1; iter++) {
											seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
										}


										if (ilevel > 9) {
											// residual
											doublerealT *residual_fine8 = new doublerealT[n_a[8] + 1];
											integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7];
											integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
											residual(Amat, n1, n2, error_approx_coarse7, residual_coarse7, flag, n_a[8], residual_fine8);


											doublerealT *residual_coarse8 = new doublerealT[n_a[9] + 1];

											// restriction
											integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
											integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
											restriction(R, n3, n4, flag, residual_fine8, residual_coarse8, n_a[8], n_a[9]);

											// Amat*e=r;
											doublerealT* error_approx_coarse8 = new doublerealT[n_a[9] + 1];
											for (integer ii = 1; ii <= n_a[9]; ii++) {
												error_approx_coarse8[ii] = 0.0;
											}
											// pre smothing
											for (integer iter = 0; iter < nu1; iter++) {
												integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
												integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
												seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
											}

											if (ilevel > 10) {
												// 8 сентября 2015 РИМИНИ пляж 

												// residual
												doublerealT *residual_fine9 = new doublerealT[n_a[9] + 1];
												integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
												integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
												residual(Amat, n1, n2, error_approx_coarse8, residual_coarse8, flag, n_a[9], residual_fine9);


												doublerealT *residual_coarse9 = new doublerealT[n_a[10] + 1];

												// restriction
												integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
												integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
												restriction(R, n3, n4, flag, residual_fine9, residual_coarse9, n_a[9], n_a[10]);

												// Amat*e=r;
												doublerealT* error_approx_coarse9 = new doublerealT[n_a[10] + 1];
												for (integer ii = 1; ii <= n_a[10]; ii++) {
													error_approx_coarse9[ii] = 0.0;
												}
												// pre smothing
												for (integer iter = 0; iter < nu1; iter++) {
													integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
													integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
													seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
												}

												if (ilevel > 11) {
													// 8 сентября 2015 РИМИНИ пляж 

													// residual
													doublerealT *residual_fine10 = new doublerealT[n_a[10] + 1];
													integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
													integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
													residual(Amat, n1, n2, error_approx_coarse9, residual_coarse9, flag, n_a[10], residual_fine10);


													doublerealT *residual_coarse10 = new doublerealT[n_a[11] + 1];

													// restriction
													integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
													integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
													restriction(R, n3, n4, flag, residual_fine10, residual_coarse10, n_a[10], n_a[11]);

													// Amat*e=r;
													doublerealT* error_approx_coarse10 = new doublerealT[n_a[11] + 1];
													for (integer ii = 1; ii <= n_a[11]; ii++) {
														error_approx_coarse10[ii] = 0.0;
													}
													// pre smothing
													for (integer iter = 0; iter < nu1; iter++) {
														integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
														integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
														seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
													}

													if (ilevel > 12) {
														// 11 сентября 2015 РИМИНИ пляж 

														// residual
														doublerealT *residual_fine11 = new doublerealT[n_a[11] + 1];
														integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
														integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
														residual(Amat, n1, n2, error_approx_coarse10, residual_coarse10, flag, n_a[11], residual_fine11);


														doublerealT *residual_coarse11 = new doublerealT[n_a[12] + 1];

														// restriction
														integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
														integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
														restriction(R, n3, n4, flag, residual_fine11, residual_coarse11, n_a[11], n_a[12]);

														// Amat*e=r;
														doublerealT* error_approx_coarse11 = new doublerealT[n_a[12] + 1];
														for (integer ii = 1; ii <= n_a[12]; ii++) {
															error_approx_coarse11[ii] = 0.0;
														}
														// pre smothing
														for (integer iter = 0; iter < nu1; iter++) {
															integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
															integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
															seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
														}

														if (ilevel > 13) {
															// 11 сентября 2015 РИМИНИ пляж 

															// residual
															doublerealT *residual_fine12 = new doublerealT[n_a[12] + 1];
															integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
															integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
															residual(Amat, n1, n2, error_approx_coarse11, residual_coarse11, flag, n_a[12], residual_fine12);


															doublerealT *residual_coarse12 = new doublerealT[n_a[13] + 1];

															// restriction
															integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
															integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
															restriction(R, n3, n4, flag, residual_fine12, residual_coarse12, n_a[12], n_a[13]);

															// Amat*e=r;
															doublerealT* error_approx_coarse12 = new doublerealT[n_a[13] + 1];
															for (integer ii = 1; ii <= n_a[13]; ii++) {
																error_approx_coarse12[ii] = 0.0;
															}
															// pre smothing
															for (integer iter = 0; iter < nu1; iter++) {
																integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
															}


															if (ilevel > 14) {
																// 11 сентября 2015 РИМИНИ пляж 

																// residual
																doublerealT *residual_fine13 = new doublerealT[n_a[13] + 1];
																integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																residual(Amat, n1, n2, error_approx_coarse12, residual_coarse12, flag, n_a[13], residual_fine13);


																doublerealT *residual_coarse13 = new doublerealT[n_a[14] + 1];

																// restriction
																integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																restriction(R, n3, n4, flag, residual_fine13, residual_coarse13, n_a[13], n_a[14]);

																// Amat*e=r;
																doublerealT* error_approx_coarse13 = new doublerealT[n_a[14] + 1];
																for (integer ii = 1; ii <= n_a[14]; ii++) {
																	error_approx_coarse13[ii] = 0.0;
																}
																// pre smothing
																for (integer iter = 0; iter < nu1; iter++) {
																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																	seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																}

																if (ilevel > 15) {
																	// 14 сентября 2015 Москва на работе в пн. 

																	// residual
																	doublerealT *residual_fine14 = new doublerealT[n_a[14] + 1];
																	integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																	integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																	residual(Amat, n1, n2, error_approx_coarse13, residual_coarse13, flag, n_a[14], residual_fine14);


																	doublerealT *residual_coarse14 = new doublerealT[n_a[15] + 1];

																	// restriction
																	integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																	integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																	restriction(R, n3, n4, flag, residual_fine14, residual_coarse14, n_a[14], n_a[15]);

																	// Amat*e=r;
																	doublerealT* error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																	for (integer ii = 1; ii <= n_a[15]; ii++) {
																		error_approx_coarse14[ii] = 0.0;
																	}
																	// pre smothing
																	for (integer iter = 0; iter < nu1; iter++) {
																		integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																		integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																		seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																	}

																	if (ilevel > 16) {
																		// 10 октября 2015. 

																		// residual
																		doublerealT *residual_fine15 = new doublerealT[n_a[15] + 1];
																		integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																		integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																		residual(Amat, n1, n2, error_approx_coarse14, residual_coarse14, flag, n_a[15], residual_fine15);


																		doublerealT *residual_coarse15 = new doublerealT[n_a[16] + 1];

																		// restriction
																		integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																		integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																		restriction(R, n3, n4, flag, residual_fine15, residual_coarse15, n_a[15], n_a[16]);

																		// Amat*e=r;
																		doublerealT* error_approx_coarse15 = new doublerealT[n_a[16] + 1];
																		for (integer ii = 1; ii <= n_a[16]; ii++) {
																			error_approx_coarse15[ii] = 0.0;
																		}
																		// pre smothing
																		for (integer iter = 0; iter < nu1; iter++) {
																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																			seidel(Amat, n5, n6, error_approx_coarse15, residual_coarse15, flag, n_a[16]);
																		}

																		if (ilevel > 17) {
																			// 10 октября 2015. 

																			// residual
																			doublerealT *residual_fine16 = new doublerealT[n_a[16] + 1];
																			integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																			integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																			residual(Amat, n1, n2, error_approx_coarse15, residual_coarse15, flag, n_a[16], residual_fine16);


																			doublerealT *residual_coarse16 = new doublerealT[n_a[17] + 1];

																			// restriction
																			integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																			integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																			restriction(R, n3, n4, flag, residual_fine16, residual_coarse16, n_a[16], n_a[17]);

																			// Amat*e=r;
																			doublerealT* error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																			for (integer ii = 1; ii <= n_a[17]; ii++) {
																				error_approx_coarse16[ii] = 0.0;
																			}
																			// pre smothing
																			for (integer iter = 0; iter < nu1; iter++) {
																				integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																				integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																				seidel(Amat, n5, n6, error_approx_coarse16, residual_coarse16, flag, n_a[17]);
																			}

																			if (ilevel > 18) {
																				// 5 декабря 2015. 

																				// residual
																				doublerealT *residual_fine17 = new doublerealT[n_a[17] + 1];
																				integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																				integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																				residual(Amat, n1, n2, error_approx_coarse16, residual_coarse16, flag, n_a[17], residual_fine17);


																				doublerealT *residual_coarse17 = new doublerealT[n_a[18] + 1];

																				// restriction
																				integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																				integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17];
																				restriction(R, n3, n4, flag, residual_fine17, residual_coarse17, n_a[17], n_a[18]);

																				// Amat*e=r;
																				doublerealT* error_approx_coarse17 = new doublerealT[n_a[18] + 1];
																				for (integer ii = 1; ii <= n_a[18]; ii++) {
																					error_approx_coarse17[ii] = 0.0;
																				}
																				// pre smothing
																				for (integer iter = 0; iter < nu1; iter++) {
																					integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																					integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17] + nnz_a[18];
																					seidel(Amat, n5, n6, error_approx_coarse17, residual_coarse17, flag, n_a[18]);
																				}

																				// post smothing
																				for (integer iter = 0; iter < nu2; iter++) {
																					integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																					integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17] + nnz_a[18];
																					seidel(Amat, n5, n6, error_approx_coarse17, residual_coarse17, flag, n_a[18]);
																				}


																				// prolongation
																				// residual_r
																				doublerealT *error_approx_fine17 = new doublerealT[n_a[17] + 1];
																				for (integer ii = 1; ii <= n_a[17]; ii++) {
																					error_approx_fine17[ii] = 0.0;
																				}



																				integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																				integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17];
																				prolongation(P, n7, n8, flag, error_approx_fine17, error_approx_coarse17, n_a[17], n_a[18]);

																				// correction
																				for (integer ii = 1; ii <= n_a[17]; ii++) {
																					error_approx_coarse16[ii] += error_approx_fine17[ii];
																				}

																				// free
																				delete[] error_approx_fine17;
																				delete[] error_approx_coarse17;
																				delete[] residual_coarse17;
																				delete[] residual_fine17;

																			}


																			// post smothing
																			for (integer iter = 0; iter < nu2; iter++) {
																				integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																				integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																				seidel(Amat, n5, n6, error_approx_coarse16, residual_coarse16, flag, n_a[17]);
																			}


																			// prolongation
																			// residual_r
																			doublerealT *error_approx_fine16 = new doublerealT[n_a[16] + 1];
																			for (integer ii = 1; ii <= n_a[16]; ii++) {
																				error_approx_fine16[ii] = 0.0;
																			}



																			integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																			integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																			prolongation(P, n7, n8, flag, error_approx_fine16, error_approx_coarse16, n_a[16], n_a[17]);

																			// correction
																			for (integer ii = 1; ii <= n_a[16]; ii++) {
																				error_approx_coarse15[ii] += error_approx_fine16[ii];
																			}

																			// free
																			delete[] error_approx_fine16;
																			delete[] error_approx_coarse16;
																			delete[] residual_coarse16;
																			delete[] residual_fine16;

																		}


																		// post smothing
																		for (integer iter = 0; iter < nu2; iter++) {
																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																			seidel(Amat, n5, n6, error_approx_coarse15, residual_coarse15, flag, n_a[16]);
																		}


																		// prolongation
																		// residual_r
																		doublerealT *error_approx_fine15 = new doublerealT[n_a[15] + 1];
																		for (integer ii = 1; ii <= n_a[15]; ii++) {
																			error_approx_fine15[ii] = 0.0;
																		}



																		integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																		integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																		prolongation(P, n7, n8, flag, error_approx_fine15, error_approx_coarse15, n_a[15], n_a[16]);

																		// correction
																		for (integer ii = 1; ii <= n_a[15]; ii++) {
																			error_approx_coarse14[ii] += error_approx_fine15[ii];
																		}

																		// free
																		delete[] error_approx_fine15;
																		delete[] error_approx_coarse15;
																		delete[] residual_coarse15;
																		delete[] residual_fine15;

																	}

																	// post smothing
																	for (integer iter = 0; iter < nu2; iter++) {
																		integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																		integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																		seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																	}


																	// prolongation
																	// residual_r
																	doublerealT *error_approx_fine14 = new doublerealT[n_a[14] + 1];
																	for (integer ii = 1; ii <= n_a[14]; ii++) {
																		error_approx_fine14[ii] = 0.0;
																	}



																	integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																	integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																	prolongation(P, n7, n8, flag, error_approx_fine14, error_approx_coarse14, n_a[14], n_a[15]);

																	// correction
																	for (integer ii = 1; ii <= n_a[14]; ii++) {
																		error_approx_coarse13[ii] += error_approx_fine14[ii];
																	}

																	// free
																	delete[] error_approx_fine14;
																	delete[] error_approx_coarse14;
																	delete[] residual_coarse14;
																	delete[] residual_fine14;

																}


																// post smothing
																for (integer iter = 0; iter < nu2; iter++) {
																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																	seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																}


																// prolongation
																// residual_r
																doublerealT *error_approx_fine13 = new doublerealT[n_a[13] + 1];
																for (integer ii = 1; ii <= n_a[13]; ii++) {
																	error_approx_fine13[ii] = 0.0;
																}

#if doubleintprecision == 1
																//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																//printf("error_approx_coarse13[%lld]=%e\n",ii, error_approx_coarse13[ii]);

																//printf("residual_coarse13[%lld]=%e\n", ii, residual_coarse13[ii]);
																//getchar();
																//}
																//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																//if (ii % 20 == 0) getchar();
																//}
#else
																//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																//printf("error_approx_coarse13[%d]=%e\n",ii, error_approx_coarse13[ii]);

																//printf("residual_coarse13[%d]=%e\n", ii, residual_coarse13[ii]);
																//getchar();
																//}
																//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																//if (ii % 20 == 0) getchar();
																//}
#endif
																

																integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																prolongation(P, n7, n8, flag, error_approx_fine13, error_approx_coarse13, n_a[13], n_a[14]);

																// correction
																for (integer ii = 1; ii <= n_a[13]; ii++) {
																	error_approx_coarse12[ii] += error_approx_fine13[ii];
																}

																// free
																delete[] error_approx_fine13;
																delete[] error_approx_coarse13;
																delete[] residual_coarse13;
																delete[] residual_fine13;

															}


															// post smothing
															for (integer iter = 0; iter < nu2; iter++) {
																integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
															}


															// prolongation
															// residual_r
															doublerealT *error_approx_fine12 = new doublerealT[n_a[12] + 1];
															for (integer ii = 1; ii <= n_a[12]; ii++) {
																error_approx_fine12[ii] = 0.0;
															}

#if doubleintprecision == 1
															//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
															//printf("error_approx_coarse12[%lld]=%e\n",ii, error_approx_coarse12[ii]);

															//printf("residual_coarse12[%lld]=%e\n", ii, residual_coarse12[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
															//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#else
															//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
															//printf("error_approx_coarse12[%d]=%e\n",ii, error_approx_coarse12[ii]);

															//printf("residual_coarse12[%d]=%e\n", ii, residual_coarse12[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
															//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#endif
															

															integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
															integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
															prolongation(P, n7, n8, flag, error_approx_fine12, error_approx_coarse12, n_a[12], n_a[13]);

															// correction
															for (integer ii = 1; ii <= n_a[12]; ii++) {
																error_approx_coarse11[ii] += error_approx_fine12[ii];
															}

															// free
															delete[] error_approx_fine12;
															delete[] error_approx_coarse12;
															delete[] residual_coarse12;
															delete[] residual_fine12;

														}



														// post smothing
														for (integer iter = 0; iter < nu2; iter++) {
															integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
															integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
															seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
														}


														// prolongation
														// residual_r
														doublerealT *error_approx_fine11 = new doublerealT[n_a[11] + 1];
														for (integer ii = 1; ii <= n_a[11]; ii++) {
															error_approx_fine11[ii] = 0.0;
														}

#if doubleintprecision == 1
														//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
														//printf("error_approx_coarse11[%lld]=%e\n",ii, error_approx_coarse11[ii]);

														//printf("residual_coarse11[%lld]=%e\n", ii, residual_coarse11[ii]);
														//getchar();
														//}
														//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
														//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
														//if (ii % 20 == 0) getchar();
														//}
#else
														//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
														//printf("error_approx_coarse11[%d]=%e\n",ii, error_approx_coarse11[ii]);

														//printf("residual_coarse11[%d]=%e\n", ii, residual_coarse11[ii]);
														//getchar();
														//}
														//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
														//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
														//if (ii % 20 == 0) getchar();
														//}
#endif

													

														integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
														integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
														prolongation(P, n7, n8, flag, error_approx_fine11, error_approx_coarse11, n_a[11], n_a[12]);

														// correction
														for (integer ii = 1; ii <= n_a[11]; ii++) {
															error_approx_coarse10[ii] += error_approx_fine11[ii];
														}

														// free
														delete[] error_approx_fine11;
														delete[] error_approx_coarse11;
														delete[] residual_coarse11;
														delete[] residual_fine11;

													}


													// post smothing
													for (integer iter = 0; iter < nu2; iter++) {
														integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
														integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
														seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
													}


													// prolongation
													// residual_r
													doublerealT *error_approx_fine10 = new doublerealT[n_a[10] + 1];
													for (integer ii = 1; ii <= n_a[10]; ii++) {
														error_approx_fine10[ii] = 0.0;
													}

#if doubleintprecision == 1
													//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
													//printf("error_approx_coarse10[%lld]=%e\n",ii, error_approx_coarse10[ii]);

													//printf("residual_coarse10[%lld]=%e\n", ii, residual_coarse10[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
													//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#else
													//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
													//printf("error_approx_coarse10[%d]=%e\n",ii, error_approx_coarse10[ii]);

													//printf("residual_coarse10[%d]=%e\n", ii, residual_coarse10[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
													//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#endif
													

													integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
													integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
													prolongation(P, n7, n8, flag, error_approx_fine10, error_approx_coarse10, n_a[10], n_a[11]);

													// correction
													for (integer ii = 1; ii <= n_a[10]; ii++) {
														error_approx_coarse9[ii] += error_approx_fine10[ii];
													}

													// free
													delete[] error_approx_fine10;
													delete[] error_approx_coarse10;
													delete[] residual_coarse10;
													delete[] residual_fine10;

												}



												// post smothing
												for (integer iter = 0; iter < nu2; iter++) {
													integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
													integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
													seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
												}


												// prolongation
												// residual_r
												doublerealT *error_approx_fine9 = new doublerealT[n_a[9] + 1];
												for (integer ii = 1; ii <= n_a[9]; ii++) {
													error_approx_fine9[ii] = 0.0;
												}

#if doubleintprecision == 1
												//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
												//printf("error_approx_coarse9[%lld]=%e\n",ii, error_approx_coarse9[ii]);

												//printf("residual_coarse9[%lld]=%e\n", ii, residual_coarse9[ii]);
												//getchar();
												//}
												//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
												//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
												//if (ii % 20 == 0) getchar();
												//}
#else
												//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
												//printf("error_approx_coarse9[%d]=%e\n",ii, error_approx_coarse9[ii]);

												//printf("residual_coarse9[%d]=%e\n", ii, residual_coarse9[ii]);
												//getchar();
												//}
												//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
												//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
												//if (ii % 20 == 0) getchar();
												//}
#endif
												

												integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
												integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
												prolongation(P, n7, n8, flag, error_approx_fine9, error_approx_coarse9, n_a[9], n_a[10]);

												// correction
												for (integer ii = 1; ii <= n_a[9]; ii++) {
													error_approx_coarse8[ii] += error_approx_fine9[ii];
												}

												// free
												delete[] error_approx_fine9;
												delete[] error_approx_coarse9;
												delete[] residual_coarse9;
												delete[] residual_fine9;

											}

											// post smothing
											for (integer iter = 0; iter < nu2; iter++) {
												integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
												integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
												seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
											}


											// prolongation
											// residual_r
											doublerealT *error_approx_fine8 = new doublerealT[n_a[8] + 1];
											for (integer ii = 1; ii <= n_a[8]; ii++) {
												error_approx_fine8[ii] = 0.0;
											}

#if doubleintprecision == 1
											//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
											//printf("error_approx_coarse8[%lld]=%e\n",ii, error_approx_coarse8[ii]);

											//printf("residual_coarse8[%lld]=%e\n", ii, residual_coarse8[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
											//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#else
											//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
											//printf("error_approx_coarse8[%d]=%e\n",ii, error_approx_coarse8[ii]);

											//printf("residual_coarse8[%d]=%e\n", ii, residual_coarse8[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
											//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#endif
											

											integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
											integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
											prolongation(P, n7, n8, flag, error_approx_fine8, error_approx_coarse8, n_a[8], n_a[9]);

											// correction
											for (integer ii = 1; ii <= n_a[8]; ii++) {
												error_approx_coarse7[ii] += error_approx_fine8[ii];
											}

											// free
											delete[] error_approx_fine8;
											delete[] error_approx_coarse8;
											delete[] residual_coarse8;
											delete[] residual_fine8;

										}

										// post smothing
										for (integer iter = 0; iter < nu2; iter++) {
											seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
										}


										// prolongation
										// residual_r
										doublerealT *error_approx_fine7 = new doublerealT[n_a[7] + 1];
										for (integer ii = 1; ii <= n_a[7]; ii++) {
											error_approx_fine7[ii] = 0.0;
										}

#if doubleintprecision == 1
										//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
										//printf("error_approx_coarse7[%lld]=%e\n",ii, error_approx_coarse7[ii]);

										//printf("residual_coarse7[%lld]=%e\n", ii, residual_coarse7[ii]);
										//getchar();
										//}
										//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
										//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
										//if (ii % 20 == 0) getchar();
										//}
#else
										//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
										//printf("error_approx_coarse7[%d]=%e\n",ii, error_approx_coarse7[ii]);

										//printf("residual_coarse7[%d]=%e\n", ii, residual_coarse7[ii]);
										//getchar();
										//}
										//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
										//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
										//if (ii % 20 == 0) getchar();
										//}
#endif
										

										prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, error_approx_fine7, error_approx_coarse7, n_a[7], n_a[8]);

										// correction
										for (integer ii = 1; ii <= n_a[7]; ii++) {
											error_approx_coarse6[ii] += error_approx_fine7[ii];
										}

										// free
										delete[] error_approx_fine7;
										delete[] error_approx_coarse7;
										delete[] residual_coarse7;
										delete[] residual_fine7;

									}


									// post smothing
									for (integer iter = 0; iter < nu2; iter++) {
										seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7]);
									}


									// prolongation
									// residual_r
									//doublerealT *error_approx_fine6 = new doublerealT[n_a[6] + 1];
									for (integer ii = 1; ii <= n_a[6]; ii++) {
										error_approx_fine6[ii] = 0.0;
									}

#if doubleintprecision == 1
									//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
									//printf("error_approx_coarse6[%lld]=%e\n",ii, error_approx_coarse6[ii]);

									//printf("residual_coarse6[%lld]=%e\n", ii, residual_coarse6[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#else
									//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
									//printf("error_approx_coarse6[%d]=%e\n",ii, error_approx_coarse6[ii]);

									//printf("residual_coarse6[%d]=%e\n", ii, residual_coarse6[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#endif
									

									prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, error_approx_fine6, error_approx_coarse6, n_a[6], n_a[7]);

									// correction
									for (integer ii = 1; ii <= n_a[6]; ii++) {
										error_approx_coarse5[ii] += error_approx_fine6[ii];
									}

									// free
									//delete[] error_approx_fine6;
									//delete[] error_approx_coarse6;
									//delete[] residual_coarse6;
									//delete[] residual_fine6;

								}

								// post smothing
								for (integer iter = 0; iter < nu2; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
									seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
								}

								// prolongation
								// residual_r
								//doublerealT *error_approx_fine5 = new doublerealT[n_a[5] + 1];
								for (integer ii = 1; ii <= n_a[5]; ii++) {
									error_approx_fine5[ii] = 0.0;
								}

#if doubleintprecision == 1
								//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
								//printf("error_approx_coarse5[%lld]=%e\n",ii, error_approx_coarse5[ii]);

								//printf("residual_coarse5[%lld]=%e\n", ii, residual_coarse5[ii]);
								//getchar();
								//}
								//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
								//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
								//if (ii % 20 == 0) getchar();
								//}
#else
								//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
								//printf("error_approx_coarse5[%d]=%e\n",ii, error_approx_coarse5[ii]);

								//printf("residual_coarse5[%d]=%e\n", ii, residual_coarse5[ii]);
								//getchar();
								//}
								//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
								//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
								//if (ii % 20 == 0) getchar();
								//}
#endif

								

								prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, error_approx_fine5, error_approx_coarse5, n_a[5], n_a[6]);

								// correction
								for (integer ii = 1; ii <= n_a[5]; ii++) {
									error_approx_coarse4[ii] += error_approx_fine5[ii];
								}

								// free
								//delete[] error_approx_fine5;
								//delete[] error_approx_coarse5;
								//delete[] residual_coarse5;
								//delete[] residual_fine5;

							}
							// post smothing
							for (integer iter = 0; iter < nu2; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
								seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
							}

							// prolongation
							// residual_r
							//doublerealT *error_approx_fine4 = new doublerealT[n_a[4] + 1];
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_fine4[ii] = 0.0;
							}

#if doubleintprecision == 1
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%lld]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%lld]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#else
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%d]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%d]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#endif

							

							prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, error_approx_fine4, error_approx_coarse4, n_a[4], n_a[5]);

							// correction
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] += error_approx_fine4[ii];
							}

							// free
							//delete[] error_approx_fine4;
							//delete[] error_approx_coarse4;
							//delete[] residual_coarse4;
							//delete[] residual_fine4;

						}
						// post smothing
						for (integer iter = 0; iter < nu2; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
							seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
						}

						// prolongation
						// residual_r
						//doublerealT *error_approx_fine3 = new doublerealT[n_a[3] + 1];
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_fine3[ii] = 0.0;
						}

#if doubleintprecision == 1
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%lld]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%lld]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%lld].aij=%e, Amat[%ld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#else
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%d]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%d]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#endif

						

						prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, error_approx_fine3, error_approx_coarse3, n_a[3], n_a[4]);

						// correction
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] += error_approx_fine3[ii];
						}

						// free
						//delete[] error_approx_fine3;
						//delete[] error_approx_coarse3;
						//delete[] residual_coarse3;
						//delete[] residual_fine3;

					}
					// post smothing
					for (integer iter = 0; iter < nu2; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
						seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);

					}

					// prolongation
					// residual_r
					//doublerealT *error_approx_fine2 = new doublerealT[n_a[2] + 1];
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_fine2[ii] = 0.0;
					}

#if doubleintprecision == 1
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%lld]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%lld]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#else
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%d]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%d]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#endif

					

					prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, error_approx_fine2, error_approx_coarse2, n_a[2], n_a[3]);

					// correction
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] += error_approx_fine2[ii];
					}

					// free
					//delete[] error_approx_fine2;
					//delete[] error_approx_coarse2;
					//delete[] residual_coarse2;
					//delete[] residual_fine2;

				}
				// post smothing
				for (integer iter = 0; iter < nu2; iter++) {
					//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
					seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
				}

				// prolongation
				// residual_r
				//doublerealT *error_approx_fine1 = new doublerealT[n_a[1] + 1];
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_fine1[ii] = 0.0;
				}

#if doubleintprecision == 1
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%lld]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%lld]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#else
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%d]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%d]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#endif

				

				prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, error_approx_fine1, error_approx_coarse1, n_a[1], n_a[2]);

				// correction
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] += error_approx_fine1[ii];
				}

				// free
				//delete[] error_approx_fine1;
				//delete[] error_approx_coarse1;
				//delete[] residual_coarse1;
				//delete[] residual_fine1;

			}

			// post smothing
			for (integer iter = 0; iter < nu2; iter++) {
				//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
				seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
			}

			// prolongation
			// residual_r
			//doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				error_approx_fine[ii] = 0.0;
			}

			prolongation(P, 1, nnz_aRP[0], flag, error_approx_fine, error_approx_coarse, n_a[0], n_a[1]);

			// correction
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				x[ii] += error_approx_fine[ii];
			}

			// free
			//delete[] error_approx_fine;
			//delete[] error_approx_coarse;
			//delete[] residual_coarse;
			//delete[] residual_fine;
		}
		// post smother
		for (integer iter = 0; iter < nu2; iter++) {
			//seidel<doublereal>(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
			//quick seidel
			seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
		}

		//system("pause");
	}

	if (debug_reshime) system("pause");
	//system("pause");

	// free
	delete[] error_approx_fine;
	if (ilevel > 1) {
		delete[] error_approx_coarse;
		delete[] residual_coarse;
		if (ilevel > 2) {
			// free
			delete[] error_approx_fine1;
			delete[] error_approx_coarse1;
			delete[] residual_coarse1;
			delete[] residual_fine1;
			if (ilevel > 3) {
				// free
				delete[] error_approx_fine2;
				delete[] error_approx_coarse2;
				delete[] residual_coarse2;
				delete[] residual_fine2;
				if (ilevel > 4) {
					// free
					delete[] error_approx_fine3;
					delete[] error_approx_coarse3;
					delete[] residual_coarse3;
					delete[] residual_fine3;
					if (ilevel > 5) {
						// free
						delete[] error_approx_fine4;
						delete[] error_approx_coarse4;
						delete[] residual_coarse4;
						delete[] residual_fine4;
						if (ilevel > 6) {
							// free
							delete[] error_approx_fine5;
							delete[] error_approx_coarse5;
							delete[] residual_coarse5;
							delete[] residual_fine5;
							if (ilevel > 7) {
								// free
								delete[] error_approx_fine6;
								delete[] error_approx_coarse6;
								delete[] residual_coarse6;
								delete[] residual_fine6;
							}
						}
					}
				}
			}
		}
	}


	delete[] residual_fine;

	delete[] row_ptr_start;
	delete[] row_ptr_end;


	delete[] flag_shadow;
	delete[] flag;
	//delete[] flag_;
	return 0;

} // classic_aglomerative_amg1

integer iglcounter_up_and_douwn = 0;
void move_down(integer &nu1, integer& nu2) {
	//iglcounter_up_and_douwn++;
	// TODO
	//if (iglcounter_up_and_douwn % 2 == 0) {
		//nu1++;
		//nu2++;
	//}	
}

void move_up(integer &nu1, integer& nu2) {
	//iglcounter_up_and_douwn--;
	// TODO
	//if (iglcounter_up_and_douwn % 2 == 0) {
		//nu1--;
		//nu2--;
	//}
}



void nested_desection_patch(Ak1* &Amat, integer isize_na, bool* &nested_desection,
	integer* &row_ptr_start, integer* &row_ptr_end, integer iadd_now) {

	// Данный метод самописный и очень хреновый. Его не рекомендуется использовать в частности из-за граничных узлов.
	// Лучше производить разбиения по геометрическому признаку. Т.е. если есть координаты узлов, то слева выделить всё с координатами меньше
	// чем центральная координата, а справа всё что больше. Помоему так делают в Open Foam X.

	// Описание способа работы.
	// Метод требует подачи на вход матрицы в Ak1 формате.
	// Данная функция выдаёт булевый вектор nested desection [1..isize_na]:
	// Ячейки равные false относятся к границе сепаратора (разделителя двух подобластей).
	// Введем число integer middle = (integer)(0.5*(1 + isize_na));
	// Ячейки помеченные true индекс которых [1..middle] Могут выполнятся первым потоком.
	// Ячейки помеченные true индекс которых [middle+1..isize_na] Могут выполнятся вторым потоком независимо от первого.

	// Готовим nested desection
	// для двух потоков.
	// Самая подробная матрица 0.
	// nested_desection0
	bool *nested_desection1 = nullptr;
	nested_desection1 = (bool*)malloc((isize_na + 1)*sizeof(bool));
	char c1[19] = "nested_desection1";
	char c2[24] = "nested_desection_patch";
	char c3[19] = "nested_desection2";
	handle_error<bool>(nested_desection1,  c1, c2, (isize_na + 1));
	bool *nested_desection2 = nullptr;
	nested_desection2 = (bool*)malloc((isize_na + 1)*sizeof(bool));
	handle_error<bool>(nested_desection2, c3, c2, (isize_na + 1));

	// инициализация.
	for (integer i_73 = 1; i_73 <= isize_na; i_73++) {
		nested_desection1[i_73] = false;
		nested_desection2[i_73] = false;
		nested_desection[i_73] = true;
	}
	integer middle = (1 + isize_na)/2;
	for (integer i_72 = 1; i_72 <= middle; i_72++) {
		for (integer i_82 = row_ptr_start[i_72 + iadd_now]; i_82 <= row_ptr_end[i_72 + iadd_now]; i_82++) {
			nested_desection1[Amat[i_82].j] = true;
		}
	}
	for (integer i_72 = middle + 1; i_72 <= isize_na; i_72++) {
		for (integer i_82 = row_ptr_start[i_72 + iadd_now]; i_82 <= row_ptr_end[i_72 + iadd_now]; i_82++) {
			nested_desection2[Amat[i_82].j] = true;
		}
	}
	// На пересечении двух множеств находятся узлы сепаратора.
	for (integer i_73 = 1; i_73 <= isize_na; i_73++) {
		if ((nested_desection1[i_73]) && (nested_desection2[i_73])) {
			nested_desection[i_73] = false;
		}
	}
	// запоминаем узлов из сепаратора.
	for (integer i_73 = 1; i_73 <= isize_na; i_73++) {
		nested_desection1[i_73] = nested_desection[i_73];
	}
	// Если какой-либо сосед принадлежит сепаратору то и сам узел принадлежит сепаратору.
	for (integer i_72 = 1; i_72 <= isize_na; i_72++) {
		for (integer i_82 = row_ptr_start[i_72 + iadd_now]; i_82 <= row_ptr_end[i_72 + iadd_now]; i_82++) {
			if (!nested_desection1[Amat[i_82].j]) nested_desection[Amat[i_82].i] = false;
		}
	}

   free(nested_desection1);
   free(nested_desection2);
} // nested_desection_patch




// 22 января текущий работоспособный вариант кода.
// Планы: 1. сделать версию amg3. 
// В ней: 2. заменить все проверки на невыделение оперативной памяти на универсальную функцию единую для всего.
// это очевидно немного сократит программный код.
// В ней 3. код V цикла оформить в виде цикла for. Тогда же можно будет попробовать вставить direct метод для самого грубого уровня.
// Это же откроет возможности сделать из amg алгоритма предобуславливатель для BiCGStab.
// 15 января экономим память переходим на Ak1.
// 10 января 2016 двоичный поиск заменён на хеширование.
  // 15 декабря 2015. Данная версия кода будет полностью очищена от устаревшего кода.
  // 13 декабря 2015. Внедрено АВЛ дерево. При внедрении АВЛ дерева исправлена логическая ошибка в
  // построении С-F разбиения, теперь C/F разбиение строится корректно.
  // Исправлен и внедрён quicksort (qs,qsj)
  // который в рять раз быстрее пирамидальной сортировки.
  // Полный отказ от band_size!!!.
  // Время работы алгоритма на 1.7М неизвестных в 3D составило ровно 1 минуту.
  // 18 октября 2015. Полностью работоспособный мультигрид.
  // Тестировалось на условиях Дирихле но должно работать на любых 
  // краевых задачах. 18 октября датируется версия 0.04. Версия 0.04 на треть
  // быстрее версии 0.03. Были ускорены как операции построения C/F разбиения, 
  // так и нахождение оператора Галёркина. При нахождении С/F разбиения 
  // учитывается уже построенная его часть и поэтому число сканирований на
  // на поздних циклах сокращается охватывая только не построенную часть.
  // При нахождении произведения Галёркина получена самая оптимальная по быстродействию версия,
  // Основанная на алгоритме слияния отсортированных списков.
  // 4 октября правильное построение последовательности вложенных графов.
  // 30 сентября продолжаем исправление метода. Делаем классический 
  // алгебраический многосеточный метод на основе  C/F разбиения.
  // 16 сентября 2015 года обнаружено что операции 
  // сгрубления и интерполяции сделаны совершенно неверно,
  // и если сгрубление еще в какой-то мере проецирует то интерполяция просто никакая.
  // Операции сгрубления и интерполяции будут сделаны заново на основе статьи
  // К.Н. Волкова в новой версии солвера.
  // 3 september 2015 Villa Borgese.
// Возвращает divergence detected.
template <typename doublerealT>
bool classic_aglomerative_amg2(Ak1* &Amat, 
	integer nsizeA, // количество ячеек выделенное извне для хранилища матриц А
	integer nnz, // number of non zero elements
	integer n, // dimension of vectors x and b.
	Ak1* &R, // restriction
	Ak1* &P, // prolongation
	doublereal* &x, doublereal* &b,
	doublerealT &theta,
	INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14 imyinit = INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT
	) {

	// Параметры отвечающие за автоматическую настройку SOR.
	// По трём точкам мы построим параболу и на её основе 
	// спрогнозируем улучшенный параметр релаксации omega_optimal.
	// Парабола представляется намного лучшей чем простая линейная экстрополяция.
	bproblem_amg_convergence1 = false;
	bproblem_amg_convergence2 = false;
	bproblem_amg_convergence3 = false;
	gold_const = 0.2;

	const bool bprint_mesage_diagnostic = true;

	const integer AVL_TREE_ID = 0;
	const integer SPLAY_TREE_ID = 1;
	integer id_tree =  SPLAY_TREE_ID;

	// Надо заменить все new на malloc.
	//theta = 0.25;

	bool bonly_serial = true;
//#ifdef _OPENMP
	//omp_set_num_threads(2);
//#endif

	// barjer=0.0001; optimum. для 1M задач.
	// Для зачачи с 3.2M неизвестных (теплопередача в 5mm СВЧ транзисторе без дырок.)
	// для константы 1.0e-8 получено сокращение времени счёта с 9мин до 4мин (Количество итераций 213 вместо 1003).
	// Пик использования оперативной памяти при этом приложению составил 2373Мб.
	// Для BiCGStab+ILU2 время счёта равно 1мин 50с против 4мин в данной версии алгоритма.
	// 14 января 2016 подобраны оптимальными и равными 1e-7 каждый.
	doublerealT barjer = 1.0e-7; // 1.0e-7 
	doublerealT barjerA = 1.0e-7; // 1.0e-7

	// контроль числа сильных связей между переменными.
	// doublerealT theta = 0.25;  // 0.25 for 2D and 0.5 for 3D 

	// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
	// В компиляторе надо увеличить размер стека до 4Мб.
	bool bqs = true; // Использовать ли quicksort qs and qsj.
					 // Сортировка с подсчётом быстрее quickSort.
	bool bCounting_Sort = true; // Использовать ли сортировку подсчётом которая потребляет килотонну памяти (Короче для машин у которых море оперативки).


	const doublerealT RealZERO = 1.0e-300;// 1.0e-10;
	const doublerealT divisionZERO = 1.0e-300;
	const doublerealT RealMAXIMUM = 1.0e300;
	// включение/отключение отладочного режима.
	bool debug_reshime = false;

	const integer max_neighbour = 27850;
	// Мы будем поддерживать информацию о максимальном количестве соседей.
	integer Maximumneighbourcount = -1;
	// мы получим порядковый номер элемента с максимальным число соседей в матрице А,
	// прямо в результате построения C/F разбиения.
	bool bmaxneighbourinfoactive = false;


	// Возможно можно обойтись без ji связи.
	// 17 dec 2015 эксперимент показывает что можно обойтись без учёта ji связи.
	// false без связи. Если false то Atemp вообще ненужен.
	bool bji = false;
	Ak1* Atemp = nullptr;
	if (bji) {
		Atemp = new Ak1[3 * nnz + 1];
	}

	// нумерация начинается с единицы.

	const integer maxlevel = 30;
	integer ilevel = 1;
	integer nnz_a[maxlevel];
	integer n_a[maxlevel];
	nnz_a[0] = nnz;
	n_a[0] = n;
	//bool* flag = new bool[n + 1];
	bool* flag = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(flag, "flag", "classic_aglomerative_amg_2", (n + 1));
	
	//bool* flag_shadow = new bool[n + 1];
	bool* flag_shadow = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(flag_shadow, "flag_shadow", "classic_aglomerative_amg_2", (n + 1));
	
	//bool* hash_table = new bool[nnz + 1]; // Огромного размера hash таблица.
	bool* hash_table = (bool*)malloc((nnz + 1)*sizeof(bool));
	handle_error<bool>(hash_table, "hash_table", "classic_aglomerative_amg_2", (nnz + 1));
	
	// Огромный размер поэтому инициализация делается лишь единожды.
	for (integer isc = 0; isc <= nnz; isc++) hash_table[isc] = false; // initialization 
	const integer istack_size_limit = n+1; // 128000
	//integer ipool[ipool_size_limit];
	integer* istack = nullptr;
		//istack = new integer[istack_size_limit];
	istack = (integer*)malloc((istack_size_limit)*sizeof(integer));
	handle_error<integer>(istack, "istack", "classic_aglomerative_amg_2", (istack_size_limit));

	// Для построения C/F декомпозиции нам тоже потребуется хеш-таблица
	// и стек для очистки хеш-таблицы.
	bool* hash_table2 = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(hash_table2, "hash_table2", "classic_aglomerative_amg_2", (n + 1));
	
	// Инициализация.
	for (integer isc = 0; isc <= n; isc++) hash_table2[isc] = false;
	// И теперь стек для очистки хеш-таблицы.
	integer* istack2 = nullptr;
	//istack2 = new integer[n + 1];
	istack2 = (integer*)malloc((n + 1)*sizeof(integer));
	handle_error<integer>(istack2, "istack2", "classic_aglomerative_amg_2", (n + 1));
	

	integer iadd = 0;
	integer nnzR = 1;
	integer iaddR = 0;
	integer nnz_aRP[maxlevel];
	bool bcontinue = true;
	//bool* this_is_C_node = new bool[n + 1];
	//bool* this_is_F_node = new bool[n + 1];
	bool* this_is_C_node = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(this_is_C_node, "this_is_C_node", "classic_aglomerative_amg_2", (n + 1));
	
	bool* this_is_F_node = (bool*)malloc((n+1)*sizeof(bool));
	handle_error<bool>(this_is_F_node, "this_is_F_node", "classic_aglomerative_amg_2", (n + 1));
	

	while ((ilevel < maxlevel - 1) && (n_a[ilevel - 1] > 50) && (bcontinue)) {


		/*
		hashlist** hash = new hashlist*[n_a[ilevel - 1]+1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hash[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].i;
		insertion_hash(hash[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hash[i_1]);
		hash[i_1] = 0;
		}
		delete[] hash;

		hashlist** hashj = new hashlist*[n_a[ilevel - 1] + 1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hashj[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].j;
		insertion_hash(hashj[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hashj[i_1]);
		hashj[i_1] = 0;
		}
		delete[] hashj;
		*/


		Maximumneighbourcount = -1;
		bmaxneighbourinfoactive = false;

		//if (ilevel > 1) {
		//if (n_a[ilevel - 2] == n_a[ilevel - 1]) break;
		//}

		if (ilevel > 10) {
			if (n_a[ilevel - 1] < 300) break;
		}

		if (ilevel > 1) {
			doublerealT procent = (100.0*(abs(n_a[ilevel - 1] - n_a[ilevel - 2]))) / (1.0*n_a[ilevel - 2]);
			if (procent<2.0) break;
		}

		if (((ilevel > 1) && (nnz_a[ilevel - 1] > nnz_a[ilevel - 2]))) {
			//break;
		}


#if doubleintprecision == 1
		if (bprint_mesage_diagnostic) {
			// level info.
			if (ilevel == 2) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld nnz_a[0]=%lld nnz_a[1]=%lld iadd=%lld\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 3) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld iadd=%lld\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 4) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld n_a[3]=%lld \n", n_a[0], n_a[1], n_a[2], n_a[3]);
				printf("nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld nnz_a[3]=%lld iadd=%lld\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if (ilevel > 17) {
				printf("very big matrix (mesh). no programming.\n");
				system("pause");
				exit(1);
			}
		}
#else
		if (bprint_mesage_diagnostic) {
			// level info.
			if (ilevel == 2) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d nnz_a[0]=%d nnz_a[1]=%d iadd=%d\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 3) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d iadd=%d\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 4) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d n_a[3]=%d \n", n_a[0], n_a[1], n_a[2], n_a[3]);
				printf("nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d nnz_a[3]=%d iadd=%d\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if (ilevel > 17) {
				printf("very big matrix (mesh). no programming.\n");
				system("pause");
				exit(1);
			}
		}
#endif

		

		//nnzR = 1;

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		for (integer ii = n_a[ilevel - 1]; ii <= n; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		// Сортировка нужна лишь на первом уровне, т.к.
		// результат алгоритма перемножения по Густавсону уже 
		// даёт на выходе отсортированную по строкам матрицу.
		if (ilevel == 1) {
			// сортировка исходной  А  по i.
			//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1], comparei);


			// 7 января 2016. Обязательно нужна эта сортировка.
			if (bqs) {
				if (bCounting_Sort) {
					Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, true, indx_comparei);
				}
				else {
					// quicksort
					qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparei);
				}
			}
			else {
				HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);
			}
			//QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);
		}





		if (bji) {
			// Создаём копию в Atemp, копия будет отсортирована по j.
			for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
				Atemp[i_1 - iadd] = Amat[i_1];
			}
			// Сортируем копию по j.
			// Мы сортируем по j, чтобы потом быстро искать по j.
			if (bqs) {
				if (bCounting_Sort) {
					// Сортировка с подсчётом за линейное время.
					Counting_Sort(Atemp, 1, nnz_a[ilevel - 1], indx_comparej);
				}
				else {
					// Быстрая сортировка Чарльза Хоара.
					qs(Atemp, 1, nnz_a[ilevel - 1], indx_comparej);
				}
			}
			else {
				HeapSort(Atemp, 1, nnz_a[ilevel - 1], comparej);
			}
		}

		for (integer i_1 = 1; i_1 <= n; i_1++) {
			flag[i_1] = false;
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}

		// позиция начала каждой строки в матрице.
		integer* row_startA = nullptr;
		//row_startA = new integer[n_a[ilevel - 1] + 1];
		row_startA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_startA, "row_startA", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				flag[Amat[ii].i] = true;
				row_startA[Amat[ii].i] = ii;
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}


		// вычисляем для кадого узла число его соседей.
		integer* count_neighbour = nullptr;
		//count_neighbour = new integer[n_a[ilevel - 1] + 1];
		count_neighbour = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(count_neighbour, "count_neighbour", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			count_neighbour[ii] = 0; // нет соседей.
		}




		// При таком коде узел Дирихле тоже имеет соседа, сосед это 
		// внутренний узел который связан с этим узлом Дирихле.
		// Соседей вычисляем на самой первой матрице А (самой левой).
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer ic = -1;
				integer cand[max_neighbour];
				if (0) {
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						ic++; //i,j
						cand[ic] = Amat[is0].j;
					}
				}
				else {
					// 12 января 2016.
					// Учитываем только Strong соседей.
					doublerealT threshold = -1.0;
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						if (Amat[is0].j != Amat[ii].i) {
							if (fabs(Amat[is0].aij) > threshold) {
								// Определяем максимальный внедиагональный элемент.
								threshold = fabs(Amat[is0].aij);
							}
						}
					}
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						if (Amat[is0].j != Amat[ii].i) {
							if (fabs(Amat[is0].aij) > theta*threshold) {
								// Учитываем только сильно связанных соседей.
								ic++; //i,j
								cand[ic] = Amat[is0].j;
							}
						}
					}
				}
				integer len_neighbour = ic;
				// Найти столбец j который равен индексу Amat[ii].i
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//if (Amat[ii1].i != Amat[ii].i) {
				//	if (Amat[ii1].j == Amat[ii].i) {
				// j,i
				//		bool foundneighbour = false;
				//		for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
				//			if (Amat[ii1].j == cand[i_1]) foundneighbour = true;
				//		}
				//		if (!foundneighbour) {
				//			ic++;
				//			cand[ic] = Amat[ii1].j;
				//			len_neighbour++;
				//		}
				//	}
				//}
				//}
				if (bji) {
					// Ускоренная версия с бинарным поиском по j.
					integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
					for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == Amat[ii].i); ii1++) {
						if (Atemp[ii1].i != Amat[ii].i) {
							// j,i
							bool foundneighbour = false;
							for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
								if (Atemp[ii1].j == cand[i_1]) foundneighbour = true;
							}
							if (!foundneighbour) {
								ic++;
								cand[ic] = Atemp[ii1].j;
								len_neighbour++;
							}
						}
					}
				}


				count_neighbour[Amat[ii].i] = ic;
				if (ic > Maximumneighbourcount) {
					Maximumneighbourcount = ic;
					bmaxneighbourinfoactive = true;
				}
				flag[Amat[ii].i] = true;
			}
		}



		integer maxneighbour = 0;
		integer icandidate = 0;
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}
		// Находим узел с наибольшим числом соседей и запоминаем его.
		// Это первый встретившийся узел с наибольшим числом соседей.
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				if (count_neighbour[Amat[ii].i] > maxneighbour) {
					maxneighbour = count_neighbour[Amat[ii].i];
					icandidate = ii;
					if (bmaxneighbourinfoactive) {
						// организуем досрочный выход из цикла for.
						// Это должно сильно сокращать количество сканирований.
						if (maxneighbour == Maximumneighbourcount) break;
					}
				}
				flag[Amat[ii].i] = true;
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}


		// нужно выделить кто попал в coarse, а кто в этот раз попал в Fine Выделить всех кто соседствует
		// с новыми Fine увеличить им счётчик соседей.

		integer n_coarce = 1; // начальный номер C узла.
		nnzR = 1;

		const integer NULL_NEIGHBOUR = -1;
		integer vacant = NULL_NEIGHBOUR;
		bool bcontinue = true;

		// Построение C/F разбиения.
		//while (icandidate != 0)
		integer icountprohod = 0;
		// Мы будем заоминать с какой позиции начинаются ещё не помеченные узлы,
		// это сократит количество перебираемых элементов в поиске узла с максимальным 
		// количеством соседей.
		//integer ibegining_start_index_found_maximum = 1 + iadd;
		// храним те узлы которые уже были пройдены при конструировании.
		bool *bmarkervisit = nullptr;
		//bmarkervisit = new bool[n + 1];
		bmarkervisit = (bool*)malloc((n+1)*sizeof(bool));
		handle_error<bool>(bmarkervisit, "bmarkervisit", "classic_aglomerative_amg_2", (n + 1));
		
		// поначалу все узлы помечены как непосещенные.
		for (integer i_1 = 1; i_1 <= n; i_1++) bmarkervisit[i_1] = false;



		// увеличение быстродействия достигается 
		// сокращением пределов сканирования
		// здесь хранится индекс начала сканирования flag.
		integer istartflag_scan = 1;


		// if (bAVL) работа на основе АВЛ дерева.
		bool bAVL = true;
		bool bAVL_deb = false;
		node_AVL* root = 0;
		Tree_splay* root_splay = 0;
		size_splay_Tree = 0;

		integer newCcount = 0;




		while (bcontinue)
		{


#if doubleintprecision == 1
			//printf("prohod count number %lld\n", icountprohod);
#else
			//printf("prohod count number %d\n", icountprohod);
#endif
			


			integer set[max_neighbour]; // не более 20 узлов в одном агрегате.
									// инициализация убрана потому что она не нужна и она сильно тормозит быстродействие.
									//for (integer js = 0; js < max_neighbour; js++) {
									//set[js] = NULL_NEIGHBOUR;
									//}
			integer ic = 0;

			integer ii = icandidate;
			if (flag[Amat[ii].i] == false) {

				ic = 0; // Обязательная инициализация.
				set[ic] = Amat[ii].i;


				
				this_is_C_node[set[0]] = true;
				bmarkervisit[set[0]] = true;

				doublerealT max_vnediagonal = -1.0; // максимальное значение модуля вне диагонального элемента. 
				// добавляем диагональный элемент.
				// узел set[0]==Amat[is0].i.
				// Нахождение значения максимального внедиагольного элемента, с 
				// учётом того что даже узел Дирихле связан с одним внутренним узлом расчётной области.
				// 17 января 2016 правильное определение максимального внедиагонального элемента.
				// Обязательная перемотка в самое начало строки.
				integer ii_back = ii;
				while ((ii_back > iadd) && (Amat[ii_back].i == set[0])) ii_back--;
				ii_back++;

				doublerealT max_vnediagonal1 = -1.0;
				doublerealT min_vnediagonal1 = 1.0e30;
				doublerealT counter_vnediagonal = 0.0;
				doublerealT avg_vnediagonal1 = 0.0;

				// Если делать по максимальному внедиагональному элементу то мы получим очень много элементов на грубых уровнях,
				// и чрезвычайно медленную сходимость.

				for (integer is0 = ii_back; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
					if (Amat[is0].j != set[0]) {
						counter_vnediagonal = counter_vnediagonal + 1.0;
						avg_vnediagonal1 += fabs(Amat[is0].aij);
						if (fabs(Amat[is0].aij) > max_vnediagonal1) {
							max_vnediagonal1 = fabs(Amat[is0].aij); //i,j
							// Большое количество элементов на грубых уровнях,
							// очень медленная сходимость.
							//if (Amat[is0].j == set[0]) break; 
						}
						if (fabs(Amat[is0].aij) < min_vnediagonal1) {
							min_vnediagonal1 = fabs(Amat[is0].aij); //i,j
							
						}
					}
				}
				if (fabs(counter_vnediagonal) > 0.5) {
					avg_vnediagonal1 = avg_vnediagonal1 / counter_vnediagonal;
				}
				else {
					avg_vnediagonal1 = max_vnediagonal1;
				}
				//max_vnediagonal = avg_vnediagonal1;
				//max_vnediagonal = max_vnediagonal1;  // 1
				//max_vnediagonal = 0.5* avg_vnediagonal1 + 0.5*max_vnediagonal1;
				//max_vnediagonal = avg_vnediagonal1 + 0.05*(max_vnediagonal1 - avg_vnediagonal1);
				// наиболее близка к оптимальной. -85%. но несомненно лучше max_vnediagonal = -1.0;
				//max_vnediagonal = avg_vnediagonal1 - 0.85*(avg_vnediagonal1 - min_vnediagonal1);
				// 19 января 2016 установлено что важды все связы, не нужно учитывать threshold
				// max_vnediagonal должно быть -1.0. Именно это значение обеспечивает наилучшую 
				// скорость агломерации и наилучшую скорость сходимости.
				max_vnediagonal = -1.0;  // все связи!!!

				/*
				// Лишний код 19 января 2016.
				for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
					if (Amat[is0].j == set[0]) {

						// Из-за этого прерывания максимальный внедиагональный элемент может быть определён неверно.
						// поэтому смотри цикл выше от 17 января 2016 по правильному определению максимального внедиагонального элемента.
						break;
					}
					else {
						if (fabs(Amat[is0].aij) > max_vnediagonal) {
							// При стабильной версии требуется расскоментировать
							// 19 jan 2016.
							//max_vnediagonal = fabs(Amat[is0].aij); //i,j
						}
					}

					// Этот цикл является добавочным.
					// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
					// Медленный линейный поиск.
					//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
					//if (Amat[ii1].i != set[0]) {
					//if (!flag[Amat[ii1].i]) {
					//	if (Amat[ii1].j == set[0]) {
					//		if (fabs(Amat[ii1].aij) > max_vnediagonal) {
					//			max_vnediagonal = fabs(Amat[ii1].aij); //j,i
					//		}
					//	}
					//}
					//}
					//}

					if (bji) {
						// Этот цикл является добавочным.
						// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
						// Ускоренная версия на основе двоичного поиска.
						integer ii2 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
						for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == set[0]); ii1++)
						{
							if (Atemp[ii1].i != set[0]) {
								if (!flag[Atemp[ii1].i]) {
									if (fabs(Atemp[ii1].aij) > max_vnediagonal) {
										max_vnediagonal = fabs(Atemp[ii1].aij); //j,i
									}
								}
							}
						}
					}


				}
				*/

				ic++;



				// если узел j ещё не был добавлен в агрегат.
				if (flag[Amat[ii].j] == false) {
					if ((Amat[ii].j != set[0]) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
						vacant = Amat[ii].j;
						for (integer js = 0; js < ic; js++) {
							if (vacant == set[js]) {
								vacant = NULL_NEIGHBOUR;
							}
						}
						if (vacant != NULL_NEIGHBOUR) {
							set[ic] = vacant;

							ic++;
						}
					}
				}
				//integer iscan = ii + 1;
				integer iscan = ii_back; // важная модификация 19 января 2016г.
				// TODO 19 jan 2016.
				while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set[0])) {
					// если узел j ещё не был добавлен в агрегат.
					if (flag[Amat[iscan].j] == false) {
						if ((Amat[iscan].j != set[0]) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
							vacant = Amat[iscan].j;
							for (integer js = 0; js < ic; js++) {
								if (vacant == set[js]) {
									vacant = NULL_NEIGHBOUR;
								}
							}
							if (vacant != NULL_NEIGHBOUR) {
								set[ic] = vacant;

								ic++;

							}
						}
					}

					iscan++;

				} // while

				// Это была учтена только связь i,j



				  // Учёт свяи j,i
				  //for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
				  //if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
				  //if (!flag[Amat[ii1].i]) {
				  //if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
				  //	vacant = Amat[ii1].i;
				  //	for (integer js = 0; js < ic; js++) {
				  //		if (vacant == set[js]) {
				  //			vacant = NULL_NEIGHBOUR;
				  //		}
				  //	}
				  //	if (vacant != NULL_NEIGHBOUR) {
				  //		set[ic] = vacant; // j,i связь.

				  //		ic++;
				  //	}
				  //	}
				  //}
				  //}
				  //}

				  // Учёт связи j,i
				  // Медленная версия на основе линейного поиска.
				  //for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
				  //if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
				  //if (!flag[Amat[ii1].i]) {
				  //if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
				  //	vacant = Amat[ii1].i;
				  //	for (integer js = 0; js < ic; js++) {
				  //		if (vacant == set[js]) {
				  //			vacant = NULL_NEIGHBOUR;
				  //		}
				  //	}
				  //	if (vacant != NULL_NEIGHBOUR) {
				  //		set[ic] = vacant; // j,i связь.

				  //		ic++;
				  //	}
				  //}
				  //}
				  //}
				  //}

				if (bji) {
					// Учёт свяи j,i
					// Более быстрая версия на основе двоичного поиска.
					integer ii1 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
					for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1]) && (Atemp[ii2].j == set[0]); ii2++) {
						if ((Atemp[ii2].i != set[0]) && (!flag[Atemp[ii2].i])) {
							if (fabs(Atemp[ii2].aij) >= theta*max_vnediagonal) {
								vacant = Atemp[ii2].i;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_NEIGHBOUR;
									}
								}
								if (vacant != NULL_NEIGHBOUR) {
									set[ic] = vacant; // j,i связь.
									ic++;
								}
							}
						}
					}


				}


				for (integer isc = 1; isc < ic; isc++) {
					this_is_F_node[set[isc]] = true; // это только новые F узлы.
					bmarkervisit[set[isc]] = true;
				}




				// Помечаем узлы как включённые в агрегат.
				for (integer js = 0; js < ic; js++) {
					flag[set[js]] = true;
				}






				// Алгоритм (5 декабря 2015 revised) 
				// 1. Сканируем все F которые соседи данного С на данном проходе.
				// 2. Для каждого фиксированного F сканируем его "строчных" соседей.
				// 3. Если узел еще не был включён в агрегат то ищем всех соседей данного узла на предмет 
				// соседства с фиксированным набором F из пункта 1.



				if (bAVL) {
					// 12 декабря 2015.
					// Надо удалить из АВЛ дерева C и F узлы.
					// Это удаление очищает АВЛ дерево и приводит его к
					// рабочему состоянию. Удаление несуществующих в дереве узлов
					// производится корректно. Удаление производится за логарифмическое
					// по основанию 2  время от количества элементов в дереве
					// сбалансированность дерева при этом сохраняется.
					for (integer js = 0; js < ic; js++) {
						data_BalTree ddel;
						ddel.i = set[js];
						ddel.count_neighbour = count_neighbour[set[js]];
						//ddel.ii = row_startA[ddel.i];
						switch (id_tree) {
						case AVL_TREE_ID: root = remove_AVL(root, ddel);
							break;
						case SPLAY_TREE_ID: root_splay = delete_splay_Tree(ddel, root_splay);
							break;
						default: root = remove_AVL(root, ddel);
							break;
						}
						
						if (bAVL_deb)
						{
							printf("remove\n");
						}
					}
				}

				
					//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
					//flag_shadow[i_1] = flag[i_1];
					//}



					//integer i3 = 1;
					//while ((i3 <= n_a[ilevel - 1]) && (row_startA[i3] < istart)) i3++;
					//integer i4 = n_a[ilevel - 1];
					//while ((i4 >= 1) && (row_startA[i4]>iend)) i4--;


					// Ищем только среди ближайшего окружения вновь добавленного F узла.
					//for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {

					// Старая реализация которой присуща большая нагрузка на операторы new && delete.

#if 0
				if (0) {
					for (integer js = 1; js < ic; js++) {

					// см. новый вариант от 10 января 2016.

					// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
					// элемент lsos_head;
					List *lsos = nullptr;
					List *lsos_head = nullptr;
					lsos = new List;
					lsos->prev = nullptr;
					lsos_head = lsos;
					{
						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart2 = ii_11;
						while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_11].i)) istart2--;
						istart2++;
						bool bvisitsos = false;
						for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {
								lsos->next = nullptr;
								lsos->i = Amat[is0].j;
								lsos->ii = row_startA[lsos->i];
								// lsos->count_neighbour // не используется.
								List *newnodesos = new List;
								newnodesos->prev = lsos;
								lsos->next = newnodesos;
								newnodesos->next = nullptr;
								lsos = lsos->next;
								newnodesos = nullptr;
								bvisitsos = true;
							}
						}
						if (bvisitsos) {

							List *delsos = lsos;
							lsos = lsos->prev;
							lsos->next = nullptr;
							delsos->prev = nullptr;
							delete delsos;
							delsos = nullptr;
						}
						else {
							// Нет ни одного соседа
							lsos_head = nullptr;
							delete lsos;
							lsos = nullptr;
						}
					}

					lsos = lsos_head;
					// ищем соседа узла set[js].
					//for (integer i5 = i3; i5 <= i4; i5++) {
					while (lsos != nullptr) {


						//integer isc = Amat[ii_2].i;
						//integer ii_2 = row_startA[i5];
						//integer ii_2 = BinarySearchAi(Amat, i5, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						//integer isc = i5;

						integer isc = lsos->i;
						integer ii_2 = lsos->ii;


						//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
						//if (flag[isc] == false) {
						//flag_shadow[isc] = true;
						integer ic2 = 0;
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart2 = ii_2;
						while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
						istart2++;
						for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_2].i); is0++) {
							if (Amat[is0].j == set[js]) {
								ic2++;
							}
						}

						data_BalTree dsearch;
						dsearch.count_neighbour = count_neighbour[isc];
						//dsearch.ii = ii_2;
						dsearch.i = isc;
						count_neighbour[isc] += ic2;
						data_BalTree dadd;
						dadd.count_neighbour = count_neighbour[isc];
						//dadd.ii = ii_2;
						dadd.i = isc;
						if (bmaxneighbourinfoactive) {
							// Обновляем информацию о максимальном количестве соседей.
							if (count_neighbour[isc] >= Maximumneighbourcount) {
								Maximumneighbourcount = count_neighbour[isc];
							}

							// Добавляем соседа в любом случае
							// позволило существенным образом 
							// ускорить алгоритм. Если раньше 
							// old = 48595  | 21229
							// new = 433315 | 63031
							// new2 = 19434 | 3698
							// и основное время уходило на old
							// то теперь
							// old = 1449 | 1466
							// new = 472600 | 64525
							// new2= 56544 | 18431
							// Время решения 3D задачи с 1M неизвестными 
							// сократилось с 6мин 48с до 4мин 45с.

							if (bAVL) {

								// добавляем элемент в АВЛ дерево,
								// причём если элемент уже находился в дереве то он модифицируется.
								// 12 декабря 2015.
								// Добавление узла происходит за логарифмическое по основанию 2 время,
								// причём после добавления дерево остаётся сбалансированным.
								// Адельсон-Вельский и Ландис 1962.
								switch (id_tree) {
								case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
								case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
									break;
								default: root = insert_and_modify(root, dadd, dsearch);
									break;
								}
								
								if (bAVL_deb)
								{
									printf("insert and modify\n");
								}
							}


						}
						//}
						lsos = lsos->next;
					}

					// Уничтожение lsos
					// Список постепенно уничтожается с головы.
					lsos = lsos_head;
					while (lsos != nullptr) {
						lsos_head = lsos_head->next;
						if (lsos_head != nullptr) {
							lsos_head->prev = nullptr;
						}
						lsos->next = nullptr;
						delete lsos;
						lsos = lsos_head;
					}

				}
					}
				else				
				if (0) {
					for (integer js = 1; js < ic; js++) {

					// см.ниже  новый вариант от 10 января 2016.
					// 7 января 2016.
					// Новая версия в которой я избавился от лишних оператров new&&delete.
					// Никаких дублирующих линейных списков, никаких операторов new && delete.
					// Код стал намного понятнее.

					// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
					// элемент lsos_head;
					{
						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;
								integer ii_2 = row_startA[isc];

								//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
								//if (flag[isc] == false) {
								//flag_shadow[isc] = true;
								integer ic2 = 0;
								integer iend2loc = nnz_a[ilevel - 1] + iadd;
								integer istart2 = ii_2;
								while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
								istart2++;
								for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
									if (Amat[is01].j == set[js]) {
										ic2++;
									}
								}

								data_BalTree dsearch;
								dsearch.count_neighbour = count_neighbour[isc];
								//dsearch.ii = ii_2;
								dsearch.i = isc;
								count_neighbour[isc] += ic2;
								data_BalTree dadd;
								dadd.count_neighbour = count_neighbour[isc];
								//dadd.ii = ii_2;
								dadd.i = isc;
								if (bmaxneighbourinfoactive) {
									// Обновляем информацию о максимальном количестве соседей.
									if (count_neighbour[isc] >= Maximumneighbourcount) {
										Maximumneighbourcount = count_neighbour[isc];
									}

									// Добавляем соседа в любом случае
									// позволило существенным образом 
									// ускорить алгоритм. Если раньше 
									// old = 48595  | 21229
									// new = 433315 | 63031
									// new2 = 19434 | 3698
									// и основное время уходило на old
									// то теперь
									// old = 1449 | 1466
									// new = 472600 | 64525
									// new2= 56544 | 18431
									// Время решения 3D задачи с 1M неизвестными 
									// сократилось с 6мин 48с до 4мин 45с.

									if (bAVL) {

										// добавляем элемент в АВЛ дерево,
										// причём если элемент уже находился в дереве то он модифицируется.
										// 12 декабря 2015.
										// Добавление узла происходит за логарифмическое по основанию 2 время,
										// причём после добавления дерево остаётся сбалансированным.
										// Адельсон-Вельский и Ландис 1962.
										switch (id_tree)
										{
										case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
										case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch); break;
										default: root = insert_and_modify(root, dadd, dsearch);
											break;
										}
										
										if (bAVL_deb)
										{
											printf("insert and modify\n");
										}
									}


								}

							}
						}

					}
				}

					}
					else if (0) {
						// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
						for (integer js = 1; js < ic; js++) {

							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (flag[Amat[is0].j] == false) {


									integer isc = Amat[is0].j;
									integer ii_2 = row_startA[isc];

									// При таком подходе некоторые соседи инкрементируются дважды и это
									// даёт хорошую скорость агломерации. Хватает 4 кратного размера памяти под исходную матриу.
									// Количество повторно инкрементируемых узлов составило около 33% в 2D на пятиточечном шаблоне.
									// Было решено оставить этот вариант кода т.к. он даёт хорошую скорость агломерации.


									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									istart2++;
									for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
										if (Amat[is01].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.count_neighbour = count_neighbour[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									count_neighbour[isc] += ic2;
									data_BalTree dadd;
									dadd.count_neighbour = count_neighbour[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;

									if (bAVL) {

										// добавляем элемент в АВЛ дерево,
										// причём если элемент уже находился в дереве то он модифицируется.
										// 12 декабря 2015.
										// Добавление узла происходит за логарифмическое по основанию 2 время,
										// причём после добавления дерево остаётся сбалансированным.
										// Адельсон-Вельский и Ландис 1962.
										switch (id_tree)
										{
										case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
											break;
										case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
											break;
										default: root = insert_and_modify(root, dadd, dsearch);
											break;
										}
										
										if (bAVL_deb)
										{
											printf("insert and modify\n");
										}
									}

									if (bmaxneighbourinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_neighbour[isc] >= Maximumneighbourcount) {
											Maximumneighbourcount = count_neighbour[isc];
										}
									}

								}

							}
						}
					}
					else
					
#endif
					if (1)
					{
						// 10 января 2016. Новая логика.
						// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
						// Эта модификация даёт сокращение количества V циклов которые требуются до сходимости
						// Эта модификация наиболее близка к классической описанной в литературе чем все предыдущие.
						// На момент 13 января 2016 это лучший вариаент по скорости вычислений.
						integer itop_stack2 = 0;

						// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
						for (integer js = 1; js < ic; js++) {

							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (flag[Amat[is0].j] == false) {


									integer isc = Amat[is0].j;

									// Избавляемся от повторных инкрементаций.
									// В 2D на пятиточечном шаблоне повторные инкрементации составляют
									// около 33%.
									// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
									// на ряде тестовых задач при таком подходе агломерация проходила очень
									// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
									// Эта проблема проявилась на задачах:
									// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
									// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
									// Проблема не в этом месте кода.
									if (hash_table2[isc] == false) {
										hash_table2[isc] = true;
										istack2[itop_stack2] = isc;
										itop_stack2++;

										integer ii_2 = row_startA[isc];


										integer ic2 = 0;
										integer iend2loc = nnz_a[ilevel - 1] + iadd;
										integer istart2 = ii_2;
										while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
										istart2++;
										for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
											if (Amat[is01].j == set[js]) {
												ic2++;
											}
										}

										data_BalTree dsearch;
										dsearch.count_neighbour = count_neighbour[isc];
										//dsearch.ii = ii_2;
										dsearch.i = isc;
										// Увеличиваем на количество связей с новыми F узлами.
										count_neighbour[isc] += ic2;
										//if (ic2 > 0) {
											//count_neighbour[isc] += 1;
										//}
										data_BalTree dadd;
										dadd.count_neighbour = count_neighbour[isc];
										//dadd.ii = ii_2;
										dadd.i = isc;

										if (bAVL) {

											// добавляем элемент в АВЛ дерево,
											// причём если элемент уже находился в дереве то он модифицируется.
											// 12 декабря 2015.
											// Добавление узла происходит за логарифмическое по основанию 2 время,
											// причём после добавления дерево остаётся сбалансированным.
											// Адельсон-Вельский и Ландис 1962.
											switch (id_tree)
											{
											case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
												break;
											case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
												break;
											default: root = insert_and_modify(root, dadd, dsearch);
												break;
											}
											if (bAVL_deb)
											{
												printf("insert and modify\n");
											}
										}

										if (bmaxneighbourinfoactive) {
											// Обновляем информацию о максимальном количестве соседей.
											if (count_neighbour[isc] >= Maximumneighbourcount) {
												Maximumneighbourcount = count_neighbour[isc];
											}
										}
									}

								}

							}
						}

						// Очистка (восстановление хеш-таблицы).
						for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
							hash_table2[istack2[i_54]] = false;
						}
						itop_stack2 = 0; // стек снова готов к работе.
					
						
					} // the end
					else {
						// 13 января 2016. Новая логика.
						// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
						// Отличие в том что мы учитываем лишь Strong связи при инкрементации счётчика.
						// Это привело к 5 уровням вместо 13, и очень медленной сходимости.
						// Это было при magic=0.4
						// Strong связи при инкрементации счётчика не подходят по причине низкой производительности. 13 января 2016.
						integer itop_stack2 = 0;

						// На основе  старого варианта просто очищенного от устаревшего кода.
						for (integer js = 1; js < ic; js++) {

							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							doublerealT threshold9 = -1.0;
							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (Amat[is0].j != Amat[ii_11].i) {
									if (fabs(Amat[is0].aij) > threshold9) {
										threshold9 = fabs(Amat[is0].aij);
									}
								}
							}

							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (fabs(Amat[is0].aij) > theta*threshold9) {
									if (flag[Amat[is0].j] == false) {


										integer isc = Amat[is0].j;

										// Избавляемся от повторных инкрементаций.
										// В 2D на пятиточечном шаблоне повторные инкрементации составляют
										// около 33%.
										// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
										// на ряде тестовых задач при таком подходе агломерация проходила очень
										// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
										// Эта проблема проявилась на задачах:
										// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
										// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
										// Проблема не в этом месте кода.
										if (hash_table2[isc] == false) {
											hash_table2[isc] = true;
											istack2[itop_stack2] = isc;
											itop_stack2++;

											integer ii_2 = row_startA[isc];


											integer ic2 = 0;
											integer iend2loc = nnz_a[ilevel - 1] + iadd;
											integer istart2 = ii_2;
											while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
											istart2++;
											// Определяем модуль максимального внедиагонального элемента.
											doublerealT threshold_loc1 = -1.0; // инициализация порога.
											for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
												// Только внедиагональные элементы.
												if (Amat[is01].j != Amat[ii_2].i) {
													if (fabs(Amat[is01].aij) > threshold_loc1) {
														threshold_loc1 = fabs(Amat[is01].aij);
													}
												}
											}
											for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
												// Только внедиагональные элементы.
												if (Amat[is01].j != Amat[ii_2].i) {
													if (Amat[is01].j == set[js]) {
														// только Strong связи
														// по крайней мере именно так рекомендуют в литературе.
														if (fabs(Amat[is01].aij) > theta*threshold_loc1) {
															ic2++;
														}
													}
												}
											}

											if (ic2 > 0) {
												// Только если были Strong связи приводящие к инкрементации счётчика ic2.


												data_BalTree dsearch;
												dsearch.count_neighbour = count_neighbour[isc];
												//dsearch.ii = ii_2;
												dsearch.i = isc;
												count_neighbour[isc] += ic2;
												data_BalTree dadd;
												dadd.count_neighbour = count_neighbour[isc];
												//dadd.ii = ii_2;
												dadd.i = isc;

												if (bAVL) {

													// добавляем элемент в АВЛ дерево,
													// причём если элемент уже находился в дереве то он модифицируется.
													// 12 декабря 2015.
													// Добавление узла происходит за логарифмическое по основанию 2 время,
													// причём после добавления дерево остаётся сбалансированным.
													// Адельсон-Вельский и Ландис 1962.
													switch (id_tree)
													{
													case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
														break;
													case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
														break;
													default: root = insert_and_modify(root, dadd, dsearch);
														break;
													}
													if (bAVL_deb)
													{
														printf("insert and modify\n");
													}
												}
											}

											if (bmaxneighbourinfoactive) {
												// Обновляем информацию о максимальном количестве соседей.
												if (count_neighbour[isc] >= Maximumneighbourcount) {
													Maximumneighbourcount = count_neighbour[isc];
												}
											}
										}

									}
								}

							}
						}

						// Очистка (восстановление хеш-таблицы).
						for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
							hash_table2[istack2[i_54]] = false;
						}
						itop_stack2 = 0; // стек снова готов к работе.


					} 

				

				n_coarce++; // Увеличено количество С узлов.

							// Один агрегат создан.

			} // узел не был ещё включён в агрегат.



			bcontinue = false;
			for (integer i_1 = istartflag_scan; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (flag[i_1] == false) {
					bcontinue = true;
					istartflag_scan = i_1; // сокращаем пределы сканирования.
					break; // досрочный выход из цикла for.
						   //if (maxneighbour == -1) {
#if doubleintprecision == 1
						   //printf("ERROR!!!!  i_1=%lld\n", i_1);
#else
						   //printf("ERROR!!!!  i_1=%d\n", i_1);
#endif
						   
						   //system("pause");
						   //}
				}
			}

			// Вычисление узла с максимальным количеством соседей.
			maxneighbour = -1;
			icandidate = 0;


			// TODO 6 november
			//integer isize_p = -1;
			/*
			if (0) {

				// На основе линейного поиска (медленный вариант на больших размерностях).

				const integer ipool_size_limit = 256000; // 128000
				//integer ipool[ipool_size_limit];
				integer* ipool = new integer[ipool_size_limit];

				for (integer isc = 0; isc < ic; isc++) {
					integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
					integer ii_c = ii_s;
					//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
					//ii_c++;
					while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
						integer icandidateq = ii_c;
						bool found1 = false;
						for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
							if (i_7 < ipool_size_limit) {
								if (ipool[i_7] == icandidateq) {
									found1 = true;
								}
							}
							else {
							#if doubleintprecision == 1
								printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
							#else
								printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
							#endif
								
								system("pause");
								exit(1);
							}
						}
						// элемент в списке не обнаружен, поэтому запомним индекс.
						if (found1 == false) {
							isize_p++;
							if (isize_p < ipool_size_limit) {
								ipool[isize_p] = icandidateq;
							}
							else {
							#if doubleintprecision == 1
									printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
							#else
									printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
							#endif
								
								system("pause");
								exit(1);
							}
						}
						ii_c++;
					}
				}
				delete[] ipool;

			}
			else if (0){

				// 4 января 2016. Медленный линейный поиск заменён на обработку АВЛ дерева.

				// На основе АВЛ дерева.
				//const integer ipool_size_limit = 256000; // 128000
				//integer ipool[ipool_size_limit];
				//integer* ipool = new integer[ipool_size_limit];

				node_AVL_Gus* root_Gus = 0;

				for (integer isc = 0; isc < ic; isc++) {
					integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
					integer ii_c = ii_s;
					//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
					//ii_c++;
					while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
						integer icandidateq = ii_c;
						bool found1 = false;
						found1 = isfound_Gus(root_Gus, icandidateq);
						//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
							//if (i_7 < ipool_size_limit) {
								//if (ipool[i_7] == icandidateq) {
									//found1 = true;
								//}
							//}
							//else {
							#if doubleintprecision == 1
									//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
							#else
									//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
							#endif
								
								//system("pause");
								//exit(1);
							//}
						//}
						// элемент в списке не обнаружен, поэтому запомним индекс.
						if (found1 == false) {
							isize_p++;

							root_Gus = insert_Gus(root_Gus, icandidateq);

							//if (isize_p < ipool_size_limit) {
								//ipool[isize_p] = icandidateq;
							//}
							//else {
							#if doubleintprecision == 1
								//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
							#else
								//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
							#endif
								
								//system("pause");
								//exit(1);
							//}
						}
						ii_c++;
					}
				}
				//delete[] ipool;
				clear_AVL_Gus(root_Gus);
				root_Gus = 0;

				// На основе сбалансированного АВЛ дерева поиска.
			}
			else {

				// 6 января 2016. Медленный линейный поиск заменён на обработку hash таблицы.

				// На основе hash таблицы.
				//const integer ipool_size_limit = 256000; // 128000
				//integer ipool[ipool_size_limit];
				//integer* ipool = new integer[ipool_size_limit];

				//node_AVL_Gus* root_Gus = 0;
				// Нельзя это вызывать это очень медленно.
				//for (integer isc = 0; isc <= nnz_a[ilevel - 1]; isc++) hash_table[isc] = false; // initialization
				integer itop = 0; // указатель на вершину стека.

				for (integer isc = 0; isc < ic; isc++) {
					integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
					integer ii_c = ii_s;
					//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
					//ii_c++;
					while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
						integer icandidateq = ii_c;
						bool found1 = false;
						//found1 = isfound_Gus(root_Gus, icandidateq);
						found1 = hash_table[icandidateq - iadd];

						//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
						//if (i_7 < ipool_size_limit) {
						//if (ipool[i_7] == icandidateq) {
						//found1 = true;
						//}
						//}
						//else {
						#if doubleintprecision == 1
								//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
						#else
								//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
						#endif
						
						//system("pause");
						//exit(1);
						//}
						//}
						// элемент в списке не обнаружен, поэтому запомним индекс.
						if (found1 == false) {
							isize_p++;

							//root_Gus = insert_Gus(root_Gus, icandidateq);
							hash_table[icandidateq - iadd] = true;
							if (itop < istack_size_limit ) {
								istack[itop] = icandidateq - iadd;
								itop++;
							}
							else {
								printf("itop>=istack_size_limit need to increase istack_size_limit");
							}

							//if (isize_p < ipool_size_limit) {
							//ipool[isize_p] = icandidateq;
							//}
							//else {
							#if doubleintprecision == 1
									//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
							#else
									//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
							#endif
							
							//system("pause");
							//exit(1);
							//}
						}
						ii_c++;
					}
				}
				//delete[] ipool;
				//clear_AVL_Gus(root_Gus);
				//root_Gus = 0;

				for (integer isc = itop - 1; isc >= 0; isc--) {
					hash_table[istack[isc]] = false;
				}
				itop = 0;

				// На основе сбалансированного АВЛ дерева поиска.
			}
			*/


		//	ibegining_start_index_found_maximum += isize_p + 1;

			if (bAVL) {
				if (bAVL_deb)
				{
					printf("found max");
				}
				// Данный код чрезвычайно компактен.
				bmaxneighbourinfoactive = true;
				// Надо найти максимальный элемент в АВЛ дереве.
				node_AVL* emax = 0;
				Tree_splay* emax_splay = 0;
				switch (id_tree)
				{
				case AVL_TREE_ID: emax = findmax(root);
					break;
				case SPLAY_TREE_ID: emax_splay = findmax(root_splay);
					break;
				default: emax = findmax(root);
					break;
				}

				
				switch (id_tree) {
				case AVL_TREE_ID:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;

					}
					break;
				case SPLAY_TREE_ID:
					// SPLAY tree
					if (emax_splay != 0) {


						//icandidate = emax_splay->item.ii; 23 jan 2016
						icandidate = row_startA[emax_splay->item.i];
						emax_splay = 0;

					}
					else {
						root_splay = 0;
						size_splay_Tree = 0;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;

					}
					break;
				default:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;

					}
					break;
				}
				

				

			}

#if doubleintprecision == 1
			//printf("maximum number of neighbour=%lld\n",maxneighbour);
#else
			//printf("maximum number of neighbour=%d\n",maxneighbour);
#endif
			
			if (maxneighbour == -1) if (debug_reshime) system("pause");
			//getchar();

			if ((icandidate == 0) && (maxneighbour == -1)) {
				bcontinue = false;
			}

			if (bAVL_deb)
			{
				print_AVL(root);
				system("pause");
			}

			icountprohod++;

		} // Построение C/F разбиения. создано.

		//delete[] bmarkervisit;
		free(bmarkervisit);

		if (bprint_mesage_diagnostic) {
			printf("additional C=%3.1f\n", (doublerealT)(100.0*newCcount / n_a[ilevel - 1]));
			//system("pause");
		}

		if (bAVL)
		{
			// Освобождение оперативной памяти из под АВЛ дерева.
			// 12 декабря 2015.
			switch (id_tree)
			{
			case AVL_TREE_ID: clear_AVL(root);
				root = 0;
				break;
			case SPLAY_TREE_ID:
				clear_SPLAY(root_splay);
				root_splay = 0;
				break;
			default: clear_AVL(root);
				root = 0;
				break;
			}
			
		}


		// В методе стандартной интерполяции присутствует шаг уменьшения разреженности,
		// для того чтобы правильно аппроксимировать все F переменные C переменными надо
		// увеличить количество С переменных.
		integer ipromah = 0;
		integer ipromah_one = 0;
		integer ipromah_oneF = 0;

		integer iadditionalCstatistic = 0;

		bool bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]  ) {
				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				// старая версия до 10 января 2016.
				//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// Быстрый вариант без поиска, просто индексирование на основе "хеш-таблицы".
				// 10 января 2016. на основе хеширования.
				integer i_2 = row_startA[i_1];

				bool bvisit = false;
				for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
					if (Amat[is0].j != Amat[i_2].i) {
						bvisit = true;
						if (this_is_C_node[Amat[is0].j]  ) {
							icsos++;
						}
						else {
							ipromah++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.
											   // Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
				if ((icsos == 0) && (bvisit)) {

					// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
					// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
					// поглощены агломератами внутренних узлов и всё было впорядке.
					// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

					// Нет С соседей, этот узел станет С узлом.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					// F node стал C_node!!! Идея стандартной интерполяции 
					// приводит к уменьшению разреженности оператора Галёркина.
					bweSholdbeContinue = true;
					newCcount++;
				}

				// 1 января 2015 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false)&&(icsos == 1)) {
					// bvisit и так true т.к. icsos==1.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					bweSholdbeContinue = true;
				}

			}

			if (bprint_mesage_diagnostic) {
				if (bweSholdbeContinue) {
					printf(" prohod succseful\n");
				}
				else {
					printf("prohod empty\n");
				}
			}

		}




		// Нужно корректно обработать узлы Дирихле,
		// Если F узел окажется узлом Дирихле без соседей то его надо сделать С узлом,
		// Но узнать такой узел можно лишь в процессе выполнения алгоритма дальше по ходу исполнения.
		// Поэтому может потребоваться вернуться и начать заново (обратная связь).


		integer* C_numerate = nullptr;
		//C_numerate = new integer[n_a[ilevel - 1] + 1];
		C_numerate = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(C_numerate,"C_numerate","classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		integer icounter = 1;
		integer icount1;
		integer numberofcoarcenodes;
		doublerealT* ap_coarse = nullptr;

		bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) { n_coarce++; }
			n_coarce--;


			// debug
			// проверка качества C/F разбиения.
			//doublerealT* exp1 = new doublerealT[n_a[ilevel - 1] + 1];
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) exp1[i_1] = 0.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) exp1[i_1] = 2.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]) exp1[i_1] = 1.0;
			//exporttecplot(exp1,n);
			//delete[] exp1;

			//printf("export ready");

			//system("pause");

			

			// C/F разбиение построено, самое время построить оператор интерполяции.
			// потом найти оператор проекции, как транспонированный оператор интерполяции.
			// Всё завершает построение матрицы нового сеточного уровня и можно запускать новый уровень.

			// Построение оператора интерполяции: 
			// coarse 2 fine.
			//P*coarse==fine


			// Занумеруем (упорядочим) узлы грубой сетки.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) C_numerate[i_1] = 0;
			icounter = 1;
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]  ) {
#if doubleintprecision == 1
				//printf("C ind= %lld", i_1); getchar();
#else
				//printf("C ind= %d", i_1); getchar();
#endif
				
				C_numerate[i_1] = icounter;
				icounter++;
			}




			// C_numerate - перенумерация на множестве Coarse узлов.
			// Построение пролонгации для узлов которые составляют грубую сетку.
			icount1 = 1 + iaddR; // nnz_R
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]  ) {
				P[icount1].aij = 1.0;
				P[icount1].i = C_numerate[i_1]; // coarse number
				P[icount1].j = i_1; // fine number.
				icount1++;
			}

			// значение icount1 нужно далее.НЕ трогать !!!.
			numberofcoarcenodes = icount1 - 1 - iaddR;

			// Для модификации R  надо transpose(P)/ap.
			if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
				printf("countloc=%lld\n", numberofcoarcenodes);
#else
				printf("countloc=%d\n", numberofcoarcenodes);
#endif
				
				if (debug_reshime) system("pause");
			}

			//ap_coarse = new doublerealT[numberofcoarcenodes + 1];
			ap_coarse = (doublerealT*)malloc((numberofcoarcenodes + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(ap_coarse, "ap_coarse", "classic_aglomerative_amg_2", (numberofcoarcenodes + 1));
			
			ap_coarse[0] = 0.0;

			
			

			// Для каждого С узла запоминаем в ap_coarse[C_numerate[i8]] 
			// модуль диагонального элемента.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_C_node[i8]  ) {
				// Старая версия до 10 января 2016. Время O(log2(nnz))
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// 10 января 2016 новая версия на основе хеширования. Время O(1).
				integer ii1 = row_startA[i8];
				// бинарный поиск должен гарантирует нахождение самого левого представителя.
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
#if doubleintprecision == 1
					//printf("i=%lld j=%lld Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#else
					//printf("i=%d j=%d Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#endif
					
					if (Amat[is0].j == Amat[ii1].i) {
						
						if (fabs(Amat[is0].aij) > RealMAXIMUM) {
							printf("perepolnenie error!");
							//getchar();
							system("pause");
						}
						ap_coarse[C_numerate[i8]] = fabs(Amat[is0].aij);
						//printf("find = %e", fabs(Amat[is0].aij));
					}
				}
				//printf("\n");
				//getchar();
			}

			// верно 2 октября.
			
			bool the_good_old_interpolation = true;

			if (the_good_old_interpolation) {

				// Старая добрая верная, проверенная интерполяция.
				// К тому же чрезвычайно простая.

				if (0) {

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.

				    ipromah = 0;
				    ipromah_one = 0;
				    // Построение пролонгации для узлов которые составляют F nodes.
				    // Каждый F-nodes окружён C-nodes.
				    for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

					    // Нам нужен разреженный оператор Галёркина.
					    // 5 декабря 2015 года мы попробуем увеличить разреженность
					    // оператора интерполяции а значит и оператора Галёркина.
					    doublerealT maxelem_threshold = -1.0;
						// O(log2(nnz))
					    //integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// O(1)
						integer ii1 = row_startA[i8];
					    for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						    if (Amat[is0].j != Amat[ii1].i) {
							    // Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
							    //if (this_is_C_node[Amat[is0].j]  ) {
							    if (fabs(Amat[is0].aij) > maxelem_threshold) {
							    	maxelem_threshold = fabs(Amat[is0].aij);
							    }
						    	//}
					    	}
					   }
					   // Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					   // Найти соседей данного F-node которые C-node.
					   integer icsos = 0;

					   // Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					   // Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					   doublerealT sumP = 0.0;
					   for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						   if (Amat[is0].j != Amat[ii1].i) {
							   if (this_is_C_node[Amat[is0].j]  ) {
								   //	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								   if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									   sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									   icsos++;
								   }
						    	}
							    else {
								   // Подсчитываем количество соседей которые не являются С узлами.
								   ipromah++; // подсчитываем проблемы интерполяции 
							    }
						   }
					   }
					   if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


					   // 1 января 2016 Один сосед это недостаточно.
					   // Поэтому в случае одного соседа делаем такой узел С узлом.
					   if ((false) && (icsos == 1)) {
						    this_is_F_node[i8] = false;
						    this_is_C_node[i8] = true;
						    bweSholdbeContinue = true;
					   }
					   else {



						    for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							    if (Amat[is0].j != Amat[ii1].i) {
								    if (this_is_C_node[Amat[is0].j]  ) {

									     if (fabs(sumP) < RealZERO) {
										     //printf("error interpolation zero diagonal sumP.\n");
										     //printf("Fnode all neighbour is F");
										     //system("pause");
										     //printf("i8 is Dirichlet node\n");
										     this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										     this_is_C_node[i8] = true;
										     bweSholdbeContinue = true;
										     iadditionalCstatistic++;
										     //exit(1);
										     // здесь нужна непрямая интерполяция.
									     }
									     else {

									     	// Внедиагональный элемент из множества С узлов.

										    // Данная вставка должна существенно сохранять 
										    // разреженность оператора Галёркина на глубоких 
									    	// сеточных уровнях.
										    // Модификация 5 декабря 2015.
										    //if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										    if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											   P[icount1].j = i8;
											   P[icount1].i = C_numerate[Amat[is0].j];
											   P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											   icount1++;
										    }
                                  
									    }

			      					}
					    		}
						    }

					    }

			    	}
				}
				if (0) {
					// Немного более экономичная по памяти. Коэффициент не превышал 3.

					// Прямая интерполяция с элементам непрямой.
					// Непрямая интерполяция применяется только для F узлов которые
					// не имеют С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.
					// Узел F не имеющий Strong C соседей, получает значение из Strong C соседей соседних Strong F узлов в
					// в результате сканирования списка Strong F соседей.
					// Если на встречаются два Strongly связанных F узла у которых в совокупности нет вообще ни одного Strong C соседа
					// то один из этих Strong F узлов тановится С узлом и сканирование списка сильных Strong F соседов данного узла F прекращается.
					// Потом мы повторн запускаем алгоритм построения с учётом уже добавленных С узлов.


					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						// O(log2(nnz))
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// O(1)
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j]  ) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


													   // 1 января 2015 Один сосед это недостаточно.
													   // Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all neighbour is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");

								//exit(1);
								// здесь нужна непрямая интерполяция.
								bool* empty_interpol = nullptr;
								//empty_interpol = new bool[icount_StronglyF];
								empty_interpol = (bool*)malloc(icount_StronglyF*sizeof(bool));
								handle_error<bool>(empty_interpol, "empty_interpol", "classic_aglomerative_amg_2", icount_StronglyF);
								
								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									empty_interpol[i_38] = false; // initialization
								}

								integer i_38_count = 0;

								bool bCinsert = false;

								// Сканируем сильных F соседей данного F узла для которого надо построить интерполяцию.
								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j]  ) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

												integer iFpoint = Amat[is0].j;
												doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
												// сканируем всех соседей iFpointeger 
												// чтобы найти среди них С узлы.

												// Идентифицируем локальный порог.
												doublerealT maxelem_threshold_loc = -1.0;
												//O(log2(nnz))
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												// O(1)
												integer ii1_loc = row_startA[iFpoint];
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														//if (this_is_C_node[Amat[is0_loc].j]  ) {
														// Будем рассматривать только действительно сильных C кандидатов второго уровня.
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
															}
														//}
													}
												}


												// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

												// Найти соседей данного F-node которые C-node.
												integer icsos_loc = 0;
												bool bvisit_sumPloc = false;

												// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
												// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
												doublerealT sumP_loc = 0.0;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {




														if (this_is_C_node[Amat[is0_loc].j]  ) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																icsos_loc++;
																bvisit_sumPloc = true;
																empty_interpol[i_38_count] = true;
															}
														}
														else {
															// Подсчитываем количество соседей которые не являются С узлами.
															//ipromah_loc++; // подсчитываем проблемы интерполяции 
														}
													}
												}


												if (bvisit_sumPloc) {
													// В общем это двойная интерполяционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}
												}
												else {
													// не было С соседей интерполяция может испытывать проблемы.
													// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
													// Данная проблема проявляется уже на втором уровне.
													//printf("problem situation");
													//getchar();
													this_is_F_node[iFpoint] = false;
													this_is_C_node[iFpoint] = true;
													bweSholdbeContinue = true;
													bCinsert = true;
													// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполлчяцию,
													// Иначе я боюсь мы можем добавить слишком много С узлов на грубосеточных уровнях.
													break;
													// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых уровнях сетки.

												}

												i_38_count++;

											}
										}
									}
								}

								if (!bCinsert) {
									// Ибиранее этой добавки даёт ускорение вместо 3мин 42с до 3мин 29с.

									bool bstandart_vjzov = true;
									for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
										// 3 января. На самом деле здесь хорошо бы посмотреть вариант
										// когда с не менее чем двух сторон интерполяция сработала, здесь 
										// же срабатывание было лишь с одной из сторон как минимум.
										if (empty_interpol[i_38]  ) {
											bstandart_vjzov = false;
										}
									}
									if (bstandart_vjzov) {
										this_is_F_node[i8] = false;
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
									}
								}

								free(empty_interpol); 

							}



							else {

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j]  ) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
											}



										}
									}
								}
							} // standart

						} // i8


					}

				}

				if (0) {
					// Немного более экономичная по памяти. Коэффициент не превышал 3.

					// Прямая интерполяция с элементам непрямой. Экспериментальный вариант. TODO.
					// Непрямая интерполяция применяется только для F узлов которые
					// не имеют С соседей или имеют недостаточное число С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.

					// Надо сохранить разреженность оператора Галёркина но при этом усилить интерполяцию.
					// Идея в том чтобы узел F имеющий лишь одного Strong С соседа обработать так чтобы у него было не менее 
					// двух  C соседей учитывая эффект непрямой интерполяции.


					ipromah = 0;
					ipromah_one = 0;
					ipromah_oneF = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j]  ) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполяцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}


													   // 1 января 2015 Один сосед это недостаточно.
													   // Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all neighbour is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");

								//exit(1);
								// здесь нужна непрямая интерполяция.
								bool* empty_interpol = nullptr;
								//empty_interpol = new bool[icount_StronglyF];
								empty_interpol = (bool*)malloc(icount_StronglyF*sizeof(bool));
								handle_error<bool>(empty_interpol, "empty_interpol", "classic_aglomerative_amg_2", icount_StronglyF);
								
								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									empty_interpol[i_38] = false; // initialization
								}

								integer i_38_count = 0;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j]  ) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

												integer iFpoint = Amat[is0].j;
												doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
												// сканируем всех соседей iFpointeger 
												// чтобы найти среди них С узлы.

												// Идентифицируем локальный порог.
												doublerealT maxelem_threshold_loc = -1.0;
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												integer ii1_loc = row_startA[iFpoint];
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														//if (this_is_C_node[Amat[is0_loc].j]  ) {
														// Будем рассматривать только действительно сильных С кандидатов второго уровня.
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
															}
														//}
													}
												}


												// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

												// Найти соседей данного F-node которые C-node.
												integer icsos_loc = 0;
												bool bvisit_sumPloc = false;

												// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
												// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
												doublerealT sumP_loc = 0.0;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {




														if (this_is_C_node[Amat[is0_loc].j]  ) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																icsos_loc++;
																bvisit_sumPloc = true;
																empty_interpol[i_38_count] = true;
															}
														}
														else {
															// Подсчитываем количество соседей которые не являются С узлами.
															//ipromah_loc++; // подсчитываем проблемы интерполяции 
														}
													}
												}


												if (bvisit_sumPloc) {
													// В общем это двойная интерполяционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}
												}
												else {
													// не было С соседей интерполяция может испытывать проблемы.
													// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
													// Данная проблема проявляется уже на втором уровне вложенности.
													//printf("problem situation");
													//getchar();
													this_is_F_node[iFpoint] = false;
													this_is_C_node[iFpoint] = true;
													bweSholdbeContinue = true;
													// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполяцию,
													// Иначе я боюсь мы можем добавить слишком много С узлов на грубых уровнях влженности.
													break;
													// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых урвнях сетки.
												}

												i_38_count++;

											}
										}
									}
								}

								bool bstandart_vjzov = true;
								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									// 3 января. На самом деле здесь хорошо бы посмотреть вариант
									// когда с не менее чем двух сторон интерполяция сработала, здесь 
									// же срабатывание было лишь с одной из сторон как минимум.
									if (empty_interpol[i_38]  ) {
										bstandart_vjzov = false;
									}
								}
								if (bstandart_vjzov) {
									this_is_F_node[i8] = false;
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
								}

								free(empty_interpol);

							}
							else if ((icsos == 1)&&(icsosF!=0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (this_is_C_node[Amat[is0].j]  ) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//	printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												else {
													// Это как раз единственная Strong C связь. 
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {

													// Рассматриваем Strong F связи.

													// Смысл:
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														// В общем это двойная интерполяционная сумма 
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																	}
																}
															}
														}


													//}
												}
										}
									}
								}
							}
							else {

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j]  ) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
											}



										}
									}
								}
							} // standart

						} // i8


					}

				}

				if (1) {
					//theta = 0.24;
					// theta_strong_F iter_number time,s
					// 0.21 56 22.63
					// 0.22 55 21.769
					// 0.23 52 21.488
					// 0.24 52 21.741 == theta // optimum
					// 0.26 69 24.623
					doublerealT theta_strong_F = 0.23; // оптимальный выбор.

					// четвёртая версия интерполяции.
					integer ioneStrongC_and_0_StrongF = 0;

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					    //6interpolation 0.4 6.77 11 26 28.355
						//6interpolation 0.45 6.6 10 27 28.151
						//6interpolation 0.5 6.42 12 32 28.735
						//4interpolation 0.4 3.7  52 24.736 // best
						//4interpolation 0.3 3.78 13 59 27.525
						//4interpolation 0.5 3.61 12 55 25.533
						//4interpolation 0.45 3.65 10 63 30.24

					bool byes_add = false;
					// Быстрое добавление недостающих С узлов.
					if (1) {
						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						//doublerealT magic = 0.4; // 0.4 optimum


						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if (fabs(Amat[is0].aij)>maxelem_threshold_theta) {
										    sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
											    SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}

							

							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							{

								if ((icsos == 1) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									//SumPall += sumP;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
												if (this_is_C_node[Amat[is0].j]  ) {

													// 20 января 2016.
													// По-моему этой ситуации вообще быть не может так как у нас 
													// заведомо один С сосед.
													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all neighbour is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														byes_add = true; // Были добавления узлов.
														//exit(1);
														// здесь нужна непрямая интерполяция.
													}
													

												}
												
											}
										}
									}
								}
								else {

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (this_is_C_node[Amat[is0].j]  ) {
										if (Amat[is0].j != Amat[ii1].i) {
											

												// 20 jan 2016.
												// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


												if (fabs(sumP) < RealZERO) {
													// Это случай когда вообще нет сильных С соседей.


													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													byes_add = true; // Были добавления узлов.
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												

											}
										}
									}
								}

							}

						}

					}

					

					if (!byes_add) {

					// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
					doublerealT magic = 0.4; // 0.4 optimum
					// линейный прогноз не дает улучшений
					// ни по быстрдействию ни по числу V циклов.
					//magic = 0.5 - 0.2*ilevel / 12.0;

					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						integer istr_etalon1 = Amat[ii1].i;
						integer iend_for1 = -1;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == istr_etalon1); is0++) {
							iend_for1 = is0;
							if (Amat[is0].j != istr_etalon1) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
						doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
					    //	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						for (integer is0 = ii1; is0 <= iend_for1; is0++) {
							if (Amat[is0].j != istr_etalon1) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j]  ) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
										if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполяцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}



						// 1 января 2016 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										
										
											if (this_is_C_node[Amat[is0].j]  ) {
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all neighbour is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполяция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															icount1++;
														}

													}
												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
													if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
														// Рассматриваем Strong F связи.

														// Смысл:
														// 



														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														// Это лишнее условие, ранее уже было проверено что мы имеем дело
														// с сильной F связью.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														integer istr_etalon = Amat[ii1_loc].i;
														integer iend_for = -1;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == istr_etalon); is0_loc++) {
															iend_for = is0_loc;
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																if (Amat[is0_loc].j != istr_etalon) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}

														doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
															if (Amat[is0_loc].j != istr_etalon) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

														// В общем это двойная интерполяционная сумма 
														//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
														    if (this_is_C_node[Amat[is0_loc].j]  ) {
																if (Amat[is0_loc].j != istr_etalon) {
																
																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
																	if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																	}
																}
															}
														}


														//}
													}
												}
										}
									
								}
							}
							else {

								// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
								// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
								// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
								// bmodify_interpol4_amg = false;
								// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
								bool bmodify_interpol4_amg = false;
								doublerealT magic2 = 0.5;

								// Подготовительный этап к усилению четвертой интерполяции 
								// Усиление интерполяции происходит без добавления новых С узлов.
								// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
								// имеется конечно.
								// Подготовительный этап заключается в определении положения is0_candidate самой сильной
								// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
								doublerealT sum1 = 0.0;
								integer is0_candidate = -1;
								if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											if (this_is_C_node[Amat[is0].j]  ) {
												//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
												if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
													if (fabs(Amat[is0].aij) > sum1) {
														sum1 = fabs(Amat[is0].aij);
														is0_candidate = is0;
													}
												}
											}
										}
									}

									if (sum1 / sumP < magic2) {
										// Если найденный элемент слишком слабый ничего не делаем с этим С,
										// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
										sum1 = 0.0;
										is0_candidate = -1;

										// Тогда ищем среди Weakly F узлов кандидата.
										for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												if (this_is_F_node[Amat[is0].j]  ) {
													//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
													if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
													    if (fabs(Amat[is0].aij) > sum1) {
															sum1 = fabs(Amat[is0].aij);
															is0_candidate = is0;
														}
													}
												}
											}
										}

										// такой узел F должен стать новым С узлом.
										if (sum1 / sumP >= magic2) {
											this_is_F_node[i8] = false; // Этот узел  станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											byes_add = true;
											iadditionalCstatistic++;
											
										}
										// Обязательный сброс перед рестартом чтобы не было деления на ноль.
										sum1 = 0.0;
										is0_candidate = -1;

									}
								}


								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j]  ) {

											

											if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
												// Мы усиливаем силу интерполяции без добавления новых узлов за
												// счёт одной дополнительной самой сильной Weakly C связи.
												// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

												 ioneStrongC_and_0_StrongF++;
												 if ( is0_candidate != -1) {
													 P[icount1].j = i8;
													 P[icount1].i = C_numerate[Amat[is0_candidate].j];
													 P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
													 icount1++;
												 }

												 //if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												 if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
												     P[icount1].j = i8;
													 P[icount1].i = C_numerate[Amat[is0].j];
													 P[icount1].aij = fabs(Amat[is0].aij) / (sumP+sum1);
													 icount1++;
												 }
											}
											else {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												else {

													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
												//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
													if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														icount1++;
													}

												}

											}

										}
									}
								}
							}

						}
					}

					}
#if doubleintprecision == 1
					//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
					//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif
					
					//system("pause");
				}
				if (0) {
					// пятая попытка.
					// показывает время 1.22 против времени в 1.36 в четвертой попытке.

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j]  ) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполяцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}



						// 1 января 2016 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if ((icsos == 1) && (icsosF != 0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (this_is_C_node[Amat[is0].j]  ) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//	printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												else {
													// Это как раз единственная Strong C связь. 
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {

													// Рассматриваем Strong F связи.

													// Смысл:
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpointeger 
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j]  ) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции 
															}
														}
													}

													// В общем это двойная интерполяционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}


													//}
												}
										}
									}
								}
							}
							else {

								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										
											if (this_is_C_node[Amat[is0].j]  ) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												else {

													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {

													// Рассматриваем Strong F связи.
													// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
													// Смысл:
													//



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpoint
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														// В общем это двойная интерполяционная сумма
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять
																	// разреженность оператора Галёркина на глубоких
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																	}
																}
															}
														}


														//}
													}
												}
												
										
									}
								}
							}

						}

					}
				}

				if (0) {

					bool byes_add = false;
					//  быстрая проверка на добавление.
					if (1) {
						// шестая попытка.
						// CGHV1J amg1r5 time 0.26
						// cl_agl_amg_v0_14 time:
						// magic  time number V cycles grid complexity
						// 0.25   0:48  29  6.55A
						// 0.3    0:45  28  6.19A 
						// 0.35  0:43   28  5.98A
						// 0.4   0:41   27  5.77A // отыграно 14% производительности.
						// tgf2023_10 amg1r5 time 1:00
						// cl_agl_amg_v0_14 time
						// magic  time number V cycles grid complexity
						// 0.25 1:49 27 3.61
						// 0.3 1:47 26 3.47
						// 0.35 1:46 27 3.51
						// 0.4 1:44 28 3.413 // отыграно 5% производительности.
						// Electric potencial in FET2 amg1r5 time 1:38
						// cl_agl_amg_v0_14 time:
						// magic  time number V cycles grid complexity
						// 0.25 3:19 36 6.65
						// 0.3 3:02 34 6.34
						// 0.35 2:52 33 6.091
						// 0.4 2:46 33 5.91 // отыграно 20% производительности.

						// magic=0.4 is optimum.11 jan 2016
						doublerealT magic = 0.4; // 0.4

						// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
						// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
						// сильных F узлов.

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							 {

								 if ((icsos == 1) && (icsosF != 0)) {
									 // Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									 //
									 SumPall += sumP;

									 for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										 if (Amat[is0].j != Amat[ii1].i) {
											 // Нас интересуют только Strong связи.
											 if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												 if (this_is_C_node[Amat[is0].j]  ) {

													 if (fabs(sumP) < RealZERO) {
														 //printf("error interpolation zero diagonal sumP.\n");
														 //printf("Fnode all neighbour is F");
														 //system("pause");
														 //	printf("i8 is Dirichlet node\n");
														 this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														 this_is_C_node[i8] = true;
														 bweSholdbeContinue = true;
														 iadditionalCstatistic++;
														 byes_add = true;
														 //exit(1);
														 // здесь нужна непрямая интерполяция.
													 }


												 }

											 }
										 }
									 }
								 }
								 else {



									 for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										 if (Amat[is0].j != Amat[ii1].i) {

											 if (this_is_C_node[Amat[is0].j]  ) {

												 if (fabs(sumP) < RealZERO) {
													 //printf("error interpolation zero diagonal sumP.\n");
													 //printf("Fnode all neighbour is F");
													 //system("pause");
													 //printf("i8 is Dirichlet node\n");
													 this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													 this_is_C_node[i8] = true;
													 bweSholdbeContinue = true;
													 iadditionalCstatistic++;
													 byes_add = true;
													 //exit(1);
													 // здесь нужна непрямая интерполяция.
												 }


											 }



										 }
									 }



								 }

							 }

						}
					}


					// Проверка на добавление пройдена успешно, 
					// добавлений не было и можно интерполировать !!!.
					if (byes_add == false) {

						// шестая попытка.
						// CGHV1J amg1r5 time 0.26
						// cl_agl_amg_v0_14 time:
						// magic  time number V cycles grid complexity
						// 0.25   0:48  29  6.55A
						// 0.3    0:45  28  6.19A 
						// 0.35  0:43   28  5.98A
						// 0.4   0:41   27  5.77A // отыграно 14% производительности.
						// tgf2023_10 amg1r5 time 1:00
						// cl_agl_amg_v0_14 time
						// magic  time number V cycles grid complexity
						// 0.25 1:49 27 3.61
						// 0.3 1:47 26 3.47
						// 0.35 1:46 27 3.51
						// 0.4 1:44 28 3.413 // отыграно 5% производительности.
						// Electric potencial in FET2 amg1r5 time 1:38
						// cl_agl_amg_v0_14 time:
						// magic  time number V cycles grid complexity
						// 0.25 3:19 36 6.65
						// 0.3 3:02 34 6.34
						// 0.35 2:52 33 6.091
						// 0.4 2:46 33 5.91 // отыграно 20% производительности.

						// magic=0.4 is optimum.11 jan 2016
						doublerealT magic = 0.4; // 0.4

						// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
						// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
						// сильных F узлов.

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							if ((false) && (icsos == 1)) {
								this_is_F_node[i8] = false;
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
							}
							else {

								if ((icsos == 1) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									SumPall += sumP;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if (this_is_C_node[Amat[is0].j]  ) {

													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all neighbour is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполяция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															icount1++;
														}

													}

												}
												else
													if (this_is_F_node[Amat[is0].j]  ) {

														// Рассматриваем Strong F связи.

														// Смысл:
														// 



														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														// Это лишнее условие, ранее уже было проверено что мы имеем дело
														// с сильной F связью.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														// В общем это двойная интерполяционная сумма 
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																	}
																}
															}
														}


														//}
													}
											}
										}
									}
								}
								else {

									SumPall += sumP;
									doublerealT sum_ok = 0.0;
									bool bbackreturn = false;
									integer icount1_mem = icount1;
									bool* bbackrarr = nullptr;
									//bbackrarr = new bool[icount_StronglyF];
									bbackrarr = (bool*)malloc(icount_StronglyF*sizeof(bool));
									handle_error<bool>(bbackrarr, "bbackrarr", "classic_aglomerative_amg_2", icount_StronglyF);
									
									for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
										bbackrarr[i_63] = false;
									}
									integer icounter_bbackarr = -1;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {

											if (this_is_C_node[Amat[is0].j]  ) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												else {

													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														P[icount1].aij = fabs(Amat[is0].aij);
														sum_ok += fabs(Amat[is0].aij);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {

													// Рассматриваем Strong F связи.
													// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
													// Смысл:
													//



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														icounter_bbackarr++;

														integer iFpoint = Amat[is0].j;
														//doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														doublerealT mult1 = fabs(Amat[is0].aij);
														// сканируем всех соседей iFpoint
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														icsos_loc = 0;
														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc1 = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc)>maxelem_threshold*theta) {
																		sumP_loc1 += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																		//	}
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														if (icsos_loc > 0) {
															// В общем это двойная интерполяционная сумма
															for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
																if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																	if (this_is_C_node[Amat[is0_loc].j]  ) {
																		// Внедиагональный элемент из множества С узлов.

																		// Данная вставка должна существенно сохранять
																		// разреженность оператора Галёркина на глубоких
																		// сеточных уровнях.
																		// Модификация 5 декабря 2015.
																		//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																		//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																			//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc) > maxelem_threshold*theta) {
																			P[icount1].j = i8;
																			P[icount1].i = C_numerate[Amat[is0_loc].j];
																			//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																			//P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			P[icount1].aij = mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			sum_ok += mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			icount1++;
																		}
																		//}
																	}
																}
															}
														}
														else {
															//bbackreturn = true;
															bbackrarr[icounter_bbackarr] = true;
														}


														//}
													}
												}


										}
									}


									//bbackreturn = true;
									//for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
									//if (!bbackrarr[i_63]) {
									//	bbackreturn = false;
									//}
									//}

									//if (bbackreturn) {
									// сильные F связи не дали результата, поэтому мы возвращаемся к исходному 
									// варианту интерполяции.
									//for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
									//P[i_95].aij = P[i_95].aij*SumPall / sumP;
									//}
									//}

									// Апосториорная коррекция
									for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
										P[i_95].aij = P[i_95].aij / sum_ok;
									}

									free(bbackrarr);

								}

							}

						}
					}
				
				}

			}
			else if (true) {


				// Экспериментальная интерполяция 1 января 2016.

				ipromah = 0;
				ipromah_one = 0;
				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
				for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

					// Нам нужен разреженный оператор Галёркина.
					// 5 декабря 2015 года мы попробуем увеличить разреженность
					// оператора интерполяции а значит и оператора Галёркина.
					doublerealT maxelem_threshold = -1.0;
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					integer ii1 = row_startA[i8];
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Наверно разумно что threshold определён по всей строке, а не только по С узлам в строке.
							//if (this_is_C_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
							//}
						}
					}
					// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					// Найти соседей данного F-node которые C-node.
					integer icsos = 0;

					doublerealT SumPall = 0.0;
					// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					doublerealT sumP = 0.0;
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {

							// Сумма вообще всех внедиагональных элементов.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								SumPall += fabs(Amat[is0].aij);
							}


							if (this_is_C_node[Amat[is0].j]  ) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									icsos++;
								}
							}
							else {
								// Подсчитываем количество соседей которые не являются С узлами.
								ipromah++; // подсчитываем проблемы интерполяции 
							}
						}
					}
					if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


												   // 1 января 2015 Один сосед это недостаточно.
												   // Поэтому в случае одного соседа делаем такой узел С узлом.
					if ((false) && (icsos == 1)) {
						this_is_F_node[i8] = false;
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
					}
					else {



						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
									//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j]  ) {

										// Смысл:
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

											integer iFpoint = Amat[is0].j;
											doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublerealT maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j]  ) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//ipromah_loc++; // подсчитываем проблемы интерполяции 
													}
												}
											}

											// В общем это двойная интерполяционная сумма 
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0_loc].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
														}
													}
												}
											}


										}
									}
							}
						}

					}


				}
			}
			else {
				// От интерполяции зависит очень много поэтому
				// реализуем следующую экспериментальную идею интерполяции.
				// Эта интерполяция претендует быть единственно теоретически верной,
				// сделанной на основе литературных данных.


				ipromah = 0;
				ipromah_one = 0;
				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
				for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

					// Нам нужен разреженный оператор Галёркина.
					// 5 декабря 2015 года мы попробуем увеличить разреженность
					// оператора интерполяции а значит и оператора Галёркина.
					doublerealT maxelem_threshold = -1.0;
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					integer ii1 = row_startA[i8];
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j]  ) {
							if (fabs(Amat[is0].aij) > maxelem_threshold) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
					// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					// Найти соседей данного F-node которые C-node.
					//integer icsos = 0;

					// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					doublerealT sumP = 0.0;
					doublerealT sumPindicator = 0.0;
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
									// Weak connectors
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									//icsos++;
								}
								else {
									sumPindicator += fabs(Amat[is0].aij);
								}
							}
							else {
								// Подсчитываем количество соседей которые не являются С узлами.
								if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
									// Weak connectors
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															  //icsos++;
								}
								ipromah++; // подсчитываем проблемы интерполяции 
							}
						}
						else {
							// Диагональный элемент.
							sumP += fabs(Amat[is0].aij);
						}
					}
					//if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


					// 1 января 2015 Один сосед это недостаточно.
					// Поэтому в случае одного соседа делаем такой узел С узлом.
					//if ((false) && (icsos == 1)) {
						//this_is_F_node[i8] = false;
						//this_is_C_node[i8] = true;
						//bweSholdbeContinue = true;
					//}
					//else
					{

						if (fabs(sumPindicator) < RealZERO) {
							//printf("error interpolation zero diagonal sumP.\n");
							//printf("Fnode all neighbour is F");
							//system("pause");
							//printf("i8 is Dirichlet node\n");
							this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
							iadditionalCstatistic++;
							//exit(1);
							// здесь нужна непрямая интерполяция.

							// Мы не будем добалять С узлы, мы будем использовать непрямую интерполяцию.



						}
						else {

							integer icount1_frozen = icount1;

							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											// Strongly C connectors.

											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
										}


									}
								}
							}

							integer ilength_n = icount1 - icount1_frozen;
							integer* jposition_in_P = nullptr;
							//jposition_in_P = new integer[ilength_n];
							jposition_in_P = (integer*)malloc(ilength_n*sizeof(integer));
							handle_error<integer>(jposition_in_P, "jposition_in_P", "classic_aglomerative_amg_2", ilength_n);
							
							

							integer i_97 = 0;

							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											// Strongly C connections j position.
											jposition_in_P[i_97] = Amat[is0].j;
											i_97++;
										}
									}
								}
							}


							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_F_node[Amat[is0].j]  ) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											// Strong F connections
											doublerealT my_mult = fabs(Amat[is0].aij);
											integer iFpoint = Amat[is0].j;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];

											// Смотрим всех соседей узла iFpoint
											// если среди них окажутся сильные С соседи 
											// первоначально рассматриваемого узла Amat[ii1].i
											// то мы будем накапливать в сумматоре sum23 
											// модули значеий матрицы.
											doublerealT sum23 = 0.0;
											bool bvisit23 = false;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														for (i_97 = 0; i_97 < ilength_n; i_97++) {
															if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																sum23 += fabs(Amat[is0_loc].aij);
																bvisit23 = true;
																break;
															}
														}
													}
												}
											}

											//if (fabs(sum23) > RealZERO) {
											if (bvisit23) {
												// мы точно не делим на ноль.

												// Сканируем всех соседей узла F.
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j]  ) {
															for (i_97 = 0; i_97 < ilength_n; i_97++) {
																if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																	//P[icount1_frozen + i_97].j = i8;
																	//P[icount1_frozen+i_97].i = C_numerate[Amat[is0].j];
																	P[icount1_frozen + i_97].aij += (my_mult*fabs(Amat[is0_loc].aij)) / (sumP*sum23);
																	break;
																}
															}
														}
													}
												}
											}


										}
									}
								}
							}

							//delete[] jposition_in_P;
							free(jposition_in_P);

						}

					}


				}
			}


		
			if (bweSholdbeContinue) {
				//delete[] ap_coarse;
				free(ap_coarse);
				ap_coarse = nullptr;
				if (bprint_mesage_diagnostic) {
					printf("obratnaq svqz restart...\n");
				}
			}

			if (bprint_mesage_diagnostic) {
				printf("addition C nodes procent %3.1f", (doublerealT)(100.0*iadditionalCstatistic / n_a[ilevel - 1]));
			}
			iadditionalCstatistic = 0;
			//system("pause");
		

		}

		nnzR = icount1 - iaddR;



		// нужно определить nnzR количество ненулевых элементов в матрице R и P.

		// оператор restriction построен и он упорядочен по i.
		// число ненулевых элементов nnzR-1.
		// P=Copy(R);
		for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
			R[ii] = P[ii];
			//if ((ilevel == 2) && (ii >= iaddR + nnzR - 1-30)) {
#if doubleintprecision == 1
			//printf("ii=%lld aij=%e, i=%lld j=%lld\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#else
			//printf("ii=%d aij=%e, i=%d j=%d\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#endif
			
			//getchar();
			//}
		}

		// heapsort(P,key==j,iaddR+1,iaddR+nnzR - 1);

		/*
		// 10 января 2016. Эта сортировка не требуется.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
			}
			else {
				// Быстрая сортировка Хоара.
				qsj(P, 1 + iaddR, iaddR + nnzR - 1);
			}
		}
		else {
			HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		*/


		// где то надо разделить на ap, т.к. 
		// R=P/ap. ????


		// heapsort(R,key==i,iaddR+1,iaddR+nnzR - 1, comparei);

		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(R, 1 + iaddR, iaddR + nnzR - 1,false, indx_comparei);
			}
			else {
				qs(R, 1 + iaddR, iaddR + nnzR - 1, indx_comparei);
			}
		}
		else {
			HeapSort(R, 1 + iaddR, iaddR + nnzR - 1, comparei);
		}


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("first level size n=%lld numberofcoarcenodes=%lld\n", n, numberofcoarcenodes);
#else
			printf("first level size n=%d numberofcoarcenodes=%d\n", n, numberofcoarcenodes);
#endif
			
		}

		// Корректировка диагонали restriction
		if (0) {
			// убрано 2 января 2015 года.
			// Убирание этого сомнительного шага дало сокращение 
			// времени счтёта для 1M неизвестных с 51с(131 итерация) до 42с (91 итерации).
			// на задаче tgf2023_01 включение данного шага приводит к расходимости вычислительного процесса.

			if (debug_reshime) system("pause");
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				flag[i_1] = false; // init flag.
			}

			for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
				if (flag[R[i_1].i] == false)
				{
					for (integer i_2 = i_1; (i_2 <= iaddR + nnzR - 1) && (R[i_2].i == R[i_1].i); i_2++) {
						if ((R[i_1].i<1) || (R[i_1].i>numberofcoarcenodes)) {
#if doubleintprecision == 1
							printf("error R[%lld].i=%lld\n", i_1, R[i_1].i);
#else
							printf("error R[%d].i=%d\n", i_1, R[i_1].i);
#endif
							
							system("pause");
						}
						if (fabs(ap_coarse[R[i_1].i]) < divisionZERO) {
							printf("error division by zero\n");
							system("pause");
						}
						doublerealT delitel;
						if (ap_coarse[R[i_1].i] > 1.0) {
							// internal node
							delitel = 0.5*ap_coarse[R[i_1].i];
						}
						else {
							// Dirichlet
							delitel = ap_coarse[R[i_1].i];
						}
						R[i_2].aij = R[i_2].aij / (delitel);
					}
					flag[R[i_1].i] = true;
				}
			}
		}

		//delete[] ap_coarse;
		free(ap_coarse);





		// Сортировка А по j.
		//heapsort(Amat, key=j*n_a[ilevel - 1] + i, 1, nnz_a[ilevel - 1]);

		// Лишний код потомучто потом сразу же следует сортировка по i.
		/*
		// 7 января 2016. закомментировано.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sortj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
			else {
				qsj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
		}
		else {
			HeapSort_j(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/


		// Нахождение матрицы грубосеточного уровня:
		// Acorse=R*Afine*P;
		// часть 1: R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", nnzR, nnz_a[ilevel - 1]);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", nnzR, nnz_a[ilevel - 1]);
#endif
			
		}

		integer istartAnew;


		// Фред Густавсон IBM 1978.
		// 23 октября 2015 года.

		// часть 1: R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]
		// Сортировка А по строкам.
		/*
		// 7 января 2016. Сортировка матрицы А была выполнена единожды при начале обработке данного уровня.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
			else {
				qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
		}
		else {
			HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/
		// Преобразование к формату CRS.

		integer* row_ind_SR = nullptr;
		//row_ind_SR = new integer[numberofcoarcenodes + 1];
		row_ind_SR = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_SR, "row_ind_SR", "classic_aglomerative_amg_2", (numberofcoarcenodes + 1));
		
		integer* row_ind_ER = nullptr;
		//row_ind_ER = new integer[numberofcoarcenodes + 1];
		row_ind_ER = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_ER, "row_ind_ER", "classic_aglomerative_amg_2", (numberofcoarcenodes + 1));
		
		for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			row_ind_SR[i_1] = -1;
			row_ind_ER[i_1] = -2;
		}
		integer istart1 = 1 + iaddR;
		integer iend1 = nnzR - 1 + iaddR;
		for (integer i = 1; i <= icounter - 1; i++) {
			flag[i] = false;
		}
		for (integer ii = istart1; ii <= iend1; ii++) {
			if (flag[R[ii].i] == false) {
				integer istr = R[ii].i;
				integer ic = ii;
				integer kf = ic;

				while ((kf <= iend1) && (R[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_SR[istr] = ic;
				row_ind_ER[istr] = kf;
				flag[R[ii].i] = true;
			}
		}

		// Пустые строки просто отсутствуют.
		//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
		//if (row_ind_SR[i_1] == -1) {
#if doubleintprecision == 1
		//printf("empty string %lld\n", row_ind_ER[i_1]);
#else
		//printf("empty string %d\n", row_ind_ER[i_1]);
#endif
		
		//}
		//}

		integer* row_ind_SA = nullptr;
		//row_ind_SA = new integer[n_a[ilevel - 1] + 1];
		row_ind_SA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_SA, "row_ind_SA", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		integer* row_ind_EA = nullptr;
		//	row_ind_EA = new integer[n_a[ilevel - 1] + 1];
		row_ind_EA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_EA, "row_ind_EA", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		integer istart3 = 1 + iadd;
		integer iend3 = nnz_a[ilevel - 1] + iadd;
		for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
			flag[i] = false;
		}
		for (integer ii = istart3; ii <= iend3; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer kf = ic;

				while ((kf <= iend3) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_SA[istr] = ic;
				row_ind_EA[istr] = kf;
				flag[Amat[ii].i] = true;
			}
		}

		istartAnew = nnz_a[ilevel - 1] + 1 + iadd;

		// Данные используемые для частичного формирователя суммы.
		doublerealT* vector_sum = nullptr;
		//vector_sum = new doublerealT[n_a[ilevel - 1] + 1];
		vector_sum = (doublerealT*)malloc((n_a[ilevel - 1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		//bool* b_visit_vec_sum = new bool[n_a[ilevel - 1] + 1];
		//integer size_v = sizeof(doublerealT)*(1 + n_a[ilevel - 1]);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		integer* index_visit = nullptr;
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		integer index_size = 0;

		


		// Сканируем первый операнд построчно.
		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Начинаем обрабатывать новую строку.
			// Сброс формирователя суммы в ноль.
			//#pragma omp parallel for
			//for (integer i_2 = 1; i_2 <= n_a[ilevel - 1]; i_2++) {
			//vector_sum[i_2] = 0.0; // инициализация // 18.5
			//b_visit_vec_sum[i_2] = false;
			//}
			// Более быстрое обнуление
			// По времени в лучшем случае также. Но может сильно ухудшиться из-за занятости системной dll-ки.
			//memset(vector_sum, 0,size_v );

			node_AVL_Gus* root_Gus = 0;

#if 0
			if (0) {

				// линейный поиск очень медленный на больших размерностях.

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else if (0) {

				// закомментировано т.к. это медленная ветвь кода.
				// Ситуация такая. Ранее на небольших задачах до 1М включительно,
				// данная ветвь кода не показывала выигрыша в быстродействии и возможно 
				// даже была слегка медленее (совсем немного). 
				// Это быстрая часть кода на больших размерностях.
				// Гораздо лучше линейного поиска. Сейчас это подтверждается
				// на непрямой интерполяции при задаче в 3.2М неизвестных.
				// Там на линейный поиск в данном месте тратится не менее 80% фазы построения грубосеточных операторов.

				// На основе АВЛ
				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							root_Gus = insert_Gus(root_Gus, iaddind);
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else
#endif
			{

				// на основе hash таблицы. 

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						//foundnow = isfound_Gus(root_Gus, iaddind);
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							//root_Gus = insert_Gus(root_Gus, iaddind);
							hash_table[iaddind] = true;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}

			
			doublerealT maxth = -1.0;
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];
				hash_table[jstr] = false; // инициализируем hash таблицу для следующих проходов.
				if (istr != jstr) {
					// 14 января 2016.
					// Правильнее определить величину барьера только по внедиагональным элементам.
					if (fabs(vector_sum[jstr]) > maxth) maxth = vector_sum[jstr];
				}
			}

			/*
			if (nsizeA > istartAnew + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					if (istr != jstr) {
						// 5 декабря 2015. threshold.
						//if (fabs(vector_sum[jstr]) > 1.0e-30) {
						if (fabs(vector_sum[jstr]) > barjer*maxth) {
							Amat[istartAnew].aij = vector_sum[jstr];
							Amat[istartAnew].i = istr;
							Amat[istartAnew].j = jstr;
							istartAnew++;
						}
					}
					else {
						// диагональный элемент записываем обязательно.
						Amat[istartAnew].aij = vector_sum[jstr];
						Amat[istartAnew].i = istr;
						Amat[istartAnew].j = jstr;
						istartAnew++;
					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем
			// проверками.
			doublerealT barjer_maxth = barjer*maxth;
			doublerealT mbarjer_maxth = -barjer_maxth;
			if (nsizeA > istartAnew + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					
					doublerealT vs1 = vector_sum[jstr];
					if ((vs1 < mbarjer_maxth) || (vs1 > barjer_maxth)) {
							//Amat[istartAnew].aij = vs1;
							//Amat[istartAnew].i = istr;
							//Amat[istartAnew].j = jstr;
							//istartAnew++;

							Ak1 Atemp;
							Atemp.aij = vs1;
							Atemp.i = istr;
							Atemp.j = jstr;
							Amat[istartAnew++] = Atemp;

						}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			index_size = 0; // Сброс индикатора, строка обработана.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

		}



		//delete[] index_visit;
		//delete[] row_ind_SR;
		//delete[] row_ind_ER;
		//delete[] row_ind_SA;
		//delete[] row_ind_EA;
		//delete[] vector_sum;

		free(index_visit);
		free(row_ind_SR);
		free(row_ind_ER);
		free(row_ind_SA);
		free(row_ind_EA);
		free(vector_sum);


		// Сортировка А по i (оригинала.).
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);

		/*
		// Лишняя сортировка до этого уже была выполнена сортировка по i.
		// 7 января 2016.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
			else {
				qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
		}
		else
		{
			HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/


		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
			//if (Amat[i_1].j < 0) {
			//	printf("error: negativ j index\n");
			//	system("pause");
			//}
#if doubleintprecision == 1
			//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
			//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
			
			//system("pause");
		//}



		// Часть 2. [R*Afine]*P=Abuf*P.
		// Сортировка [R*А] по i.
		//heapsort(Amat, key=i*n_coarce + j, 1, nnz_a[ilevel - 1]);

		// В результате работы алгоритма разреженного матричного умножения по Густавсону,
		// мы и так имеем отсортированный по строкам результат, поэтому дополнительная 
		// сортировка не требуется. Это проверено 11 января 2016.
		// 11 января 2016.
		/*
		if (bqs) {
			// Обязательно нужна сортировка.
			if (bCounting_Sort) {
				Counting_Sort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
			}
			else {
				qs(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
			}
		}
		else {
			HeapSort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		*/



		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
			//if (Amat[i_1].j < 0) {
			//	printf("error: negativ j index\n");
			//	system("pause");
			//}
#if doubleintprecision == 1
			//-->	//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
			//-->	//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
			
			//system("pause");
		//}




		/*
        // 10 января 2016. Данная сортировка не требуется.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1);
			}
			else {
				qs(P, 1 + iaddR, iaddR + nnzR - 1);
			}
		}
		else {
			HeapSort(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		*/


		// Prolongation должна быть упорядочена по j.
		// Начальная позиция элементов матрицы грубосеточного уровня.
		integer istartAnew2 = istartAnew;



		// Быстрее этого кода на основе идеи слияния списков уже не будет.
		// 17 октября 2015. Нужно двигаться в сторону Писсанецки.
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#endif
			
		}



		// Фред Густавсон IBM 1978
		// В ядре кода Густавсона нету ни одного ветвления,
		// а мы знаем что в результате профайлинга предыдущих версий кода:
		// (наивный, слияние, Писсанецки) львиная доля вычислительной работы уходила
		// на сравнения (ветвления) в отношении примерно 30 к 1. 30 сравнений на одно суммирование.
		// 23 октября 2015 года.
		// 6 января 2016 года Добавлено АВЛ дерево.


		// Рабочая версия алгоритма Фреда Густавсона.
		// IBM 1978 Sparse Matrix multiplication.

		// Сортировка обязательно требуется.
		// Преобразование обоих матриц в формат CRS.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
			}
			else {
				qs(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
			}
		}
		else {
			HeapSort(P, 1 + iaddR, iaddR + nnzR - 1, comparej);
		}

		integer* row_ind_AS = nullptr;
		//row_ind_AS = new integer[numberofcoarcenodes + 1];
		row_ind_AS = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_AS, "row_ind_AS", "classic_aglomerative_amg_2", (numberofcoarcenodes + 1));
		
		integer* row_ind_AE = nullptr;
		//row_ind_AE = new integer[numberofcoarcenodes + 1];
		row_ind_AE = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_AE, "row_ind_AE", "classic_aglomerative_amg_2", (numberofcoarcenodes + 1));
		
		integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
		integer iend2 = istartAnew - 1;
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = istart2; ii <= iend2; ii++) {
			if (flag[Amat[ii].i] == false) {
				// сканируем построчно.
				integer istr = Amat[ii].i;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend2) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_AS[istr] = ic;
				row_ind_AE[istr] = kf;
				flag[Amat[ii].i] = true;

			}
		}

		integer* row_ind_PS = nullptr;
		//row_ind_PS = new integer[n_a[ilevel - 1] + 1];
		row_ind_PS = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_PS, "row_ind_PS", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		integer* row_ind_PE = nullptr;
		//row_ind_PE = new integer[n_a[ilevel - 1] + 1];
		row_ind_PE = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_PE, "row_ind_PE", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));

		
		// Инициализация чрезвычайно важна, т.к. 
		// обязательно присутствуют пустые строки которые
		// надо корректно обрабатывать.
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			row_ind_PS[ii] = -1; // инициализация.
			row_ind_PE[ii] = -2;
		}
		integer istart4 = 1 + iaddR;
		integer iend4 = nnzR - 1 + iaddR;
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = istart4; ii <= iend4; ii++) {
			if (flag[P[ii].j] == false) {
				// сканируем построчно.
				integer istr = P[ii].j;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend4) && (P[kf].j == istr)) {
					kf++;
				}
				kf--;
				row_ind_PS[istr] = ic;
				row_ind_PE[istr] = kf;
				flag[P[ii].j] = true;

			}
		}

		// Данный код подтверждает что обязательно присутствуют
		// пустые строки.
		//for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
		//if (row_ind_PS[ii] == -1) {
#if doubleintprecision == 1
		//printf("propusk string %lld\n", row_ind_PE[ii]);
#else
		//printf("propusk string %d\n", row_ind_PE[ii]);
#endif
		
		//getchar();
		//}
		//}

		// Накопитель результата.
		//vector_sum = new doublerealT[numberofcoarcenodes + 1];
		vector_sum = (doublerealT*)malloc((numberofcoarcenodes + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_2", (numberofcoarcenodes + 1));
		
		//integer size_v = sizeof(doublerealT)*(1 + numberofcoarcenodes);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		index_visit[0] = 0;
		index_size = 0;

		// Мы будем сканировать левый операнд построчно, а
		// после окончания обработки одной строки левого операнда
		// получать готовую строку результата.

		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Переход к новой строке, сброс накопителя результата.
			//#pragma omp parallel for
			//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			//vector_sum[i_1] = 0.0; // обнуление.
			//}
			// хоть профайлер и показывает что на memset тратиться меньше процессорного времени,
			// но там возникает системный вызов на который тратиться столько же времени что и раньше.
			// работа перекочевала из одного места в другое.
			// Более быстрое обнуление.
			//memset(vector_sum, 0, size_v);

			node_AVL_Gus* root_Gus = 0;

#if 0
			if (0) {
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику:
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else if (0) {

				// На основе АВЛ дерева.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							//if (index_visit[i_6] == iaddind) {
								//foundnow = true;
								//ifoundind = i_6;
								//break;
							//}
						//}

						// Бинарный поиск в АВЛ дереве.
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							root_Gus = insert_Gus(root_Gus, iaddind);

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику:
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else 
#endif 
{

				// На основе hash таблицы.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						// Бинарный поиск в АВЛ дереве.
						//foundnow = isfound_Gus(root_Gus, iaddind);
						// мгновенный поиск за O(1).
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							//root_Gus = insert_Gus(root_Gus, iaddind);
							// Мгновенная вставка в hash table за O(1).
							hash_table[iaddind] = true;

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику:
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			

			doublerealT maxth = -1.0;
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];
				hash_table[jstr] = false; // initialization hash.
				if (istr != jstr) {
					// 14 января 2016 года.
					// Правильно определить барьер только по внедиагональным элементам.
					if (fabs(vector_sum[jstr]) > maxth) maxth = vector_sum[jstr];
				}
			}
			
			/*
			if (nsizeA > istartAnew2 + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					// 15 декабря 2015.
					// Если не принять специальных мер элементы не будут упорядочены
					// и двоичным поиском воспользоваться нельзя.
					//if (index_visit[i_6] < index_visit[i_6 - 1]) {
					//printf("Gipotesa uporqdochennosti in Fred Gustavson neverna\n");
					//system("pause");
					//}

					integer jstr = index_visit[i_6];
					if (istr != jstr) {
						// 5 декабря 2015 года. Сохранение разреженности.
						//if (fabs(vector_sum[jstr]) > 1.0e-30) {
						if (fabs(vector_sum[jstr]) > barjerA*maxth) {
							Amat[istartAnew2].aij = vector_sum[jstr];
							Amat[istartAnew2].i = istr;
							Amat[istartAnew2].j = jstr;
							istartAnew2++;
						}
					}
					else {
						Amat[istartAnew2].aij = vector_sum[jstr];
						Amat[istartAnew2].i = istr;
						Amat[istartAnew2].j = jstr;
						istartAnew2++;
					}
				}
			}			
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем проверками.
			doublerealT barjerA_maxth = barjerA*maxth;
			doublerealT mbarjerA_maxth = -barjerA_maxth;
			if (nsizeA > istartAnew2 + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {

					integer jstr = index_visit[i_6];
					doublerealT vs1 = vector_sum[jstr];
					if ((vs1 < mbarjerA_maxth) || (vs1 > barjerA_maxth)) {
						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = istr;
						Atemp.j = jstr;

						//Amat[istartAnew2].aij = vs1;
						//Amat[istartAnew2].i = istr;
						//Amat[istartAnew2].j = jstr;
						//istartAnew2++;

						Amat[istartAnew2++] = Atemp;

					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			index_size = 0;
			// Освобождение памяти из под АВЛ дерева.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;
		}

		//delete[] vector_sum;
		//delete[] index_visit;
		free(vector_sum);
		free(index_visit);


		//delete[] row_ind_AS;
		//delete[] row_ind_AE;
		//delete[] row_ind_PS;
		//delete[] row_ind_PE;
		free(row_ind_AS);
		free(row_ind_AE);
		free(row_ind_PS);
		free(row_ind_PE);




		// Есть подозрение что это избыточный код и его не надо вызывать.
		// 13  декабря 2015.
		// Это полностью подтвердилось 13 декабря 2015 года.
		/*

		if (bqs)
		{
		if (bCounting_Sort) {
		Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else
		{
		// Быстрая сортировка Хоара.
		qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}

		*/

		// Копируем матрицу А следующего уровня влево вплотную к матице первоначального уровня.
		//integer icounter3 = 1;
		integer nsize = istartAnew2 - (istartAnew);
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd, i_2 = 1; i_2 <= nsize; i_1++, i_2++) {
			integer i_right_position = istartAnew - 1 + i_2;
			Amat[i_1] = Amat[i_right_position];
		}

		if (bprint_mesage_diagnostic) {
			printf("Prolongation is construct.\n");
			// Общее количество узлов не являющихся соседемя, но не С соседями 
#if doubleintprecision == 1
			printf("Error interpolation is count %lld\n", ipromah);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic ipromah_one=%lld iz nih kol-vo beznadechnjh %lld\n", ipromah_one, ipromah_oneF);
#else
			printf("Error interpolation is count %d\n", ipromah);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic ipromah_one=%d iz nih kol-vo beznadechnjh %d\n", ipromah_one, ipromah_oneF);
#endif
			
			//system("pause");
		}
		if (debug_reshime) system("pause");
		

		//delete[] C_numerate;
		free(C_numerate);

		nnz_aRP[ilevel - 1] = nnzR - 1;
		iaddR += nnzR - 1;
		n_a[ilevel] = icounter - 1;
		nnz_a[ilevel] = nsize;
		iadd += nnz_a[ilevel - 1];


		ilevel++;

		// сортировка А по i.
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		/*

		if (nnz_a[ilevel - 1] < heapsortsizelimit) {
		HeapSort(Amat, n_a[ilevel - 1], 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		Ak1* Aorig = &Amat[1 + iadd];
		MergeSort(Aorig, nnz_a[ilevel - 1]);
		Aorig = nullptr;
		}

		*/

#if doubleintprecision == 1
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%lld ",Amat[i_1].j);
		//}
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#else
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%d ",Amat[i_1].j);
		//}
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#endif
		


		//exit(1);
		if (bprint_mesage_diagnostic) {
			printf("one level construct OK.\n");
		}
		if (debug_reshime) system("pause");


		//printf("export b\n");
		//exporttecplot(b,n);

		//doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

		// restriction
		//restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
		//for (integer ii = 1; ii <= n_a[0]; ii++) {
		//b[ii] = 0.0;
		//}

		/*{
		doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		for (integer ii = 1; ii <= n_a[1]; ii++) {
		test_coarse[ii] = 0.0;
		}

		{
		doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		for (integer ii = 1; ii <= n_a[2]; ii++) {
		test_coarse1[ii] = 0.0;
		}

		prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		}

		prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		}
		*/
		//prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

		//exporttecplot(b, n);
		// proverka start
		// на сетке 81х81 проверка успешно проходится.

		/*
		printf("proverka start\n");
		// первый уровень вложенности.
		if (ilevel > 1) {
			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}

			for (integer ii77 = nnz_a[0] + 1; ii77 <= nnz_a[0] + nnz_a[1]; ii77++) {
				if (flag[Amat[ii77].i] == false) {
					integer istr77 = Amat[ii77].i;
					integer ic77 = ii77;
					//integer icdiag = ii77;
					doublerealT ap = 0.0;
					//x[istr] = b[istr];
					while ((ic77 <= nnz_a[0] + nnz_a[1]) && (Amat[ic77].i == istr77)) {
						if (Amat[ic77].j != istr77) {
							//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
						}
						else {
							ap = Amat[ic77].aij;
							//icdiag = ic77;
						}
						ic77++;
					}
					if (fabs(ap) < RealZERO) {
					#if doubleintprecision == 1
						printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr77);
					#else
						printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr77);
					#endif
						
						system("PAUSE");
						//exit(1);
					}

					flag[Amat[ii77].i] = true;

				}
			}
		}
		*/

		//проверка конец

		//delete[] count_neighbour;
		free(count_neighbour);
		//delete[] row_startA;
		free(row_startA);

	}// иерархия сеток построена.

	ilevel--;
	if (n_a[ilevel] < 5) {
		// Чтобы не было последних уровней где меньше 5 узлов сетки.
		ilevel--;
	}

	if (bprint_mesage_diagnostic) {
		printf("grid complexity is %1.2f", (((double)(1.0*iadd)) / ((double)(1.0*nnz_a[0]))));
	}

	if (bji) {
		delete[] Atemp;
		Atemp = nullptr;
	}

	// 31.224s [50.986] 2D m=81 debug x64 acumulqtor
	// 13.792 [18.156] 2D m=81 realese x64 acumulqtor
	// 8.028s 2D m=81 debug x64 rozetka
	// 3.827 2D m=81 realese x64 rozetka

	if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
		printf("ilevel=%lld\n", ilevel);
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
		}
#else
		printf("ilevel=%d\n", ilevel);
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
		}
#endif
		
		printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	}
	if (debug_reshime) system("pause");
	//system("pause");
	//exit(1);





	/*
	//exporttecplot(b,n);

	doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

	// restriction
	restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
	for (integer ii = 1; ii <= n_a[0]; ii++) {
	b[ii] = 0.0;
	}

	{
	doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

	// restriction
	restriction(R, 1+nnz_aRP[0], nnz_aRP[0]+nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	for (integer ii = 1; ii <= n_a[1]; ii++) {
	test_coarse[ii] = 0.0;
	}

	{
	doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

	// restriction
	restriction(R, 1 + nnz_aRP[0]+nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1]+nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	for (integer ii = 1; ii <= n_a[2]; ii++) {
	test_coarse1[ii] = 0.0;
	}

	prolongation(P, 1 + nnz_aRP[0]+ nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	}

	prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	}

	prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

	exporttecplot(b, n);
	*/

	// подготовка матрицы к cycling:
	/*
	// smoother.
	// 1 september 2015.
	void seidel(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
	{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	doublerealT ap = 0.0;
	x[istr] = b[istr];
	while ((ic<=iend)&&(Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else ap = Amat[ic].aij;
	ic++;
	}
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld",istr);
	#else
		printf("zero diagonal elements in string %d",istr);
	#endif
	
	getchar();
	exit(1);
	}
	else {
	x[istr] /= ap;
	}
	flag[Amat[ii].i] = true;
	}
	}


	} // seidel
	

	*/

	/*
	// Т.к. деление очень медленное то мы поделим лишь один раз.
	doublerealT *diag0 = new doublerealT[n_a[0] + 1];
	doublerealT *diag1=nullptr;
	if (ilevel > 1) {
		diag1 = new doublerealT[n_a[1] + 1];
	}
	doublerealT *diag2=nullptr;
	if (ilevel > 2) {
		diag2 = new doublerealT[n_a[2] + 1];
	}
	doublerealT *diag3 = nullptr;
	if (ilevel > 3) {
		diag3 = new doublerealT[n_a[3] + 1];
	}
	doublerealT *diag4 = nullptr;
	if (ilevel > 4) {
		diag4 = new doublerealT[n_a[4] + 1];
	}
	doublerealT *diag5 = nullptr;
	if (ilevel > 5) {
		diag5 = new doublerealT[n_a[5] + 1];
	}
	doublerealT *diag6 = nullptr;
	if (ilevel > 6) {
		diag6 = new doublerealT[n_a[6] + 1];
	}
	doublerealT *diag7 = nullptr;
	if (ilevel > 7) {
		diag7 = new doublerealT[n_a[7] + 1];
	}
	doublerealT *diag8 = nullptr;
	if (ilevel > 8) {
		diag8 = new doublerealT[n_a[8] + 1];
	}
	*/

     // Т.к. деление очень медленное то мы поделим лишь один раз.
     doublerealT *diag0 = nullptr;
     //diag0 = new doublerealT[n_a[0] + 1];
	 diag0 = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	 handle_error<doublerealT>(diag0, "diag0", "classic_aglomerative_amg_2", (n_a[0] + 1));
	 
     doublerealT *diag1 = nullptr;
     if (ilevel > 1) {
	     //diag1 = new doublerealT[n_a[1] + 1];
		 diag1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		 handle_error<doublerealT>(diag1, "diag1", "classic_aglomerative_amg_2", (n_a[1] + 1));
     }
     doublerealT *diag2 = nullptr;
     if (ilevel > 2) {
	    //diag2 = new doublerealT[n_a[2] + 1];
		diag2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag2, "diag2", "classic_aglomerative_amg_2", (n_a[2] + 1));
     }
     doublerealT *diag3 = nullptr;
     if (ilevel > 3) {
	     //diag3 = new doublerealT[n_a[3] + 1];
		 diag3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
		 handle_error<doublerealT>(diag3, "diag3", "classic_aglomerative_amg_2", (n_a[3] + 1));
     }
     doublerealT *diag4 = nullptr;
     if (ilevel > 4) {
	    //diag4 = new doublerealT[n_a[4] + 1];
		diag4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag4, "diag4", "classic_aglomerative_amg_2", (n_a[4] + 1));
     }
     doublerealT *diag5 = nullptr;
     if (ilevel > 5) {
	    //diag5 = new doublerealT[n_a[5] + 1];
		diag5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag5, "diag5", "classic_aglomerative_amg_2", (n_a[5] + 1));
     }
     doublerealT *diag6 = nullptr;
     if (ilevel > 6) {
	    //diag6 = new doublerealT[n_a[6] + 1];
		diag6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag6, "diag6", "classic_aglomerative_amg_2", (n_a[6] + 1));
     }
     doublerealT *diag7 = nullptr;
     if (ilevel > 7) {
    	//diag7 = new doublerealT[n_a[7] + 1];
		diag7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag7, "diag7", "classic_aglomerative_amg_2", (n_a[7] + 1));
     }
     doublerealT *diag8 = nullptr;
     if (ilevel > 8) {
	   // diag8 = new doublerealT[n_a[8] + 1];
		diag8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag8, "diag8", "classic_aglomerative_amg_2", (n_a[8] + 1));
     }

	 bnested_desection_global_amg = nullptr;
	 bool *nested_desection0 = nullptr;
	 bool *nested_desection1 = nullptr;
	 bool *nested_desection2 = nullptr;
	 bool *nested_desection3 = nullptr;
	 bool *nested_desection4 = nullptr;
	 bool *nested_desection5 = nullptr;
	 bool *nested_desection6 = nullptr;
	 bool *nested_desection7 = nullptr;
	 bool *nested_desection8 = nullptr;
	 if (!bonly_serial) {
		 // nested desection start
		 bnested_desection_global_amg = (bool*)malloc((n_a[0] + 1)*sizeof(bool));
		 handle_error<bool>(bnested_desection_global_amg, "bnested_desection_global_amg", "classic_aglomerative_amg_2", (n_a[0] + 1));

		
		 nested_desection0 = (bool*)malloc((n_a[0] + 1)*sizeof(bool));
		 handle_error<bool>(nested_desection0, "nested_desection0", "classic_aglomerative_amg_2", (n_a[0] + 1));
		
		
		 if (ilevel > 1) {
			 nested_desection1 = (bool*)malloc((n_a[1] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection1, "nested_desection1", "classic_aglomerative_amg_2", (n_a[1] + 1));
		 }
		
		 if (ilevel > 2) {
			 nested_desection2 = (bool*)malloc((n_a[2] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection2, "nested_desection2", "classic_aglomerative_amg_2", (n_a[2] + 1));
		 }
		 
		 if (ilevel > 3) {
			 nested_desection3 = (bool*)malloc((n_a[3] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection3, "nested_desection3", "classic_aglomerative_amg_2", (n_a[3] + 1));
		 }
		
		 if (ilevel > 4) {
			 nested_desection4 = (bool*)malloc((n_a[4] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection4, "nested_desection4", "classic_aglomerative_amg_2", (n_a[4] + 1));
		 }
		 
		 if (ilevel > 5) {
			 nested_desection5 = (bool*)malloc((n_a[5] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection5, "nested_desection5", "classic_aglomerative_amg_2", (n_a[5] + 1));
		 }
		 
		 if (ilevel > 6) {
			 nested_desection6 = (bool*)malloc((n_a[6] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection6, "nested_desection6", "classic_aglomerative_amg_2", (n_a[6] + 1));
		 }
		 
		 if (ilevel > 7) {
			 nested_desection7 = (bool*)malloc((n_a[7] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection7, "nested_desection7", "classic_aglomerative_amg_2", (n_a[7] + 1));
		 }
		 
		 if (ilevel > 8) {
			 nested_desection8 = (bool*)malloc((n_a[8] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection8, "nested_desection8", "classic_aglomerative_amg_2", (n_a[8] + 1));
		 }
	 }
	 // nested_desection_end

	 integer *row_ptr_start = nullptr;
	//row_ptr_start = new integer[4 * n_a[0] + 1];
	 row_ptr_start = (integer*)malloc((4 * n_a[0] + 1)*sizeof(integer));
	 handle_error<integer>(row_ptr_start, " row_ptr_start", "classic_aglomerative_amg_2", (4 * n_a[0] + 1));
	
	integer *row_ptr_end = nullptr;
	//row_ptr_end = new integer[4 * n_a[0] + 1];
	row_ptr_end = (integer*)malloc((4 * n_a[0] + 1)*sizeof(integer));
	handle_error<integer>(row_ptr_end, " row_ptr_end", "classic_aglomerative_amg_2", (4 * n_a[0] + 1));
	
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = 1; ii <= nnz_a[0]; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			integer icdiag = ii;
			row_ptr_start[istr] = ii;
			doublerealT ap = 0.0; // значение на диагонали.
			//x[istr] = b[istr];
			while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else {
					ap = Amat[ic].aij;
					icdiag = ic;
				}
				ic++;
			}
			row_ptr_end[istr] = ic - 1;
			if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld in basic matrix", istr);
#else
				printf("zero diagonal elements in string %d in basic matrix", istr);
#endif
				
				system("PAUSE");
				exit(1);
			}
			else {
				//x[istr] /= ap;
			}

			flag[Amat[ii].i] = true;
			Ak1 temp = Amat[ii];
			Amat[ii] = Amat[icdiag];
			Amat[icdiag] = temp;
			diag0[Amat[ii].i] = ap; // для ускорения вычисления невязки.
			Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
		}
	}

	bool bstop = false;
	// первый уровень вложенности.
	if (ilevel > 1) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}

		for (integer ii = nnz_a[0] + 1; ii <= nnz_a[0] + nnz_a[1]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= nnz_a[0] + nnz_a[1]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr);
#else
					printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr);
#endif
					
					system("PAUSE");
					//exit(1);
					bstop = true;
				}
				else {

					flag[Amat[ii].i] = true;
					Ak1 temp = Amat[ii];
					Amat[ii] = Amat[icdiag];
					Amat[icdiag] = temp;
					diag1[Amat[ii].i] = ap; // для ускорения вычисления невязки.
					Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.

				}


			}
		}
	}

	if (bstop) exit(1);

	// второй уровень вложенности.

	if (ilevel > 2) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = nnz_a[0] + nnz_a[1] + 1; ii <= nnz_a[0] + nnz_a[1] + nnz_a[2]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= nnz_a[0] + nnz_a[1] + nnz_a[2]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 2 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 2 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag2[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// третий уровень вложенности.

	if (ilevel > 3) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = nnz_a[0] + nnz_a[1] + nnz_a[2] + 1; ii <= nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 3 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 3 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag3[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// 14 сентября 2015 понедельник
	// четвёртый уровень вложенности.

	if (ilevel > 4) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 4 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 4 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag4[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// пятый уровень вложенности.

	if (ilevel > 5) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 5 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 5 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag5[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}

	// шестой уровень вложенности.

	if (ilevel > 6) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 6 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 6 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag6[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}

	// седьмой уровень вложенности.

	if (ilevel > 7) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 7 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 7 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag7[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}

	// восьмой уровень вложенности.
	/*
	if (ilevel > 8) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ic - 1;
				if (fabs(ap) < RealZERO) {
				#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 7 matrix", istr);
				#else
					printf("zero diagonal elements in string %d in level 7 matrix", istr);
				#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag8[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}
	*/


	if (!bonly_serial) {
		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 0.
		// nested_desection0
		nested_desection_patch(Amat, n_a[0], nested_desection0, row_ptr_start, row_ptr_end, 0);
		if (bprint_mesage_diagnostic) {
			printf("part1\n");
		}


		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 1.
		// nested_desection1
		nested_desection_patch(Amat, n_a[1], nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
		if (bprint_mesage_diagnostic) {
			printf("part2\n");
		}
		nested_desection_patch(Amat, n_a[2], nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
		if (bprint_mesage_diagnostic) {
			printf("part3\n");
		}
		nested_desection_patch(Amat, n_a[3], nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
		if (bprint_mesage_diagnostic) {
			printf("part4\n");
		}
		nested_desection_patch(Amat, n_a[4], nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
		if (bprint_mesage_diagnostic) {
			printf("part5\n");
		}
		nested_desection_patch(Amat, n_a[5], nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
		if (bprint_mesage_diagnostic) {
			printf("part6\n");
		}
		nested_desection_patch(Amat, n_a[6], nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
		if (bprint_mesage_diagnostic) {
			printf("part7\n");
		}
		nested_desection_patch(Amat, n_a[7], nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
		if (bprint_mesage_diagnostic) {
			printf("part8 \n");
			printf("nested desection is finish\n");
		}

	}
	

	// smoother.
	// 9 september 2015.
	// q - quick.
	// seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
	//void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
	//{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	//integer startpos = istartq + iadd;
	//integer endpos = iendq+iadd;
	//for (integer ii = startpos; ii <= endpos; ii++) {
	//integer istr = ii - iadd;
	//x[istr] = b[istr];
	//for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
	//{
	//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
	//}
	//x[istr] *= Amat[row_ptr_start[ii]].aij;
	//}


	//} // seidelq

	// Освобождение памяти используемой на этапе построения иерархии матриц.

	//delete[] this_is_C_node;
	//delete[] this_is_F_node;
	if (this_is_C_node!=nullptr) {
	   free(this_is_C_node);
	   this_is_C_node=nullptr;
	}
	if (this_is_F_node!=nullptr) {
	   free(this_is_F_node);
       this_is_F_node=nullptr;
	}
	//delete[] hash_table;
	free(hash_table);
	free(hash_table2);
	//delete[] istack;
	//delete[] istack2;
	free(istack);
	free(istack2);


	if (bprint_mesage_diagnostic) {
		printf("cycling: V cycle.\n");
#if doubleintprecision == 1
		printf("level=%lld\n", ilevel);
#else
		printf("level=%d\n", ilevel);
#endif
		
		printf("multigrid R.P.Fedorenko 1961.\n");
		printf("standart aglomerative algebraic multigrid method.\n");
	}
	if (debug_reshime) system("pause");
	//exit(1);

	// 10 11 21 multigrid tutorial Вильм Бригг.
	// Высокорейнольдсовое обтекание квадрата в DavisTest,
	// решатель работал на x-компоненте скорости. Сетка сгущалась
	// к поверхности квадрата достаточно сильно. Это дало расходимость
	// amg v0.08 решателя на данной задаче с параметрами nu1=4, nu2=3.
	// Параметры nu1=8, nu2=7 обеспечили сходимость вычислительного процесса.

	// Возможно имеет смысл сделать управляемый выход из сглаживателя, допустим
	// если невязка опустилась ниже первоначальной в 0.1 раз то имеет смысл досрочно 
	// оборвать итерации сглаживателя.


	// nu1=0; nu2=2; nFinestSweeps=2 is recomended 
	// Masashi Imano. Optimization of parameter setting for GAMG
	// solver in simple solver. 
	// Aug 26th 2012. OpeanFOAM study. 
	// nu1=0 имеем расходимость на BSK Dmitrii.
	// nFinestSweeps=2 имеем расходимость на BSK Dmitrii.
	// BSK Dmitrii сходится при nu1=1, nu2=2, nFinestSweeps=3.

	integer nu1 = 1; // minimum value 1 // 4 // 8
	integer nu2 = 2; // minimum value 2 // 3 // 7

	integer nFinestSweeps = 3;
	// для Finner Heat Sink надо усилить сглаживания.
	// Это не помогает будет перенаправление на другой алгоритм.
	//nu1 = 3;
	//nu2 = 3;
	//nFinestSweeps = 6;


	// Смысл этих параметров в том что они экономят ресурсы процессора
	// в теории осуществляя досрочный выход из пред и пост сглаживаний.
	// Т.е. параметры nu1,nu2 задаются с запасом и алгоритм сам использует
	// сколько ему взять итераций для оптимальной работы (сходимости). 
	// Пользователь не ломает голову какие задавать параметры nu1, nu2 
	// а задаёт их верхние предельные значения. 
	doublerealT process_flow_beta = 0.7;
	doublerealT process_flow_alpha = 0.1;
	bool process_flow_logic = false;

	if (process_flow_logic) {
		nu1 = 40;
		nu2 = 40;
	}

	if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
		printf("nu1=%lld, nu2=%lld\n", nu1, nu2);
#else
		printf("nu1=%d, nu2=%d\n", nu1, nu2);
#endif
		
	}

	//ilevel = 1; //debug
	doublerealT rho = 1.0;
	doublerealT dres = 1.0;
	integer iiter = 1;
	//const doublerealT tolerance = 1.0e-12;
	// 13 февраля 2016 калибруем точность солвера с целью ускорения получения результата.
	// Т.к. нам ненужна точность выше чем десятая доля градуса по температуре.
	// начальное значение невязки составляет примерно 7000.0.
	const doublerealT tolerance = 0.003; // точность выхода по классическому определению L2 нормы.


	doublerealT *residual_fine =nullptr;
	//residual_fine = new doublerealT[n_a[0] + 1];
	doublerealT *residual_coarse = nullptr;
	doublerealT* error_approx_coarse = nullptr;
	doublerealT *residual_fine1 = nullptr;
	doublerealT *residual_coarse1 = nullptr;
	doublerealT* error_approx_coarse1 = nullptr;
	doublerealT *error_approx_fine1 = nullptr;
	doublerealT *residual_fine2 = nullptr;
	doublerealT *residual_coarse2 = nullptr;
	doublerealT* error_approx_coarse2 = nullptr;
	doublerealT *error_approx_fine2 = nullptr;
	doublerealT *residual_fine3 = nullptr;
	doublerealT *residual_coarse3 = nullptr;
	doublerealT* error_approx_coarse3 = nullptr;
	doublerealT *error_approx_fine3 = nullptr;
	doublerealT *residual_fine4 = nullptr;
	doublerealT *residual_coarse4 = nullptr;
	doublerealT *error_approx_coarse4 = nullptr;
	doublerealT *error_approx_fine4 = nullptr;
	doublerealT *residual_fine5 = nullptr;
	doublerealT *residual_coarse5 = nullptr;
	doublerealT* error_approx_coarse5 = nullptr;
	doublerealT *error_approx_fine5 = nullptr;
	doublerealT *residual_fine6 = nullptr;
	doublerealT *residual_coarse6 = nullptr;
	doublerealT* error_approx_coarse6 = nullptr;
	doublerealT *error_approx_fine6 = nullptr;
	doublerealT *residual_fine7 = nullptr;
	doublerealT *residual_coarse7 = nullptr;
	doublerealT* error_approx_coarse7 = nullptr;
	doublerealT *error_approx_fine7 = nullptr;
	doublerealT *residual_fine8 = nullptr;
	doublerealT *residual_coarse8 = nullptr;
	doublerealT* error_approx_coarse8 = nullptr;
	doublerealT *error_approx_fine8 = nullptr;
	doublerealT *residual_fine9 = nullptr;
	doublerealT *residual_coarse9 = nullptr;
	doublerealT* error_approx_coarse9 = nullptr;
	doublerealT *error_approx_fine9 = nullptr;
	doublerealT *residual_fine10 = nullptr;
	doublerealT *residual_coarse10 = nullptr;
	doublerealT* error_approx_coarse10 = nullptr;
	doublerealT *error_approx_fine10 = nullptr;
	doublerealT *residual_fine11 = nullptr;
	doublerealT *residual_coarse11 = nullptr;
	doublerealT* error_approx_coarse11 = nullptr;
	doublerealT *error_approx_fine11 = nullptr;
	doublerealT *residual_fine12 = nullptr;
	doublerealT *residual_coarse12 = nullptr;
	doublerealT* error_approx_coarse12 = nullptr;
	doublerealT *error_approx_fine12 = nullptr;
	doublerealT *residual_fine13 = nullptr;
	doublerealT *residual_coarse13 = nullptr;
	doublerealT* error_approx_coarse13 = nullptr;
	doublerealT *error_approx_fine13 = nullptr;
	doublerealT *residual_fine14 = nullptr;
	doublerealT *residual_coarse14 = nullptr;
	doublerealT* error_approx_coarse14 = nullptr;
	doublerealT *error_approx_fine14 = nullptr;
	doublerealT *residual_fine15 = nullptr;
	doublerealT *residual_coarse15 = nullptr;
	doublerealT* error_approx_coarse15 = nullptr;
	doublerealT *error_approx_fine15 = nullptr;
	doublerealT *residual_fine16 = nullptr;
	doublerealT *residual_coarse16 = nullptr;
	doublerealT* error_approx_coarse16 = nullptr;
	doublerealT *error_approx_fine16 = nullptr;
	doublerealT *residual_fine17 = nullptr;
	doublerealT *residual_coarse17 = nullptr;
	doublerealT* error_approx_coarse17 = nullptr;
	doublerealT *error_approx_fine17 = nullptr;

	/*
	residual_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	if (residual_fine == nullptr) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem: not enough memory on your equipment for residual_fine in classic_aglomerative_amg2 my_agregat_amg...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	if (ilevel > 1) {
		residual_coarse = new doublerealT[n_a[1] + 1];
		error_approx_coarse = new doublerealT[n_a[1] + 1];
		if (ilevel > 2) {
			// residual
			residual_fine1 = new doublerealT[n_a[1] + 1];
			residual_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_fine1 = new doublerealT[n_a[1] + 1];
			if (ilevel > 3) {
				// residual
				residual_fine2 = new doublerealT[n_a[2] + 1];
				residual_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_fine2 = new doublerealT[n_a[2] + 1];
				if (ilevel > 4) {
					// residual
					residual_fine3 = new doublerealT[n_a[3] + 1];
					residual_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_fine3 = new doublerealT[n_a[3] + 1];
					if (ilevel > 5) {
						// residual
						residual_fine4 = new doublerealT[n_a[4] + 1];
						residual_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_fine4 = new doublerealT[n_a[4] + 1];
						if (ilevel > 6) {
							// residual
							residual_fine5 = new doublerealT[n_a[5] + 1];
							residual_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_fine5 = new doublerealT[n_a[5] + 1];
							if (ilevel > 7) {
								// residual
								residual_fine6 = new doublerealT[n_a[6] + 1];
								residual_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_fine6 = new doublerealT[n_a[6] + 1];
								if (ilevel > 8) {
									// residual
									residual_fine7 = new doublerealT[n_a[7] + 1];
									residual_coarse7 = new doublerealT[n_a[8] + 1];
									error_approx_coarse7 = new doublerealT[n_a[8] + 1];
									error_approx_fine7 = new doublerealT[n_a[7] + 1];
									if (ilevel > 9) {
										// residual
										residual_fine8 = new doublerealT[n_a[8] + 1];
										residual_coarse8 = new doublerealT[n_a[9] + 1];
										error_approx_coarse8 = new doublerealT[n_a[9] + 1];
										error_approx_fine8 = new doublerealT[n_a[8] + 1];
										if (ilevel > 10) {
											// residual
											residual_fine9 = new doublerealT[n_a[9] + 1];
											residual_coarse9 = new doublerealT[n_a[10] + 1];
											error_approx_coarse9 = new doublerealT[n_a[10] + 1];
											error_approx_fine9 = new doublerealT[n_a[9] + 1];
											if (ilevel > 11) {
												// residual
												residual_fine10 = new doublerealT[n_a[10] + 1];
												residual_coarse10 = new doublerealT[n_a[11] + 1];
												error_approx_coarse10 = new doublerealT[n_a[11] + 1];
												error_approx_fine10 = new doublerealT[n_a[10] + 1];
												if (ilevel > 12) {
													// residual
													residual_fine11 = new doublerealT[n_a[11] + 1];
													residual_coarse11 = new doublerealT[n_a[12] + 1];
													error_approx_coarse11 = new doublerealT[n_a[12] + 1];
													error_approx_fine11 = new doublerealT[n_a[11] + 1];
													if (ilevel > 13) {
														// residual
														residual_fine12 = new doublerealT[n_a[12] + 1];
														residual_coarse12 = new doublerealT[n_a[13] + 1];
														error_approx_coarse12 = new doublerealT[n_a[13] + 1];
														error_approx_fine12 = new doublerealT[n_a[12] + 1];
														if (ilevel > 14) {
															// residual
															residual_fine13 = new doublerealT[n_a[13] + 1];
															residual_coarse13 = new doublerealT[n_a[14] + 1];
															error_approx_coarse13 = new doublerealT[n_a[14] + 1];
															error_approx_fine13 = new doublerealT[n_a[13] + 1];
															if (ilevel > 15) {
																// residual
																residual_fine14 = new doublerealT[n_a[14] + 1];
																residual_coarse14 = new doublerealT[n_a[15] + 1];
																error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																error_approx_fine14 = new doublerealT[n_a[14] + 1];
																if (ilevel > 16) {
																	// residual
																	residual_fine15 = new doublerealT[n_a[15] + 1];
																	residual_coarse15 = new doublerealT[n_a[16] + 1];
																	error_approx_coarse15 = new doublerealT[n_a[16] + 1];
																	error_approx_fine15 = new doublerealT[n_a[15] + 1];
																	if (ilevel > 17) {
																		// residual
																		residual_fine16 = new doublerealT[n_a[16] + 1];
																		residual_coarse16 = new doublerealT[n_a[17] + 1];
																		error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																		error_approx_fine16 = new doublerealT[n_a[16] + 1];
																		if (ilevel > 18) {
																			// residual
																			residual_fine17 = new doublerealT[n_a[17] + 1];
																			residual_coarse17 = new doublerealT[n_a[18] + 1];
																			error_approx_coarse17 = new doublerealT[n_a[18] + 1];
																			error_approx_fine17 = new doublerealT[n_a[17] + 1];

																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
	*/

// лучше выделять оперативную память небольшими блоками т.к.
// оперативная память фрагментирована системными dll и
// большого свободного блока может не найтись.


residual_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
handle_error<doublerealT>(residual_fine, "residual_fine", "classic_aglomerative_amg_2", (n_a[0] + 1));

if (ilevel > 1) {
	//residual_coarse = new doublerealT[n_a[1] + 1];
	residual_coarse = (doublerealT*)malloc((n_a[1]+1)*sizeof(doublerealT));
	handle_error<doublerealT>(residual_coarse, "residual_coarse", "classic_aglomerative_amg_2", (n_a[1] + 1));
	
	//error_approx_coarse = new doublerealT[n_a[1] + 1];
	error_approx_coarse = (doublerealT*)malloc((n_a[1]+1)*sizeof(doublerealT));
	handle_error<doublerealT>(error_approx_coarse, "error_approx_coarse", "classic_aglomerative_amg_2", (n_a[1] + 1));
	
	if (ilevel > 2) {
		// residual
		//residual_fine1 = new doublerealT[n_a[1] + 1];
		residual_fine1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(residual_fine1, "residual_fine1", "classic_aglomerative_amg_2", (n_a[1] + 1));
		
		//residual_coarse1 = new doublerealT[n_a[2] + 1];
		residual_coarse1 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(residual_coarse1, "residual_coarse1", "classic_aglomerative_amg_2", (n_a[2] + 1));
		
		//error_approx_coarse1 = new doublerealT[n_a[2] + 1];
		error_approx_coarse1 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(error_approx_coarse1, "error_approx_coarse1", "classic_aglomerative_amg_2", (n_a[2] + 1));
		
		//error_approx_fine1 = new doublerealT[n_a[1] + 1];
		error_approx_fine1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(error_approx_fine1, "error_approx_fine1", "classic_aglomerative_amg_2", (n_a[1] + 1));
		
		if (ilevel > 3) {
			// residual
			//residual_fine2 = new doublerealT[n_a[2] + 1];
			residual_fine2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(residual_fine2, "residual_fine2", "classic_aglomerative_amg_2", (n_a[2] + 1));
			
			//residual_coarse2 = new doublerealT[n_a[3] + 1];
			residual_coarse2 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(residual_coarse2, "residual_coarse2", "classic_aglomerative_amg_2", (n_a[3] + 1));
			
			//error_approx_coarse2 = new doublerealT[n_a[3] + 1];
			error_approx_coarse2 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_coarse2, "error_approx_coarse2", "classic_aglomerative_amg_2", (n_a[3] + 1));
			
			//error_approx_fine2 = new doublerealT[n_a[2] + 1];
			error_approx_fine2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_fine2, "error_approx_fine2", "classic_aglomerative_amg_2", (n_a[2] + 1));
			
			if (ilevel > 4) {
				// residual
				//residual_fine3 = new doublerealT[n_a[3] + 1];
				residual_fine3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(residual_fine3, "residual_fine3", "classic_aglomerative_amg_2", (n_a[3] + 1));
				
				//residual_coarse3 = new doublerealT[n_a[4] + 1];
				residual_coarse3 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(residual_coarse3, "residual_coarse3", "classic_aglomerative_amg_2", (n_a[4] + 1));
				
				//error_approx_coarse3 = new doublerealT[n_a[4] + 1];
				error_approx_coarse3 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(error_approx_coarse3, "error_approx_coarse3", "classic_aglomerative_amg_2", (n_a[4] + 1));
				
				//error_approx_fine3 = new doublerealT[n_a[3] + 1];
				error_approx_fine3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(error_approx_fine3, "error_approx_fine3", "classic_aglomerative_amg_2", (n_a[3] + 1));
				
				if (ilevel > 5) {
					// residual
					//residual_fine4 = new doublerealT[n_a[4] + 1];
					residual_fine4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(residual_fine4, "residual_fine4", "classic_aglomerative_amg_2", (n_a[4] + 1));
					
					//residual_coarse4 = new doublerealT[n_a[5] + 1];
					residual_coarse4 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(residual_coarse4, "residual_coarse4", "classic_aglomerative_amg_2", (n_a[5] + 1));
					
					//error_approx_coarse4 = new doublerealT[n_a[5] + 1];
					error_approx_coarse4 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(error_approx_coarse4, "error_approx_coarse4", "classic_aglomerative_amg_2", (n_a[5] + 1));
					
					//error_approx_fine4 = new doublerealT[n_a[4] + 1];
					error_approx_fine4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(error_approx_fine4, "error_approx_fine4", "classic_aglomerative_amg_2", (n_a[4] + 1));
					
					if (ilevel > 6) {
						// residual
						//residual_fine5 = new doublerealT[n_a[5] + 1];
						residual_fine5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(residual_fine5, "residual_fine5", "classic_aglomerative_amg_2", (n_a[5] + 1));
						
						//residual_coarse5 = new doublerealT[n_a[6] + 1];
						residual_coarse5 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(residual_coarse5, "residual_coarse5", "classic_aglomerative_amg_2", (n_a[6] + 1));
						
						//error_approx_coarse5 = new doublerealT[n_a[6] + 1];
						error_approx_coarse5 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(error_approx_coarse5, "error_approx_coarse5", "classic_aglomerative_amg_2", (n_a[6] + 1));
						
						//error_approx_fine5 = new doublerealT[n_a[5] + 1];
						error_approx_fine5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(error_approx_fine5, "error_approx_fine5", "classic_aglomerative_amg_2", (n_a[5] + 1));
						
						if (ilevel > 7) {
							// residual
							//residual_fine6 = new doublerealT[n_a[6] + 1];
							residual_fine6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(residual_fine6, "residual_fine6", "classic_aglomerative_amg_2", (n_a[6] + 1));
							
							//residual_coarse6 = new doublerealT[n_a[7] + 1];
							residual_coarse6 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(residual_coarse6, "residual_coarse6", "classic_aglomerative_amg_2", (n_a[7] + 1));
							
							//error_approx_coarse6 = new doublerealT[n_a[7] + 1];
							error_approx_coarse6 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(error_approx_coarse6, "error_approx_coarse6", "classic_aglomerative_amg_2", (n_a[7] + 1));
							
							//error_approx_fine6 = new doublerealT[n_a[6] + 1];
							error_approx_fine6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(error_approx_fine6, "error_approx_fine6", "classic_aglomerative_amg_2", (n_a[6] + 1));
							
							if (ilevel > 8) {
								// residual
								//residual_fine7 = new doublerealT[n_a[7] + 1];
								residual_fine7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(residual_fine7, "residual_fine7", "classic_aglomerative_amg_2", (n_a[7] + 1));
								
								//residual_coarse7 = new doublerealT[n_a[8] + 1];
								residual_coarse7 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(residual_coarse7, "residual_coarse7", "classic_aglomerative_amg_2", (n_a[8] + 1));
								
								//error_approx_coarse7 = new doublerealT[n_a[8] + 1];
								error_approx_coarse7 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(error_approx_coarse7, "error_approx_coarse7", "classic_aglomerative_amg_2", (n_a[8] + 1));
								
								//error_approx_fine7 = new doublerealT[n_a[7] + 1];
								error_approx_fine7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(error_approx_fine7, "error_approx_fine7", "classic_aglomerative_amg_2", (n_a[7] + 1));
								
								if (ilevel > 9) {
									// residual
									//residual_fine8 = new doublerealT[n_a[8] + 1];
									residual_fine8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(residual_fine8, "residual_fine8", "classic_aglomerative_amg_2", (n_a[8] + 1));
									
									//residual_coarse8 = new doublerealT[n_a[9] + 1];
									residual_coarse8 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(residual_coarse8, "residual_coarse8", "classic_aglomerative_amg_2", (n_a[9] + 1));
									
									//error_approx_coarse8 = new doublerealT[n_a[9] + 1];
									error_approx_coarse8 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(error_approx_coarse8, "error_approx_coarse8", "classic_aglomerative_amg_2", (n_a[9] + 1));
									
									//error_approx_fine8 = new doublerealT[n_a[8] + 1];
									error_approx_fine8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(error_approx_fine8, "error_approx_fine8", "classic_aglomerative_amg_2", (n_a[8] + 1));
									
									if (ilevel > 10) {
										// residual
										//residual_fine9 = new doublerealT[n_a[9] + 1];
										residual_fine9 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(residual_fine9, "residual_fine9", "classic_aglomerative_amg_2", (n_a[9] + 1));
										
										//residual_coarse9 = new doublerealT[n_a[10] + 1];
										residual_coarse9 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(residual_coarse9, "residual_coarse9", "classic_aglomerative_amg_2", (n_a[10] + 1));
										
										//error_approx_coarse9 = new doublerealT[n_a[10] + 1];
										error_approx_coarse9 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(error_approx_coarse9, "error_approx_coarse9", "classic_aglomerative_amg_2", (n_a[10] + 1));
										
										//error_approx_fine9 = new doublerealT[n_a[9] + 1];
										error_approx_fine9 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(error_approx_fine9, "error_approx_fine9", "classic_aglomerative_amg_2", (n_a[9] + 1));
										
										if (ilevel > 11) {
											// residual
											//residual_fine10 = new doublerealT[n_a[10] + 1];
											residual_fine10 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(residual_fine10, "residual_fine10", "classic_aglomerative_amg_2", (n_a[10] + 1));
											
											//residual_coarse10 = new doublerealT[n_a[11] + 1];
											residual_coarse10 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(residual_coarse10, "residual_coarse10", "classic_aglomerative_amg_2", (n_a[11] + 1));
											
											//error_approx_coarse10 = new doublerealT[n_a[11] + 1];
											error_approx_coarse10 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(error_approx_coarse10, "error_approx_coarse10", "classic_aglomerative_amg_2", (n_a[11] + 1));
											
											//error_approx_fine10 = new doublerealT[n_a[10] + 1];
											error_approx_fine10 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(error_approx_fine10, "error_approx_fine10", "classic_aglomerative_amg_2", (n_a[10] + 1));
											
											if (ilevel > 12) {
												// residual
												//residual_fine11 = new doublerealT[n_a[11] + 1];
												residual_fine11 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(residual_fine11, "residual_fine11", "classic_aglomerative_amg_2", (n_a[11] + 1));
												
												//residual_coarse11 = new doublerealT[n_a[12] + 1];
												residual_coarse11 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(residual_coarse11, "residual_coarse11", "classic_aglomerative_amg_2", (n_a[12] + 1));
												
												//error_approx_coarse11 = new doublerealT[n_a[12] + 1];
												error_approx_coarse11 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(error_approx_coarse11, "error_approx_coarse11", "classic_aglomerative_amg_2", (n_a[12] + 1));
												
												//error_approx_fine11 = new doublerealT[n_a[11] + 1];
												error_approx_fine11 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(error_approx_fine11, "error_approx_fine11", "classic_aglomerative_amg_2", (n_a[11] + 1));
												
												if (ilevel > 13) {
													// residual
													//residual_fine12 = new doublerealT[n_a[12] + 1];
													residual_fine12 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(residual_fine12, "residual_fine12", "classic_aglomerative_amg_2", (n_a[12] + 1));
													
													//residual_coarse12 = new doublerealT[n_a[13] + 1];
													residual_coarse12 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(residual_coarse12, "residual_coarse12", "classic_aglomerative_amg_2", (n_a[13] + 1));
													
													//error_approx_coarse12 = new doublerealT[n_a[13] + 1];
													error_approx_coarse12 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(error_approx_coarse12, "error_approx_coarse12", "classic_aglomerative_amg_2", (n_a[13] + 1));
													
													//error_approx_fine12 = new doublerealT[n_a[12] + 1];
													error_approx_fine12 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(error_approx_fine12, "error_approx_fine12", "classic_aglomerative_amg_2", (n_a[12] + 1));
													
													if (ilevel > 14) {
														// residual
														//residual_fine13 = new doublerealT[n_a[13] + 1];
														residual_fine13 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(residual_fine13, "residual_fine13", "classic_aglomerative_amg_2", (n_a[13] + 1));
														
														//residual_coarse13 = new doublerealT[n_a[14] + 1];
														residual_coarse13 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(residual_coarse13, "residual_coarse13", "classic_aglomerative_amg_2", (n_a[14] + 1));
														
														//error_approx_coarse13 = new doublerealT[n_a[14] + 1];
														error_approx_coarse13 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(error_approx_coarse13, "error_approx_coarse13", "classic_aglomerative_amg_2", (n_a[14] + 1));
														
														//error_approx_fine13 = new doublerealT[n_a[13] + 1];
														error_approx_fine13 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(error_approx_fine13, "error_approx_fine13", "classic_aglomerative_amg_2", (n_a[13] + 1));
														
														if (ilevel > 15) {
															// residual
															//residual_fine14 = new doublerealT[n_a[14] + 1];
															residual_fine14 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(residual_fine14, "residual_fine14", "classic_aglomerative_amg_2", (n_a[14] + 1));
															
															//residual_coarse14 = new doublerealT[n_a[15] + 1];
															residual_coarse14 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(residual_coarse14, "residual_coarse14", "classic_aglomerative_amg_2", (n_a[15] + 1));
															
															//error_approx_coarse14 = new doublerealT[n_a[15] + 1];
															error_approx_coarse14 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(error_approx_coarse14, "error_approx_coarse14", "classic_aglomerative_amg_2", (n_a[15] + 1));
															
															//error_approx_fine14 = new doublerealT[n_a[14] + 1];
															error_approx_fine14 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(error_approx_fine14, "error_approx_fine14", "classic_aglomerative_amg_2", (n_a[14] + 1));
															
															if (ilevel > 16) {
																// residual
																//residual_fine15 = new doublerealT[n_a[15] + 1];
																residual_fine15 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(residual_fine15, "residual_fine15", "classic_aglomerative_amg_2", (n_a[15] + 1));
																
																//residual_coarse15 = new doublerealT[n_a[16] + 1];
																residual_coarse15 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(residual_coarse15, "residual_coarse15", "classic_aglomerative_amg_2", (n_a[16] + 1));
																
																//error_approx_coarse15 = new doublerealT[n_a[16] + 1];
																error_approx_coarse15 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(error_approx_coarse15, "error_approx_coarse15", "classic_aglomerative_amg_2", (n_a[16] + 1));
																
																//error_approx_fine15 = new doublerealT[n_a[15] + 1];
																error_approx_fine15 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(error_approx_fine15, "error_approx_fine15", "classic_aglomerative_amg_2", (n_a[15] + 1));
																
																if (ilevel > 17) {
																	// residual
																	//residual_fine16 = new doublerealT[n_a[16] + 1];
																	residual_fine16 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(residual_fine16, "residual_fine16", "classic_aglomerative_amg_2", (n_a[16] + 1));
																	
																	//residual_coarse16 = new doublerealT[n_a[17] + 1];
																	residual_coarse16 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(residual_coarse16, "residual_coarse16", "classic_aglomerative_amg_2", (n_a[17] + 1));
																
																	//error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																	error_approx_coarse16 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(error_approx_coarse16, "error_approx_coarse16", "classic_aglomerative_amg_2", (n_a[17] + 1));
																	
																	//error_approx_fine16 = new doublerealT[n_a[16] + 1];
																	error_approx_fine16 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(error_approx_fine16, "error_approx_fine16", "classic_aglomerative_amg_2", (n_a[16] + 1));
																	
																	if (ilevel > 18) {
																		// residual
																		//residual_fine17 = new doublerealT[n_a[17] + 1];
																		residual_fine17 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(residual_fine17, "residual_fine17", "classic_aglomerative_amg_2", (n_a[17] + 1));
																		
																		//residual_coarse17 = new doublerealT[n_a[18] + 1];
																		residual_coarse17 = (doublerealT*)malloc((n_a[18] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(residual_coarse17, "residual_coarse17", "classic_aglomerative_amg_2", (n_a[18] + 1));
																		
																		//error_approx_coarse17 = new doublerealT[n_a[18] + 1];
																		error_approx_coarse17 = (doublerealT*)malloc((n_a[18] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(error_approx_coarse17, "error_approx_coarse17", "classic_aglomerative_amg_2", (n_a[18] + 1));
																		
																		//error_approx_fine17 = new doublerealT[n_a[17] + 1];
																		error_approx_fine17 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(error_approx_fine17, "error_approx_fine17", "classic_aglomerative_amg_2", (n_a[17] + 1));
																		

																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
doublerealT *error_approx_fine = nullptr;
//error_approx_fine = new doublerealT[n_a[0] + 1];
error_approx_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
handle_error<doublerealT>(error_approx_fine, "error_approx_fine", "classic_aglomerative_amg_2", (n_a[0] + 1));



	// 2 jan 2016. 
	integer igam = 1; // 1-V; 2-W
	// надо увеличивать nu1, nu2 с 1,2 до 5 наверно.
	//INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14 imyinit =  ZERO_INIT; // ZERO_INIT optimum

	doublerealT* x_copy = nullptr;
	x_copy = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(x_copy, "x_copy", "classic_aglomerative_amg_2", (n_a[0] + 1));

	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_copy[i47] = x[i47];
	}

	doublerealT* x_best_search = nullptr;
	x_best_search = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(x_best_search, "x_best_search", "classic_aglomerative_amg_2", (n_a[0] + 1));

	doublerealT res_best_search = 1e40;
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search[i47] = x[i47];
	}


	// Для поправки давления возникает задача когда на всех границах стоит условие Неймана,
	// это приводит к тому что метод работает бесконечно долго и не может сойтись, поэтому нужно 
	// заложить критерий останова по превышению количества допустимых итераций (не более 1000 итераций).
	// 1000 итераций это очень долго поэтому для поправки давления надо подобрать разумное количество 
	// итераций т.к. от этого существенным образом зависит быстродействие гидродинамического алгоритма.
	integer iter_limit = 0;
	integer istop_porog_reconst = 50;

	bool ret_value = false;
	doublerealT dres_previos = 1.0e36;
	integer icount_bad_convergence_Vcycles = 0;
	integer i_count_stagnation = 0;
	doublerealT res0start = 1.0e-36;
	bool bfirst_divergence = true;

	//for (integer iprohod = 0; iprohod < 20; iprohod++) {
	while (dres>tolerance) {

		if (iter_limit == 1) {
			// начальная невязка.
			res0start = fabs(dres);
		}
		
		if (fabs(dres) < res_best_search)
		{
			// Запоминаем лучшую попытку.
			res_best_search = fabs(dres);
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x_best_search[i47] = x[i47];
			}
		}

		if (iter_limit > 2000) { // Finner Heat Sink
			if (bfirst_divergence) {
				iter_limit = 3;
				nu1 += 2;
				nu2 += 2;
				nFinestSweeps+=2;
				bfirst_divergence = false;
			}
			else {
				if ((fabs(res_best_search / res0start) < 0.23) && (fabs(res_best_search) < 1.0e-3)) {
					// Если невязка меньше первоначальной на два порядка.
					// Обратное копирование и выход и алгоритма.
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				else if ((fabs(res_best_search / res0start) <= 1.0) && (fabs(res_best_search) < 1.0e-4)) {
					// Если невязка меньше первоначальной на два порядка.
					// Обратное копирование и выход и алгоритма.
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				// Обратное копирование и выход и алгоритма.
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = x_best_search[i47];
				}
				break;
				// закомментировал 11.01.2020
				// как недостижимый код.
				// Эта ветвь кода вообще никогда не вызовется.
				/*
				printf("Fatal amg error: Strong divergence amg solver...%e \n", fabs(res_best_search / res0start));
				printf("res_best_search=%e, res0start=%e\n", fabs(res_best_search), fabs(res0start));
				printf("BiCGStab+ILU2 is start now...\n");
				printf("please wait...");
				system("pause");
				break; // досрочный выход из while цикла.
				*/
			}
		}
		iter_limit++;

		if (fabs(dres) < fabs(dres_previos)) {
			// все нормально процесс сходится.
			icount_bad_convergence_Vcycles = 0;
		}
		else {
			icount_bad_convergence_Vcycles++;
		}

		//if (_finite(dres) == 0) {
		//if (fabs(dres) > 1.0e30)
		//{
			//printf("\ndivergence AMG detected...solver will be restart... please wait... ... ...\n");
			//printf("\a\a\a\a\a\a\a\a");
			//system("pause");
			//exit(1);
			//return true;
			//for (integer i47 = 1; i47 <= n_a[0]; i47++) {
			//	x[i47] = x_copy[i47];
			//}
			//if (iter_limit > 100) {
			//	ret_value = true;
			//	break;
			//}
			//else {
		    // Увеличение количества сглаживающих итераций ни коим образом не 
		    // исправляет факт расходимости. 
			//	nu1++;
			//	nu2++;
			//	nFinestSweeps++;
		    // По видимому надо действовать очень тонкой настройкой параметра верхней релаксации omega optimal.
		    // Настройка omega optimal должна быть самообучающейся (адаптированной к задаче).
			//}
		//}
		if ((icount_bad_convergence_Vcycles >= istop_porog_reconst) || (fabs(dres) > 1.0e30)) {
			// детектировано 10 шагов расходимости подряд по-видимому метод расходится.
			// Также о расходимости говорит невязка большая 1.0e30.

			//if (fabs(dres) < 1.0e-3) break; // Будем считать сходимость достигнута успешно.
			if ((fabs(res_best_search / res0start) < 1.0e-1) && (fabs(dres) < 1.0e-3)) {
				// Если невязка меньше первоначальной на два порядка.
				// Обратное копирование и выход и алгоритма.
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = x_best_search[i47];
				}
				break;
			}
			i_count_stagnation++;

			printf("\ndivergence AMG detected...solver will be restart... please wait... ... ...\n");
			//printf("\a\a\a\a\a\a\a\a");
			//system("pause");
			//exit(1);
			//return true;
			if (i_count_stagnation < 20) {
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					//x[i47] = x_copy[i47];
					x[i47] = x_best_search[i47]; // лучшее найденное решение
				}
			}
			if (i_count_stagnation == 20 || i_count_stagnation == 21) gold_const = 0.2;
			if ((i_count_stagnation >= 20) && (i_count_stagnation < 30)) {
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					//x[i47] = x_copy[i47];
					// Можно еще единократно немного улучшить nu1 и nu2.
					doublerealT signumnow = 1.0;
					if (rand() % 2 == 0) signumnow = -1.0;
					x[i47] = signumnow *1.0*(rand() % 90 + 10) / 100.0; // Случайное число в интервале от 0 до 1.
				}
			}
			if (i_count_stagnation == 30 || i_count_stagnation == 31) gold_const = 0.2;
			if (i_count_stagnation >= 30) {
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = 1.0;
				}
			}
			if (bproblem_amg_convergence1) {
				if (bproblem_amg_convergence2) {
					if (bproblem_amg_convergence3) {
						// выход к вызову BiCGStab+ILU2.
						ret_value = true;
						break;
					}
					else {
						// смена omega.
						bproblem_amg_convergence3 = true;
						icount_bad_convergence_Vcycles = 0;
						buffers3omega = dres / dres_previos;
						printf("buffers1omega=%1.4f, buffers2omega=%1.4f, buffers3omega=%1.4f\n", buffers1omega, buffers2omega, buffers3omega);
					}
				}
				else {
					// смена omega.
					bproblem_amg_convergence2 = true;
					icount_bad_convergence_Vcycles = 0;
					buffers2omega = dres / dres_previos;
					printf("buffers1omega=%1.4f, buffers2omega=%1.4f\n", buffers1omega, buffers2omega);
					//istop_porog_reconst += 50; // 10, 20, 30, 40
					// Увеличение количества сглаживающих итераций ничего не даёт.
					//nu1++;
					//nu2++;
					//nFinestSweeps++;
				}
			}
			else {
				
				bproblem_amg_convergence1 = true; // переход с SOR на стабильный Зейдель.
				icount_bad_convergence_Vcycles = 0;
				buffers1omega = dres / dres_previos;
			}
		}

		dres_previos = dres;


		doublerealT R0_0 = 0.0;
		doublerealT Rprev_0=0.0, Rnext_0=0.0;
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine,diag0);
			R0_0 = norma(residual_fine, n_a[0]);
			Rprev_0 = R0_0;
			
			// smother
			integer iter = 0;
			for (iter = 0; iter < nFinestSweeps; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
				//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
				residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine,diag0);
				Rnext_0 = norma(residual_fine, n_a[0]);
				// this is process flow logic
				if (Rnext_0 > process_flow_beta*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nu1) {
				printf("level 0 limit presmother iteration is reached\n");
			}

		}
		else {
			// smother
			for (integer iter = 0; iter < nFinestSweeps; iter++) {
				//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
			}
		}

		//exporttecplot(x, n);

		move_down(nu1, nu2);

		if (!process_flow_logic) {
			// residual_r
			//doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
			//residual(Amat, 1, nnz_a[0], x, b, flag, n_a[0], residual_fine);
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine,diag0);
		}
		dres = norma(residual_fine, n_a[0]);
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("%lld %e rho=%e\n", iiter, dres, dres / rho);
#else
			printf("%d %e rho=%e\n", iiter, dres, dres / rho);
#endif
			
		}
		iiter++;
		//rho=norma(residual_fine, n_a[0]);
		rho = dres;
		
		//if (iprohod%5==0) getchar();
		if (ilevel > 1) {

			//doublerealT *residual_coarse = new doublerealT[n_a[1] + 1];

			// restriction
			restriction(R, 1, nnz_aRP[0], flag, residual_fine, residual_coarse, n_a[0], n_a[1]);

			// Amat*e=r;
			//doublerealT* error_approx_coarse = new doublerealT[n_a[1] + 1];
			if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] = 0.0;
				}
			}
			
			if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] = (rand()/((doublerealT)RAND_MAX));
				}
			}


			for (integer i_37 = 1; i_37 <= igam; i_37++) {
			doublerealT R0_1 = 0.0;
			doublerealT Rprev_1 = 0.0, Rnext_1 = 0.0;
			if (process_flow_logic) {
				// calculate initial residual.
				//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
				residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1,diag1);

				R0_1 = norma(residual_fine1, n_a[1]);
				Rprev_1 = R0_1;

				// smother
				integer iter = 0;
				for (iter = 0; iter < nu1; iter++) {
					//quick seidel
					if (bonly_serial) {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
					}
					else {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
					}

					//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
					residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1,diag1);

					Rnext_1 = norma(residual_fine1, n_a[1]);
					// this is process flow logic
					if (Rnext_1 > process_flow_beta*Rprev_1) {
						// Смысл модификации в том что мы экономим итерации на пресмутере.
						break; // досрочно опускаемся на следующий уровень если он есть конечно.
					}
					else {
						Rprev_1 = Rnext_1;
					}
				}

				if (iter == nu1) {
					printf("level 1 limit presmother iteration is reached\n");
				}

			}
			else {

				// pre smothing
				for (integer iter = 0; iter < nu1; iter++) {
					//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
					if (bonly_serial) {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
					}
					else {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
					}
				}
			}

			move_down(nu1, nu2);

			
			if (ilevel > 2) {
				// residual
				if (!process_flow_logic) {
					//doublerealT *residual_fine1 = new doublerealT[n_a[1] + 1];
					//residual(Amat, 1+2*nnz_a[0], 2*nnz_a[0]+nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1], residual_fine1);
					//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
					residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1,diag1);
					//residualqspeshial(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
				}

				//doublerealT *residual_coarse1 = new doublerealT[n_a[2] + 1];

				// restriction
				restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, residual_fine1, residual_coarse1, n_a[1], n_a[2]);

				// Amat*e=r;
				//doublerealT* error_approx_coarse1 = new doublerealT[n_a[2] + 1];
				if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] = 0.0;
					}
				}
				if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] = (rand() / ((doublerealT)RAND_MAX));
					}
				}

				//for (integer i_37 = 1; i_37 <= igam; i_37++)
				{
				doublerealT R0_2 = 0.0;
				doublerealT Rprev_2 = 0.0, Rnext_2 = 0.0;
				if (process_flow_logic) {
					// calculate initial residual.
					//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
					residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2,diag2);

					R0_2 = norma(residual_fine2, n_a[2]);
					Rprev_2 = R0_2;

					// smother
					integer iter = 0;
					for (iter = 0; iter < nu1; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}
						else {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}

						//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2,diag2);

						Rnext_2 = norma(residual_fine2, n_a[2]);
						// this is process flow logic
						if (Rnext_2 > process_flow_beta*Rprev_2) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_2 = Rnext_2;
						}
					}

					if (iter == nu1) {
						printf("level 2 limit presmother iteration is reached\n");
					}

				}
				else {

					// pre smothing
					for (integer iter = 0; iter < nu1; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}
						else {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}
					}

				}

				move_down(nu1, nu2);
				
				if (ilevel > 3) {
					// residual
					if (!process_flow_logic) {
						//doublerealT *residual_fine2 = new doublerealT[n_a[2] + 1];
						//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2], residual_fine2);
						//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2,diag2);
						//residualqspeshial(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
					}

					//doublerealT *residual_coarse2 = new doublerealT[n_a[3] + 1];

					// restriction
					restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, residual_fine2, residual_coarse2, n_a[2], n_a[3]);

					// Amat*e=r;
					//doublerealT* error_approx_coarse2 = new doublerealT[n_a[3] + 1];
					if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] = 0.0;
						}
					}
					if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] = (rand() / ((doublerealT)RAND_MAX));
						}
					}
					//for (integer i_37 = 1; i_37 <= igam; i_37++)
					{
					doublerealT R0_3 = 0.0;
					doublerealT Rprev_3 = 0.0, Rnext_3 = 0.0;
					if (process_flow_logic) {
						// calculate initial residual.
						//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
						residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3,diag3);


						R0_3 = norma(residual_fine3, n_a[3]);
						Rprev_3 = R0_3;

						// smother
						integer iter = 0;
						for (iter = 0; iter < nu1; iter++) {
							//quick seidel
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
							else {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
							//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
							residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3,diag3);


							Rnext_3 = norma(residual_fine3, n_a[3]);
							// this is process flow logic
							if (Rnext_3 > process_flow_beta*Rprev_3) {
								// Смысл модификации в том что мы экономим итерации на пресмутере.
								break; // досрочно опускаемся на следующий уровень если он есть конечно.
							}
							else {
								Rprev_3 = Rnext_3;
							}
						}

						if (iter == nu1) {
							printf("level 3 limit presmother iteration is reached\n");
						}

					}
					else {
						// pre smothing
						for (integer iter = 0; iter < nu1; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
							else {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
						}
					}


					move_down(nu1, nu2);

					
					if (ilevel > 4) {
						// residual
						if (!process_flow_logic) {
							//doublerealT *residual_fine3 = new doublerealT[n_a[3] + 1];
							//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3], residual_fine3);
							//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
							residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3,diag3);

							//speshial
							//residualqspeshial(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
						}


						//doublerealT *residual_coarse3 = new doublerealT[n_a[4] + 1];

						// restriction
						restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, residual_fine3, residual_coarse3, n_a[3], n_a[4]);

						// Amat*e=r;
						//doublerealT* error_approx_coarse3 = new doublerealT[n_a[4] + 1];
						if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] = 0.0;
							}
						}
						if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] = (rand() / ((doublerealT)RAND_MAX));
							}
						}

						//for (integer i_37 = 1; i_37 <= igam; i_37++) 
						{
						doublerealT R0_4 = 0.0;
						doublerealT Rprev_4 = 0.0, Rnext_4 = 0.0;
						if (process_flow_logic) {
							// calculate initial residual.
							//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
							residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4,diag4);


							R0_4 = norma(residual_fine4, n_a[4]);
							Rprev_4 = R0_4;

							// smother
							integer iter = 0;
							for (iter = 0; iter < nu1; iter++) {
								//quick seidel
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}
								else {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}

								//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
								residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4,diag4);


								Rnext_4 = norma(residual_fine4, n_a[4]);
								// this is process flow logic
								if (Rnext_4 > process_flow_beta*Rprev_4) {
									// Смысл модификации в том что мы экономим итерации на пресмутере.
									break; // досрочно опускаемся на следующий уровень если он есть конечно.
								}
								else {
									Rprev_4 = Rnext_4;
								}
							}

							if (iter == nu1) {
								printf("level 4 limit presmother iteration is reached\n");
							}

						}
						else {
							// pre smothing
							for (integer iter = 0; iter < nu1; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}
								else {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}
							}
						}


						move_down(nu1, nu2);
						
						if (ilevel > 5) {
							// residual
							if (!process_flow_logic) {
								//doublerealT *residual_fine4 = new doublerealT[n_a[4] + 1];
								//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4], residual_fine4);
								//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
								residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4,diag4);

								//speshial 14 september 2015.
								//residualqspeshial(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
							}


							//doublerealT *residual_coarse4 = new doublerealT[n_a[5] + 1];

							// restriction
							restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, residual_fine4, residual_coarse4, n_a[4], n_a[5]);

							// Amat*e=r;
							//doublerealT* error_approx_coarse4 = new doublerealT[n_a[5] + 1];
							if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
								for (integer ii = 1; ii <= n_a[5]; ii++) {
									error_approx_coarse4[ii] = 0.0;
								}
							}
							if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
								for (integer ii = 1; ii <= n_a[5]; ii++) {
									error_approx_coarse4[ii] = (rand() / ((doublerealT)RAND_MAX));
								}
							}

							// pre smothing
							//for (integer i_37 = 1; i_37 <= igam; i_37++)
							{
							doublerealT R0_5 = 0.0;
							doublerealT Rprev_5 = 0.0, Rnext_5 = 0.0;
							if (process_flow_logic) {
								// calculate initial residual.
								//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
								residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5,diag5);



								R0_5 = norma(residual_fine5, n_a[5]);
								Rprev_5 = R0_5;

								// smother
								integer iter = 0;
								for (iter = 0; iter < nu1; iter++) {
									//quick seidel
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}
									else {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}

									//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
									residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5,diag5);


									Rnext_5 = norma(residual_fine5, n_a[5]);
									// this is process flow logic
									if (Rnext_5 > process_flow_beta*Rprev_5) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_5 = Rnext_5;
									}
								}

								if (iter == nu1) {
									printf("level 5 limit presmother iteration is reached\n");
								}

							}
							else {
								for (integer iter = 0; iter < nu1; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}
									else {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}
								}
							}


							move_down(nu1, nu2);
							
								if (ilevel > 6) {
									// residual
									if (!process_flow_logic) {
										//doublerealT *residual_fine5 = new doublerealT[n_a[5] + 1];
										//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5], residual_fine5);
										//if (ilevel <= 15) {
										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5,diag5);

										//}
										//else {
										// приводит к расходимости.
										//speshial 14 september 2015.
										// это уже приводит к увеличению числа итераций на примере сетки в 1млн узлов. остановимся.
										//residualqspeshial(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										//}
									}

									//doublerealT *residual_coarse5 = new doublerealT[n_a[6] + 1];

									// restriction
									restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, residual_fine5, residual_coarse5, n_a[5], n_a[6]);

									// Amat*e=r;
									//doublerealT* error_approx_coarse5 = new doublerealT[n_a[6] + 1];
									if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
										for (integer ii = 1; ii <= n_a[6]; ii++) {
											error_approx_coarse5[ii] = 0.0;
										}
									}
									if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
										for (integer ii = 1; ii <= n_a[6]; ii++) {
											error_approx_coarse5[ii] = (rand() / ((doublerealT)RAND_MAX));
										}
									}

									//for (integer i_37 = 1; i_37 <= igam; i_37++) 
									{
										// pre smothing

										doublerealT R0_6 = 0.0;
										doublerealT Rprev_6 = 0.0, Rnext_6 = 0.0;
										if (process_flow_logic) {
											// calculate initial residual.
											//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
											residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6,diag6);



											R0_6 = norma(residual_fine6, n_a[6]);
											Rprev_6 = R0_6;

											// smother
											integer iter = 0;
											for (iter = 0; iter < nu1; iter++) {
												//quick seidel
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}

												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6,diag6);


												Rnext_6 = norma(residual_fine6, n_a[6]);
												// this is process flow logic
												if (Rnext_6 > process_flow_beta*Rprev_6) {
													// Смысл модификации в том что мы экономим итерации на пресмутере.
													break; // досрочно опускаемся на следующий уровень если он есть конечно.
												}
												else {
													Rprev_6 = Rnext_6;
												}
											}

											if (iter == nu1) {
												printf("level 6 limit presmother iteration is reached\n");
											}

										}
										else {
											for (integer iter = 0; iter < nu1; iter++) {
												//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
											}
										}


										move_down(nu1, nu2);

										if (ilevel > 7) {
											// residual
											if (!process_flow_logic) {
												//doublerealT *residual_fine6 = new doublerealT[n_a[6] + 1];
												//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] +2*nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6], residual_fine6);
												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6,diag6);
											}

											//doublerealT *residual_coarse6 = new doublerealT[n_a[7] + 1];

											// restriction
											restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, residual_fine6, residual_coarse6, n_a[6], n_a[7]);

											// Amat*e=r;
											//doublerealT* error_approx_coarse6 = new doublerealT[n_a[7] + 1];
											if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
												for (integer ii = 1; ii <= n_a[7]; ii++) {
													error_approx_coarse6[ii] = 0.0;
												}
											}
											if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
												for (integer ii = 1; ii <= n_a[7]; ii++) {
													error_approx_coarse6[ii] = (rand() / ((doublerealT)RAND_MAX));
												}
											}

											//for (integer i_37 = 1; i_37 <= igam; i_37++) 
											{

												// pre smothing


												doublerealT R0_7 = 0.0;
												doublerealT Rprev_7 = 0.0, Rnext_7 = 0.0;
												if (process_flow_logic) {
													// calculate initial residual.
													//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
													residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7,diag7);



													R0_7 = norma(residual_fine7, n_a[7]);
													Rprev_7 = R0_7;

													// smother
													integer iter = 0;
													for (iter = 0; iter < nu1; iter++) {
														//quick seidel
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}

														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7,diag7);


														Rnext_7 = norma(residual_fine7, n_a[7]);
														// this is process flow logic
														if (Rnext_7 > process_flow_beta*Rprev_7) {
															// Смысл модификации в том что мы экономим итерации на пресмутере.
															break; // досрочно опускаемся на следующий уровень если он есть конечно.
														}
														else {
															Rprev_7 = Rnext_7;
														}
													}

													if (iter == nu1) {
														printf("level 7 limit presmother iteration is reached\n");
													}

												}
												else {
													for (integer iter = 0; iter < nu1; iter++) {
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
													}
												}


												move_down(nu1, nu2);

												if (ilevel > 8) {
													// residual
													if (!process_flow_logic) {
														//doublerealT *residual_fine7 = new doublerealT[n_a[7] + 1];
														//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7], residual_fine7);
														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7,diag7);

													}


													//doublerealT *residual_coarse7 = new doublerealT[n_a[8] + 1];

													// restriction
													restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, residual_fine7, residual_coarse7, n_a[7], n_a[8]);

													// Amat*e=r;
													//doublerealT* error_approx_coarse7 = new doublerealT[n_a[8] + 1];
													if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
														for (integer ii = 1; ii <= n_a[8]; ii++) {
															error_approx_coarse7[ii] = 0.0;
														}
													}
													if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
														for (integer ii = 1; ii <= n_a[8]; ii++) {
															error_approx_coarse7[ii] = (rand() / ((doublerealT)RAND_MAX));
														}
													}

													//for (integer i_37 = 1; i_37 <= igam; i_37++)
													{
														// pre smothing
														for (integer iter = 0; iter < nu1; iter++) {
															seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
															//nested_desection8 futures

														}


														if (ilevel > 9) {
															// residual
															//doublerealT *residual_fine8 = new doublerealT[n_a[8] + 1];
															integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7];
															integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
															residual(Amat, n1, n2, error_approx_coarse7, residual_coarse7, flag, n_a[8], residual_fine8);


															//doublerealT *residual_coarse8 = new doublerealT[n_a[9] + 1];

															// restriction
															integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
															integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
															restriction(R, n3, n4, flag, residual_fine8, residual_coarse8, n_a[8], n_a[9]);

															// Amat*e=r;
															//doublerealT* error_approx_coarse8 = new doublerealT[n_a[9] + 1];
															if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																for (integer ii = 1; ii <= n_a[9]; ii++) {
																	error_approx_coarse8[ii] = 0.0;
																}
															}
															if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																for (integer ii = 1; ii <= n_a[9]; ii++) {
																	error_approx_coarse8[ii] = (rand() / ((doublerealT)RAND_MAX));
																}
															}

															//for (integer i_37 = 1; i_37 <= igam; i_37++) 
															{
																// pre smothing
																for (integer iter = 0; iter < nu1; iter++) {
																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																	seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
																}

																// точное решение на подробном уровне лишь замедляет время счёта и нисколько не
																// улучшает сходимость.
																


																move_down(nu1, nu2);

																if (ilevel > 10) {
																	// 8 сентября 2015 РИМИНИ пляж 

																	// residual
																	//doublerealT *residual_fine9 = new doublerealT[n_a[9] + 1];
																	integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
																	integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																	residual(Amat, n1, n2, error_approx_coarse8, residual_coarse8, flag, n_a[9], residual_fine9);


																	//doublerealT *residual_coarse9 = new doublerealT[n_a[10] + 1];

																	// restriction
																	integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
																	integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																	restriction(R, n3, n4, flag, residual_fine9, residual_coarse9, n_a[9], n_a[10]);

																	// Amat*e=r;
																	//doublerealT* error_approx_coarse9 = new doublerealT[n_a[10] + 1];


																	if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																		for (integer ii = 1; ii <= n_a[10]; ii++) {
																			error_approx_coarse9[ii] = 0.0;
																		}
																	}
																	if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																		for (integer ii = 1; ii <= n_a[10]; ii++) {
																			error_approx_coarse9[ii] = (rand() / ((doublerealT)RAND_MAX));
																		}
																	}

																	//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																	{
																		// pre smothing
																		for (integer iter = 0; iter < nu1; iter++) {
																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																			seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
																		}

																		// до 11 уровня вроде всё верно 3 января 2016

																		move_down(nu1, nu2);

																		if (ilevel > 11) {
																			// 8 сентября 2015 РИМИНИ пляж 

																			// residual
																			//doublerealT *residual_fine10 = new doublerealT[n_a[10] + 1];
																			integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																			integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																			residual(Amat, n1, n2, error_approx_coarse9, residual_coarse9, flag, n_a[10], residual_fine10);


																			//doublerealT *residual_coarse10 = new doublerealT[n_a[11] + 1];

																			// restriction
																			integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																			integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																			restriction(R, n3, n4, flag, residual_fine10, residual_coarse10, n_a[10], n_a[11]);

																			// Amat*e=r;
																			//doublerealT* error_approx_coarse10 = new doublerealT[n_a[11] + 1];


																			if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																				for (integer ii = 1; ii <= n_a[11]; ii++) {
																					error_approx_coarse10[ii] = 0.0;
																				}
																			}
																			if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																				for (integer ii = 1; ii <= n_a[11]; ii++) {
																					error_approx_coarse10[ii] = (rand() / ((doublerealT)RAND_MAX));
																				}
																			}

																			//for (integer i_37 = 1; i_37 <= igam; i_37++)
																			{
																				// pre smothing
																				for (integer iter = 0; iter < nu1; iter++) {
																					integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																					integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																					seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
																				}

																				move_down(nu1, nu2);

																				if (ilevel > 12) {
																					// 11 сентября 2015 РИМИНИ пляж 

																					// residual
																					//doublerealT *residual_fine11 = new doublerealT[n_a[11] + 1];
																					integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																					integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																					residual(Amat, n1, n2, error_approx_coarse10, residual_coarse10, flag, n_a[11], residual_fine11);


																					//doublerealT *residual_coarse11 = new doublerealT[n_a[12] + 1];

																					// restriction
																					integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																					integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																					restriction(R, n3, n4, flag, residual_fine11, residual_coarse11, n_a[11], n_a[12]);

																					// Amat*e=r;
																					//doublerealT* error_approx_coarse11 = new doublerealT[n_a[12] + 1];

																					if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																						for (integer ii = 1; ii <= n_a[12]; ii++) {
																							error_approx_coarse11[ii] = 0.0;
																						}
																					}
																					if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																						for (integer ii = 1; ii <= n_a[12]; ii++) {
																							error_approx_coarse11[ii] = (rand() / ((doublerealT)RAND_MAX));
																						}
																					}

																					//for (integer i_37 = 1; i_37 <= igam; i_37++)
																					{
																						// pre smothing
																						for (integer iter = 0; iter < nu1; iter++) {
																							integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																							integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																							seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
																						}

																						move_down(nu1, nu2);

																						if (ilevel > 13) {
																							// 11 сентября 2015 РИМИНИ пляж 

																							// residual
																							//doublerealT *residual_fine12 = new doublerealT[n_a[12] + 1];
																							integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																							integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																							residual(Amat, n1, n2, error_approx_coarse11, residual_coarse11, flag, n_a[12], residual_fine12);


																							//doublerealT *residual_coarse12 = new doublerealT[n_a[13] + 1];

																							// restriction
																							integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																							integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																							restriction(R, n3, n4, flag, residual_fine12, residual_coarse12, n_a[12], n_a[13]);

																							// Amat*e=r;
																							//doublerealT* error_approx_coarse12 = new doublerealT[n_a[13] + 1];

																							if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																								for (integer ii = 1; ii <= n_a[13]; ii++) {
																									error_approx_coarse12[ii] = 0.0;
																								}
																							}
																							if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																								for (integer ii = 1; ii <= n_a[13]; ii++) {
																									error_approx_coarse12[ii] = (rand() / ((doublerealT)RAND_MAX));
																								}
																							}

																							//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																							{
																								// pre smothing
																								for (integer iter = 0; iter < nu1; iter++) {
																									integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																									integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																									seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
																								}


																								move_down(nu1, nu2);

																								if (ilevel > 14) {
																									// 11 сентября 2015 РИМИНИ пляж 

																									// residual
																									//doublerealT *residual_fine13 = new doublerealT[n_a[13] + 1];
																									integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																									integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																									residual(Amat, n1, n2, error_approx_coarse12, residual_coarse12, flag, n_a[13], residual_fine13);


																									//doublerealT *residual_coarse13 = new doublerealT[n_a[14] + 1];

																									// restriction
																									integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																									integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																									restriction(R, n3, n4, flag, residual_fine13, residual_coarse13, n_a[13], n_a[14]);

																									// Amat*e=r;
																									//doublerealT* error_approx_coarse13 = new doublerealT[n_a[14] + 1];

																									if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																										for (integer ii = 1; ii <= n_a[14]; ii++) {
																											error_approx_coarse13[ii] = 0.0;
																										}
																									}
																									if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																										for (integer ii = 1; ii <= n_a[14]; ii++) {
																											error_approx_coarse13[ii] = (rand() / ((doublerealT)RAND_MAX));
																										}
																									}


																									//for (integer i_37 = 1; i_37 <= igam; i_37++)
																									{
																										// pre smothing
																										for (integer iter = 0; iter < nu1; iter++) {
																											integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																											integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																											seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																										}


																										move_down(nu1, nu2);

																										if (ilevel > 15) {
																											// 14 сентября 2015 Москва на работе в пн. 

																											// residual
																											//doublerealT *residual_fine14 = new doublerealT[n_a[14] + 1];
																											integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																											integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																											residual(Amat, n1, n2, error_approx_coarse13, residual_coarse13, flag, n_a[14], residual_fine14);


																											//doublerealT *residual_coarse14 = new doublerealT[n_a[15] + 1];

																											// restriction
																											integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																											integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																											restriction(R, n3, n4, flag, residual_fine14, residual_coarse14, n_a[14], n_a[15]);

																											// Amat*e=r;
																											//doublerealT* error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																											if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																												for (integer ii = 1; ii <= n_a[15]; ii++) {
																													error_approx_coarse14[ii] = 0.0;
																												}
																											}
																											if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																												for (integer ii = 1; ii <= n_a[15]; ii++) {
																													error_approx_coarse14[ii] = (rand() / ((doublerealT)RAND_MAX));
																												}
																											}

																											//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																											{
																												// pre smothing
																												for (integer iter = 0; iter < nu1; iter++) {
																													integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																													integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																													seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																												}


																												move_down(nu1, nu2);

																												if (ilevel > 16) {
																													// 10 октября 2015. 

																													// residual
																													//doublerealT *residual_fine15 = new doublerealT[n_a[15] + 1];
																													integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																													integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																													residual(Amat, n1, n2, error_approx_coarse14, residual_coarse14, flag, n_a[15], residual_fine15);


																													//doublerealT *residual_coarse15 = new doublerealT[n_a[16] + 1];

																													// restriction
																													integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																													integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																													restriction(R, n3, n4, flag, residual_fine15, residual_coarse15, n_a[15], n_a[16]);

																													// Amat*e=r;
																													//doublerealT* error_approx_coarse15 = new doublerealT[n_a[16] + 1];

																													if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																														for (integer ii = 1; ii <= n_a[16]; ii++) {
																															error_approx_coarse15[ii] = 0.0;
																														}
																													}
																													if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																														for (integer ii = 1; ii <= n_a[16]; ii++) {
																															error_approx_coarse15[ii] = (rand() / ((doublerealT)RAND_MAX));
																														}
																													}

																													//for (integer i_37 = 1; i_37 <= igam; i_37++)
																													{
																														// pre smothing
																														for (integer iter = 0; iter < nu1; iter++) {
																															integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																															integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																															seidel(Amat, n5, n6, error_approx_coarse15, residual_coarse15, flag, n_a[16]);
																														}


																														move_down(nu1, nu2);

																														if (ilevel > 17) {
																															// 10 октября 2015. 

																															// residual
																															//doublerealT *residual_fine16 = new doublerealT[n_a[16] + 1];
																															integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																															integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																															residual(Amat, n1, n2, error_approx_coarse15, residual_coarse15, flag, n_a[16], residual_fine16);


																															//doublerealT *residual_coarse16 = new doublerealT[n_a[17] + 1];

																															// restriction
																															integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																															integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																															restriction(R, n3, n4, flag, residual_fine16, residual_coarse16, n_a[16], n_a[17]);

																															// Amat*e=r;
																															//doublerealT* error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																															if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																																for (integer ii = 1; ii <= n_a[17]; ii++) {
																																	error_approx_coarse16[ii] = 0.0;
																																}
																															}
																															if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																																for (integer ii = 1; ii <= n_a[17]; ii++) {
																																	error_approx_coarse16[ii] = (rand() / ((doublerealT)RAND_MAX));
																																}
																															}


																															//for (integer i_37 = 1; i_37 <= igam; i_37++)
																															{
																																// pre smothing
																																for (integer iter = 0; iter < nu1; iter++) {
																																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																	seidel(Amat, n5, n6, error_approx_coarse16, residual_coarse16, flag, n_a[17]);
																																}

																																move_down(nu1, nu2);


																																if (ilevel > 18) {
																																	// 5 декабря 2015. 

																																	// residual
																																	//doublerealT *residual_fine17 = new doublerealT[n_a[17] + 1];
																																	integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																																	integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																	residual(Amat, n1, n2, error_approx_coarse16, residual_coarse16, flag, n_a[17], residual_fine17);


																																	//doublerealT *residual_coarse17 = new doublerealT[n_a[18] + 1];

																																	// restriction
																																	integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																																	integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17];
																																	restriction(R, n3, n4, flag, residual_fine17, residual_coarse17, n_a[17], n_a[18]);

																																	// Amat*e=r;
																																	//doublerealT* error_approx_coarse17 = new doublerealT[n_a[18] + 1];

																																	if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																																		for (integer ii = 1; ii <= n_a[18]; ii++) {
																																			error_approx_coarse17[ii] = 0.0;
																																		}
																																	}
																																	if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																																		for (integer ii = 1; ii <= n_a[18]; ii++) {
																																			error_approx_coarse17[ii] = (rand() / ((doublerealT)RAND_MAX));
																																		}
																																	}


																																	//for (integer i_37 = 1; i_37 <= igam; i_37++)
																																	{
																																		// pre smothing
																																		for (integer iter = 0; iter < nu1; iter++) {
																																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17] + nnz_a[18];
																																			seidel(Amat, n5, n6, error_approx_coarse17, residual_coarse17, flag, n_a[18]);
																																		}

																																		// post smothing
																																		for (integer iter = 0; iter < nu2; iter++) {
																																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17] + nnz_a[18];
																																			seidel(Amat, n5, n6, error_approx_coarse17, residual_coarse17, flag, n_a[18]);
																																		}
																																	}

																																	// prolongation
																																	// residual_r
																																	//doublerealT *error_approx_fine17 = new doublerealT[n_a[17] + 1];
																																	for (integer ii = 1; ii <= n_a[17]; ii++) {
																																		error_approx_fine17[ii] = 0.0;
																																	}



																																	integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																																	integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17];
																																	prolongation(P, n7, n8, flag, error_approx_fine17, error_approx_coarse17, n_a[17], n_a[18]);

																																	// correction
																																	for (integer ii = 1; ii <= n_a[17]; ii++) {
																																		error_approx_coarse16[ii] += error_approx_fine17[ii];
																																	}

																																	// free
																																	//delete[] error_approx_fine17;
																																	//delete[] error_approx_coarse17;
																																	//delete[] residual_coarse17;
																																	//delete[] residual_fine17;

																																}



																																// post smothing
																																for (integer iter = 0; iter < nu2; iter++) {
																																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																	seidel(Amat, n5, n6, error_approx_coarse16, residual_coarse16, flag, n_a[17]);
																																}
																															}
																															move_up(nu1, nu2);

																															// prolongation
																															// residual_r
																															//doublerealT *error_approx_fine16 = new doublerealT[n_a[16] + 1];
																															for (integer ii = 1; ii <= n_a[16]; ii++) {
																																error_approx_fine16[ii] = 0.0;
																															}



																															integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																															integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																															prolongation(P, n7, n8, flag, error_approx_fine16, error_approx_coarse16, n_a[16], n_a[17]);

																															// correction
																															for (integer ii = 1; ii <= n_a[16]; ii++) {
																																error_approx_coarse15[ii] += error_approx_fine16[ii];
																															}

																															// free
																															//delete[] error_approx_fine16;
																															//delete[] error_approx_coarse16;
																															//delete[] residual_coarse16;
																															//delete[] residual_fine16;

																														}


																														// post smothing
																														for (integer iter = 0; iter < nu2; iter++) {
																															integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																															integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																															seidel(Amat, n5, n6, error_approx_coarse15, residual_coarse15, flag, n_a[16]);
																														}
																													}
																													move_up(nu1, nu2);

																													// prolongation
																													// residual_r
																													//doublerealT *error_approx_fine15 = new doublerealT[n_a[15] + 1];
																													for (integer ii = 1; ii <= n_a[15]; ii++) {
																														error_approx_fine15[ii] = 0.0;
																													}



																													integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																													integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																													prolongation(P, n7, n8, flag, error_approx_fine15, error_approx_coarse15, n_a[15], n_a[16]);

																													// correction
																													for (integer ii = 1; ii <= n_a[15]; ii++) {
																														error_approx_coarse14[ii] += error_approx_fine15[ii];
																													}

																													// free
																													//delete[] error_approx_fine15;
																													//delete[] error_approx_coarse15;
																													//delete[] residual_coarse15;
																													//delete[] residual_fine15;

																												}

																												// post smothing
																												for (integer iter = 0; iter < nu2; iter++) {
																													integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																													integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																													seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																												}
																											}
																											move_up(nu1, nu2);

																											// prolongation
																											// residual_r
																											//doublerealT *error_approx_fine14 = new doublerealT[n_a[14] + 1];
																											for (integer ii = 1; ii <= n_a[14]; ii++) {
																												error_approx_fine14[ii] = 0.0;
																											}



																											integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																											integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																											prolongation(P, n7, n8, flag, error_approx_fine14, error_approx_coarse14, n_a[14], n_a[15]);

																											// correction
																											for (integer ii = 1; ii <= n_a[14]; ii++) {
																												error_approx_coarse13[ii] += error_approx_fine14[ii];
																											}

																											// free
																											//delete[] error_approx_fine14;
																											//delete[] error_approx_coarse14;
																											//delete[] residual_coarse14;
																											//delete[] residual_fine14;

																										}


																										// post smothing
																										for (integer iter = 0; iter < nu2; iter++) {
																											integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																											integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																											seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																										}
																									}

																									move_up(nu1, nu2);

																									// prolongation
																									// residual_r
																									//doublerealT *error_approx_fine13 = new doublerealT[n_a[13] + 1];
																									for (integer ii = 1; ii <= n_a[13]; ii++) {
																										error_approx_fine13[ii] = 0.0;
																									}

#if doubleintprecision == 1
																									//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																									//printf("error_approx_coarse13[%lld]=%e\n",ii, error_approx_coarse13[ii]);

																									//printf("residual_coarse13[%lld]=%e\n", ii, residual_coarse13[ii]);
																									//getchar();
																									//}
																									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																									//if (ii % 20 == 0) getchar();
																									//}
#else
																									//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																									//printf("error_approx_coarse13[%d]=%e\n",ii, error_approx_coarse13[ii]);

																									//printf("residual_coarse13[%d]=%e\n", ii, residual_coarse13[ii]);
																									//getchar();
																									//}
																									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																									//if (ii % 20 == 0) getchar();
																									//}
#endif
																									

																									integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																									integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																									prolongation(P, n7, n8, flag, error_approx_fine13, error_approx_coarse13, n_a[13], n_a[14]);

																									// correction
																									for (integer ii = 1; ii <= n_a[13]; ii++) {
																										error_approx_coarse12[ii] += error_approx_fine13[ii];
																									}

																									// free
																									//delete[] error_approx_fine13;
																									//delete[] error_approx_coarse13;
																									//delete[] residual_coarse13;
																									//delete[] residual_fine13;

																								}


																								// post smothing
																								for (integer iter = 0; iter < nu2; iter++) {
																									integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																									integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																									seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
																								}
																							}

																							move_up(nu1, nu2);

																							// prolongation
																							// residual_r
																							//doublerealT *error_approx_fine12 = new doublerealT[n_a[12] + 1];
																							for (integer ii = 1; ii <= n_a[12]; ii++) {
																								error_approx_fine12[ii] = 0.0;
																							}

#if doubleintprecision == 1
																							//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
																							//printf("error_approx_coarse12[%lld]=%e\n",ii, error_approx_coarse12[ii]);

																							//printf("residual_coarse12[%lld]=%e\n", ii, residual_coarse12[ii]);
																							//getchar();
																							//}
																							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
																							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																							//if (ii % 20 == 0) getchar();
																							//}
#else
																							//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
																							//printf("error_approx_coarse12[%d]=%e\n",ii, error_approx_coarse12[ii]);

																							//printf("residual_coarse12[%d]=%e\n", ii, residual_coarse12[ii]);
																							//getchar();
																							//}
																							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
																							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																							//if (ii % 20 == 0) getchar();
																							//}
#endif
																							

																							integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																							integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																							prolongation(P, n7, n8, flag, error_approx_fine12, error_approx_coarse12, n_a[12], n_a[13]);

																							// correction
																							for (integer ii = 1; ii <= n_a[12]; ii++) {
																								error_approx_coarse11[ii] += error_approx_fine12[ii];
																							}

																							// free
																							//delete[] error_approx_fine12;
																							//delete[] error_approx_coarse12;
																							//delete[] residual_coarse12;
																							//delete[] residual_fine12;

																						}



																						// post smothing
																						for (integer iter = 0; iter < nu2; iter++) {
																							integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																							integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																							seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
																						}
																					}
																					move_up(nu1, nu2);

																					// prolongation
																					// residual_r
																					//doublerealT *error_approx_fine11 = new doublerealT[n_a[11] + 1];
																					for (integer ii = 1; ii <= n_a[11]; ii++) {
																						error_approx_fine11[ii] = 0.0;
																					}

#if doubleintprecision == 1
																					//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
																					//printf("error_approx_coarse11[%lld]=%e\n",ii, error_approx_coarse11[ii]);

																					//printf("residual_coarse11[%lld]=%e\n", ii, residual_coarse11[ii]);
																					//getchar();
																					//}
																					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
																					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																					//if (ii % 20 == 0) getchar();
																					//}
#else
																					//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
																					//printf("error_approx_coarse11[%d]=%e\n",ii, error_approx_coarse11[ii]);

																					//printf("residual_coarse11[%d]=%e\n", ii, residual_coarse11[ii]);
																					//getchar();
																					//}
																					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
																					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																					//if (ii % 20 == 0) getchar();
																					//}
#endif
																					

																					integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																					integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																					prolongation(P, n7, n8, flag, error_approx_fine11, error_approx_coarse11, n_a[11], n_a[12]);

																					// correction
																					for (integer ii = 1; ii <= n_a[11]; ii++) {
																						error_approx_coarse10[ii] += error_approx_fine11[ii];
																					}

																					// free
																					//delete[] error_approx_fine11;
																					//delete[] error_approx_coarse11;
																					//delete[] residual_coarse11;
																					//delete[] residual_fine11;

																				}


																				// post smothing
																				for (integer iter = 0; iter < nu2; iter++) {
																					integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																					integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																					seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
																				}
																			}
																			move_up(nu1, nu2);

																			// prolongation
																			// residual_r
																			//doublerealT *error_approx_fine10 = new doublerealT[n_a[10] + 1];
																			for (integer ii = 1; ii <= n_a[10]; ii++) {
																				error_approx_fine10[ii] = 0.0;
																			}

#if doubleintprecision == 1
																			//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
																			//printf("error_approx_coarse10[%lld]=%e\n",ii, error_approx_coarse10[ii]);

																			//printf("residual_coarse10[%lld]=%e\n", ii, residual_coarse10[ii]);
																			//getchar();
																			//}
																			//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
																			//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																			//if (ii % 20 == 0) getchar();
																			//}
#else
																			//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
																			//printf("error_approx_coarse10[%d]=%e\n",ii, error_approx_coarse10[ii]);

																			//printf("residual_coarse10[%d]=%e\n", ii, residual_coarse10[ii]);
																			//getchar();
																			//}
																			//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
																			//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																			//if (ii % 20 == 0) getchar();
																			//}
#endif
																			

																			integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																			integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																			prolongation(P, n7, n8, flag, error_approx_fine10, error_approx_coarse10, n_a[10], n_a[11]);

																			// correction
																			for (integer ii = 1; ii <= n_a[10]; ii++) {
																				error_approx_coarse9[ii] += error_approx_fine10[ii];
																			}

																			// free
																			//delete[] error_approx_fine10;
																			//delete[] error_approx_coarse10;
																			//delete[] residual_coarse10;
																			//delete[] residual_fine10;

																		}



																		// post smothing
																		for (integer iter = 0; iter < nu2; iter++) {
																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																			seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
																		}
																	}

																	move_up(nu1, nu2);

																	// prolongation
																	// residual_r
																	//doublerealT *error_approx_fine9 = new doublerealT[n_a[9] + 1];
																	for (integer ii = 1; ii <= n_a[9]; ii++) {
																		error_approx_fine9[ii] = 0.0;
																	}

#if doubleintprecision == 1
																	//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
																	//printf("error_approx_coarse9[%lld]=%e\n",ii, error_approx_coarse9[ii]);

																	//printf("residual_coarse9[%lld]=%e\n", ii, residual_coarse9[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
																	//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#else
																	//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
																	//printf("error_approx_coarse9[%d]=%e\n",ii, error_approx_coarse9[ii]);

																	//printf("residual_coarse9[%d]=%e\n", ii, residual_coarse9[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
																	//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#endif
																	

																	integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
																	integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																	prolongation(P, n7, n8, flag, error_approx_fine9, error_approx_coarse9, n_a[9], n_a[10]);

																	// correction
																	for (integer ii = 1; ii <= n_a[9]; ii++) {
																		error_approx_coarse8[ii] += error_approx_fine9[ii];
																	}

																	// free
																	//delete[] error_approx_fine9;
																	//delete[] error_approx_coarse9;
																	//delete[] residual_coarse9;
																	//delete[] residual_fine9;

																}

																// post smothing
																for (integer iter = 0; iter < nu2; iter++) {
																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																	seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
																}
															}

															move_up(nu1, nu2);

															// prolongation
															// residual_r
															//doublerealT *error_approx_fine8 = new doublerealT[n_a[8] + 1];
															for (integer ii = 1; ii <= n_a[8]; ii++) {
																error_approx_fine8[ii] = 0.0;
															}

#if doubleintprecision == 1
															//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
															//printf("error_approx_coarse8[%lld]=%e\n",ii, error_approx_coarse8[ii]);

															//printf("residual_coarse8[%lld]=%e\n", ii, residual_coarse8[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
															//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#else
															//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
															//printf("error_approx_coarse8[%d]=%e\n",ii, error_approx_coarse8[ii]);

															//printf("residual_coarse8[%d]=%e\n", ii, residual_coarse8[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
															//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#endif
															

															integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
															integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
															prolongation(P, n7, n8, flag, error_approx_fine8, error_approx_coarse8, n_a[8], n_a[9]);

															// correction
															for (integer ii = 1; ii <= n_a[8]; ii++) {
																error_approx_coarse7[ii] += error_approx_fine8[ii];
															}

															// free
															//delete[] error_approx_fine8;
															//delete[] error_approx_coarse8;
															//delete[] residual_coarse8;
															//delete[] residual_fine8;

														}




														// post smothing
														for (integer iter = 0; iter < nu2; iter++) {
															seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
														}
													}
													move_up(nu1, nu2);

													// prolongation
													// residual_r
													//doublerealT *error_approx_fine7 = new doublerealT[n_a[7] + 1];
													for (integer ii = 1; ii <= n_a[7]; ii++) {
														error_approx_fine7[ii] = 0.0;
													}

#if doubleintprecision == 1
													//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
													//printf("error_approx_coarse7[%lld]=%e\n",ii, error_approx_coarse7[ii]);

													//printf("residual_coarse7[%lld]=%e\n", ii, residual_coarse7[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
													//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#else
													//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
													//printf("error_approx_coarse7[%d]=%e\n",ii, error_approx_coarse7[ii]);

													//printf("residual_coarse7[%d]=%e\n", ii, residual_coarse7[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
													//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#endif
													

													prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, error_approx_fine7, error_approx_coarse7, n_a[7], n_a[8]);

													// correction
													for (integer ii = 1; ii <= n_a[7]; ii++) {
														error_approx_coarse6[ii] += error_approx_fine7[ii];
													}

													// free
													//delete[] error_approx_fine7;
													//delete[] error_approx_coarse7;
													//delete[] residual_coarse7;
													//delete[] residual_fine7;

												}

												// post smothing
												//doublerealT R0_7 = 0.0;
												//doublerealT Rprev_7 = 0.0, Rnext_7 = 0.0;
												if (process_flow_logic) {
													// calculate initial residual.
													//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);



													//Rprev_7 = norma(residual_fine7, n_a[7]);


													// smother
													integer iter = 0;
													for (iter = 0; iter < nu2; iter++) {
														//quick seidel
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}

														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7,diag7);


														Rnext_7 = norma(residual_fine7, n_a[7]);
														// this is process flow logic
														if (Rnext_7 < process_flow_alpha*R0_7) {
															// Смысл модификации в том что мы экономим итерации на пресмутере.
															break; // досрочно опускаемся на следующий уровень если он есть конечно.
														}
														else {
															Rprev_7 = Rnext_7;
														}
													}

													if (iter == nu2) {
														printf("level 7 limit postsmother iteration is reached\n");
													}

												}
												else {
													for (integer iter = 0; iter < nu2; iter++) {
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
													}
												}
											}

											move_up(nu1, nu2);


											// prolongation
											// residual_r
											//doublerealT *error_approx_fine6 = new doublerealT[n_a[6] + 1];
											for (integer ii = 1; ii <= n_a[6]; ii++) {
												error_approx_fine6[ii] = 0.0;
											}

#if doubleintprecision == 1
											//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
											//printf("error_approx_coarse6[%lld]=%e\n",ii, error_approx_coarse6[ii]);

											//printf("residual_coarse6[%lld]=%e\n", ii, residual_coarse6[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
											//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#else
											//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
											//printf("error_approx_coarse6[%d]=%e\n",ii, error_approx_coarse6[ii]);

											//printf("residual_coarse6[%d]=%e\n", ii, residual_coarse6[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
											//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#endif
											

											prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, error_approx_fine6, error_approx_coarse6, n_a[6], n_a[7]);

											// correction
											for (integer ii = 1; ii <= n_a[6]; ii++) {
												error_approx_coarse5[ii] += error_approx_fine6[ii];
											}

											// free
											//delete[] error_approx_fine6;
											//delete[] error_approx_coarse6;
											//delete[] residual_coarse6;
											//delete[] residual_fine6;

										}



										// post smothing
										if (process_flow_logic) {
											// calculate initial residual.
											//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);



											//Rprev_6 = norma(residual_fine6, n_a[6]);


											// smother
											integer iter = 0;
											for (iter = 0; iter < nu2; iter++) {
												//quick seidel
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}

												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6,diag6);



												Rnext_6 = norma(residual_fine6, n_a[6]);
												// this is process flow logic
												if (Rnext_6 < process_flow_alpha*R0_6) {
													// Смысл модификации в том что мы экономим итерации на пресмутере.
													break; // досрочно опускаемся на следующий уровень если он есть конечно.
												}
												else {
													Rprev_6 = Rnext_6;
												}
											}

											if (iter == nu2) {
												printf("level 6 limit postsmother iteration is reached\n");
											}

										}
										else {
											for (integer iter = 0; iter < nu2; iter++) {
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
											}
										}
									}

									move_up(nu1, nu2);

									// prolongation
									// residual_r
									//doublerealT *error_approx_fine5 = new doublerealT[n_a[5] + 1];
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_fine5[ii] = 0.0;
									}

#if doubleintprecision == 1
									//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
									//printf("error_approx_coarse5[%lld]=%e\n",ii, error_approx_coarse5[ii]);

									//printf("residual_coarse5[%lld]=%e\n", ii, residual_coarse5[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#else
									//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
									//printf("error_approx_coarse5[%d]=%e\n",ii, error_approx_coarse5[ii]);

									//printf("residual_coarse5[%d]=%e\n", ii, residual_coarse5[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#endif
									

									prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, error_approx_fine5, error_approx_coarse5, n_a[5], n_a[6]);

									// correction
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] += error_approx_fine5[ii];
									}

									// free
									//delete[] error_approx_fine5;
									//delete[] error_approx_coarse5;
									//delete[] residual_coarse5;
									//delete[] residual_fine5;

								}
							


							// post smothing
							if (process_flow_logic) {
								// calculate initial residual.
								//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] , residual_fine5);



								//Rprev_5 = norma(residual_fine5, n_a[5]);


								// smother
								integer iter = 0;
								for (iter = 0; iter < nu2; iter++) {
									//quick seidel
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}
									else {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}

									//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] , residual_fine5);
									residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5,diag5);


									Rnext_5 = norma(residual_fine5, n_a[5]);
									// this is process flow logic
									if (Rnext_5 < process_flow_alpha*R0_5) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_5 = Rnext_5;
									}
								}

								if (iter == nu2) {
									printf("level 5 limit postsmother iteration is reached\n");
								}

							}
							else {
								for (integer iter = 0; iter < nu2; iter++) {
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}
									else
									{
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}
								}
							}
							}

							move_up(nu1, nu2);

							// prolongation
							// residual_r
							//doublerealT *error_approx_fine4 = new doublerealT[n_a[4] + 1];
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_fine4[ii] = 0.0;
							}

#if doubleintprecision == 1
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%lld]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%lld]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#else
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%d]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%d]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#endif
							

							prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, error_approx_fine4, error_approx_coarse4, n_a[4], n_a[5]);

							// correction
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] += error_approx_fine4[ii];
							}

							// free
							//delete[] error_approx_fine4;
							//delete[] error_approx_coarse4;
							//delete[] residual_coarse4;
							//delete[] residual_fine4;

						}
						



						// post smothing
						if (process_flow_logic) {
							

							// smother
							integer iter = 0;
							for (iter = 0; iter < nu2; iter++) {
								//quick seidel
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}
								else {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}

								//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] , residual_fine4);
								residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4,diag4);


								Rnext_4 = norma(residual_fine4, n_a[4]);
								// this is process flow logic
								if (Rnext_4 < process_flow_alpha*R0_4) {
									// Смысл модификации в том что мы экономим итерации на пресмутере.
									break; // досрочно опускаемся на следующий уровень если он есть конечно.
								}
								else {
									Rprev_4 = Rnext_4;
								}
							}

							if (iter == nu2) {
								printf("level 4 limit postsmother iteration is reached\n");
							}

						}
						else {
							for (integer iter = 0; iter < nu2; iter++) {
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}
								else {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}
							}
						}
						}
						move_up(nu1, nu2);

						// prolongation
						// residual_r
						//doublerealT *error_approx_fine3 = new doublerealT[n_a[3] + 1];
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_fine3[ii] = 0.0;
						}

#if doubleintprecision == 1
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%lld]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%lld]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#else
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%d]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%d]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#endif
						

						prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, error_approx_fine3, error_approx_coarse3, n_a[3], n_a[4]);

						// correction
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] += error_approx_fine3[ii];
						}

						// free
						//delete[] error_approx_fine3;
						//delete[] error_approx_coarse3;
						//delete[] residual_coarse3;
						//delete[] residual_fine3;

					}
					


					// post smothing
					if (process_flow_logic) {


						// smother
						integer iter = 0;
						for (iter = 0; iter < nu2; iter++) {
							//quick seidel
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
							else {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}

							//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] , residual_fine3);
							residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3,diag3);


							Rnext_3 = norma(residual_fine3, n_a[3]);
							// this is process flow logic
							if (Rnext_3 < process_flow_alpha*R0_3) {
								// Смысл модификации в том что мы экономим итерации на пресмутере.
								break; // досрочно опускаемся на следующий уровень если он есть конечно.
							}
							else {
								Rprev_3 = Rnext_3;
							}
						}

						if (iter == nu2) {
							printf("level 3 limit postsmother iteration is reached\n");
						}

					}
					else {
						for (integer iter = 0; iter < nu2; iter++) {
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
							else {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
						}
					}
					}

					move_up(nu1, nu2);

					// prolongation
					// residual_r
					//doublerealT *error_approx_fine2 = new doublerealT[n_a[2] + 1];
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_fine2[ii] = 0.0;
					}

#if doubleintprecision == 1
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%lld]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%lld]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#else
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%d]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%d]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#endif
				

					prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, error_approx_fine2, error_approx_coarse2, n_a[2], n_a[3]);

					// correction
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] += error_approx_fine2[ii];
					}

					// free
					//delete[] error_approx_fine2;
					//delete[] error_approx_coarse2;
					//delete[] residual_coarse2;
					//delete[] residual_fine2;

				}
				

				// post smothing
				if (process_flow_logic) {


					// smother
					integer iter = 0;
					for (iter = 0; iter < nu2; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}
						else {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}

						//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2,diag2);



						Rnext_2 = norma(residual_fine2, n_a[2]);
						// this is process flow logic
						if (Rnext_2 < process_flow_alpha*R0_2) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_2 = Rnext_2;
						}
					}

					if (iter == nu2) {
						printf("level 2 limit postsmother iteration is reached\n");
					}

				}
				else {
					for (integer iter = 0; iter < nu2; iter++) {
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}
						else {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}
					}
				}
				}

				move_up(nu1, nu2);

				// prolongation
				// residual_r
				//doublerealT *error_approx_fine1 = new doublerealT[n_a[1] + 1];
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_fine1[ii] = 0.0;
				}

#if doubleintprecision == 1
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%lld]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%lld]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#else
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%d]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%d]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#endif
				

				prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, error_approx_fine1, error_approx_coarse1, n_a[1], n_a[2]);

				// correction
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] += error_approx_fine1[ii];
				}

				// free
				//delete[] error_approx_fine1;
				//delete[] error_approx_coarse1;
				//delete[] residual_coarse1;
				//delete[] residual_fine1;

			}
			
			

			// post smothing
			if (process_flow_logic) {


				// smother
				integer iter = 0;
				for (iter = 0; iter < nu2; iter++) {
					//quick seidel
					if (bonly_serial) {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
					}
					else {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
					}

					//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0] , residual_fine1);
					residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0] , residual_fine1,diag1);


					Rnext_1 = norma(residual_fine1, n_a[1]);
					// this is process flow logic
					if (Rnext_1 < process_flow_alpha*R0_1) {
						// Смысл модификации в том что мы экономим итерации на пресмутере.
						break; // досрочно опускаемся на следующий уровень если он есть конечно.
					}
					else {
						Rprev_1 = Rnext_1;
					}
				}

				if (iter == nu2) {
					printf("level 1 limit postsmother iteration is reached\n");
				}

			}
			else {
				for (integer iter = 0; iter < nu2; iter++) {
					if (bonly_serial) {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
					}
					else {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
					}
				}
			}
			}

			move_up(nu1, nu2);

			// prolongation
			// residual_r
			//doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				error_approx_fine[ii] = 0.0;
			}

			prolongation(P, 1, nnz_aRP[0], flag, error_approx_fine, error_approx_coarse, n_a[0], n_a[1]);

			// correction
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				x[ii] += error_approx_fine[ii];
			}

			// free
			//delete[] error_approx_fine;
			//delete[] error_approx_coarse;
			//delete[] residual_coarse;
			//delete[] residual_fine;
		}
		


		//doublerealT R0_0 = 0.0;
		//doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		// post smothing
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine,diag0);
			Rprev_0 = norma(residual_fine, n_a[0]);

			// smother
			//integer iter = 0;
			//for (iter = 0; iter < nu2; iter++) {
				//quick seidel
			if (bonly_serial) {
				//	seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
			}
			else {
				//seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
			}
				//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			//	residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine,diag0);
			//	Rnext_0 = norma(residual_fine, n_a[0]);
				// this is process flow logic
			//	if (Rnext_0 < process_flow_alpha*R0_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
			//		break; // досрочно опускаемся на следующий уровень если он есть конечно.
			//	}
			//	else {
			//		Rprev_0 = Rnext_0;
			//	}
		//	}
			//if (iter == nu1) {
			//	printf("level 0 limit postsmother iteration is reached\n");
			//}

		}
		//else {
			// nFinnestSweeps new logic 14 jan 2016.
			// smother
			//for (integer iter = 0; iter < nu2; iter++) {
				//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
				//quick seidel
		if (bonly_serial) {
			//	seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
		}
		else {
			//seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
		}
//			}
		//}



		


		//system("pause");
	}

	if (debug_reshime) system("pause");
	//system("pause");

	


	// free
	/*
	delete[] diag0;
	delete[] error_approx_fine;
	if (ilevel > 1) {
		delete[] diag1;
		delete[] error_approx_coarse;
		delete[] residual_coarse;
		if (ilevel > 2) {
			// free
			delete[] diag2;
			delete[] error_approx_fine1;
			delete[] error_approx_coarse1;
			delete[] residual_coarse1;
			delete[] residual_fine1;
			if (ilevel > 3) {
				// free
				delete[] diag3;
				delete[] error_approx_fine2;
				delete[] error_approx_coarse2;
				delete[] residual_coarse2;
				delete[] residual_fine2;
				if (ilevel > 4) {
					// free
					delete[] diag4;
					delete[] error_approx_fine3;
					delete[] error_approx_coarse3;
					delete[] residual_coarse3;
					delete[] residual_fine3;
					if (ilevel > 5) {
						// free
						delete[] diag5;
						delete[] error_approx_fine4;
						delete[] error_approx_coarse4;
						delete[] residual_coarse4;
						delete[] residual_fine4;
						if (ilevel > 6) {
							// free
							delete[] diag6;
							delete[] error_approx_fine5;
							delete[] error_approx_coarse5;
							delete[] residual_coarse5;
							delete[] residual_fine5;
							if (ilevel > 7) {
								// free
								delete[] diag7;
								delete[] error_approx_fine6;
								delete[] error_approx_coarse6;
								delete[] residual_coarse6;
								delete[] residual_fine6;
								if (ilevel > 8) {
									// free
									delete[] diag8;
									delete[] error_approx_fine7;
									delete[] error_approx_coarse7;
									delete[] residual_coarse7;
									delete[] residual_fine7;
									if (ilevel > 9) {
										// free
										delete[] error_approx_fine8;
										delete[] error_approx_coarse8;
										delete[] residual_coarse8;
										delete[] residual_fine8;
										if (ilevel > 10) {
											// free
											delete[] error_approx_fine9;
											delete[] error_approx_coarse9;
											delete[] residual_coarse9;
											delete[] residual_fine9;
											if (ilevel > 11) {
												// free
												delete[] error_approx_fine10;
												delete[] error_approx_coarse10;
												delete[] residual_coarse10;
												delete[] residual_fine10;
												if (ilevel > 12) {
													// free
													delete[] error_approx_fine11;
													delete[] error_approx_coarse11;
													delete[] residual_coarse11;
													delete[] residual_fine11;
													if (ilevel > 13) {
														// free
														delete[] error_approx_fine12;
														delete[] error_approx_coarse12;
														delete[] residual_coarse12;
														delete[] residual_fine12;
														if (ilevel > 14) {
															// free
															delete[] error_approx_fine13;
															delete[] error_approx_coarse13;
															delete[] residual_coarse13;
															delete[] residual_fine13;
															if (ilevel > 15) {
																// free
																delete[] error_approx_fine14;
																delete[] error_approx_coarse14;
																delete[] residual_coarse14;
																delete[] residual_fine14;
																if (ilevel > 16) {
																	// free
																	delete[] error_approx_fine15;
																	delete[] error_approx_coarse15;
																	delete[] residual_coarse15;
																	delete[] residual_fine15;
																	if (ilevel > 17) {
																		// free
																		delete[] error_approx_fine16;
																		delete[] error_approx_coarse16;
																		delete[] residual_coarse16;
																		delete[] residual_fine16;
																		if (ilevel > 18) {
																			// free
																			delete[] error_approx_fine17;
																			delete[] error_approx_coarse17;
																			delete[] residual_coarse17;
																			delete[] residual_fine17;

																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	*/

// free
free(diag0);
free(bnested_desection_global_amg);  // Глобальная память.
free(nested_desection0);
free(error_approx_fine);
if (ilevel > 1) {
	free(diag1);
	free(nested_desection1);
	free(error_approx_coarse);
	free(residual_coarse);
	if (ilevel > 2) {
		// free
		free(diag2);
		free(nested_desection2);
		free(error_approx_fine1);
		free(error_approx_coarse1);
		free(residual_coarse1);
		free(residual_fine1);
		if (ilevel > 3) {
			// free
			free(diag3);
			free(nested_desection3);
			free(error_approx_fine2);
			free(error_approx_coarse2);
			free(residual_coarse2);
			free(residual_fine2);
			if (ilevel > 4) {
				// free
				free(diag4);
				free(nested_desection4);
				free(error_approx_fine3);
				free(error_approx_coarse3);
				free(residual_coarse3);
				free(residual_fine3);
				if (ilevel > 5) {
					// free
					free(diag5);
					free(nested_desection5);
					free(error_approx_fine4);
					free(error_approx_coarse4);
					free(residual_coarse4);
					free(residual_fine4);
					if (ilevel > 6) {
						// free
						 free(diag6);
						 free(nested_desection6);
						 free(error_approx_fine5);
						 free(error_approx_coarse5);
						 free(residual_coarse5);
						 free(residual_fine5);
						if (ilevel > 7) {
							// free
							free(diag7);
							free(nested_desection7);
							free(error_approx_fine6);
							free(error_approx_coarse6);
							free(residual_coarse6);
							free(residual_fine6);
							if (ilevel > 8) {
								// free
								free(diag8);
								free(nested_desection8);
								free(error_approx_fine7);
								free(error_approx_coarse7);
								free(residual_coarse7);
								free(residual_fine7);
								if (ilevel > 9) {
									// free
									free(error_approx_fine8);
									free(error_approx_coarse8);
									free(residual_coarse8);
									free(residual_fine8);
									if (ilevel > 10) {
										// free
										free(error_approx_fine9);
										free(error_approx_coarse9);
										free(residual_coarse9);
										free(residual_fine9);
										if (ilevel > 11) {
											// free
											free(error_approx_fine10);
											free(error_approx_coarse10);
											free(residual_coarse10);
											free(residual_fine10);
											if (ilevel > 12) {
												// free
												 free(error_approx_fine11);
												 free(error_approx_coarse11);
												 free(residual_coarse11);
												 free(residual_fine11);
												if (ilevel > 13) {
													// free
													free(error_approx_fine12);
													free(error_approx_coarse12);
													free(residual_coarse12);
													free(residual_fine12);
													if (ilevel > 14) {
														// free
														free(error_approx_fine13);
														free(error_approx_coarse13);
														free(residual_coarse13);
														free(residual_fine13);
														if (ilevel > 15) {
															// free
															free(error_approx_fine14);
															free(error_approx_coarse14);
															free(residual_coarse14);
															free(residual_fine14);
															if (ilevel > 16) {
																// free
																free(error_approx_fine15);
																free(error_approx_coarse15);
																free(residual_coarse15);
																free(residual_fine15);
																if (ilevel > 17) {
																	// free
																	free(error_approx_fine16);
																	free(error_approx_coarse16);
																	free(residual_coarse16);
																	free(residual_fine16);
																	if (ilevel > 18) {
																		// free
																		free(error_approx_fine17);
																		free(error_approx_coarse17);
																		free(residual_coarse17);
																		free(residual_fine17);

																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}


	//delete[] residual_fine;
	free(residual_fine);

	//delete[] row_ptr_start;
	//delete[] row_ptr_end;
	free(row_ptr_start);
	free(row_ptr_end);


	//delete[] flag_shadow;
	free(flag_shadow);
	
	
	//delete[] flag;
	free(flag);
	free(x_copy);
	free(x_best_search);
	//return false;
	return ret_value;

} // classic_aglomerative_amg2

// 27 янв 2016. Предпринята попытка сделать в точности как у Руге и Штубена. Попытка провалилась.
// Сходимость сильно испорчена.
// 22 января текущий работоспособный вариант кода.
// Планы: 1. сделать версию amg3. 
// В ней: 2. заменить все проверки на невыделение оперативной памяти на универсальную функцию единую для всего.
// это очевидно немного сократит программный код.
// В ней 3. код V цикла оформить в виде цикла for. Тогда же можно будет попробовать вставить direct метод для самого грубого уровня.
// Это же откроет возможности сделать из amg алгоритма предобуславливатель для BiCGStab.
// 15 января экономим память переходим на Ak1.
// 10 января 2016 двоичный поиск заменён на хеширование.
// 15 декабря 2015. Данная версия кода будет полностью очищена от устаревшего кода.
// 13 декабря 2015. Внедрено АВЛ дерево. При внедрении АВЛ дерева исправлена логическая ошибка в
// построении С-F разбиения, теперь C/F разбиение строится корректно.
// Исправлен и внедрён quicksort (qs,qsj)
// который в рять раз быстрее пирамидальной сортировки.
// Полный отказ от band_size!!!.
// Время работы алгоритма на 1.7М неизвестных в 3D составило ровно 1 минуту.
// 18 октября 2015. Полностью работоспособный мультигрид.
// Тестировалось на условиях Дирихле но должно работать на любых 
// краевых задачах. 18 октября датируется версия 0.04. Версия 0.04 на треть
// быстрее версии 0.03. Были ускорены как операции построения C/F разбиения, 
// так и нахождение оператора Галёркина. При нахождении С/F разбиения 
// учитывается уже построенная его часть и поэтому число сканирований на
// на поздних циклах сокращается охватывая только не построенную часть.
// При нахождении произведения Галёркина получена самая оптимальная по быстродействию версия,
// Основанная на алгоритме слияния отсортированных списков.
// 4 октября правильное построение последовательности вложенных графов.
// 30 сентября продолжаем исправление метода. Делаем классический 
// алгебраический многосеточный метод на основе  C/F разбиения.
// 16 сентября 2015 года обнаружено что операции 
// сгрубления и интерполяции сделаны совершенно неверно,
// и если сгрубление еще в какой-то мере проецирует то интерполяция просто никакая.
// Операции сгрубления и интерполяции будут сделаны заново на основе статьи
// К.Н. Волкова в новой версии солвера.
// 3 september 2015 Villa Borgese.
template <typename doublerealT>
integer classic_aglomerative_amg3(Ak1* &Amat,
	integer nsizeA, // количество ячеек выделенное извне для хранилища матриц А
	integer nnz, // number of non zero elements
	integer n, // dimension of vectors x and b.
	Ak1* &R, // restriction
	Ak1* &P, // prolongation
	doublereal* &x, doublereal* &b,
	doublerealT &theta, 
	INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14 imyinit = INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT
	) {

	const bool bprint_mesage_diagnostic = true;

	const integer AVL_TREE_ID = 0;
	const integer SPLAY_TREE_ID = 1;
	integer id_tree = SPLAY_TREE_ID;

	// Надо заменить все new на malloc.
	//theta = 0.25;

	bool bonly_serial = true;
//#ifdef _OPENMP
	//omp_set_num_threads(2);
//#endif

	// barjer=0.0001; optimum. для 1M задач.
	// Для зачачи с 3.2M неизвестных (теплопередача в 5mm СВЧ транзисторе без дырок.)
	// для константы 1.0e-8 получено сокращение времени счёта с 9мин до 4мин (Количество итераций 213 вместо 1003).
	// Пик использования оперативной памяти при этом приложению составил 2373Мб.
	// Для BiCGStab+ILU2 время счёта равно 1мин 50с против 4мин в данной версии алгоритма.
	// 14 января 2016 подобраны оптимальными и равными 1e-7 каждый.
	doublerealT barjer = 1.0e-7; // 1.0e-7 
	doublerealT barjerA = 1.0e-7; // 1.0e-7

	// контроль числа сильных связей между переменными.
	// doublerealT theta = 0.25;  // 0.25 for 2D and 0.5 for 3D 

	// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
	// В компиляторе надо увеличить размер стека до 4Мб.
	bool bqs = true; // Использовать ли quicksort qs and qsj.
	// Сортировка с подсчётом быстрее quickSort.
	bool bCounting_Sort = true; // Использовать ли сортировку подсчётом которая потребляет килотонну памяти (Короче для машин у которых море оперативки).


	const doublerealT RealZERO = 1.0e-300;// 1.0e-10;
	const doublerealT divisionZERO = 1.0e-300;
	const doublerealT RealMAXIMUM = 1.0e300;
	// включение/отключение отладочного режима.
	bool debug_reshime = false;

	const integer max_neighbour = 27850;
	// Мы будем поддерживать информацию о максимальном количестве соседей.
	integer Maximumneighbourcount = -1;
	// мы получим порядковый номер элемента с максимальным число соседей в матрице А,
	// прямо в результате построения C/F разбиения.
	bool bmaxneighbourinfoactive = false;


	// Возможно можно обойтись без ji связи.
	// 17 dec 2015 эксперимент показывает что можно обойтись без учёта ji связи.
	// false без связи. Если false то Atemp вообще ненужен.
	bool bji = false;
	Ak1* Atemp = nullptr;
	if (bji) {
		Atemp = new Ak1[3 * nnz + 1];
	}

	// нумерация начинается с единицы.

	const integer maxlevel = 30;
	integer ilevel = 1;
	integer nnz_a[maxlevel];
	integer n_a[maxlevel];
	nnz_a[0] = nnz;
	n_a[0] = n;
	//bool* flag = new bool[n + 1];
	bool* flag = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(flag, "flag", "classic_aglomerative_amg_3", (n + 1));

	//bool* flag_shadow = new bool[n + 1];
	bool* flag_shadow = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(flag_shadow, "flag_shadow", "classic_aglomerative_amg_3", (n + 1));

	//bool* hash_table = new bool[nnz + 1]; // Огромного размера hash таблица.
	bool* hash_table = (bool*)malloc((nnz + 1)*sizeof(bool));
	handle_error<bool>(hash_table, "hash_table", "classic_aglomerative_amg_3", (nnz + 1));

	// Огромный размер поэтому инициализация делается лишь единожды.
	for (integer isc = 0; isc <= nnz; isc++) hash_table[isc] = false; // initialization 
	const integer istack_size_limit = n + 1; // 128000
	//integer ipool[ipool_size_limit];
	integer* istack = nullptr;
	//istack = new integer[istack_size_limit];
	istack = (integer*)malloc((istack_size_limit)*sizeof(integer));
	handle_error<integer>(istack, "istack", "classic_aglomerative_amg_3", (istack_size_limit));

	// Для построения C/F декомпозиции нам тоже потребуется хеш-таблица
	// и стек для очистки хеш-таблицы.
	bool* hash_table2 = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(hash_table2, "hash_table2", "classic_aglomerative_amg_3", (n + 1));

	// Инициализация.
	for (integer isc = 0; isc <= n; isc++) hash_table2[isc] = false;
	// И теперь стек для очистки хеш-таблицы.
	integer* istack2 = nullptr;
	//istack2 = new integer[n + 1];
	istack2 = (integer*)malloc((n + 1)*sizeof(integer));
	handle_error<integer>(istack2, "istack2", "classic_aglomerative_amg_3", (n + 1));

	integer iadd = 0;
	integer nnzR = 1;
	integer iaddR = 0;
	integer nnz_aRP[maxlevel];
	
	//bool* this_is_C_node = new bool[n + 1];
	//bool* this_is_F_node = new bool[n + 1];
	bool* this_is_C_node = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(this_is_C_node, "this_is_C_node", "classic_aglomerative_amg_3", (n + 1));

	bool* this_is_F_node = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(this_is_F_node, "this_is_F_node", "classic_aglomerative_amg_3", (n + 1));


	while ((ilevel < maxlevel - 1) && (n_a[ilevel - 1] > 50)) {


		/*
		hashlist** hash = new hashlist*[n_a[ilevel - 1]+1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hash[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].i;
		insertion_hash(hash[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hash[i_1]);
		hash[i_1] = 0;
		}
		delete[] hash;

		hashlist** hashj = new hashlist*[n_a[ilevel - 1] + 1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hashj[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].j;
		insertion_hash(hashj[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hashj[i_1]);
		hashj[i_1] = 0;
		}
		delete[] hashj;
		*/


		Maximumneighbourcount = -1;
		bmaxneighbourinfoactive = false;

		//if (ilevel > 1) {
		//if (n_a[ilevel - 2] == n_a[ilevel - 1]) break;
		//}

		if (ilevel > 10) {
			if (n_a[ilevel - 1] < 300) break;
		}

		if (ilevel > 1) {
			doublerealT procent = (100.0*(abs(n_a[ilevel - 1] - n_a[ilevel - 2]))) / (1.0*n_a[ilevel - 2]);
			if (procent<2.0) break;
		}

		if (((ilevel > 1) && (nnz_a[ilevel - 1] > nnz_a[ilevel - 2]))) {
			//break;
		}

#if doubleintprecision == 1
		if (bprint_mesage_diagnostic) {
			// level info.
			if (ilevel == 2) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld nnz_a[0]=%lld nnz_a[1]=%lld iadd=%lld\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 3) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld iadd=%lld\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 4) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld n_a[3]=%lld \n", n_a[0], n_a[1], n_a[2], n_a[3]);
				printf("nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld nnz_a[3]=%lld iadd=%lld\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if (ilevel > 17) {
				printf("very big matrix (mesh). no programming.\n");
				system("pause");
				exit(1);
			}
		}
#else
		if (bprint_mesage_diagnostic) {
			// level info.
			if (ilevel == 2) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d nnz_a[0]=%d nnz_a[1]=%d iadd=%d\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 3) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d iadd=%d\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 4) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d n_a[3]=%d \n", n_a[0], n_a[1], n_a[2], n_a[3]);
				printf("nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d nnz_a[3]=%d iadd=%d\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if (ilevel > 17) {
				printf("very big matrix (mesh). no programming.\n");
				system("pause");
				exit(1);
			}
		}
#endif

		

		//nnzR = 1;

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		for (integer ii = n_a[ilevel - 1]; ii <= n; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		// Сортировка нужна лишь на первом уровне, т.к.
		// результат алгоритма перемножения по Густавсону уже 
		// даёт на выходе отсортированную по строкам матрицу.
		if (ilevel == 1) {
			// сортировка исходной  А  по i.
			//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1], comparei);


			// 7 января 2016. Обязательно нужна эта сортировка.
			if (bqs) {
				if (bCounting_Sort) {
					Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, true, indx_comparei);
				}
				else {
					// quicksort
					qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparei);
				}
			}
			else {
				HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);
			}
			//QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);
		}





		if (bji) {
			// Создаём копию в Atemp, копия будет отсортирована по j.
			for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
				Atemp[i_1 - iadd] = Amat[i_1];
			}
			// Сортируем копию по j.
			// Мы сортируем по j, чтобы потом быстро искать по j.
			if (bqs) {
				if (bCounting_Sort) {
					// Сортировка с подсчётом за линейное время.
					Counting_Sort(Atemp, 1, nnz_a[ilevel - 1], indx_comparej);
				}
				else {
					// Быстрая сортировка Чарльза Хоара.
					qs(Atemp, 1, nnz_a[ilevel - 1], indx_comparej);
				}
			}
			else {
				HeapSort(Atemp, 1, nnz_a[ilevel - 1], comparej);
			}
		}

		for (integer i_1 = 1; i_1 <= n; i_1++) {
			flag[i_1] = false;
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}

		// позиция начала каждой строки в матрице.
		integer* row_startA = nullptr;
		//row_startA = new integer[n_a[ilevel - 1] + 1];
		row_startA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_startA, "row_startA", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				flag[Amat[ii].i] = true;
				row_startA[Amat[ii].i] = ii;
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}


		// вычисляем для кадого узла число его соседей.
		integer* count_neighbour = nullptr;
		//count_neighbour = new integer[n_a[ilevel - 1] + 1];
		count_neighbour = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(count_neighbour, "count_neighbour", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			count_neighbour[ii] = 0; // нет соседей.
		}




		// При таком коде узел Дирихле тоже имеет соседа, сосед это 
		// внутренний узел который связан с этим узлом Дирихле.
		// Соседей вычисляем на самой первой матрице А (самой левой).
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer ic = -1;
				integer cand[max_neighbour];
				if (0) {
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						ic++; //i,j
						cand[ic] = Amat[is0].j;
					}
				}
				else {
					// 12 января 2016.
					// Учитываем только Strong соседей.
					doublerealT threshold = -1.0;
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						if (Amat[is0].j != Amat[ii].i) {
							if (fabs(Amat[is0].aij) > threshold) {
								// Определяем максимальный внедиагональный элемент.
								threshold = fabs(Amat[is0].aij);
							}
						}
					}
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						if (Amat[is0].j != Amat[ii].i) {
							if (fabs(Amat[is0].aij) > theta*threshold) {
								// Учитываем только сильно связанных соседей.
								ic++; //i,j
								cand[ic] = Amat[is0].j;
							}
						}
					}
				}
				integer len_neighbour = ic;
				// Найти столбец j который равен индексу Amat[ii].i
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//if (Amat[ii1].i != Amat[ii].i) {
				//	if (Amat[ii1].j == Amat[ii].i) {
				// j,i
				//		bool foundneighbour = false;
				//		for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
				//			if (Amat[ii1].j == cand[i_1]) foundneighbour = true;
				//		}
				//		if (!foundneighbour) {
				//			ic++;
				//			cand[ic] = Amat[ii1].j;
				//			len_neighbour++;
				//		}
				//	}
				//}
				//}
				if (bji) {
					// Ускоренная версия с бинарным поиском по j.
					integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
					for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == Amat[ii].i); ii1++) {
						if (Atemp[ii1].i != Amat[ii].i) {
							// j,i
							bool foundneighbour = false;
							for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
								if (Atemp[ii1].j == cand[i_1]) foundneighbour = true;
							}
							if (!foundneighbour) {
								ic++;
								cand[ic] = Atemp[ii1].j;
								len_neighbour++;
							}
						}
					}
				}


				count_neighbour[Amat[ii].i] = ic;
				if (ic > Maximumneighbourcount) {
					Maximumneighbourcount = ic;
					bmaxneighbourinfoactive = true;
				}
				flag[Amat[ii].i] = true;
			}
		}



		integer maxneighbour = 0;
		integer icandidate = 0;
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}
		// Находим узел с наибольшим числом соседей и запоминаем его.
		// Это первый встретившийся узел с наибольшим числом соседей.
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				if (count_neighbour[Amat[ii].i] > maxneighbour) {
					maxneighbour = count_neighbour[Amat[ii].i];
					icandidate = ii;
					if (bmaxneighbourinfoactive) {
						// организуем досрочный выход из цикла for.
						// Это должно сильно сокращать количество сканирований.
						if (maxneighbour == Maximumneighbourcount) break;
					}
				}
				flag[Amat[ii].i] = true;
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}


		// нужно выделить кто попал в coarse, а кто в этот раз попал в Fine Выделить всех кто соседствует
		// с новыми Fine увеличить им счётчик соседей.

		integer n_coarce = 1; // начальный номер C узла.
		nnzR = 1;

		const integer NULL_NEIGHBOUR = -1;
		integer vacant = NULL_NEIGHBOUR;
		bool bcontinue = true;

		// Построение C/F разбиения.
		//while (icandidate != 0)
		integer icountprohod = 0;
		// Мы будем заоминать с какой позиции начинаются ещё не помеченные узлы,
		// это сократит количество перебираемых элементов в поиске узла с максимальным 
		// количеством соседей.
		// integer ibegining_start_index_found_maximum = 1 + iadd;
		// храним те узлы которые уже были пройдены при конструировании.
		bool *bmarkervisit = nullptr;
		//bmarkervisit = new bool[n + 1];
		bmarkervisit = (bool*)malloc((n + 1)*sizeof(bool));
		handle_error<bool>(bmarkervisit, "bmarkervisit", "classic_aglomerative_amg_3", (n + 1));

		// поначалу все узлы помечены как непосещенные.
		for (integer i_1 = 1; i_1 <= n; i_1++) bmarkervisit[i_1] = false;



		// увеличение быстродействия достигается 
		// сокращением пределов сканирования
		// здесь хранится индекс начала сканирования flag.
		integer istartflag_scan = 1;


		// if (bAVL) работа на основе АВЛ дерева.
		bool bAVL = true;
		bool bAVL_deb = false;
		node_AVL* root = 0;
		Tree_splay* root_splay = 0;
		size_splay_Tree = 0;

		integer newCcount = 0;




		while (bcontinue)
		{


#if doubleintprecision == 1
			//printf("prohod count number %lld\n", icountprohod);
#else
			//printf("prohod count number %d\n", icountprohod);
#endif
			


			integer set[max_neighbour]; // не более 20 узлов в одном агрегате.
			integer set17[max_neighbour]; // для новой ветки кода.
			// инициализация убрана потому что она не нужна и она сильно тормозит быстродействие.
			//for (integer js = 0; js < max_neighbour; js++) {
			//set[js] = NULL_NEIGHBOUR;
			//}
			integer ic = 0;

			integer ii = icandidate;
			if (flag[Amat[ii].i] == false) {

				ic = 0; // Обязательная инициализация.
				set[ic] = Amat[ii].i;



				this_is_C_node[set[0]] = true;
				bmarkervisit[set[0]] = true;

				doublerealT max_vnediagonal = -1.0; // максимальное значение модуля вне диагонального элемента. 
				// добавляем диагональный элемент.
				// узел set[0]==Amat[is0].i.
				// Нахождение значения максимального внедиагольного элемента, с 
				// учётом того что даже узел Дирихле связан с одним внутренним узлом расчётной области.
				// 17 января 2016 правильное определение максимального внедиагонального элемента.
				// Обязательная перемотка в самое начало строки.
				integer ii_back = ii;
				while ((ii_back > iadd) && (Amat[ii_back].i == set[0])) ii_back--;
				ii_back++;

				doublerealT max_vnediagonal1 = -1.0;
				doublerealT min_vnediagonal1 = 1.0e30;
				doublerealT counter_vnediagonal = 0.0;
				doublerealT avg_vnediagonal1 = 0.0;

				// Если делать по максимальному внедиагональному элементу то мы получим очень много элементов на грубых уровнях,
				// и чрезвычайно медленную сходимость.

				for (integer is0 = ii_back; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
					if (Amat[is0].j != set[0]) {
						counter_vnediagonal = counter_vnediagonal + 1.0;
						avg_vnediagonal1 += fabs(Amat[is0].aij);
						if (fabs(Amat[is0].aij) > max_vnediagonal1) {
							max_vnediagonal1 = fabs(Amat[is0].aij); //i,j
							// Большое количество элементов на грубых уровнях,
							// очень медленная сходимость.
							//if (Amat[is0].j == set[0]) break; 
						}
						if (fabs(Amat[is0].aij) < min_vnediagonal1) {
							min_vnediagonal1 = fabs(Amat[is0].aij); //i,j

						}
					}
				}
				if (fabs(counter_vnediagonal) > 0.5) {
					avg_vnediagonal1 = avg_vnediagonal1 / counter_vnediagonal;
				}
				else {
					avg_vnediagonal1 = max_vnediagonal1;
				}
				//max_vnediagonal = avg_vnediagonal1;
				// Только сильные связи станут F узлами.
				max_vnediagonal = max_vnediagonal1;  // 1
				//max_vnediagonal = 0.5* avg_vnediagonal1 + 0.5*max_vnediagonal1;
				//max_vnediagonal = avg_vnediagonal1 + 0.05*(max_vnediagonal1 - avg_vnediagonal1);
				// наиболее близка к оптимальной. -85%. но несомненно лучше max_vnediagonal = -1.0;
				//max_vnediagonal = avg_vnediagonal1 - 0.85*(avg_vnediagonal1 - min_vnediagonal1);
				// 19 января 2016 установлено что важды все связы, не нужно учитывать threshold
				// max_vnediagonal должно быть -1.0. Именно это значение обеспечивает наилучшую 
				// скорость агломерации и наилучшую скорость сходимости.
				//max_vnediagonal = -1.0;  // все связи!!!

				/*
				// Лишний код 19 января 2016.
				for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
				if (Amat[is0].j == set[0]) {

				// Из-за этого прерывания максимальный внедиагональный элемент может быть определён неверно.
				// поэтому смотри цикл выше от 17 января 2016 по правильному определению максимального внедиагонального элемента.
				break;
				}
				else {
				if (fabs(Amat[is0].aij) > max_vnediagonal) {
				// При стабильной версии требуется расскоментировать
				// 19 jan 2016.
				//max_vnediagonal = fabs(Amat[is0].aij); //i,j
				}
				}

				// Этот цикл является добавочным.
				// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
				// Медленный линейный поиск.
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//if (Amat[ii1].i != set[0]) {
				//if (!flag[Amat[ii1].i]) {
				//	if (Amat[ii1].j == set[0]) {
				//		if (fabs(Amat[ii1].aij) > max_vnediagonal) {
				//			max_vnediagonal = fabs(Amat[ii1].aij); //j,i
				//		}
				//	}
				//}
				//}
				//}

				if (bji) {
				// Этот цикл является добавочным.
				// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
				// Ускоренная версия на основе двоичного поиска.
				integer ii2 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
				for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == set[0]); ii1++)
				{
				if (Atemp[ii1].i != set[0]) {
				if (!flag[Atemp[ii1].i]) {
				if (fabs(Atemp[ii1].aij) > max_vnediagonal) {
				max_vnediagonal = fabs(Atemp[ii1].aij); //j,i
				}
				}
				}
				}
				}


				}
				*/

				ic++;



				// если узел j ещё не был добавлен в агрегат.
				if (flag[Amat[ii].j] == false) {
					if ((Amat[ii].j != set[0]) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
						vacant = Amat[ii].j;
						for (integer js = 0; js < ic; js++) {
							if (vacant == set[js]) {
								vacant = NULL_NEIGHBOUR;
							}
						}
						if (vacant != NULL_NEIGHBOUR) {
							set[ic] = vacant;

							ic++;
						}
					}
				}
				//integer iscan = ii + 1;
				integer iscan = ii_back; // важная модификация 19 января 2016г.
				// TODO 19 jan 2016.
				while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set[0])) {
					// если узел j ещё не был добавлен в агрегат.
					if (flag[Amat[iscan].j] == false) {
						if ((Amat[iscan].j != set[0]) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
							vacant = Amat[iscan].j;
							for (integer js = 0; js < ic; js++) {
								if (vacant == set[js]) {
									vacant = NULL_NEIGHBOUR;
								}
							}
							if (vacant != NULL_NEIGHBOUR) {
								set[ic] = vacant;

								ic++;

							}
						}
					}

					iscan++;

				} // while

				// Это была учтена только связь i,j



				// Учёт свяи j,i
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
				//if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
				//if (!flag[Amat[ii1].i]) {
				//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
				//	vacant = Amat[ii1].i;
				//	for (integer js = 0; js < ic; js++) {
				//		if (vacant == set[js]) {
				//			vacant = NULL_NEIGHBOUR;
				//		}
				//	}
				//	if (vacant != NULL_NEIGHBOUR) {
				//		set[ic] = vacant; // j,i связь.

				//		ic++;
				//	}
				//	}
				//}
				//}
				//}

				// Учёт связи j,i
				// Медленная версия на основе линейного поиска.
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
				//if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
				//if (!flag[Amat[ii1].i]) {
				//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
				//	vacant = Amat[ii1].i;
				//	for (integer js = 0; js < ic; js++) {
				//		if (vacant == set[js]) {
				//			vacant = NULL_NEIGHBOUR;
				//		}
				//	}
				//	if (vacant != NULL_NEIGHBOUR) {
				//		set[ic] = vacant; // j,i связь.

				//		ic++;
				//	}
				//}
				//}
				//}
				//}

				if (bji) {
					// Учёт свяи j,i
					// Более быстрая версия на основе двоичного поиска.
					integer ii1 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
					for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1]) && (Atemp[ii2].j == set[0]); ii2++) {
						if ((Atemp[ii2].i != set[0]) && (!flag[Atemp[ii2].i])) {
							if (fabs(Atemp[ii2].aij) >= theta*max_vnediagonal) {
								vacant = Atemp[ii2].i;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_NEIGHBOUR;
									}
								}
								if (vacant != NULL_NEIGHBOUR) {
									set[ic] = vacant; // j,i связь.
									ic++;
								}
							}
						}
					}


				}


				for (integer isc = 1; isc < ic; isc++) {
					this_is_F_node[set[isc]] = true; // это только новые F узлы.
					bmarkervisit[set[isc]] = true;
				}




				// Помечаем узлы как включённые в агрегат.
				for (integer js = 0; js < ic; js++) {
					flag[set[js]] = true;
				}






				// Алгоритм (5 декабря 2015 revised) 
				// 1. Сканируем все F которые соседи данного С на данном проходе.
				// 2. Для каждого фиксированного F сканируем его "строчных" соседей.
				// 3. Если узел еще не был включён в агрегат то ищем всех соседей данного узла на предмет 
				// соседства с фиксированным набором F из пункта 1.



				if (bAVL) {
					// 12 декабря 2015.
					// Надо удалить из АВЛ дерева C и F узлы.
					// Это удаление очищает АВЛ дерево и приводит его к
					// рабочему состоянию. Удаление несуществующих в дереве узлов
					// производится корректно. Удаление производится за логарифмическое
					// по основанию 2  время от количества элементов в дереве
					// сбалансированность дерева при этом сохраняется.
					for (integer js = 0; js < ic; js++) {
						data_BalTree ddel;
						ddel.i = set[js];
						ddel.count_neighbour = count_neighbour[set[js]];
						//ddel.ii = row_startA[ddel.i];
						switch (id_tree) {
						case AVL_TREE_ID: root = remove_AVL(root, ddel);
							break;
						case SPLAY_TREE_ID: root_splay = delete_splay_Tree(ddel, root_splay);
							break;
						default: root = remove_AVL(root, ddel);
							break;
						}

						if (bAVL_deb)
						{
							printf("remove\n");
						}
					}
				}


				//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
				//flag_shadow[i_1] = flag[i_1];
				//}



				//integer i3 = 1;
				//while ((i3 <= n_a[ilevel - 1]) && (row_startA[i3] < istart)) i3++;
				//integer i4 = n_a[ilevel - 1];
				//while ((i4 >= 1) && (row_startA[i4]>iend)) i4--;


				// Ищем только среди ближайшего окружения вновь добавленного F узла.
				//for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {

				// Старая реализация которой присуща большая нагрузка на операторы new && delete.
#if 0
				if (0) {
					for (integer js = 1; js < ic; js++) {

						// см. новый вариант от 10 января 2016.

						// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
						// элемент lsos_head;
						List *lsos = nullptr;
						List *lsos_head = nullptr;
						lsos = new List;
						lsos->prev = nullptr;
						lsos_head = lsos;
						{
							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart2 = ii_11;
							while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_11].i)) istart2--;
							istart2++;
							bool bvisitsos = false;
							for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (flag[Amat[is0].j] == false) {
									lsos->next = nullptr;
									lsos->i = Amat[is0].j;
									lsos->ii = row_startA[lsos->i];
									// lsos->count_neighbour // не используется.
									List *newnodesos = new List;
									newnodesos->prev = lsos;
									lsos->next = newnodesos;
									newnodesos->next = nullptr;
									lsos = lsos->next;
									newnodesos = nullptr;
									bvisitsos = true;
								}
							}
							if (bvisitsos) {

								List *delsos = lsos;
								lsos = lsos->prev;
								lsos->next = nullptr;
								delsos->prev = nullptr;
								delete delsos;
								delsos = nullptr;
							}
							else {
								// Нет ни одного соседа
								lsos_head = nullptr;
								delete lsos;
								lsos = nullptr;
							}
						}

						lsos = lsos_head;
						// ищем соседа узла set[js].
						//for (integer i5 = i3; i5 <= i4; i5++) {
						while (lsos != nullptr) {


							//integer isc = Amat[ii_2].i;
							//integer ii_2 = row_startA[i5];
							//integer ii_2 = BinarySearchAi(Amat, i5, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							//integer isc = i5;

							integer isc = lsos->i;
							integer ii_2 = lsos->ii;


							//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
							//if (flag[isc] == false) {
							//flag_shadow[isc] = true;
							integer ic2 = 0;
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart2 = ii_2;
							while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
							istart2++;
							for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_2].i); is0++) {
								if (Amat[is0].j == set[js]) {
									ic2++;
								}
							}

							data_BalTree dsearch;
							dsearch.count_neighbour = count_neighbour[isc];
							//dsearch.ii = ii_2;
							dsearch.i = isc;
							count_neighbour[isc] += ic2;
							data_BalTree dadd;
							dadd.count_neighbour = count_neighbour[isc];
							//dadd.ii = ii_2;
							dadd.i = isc;
							if (bmaxneighbourinfoactive) {
								// Обновляем информацию о максимальном количестве соседей.
								if (count_neighbour[isc] >= Maximumneighbourcount) {
									Maximumneighbourcount = count_neighbour[isc];
								}

								// Добавляем соседа в любом случае
								// позволило существенным образом 
								// ускорить алгоритм. Если раньше 
								// old = 48595  | 21229
								// new = 433315 | 63031
								// new2 = 19434 | 3698
								// и основное время уходило на old
								// то теперь
								// old = 1449 | 1466
								// new = 472600 | 64525
								// new2= 56544 | 18431
								// Время решения 3D задачи с 1M неизвестными 
								// сократилось с 6мин 48с до 4мин 45с.

								if (bAVL) {

									// добавляем элемент в АВЛ дерево,
									// причём если элемент уже находился в дереве то он модифицируется.
									// 12 декабря 2015.
									// Добавление узла происходит за логарифмическое по основанию 2 время,
									// причём после добавления дерево остаётся сбалансированным.
									// Адельсон-Вельский и Ландис 1962.
									switch (id_tree) {
									case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
									case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
										break;
									default: root = insert_and_modify(root, dadd, dsearch);
										break;
									}

									if (bAVL_deb)
									{
										printf("insert and modify\n");
									}
								}


							}
							//}
							lsos = lsos->next;
						}

						// Уничтожение lsos
						// Список постепенно уничтожается с головы.
						lsos = lsos_head;
						while (lsos != nullptr) {
							lsos_head = lsos_head->next;
							if (lsos_head != nullptr) {
								lsos_head->prev = nullptr;
							}
							lsos->next = nullptr;
							delete lsos;
							lsos = lsos_head;
						}

					}
				}
				else if (0) {
					for (integer js = 1; js < ic; js++) {

						// см.ниже  новый вариант от 10 января 2016.
						// 7 января 2016.
						// Новая версия в которой я избавился от лишних оператров new&&delete.
						// Никаких дублирующих линейных списков, никаких операторов new && delete.
						// Код стал намного понятнее.

						// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
						// элемент lsos_head;
						{
							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (flag[Amat[is0].j] == false) {


									integer isc = Amat[is0].j;
									integer ii_2 = row_startA[isc];

									//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
									//if (flag[isc] == false) {
									//flag_shadow[isc] = true;
									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									istart2++;
									for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
										if (Amat[is01].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.count_neighbour = count_neighbour[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									count_neighbour[isc] += ic2;
									data_BalTree dadd;
									dadd.count_neighbour = count_neighbour[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;
									if (bmaxneighbourinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_neighbour[isc] >= Maximumneighbourcount) {
											Maximumneighbourcount = count_neighbour[isc];
										}

										// Добавляем соседа в любом случае
										// позволило существенным образом 
										// ускорить алгоритм. Если раньше 
										// old = 48595  | 21229
										// new = 433315 | 63031
										// new2 = 19434 | 3698
										// и основное время уходило на old
										// то теперь
										// old = 1449 | 1466
										// new = 472600 | 64525
										// new2= 56544 | 18431
										// Время решения 3D задачи с 1M неизвестными 
										// сократилось с 6мин 48с до 4мин 45с.

										if (bAVL) {

											// добавляем элемент в АВЛ дерево,
											// причём если элемент уже находился в дереве то он модифицируется.
											// 12 декабря 2015.
											// Добавление узла происходит за логарифмическое по основанию 2 время,
											// причём после добавления дерево остаётся сбалансированным.
											// Адельсон-Вельский и Ландис 1962.
											switch (id_tree)
											{
											case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
											case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch); break;
											default: root = insert_and_modify(root, dadd, dsearch);
												break;
											}

											if (bAVL_deb)
											{
												printf("insert and modify\n");
											}
										}


									}

								}
							}

						}
					}

				}
				else if (0) {
					// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;
								integer ii_2 = row_startA[isc];

								// При таком подходе некоторые соседи инкрементируются дважды и это
								// даёт хорошую скорость агломерации. Хватает 4 кратного размера памяти под исходную матриу.
								// Количество повторно инкрементируемых узлов составило около 33% в 2D на пятиточечном шаблоне.
								// Было решено оставить этот вариант кода т.к. он даёт хорошую скорость агломерации.


								integer ic2 = 0;
								integer iend2loc = nnz_a[ilevel - 1] + iadd;
								integer istart2 = ii_2;
								while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
								istart2++;
								for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
									if (Amat[is01].j == set[js]) {
										ic2++;
									}
								}

								data_BalTree dsearch;
								dsearch.count_neighbour = count_neighbour[isc];
								//dsearch.ii = ii_2;
								dsearch.i = isc;
								count_neighbour[isc] += ic2;
								data_BalTree dadd;
								dadd.count_neighbour = count_neighbour[isc];
								//dadd.ii = ii_2;
								dadd.i = isc;

								if (bAVL) {

									// добавляем элемент в АВЛ дерево,
									// причём если элемент уже находился в дереве то он модифицируется.
									// 12 декабря 2015.
									// Добавление узла происходит за логарифмическое по основанию 2 время,
									// причём после добавления дерево остаётся сбалансированным.
									// Адельсон-Вельский и Ландис 1962.
									switch (id_tree)
									{
									case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
										break;
									case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
										break;
									default: root = insert_and_modify(root, dadd, dsearch);
										break;
									}

									if (bAVL_deb)
									{
										printf("insert and modify\n");
									}
								}

								if (bmaxneighbourinfoactive) {
									// Обновляем информацию о максимальном количестве соседей.
									if (count_neighbour[isc] >= Maximumneighbourcount) {
										Maximumneighbourcount = count_neighbour[isc];
									}
								}

							}

						}
					}
				}
				else if (0) {
					// 10 января 2016. Новая логика.
					// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
					// Эта модификация даёт сокращение количества V циклов которые требуются до сходимости
					// Эта модификация наиболее близка к классической описанной в литературе чем все предыдущие.
					// На момент 13 января 2016 это лучший вариаент по скорости вычислений.
					integer itop_stack2 = 0;

					// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;

								// Избавляемся от повторных инкрементаций.
								// В 2D на пятиточечном шаблоне повторные инкрементации составляют
								// около 33%.
								// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
								// на ряде тестовых задач при таком подходе агломерация проходила очень
								// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
								// Эта проблема проявилась на задачах:
								// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
								// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
								// Проблема не в этом месте кода.
								if (hash_table2[isc] == false) {
									hash_table2[isc] = true;
									istack2[itop_stack2] = isc;
									itop_stack2++;

									integer ii_2 = row_startA[isc];


									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									istart2++;
									for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
										if (Amat[is01].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.count_neighbour = count_neighbour[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									count_neighbour[isc] += ic2;
									data_BalTree dadd;
									dadd.count_neighbour = count_neighbour[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;

									if (bAVL) {

										// добавляем элемент в АВЛ дерево,
										// причём если элемент уже находился в дереве то он модифицируется.
										// 12 декабря 2015.
										// Добавление узла происходит за логарифмическое по основанию 2 время,
										// причём после добавления дерево остаётся сбалансированным.
										// Адельсон-Вельский и Ландис 1962.
										switch (id_tree)
										{
										case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
											break;
										case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
											break;
										default: root = insert_and_modify(root, dadd, dsearch);
											break;
										}
										if (bAVL_deb)
										{
											printf("insert and modify\n");
										}
									}

									if (bmaxneighbourinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_neighbour[isc] >= Maximumneighbourcount) {
											Maximumneighbourcount = count_neighbour[isc];
										}
									}
								}

							}

						}
					}

					// Очистка (восстановление хеш-таблицы).
					for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
						hash_table2[istack2[i_54]] = false;
					}
					itop_stack2 = 0; // стек снова готов к работе.


				} // the end
				else 
#endif
{
					// 27 января 2016.
					// 13 января 2016. Новая логика.
					// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
					// Отличие в том что мы учитываем лишь Strong связи при инкрементации счётчика.
					// Это привело к 5 уровням вместо 13, и очень медленной сходимости.
					// Это было при magic=0.4
					// Strong связи при инкрементации счётчика не подходят по причине низкой производительности. 13 января 2016.
					integer itop_stack2 = 0;

					// На основе  старого варианта просто очищенного от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						doublerealT threshold9 = -1.0;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (Amat[is0].j != Amat[ii_11].i) {
								if (fabs(Amat[is0].aij) > threshold9) {
									threshold9 = fabs(Amat[is0].aij);
								}
							}
						}

						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (fabs(Amat[is0].aij) > theta*threshold9) {
								if (flag[Amat[is0].j] == false) {

									// Здесь только сильные соседи Strong F.
									// Данного соседа инкрементируем на количество сильных связей с новыми F узлами.
									integer isc = Amat[is0].j;

									// Избавляемся от повторных инкрементаций.
									// В 2D на пятиточечном шаблоне повторные инкрементации составляют
									// около 33%.
									// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
									// на ряде тестовых задач при таком подходе агломерация проходила очень
									// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
									// Эта проблема проявилась на задачах:
									// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
									// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
									// Проблема не в этом месте кода.
									if (hash_table2[isc] == false) {
										hash_table2[isc] = true;
										istack2[itop_stack2] = isc;
										itop_stack2++;

										integer ii_2 = row_startA[isc];


										integer ic2 = 0;
										integer iend2loc = nnz_a[ilevel - 1] + iadd;
										integer istart2 = ii_2;
										while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
										istart2++;
										// Определяем модуль максимального внедиагонального элемента.
										doublerealT threshold_loc1 = -1.0; // инициализация порога.
										for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
											// Только внедиагональные элементы.
											if (Amat[is01].j != Amat[ii_2].i) {
												if (fabs(Amat[is01].aij) > threshold_loc1) {
													threshold_loc1 = fabs(Amat[is01].aij);
												}
											}
										}
										//threshold_loc1 = -1; // 27 фнваря 2016.
										for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
											// Только внедиагональные элементы.
											if (Amat[is01].j != Amat[ii_2].i) {
												if (Amat[is01].j == set[js]) {
													// только Strong связи
													// по крайней мере именно так рекомендуют в литературе.
													if (fabs(Amat[is01].aij) > theta*threshold_loc1) {
														ic2++;
													}
												}
											}
										}

										if (ic2 > 0) {
											// Только если были Strong связи приводящие к инкрементации счётчика ic2.


											data_BalTree dsearch;
											dsearch.count_neighbour = count_neighbour[isc];
											//dsearch.ii = ii_2;
											dsearch.i = isc;
											count_neighbour[isc] += ic2;
											data_BalTree dadd;
											dadd.count_neighbour = count_neighbour[isc];
											//dadd.ii = ii_2;
											dadd.i = isc;

											if (bAVL) {

												// добавляем элемент в АВЛ дерево,
												// причём если элемент уже находился в дереве то он модифицируется.
												// 12 декабря 2015.
												// Добавление узла происходит за логарифмическое по основанию 2 время,
												// причём после добавления дерево остаётся сбалансированным.
												// Адельсон-Вельский и Ландис 1962.
												switch (id_tree)
												{
												case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
													break;
												case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
													break;
												default: root = insert_and_modify(root, dadd, dsearch);
													break;
												}
												if (bAVL_deb)
												{
													printf("insert and modify\n");
												}
											}
										}

										if (bmaxneighbourinfoactive) {
											// Обновляем информацию о максимальном количестве соседей.
											if (count_neighbour[isc] >= Maximumneighbourcount) {
												Maximumneighbourcount = count_neighbour[isc];
											}
										}
									}

								}
							}

						}
					}

					// Очистка (восстановление хеш-таблицы).
					for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
						hash_table2[istack2[i_54]] = false;
					}
					itop_stack2 = 0; // стек снова готов к работе.



					if (1) {
						// set17
						// актуален ли ii_back
						integer ic17 = 0;
						integer vacant17;

						// Декрементация счётчиков в дереве для Weakly связей.
						// если узел j ещё не был добавлен в агрегат.
						if (flag[Amat[ii].j] == false) {
							if ((Amat[ii].j != set[0]) && (fabs(Amat[ii].aij) < theta*max_vnediagonal)) {
								vacant17 = Amat[ii].j;
								if (ic17 > 0) {
									for (integer js = 0; js < ic17; js++) {
										if (vacant17 == set17[js]) {
											vacant17 = NULL_NEIGHBOUR;
										}
									}
								}
								if (vacant17 != NULL_NEIGHBOUR) {
									set17[ic17] = vacant17;

									ic17++;
								}
							}
						}
						//integer iscan17 = ii + 1;
						integer iscan17 = ii_back; // важная модификация 19 января 2016г.
						// TODO 19 jan 2016.
						while ((iscan17 <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan17].i == set[0])) {
							// если узел j ещё не был добавлен в агрегат.
							if (flag[Amat[iscan].j] == false) {
								if ((Amat[iscan].j != set[0]) && (fabs(Amat[iscan].aij) < theta*max_vnediagonal)) {
									vacant17 = Amat[iscan].j;
									for (integer js = 0; js < ic; js++) {
										if (vacant17 == set17[js]) {
											vacant17 = NULL_NEIGHBOUR;
										}
									}
									if (vacant != NULL_NEIGHBOUR) {
										set17[ic17] = vacant;

										ic17++;

									}
								}
							}

							iscan17++;

						} // while


						// Декрементация счётчика для всех Weakly соседей нового узла С.
						// Нужно декремировать счётчик для всех <ic17 в set17.
						// flag == false гарантировал что узлы еще не были добавлены в агломераты.

						for (integer js = 0; js < ic17; js++) {
							integer isc17 = set17[js];
							data_BalTree dsearch;
							dsearch.count_neighbour = count_neighbour[isc17];
							//dsearch.ii = ii_2;
							dsearch.i = isc17;
							bool foundnow = false;
							switch (id_tree)
							{
							case AVL_TREE_ID: foundnow = isfound(root, dsearch);
								break;
							case SPLAY_TREE_ID: foundnow = isfound(root_splay, dsearch);
								break;
							default: foundnow = isfound(root, dsearch);
								break;
							}
							
							if (foundnow) {
								data_BalTree  dadd;
								// декрементация счётчика для всех Weakly соседей нового С узла.
								dadd.count_neighbour = count_neighbour[isc17] - 1;
								count_neighbour[isc17]--;
								dadd.i = isc17;
								switch (id_tree)
								{
								case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
									break;
								case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
									break;
								default: root = insert_and_modify(root, dadd, dsearch);
									break;
								}
							}
							

						}
						

					}

				}

				

				n_coarce++; // Увеличено количество С узлов.

				// Один агрегат создан.

			} // узел не был ещё включён в агрегат.



			bcontinue = false;
			for (integer i_1 = istartflag_scan; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (flag[i_1] == false) {
					bcontinue = true;
					istartflag_scan = i_1; // сокращаем пределы сканирования.
					break; // досрочный выход из цикла for.
					//if (maxneighbour == -1) {
#if doubleintprecision == 1
					//printf("ERROR!!!!  i_1=%lld\n", i_1);
#else
					//printf("ERROR!!!!  i_1=%d\n", i_1);
#endif
					
					//system("pause");
					//}
				}
			}

			// Вычисление узла с максимальным количеством соседей.
			maxneighbour = -1;
			icandidate = 0;


			// TODO 6 november
			//integer isize_p = -1;
			/*
			if (0) {

			// На основе линейного поиска (медленный вариант на больших размерностях).

			const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			integer* ipool = new integer[ipool_size_limit];

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			if (i_7 < ipool_size_limit) {
			if (ipool[i_7] == icandidateq) {
			found1 = true;
			}
			}
			else {
			#if doubleintprecision == 1
				printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			system("pause");
			exit(1);
			}
			}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;
			if (isize_p < ipool_size_limit) {
			ipool[isize_p] = icandidateq;
			}
			else {
			#if doubleintprecision == 1
				printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			system("pause");
			exit(1);
			}
			}
			ii_c++;
			}
			}
			delete[] ipool;

			}
			else if (0){

			// 4 января 2016. Медленный линейный поиск заменён на обработку АВЛ дерева.

			// На основе АВЛ дерева.
			//const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			//integer* ipool = new integer[ipool_size_limit];

			node_AVL_Gus* root_Gus = 0;

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			found1 = isfound_Gus(root_Gus, icandidateq);
			//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			//if (i_7 < ipool_size_limit) {
			//if (ipool[i_7] == icandidateq) {
			//found1 = true;
			//}
			//}
			//else {
			#if doubleintprecision == 1
				//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			//}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;

			root_Gus = insert_Gus(root_Gus, icandidateq);

			//if (isize_p < ipool_size_limit) {
			//ipool[isize_p] = icandidateq;
			//}
			//else {
			#if doubleintprecision == 1
				//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			}
			ii_c++;
			}
			}
			//delete[] ipool;
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

			// На основе сбалансированного АВЛ дерева поиска.
			}
			else {

			// 6 января 2016. Медленный линейный поиск заменён на обработку hash таблицы.

			// На основе hash таблицы.
			//const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			//integer* ipool = new integer[ipool_size_limit];

			//node_AVL_Gus* root_Gus = 0;
			// Нельзя это вызывать это очень медленно.
			//for (integer isc = 0; isc <= nnz_a[ilevel - 1]; isc++) hash_table[isc] = false; // initialization
			integer itop = 0; // указатель на вершину стека.

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			//found1 = isfound_Gus(root_Gus, icandidateq);
			found1 = hash_table[icandidateq - iadd];

			//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			//if (i_7 < ipool_size_limit) {
			//if (ipool[i_7] == icandidateq) {
			//found1 = true;
			//}
			//}
			//else {
			#if doubleintprecision == 1
				//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			//}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;

			//root_Gus = insert_Gus(root_Gus, icandidateq);
			hash_table[icandidateq - iadd] = true;
			if (itop < istack_size_limit ) {
			istack[itop] = icandidateq - iadd;
			itop++;
			}
			else {
			printf("itop>=istack_size_limit need to increase istack_size_limit");
			}

			//if (isize_p < ipool_size_limit) {
			//ipool[isize_p] = icandidateq;
			//}
			//else {
			#if doubleintprecision == 1
				//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			}
			ii_c++;
			}
			}
			//delete[] ipool;
			//clear_AVL_Gus(root_Gus);
			//root_Gus = 0;

			for (integer isc = itop - 1; isc >= 0; isc--) {
			hash_table[istack[isc]] = false;
			}
			itop = 0;

			// На основе сбалансированного АВЛ дерева поиска.
			}
			*/


			//	ibegining_start_index_found_maximum += isize_p + 1;

			if (bAVL) {
				if (bAVL_deb)
				{
					printf("found max");
				}
				// Данный код чрезвычайно компактен.
				bmaxneighbourinfoactive = true;
				// Надо найти максимальный элемент в АВЛ дереве.
				node_AVL* emax = 0;
				Tree_splay* emax_splay = 0;
				switch (id_tree)
				{
				case AVL_TREE_ID: emax = findmax(root);
					break;
				case SPLAY_TREE_ID: emax_splay = findmax(root_splay);
					break;
				default: emax = findmax(root);
					break;
				}


				switch (id_tree) {
				case AVL_TREE_ID:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;

					}
					break;
				case SPLAY_TREE_ID:
					// SPLAY tree
					if (emax_splay != 0) {


						//icandidate = emax_splay->item.ii; 23 jan 2016
						icandidate = row_startA[emax_splay->item.i];
						emax_splay = 0;

					}
					else {
						root_splay = 0;
						size_splay_Tree = 0;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;

					}
					break;
				default:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;

					}
					break;
				}




			}

#if doubleintprecision == 1
			//printf("maximum number of neighbour=%lld\n",maxneighbour);
#else
			//printf("maximum number of neighbour=%d\n",maxneighbour);
#endif
			
			if (maxneighbour == -1) if (debug_reshime) system("pause");
			//getchar();

			if ((icandidate == 0) && (maxneighbour == -1)) {
				bcontinue = false;
			}

			if (bAVL_deb)
			{
				print_AVL(root);
				system("pause");
			}

			icountprohod++;

		} // Построение C/F разбиения. создано.

		//delete[] bmarkervisit;
		free(bmarkervisit);

		if (bprint_mesage_diagnostic) {
			printf("additional C=%3.1f\n", (doublerealT)(100.0*newCcount / n_a[ilevel - 1]));
			//system("pause");
		}

		if (bAVL)
		{
			// Освобождение оперативной памяти из под АВЛ дерева.
			// 12 декабря 2015.
			switch (id_tree)
			{
			case AVL_TREE_ID: clear_AVL(root);
				root = 0;
				break;
			case SPLAY_TREE_ID:
				clear_SPLAY(root_splay);
				root_splay = 0;
				break;
			default: clear_AVL(root);
				root = 0;
				break;
			}

		}


		// В методе стандартной интерполяции присутствует шаг уменьшения разреженности,
		// для того чтобы правильно аппроксимировать все F переменные C переменными надо
		// увеличить количество С переменных.
		integer ipromah = 0;
		integer ipromah_one = 0;
		integer ipromah_oneF = 0;

		integer iadditionalCstatistic = 0;

		bool bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]  ) {
				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				// старая версия до 10 января 2016.
				//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// Быстрый вариант без поиска, просто индексирование на основе "хеш-таблицы".
				// 10 января 2016. на основе хеширования.
				integer i_2 = row_startA[i_1];

				bool bvisit = false;
				for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
					if (Amat[is0].j != Amat[i_2].i) {
						bvisit = true;
						if (this_is_C_node[Amat[is0].j]  ) {
							icsos++;
						}
						else {
							ipromah++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.
				// Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
				if ((icsos == 0) && (bvisit)) {

					// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
					// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
					// поглощены агломератами внутренних узлов и всё было впорядке.
					// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

					// Нет С соседей, этот узел станет С узлом.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					// F node стал C_node!!! Идея стандартной интерполяции 
					// приводит к уменьшению разреженности оператора Галёркина.
					bweSholdbeContinue = true;
					newCcount++;
				}

				// 1 января 2015 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false) && (icsos == 1)) {
					// bvisit и так true т.к. icsos==1.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					bweSholdbeContinue = true;
				}

			}

			if (bprint_mesage_diagnostic) {
				if (bweSholdbeContinue) {
					printf(" prohod succseful\n");
				}
				else {
					printf("prohod empty\n");
				}
			}

		}




		// Нужно корректно обработать узлы Дирихле,
		// Если F узел окажется узлом Дирихле без соседей то его надо сделать С узлом,
		// Но узнать такой узел можно лишь в процессе выполнения алгоритма дальше по ходу исполнения.
		// Поэтому может потребоваться вернуться и начать заново (обратная связь).


		integer* C_numerate = nullptr;
		//C_numerate = new integer[n_a[ilevel - 1] + 1];
		C_numerate = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(C_numerate, "C_numerate", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		integer icounter = 1;
		integer icount1;
		integer numberofcoarcenodes;
		doublerealT* ap_coarse = nullptr;

		bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) { n_coarce++; }
			n_coarce--;


			// debug
			// проверка качества C/F разбиения.
			//doublerealT* exp1 = new doublerealT[n_a[ilevel - 1] + 1];
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) exp1[i_1] = 0.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) exp1[i_1] = 2.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]) exp1[i_1] = 1.0;
			//exporttecplot(exp1,n);
			//delete[] exp1;

			//printf("export ready");

			//system("pause");



			// C/F разбиение построено, самое время построить оператор интерполяции.
			// потом найти оператор проекции, как транспонированный оператор интерполяции.
			// Всё завершает построение матрицы нового сеточного уровня и можно запускать новый уровень.

			// Построение оператора интерполяции: 
			// coarse 2 fine.
			//P*coarse==fine


			// Занумеруем (упорядочим) узлы грубой сетки.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) C_numerate[i_1] = 0;
			icounter = 1;
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]  ) {
#if doubleintprecision == 1
				//printf("C ind= %lld", i_1); getchar();
#else
				//printf("C ind= %d", i_1); getchar();
#endif
				
				C_numerate[i_1] = icounter;
				icounter++;
			}




			// C_numerate - перенумерация на множестве Coarse узлов.
			// Построение пролонгации для узлов которые составляют грубую сетку.
			icount1 = 1 + iaddR; // nnz_R
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]  ) {
				P[icount1].aij = 1.0;
				P[icount1].i = C_numerate[i_1]; // coarse number
				P[icount1].j = i_1; // fine number.
				icount1++;
			}

			// значение icount1 нужно далее.НЕ трогать !!!.
			numberofcoarcenodes = icount1 - 1 - iaddR;

			// Для модификации R  надо transpose(P)/ap.
			if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
				printf("countloc=%lld\n", numberofcoarcenodes);
#else
				printf("countloc=%d\n", numberofcoarcenodes);
#endif
				
				if (debug_reshime) system("pause");
			}

			//ap_coarse = new doublerealT[numberofcoarcenodes + 1];
			ap_coarse = (doublerealT*)malloc((numberofcoarcenodes + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(ap_coarse, "ap_coarse", "classic_aglomerative_amg_3", (numberofcoarcenodes + 1));

			ap_coarse[0] = 0.0;




			// Для каждого С узла запоминаем в ap_coarse[C_numerate[i8]] 
			// модуль диагонального элемента.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_C_node[i8]  ) {
				// Старая версия до 10 января 2016. Время O(log2(nnz))
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// 10 января 2016 новая версия на основе хеширования. Время O(1).
				integer ii1 = row_startA[i8];
				// бинарный поиск должен гарантирует нахождение самого левого представителя.
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
#if doubleintprecision == 1
					//printf("i=%lld j=%lld Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#else
					//printf("i=%d j=%d Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#endif
					
					if (Amat[is0].j == Amat[ii1].i) {

						if (fabs(Amat[is0].aij) > RealMAXIMUM) {
							printf("perepolnenie error!");
							//getchar();
							system("pause");
						}
						ap_coarse[C_numerate[i8]] = fabs(Amat[is0].aij);
						//printf("find = %e", fabs(Amat[is0].aij));
					}
				}
				//printf("\n");
				//getchar();
			}

			// верно 2 октября.

			bool the_good_old_interpolation = true;

			if (the_good_old_interpolation) {

				// Старая добрая верная, проверенная интерполяция.
				// К тому же чрезвычайно простая.

				if (0) {

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.

					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						// O(log2(nnz))
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// O(1)
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
										icsos++;
									}
								}
								else {
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


						// 1 января 2016 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {



							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all neighbour is F");
											//system("pause");
											//printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполяция.
										}
										else {

											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
											}

										}

									}
								}
							}

						}

					}
				}
				if (0) {
					// Немного более экономичная по памяти. Коэффициент не превышал 3.

					// Прямая интерполяция с элементам непрямой.
					// Непрямая интерполяция применяется только для F узлов которые
					// не имеют С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.
					// Узел F не имеющий Strong C соседей, получает значение из Strong C соседей соседних Strong F узлов в
					// в результате сканирования списка Strong F соседей.
					// Если на встречаются два Strongly связанных F узла у которых в совокупности нет вообще ни одного Strong C соседа
					// то один из этих Strong F узлов тановится С узлом и сканирование списка сильных Strong F соседов данного узла F прекращается.
					// Потом мы повторн запускаем алгоритм построения с учётом уже добавленных С узлов.


					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						// O(log2(nnz))
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// O(1)
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j]  ) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all neighbour is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");

								//exit(1);
								// здесь нужна непрямая интерполяция.
								bool* empty_interpol = nullptr;
								//empty_interpol = new bool[icount_StronglyF];
								empty_interpol = (bool*)malloc(icount_StronglyF*sizeof(bool));
								handle_error<bool>(empty_interpol, "empty_interpol", "classic_aglomerative_amg_3", icount_StronglyF);

								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									empty_interpol[i_38] = false; // initialization
								}

								integer i_38_count = 0;

								bool bCinsert = false;

								// Сканируем сильных F соседей данного F узла для которого надо построить интерполяцию.
								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j]  ) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

												integer iFpoint = Amat[is0].j;
												doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
												// сканируем всех соседей iFpointeger 
												// чтобы найти среди них С узлы.

												// Идентифицируем локальный порог.
												doublerealT maxelem_threshold_loc = -1.0;
												//O(log2(nnz))
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												// O(1)
												integer ii1_loc = row_startA[iFpoint];
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														//if (this_is_C_node[Amat[is0_loc].j]  ) {
														// Будем рассматривать только действительно сильных C кандидатов второго уровня.
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
														//}
													}
												}


												// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

												// Найти соседей данного F-node которые C-node.
												integer icsos_loc = 0;
												bool bvisit_sumPloc = false;

												// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
												// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
												doublerealT sumP_loc = 0.0;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {




														if (this_is_C_node[Amat[is0_loc].j]  ) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																icsos_loc++;
																bvisit_sumPloc = true;
																empty_interpol[i_38_count] = true;
															}
														}
														else {
															// Подсчитываем количество соседей которые не являются С узлами.
															//ipromah_loc++; // подсчитываем проблемы интерполяции 
														}
													}
												}


												if (bvisit_sumPloc) {
													// В общем это двойная интерполяционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}
												}
												else {
													// не было С соседей интерполяция может испытывать проблемы.
													// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
													// Данная проблема проявляется уже на втором уровне.
													//printf("problem situation");
													//getchar();
													this_is_F_node[iFpoint] = false;
													this_is_C_node[iFpoint] = true;
													bweSholdbeContinue = true;
													bCinsert = true;
													// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполлчяцию,
													// Иначе я боюсь мы можем добавить слишком много С узлов на грубосеточных уровнях.
													break;
													// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых уровнях сетки.

												}

												i_38_count++;

											}
										}
									}
								}

								if (!bCinsert) {
									// Ибиранее этой добавки даёт ускорение вместо 3мин 42с до 3мин 29с.

									bool bstandart_vjzov = true;
									for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
										// 3 января. На самом деле здесь хорошо бы посмотреть вариант
										// когда с не менее чем двух сторон интерполяция сработала, здесь 
										// же срабатывание было лишь с одной из сторон как минимум.
										if (empty_interpol[i_38]  ) {
											bstandart_vjzov = false;
										}
									}
									if (bstandart_vjzov) {
										this_is_F_node[i8] = false;
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
									}
								}

								free(empty_interpol);

							}



							else {

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j]  ) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
											}



										}
									}
								}
							} // standart

						} // i8


					}

				}

				if (0) {
					// Немного более экономичная по памяти. Коэффициент не превышал 3.

					// Прямая интерполяция с элементам непрямой. Экспериментальный вариант. TODO.
					// Непрямая интерполяция применяется только для F узлов которые
					// не имеют С соседей или имеют недостаточное число С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.

					// Надо сохранить разреженность оператора Галёркина но при этом усилить интерполяцию.
					// Идея в том чтобы узел F имеющий лишь одного Strong С соседа обработать так чтобы у него было не менее 
					// двух  C соседей учитывая эффект непрямой интерполяции.


					ipromah = 0;
					ipromah_one = 0;
					ipromah_oneF = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j]  ) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполяцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}


						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all neighbour is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");

								//exit(1);
								// здесь нужна непрямая интерполяция.
								bool* empty_interpol = nullptr;
								//empty_interpol = new bool[icount_StronglyF];
								empty_interpol = (bool*)malloc(icount_StronglyF*sizeof(bool));
								handle_error<bool>(empty_interpol, "empty_interpol", "classic_aglomerative_amg_3", icount_StronglyF);

								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									empty_interpol[i_38] = false; // initialization
								}

								integer i_38_count = 0;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j]  ) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

												integer iFpoint = Amat[is0].j;
												doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
												// сканируем всех соседей iFpointeger 
												// чтобы найти среди них С узлы.

												// Идентифицируем локальный порог.
												doublerealT maxelem_threshold_loc = -1.0;
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												integer ii1_loc = row_startA[iFpoint];
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														//if (this_is_C_node[Amat[is0_loc].j]  ) {
														// Будем рассматривать только действительно сильных С кандидатов второго уровня.
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
														//}
													}
												}


												// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

												// Найти соседей данного F-node которые C-node.
												integer icsos_loc = 0;
												bool bvisit_sumPloc = false;

												// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
												// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
												doublerealT sumP_loc = 0.0;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {




														if (this_is_C_node[Amat[is0_loc].j]  ) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																icsos_loc++;
																bvisit_sumPloc = true;
																empty_interpol[i_38_count] = true;
															}
														}
														else {
															// Подсчитываем количество соседей которые не являются С узлами.
															//ipromah_loc++; // подсчитываем проблемы интерполяции 
														}
													}
												}


												if (bvisit_sumPloc) {
													// В общем это двойная интерполяционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}
												}
												else {
													// не было С соседей интерполяция может испытывать проблемы.
													// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
													// Данная проблема проявляется уже на втором уровне вложенности.
													//printf("problem situation");
													//getchar();
													this_is_F_node[iFpoint] = false;
													this_is_C_node[iFpoint] = true;
													bweSholdbeContinue = true;
													// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполяцию,
													// Иначе я боюсь мы можем добавить слишком много С узлов на грубых уровнях влженности.
													break;
													// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых урвнях сетки.
												}

												i_38_count++;

											}
										}
									}
								}

								bool bstandart_vjzov = true;
								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									// 3 января. На самом деле здесь хорошо бы посмотреть вариант
									// когда с не менее чем двух сторон интерполяция сработала, здесь 
									// же срабатывание было лишь с одной из сторон как минимум.
									if (empty_interpol[i_38]  ) {
										bstandart_vjzov = false;
									}
								}
								if (bstandart_vjzov) {
									this_is_F_node[i8] = false;
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
								}

								free(empty_interpol);

							}
							else if ((icsos == 1) && (icsosF != 0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (this_is_C_node[Amat[is0].j]  ) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//	printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												else {
													// Это как раз единственная Strong C связь. 
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {

													// Рассматриваем Strong F связи.

													// Смысл:
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpointeger 
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j]  ) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции 
															}
														}
													}

													// В общем это двойная интерполяционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}


													//}
												}
										}
									}
								}
							}
							else {

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j]  ) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
											}



										}
									}
								}
							} // standart

						} // i8


					}

				}

				if (1) {
					//theta = 0.24;
					// theta_strong_F iter_number time,s
					// 0.21 56 22.63
					// 0.22 55 21.769
					// 0.23 52 21.488
					// 0.24 52 21.741 == theta // optimum
					// 0.26 69 24.623
					doublerealT theta_strong_F = 0.23; // оптимальный выбор.

					// четвёртая версия интерполяции.
					integer ioneStrongC_and_0_StrongF = 0;

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					//6interpolation 0.4 6.77 11 26 28.355
					//6interpolation 0.45 6.6 10 27 28.151
					//6interpolation 0.5 6.42 12 32 28.735
					//4interpolation 0.4 3.7  52 24.736 // best
					//4interpolation 0.3 3.78 13 59 27.525
					//4interpolation 0.5 3.61 12 55 25.533
					//4interpolation 0.45 3.65 10 63 30.24

					bool byes_add = false;
					// Быстрое добавление недостающих С узлов.
					if (1) {
						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						//doublerealT magic = 0.4; // 0.4 optimum


						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if (fabs(Amat[is0].aij)>maxelem_threshold_theta) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							{

								if ((icsos == 1) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									//SumPall += sumP;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
												if (this_is_C_node[Amat[is0].j]  ) {

													// 20 января 2016.
													// По-моему этой ситуации вообще быть не может так как у нас 
													// заведомо один С сосед.
													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all neighbour is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														byes_add = true; // Были добавления узлов.
														//exit(1);
														// здесь нужна непрямая интерполяция.
													}


												}

											}
										}
									}
								}
								else {

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (this_is_C_node[Amat[is0].j]  ) {
											if (Amat[is0].j != Amat[ii1].i) {


												// 20 jan 2016.
												// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


												if (fabs(sumP) < RealZERO) {
													// Это случай когда вообще нет сильных С соседей.


													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													byes_add = true; // Были добавления узлов.
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}


											}
										}
									}
								}

							}

						}

					}



					if (!byes_add) {

						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						doublerealT magic = 0.4; // 0.4 optimum

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							integer istr_etalon1 = Amat[ii1].i;
							integer iend_for1 = -1;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == istr_etalon1); is0++) {
								iend_for1 = is0;
								if (Amat[is0].j != istr_etalon1) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							for (integer is0 = ii1; is0 <= iend_for1; is0++) {
								if (Amat[is0].j != istr_etalon1) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							if ((false) && (icsos == 1)) {
								this_is_F_node[i8] = false;
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
							}
							else {

								if (((icsos == 1) || (icsos == 2)) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									SumPall += sumP;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.


											if (this_is_C_node[Amat[is0].j]  ) {
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all neighbour is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполяция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															icount1++;
														}

													}
												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
													if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
														// Рассматриваем Strong F связи.

														// Смысл:
														// 



														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														// Это лишнее условие, ранее уже было проверено что мы имеем дело
														// с сильной F связью.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														integer istr_etalon = Amat[ii1_loc].i;
														integer iend_for = -1;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == istr_etalon); is0_loc++) {
															iend_for = is0_loc;
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																if (Amat[is0_loc].j != istr_etalon) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}

														doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
															if (Amat[is0_loc].j != istr_etalon) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

														// В общем это двойная интерполяционная сумма 
														//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																if (Amat[is0_loc].j != istr_etalon) {

																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
																	if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																	}
																}
															}
														}


														//}
													}
												}
										}

									}
								}
								else {

									// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
									// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
									// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
									// bmodify_interpol4_amg = false;
									// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
									bool bmodify_interpol4_amg = false;
									doublerealT magic2 = 0.5;

									// Подготовительный этап к усилению четвертой интерполяции 
									// Усиление интерполяции происходит без добавления новых С узлов.
									// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
									// имеется конечно.
									// Подготовительный этап заключается в определении положения is0_candidate самой сильной
									// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
									doublerealT sum1 = 0.0;
									integer is0_candidate = -1;
									if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
										for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												if (this_is_C_node[Amat[is0].j]  ) {
													//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
													if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
														if (fabs(Amat[is0].aij) > sum1) {
															sum1 = fabs(Amat[is0].aij);
															is0_candidate = is0;
														}
													}
												}
											}
										}

										if (sum1 / sumP < magic2) {
											// Если найденный элемент слишком слабый ничего не делаем с этим С,
											// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
											sum1 = 0.0;
											is0_candidate = -1;

											// Тогда ищем среди Weakly F узлов кандидата.
											for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
												if (Amat[is0].j != Amat[ii1].i) {
													if (this_is_F_node[Amat[is0].j]  ) {
														//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
														if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
															if (fabs(Amat[is0].aij) > sum1) {
																sum1 = fabs(Amat[is0].aij);
																is0_candidate = is0;
															}
														}
													}
												}
											}

											// такой узел F должен стать новым С узлом.
											if (sum1 / sumP >= magic2) {
												this_is_F_node[i8] = false; // Этот узел  станет С нодом.
												this_is_C_node[i8] = true;
												bweSholdbeContinue = true;
												byes_add = true;
												iadditionalCstatistic++;

											}
											// Обязательный сброс перед рестартом чтобы не было деления на ноль.
											sum1 = 0.0;
											is0_candidate = -1;

										}
									}


									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											if (this_is_C_node[Amat[is0].j]  ) {



												if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
													// Мы усиливаем силу интерполяции без добавления новых узлов за
													// счёт одной дополнительной самой сильной Weakly C связи.
													// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

													ioneStrongC_and_0_StrongF++;
													if (is0_candidate != -1) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_candidate].j];
														P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
														icount1++;
													}

													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
													if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
														icount1++;
													}
												}
												else {

													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all neighbour is F");
														//system("pause");
														//printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполяция.
													}
													else {

														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															icount1++;
														}

													}

												}

											}
										}
									}
								}

							}
						}

					}

#if doubleintprecision == 1
					//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
					//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif
					
					//system("pause");
				}
				if (0) {
					// пятая попытка.
					// показывает время 1.22 против времени в 1.36 в четвертой попытке.

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j]  ) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполяцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}



						// 1 января 2016 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if ((icsos == 1) && (icsosF != 0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (this_is_C_node[Amat[is0].j]  ) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//	printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												else {
													// Это как раз единственная Strong C связь. 
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {

													// Рассматриваем Strong F связи.

													// Смысл:
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpointeger 
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j]  ) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции 
															}
														}
													}

													// В общем это двойная интерполяционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}


													//}
												}
										}
									}
								}
							}
							else {

								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {

										if (this_is_C_node[Amat[is0].j]  ) {

											if (fabs(sumP) < RealZERO) {
												//printf("error interpolation zero diagonal sumP.\n");
												//printf("Fnode all neighbour is F");
												//system("pause");
												//printf("i8 is Dirichlet node\n");
												this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
												this_is_C_node[i8] = true;
												bweSholdbeContinue = true;
												iadditionalCstatistic++;
												//exit(1);
												// здесь нужна непрямая интерполяция.
											}
											else {

												// Внедиагональный элемент из множества С узлов.

												// Данная вставка должна существенно сохранять 
												// разреженность оператора Галёркина на глубоких 
												// сеточных уровнях.
												// Модификация 5 декабря 2015.
												//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
												if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
													P[icount1].j = i8;
													P[icount1].i = C_numerate[Amat[is0].j];
													P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
													//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
													icount1++;
												}

											}

										}
										else
											if (this_is_F_node[Amat[is0].j]  ) {

												// Рассматриваем Strong F связи.
												// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
												// Смысл:
												//



												//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
												// Это лишнее условие, ранее уже было проверено что мы имеем дело
												// с сильной F связью.
												if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpoint
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j]  ) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции
															}
														}
													}

													// В общем это двойная интерполяционная сумма
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять
																// разреженность оператора Галёркина на глубоких
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}


													//}
												}
											}


									}
								}
							}

						}

					}
				}

				if (0) {

					bool byes_add = false;
					//  быстрая проверка на добавление.
					if (1) {
						// шестая попытка.
						// CGHV1J amg1r5 time 0.26
						// cl_agl_amg_v0_14 time:
						// magic  time number V cycles grid complexity
						// 0.25   0:48  29  6.55A
						// 0.3    0:45  28  6.19A 
						// 0.35  0:43   28  5.98A
						// 0.4   0:41   27  5.77A // отыграно 14% производительности.
						// tgf2023_10 amg1r5 time 1:00
						// cl_agl_amg_v0_14 time
						// magic  time number V cycles grid complexity
						// 0.25 1:49 27 3.61
						// 0.3 1:47 26 3.47
						// 0.35 1:46 27 3.51
						// 0.4 1:44 28 3.413 // отыграно 5% производительности.
						// Electric potencial in FET2 amg1r5 time 1:38
						// cl_agl_amg_v0_14 time:
						// magic  time number V cycles grid complexity
						// 0.25 3:19 36 6.65
						// 0.3 3:02 34 6.34
						// 0.35 2:52 33 6.091
						// 0.4 2:46 33 5.91 // отыграно 20% производительности.

						// magic=0.4 is optimum.11 jan 2016
						doublerealT magic = 0.4; // 0.4

						// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
						// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
						// сильных F узлов.

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							 {

								 if ((icsos == 1) && (icsosF != 0)) {
									 // Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									 //
									 SumPall += sumP;

									 for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										 if (Amat[is0].j != Amat[ii1].i) {
											 // Нас интересуют только Strong связи.
											 if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												 if (this_is_C_node[Amat[is0].j]  ) {

													 if (fabs(sumP) < RealZERO) {
														 //printf("error interpolation zero diagonal sumP.\n");
														 //printf("Fnode all neighbour is F");
														 //system("pause");
														 //	printf("i8 is Dirichlet node\n");
														 this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														 this_is_C_node[i8] = true;
														 bweSholdbeContinue = true;
														 iadditionalCstatistic++;
														 byes_add = true;
														 //exit(1);
														 // здесь нужна непрямая интерполяция.
													 }


												 }

											 }
										 }
									 }
								 }
								 else {



									 for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										 if (Amat[is0].j != Amat[ii1].i) {

											 if (this_is_C_node[Amat[is0].j]  ) {

												 if (fabs(sumP) < RealZERO) {
													 //printf("error interpolation zero diagonal sumP.\n");
													 //printf("Fnode all neighbour is F");
													 //system("pause");
													 //printf("i8 is Dirichlet node\n");
													 this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													 this_is_C_node[i8] = true;
													 bweSholdbeContinue = true;
													 iadditionalCstatistic++;
													 byes_add = true;
													 //exit(1);
													 // здесь нужна непрямая интерполяция.
												 }


											 }



										 }
									 }



								 }

							 }

						}
					}


					// Проверка на добавление пройдена успешно, 
					// добавлений не было и можно интерполировать !!!.
					if (byes_add == false) {

						// шестая попытка.
						// CGHV1J amg1r5 time 0.26
						// cl_agl_amg_v0_14 time:
						// magic  time number V cycles grid complexity
						// 0.25   0:48  29  6.55A
						// 0.3    0:45  28  6.19A 
						// 0.35  0:43   28  5.98A
						// 0.4   0:41   27  5.77A // отыграно 14% производительности.
						// tgf2023_10 amg1r5 time 1:00
						// cl_agl_amg_v0_14 time
						// magic  time number V cycles grid complexity
						// 0.25 1:49 27 3.61
						// 0.3 1:47 26 3.47
						// 0.35 1:46 27 3.51
						// 0.4 1:44 28 3.413 // отыграно 5% производительности.
						// Electric potencial in FET2 amg1r5 time 1:38
						// cl_agl_amg_v0_14 time:
						// magic  time number V cycles grid complexity
						// 0.25 3:19 36 6.65
						// 0.3 3:02 34 6.34
						// 0.35 2:52 33 6.091
						// 0.4 2:46 33 5.91 // отыграно 20% производительности.

						// magic=0.4 is optimum.11 jan 2016
						doublerealT magic = 0.4; // 0.4

						// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
						// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
						// сильных F узлов.

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							if ((false) && (icsos == 1)) {
								this_is_F_node[i8] = false;
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
							}
							else {

								if ((icsos == 1) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									SumPall += sumP;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if (this_is_C_node[Amat[is0].j]  ) {

													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all neighbour is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполяция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															icount1++;
														}

													}

												}
												else
													if (this_is_F_node[Amat[is0].j]  ) {

														// Рассматриваем Strong F связи.

														// Смысл:
														// 



														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														// Это лишнее условие, ранее уже было проверено что мы имеем дело
														// с сильной F связью.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														// В общем это двойная интерполяционная сумма 
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																	}
																}
															}
														}


														//}
													}
											}
										}
									}
								}
								else {

									SumPall += sumP;
									doublerealT sum_ok = 0.0;
									bool bbackreturn = false;
									integer icount1_mem = icount1;
									bool* bbackrarr = nullptr;
									//bbackrarr = new bool[icount_StronglyF];
									bbackrarr = (bool*)malloc(icount_StronglyF*sizeof(bool));
									handle_error<bool>(bbackrarr, "bbackrarr", "classic_aglomerative_amg_3", icount_StronglyF);

									for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
										bbackrarr[i_63] = false;
									}
									integer icounter_bbackarr = -1;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {

											if (this_is_C_node[Amat[is0].j]  ) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												else {

													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														P[icount1].aij = fabs(Amat[is0].aij);
														sum_ok += fabs(Amat[is0].aij);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {

													// Рассматриваем Strong F связи.
													// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
													// Смысл:
													//



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														icounter_bbackarr++;

														integer iFpoint = Amat[is0].j;
														//doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														doublerealT mult1 = fabs(Amat[is0].aij);
														// сканируем всех соседей iFpoint
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														icsos_loc = 0;
														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc1 = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc)>maxelem_threshold*theta) {
																		sumP_loc1 += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																		//	}
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														if (icsos_loc > 0) {
															// В общем это двойная интерполяционная сумма
															for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
																if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																	if (this_is_C_node[Amat[is0_loc].j]  ) {
																		// Внедиагональный элемент из множества С узлов.

																		// Данная вставка должна существенно сохранять
																		// разреженность оператора Галёркина на глубоких
																		// сеточных уровнях.
																		// Модификация 5 декабря 2015.
																		//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																		//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																			//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc) > maxelem_threshold*theta) {
																			P[icount1].j = i8;
																			P[icount1].i = C_numerate[Amat[is0_loc].j];
																			//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																			//P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			P[icount1].aij = mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			sum_ok += mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			icount1++;
																		}
																		//}
																	}
																}
															}
														}
														else {
															//bbackreturn = true;
															bbackrarr[icounter_bbackarr] = true;
														}


														//}
													}
												}


										}
									}


									//bbackreturn = true;
									//for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
									//if (!bbackrarr[i_63]) {
									//	bbackreturn = false;
									//}
									//}

									//if (bbackreturn) {
									// сильные F связи не дали результата, поэтому мы возвращаемся к исходному 
									// варианту интерполяции.
									//for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
									//P[i_95].aij = P[i_95].aij*SumPall / sumP;
									//}
									//}

									// Апосториорная коррекция
									for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
										P[i_95].aij = P[i_95].aij / sum_ok;
									}

									free(bbackrarr);

								}

							}

						}
					}

				}

			}
			else if (true) {


				// Экспериментальная интерполяция 1 января 2016.

				ipromah = 0;
				ipromah_one = 0;
				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
				for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

					// Нам нужен разреженный оператор Галёркина.
					// 5 декабря 2015 года мы попробуем увеличить разреженность
					// оператора интерполяции а значит и оператора Галёркина.
					doublerealT maxelem_threshold = -1.0;
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					integer ii1 = row_startA[i8];
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Наверно разумно что threshold определён по всей строке, а не только по С узлам в строке.
							//if (this_is_C_node[Amat[is0].j]  ) {
							if (fabs(Amat[is0].aij) > maxelem_threshold) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
					// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					// Найти соседей данного F-node которые C-node.
					integer icsos = 0;

					doublerealT SumPall = 0.0;
					// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					doublerealT sumP = 0.0;
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {

							// Сумма вообще всех внедиагональных элементов.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								SumPall += fabs(Amat[is0].aij);
							}


							if (this_is_C_node[Amat[is0].j]  ) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									icsos++;
								}
							}
							else {
								// Подсчитываем количество соседей которые не являются С узлами.
								ipromah++; // подсчитываем проблемы интерполяции 
							}
						}
					}
					if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


					// 1 января 2015 Один сосед это недостаточно.
					// Поэтому в случае одного соседа делаем такой узел С узлом.
					if ((false) && (icsos == 1)) {
						this_is_F_node[i8] = false;
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
					}
					else {



						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j]  ) {

										// Смысл:
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

											integer iFpoint = Amat[is0].j;
											doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublerealT maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j]  ) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//ipromah_loc++; // подсчитываем проблемы интерполяции 
													}
												}
											}

											// В общем это двойная интерполяционная сумма 
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0_loc].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
														}
													}
												}
											}


										}
									}
							}
						}

					}


				}
			}
			else {
				// От интерполяции зависит очень много поэтому
				// реализуем следующую экспериментальную идею интерполяции.
				// Эта интерполяция претендует быть единственно теоретически верной,
				// сделанной на основе литературных данных.


				ipromah = 0;
				ipromah_one = 0;
				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
				for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

					// Нам нужен разреженный оператор Галёркина.
					// 5 декабря 2015 года мы попробуем увеличить разреженность
					// оператора интерполяции а значит и оператора Галёркина.
					doublerealT maxelem_threshold = -1.0;
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					integer ii1 = row_startA[i8];
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j]  ) {
							if (fabs(Amat[is0].aij) > maxelem_threshold) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
					// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					// Найти соседей данного F-node которые C-node.
					//integer icsos = 0;

					// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					doublerealT sumP = 0.0;
					doublerealT sumPindicator = 0.0;
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
									// Weak connectors
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									//icsos++;
								}
								else {
									sumPindicator += fabs(Amat[is0].aij);
								}
							}
							else {
								// Подсчитываем количество соседей которые не являются С узлами.
								if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
									// Weak connectors
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									//icsos++;
								}
								ipromah++; // подсчитываем проблемы интерполяции 
							}
						}
						else {
							// Диагональный элемент.
							sumP += fabs(Amat[is0].aij);
						}
					}
					//if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


					// 1 января 2015 Один сосед это недостаточно.
					// Поэтому в случае одного соседа делаем такой узел С узлом.
					//if ((false) && (icsos == 1)) {
					//this_is_F_node[i8] = false;
					//this_is_C_node[i8] = true;
					//bweSholdbeContinue = true;
					//}
					//else
					{

						if (fabs(sumPindicator) < RealZERO) {
							//printf("error interpolation zero diagonal sumP.\n");
							//printf("Fnode all neighbour is F");
							//system("pause");
							//printf("i8 is Dirichlet node\n");
							this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
							iadditionalCstatistic++;
							//exit(1);
							// здесь нужна непрямая интерполяция.

							// Мы не будем добалять С узлы, мы будем использовать непрямую интерполяцию.



						}
						else {

							integer icount1_frozen = icount1;

							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											// Strongly C connectors.

											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
										}


									}
								}
							}

							integer ilength_n = icount1 - icount1_frozen;
							integer* jposition_in_P = nullptr;
							//jposition_in_P = new integer[ilength_n];
							jposition_in_P = (integer*)malloc(ilength_n*sizeof(integer));
							handle_error<integer>(jposition_in_P, "jposition_in_P", "classic_aglomerative_amg_3", ilength_n);



							integer i_97 = 0;

							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											// Strongly C connections j position.
											jposition_in_P[i_97] = Amat[is0].j;
											i_97++;
										}
									}
								}
							}


							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_F_node[Amat[is0].j]  ) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											// Strong F connections
											doublerealT my_mult = fabs(Amat[is0].aij);
											integer iFpoint = Amat[is0].j;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];

											// Смотрим всех соседей узла iFpoint
											// если среди них окажутся сильные С соседи 
											// первоначально рассматриваемого узла Amat[ii1].i
											// то мы будем накапливать в сумматоре sum23 
											// модули значеий матрицы.
											doublerealT sum23 = 0.0;
											bool bvisit23 = false;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														for (i_97 = 0; i_97 < ilength_n; i_97++) {
															if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																sum23 += fabs(Amat[is0_loc].aij);
																bvisit23 = true;
																break;
															}
														}
													}
												}
											}

											//if (fabs(sum23) > RealZERO) {
											if (bvisit23) {
												// мы точно не делим на ноль.

												// Сканируем всех соседей узла F.
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j]  ) {
															for (i_97 = 0; i_97 < ilength_n; i_97++) {
																if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																	//P[icount1_frozen + i_97].j = i8;
																	//P[icount1_frozen+i_97].i = C_numerate[Amat[is0].j];
																	P[icount1_frozen + i_97].aij += (my_mult*fabs(Amat[is0_loc].aij)) / (sumP*sum23);
																	break;
																}
															}
														}
													}
												}
											}


										}
									}
								}
							}

							//delete[] jposition_in_P;
							free(jposition_in_P);

						}

					}


				}
			}



			if (bweSholdbeContinue) {
				//delete[] ap_coarse;
				free(ap_coarse);
				ap_coarse = nullptr;
				if (bprint_mesage_diagnostic) {
					printf("Feedback restart...\n");
				}
			}

			if (bprint_mesage_diagnostic) {
				printf("addition C nodes  %3.1f %%", (doublerealT)(100.0*iadditionalCstatistic / n_a[ilevel - 1]));
			}
			iadditionalCstatistic = 0;
			//system("pause");


		}

		nnzR = icount1 - iaddR;



		// нужно определить nnzR количество ненулевых элементов в матрице R и P.

		// оператор restriction построен и он упорядочен по i.
		// число ненулевых элементов nnzR-1.
		// P=Copy(R);
		for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
			R[ii] = P[ii];
			//if ((ilevel == 2) && (ii >= iaddR + nnzR - 1-30)) {
#if doubleintprecision == 1
			//printf("ii=%lld aij=%e, i=%lld j=%lld\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#else
			//printf("ii=%d aij=%e, i=%d j=%d\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#endif
			
			//getchar();
			//}
		}

		// heapsort(P,key==j,iaddR+1,iaddR+nnzR - 1, comparej);

		/*
		// 10 января 2016. Эта сортировка не требуется.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
		}
		else {
		// Быстрая сортировка Хоара.
		qs(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
		}
		}
		else {
		HeapSort(P, 1 + iaddR, iaddR + nnzR - 1, comparej);
		}
		*/


		// где то надо разделить на ap, т.к. 
		// R=P/ap. ????


		// heapsort(R,key==i,iaddR+1,iaddR+nnzR - 1, comparei);

		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(R, 1 + iaddR, iaddR + nnzR - 1,false, indx_comparei);
			}
			else {
				qs(R, 1 + iaddR, iaddR + nnzR - 1, indx_comparei);
			}
		}
		else {
			HeapSort(R, 1 + iaddR, iaddR + nnzR - 1, comparei);
		}


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("first level size n=%lld numberofcoarcenodes=%lld\n", n, numberofcoarcenodes);
#else
			printf("first level size n=%d numberofcoarcenodes=%d\n", n, numberofcoarcenodes);
#endif
			
		}

		// Корректировка диагонали restriction
		if (0) {
			// убрано 2 января 2015 года.
			// Убирание этого сомнительного шага дало сокращение 
			// времени счтёта для 1M неизвестных с 51с(131 итерация) до 42с (91 итерации).
			// на задаче tgf2023_01 включение данного шага приводит к расходимости вычислительного процесса.

			if (debug_reshime) system("pause");
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				flag[i_1] = false; // init flag.
			}

			for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
				if (flag[R[i_1].i] == false)
				{
					for (integer i_2 = i_1; (i_2 <= iaddR + nnzR - 1) && (R[i_2].i == R[i_1].i); i_2++) {
						if ((R[i_1].i<1) || (R[i_1].i>numberofcoarcenodes)) {
#if doubleintprecision == 1
							printf("error R[%lld].i=%lld\n", i_1, R[i_1].i);
#else
							printf("error R[%d].i=%d\n", i_1, R[i_1].i);
#endif
							
							system("pause");
						}
						if (fabs(ap_coarse[R[i_1].i]) < divisionZERO) {
							printf("error division by zero\n");
							system("pause");
						}
						doublerealT delitel;
						if (ap_coarse[R[i_1].i] > 1.0) {
							// internal node
							delitel = 0.5*ap_coarse[R[i_1].i];
						}
						else {
							// Dirichlet
							delitel = ap_coarse[R[i_1].i];
						}
						R[i_2].aij = R[i_2].aij / (delitel);
					}
					flag[R[i_1].i] = true;
				}
			}
		}

		//delete[] ap_coarse;
		free(ap_coarse);





		// Сортировка А по j.
		//heapsort(Amat, key=j*n_a[ilevel - 1] + i, 1, nnz_a[ilevel - 1]);

		// Лишний код потомучто потом сразу же следует сортировка по i.
		/*
		// 7 января 2016. закомментировано.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sortj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		qsj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		}
		else {
		HeapSort_j(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/


		// Нахождение матрицы грубосеточного уровня:
		// Acorse=R*Afine*P;
		// часть 1: R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", nnzR, nnz_a[ilevel - 1]);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", nnzR, nnz_a[ilevel - 1]);
#endif
			
		}

		integer istartAnew;


		// Фред Густавсон IBM 1978.
		// 23 октября 2015 года.

		// часть 1: R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]
		// Сортировка А по строкам.
		/*
		// 7 января 2016. Сортировка матрицы А была выполнена единожды при начале обработке данного уровня.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		}
		else {
		HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/
		// Преобразование к формату CRS.

		integer* row_ind_SR = nullptr;
		//row_ind_SR = new integer[numberofcoarcenodes + 1];
		row_ind_SR = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_SR, "row_ind_SR", "classic_aglomerative_amg_3", (numberofcoarcenodes + 1));

		integer* row_ind_ER = nullptr;
		//row_ind_ER = new integer[numberofcoarcenodes + 1];
		row_ind_ER = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_ER, "row_ind_ER", "classic_aglomerative_amg_3", (numberofcoarcenodes + 1));

		for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			row_ind_SR[i_1] = -1;
			row_ind_ER[i_1] = -2;
		}
		integer istart1 = 1 + iaddR;
		integer iend1 = nnzR - 1 + iaddR;
		for (integer i = 1; i <= icounter - 1; i++) {
			flag[i] = false;
		}
		for (integer ii = istart1; ii <= iend1; ii++) {
			if (flag[R[ii].i] == false) {
				integer istr = R[ii].i;
				integer ic = ii;
				integer kf = ic;

				while ((kf <= iend1) && (R[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_SR[istr] = ic;
				row_ind_ER[istr] = kf;
				flag[R[ii].i] = true;
			}
		}

		// Пустые строки просто отсутствуют.
		//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
		//if (row_ind_SR[i_1] == -1) {
#if doubleintprecision == 1
		//printf("empty string %lld\n", row_ind_ER[i_1]);
#else
		//printf("empty string %d\n", row_ind_ER[i_1]);
#endif
		
		//}
		//}

		integer* row_ind_SA = nullptr;
		//row_ind_SA = new integer[n_a[ilevel - 1] + 1];
		row_ind_SA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_SA, "row_ind_SA", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		integer* row_ind_EA = nullptr;
		//	row_ind_EA = new integer[n_a[ilevel - 1] + 1];
		row_ind_EA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_EA, "row_ind_EA", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		integer istart3 = 1 + iadd;
		integer iend3 = nnz_a[ilevel - 1] + iadd;
		for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
			flag[i] = false;
		}
		for (integer ii = istart3; ii <= iend3; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer kf = ic;

				while ((kf <= iend3) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_SA[istr] = ic;
				row_ind_EA[istr] = kf;
				flag[Amat[ii].i] = true;
			}
		}

		istartAnew = nnz_a[ilevel - 1] + 1 + iadd;

		// Данные используемые для частичного формирователя суммы.
		doublerealT* vector_sum = nullptr;
		//vector_sum = new doublerealT[n_a[ilevel - 1] + 1];
		vector_sum = (doublerealT*)malloc((n_a[ilevel - 1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		//bool* b_visit_vec_sum = new bool[n_a[ilevel - 1] + 1];
		//integer size_v = sizeof(doublerealT)*(1 + n_a[ilevel - 1]);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		integer* index_visit = nullptr;
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		integer index_size = 0;

		


		// Сканируем первый операнд построчно.
		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Начинаем обрабатывать новую строку.
			// Сброс формирователя суммы в ноль.
			//#pragma omp parallel for
			//for (integer i_2 = 1; i_2 <= n_a[ilevel - 1]; i_2++) {
			//vector_sum[i_2] = 0.0; // инициализация // 18.5
			//b_visit_vec_sum[i_2] = false;
			//}
			// Более быстрое обнуление
			// По времени в лучшем случае также. Но может сильно ухудшиться из-за занятости системной dll-ки.
			//memset(vector_sum, 0,size_v );

			node_AVL_Gus* root_Gus = 0;

#if 0
			if (0) {

				// линейный поиск очень медленный на больших размерностях.

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else if (0) {

				// закомментировано т.к. это медленная ветвь кода.
				// Ситуация такая. Ранее на небольших задачах до 1М включительно,
				// данная ветвь кода не показывала выигрыша в быстродействии и возможно 
				// даже была слегка медленее (совсем немного). 
				// Это быстрая часть кода на больших размерностях.
				// Гораздо лучше линейного поиска. Сейчас это подтверждается
				// на непрямой интерполяции при задаче в 3.2М неизвестных.
				// Там на линейный поиск в данном месте тратится не менее 80% фазы построения грубосеточных операторов.

				// На основе АВЛ
				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							root_Gus = insert_Gus(root_Gus, iaddind);
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else
#endif
			{

				// на основе hash таблицы. 

				// Сканируем текущую i-ую строку поэлементно
#pragma omp parallel for 
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						//foundnow = isfound_Gus(root_Gus, iaddind);
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							//root_Gus = insert_Gus(root_Gus, iaddind);
							hash_table[iaddind] = true;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}


			doublerealT maxth = -1.0;
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];
				hash_table[jstr] = false; // инициализируем hash таблицу для следующих проходов.
				if (istr != jstr) {
					// 14 января 2016.
					// Правильнее определить величину барьера только по внедиагональным элементам.
					if (fabs(vector_sum[jstr]) > maxth) maxth = vector_sum[jstr];
				}
			}

			/*
			if (nsizeA > istartAnew + index_size) {
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
			integer jstr = index_visit[i_6];
			if (istr != jstr) {
			// 5 декабря 2015. threshold.
			//if (fabs(vector_sum[jstr]) > 1.0e-30) {
			if (fabs(vector_sum[jstr]) > barjer*maxth) {
			Amat[istartAnew].aij = vector_sum[jstr];
			Amat[istartAnew].i = istr;
			Amat[istartAnew].j = jstr;
			istartAnew++;
			}
			}
			else {
			// диагональный элемент записываем обязательно.
			Amat[istartAnew].aij = vector_sum[jstr];
			Amat[istartAnew].i = istr;
			Amat[istartAnew].j = jstr;
			istartAnew++;
			}
			}
			}
			else {
			// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
			// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
			printf("Amat lack of memory\n");
			printf("yuo mast increase the size of the matrix Amat and restart solver\n");
			printf("please, press any key to exit.\n");
			system("pause");
			exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем
			// проверками.
			doublerealT barjer_maxth = barjer*maxth;
			doublerealT mbarjer_maxth = -barjer_maxth;
			if (nsizeA > istartAnew + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];

					doublerealT vs1 = vector_sum[jstr];
					if ((vs1 < mbarjer_maxth) || (vs1 > barjer_maxth)) {
						//Amat[istartAnew].aij = vs1;
						//Amat[istartAnew].i = istr;
						//Amat[istartAnew].j = jstr;
						//istartAnew++;

						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = istr;
						Atemp.j = jstr;
						Amat[istartAnew++] = Atemp;

					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			index_size = 0; // Сброс индикатора, строка обработана.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

		}



		//delete[] index_visit;
		//delete[] row_ind_SR;
		//delete[] row_ind_ER;
		//delete[] row_ind_SA;
		//delete[] row_ind_EA;
		//delete[] vector_sum;

		free(index_visit);
		free(row_ind_SR);
		free(row_ind_ER);
		free(row_ind_SA);
		free(row_ind_EA);
		free(vector_sum);


		// Сортировка А по i (оригинала.).
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);

		/*
		// Лишняя сортировка до этого уже была выполнена сортировка по i.
		// 7 января 2016.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		}
		else
		{
		HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/


		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
		//if (Amat[i_1].j < 0) {
		//	printf("error: negativ j index\n");
		//	system("pause");
		//}
#if doubleintprecision == 1
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}



		// Часть 2. [R*Afine]*P=Abuf*P.
		// Сортировка [R*А] по i.
		//heapsort(Amat, key=i*n_coarce + j, 1, nnz_a[ilevel - 1]);

		// В результате работы алгоритма разреженного матричного умножения по Густавсону,
		// мы и так имеем отсортированный по строкам результат, поэтому дополнительная 
		// сортировка не требуется. Это проверено 11 января 2016.
		// 11 января 2016.
		/*
		if (bqs) {
		// Обязательно нужна сортировка.
		if (bCounting_Sort) {
		Counting_Sort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		else {
		qs(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		}
		else {
		HeapSort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		*/



		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
		//if (Amat[i_1].j < 0) {
		//	printf("error: negativ j index\n");
		//	system("pause");
		//}
#if doubleintprecision == 1
		//-->	//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//-->	//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}




		/*
		// 10 января 2016. Данная сортировка не требуется.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
		qs(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		*/


		// Prolongation должна быть упорядочена по j.
		// Начальная позиция элементов матрицы грубосеточного уровня.
		integer istartAnew2 = istartAnew;



		// Быстрее этого кода на основе идеи слияния списков уже не будет.
		// 17 октября 2015. Нужно двигаться в сторону Писсанецки.
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#endif
			
		}



		// Фред Густавсон IBM 1978
		// В ядре кода Густавсона нету ни одного ветвления,
		// а мы знаем что в результате профайлинга предыдущих версий кода:
		// (наивный, слияние, Писсанецки) львиная доля вычислительной работы уходила
		// на сравнения (ветвления) в отношении примерно 30 к 1. 30 сравнений на одно суммирование.
		// 23 октября 2015 года.
		// 6 января 2016 года Добавлено АВЛ дерево.


		// Рабочая версия алгоритма Фреда Густавсона.
		// IBM 1978 Sparse Matrix multiplication.

		// Сортировка обязательно требуется.
		// Преобразование обоих матриц в формат CRS.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
			}
			else {
				qs(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
			}
		}
		else {
			HeapSort(P, 1 + iaddR, iaddR + nnzR - 1, comparej);
		}

		integer* row_ind_AS = nullptr;
		//row_ind_AS = new integer[numberofcoarcenodes + 1];
		row_ind_AS = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_AS, "row_ind_AS", "classic_aglomerative_amg_3", (numberofcoarcenodes + 1));

		integer* row_ind_AE = nullptr;
		//row_ind_AE = new integer[numberofcoarcenodes + 1];
		row_ind_AE = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_AE, "row_ind_AE", "classic_aglomerative_amg_3", (numberofcoarcenodes + 1));

		integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
		integer iend2 = istartAnew - 1;

#pragma omp parallel for
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
#pragma omp parallel for
		for (integer ii = istart2; ii <= iend2; ii++) {
			if (flag[Amat[ii].i] == false) {
				// сканируем построчно.
				integer istr = Amat[ii].i;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend2) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_AS[istr] = ic;
				row_ind_AE[istr] = kf;
				flag[Amat[ii].i] = true;

			}
		}

		integer* row_ind_PS = nullptr;
		//row_ind_PS = new integer[n_a[ilevel - 1] + 1];
		row_ind_PS = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_PS, "row_ind_PS", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		integer* row_ind_PE = nullptr;
		//row_ind_PE = new integer[n_a[ilevel - 1] + 1];
		row_ind_PE = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_PE, "row_ind_PE", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));


		// Инициализация чрезвычайно важна, т.к. 
		// обязательно присутствуют пустые строки которые
		// надо корректно обрабатывать.
#pragma omp parallel for
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			row_ind_PS[ii] = -1; // инициализация.
			row_ind_PE[ii] = -2;
		}
		integer istart4 = 1 + iaddR;
		integer iend4 = nnzR - 1 + iaddR;
#pragma omp parallel for
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
#pragma omp parallel for
		for (integer ii = istart4; ii <= iend4; ii++) {
			if (flag[P[ii].j] == false) {
				// сканируем построчно.
				integer istr = P[ii].j;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend4) && (P[kf].j == istr)) {
					kf++;
				}
				kf--;
				row_ind_PS[istr] = ic;
				row_ind_PE[istr] = kf;
				flag[P[ii].j] = true;

			}
		}

		// Данный код подтверждает что обязательно присутствуют
		// пустые строки.
		//for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
		//if (row_ind_PS[ii] == -1) {
#if doubleintprecision == 1
		//printf("propusk string %lld\n", row_ind_PE[ii]);
#else
		//printf("propusk string %d\n", row_ind_PE[ii]);
#endif
		
		//getchar();
		//}
		//}

		// Накопитель результата.
		//vector_sum = new doublerealT[numberofcoarcenodes + 1];
		vector_sum = (doublerealT*)malloc((numberofcoarcenodes + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_3", (numberofcoarcenodes + 1));

		//integer size_v = sizeof(doublerealT)*(1 + numberofcoarcenodes);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		index_visit[0] = 0;
		index_size = 0;

		// Мы будем сканировать левый операнд построчно, а
		// после окончания обработки одной строки левого операнда
		// получать готовую строку результата.

		

		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Переход к новой строке, сброс накопителя результата.
			//#pragma omp parallel for
			//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			//vector_sum[i_1] = 0.0; // обнуление.
			//}
			// хоть профайлер и показывает что на memset тратиться меньше процессорного времени,
			// но там возникает системный вызов на который тратиться столько же времени что и раньше.
			// работа перекочевала из одного места в другое.
			// Более быстрое обнуление.
			//memset(vector_sum, 0, size_v);

			node_AVL_Gus* root_Gus = 0;
#if 0
			if (0) {
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику:
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else if (0) {

				// На основе АВЛ дерева.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						// Бинарный поиск в АВЛ дереве.
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							root_Gus = insert_Gus(root_Gus, iaddind);
							

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику:
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else
#endif
 {

				// На основе hash таблицы.
				// сканируем все элементы строки левого операнда.
#pragma omp parallel for 
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						
						// Бинарный поиск в АВЛ дереве.
						//foundnow = isfound_Gus(root_Gus, iaddind);
						
						// мгновенный поиск за O(1).
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							
							// Вставка в АВЛ дерево .
							//root_Gus = insert_Gus(root_Gus, iaddind);
							
							// Мгновенная вставка в hash table за O(1).
							hash_table[iaddind] = true;

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику:
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}


			doublerealT maxth = -1.0;
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];
				hash_table[jstr] = false; // initialization hash.
				if (istr != jstr) {
					// 14 января 2016 года.
					// Правильно определить барьер только по внедиагональным элементам.
					if (fabs(vector_sum[jstr]) > maxth) maxth = vector_sum[jstr];
				}
			}

			/*
			if (nsizeA > istartAnew2 + index_size) {
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
			// 15 декабря 2015.
			// Если не принять специальных мер элементы не будут упорядочены
			// и двоичным поиском воспользоваться нельзя.
			//if (index_visit[i_6] < index_visit[i_6 - 1]) {
			//printf("Gipotesa uporqdochennosti in Fred Gustavson neverna\n");
			//system("pause");
			//}

			integer jstr = index_visit[i_6];
			if (istr != jstr) {
			// 5 декабря 2015 года. Сохранение разреженности.
			//if (fabs(vector_sum[jstr]) > 1.0e-30) {
			if (fabs(vector_sum[jstr]) > barjerA*maxth) {
			Amat[istartAnew2].aij = vector_sum[jstr];
			Amat[istartAnew2].i = istr;
			Amat[istartAnew2].j = jstr;
			istartAnew2++;
			}
			}
			else {
			Amat[istartAnew2].aij = vector_sum[jstr];
			Amat[istartAnew2].i = istr;
			Amat[istartAnew2].j = jstr;
			istartAnew2++;
			}
			}
			}
			else {
			// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
			// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
			printf("Amat lack of memory\n");
			printf("yuo mast increase the size of the matrix Amat and restart solver\n");
			printf("please, press any key to exit.\n");
			system("pause");
			exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем проверками.
			doublerealT barjerA_maxth = barjerA*maxth;
			doublerealT mbarjerA_maxth = -barjerA_maxth;
			if (nsizeA > istartAnew2 + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {

					integer jstr = index_visit[i_6];
					doublerealT vs1 = vector_sum[jstr];
					if ((vs1 < mbarjerA_maxth) || (vs1 > barjerA_maxth)) {
						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = istr;
						Atemp.j = jstr;

						//Amat[istartAnew2].aij = vs1;
						//Amat[istartAnew2].i = istr;
						//Amat[istartAnew2].j = jstr;
						//istartAnew2++;

						Amat[istartAnew2++] = Atemp;

					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			index_size = 0;
			
			// Освобождение памяти из под АВЛ дерева.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;
			
		}

		//delete[] vector_sum;
		//delete[] index_visit;
		free(vector_sum);
		free(index_visit);


		//delete[] row_ind_AS;
		//delete[] row_ind_AE;
		//delete[] row_ind_PS;
		//delete[] row_ind_PE;
		free(row_ind_AS);
		free(row_ind_AE);
		free(row_ind_PS);
		free(row_ind_PE);




		// Есть подозрение что это избыточный код и его не надо вызывать.
		// 13  декабря 2015.
		// Это полностью подтвердилось 13 декабря 2015 года.
		/*

		if (bqs)
		{
		if (bCounting_Sort) {
		Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else
		{
		// Быстрая сортировка Хоара.
		qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}

		*/

		// Копируем матрицу А следующего уровня влево вплотную к матице первоначального уровня.
		//integer icounter3 = 1;
		integer nsize = istartAnew2 - (istartAnew);
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd, i_2 = 1; i_2 <= nsize; i_1++, i_2++) {
			integer i_right_position = istartAnew - 1 + i_2;
			Amat[i_1] = Amat[i_right_position];
		}

		if (bprint_mesage_diagnostic) {
			printf("Prolongation is construct.\n");
#if doubleintprecision == 1
			// Общее количество узлов не являющихся соседемя, но не С соседями 
			printf("Error interpolation is count %lld\n", ipromah);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic ipromah_one=%lld iz nih kol-vo beznadechnjh %lld\n", ipromah_one, ipromah_oneF);
#else
			// Общее количество узлов не являющихся соседемя, но не С соседями 
			printf("Error interpolation is count %d\n", ipromah);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic ipromah_one=%d iz nih kol-vo beznadechnjh %d\n", ipromah_one, ipromah_oneF);
#endif
			
			//system("pause");
		}
		if (debug_reshime) system("pause");


		//delete[] C_numerate;
		free(C_numerate);

		nnz_aRP[ilevel - 1] = nnzR - 1;
		iaddR += nnzR - 1;
		n_a[ilevel] = icounter - 1;
		nnz_a[ilevel] = nsize;
		iadd += nnz_a[ilevel - 1];


		ilevel++;

		// сортировка А по i.
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		/*

		if (nnz_a[ilevel - 1] < heapsortsizelimit) {
		HeapSort(Amat, n_a[ilevel - 1], 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		Ak1* Aorig = &Amat[1 + iadd];
		MergeSort(Aorig, nnz_a[ilevel - 1]);
		Aorig = nullptr;
		}

		*/

#if doubleintprecision == 1
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%lld ",Amat[i_1].j);
		//}
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#else
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%d ",Amat[i_1].j);
		//}
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#endif
		


		//exit(1);
		if (bprint_mesage_diagnostic) {
			printf("one level construct OK.\n");
		}
		if (debug_reshime) system("pause");


		//printf("export b\n");
		//exporttecplot(b,n);

		//doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

		// restriction
		//restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
		//for (integer ii = 1; ii <= n_a[0]; ii++) {
		//b[ii] = 0.0;
		//}

		/*{
		doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		for (integer ii = 1; ii <= n_a[1]; ii++) {
		test_coarse[ii] = 0.0;
		}

		{
		doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		for (integer ii = 1; ii <= n_a[2]; ii++) {
		test_coarse1[ii] = 0.0;
		}

		prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		}

		prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		}
		*/
		//prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

		//exporttecplot(b, n);
		// proverka start
		// на сетке 81х81 проверка успешно проходится.

		/*
		printf("proverka start\n");
		// первый уровень вложенности.
		if (ilevel > 1) {
		for (integer i = 1; i <= n; i++) {
		flag[i] = false;
		}

		for (integer ii77 = nnz_a[0] + 1; ii77 <= nnz_a[0] + nnz_a[1]; ii77++) {
		if (flag[Amat[ii77].i] == false) {
		integer istr77 = Amat[ii77].i;
		integer ic77 = ii77;
		//integer icdiag = ii77;
		doublerealT ap = 0.0;
		//x[istr] = b[istr];
		while ((ic77 <= nnz_a[0] + nnz_a[1]) && (Amat[ic77].i == istr77)) {
		if (Amat[ic77].j != istr77) {
		//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
		}
		else {
		ap = Amat[ic77].aij;
		//icdiag = ic77;
		}
		ic77++;
		}
		if (fabs(ap) < RealZERO) {
		#if doubleintprecision == 1
			printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr77);
		#else
			printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr77);
		#endif
		
		system("PAUSE");
		//exit(1);
		}

		flag[Amat[ii77].i] = true;

		}
		}
		}
		*/

		//проверка конец

		//delete[] count_neighbour;
		free(count_neighbour);
		//delete[] row_startA;
		free(row_startA);

	}// иерархия сеток построена.

	ilevel--;
	if (n_a[ilevel - 1] < 5) {
		// Чтобы не было последних уровней где меньше 5 узлов сетки.
		ilevel--;
	}

	if (bprint_mesage_diagnostic) {
		printf("grid complexity is %1.2f", (((double)(1.0*iadd)) / ((double)(1.0*nnz_a[0]))));
	}

	if (bji) {
		delete[] Atemp;
		Atemp = nullptr;
	}

	// 31.224s [50.986] 2D m=81 debug x64 acumulqtor
	// 13.792 [18.156] 2D m=81 realese x64 acumulqtor
	// 8.028s 2D m=81 debug x64 rozetka
	// 3.827 2D m=81 realese x64 rozetka

#if doubleintprecision == 1
	if (bprint_mesage_diagnostic) {
		printf("ilevel=%lld\n", ilevel);
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
		}
		printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	}
#else
	if (bprint_mesage_diagnostic) {
		printf("ilevel=%d\n", ilevel);
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
		}
		printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	}
#endif
	
	if (debug_reshime) system("pause");
	//system("pause");
	//exit(1);





	/*
	//exporttecplot(b,n);

	doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

	// restriction
	restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
	for (integer ii = 1; ii <= n_a[0]; ii++) {
	b[ii] = 0.0;
	}

	{
	doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

	// restriction
	restriction(R, 1+nnz_aRP[0], nnz_aRP[0]+nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	for (integer ii = 1; ii <= n_a[1]; ii++) {
	test_coarse[ii] = 0.0;
	}

	{
	doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

	// restriction
	restriction(R, 1 + nnz_aRP[0]+nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1]+nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	for (integer ii = 1; ii <= n_a[2]; ii++) {
	test_coarse1[ii] = 0.0;
	}

	prolongation(P, 1 + nnz_aRP[0]+ nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	}

	prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	}

	prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

	exporttecplot(b, n);
	*/

	// подготовка матрицы к cycling:
	/*
	// smoother.
	// 1 september 2015.
	void seidel(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
	{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	doublerealT ap = 0.0;
	x[istr] = b[istr];
	while ((ic<=iend)&&(Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else ap = Amat[ic].aij;
	ic++;
	}
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld",istr);
	#else
		printf("zero diagonal elements in string %d",istr);
	#endif
	
	getchar();
	exit(1);
	}
	else {
	x[istr] /= ap;
	}
	flag[Amat[ii].i] = true;
	}
	}


	} // seidel


	*/

	/*
	// Т.к. деление очень медленное то мы поделим лишь один раз.
	doublerealT *diag0 = new doublerealT[n_a[0] + 1];
	doublerealT *diag1=nullptr;
	if (ilevel > 1) {
	diag1 = new doublerealT[n_a[1] + 1];
	}
	doublerealT *diag2=nullptr;
	if (ilevel > 2) {
	diag2 = new doublerealT[n_a[2] + 1];
	}
	doublerealT *diag3 = nullptr;
	if (ilevel > 3) {
	diag3 = new doublerealT[n_a[3] + 1];
	}
	doublerealT *diag4 = nullptr;
	if (ilevel > 4) {
	diag4 = new doublerealT[n_a[4] + 1];
	}
	doublerealT *diag5 = nullptr;
	if (ilevel > 5) {
	diag5 = new doublerealT[n_a[5] + 1];
	}
	doublerealT *diag6 = nullptr;
	if (ilevel > 6) {
	diag6 = new doublerealT[n_a[6] + 1];
	}
	doublerealT *diag7 = nullptr;
	if (ilevel > 7) {
	diag7 = new doublerealT[n_a[7] + 1];
	}
	doublerealT *diag8 = nullptr;
	if (ilevel > 8) {
	diag8 = new doublerealT[n_a[8] + 1];
	}
	*/

	// Т.к. деление очень медленное то мы поделим лишь один раз.
	doublerealT *diag0 = nullptr;
	//diag0 = new doublerealT[n_a[0] + 1];
	diag0 = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(diag0, "diag0", "classic_aglomerative_amg_3", (n_a[0] + 1));

	doublerealT *diag1 = nullptr;
	if (ilevel > 1) {
		//diag1 = new doublerealT[n_a[1] + 1];
		diag1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag1, "diag1", "classic_aglomerative_amg_3", (n_a[1] + 1));
	}
	doublerealT *diag2 = nullptr;
	if (ilevel > 2) {
		//diag2 = new doublerealT[n_a[2] + 1];
		diag2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag2, "diag2", "classic_aglomerative_amg_3", (n_a[2] + 1));
	}
	doublerealT *diag3 = nullptr;
	if (ilevel > 3) {
		//diag3 = new doublerealT[n_a[3] + 1];
		diag3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag3, "diag3", "classic_aglomerative_amg_3", (n_a[3] + 1));
	}
	doublerealT *diag4 = nullptr;
	if (ilevel > 4) {
		//diag4 = new doublerealT[n_a[4] + 1];
		diag4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag4, "diag4", "classic_aglomerative_amg_3", (n_a[4] + 1));
	}
	doublerealT *diag5 = nullptr;
	if (ilevel > 5) {
		//diag5 = new doublerealT[n_a[5] + 1];
		diag5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag5, "diag5", "classic_aglomerative_amg_3", (n_a[5] + 1));
	}
	doublerealT *diag6 = nullptr;
	if (ilevel > 6) {
		//diag6 = new doublerealT[n_a[6] + 1];
		diag6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag6, "diag6", "classic_aglomerative_amg_3", (n_a[6] + 1));
	}
	doublerealT *diag7 = nullptr;
	if (ilevel > 7) {
		//diag7 = new doublerealT[n_a[7] + 1];
		diag7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag7, "diag7", "classic_aglomerative_amg_3", (n_a[7] + 1));
	}
	doublerealT *diag8 = nullptr;
	if (ilevel > 8) {
		// diag8 = new doublerealT[n_a[8] + 1];
		diag8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag8, "diag8", "classic_aglomerative_amg_3", (n_a[8] + 1));
	}

	bnested_desection_global_amg = nullptr;
	bool *nested_desection0 = nullptr;
	bool *nested_desection1 = nullptr;
	bool *nested_desection2 = nullptr;
	bool *nested_desection3 = nullptr;
	bool *nested_desection4 = nullptr;
	bool *nested_desection5 = nullptr;
	bool *nested_desection6 = nullptr;
	bool *nested_desection7 = nullptr;
	bool *nested_desection8 = nullptr;
	if (!bonly_serial) {
		// nested desection start
		bnested_desection_global_amg = (bool*)malloc((n_a[0] + 1)*sizeof(bool));
		handle_error<bool>(bnested_desection_global_amg, "bnested_desection_global_amg", "classic_aglomerative_amg_3", (n_a[0] + 1));


		nested_desection0 = (bool*)malloc((n_a[0] + 1)*sizeof(bool));
		handle_error<bool>(nested_desection0, "nested_desection0", "classic_aglomerative_amg_3", (n_a[0] + 1));


		if (ilevel > 1) {
			nested_desection1 = (bool*)malloc((n_a[1] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection1, "nested_desection1", "classic_aglomerative_amg_3", (n_a[1] + 1));
		}

		if (ilevel > 2) {
			nested_desection2 = (bool*)malloc((n_a[2] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection2, "nested_desection2", "classic_aglomerative_amg_3", (n_a[2] + 1));
		}

		if (ilevel > 3) {
			nested_desection3 = (bool*)malloc((n_a[3] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection3, "nested_desection3", "classic_aglomerative_amg_3", (n_a[3] + 1));
		}

		if (ilevel > 4) {
			nested_desection4 = (bool*)malloc((n_a[4] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection4, "nested_desection4", "classic_aglomerative_amg_3", (n_a[4] + 1));
		}

		if (ilevel > 5) {
			nested_desection5 = (bool*)malloc((n_a[5] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection5, "nested_desection5", "classic_aglomerative_amg_3", (n_a[5] + 1));
		}

		if (ilevel > 6) {
			nested_desection6 = (bool*)malloc((n_a[6] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection6, "nested_desection6", "classic_aglomerative_amg_3", (n_a[6] + 1));
		}

		if (ilevel > 7) {
			nested_desection7 = (bool*)malloc((n_a[7] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection7, "nested_desection7", "classic_aglomerative_amg_3", (n_a[7] + 1));
		}

		if (ilevel > 8) {
			nested_desection8 = (bool*)malloc((n_a[8] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection8, "nested_desection8", "classic_aglomerative_amg_3", (n_a[8] + 1));
		}
	}
	// nested_desection_end

	integer *row_ptr_start = nullptr;
	//row_ptr_start = new integer[4 * n_a[0] + 1];
	row_ptr_start = (integer*)malloc((4 * n_a[0] + 1)*sizeof(integer));
	handle_error<integer>(row_ptr_start, " row_ptr_start", "classic_aglomerative_amg_3", (4 * n_a[0] + 1));

	integer *row_ptr_end = nullptr;
	//row_ptr_end = new integer[4 * n_a[0] + 1];
	row_ptr_end = (integer*)malloc((4 * n_a[0] + 1)*sizeof(integer));
	handle_error<integer>(row_ptr_end, " row_ptr_end", "classic_aglomerative_amg_3", (4 * n_a[0] + 1));

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = 1; ii <= nnz_a[0]; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			integer icdiag = ii;
			row_ptr_start[istr] = ii;
			doublerealT ap = 0.0; // значение на диагонали.
			//x[istr] = b[istr];
			while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else {
					ap = Amat[ic].aij;
					icdiag = ic;
				}
				ic++;
			}
			row_ptr_end[istr] = ic - 1;
			if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld in basic matrix", istr);
#else
				printf("zero diagonal elements in string %d in basic matrix", istr);
#endif
				
				system("PAUSE");
				exit(1);
			}
			else {
				//x[istr] /= ap;
			}

			flag[Amat[ii].i] = true;
			Ak1 temp = Amat[ii];
			Amat[ii] = Amat[icdiag];
			Amat[icdiag] = temp;
			diag0[Amat[ii].i] = ap; // для ускорения вычисления невязки.
			Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
		}
	}

	bool bstop = false;

	// 14 сентября 2015 понедельник четвёртый уровень вложенности.
	// Уровни вложенности с первого по седьмой сразу. 12.07.2016.

	for (integer ilevel_detector = 1; ilevel_detector <= 7; ilevel_detector++) {

		if (ilevel > ilevel_detector) {
			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}
			integer ist = 1;
			for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
				ist += nnz_a[ilev];
			}
			integer iend = 0;
			for (integer ilev = 0; ilev <= ilevel_detector; ilev++) {
				iend += nnz_a[ilev];
			}
			for (integer ii = ist; ii <= iend; ii++) {
				if (flag[Amat[ii].i] == false) {
					integer istr = Amat[ii].i;
					integer ic = ii;
					integer icdiag = ii;
					integer istart_row_ptr = istr;
					for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
						istart_row_ptr += n_a[ilev];
					}
					row_ptr_start[istart_row_ptr] = ii;
					doublerealT ap = 0.0;
					//x[istr] = b[istr];
					while ((ic <= iend) && (Amat[ic].i == istr)) {
						if (Amat[ic].j != istr) {
							//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
							// Все внедиагональные элементы должны быть строго отрицательны.
							// Если это не так то надо выдавать предупреждение о логической ошибке пользователю.
							if (Amat[ic].aij >= 0.0) {
#if doubleintprecision == 1
								printf("polochitelnji vnediagonalnj element %e in matrix level %lld in string %lld...\n", Amat[ic].aij, ilevel_detector, istr);
#else
								printf("polochitelnji vnediagonalnj element %e in matrix level %d in string %d...\n", Amat[ic].aij, ilevel_detector, istr);
#endif
								system("PAUSE");
							}
						}
						else {
							ap = Amat[ic].aij;
							icdiag = ic;
						}
						ic++;
					}
					row_ptr_end[istart_row_ptr] = ic - 1;
					if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
						printf("zero diagonal elements in string %lld in level 7 matrix", istr);
#else
						printf("zero diagonal elements in string %d in level 7 matrix", istr);
#endif
						
						system("PAUSE");
						exit(1);
					}
					else {
						//x[istr] /= ap;
					}

					flag[Amat[ii].i] = true;
					Ak1 temp = Amat[ii];
					Amat[ii] = Amat[icdiag];
					Amat[icdiag] = temp;
					switch (ilevel_detector) {
					case 1: diag1[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					case 2: diag2[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					case 3: diag3[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					case 4: diag4[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					case 5: diag5[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					case 6: diag6[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					case 7: diag7[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					default: printf("ilevel_detector incorrect\n"); 
						//getchar();
						system("PAUSE");
						break;
					}

					Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
				}
			}
		}
	}

	if (bstop) exit(1);

	// восьмой уровень вложенности.
	/*
	if (ilevel > 8) {
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + 1;
	integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
	for (integer ii = ist; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	integer icdiag = ii;
	row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ii;
	doublerealT ap = 0.0;
	//x[istr] = b[istr];
	while ((ic <= iend) && (Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else {
	ap = Amat[ic].aij;
	icdiag = ic;
	}
	ic++;
	}
	row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ic - 1;
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld in level 7 matrix", istr);
	#else
		printf("zero diagonal elements in string %d in level 7 matrix", istr);
	#endif
	
	system("PAUSE");
	exit(1);
	}
	else {
	//x[istr] /= ap;
	}

	flag[Amat[ii].i] = true;
	Ak1 temp = Amat[ii];
	Amat[ii] = Amat[icdiag];
	Amat[icdiag] = temp;
	diag8[Amat[ii].i] = ap; // для ускорения вычисления невязки.
	Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
	}
	}
	}
	*/


	if (!bonly_serial) {
		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 0.
		// nested_desection0
		nested_desection_patch(Amat, n_a[0], nested_desection0, row_ptr_start, row_ptr_end, 0);
		if (bprint_mesage_diagnostic) {
			printf("part1\n");
		}


		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 1.
		// nested_desection1
		nested_desection_patch(Amat, n_a[1], nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
		if (bprint_mesage_diagnostic) {
			printf("part2\n");
		}
		nested_desection_patch(Amat, n_a[2], nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
		if (bprint_mesage_diagnostic) {
			printf("part3\n");
		}
		nested_desection_patch(Amat, n_a[3], nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
		if (bprint_mesage_diagnostic) {
			printf("part4\n");
		}
		nested_desection_patch(Amat, n_a[4], nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
		if (bprint_mesage_diagnostic) {
			printf("part5\n");
		}
		nested_desection_patch(Amat, n_a[5], nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
		if (bprint_mesage_diagnostic) {
			printf("part6\n");
		}
		nested_desection_patch(Amat, n_a[6], nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
		if (bprint_mesage_diagnostic) {
			printf("part7\n");
		}
		nested_desection_patch(Amat, n_a[7], nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
		if (bprint_mesage_diagnostic) {
			printf("part8 \n");
			printf("nested desection is finish\n");
		}

	}


	// smoother.
	// 9 september 2015.
	// q - quick.
	// seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
	//void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
	//{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	//integer startpos = istartq + iadd;
	//integer endpos = iendq+iadd;
	//for (integer ii = startpos; ii <= endpos; ii++) {
	//integer istr = ii - iadd;
	//x[istr] = b[istr];
	//for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
	//{
	//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
	//}
	//x[istr] *= Amat[row_ptr_start[ii]].aij;
	//}


	//} // seidelq

	// Освобождение памяти используемой на этапе построения иерархии матриц.

	//delete[] this_is_C_node;
	//delete[] this_is_F_node;
	if (this_is_C_node!=nullptr) {
	   free(this_is_C_node);
	   this_is_C_node=nullptr;
	}
	if (this_is_F_node!=nullptr) {
	   free(this_is_F_node);
       this_is_F_node=nullptr;
	}
	//delete[] hash_table;
	free(hash_table);
	free(hash_table2);
	//delete[] istack;
	//delete[] istack2;
	free(istack);
	free(istack2);


	if (bprint_mesage_diagnostic) {
		printf("cycling: V cycle.\n");
#if doubleintprecision == 1
		printf("level=%lld\n", ilevel);
#else
		printf("level=%d\n", ilevel);
#endif
		
		printf("multigrid R.P.Fedorenko 1961.\n");
		printf("standart aglomerative algebraic multigrid method.\n");
	}
	if (debug_reshime) system("pause");
	//exit(1);

	// 10 11 21 multigrid tutorial Вильм Бригг.
	// Высокорейнольдсовое обтекание квадрата в DavisTest,
	// решатель работал на x-компоненте скорости. Сетка сгущалась
	// к поверхности квадрата достаточно сильно. Это дало расходимость
	// amg v0.08 решателя на данной задаче с параметрами nu1=4, nu2=3.
	// Параметры nu1=8, nu2=7 обеспечили сходимость вычислительного процесса.

	// Возможно имеет смысл сделать управляемый выход из сглаживателя, допустим
	// если невязка опустилась ниже первоначальной в 0.1 раз то имеет смысл досрочно 
	// оборвать итерации сглаживателя.


	// nu1=0; nu2=2; nFinestSweeps=2 is recomended 
	// Masashi Imano. Optimization of parameter setting for GAMG
	// solver in simple solver. 
	// Aug 26th 2012. OpeanFOAM study. 
	// nu1=0 имеем расходимость на BSK Dmitrii.
	// nFinestSweeps=2 имеем расходимость на BSK Dmitrii.
	// BSK Dmitrii сходится при nu1=1, nu2=2, nFinestSweeps=3.

	integer nu1 = 1; // minimum value 1 // 4 // 8
	integer nu2 = 2; // minimum value 2 // 3 // 7

	integer nFinestSweeps = 3;


	// Смысл этих параметров в том что они экономят ресурсы процессора
	// в теории осуществляя досрочный выход из пред и пост сглаживаний.
	// Т.е. параметры nu1,nu2 задаются с запасом и алгоритм сам использует
	// сколько ему взять итераций для оптимальной работы (сходимости). 
	// Пользователь не ломает голову какие задавать параметры nu1, nu2 
	// а задаёт их верхние предельные значения. 
	doublerealT process_flow_beta = 0.7;
	doublerealT process_flow_alpha = 0.1;
	bool process_flow_logic = false;

	if (process_flow_logic) {
		nu1 = 40;
		nu2 = 40;
	}

	if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
		printf("nu1=%lld, nu2=%lld\n", nu1, nu2);
#else
		printf("nu1=%d, nu2=%d\n", nu1, nu2);
#endif
		
	}

	//ilevel = 1; //debug
	doublerealT rho = 1.0;
	doublerealT dres = 1.0;
	integer iiter = 1;
	//const doublerealT tolerance = 1.0e-12;
	// 13 февраля 2016 калибруем точность солвера с целью ускорения получения результата.
	// Т.к. нам ненужна точность выше чем десятая доля градуса по температуре.
	// начальное значение невязки составляет примерно 7000.0.
	const doublerealT tolerance = 0.003; // точность выхода по классическому определению L2 нормы.


	doublerealT *residual_fine = nullptr;
	//residual_fine = new doublerealT[n_a[0] + 1];
	doublerealT *residual_coarse = nullptr;
	doublerealT* error_approx_coarse = nullptr;
	doublerealT *residual_fine1 = nullptr;
	doublerealT *residual_coarse1 = nullptr;
	doublerealT* error_approx_coarse1 = nullptr;
	doublerealT *error_approx_fine1 = nullptr;
	doublerealT *residual_fine2 = nullptr;
	doublerealT *residual_coarse2 = nullptr;
	doublerealT* error_approx_coarse2 = nullptr;
	doublerealT *error_approx_fine2 = nullptr;
	doublerealT *residual_fine3 = nullptr;
	doublerealT *residual_coarse3 = nullptr;
	doublerealT* error_approx_coarse3 = nullptr;
	doublerealT *error_approx_fine3 = nullptr;
	doublerealT *residual_fine4 = nullptr;
	doublerealT *residual_coarse4 = nullptr;
	doublerealT *error_approx_coarse4 = nullptr;
	doublerealT *error_approx_fine4 = nullptr;
	doublerealT *residual_fine5 = nullptr;
	doublerealT *residual_coarse5 = nullptr;
	doublerealT* error_approx_coarse5 = nullptr;
	doublerealT *error_approx_fine5 = nullptr;
	doublerealT *residual_fine6 = nullptr;
	doublerealT *residual_coarse6 = nullptr;
	doublerealT* error_approx_coarse6 = nullptr;
	doublerealT *error_approx_fine6 = nullptr;
	doublerealT *residual_fine7 = nullptr;
	doublerealT *residual_coarse7 = nullptr;
	doublerealT* error_approx_coarse7 = nullptr;
	doublerealT *error_approx_fine7 = nullptr;
	doublerealT *residual_fine8 = nullptr;
	doublerealT *residual_coarse8 = nullptr;
	doublerealT* error_approx_coarse8 = nullptr;
	doublerealT *error_approx_fine8 = nullptr;
	doublerealT *residual_fine9 = nullptr;
	doublerealT *residual_coarse9 = nullptr;
	doublerealT* error_approx_coarse9 = nullptr;
	doublerealT *error_approx_fine9 = nullptr;
	doublerealT *residual_fine10 = nullptr;
	doublerealT *residual_coarse10 = nullptr;
	doublerealT* error_approx_coarse10 = nullptr;
	doublerealT *error_approx_fine10 = nullptr;
	doublerealT *residual_fine11 = nullptr;
	doublerealT *residual_coarse11 = nullptr;
	doublerealT* error_approx_coarse11 = nullptr;
	doublerealT *error_approx_fine11 = nullptr;
	doublerealT *residual_fine12 = nullptr;
	doublerealT *residual_coarse12 = nullptr;
	doublerealT* error_approx_coarse12 = nullptr;
	doublerealT *error_approx_fine12 = nullptr;
	doublerealT *residual_fine13 = nullptr;
	doublerealT *residual_coarse13 = nullptr;
	doublerealT* error_approx_coarse13 = nullptr;
	doublerealT *error_approx_fine13 = nullptr;
	doublerealT *residual_fine14 = nullptr;
	doublerealT *residual_coarse14 = nullptr;
	doublerealT* error_approx_coarse14 = nullptr;
	doublerealT *error_approx_fine14 = nullptr;
	doublerealT *residual_fine15 = nullptr;
	doublerealT *residual_coarse15 = nullptr;
	doublerealT* error_approx_coarse15 = nullptr;
	doublerealT *error_approx_fine15 = nullptr;
	doublerealT *residual_fine16 = nullptr;
	doublerealT *residual_coarse16 = nullptr;
	doublerealT* error_approx_coarse16 = nullptr;
	doublerealT *error_approx_fine16 = nullptr;
	doublerealT *residual_fine17 = nullptr;
	doublerealT *residual_coarse17 = nullptr;
	doublerealT* error_approx_coarse17 = nullptr;
	doublerealT *error_approx_fine17 = nullptr;

	/*
	residual_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	if (residual_fine == nullptr) {
	// недостаточно памяти на данном оборудовании.
	printf("Problem: not enough memory on your equipment for residual_fine in classic_aglomerative_amg2 my_agregat_amg...\n");
	printf("Please any key to exit...\n");
	//getchar();
	system("pause");
	exit(1);
	}
	if (ilevel > 1) {
	residual_coarse = new doublerealT[n_a[1] + 1];
	error_approx_coarse = new doublerealT[n_a[1] + 1];
	if (ilevel > 2) {
	// residual
	residual_fine1 = new doublerealT[n_a[1] + 1];
	residual_coarse1 = new doublerealT[n_a[2] + 1];
	error_approx_coarse1 = new doublerealT[n_a[2] + 1];
	error_approx_fine1 = new doublerealT[n_a[1] + 1];
	if (ilevel > 3) {
	// residual
	residual_fine2 = new doublerealT[n_a[2] + 1];
	residual_coarse2 = new doublerealT[n_a[3] + 1];
	error_approx_coarse2 = new doublerealT[n_a[3] + 1];
	error_approx_fine2 = new doublerealT[n_a[2] + 1];
	if (ilevel > 4) {
	// residual
	residual_fine3 = new doublerealT[n_a[3] + 1];
	residual_coarse3 = new doublerealT[n_a[4] + 1];
	error_approx_coarse3 = new doublerealT[n_a[4] + 1];
	error_approx_fine3 = new doublerealT[n_a[3] + 1];
	if (ilevel > 5) {
	// residual
	residual_fine4 = new doublerealT[n_a[4] + 1];
	residual_coarse4 = new doublerealT[n_a[5] + 1];
	error_approx_coarse4 = new doublerealT[n_a[5] + 1];
	error_approx_fine4 = new doublerealT[n_a[4] + 1];
	if (ilevel > 6) {
	// residual
	residual_fine5 = new doublerealT[n_a[5] + 1];
	residual_coarse5 = new doublerealT[n_a[6] + 1];
	error_approx_coarse5 = new doublerealT[n_a[6] + 1];
	error_approx_fine5 = new doublerealT[n_a[5] + 1];
	if (ilevel > 7) {
	// residual
	residual_fine6 = new doublerealT[n_a[6] + 1];
	residual_coarse6 = new doublerealT[n_a[7] + 1];
	error_approx_coarse6 = new doublerealT[n_a[7] + 1];
	error_approx_fine6 = new doublerealT[n_a[6] + 1];
	if (ilevel > 8) {
	// residual
	residual_fine7 = new doublerealT[n_a[7] + 1];
	residual_coarse7 = new doublerealT[n_a[8] + 1];
	error_approx_coarse7 = new doublerealT[n_a[8] + 1];
	error_approx_fine7 = new doublerealT[n_a[7] + 1];
	if (ilevel > 9) {
	// residual
	residual_fine8 = new doublerealT[n_a[8] + 1];
	residual_coarse8 = new doublerealT[n_a[9] + 1];
	error_approx_coarse8 = new doublerealT[n_a[9] + 1];
	error_approx_fine8 = new doublerealT[n_a[8] + 1];
	if (ilevel > 10) {
	// residual
	residual_fine9 = new doublerealT[n_a[9] + 1];
	residual_coarse9 = new doublerealT[n_a[10] + 1];
	error_approx_coarse9 = new doublerealT[n_a[10] + 1];
	error_approx_fine9 = new doublerealT[n_a[9] + 1];
	if (ilevel > 11) {
	// residual
	residual_fine10 = new doublerealT[n_a[10] + 1];
	residual_coarse10 = new doublerealT[n_a[11] + 1];
	error_approx_coarse10 = new doublerealT[n_a[11] + 1];
	error_approx_fine10 = new doublerealT[n_a[10] + 1];
	if (ilevel > 12) {
	// residual
	residual_fine11 = new doublerealT[n_a[11] + 1];
	residual_coarse11 = new doublerealT[n_a[12] + 1];
	error_approx_coarse11 = new doublerealT[n_a[12] + 1];
	error_approx_fine11 = new doublerealT[n_a[11] + 1];
	if (ilevel > 13) {
	// residual
	residual_fine12 = new doublerealT[n_a[12] + 1];
	residual_coarse12 = new doublerealT[n_a[13] + 1];
	error_approx_coarse12 = new doublerealT[n_a[13] + 1];
	error_approx_fine12 = new doublerealT[n_a[12] + 1];
	if (ilevel > 14) {
	// residual
	residual_fine13 = new doublerealT[n_a[13] + 1];
	residual_coarse13 = new doublerealT[n_a[14] + 1];
	error_approx_coarse13 = new doublerealT[n_a[14] + 1];
	error_approx_fine13 = new doublerealT[n_a[13] + 1];
	if (ilevel > 15) {
	// residual
	residual_fine14 = new doublerealT[n_a[14] + 1];
	residual_coarse14 = new doublerealT[n_a[15] + 1];
	error_approx_coarse14 = new doublerealT[n_a[15] + 1];
	error_approx_fine14 = new doublerealT[n_a[14] + 1];
	if (ilevel > 16) {
	// residual
	residual_fine15 = new doublerealT[n_a[15] + 1];
	residual_coarse15 = new doublerealT[n_a[16] + 1];
	error_approx_coarse15 = new doublerealT[n_a[16] + 1];
	error_approx_fine15 = new doublerealT[n_a[15] + 1];
	if (ilevel > 17) {
	// residual
	residual_fine16 = new doublerealT[n_a[16] + 1];
	residual_coarse16 = new doublerealT[n_a[17] + 1];
	error_approx_coarse16 = new doublerealT[n_a[17] + 1];
	error_approx_fine16 = new doublerealT[n_a[16] + 1];
	if (ilevel > 18) {
	// residual
	residual_fine17 = new doublerealT[n_a[17] + 1];
	residual_coarse17 = new doublerealT[n_a[18] + 1];
	error_approx_coarse17 = new doublerealT[n_a[18] + 1];
	error_approx_fine17 = new doublerealT[n_a[17] + 1];

	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
	*/

	// лучше выделять оперативную память небольшими блоками т.к.
	// оперативная память фрагментирована системными dll и
	// большого свободного блока может не найтись.


	residual_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(residual_fine, "residual_fine", "classic_aglomerative_amg_3", (n_a[0] + 1));

	if (ilevel > 1) {
		//residual_coarse = new doublerealT[n_a[1] + 1];
		residual_coarse = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(residual_coarse, "residual_coarse", "classic_aglomerative_amg_3", (n_a[1] + 1));

		//error_approx_coarse = new doublerealT[n_a[1] + 1];
		error_approx_coarse = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(error_approx_coarse, "error_approx_coarse", "classic_aglomerative_amg_3", (n_a[1] + 1));

		if (ilevel > 2) {
			// residual
			//residual_fine1 = new doublerealT[n_a[1] + 1];
			residual_fine1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(residual_fine1, "residual_fine1", "classic_aglomerative_amg_3", (n_a[1] + 1));

			//residual_coarse1 = new doublerealT[n_a[2] + 1];
			residual_coarse1 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(residual_coarse1, "residual_coarse1", "classic_aglomerative_amg_3", (n_a[2] + 1));

			//error_approx_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_coarse1 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_coarse1, "error_approx_coarse1", "classic_aglomerative_amg_3", (n_a[2] + 1));

			//error_approx_fine1 = new doublerealT[n_a[1] + 1];
			error_approx_fine1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_fine1, "error_approx_fine1", "classic_aglomerative_amg_3", (n_a[1] + 1));

			if (ilevel > 3) {
				// residual
				//residual_fine2 = new doublerealT[n_a[2] + 1];
				residual_fine2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(residual_fine2, "residual_fine2", "classic_aglomerative_amg_3", (n_a[2] + 1));

				//residual_coarse2 = new doublerealT[n_a[3] + 1];
				residual_coarse2 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(residual_coarse2, "residual_coarse2", "classic_aglomerative_amg_3", (n_a[3] + 1));

				//error_approx_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_coarse2 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(error_approx_coarse2, "error_approx_coarse2", "classic_aglomerative_amg_3", (n_a[3] + 1));

				//error_approx_fine2 = new doublerealT[n_a[2] + 1];
				error_approx_fine2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(error_approx_fine2, "error_approx_fine2", "classic_aglomerative_amg_3", (n_a[2] + 1));

				if (ilevel > 4) {
					// residual
					//residual_fine3 = new doublerealT[n_a[3] + 1];
					residual_fine3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(residual_fine3, "residual_fine3", "classic_aglomerative_amg_3", (n_a[3] + 1));

					//residual_coarse3 = new doublerealT[n_a[4] + 1];
					residual_coarse3 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(residual_coarse3, "residual_coarse3", "classic_aglomerative_amg_3", (n_a[4] + 1));

					//error_approx_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_coarse3 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(error_approx_coarse3, "error_approx_coarse3", "classic_aglomerative_amg_3", (n_a[4] + 1));

					//error_approx_fine3 = new doublerealT[n_a[3] + 1];
					error_approx_fine3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(error_approx_fine3, "error_approx_fine3", "classic_aglomerative_amg_3", (n_a[3] + 1));

					if (ilevel > 5) {
						// residual
						//residual_fine4 = new doublerealT[n_a[4] + 1];
						residual_fine4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(residual_fine4, "residual_fine4", "classic_aglomerative_amg_3", (n_a[4] + 1));

						//residual_coarse4 = new doublerealT[n_a[5] + 1];
						residual_coarse4 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(residual_coarse4, "residual_coarse4", "classic_aglomerative_amg_3", (n_a[5] + 1));

						//error_approx_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_coarse4 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(error_approx_coarse4, "error_approx_coarse4", "classic_aglomerative_amg_3", (n_a[5] + 1));

						//error_approx_fine4 = new doublerealT[n_a[4] + 1];
						error_approx_fine4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(error_approx_fine4, "error_approx_fine4", "classic_aglomerative_amg_3", (n_a[4] + 1));

						if (ilevel > 6) {
							// residual
							//residual_fine5 = new doublerealT[n_a[5] + 1];
							residual_fine5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(residual_fine5, "residual_fine5", "classic_aglomerative_amg_3", (n_a[5] + 1));

							//residual_coarse5 = new doublerealT[n_a[6] + 1];
							residual_coarse5 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(residual_coarse5, "residual_coarse5", "classic_aglomerative_amg_3", (n_a[6] + 1));

							//error_approx_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_coarse5 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(error_approx_coarse5, "error_approx_coarse5", "classic_aglomerative_amg_3", (n_a[6] + 1));

							//error_approx_fine5 = new doublerealT[n_a[5] + 1];
							error_approx_fine5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(error_approx_fine5, "error_approx_fine5", "classic_aglomerative_amg_3", (n_a[5] + 1));

							if (ilevel > 7) {
								// residual
								//residual_fine6 = new doublerealT[n_a[6] + 1];
								residual_fine6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(residual_fine6, "residual_fine6", "classic_aglomerative_amg_3", (n_a[6] + 1));

								//residual_coarse6 = new doublerealT[n_a[7] + 1];
								residual_coarse6 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(residual_coarse6, "residual_coarse6", "classic_aglomerative_amg_3", (n_a[7] + 1));

								//error_approx_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_coarse6 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(error_approx_coarse6, "error_approx_coarse6", "classic_aglomerative_amg_3", (n_a[7] + 1));

								//error_approx_fine6 = new doublerealT[n_a[6] + 1];
								error_approx_fine6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(error_approx_fine6, "error_approx_fine6", "classic_aglomerative_amg_3", (n_a[6] + 1));

								if (ilevel > 8) {
									// residual
									//residual_fine7 = new doublerealT[n_a[7] + 1];
									residual_fine7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(residual_fine7, "residual_fine7", "classic_aglomerative_amg_3", (n_a[7] + 1));

									//residual_coarse7 = new doublerealT[n_a[8] + 1];
									residual_coarse7 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(residual_coarse7, "residual_coarse7", "classic_aglomerative_amg_3", (n_a[8] + 1));

									//error_approx_coarse7 = new doublerealT[n_a[8] + 1];
									error_approx_coarse7 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(error_approx_coarse7, "error_approx_coarse7", "classic_aglomerative_amg_3", (n_a[8] + 1));

									//error_approx_fine7 = new doublerealT[n_a[7] + 1];
									error_approx_fine7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(error_approx_fine7, "error_approx_fine7", "classic_aglomerative_amg_3", (n_a[7] + 1));

									if (ilevel > 9) {
										// residual
										//residual_fine8 = new doublerealT[n_a[8] + 1];
										residual_fine8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(residual_fine8, "residual_fine8", "classic_aglomerative_amg_3", (n_a[8] + 1));

										//residual_coarse8 = new doublerealT[n_a[9] + 1];
										residual_coarse8 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(residual_coarse8, "residual_coarse8", "classic_aglomerative_amg_3", (n_a[9] + 1));

										//error_approx_coarse8 = new doublerealT[n_a[9] + 1];
										error_approx_coarse8 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(error_approx_coarse8, "error_approx_coarse8", "classic_aglomerative_amg_3", (n_a[9] + 1));

										//error_approx_fine8 = new doublerealT[n_a[8] + 1];
										error_approx_fine8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(error_approx_fine8, "error_approx_fine8", "classic_aglomerative_amg_3", (n_a[8] + 1));

										if (ilevel > 10) {
											// residual
											//residual_fine9 = new doublerealT[n_a[9] + 1];
											residual_fine9 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(residual_fine9, "residual_fine9", "classic_aglomerative_amg_3", (n_a[9] + 1));

											//residual_coarse9 = new doublerealT[n_a[10] + 1];
											residual_coarse9 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(residual_coarse9, "residual_coarse9", "classic_aglomerative_amg_3", (n_a[10] + 1));

											//error_approx_coarse9 = new doublerealT[n_a[10] + 1];
											error_approx_coarse9 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(error_approx_coarse9, "error_approx_coarse9", "classic_aglomerative_amg_3", (n_a[10] + 1));

											//error_approx_fine9 = new doublerealT[n_a[9] + 1];
											error_approx_fine9 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(error_approx_fine9, "error_approx_fine9", "classic_aglomerative_amg_3", (n_a[9] + 1));

											if (ilevel > 11) {
												// residual
												//residual_fine10 = new doublerealT[n_a[10] + 1];
												residual_fine10 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(residual_fine10, "residual_fine10", "classic_aglomerative_amg_3", (n_a[10] + 1));

												//residual_coarse10 = new doublerealT[n_a[11] + 1];
												residual_coarse10 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(residual_coarse10, "residual_coarse10", "classic_aglomerative_amg_3", (n_a[11] + 1));

												//error_approx_coarse10 = new doublerealT[n_a[11] + 1];
												error_approx_coarse10 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(error_approx_coarse10, "error_approx_coarse10", "classic_aglomerative_amg_3", (n_a[11] + 1));

												//error_approx_fine10 = new doublerealT[n_a[10] + 1];
												error_approx_fine10 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(error_approx_fine10, "error_approx_fine10", "classic_aglomerative_amg_3", (n_a[10] + 1));

												if (ilevel > 12) {
													// residual
													//residual_fine11 = new doublerealT[n_a[11] + 1];
													residual_fine11 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(residual_fine11, "residual_fine11", "classic_aglomerative_amg_3", (n_a[11] + 1));

													//residual_coarse11 = new doublerealT[n_a[12] + 1];
													residual_coarse11 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(residual_coarse11, "residual_coarse11", "classic_aglomerative_amg_3", (n_a[12] + 1));

													//error_approx_coarse11 = new doublerealT[n_a[12] + 1];
													error_approx_coarse11 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(error_approx_coarse11, "error_approx_coarse11", "classic_aglomerative_amg_3", (n_a[12] + 1));

													//error_approx_fine11 = new doublerealT[n_a[11] + 1];
													error_approx_fine11 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(error_approx_fine11, "error_approx_fine11", "classic_aglomerative_amg_3", (n_a[11] + 1));

													if (ilevel > 13) {
														// residual
														//residual_fine12 = new doublerealT[n_a[12] + 1];
														residual_fine12 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(residual_fine12, "residual_fine12", "classic_aglomerative_amg_3", (n_a[12] + 1));

														//residual_coarse12 = new doublerealT[n_a[13] + 1];
														residual_coarse12 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(residual_coarse12, "residual_coarse12", "classic_aglomerative_amg_3", (n_a[13] + 1));

														//error_approx_coarse12 = new doublerealT[n_a[13] + 1];
														error_approx_coarse12 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(error_approx_coarse12, "error_approx_coarse12", "classic_aglomerative_amg_3", (n_a[13] + 1));

														//error_approx_fine12 = new doublerealT[n_a[12] + 1];
														error_approx_fine12 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(error_approx_fine12, "error_approx_fine12", "classic_aglomerative_amg_3", (n_a[12] + 1));

														if (ilevel > 14) {
															// residual
															//residual_fine13 = new doublerealT[n_a[13] + 1];
															residual_fine13 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(residual_fine13, "residual_fine13", "classic_aglomerative_amg_3", (n_a[13] + 1));

															//residual_coarse13 = new doublerealT[n_a[14] + 1];
															residual_coarse13 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(residual_coarse13, "residual_coarse13", "classic_aglomerative_amg_3", (n_a[14] + 1));

															//error_approx_coarse13 = new doublerealT[n_a[14] + 1];
															error_approx_coarse13 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(error_approx_coarse13, "error_approx_coarse13", "classic_aglomerative_amg_3", (n_a[14] + 1));

															//error_approx_fine13 = new doublerealT[n_a[13] + 1];
															error_approx_fine13 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(error_approx_fine13, "error_approx_fine13", "classic_aglomerative_amg_3", (n_a[13] + 1));

															if (ilevel > 15) {
																// residual
																//residual_fine14 = new doublerealT[n_a[14] + 1];
																residual_fine14 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(residual_fine14, "residual_fine14", "classic_aglomerative_amg_3", (n_a[14] + 1));

																//residual_coarse14 = new doublerealT[n_a[15] + 1];
																residual_coarse14 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(residual_coarse14, "residual_coarse14", "classic_aglomerative_amg_3", (n_a[15] + 1));

																//error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																error_approx_coarse14 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(error_approx_coarse14, "error_approx_coarse14", "classic_aglomerative_amg_3", (n_a[15] + 1));

																//error_approx_fine14 = new doublerealT[n_a[14] + 1];
																error_approx_fine14 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(error_approx_fine14, "error_approx_fine14", "classic_aglomerative_amg_3", (n_a[14] + 1));

																if (ilevel > 16) {
																	// residual
																	//residual_fine15 = new doublerealT[n_a[15] + 1];
																	residual_fine15 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(residual_fine15, "residual_fine15", "classic_aglomerative_amg_3", (n_a[15] + 1));

																	//residual_coarse15 = new doublerealT[n_a[16] + 1];
																	residual_coarse15 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(residual_coarse15, "residual_coarse15", "classic_aglomerative_amg_3", (n_a[16] + 1));

																	//error_approx_coarse15 = new doublerealT[n_a[16] + 1];
																	error_approx_coarse15 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(error_approx_coarse15, "error_approx_coarse15", "classic_aglomerative_amg_3", (n_a[16] + 1));

																	//error_approx_fine15 = new doublerealT[n_a[15] + 1];
																	error_approx_fine15 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(error_approx_fine15, "error_approx_fine15", "classic_aglomerative_amg_3", (n_a[15] + 1));

																	if (ilevel > 17) {
																		// residual
																		//residual_fine16 = new doublerealT[n_a[16] + 1];
																		residual_fine16 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(residual_fine16, "residual_fine16", "classic_aglomerative_amg_3", (n_a[16] + 1));

																		//residual_coarse16 = new doublerealT[n_a[17] + 1];
																		residual_coarse16 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(residual_coarse16, "residual_coarse16", "classic_aglomerative_amg_3", (n_a[17] + 1));

																		//error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																		error_approx_coarse16 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(error_approx_coarse16, "error_approx_coarse16", "classic_aglomerative_amg_3", (n_a[17] + 1));

																		//error_approx_fine16 = new doublerealT[n_a[16] + 1];
																		error_approx_fine16 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(error_approx_fine16, "error_approx_fine16", "classic_aglomerative_amg_3", (n_a[16] + 1));

																		if (ilevel > 18) {
																			// residual
																			//residual_fine17 = new doublerealT[n_a[17] + 1];
																			residual_fine17 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(residual_fine17, "residual_fine17", "classic_aglomerative_amg_3", (n_a[17] + 1));

																			//residual_coarse17 = new doublerealT[n_a[18] + 1];
																			residual_coarse17 = (doublerealT*)malloc((n_a[18] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(residual_coarse17, "residual_coarse17", "classic_aglomerative_amg_3", (n_a[18] + 1));

																			//error_approx_coarse17 = new doublerealT[n_a[18] + 1];
																			error_approx_coarse17 = (doublerealT*)malloc((n_a[18] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(error_approx_coarse17, "error_approx_coarse17", "classic_aglomerative_amg_3", (n_a[18] + 1));

																			//error_approx_fine17 = new doublerealT[n_a[17] + 1];
																			error_approx_fine17 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(error_approx_fine17, "error_approx_fine17", "classic_aglomerative_amg_3", (n_a[17] + 1));


																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	doublerealT *error_approx_fine = nullptr;
	//error_approx_fine = new doublerealT[n_a[0] + 1];
	error_approx_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(error_approx_fine, "error_approx_fine", "classic_aglomerative_amg_3", (n_a[0] + 1));



	// 2 jan 2016. 
	integer igam = 1; // 1-V; 2-W
	// надо увеличивать nu1, nu2 с 1,2 до 5 наверно.
	//const INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14 imyinit = INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT; // ZERO_INIT optimum



	// Для поправки давления возникает задача когда на всех границах стоит условие Неймана,
	// это приводит к тому что метод работает бесконечно долго и не может сойтись, поэтому нужно 
	// заложить критерий останова по превышению количества допустимых итераций (не более 1000 итераций).
	// 1000 итераций это очень долго поэтому для поправки давления надо подобрать разумное количество 
	// итераций т.к. от этого существенным образом зависит быстродействие гидродинамического алгоритма.
	integer iter_limit = 0;

	//for (integer iprohod = 0; iprohod < 20; iprohod++) {
	while (dres>tolerance) {

		if (iter_limit > 2000) {
			printf("may be Neimann in the all boundares.\n");
			break; // досрочный выход из while цикла.
		}
		iter_limit++;

#ifdef MY_DEBUG_NOT_NUMBER
		if (dres!=dres) {
			printf("divergence AMG detected\n");
			printf("\a\a\a\a\a\a\a\a");
			system("pause");
			exit(1);
		}
#endif

		doublerealT R0_0 = 0.0;
		doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
			R0_0 = norma(residual_fine, n_a[0]);
			Rprev_0 = R0_0;

			// smother
			integer iter = 0;
			for (iter = 0; iter < nFinestSweeps; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
				//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
				residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
				Rnext_0 = norma(residual_fine, n_a[0]);
				// this is process flow logic
				if (Rnext_0 > process_flow_beta*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nu1) {
				printf("level 0 limit presmother iteration is reached\n");
			}

		}
		else {
			// smother
			for (integer iter = 0; iter < nFinestSweeps; iter++) {
				//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
			}
		}

		//exporttecplot(x, n);

		move_down(nu1, nu2);

		if (!process_flow_logic) {
			// residual_r
			//doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
			//residual(Amat, 1, nnz_a[0], x, b, flag, n_a[0], residual_fine);
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
		}
		dres = norma(residual_fine, n_a[0]);
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("%lld %e rho=%e\n", iiter, dres, dres / rho);
#else
			printf("%d %e rho=%e\n", iiter, dres, dres / rho);
#endif
			
		}
		iiter++;
		//rho=norma(residual_fine, n_a[0]);
		rho = dres;

		//if (iprohod%5==0) getchar();
		if (ilevel > 1) {

			//doublerealT *residual_coarse = new doublerealT[n_a[1] + 1];

			// restriction
			restriction(R, 1, nnz_aRP[0], flag, residual_fine, residual_coarse, n_a[0], n_a[1]);

			// Amat*e=r;
			//doublerealT* error_approx_coarse = new doublerealT[n_a[1] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
			{
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] = 0.0;
				}
			}


if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) 
			{
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] = (rand() / ((doublerealT)RAND_MAX));
				}
			}


			for (integer i_37 = 1; i_37 <= igam; i_37++) {
				doublerealT R0_1 = 0.0;
				doublerealT Rprev_1 = 0.0, Rnext_1 = 0.0;
				if (process_flow_logic) {
					// calculate initial residual.
					//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
					residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

					R0_1 = norma(residual_fine1, n_a[1]);
					Rprev_1 = R0_1;

					// smother
					integer iter = 0;
					for (iter = 0; iter < nu1; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}

						//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
						residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

						Rnext_1 = norma(residual_fine1, n_a[1]);
						// this is process flow logic
						if (Rnext_1 > process_flow_beta*Rprev_1) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_1 = Rnext_1;
						}
					}

					if (iter == nu1) {
						printf("level 1 limit presmother iteration is reached\n");
					}

				}
				else {

					// pre smothing
					for (integer iter = 0; iter < nu1; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}
					}
				}

				move_down(nu1, nu2);


				if (ilevel > 2) {
					// residual
					if (!process_flow_logic) {
						//doublerealT *residual_fine1 = new doublerealT[n_a[1] + 1];
						//residual(Amat, 1+2*nnz_a[0], 2*nnz_a[0]+nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1], residual_fine1);
						//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
						residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);
						//residualqspeshial(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
					}

					//doublerealT *residual_coarse1 = new doublerealT[n_a[2] + 1];

					// restriction
					restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, residual_fine1, residual_coarse1, n_a[1], n_a[2]);

					// Amat*e=r;
					//doublerealT* error_approx_coarse1 = new doublerealT[n_a[2] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
					{
						for (integer ii = 1; ii <= n_a[2]; ii++) {
							error_approx_coarse1[ii] = 0.0;
						}
					}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) 
					{
						for (integer ii = 1; ii <= n_a[2]; ii++) {
							error_approx_coarse1[ii] = (rand() / ((doublerealT)RAND_MAX));
						}
					}


					//for (integer i_37 = 1; i_37 <= igam; i_37++)
				{
					doublerealT R0_2 = 0.0;
					doublerealT Rprev_2 = 0.0, Rnext_2 = 0.0;
					if (process_flow_logic) {
						// calculate initial residual.
						//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

						R0_2 = norma(residual_fine2, n_a[2]);
						Rprev_2 = R0_2;

						// smother
						integer iter = 0;
						for (iter = 0; iter < nu1; iter++) {
							//quick seidel
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}

							//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
							residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

							Rnext_2 = norma(residual_fine2, n_a[2]);
							// this is process flow logic
							if (Rnext_2 > process_flow_beta*Rprev_2) {
								// Смысл модификации в том что мы экономим итерации на пресмутере.
								break; // досрочно опускаемся на следующий уровень если он есть конечно.
							}
							else {
								Rprev_2 = Rnext_2;
							}
						}

						if (iter == nu1) {
							printf("level 2 limit presmother iteration is reached\n");
						}

					}
					else {

						// pre smothing
						for (integer iter = 0; iter < nu1; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
						}

					}

					move_down(nu1, nu2);

					if (ilevel > 3) {
						// residual
						if (!process_flow_logic) {
							//doublerealT *residual_fine2 = new doublerealT[n_a[2] + 1];
							//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2], residual_fine2);
							//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
							residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);
							//residualqspeshial(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						}

						//doublerealT *residual_coarse2 = new doublerealT[n_a[3] + 1];

						// restriction
						restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, residual_fine2, residual_coarse2, n_a[2], n_a[3]);

						// Amat*e=r;
						//doublerealT* error_approx_coarse2 = new doublerealT[n_a[3] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
						{
							for (integer ii = 1; ii <= n_a[3]; ii++) {
								error_approx_coarse2[ii] = 0.0;
							}
						}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
						{
							for (integer ii = 1; ii <= n_a[3]; ii++) {
								error_approx_coarse2[ii] = (rand() / ((doublerealT)RAND_MAX));
							}
						}

					//for (integer i_37 = 1; i_37 <= igam; i_37++)
					{
						doublerealT R0_3 = 0.0;
						doublerealT Rprev_3 = 0.0, Rnext_3 = 0.0;
						if (process_flow_logic) {
							// calculate initial residual.
							//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
							residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);


							R0_3 = norma(residual_fine3, n_a[3]);
							Rprev_3 = R0_3;

							// smother
							integer iter = 0;
							for (iter = 0; iter < nu1; iter++) {
								//quick seidel
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
								residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);


								Rnext_3 = norma(residual_fine3, n_a[3]);
								// this is process flow logic
								if (Rnext_3 > process_flow_beta*Rprev_3) {
									// Смысл модификации в том что мы экономим итерации на пресмутере.
									break; // досрочно опускаемся на следующий уровень если он есть конечно.
								}
								else {
									Rprev_3 = Rnext_3;
								}
							}

							if (iter == nu1) {
								printf("level 3 limit presmother iteration is reached\n");
							}

						}
						else {
							// pre smothing
							for (integer iter = 0; iter < nu1; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
							}
						}


						move_down(nu1, nu2);


						if (ilevel > 4) {
							// residual
							if (!process_flow_logic) {
								//doublerealT *residual_fine3 = new doublerealT[n_a[3] + 1];
								//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3], residual_fine3);
								//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
								residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);

								//speshial
								//residualqspeshial(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
							}


							//doublerealT *residual_coarse3 = new doublerealT[n_a[4] + 1];

							// restriction
							restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, residual_fine3, residual_coarse3, n_a[3], n_a[4]);

							// Amat*e=r;
							//doublerealT* error_approx_coarse3 = new doublerealT[n_a[4] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) 
							{
								for (integer ii = 1; ii <= n_a[4]; ii++) {
									error_approx_coarse3[ii] = 0.0;
								}
							}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
							{
								for (integer ii = 1; ii <= n_a[4]; ii++) {
									error_approx_coarse3[ii] = (rand() / ((doublerealT)RAND_MAX));
								}
							}


							//for (integer i_37 = 1; i_37 <= igam; i_37++) 
						{
							doublerealT R0_4 = 0.0;
							doublerealT Rprev_4 = 0.0, Rnext_4 = 0.0;
							if (process_flow_logic) {
								// calculate initial residual.
								//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
								residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);


								R0_4 = norma(residual_fine4, n_a[4]);
								Rprev_4 = R0_4;

								// smother
								integer iter = 0;
								for (iter = 0; iter < nu1; iter++) {
									//quick seidel
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}

									//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
									residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);


									Rnext_4 = norma(residual_fine4, n_a[4]);
									// this is process flow logic
									if (Rnext_4 > process_flow_beta*Rprev_4) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_4 = Rnext_4;
									}
								}

								if (iter == nu1) {
									printf("level 4 limit presmother iteration is reached\n");
								}

							}
							else {
								// pre smothing
								for (integer iter = 0; iter < nu1; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
								}
							}


							move_down(nu1, nu2);

							if (ilevel > 5) {
								// residual
								if (!process_flow_logic) {
									//doublerealT *residual_fine4 = new doublerealT[n_a[4] + 1];
									//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4], residual_fine4);
									//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
									residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);

									//speshial 14 september 2015.
									//residualqspeshial(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
								}


								//doublerealT *residual_coarse4 = new doublerealT[n_a[5] + 1];

								// restriction
								restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, residual_fine4, residual_coarse4, n_a[4], n_a[5]);

								// Amat*e=r;
								//doublerealT* error_approx_coarse4 = new doublerealT[n_a[5] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
								{
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] = 0.0;
									}
								}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
								{
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] = (rand() / ((doublerealT)RAND_MAX));
									}
								}


								// pre smothing
								//for (integer i_37 = 1; i_37 <= igam; i_37++)
							{
								doublerealT R0_5 = 0.0;
								doublerealT Rprev_5 = 0.0, Rnext_5 = 0.0;
								if (process_flow_logic) {
									// calculate initial residual.
									//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
									residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);



									R0_5 = norma(residual_fine5, n_a[5]);
									Rprev_5 = R0_5;

									// smother
									integer iter = 0;
									for (iter = 0; iter < nu1; iter++) {
										//quick seidel
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
										else {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}

										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);


										Rnext_5 = norma(residual_fine5, n_a[5]);
										// this is process flow logic
										if (Rnext_5 > process_flow_beta*Rprev_5) {
											// Смысл модификации в том что мы экономим итерации на пресмутере.
											break; // досрочно опускаемся на следующий уровень если он есть конечно.
										}
										else {
											Rprev_5 = Rnext_5;
										}
									}

									if (iter == nu1) {
										printf("level 5 limit presmother iteration is reached\n");
									}

								}
								else {
									for (integer iter = 0; iter < nu1; iter++) {
										//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
										else {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
									}
								}


								move_down(nu1, nu2);

								if (ilevel > 6) {
									// residual
									if (!process_flow_logic) {
										//doublerealT *residual_fine5 = new doublerealT[n_a[5] + 1];
										//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5], residual_fine5);
										//if (ilevel <= 15) {
										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);

										//}
										//else {
										// приводит к расходимости.
										//speshial 14 september 2015.
										// это уже приводит к увеличению числа итераций на примере сетки в 1млн узлов. остановимся.
										//residualqspeshial(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										//}
									}

									//doublerealT *residual_coarse5 = new doublerealT[n_a[6] + 1];

									// restriction
									restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, residual_fine5, residual_coarse5, n_a[5], n_a[6]);

									// Amat*e=r;
									//doublerealT* error_approx_coarse5 = new doublerealT[n_a[6] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
									{
										for (integer ii = 1; ii <= n_a[6]; ii++) {
											error_approx_coarse5[ii] = 0.0;
										}
									}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
									{
										for (integer ii = 1; ii <= n_a[6]; ii++) {
											error_approx_coarse5[ii] = (rand() / ((doublerealT)RAND_MAX));
										}
									}


									//for (integer i_37 = 1; i_37 <= igam; i_37++) 
									{
										// pre smothing

										doublerealT R0_6 = 0.0;
										doublerealT Rprev_6 = 0.0, Rnext_6 = 0.0;
										if (process_flow_logic) {
											// calculate initial residual.
											//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
											residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);



											R0_6 = norma(residual_fine6, n_a[6]);
											Rprev_6 = R0_6;

											// smother
											integer iter = 0;
											for (iter = 0; iter < nu1; iter++) {
												//quick seidel
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}

												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);


												Rnext_6 = norma(residual_fine6, n_a[6]);
												// this is process flow logic
												if (Rnext_6 > process_flow_beta*Rprev_6) {
													// Смысл модификации в том что мы экономим итерации на пресмутере.
													break; // досрочно опускаемся на следующий уровень если он есть конечно.
												}
												else {
													Rprev_6 = Rnext_6;
												}
											}

											if (iter == nu1) {
												printf("level 6 limit presmother iteration is reached\n");
											}

										}
										else {
											for (integer iter = 0; iter < nu1; iter++) {
												//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
											}
										}


										move_down(nu1, nu2);

										if (ilevel > 7) {
											// residual
											if (!process_flow_logic) {
												//doublerealT *residual_fine6 = new doublerealT[n_a[6] + 1];
												//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] +2*nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6], residual_fine6);
												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);
											}

											//doublerealT *residual_coarse6 = new doublerealT[n_a[7] + 1];

											// restriction
											restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, residual_fine6, residual_coarse6, n_a[6], n_a[7]);

											// Amat*e=r;
											//doublerealT* error_approx_coarse6 = new doublerealT[n_a[7] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
											{
												for (integer ii = 1; ii <= n_a[7]; ii++) {
													error_approx_coarse6[ii] = 0.0;
												}
											}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
											{
												for (integer ii = 1; ii <= n_a[7]; ii++) {
													error_approx_coarse6[ii] = (rand() / ((doublerealT)RAND_MAX));
												}
											}


											//for (integer i_37 = 1; i_37 <= igam; i_37++) 
											{

												// pre smothing


												doublerealT R0_7 = 0.0;
												doublerealT Rprev_7 = 0.0, Rnext_7 = 0.0;
												if (process_flow_logic) {
													// calculate initial residual.
													//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
													residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);



													R0_7 = norma(residual_fine7, n_a[7]);
													Rprev_7 = R0_7;

													// smother
													integer iter = 0;
													for (iter = 0; iter < nu1; iter++) {
														//quick seidel
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}

														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);


														Rnext_7 = norma(residual_fine7, n_a[7]);
														// this is process flow logic
														if (Rnext_7 > process_flow_beta*Rprev_7) {
															// Смысл модификации в том что мы экономим итерации на пресмутере.
															break; // досрочно опускаемся на следующий уровень если он есть конечно.
														}
														else {
															Rprev_7 = Rnext_7;
														}
													}

													if (iter == nu1) {
														printf("level 7 limit presmother iteration is reached\n");
													}

												}
												else {
													for (integer iter = 0; iter < nu1; iter++) {
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
													}
												}


												move_down(nu1, nu2);

												if (ilevel > 8) {
													// residual
													if (!process_flow_logic) {
														//doublerealT *residual_fine7 = new doublerealT[n_a[7] + 1];
														//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7], residual_fine7);
														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);

													}


													//doublerealT *residual_coarse7 = new doublerealT[n_a[8] + 1];

													// restriction
													restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, residual_fine7, residual_coarse7, n_a[7], n_a[8]);

													// Amat*e=r;
													//doublerealT* error_approx_coarse7 = new doublerealT[n_a[8] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
													{
														for (integer ii = 1; ii <= n_a[8]; ii++) {
															error_approx_coarse7[ii] = 0.0;
														}
													}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
													{
														for (integer ii = 1; ii <= n_a[8]; ii++) {
															error_approx_coarse7[ii] = (rand() / ((doublerealT)RAND_MAX));
														}
													}


													//for (integer i_37 = 1; i_37 <= igam; i_37++)
													{
														// pre smothing
														for (integer iter = 0; iter < nu1; iter++) {
															seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
															//nested_desection8 futures

														}


														if (ilevel > 9) {
															// residual
															//doublerealT *residual_fine8 = new doublerealT[n_a[8] + 1];
															integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7];
															integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
															residual(Amat, n1, n2, error_approx_coarse7, residual_coarse7, flag, n_a[8], residual_fine8);


															//doublerealT *residual_coarse8 = new doublerealT[n_a[9] + 1];

															// restriction
															integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
															integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
															restriction(R, n3, n4, flag, residual_fine8, residual_coarse8, n_a[8], n_a[9]);

															// Amat*e=r;
															//doublerealT* error_approx_coarse8 = new doublerealT[n_a[9] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
															{
																for (integer ii = 1; ii <= n_a[9]; ii++) {
																	error_approx_coarse8[ii] = 0.0;
																}
															}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) 
															{
																for (integer ii = 1; ii <= n_a[9]; ii++) {
																	error_approx_coarse8[ii] = (rand() / ((doublerealT)RAND_MAX));
																}
															}


															//for (integer i_37 = 1; i_37 <= igam; i_37++) 
															{
																// pre smothing
																for (integer iter = 0; iter < nu1; iter++) {
																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																	seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
																}


																move_down(nu1, nu2);

																if (ilevel > 10) {
																	// 8 сентября 2015 РИМИНИ пляж 

																	// residual
																	//doublerealT *residual_fine9 = new doublerealT[n_a[9] + 1];
																	integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
																	integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																	residual(Amat, n1, n2, error_approx_coarse8, residual_coarse8, flag, n_a[9], residual_fine9);


																	//doublerealT *residual_coarse9 = new doublerealT[n_a[10] + 1];

																	// restriction
																	integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
																	integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																	restriction(R, n3, n4, flag, residual_fine9, residual_coarse9, n_a[9], n_a[10]);

																	// Amat*e=r;
																	//doublerealT* error_approx_coarse9 = new doublerealT[n_a[10] + 1];


if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																	{
																		for (integer ii = 1; ii <= n_a[10]; ii++) {
																			error_approx_coarse9[ii] = 0.0;
																		}
																	}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																	{
																		for (integer ii = 1; ii <= n_a[10]; ii++) {
																			error_approx_coarse9[ii] = (rand() / ((doublerealT)RAND_MAX));
																		}
																	}


																	//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																	{
																		// pre smothing
																		for (integer iter = 0; iter < nu1; iter++) {
																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																			seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
																		}

																		// до 11 уровня вроде всё верно 3 января 2016

																		move_down(nu1, nu2);

																		if (ilevel > 11) {
																			// 8 сентября 2015 РИМИНИ пляж 

																			// residual
																			//doublerealT *residual_fine10 = new doublerealT[n_a[10] + 1];
																			integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																			integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																			residual(Amat, n1, n2, error_approx_coarse9, residual_coarse9, flag, n_a[10], residual_fine10);


																			//doublerealT *residual_coarse10 = new doublerealT[n_a[11] + 1];

																			// restriction
																			integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																			integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																			restriction(R, n3, n4, flag, residual_fine10, residual_coarse10, n_a[10], n_a[11]);

																			// Amat*e=r;
																			//doublerealT* error_approx_coarse10 = new doublerealT[n_a[11] + 1];


if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																			{
																				for (integer ii = 1; ii <= n_a[11]; ii++) {
																					error_approx_coarse10[ii] = 0.0;
																				}
																			}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																			{
																				for (integer ii = 1; ii <= n_a[11]; ii++) {
																					error_approx_coarse10[ii] = (rand() / ((doublerealT)RAND_MAX));
																				}
																			}


																			//for (integer i_37 = 1; i_37 <= igam; i_37++)
																			{
																				// pre smothing
																				for (integer iter = 0; iter < nu1; iter++) {
																					integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																					integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																					seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
																				}

																				move_down(nu1, nu2);

																				if (ilevel > 12) {
																					// 11 сентября 2015 РИМИНИ пляж 

																					// residual
																					//doublerealT *residual_fine11 = new doublerealT[n_a[11] + 1];
																					integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																					integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																					residual(Amat, n1, n2, error_approx_coarse10, residual_coarse10, flag, n_a[11], residual_fine11);


																					//doublerealT *residual_coarse11 = new doublerealT[n_a[12] + 1];

																					// restriction
																					integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																					integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																					restriction(R, n3, n4, flag, residual_fine11, residual_coarse11, n_a[11], n_a[12]);

																					// Amat*e=r;
																					//doublerealT* error_approx_coarse11 = new doublerealT[n_a[12] + 1];

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																					{
																						for (integer ii = 1; ii <= n_a[12]; ii++) {
																							error_approx_coarse11[ii] = 0.0;
																						}
																					}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																					{
																						for (integer ii = 1; ii <= n_a[12]; ii++) {
																							error_approx_coarse11[ii] = (rand() / ((doublerealT)RAND_MAX));
																						}
																					}


																					//for (integer i_37 = 1; i_37 <= igam; i_37++)
																					{
																						// pre smothing
																						for (integer iter = 0; iter < nu1; iter++) {
																							integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																							integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																							seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
																						}

																						move_down(nu1, nu2);

																						if (ilevel > 13) {
																							// 11 сентября 2015 РИМИНИ пляж 

																							// residual
																							//doublerealT *residual_fine12 = new doublerealT[n_a[12] + 1];
																							integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																							integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																							residual(Amat, n1, n2, error_approx_coarse11, residual_coarse11, flag, n_a[12], residual_fine12);


																							//doublerealT *residual_coarse12 = new doublerealT[n_a[13] + 1];

																							// restriction
																							integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																							integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																							restriction(R, n3, n4, flag, residual_fine12, residual_coarse12, n_a[12], n_a[13]);

																							// Amat*e=r;
																							//doublerealT* error_approx_coarse12 = new doublerealT[n_a[13] + 1];

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																							{
																								for (integer ii = 1; ii <= n_a[13]; ii++) {
																									error_approx_coarse12[ii] = 0.0;
																								}
																							}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																							{
																								for (integer ii = 1; ii <= n_a[13]; ii++) {
																									error_approx_coarse12[ii] = (rand() / ((doublerealT)RAND_MAX));
																								}
																							}


																							//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																							{
																								// pre smothing
																								for (integer iter = 0; iter < nu1; iter++) {
																									integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																									integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																									seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
																								}


																								move_down(nu1, nu2);

																								if (ilevel > 14) {
																									// 11 сентября 2015 РИМИНИ пляж 

																									// residual
																									//doublerealT *residual_fine13 = new doublerealT[n_a[13] + 1];
																									integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																									integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																									residual(Amat, n1, n2, error_approx_coarse12, residual_coarse12, flag, n_a[13], residual_fine13);


																									//doublerealT *residual_coarse13 = new doublerealT[n_a[14] + 1];

																									// restriction
																									integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																									integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																									restriction(R, n3, n4, flag, residual_fine13, residual_coarse13, n_a[13], n_a[14]);

																									// Amat*e=r;
																									//doublerealT* error_approx_coarse13 = new doublerealT[n_a[14] + 1];

																									if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																									{
																										for (integer ii = 1; ii <= n_a[14]; ii++) {
																											error_approx_coarse13[ii] = 0.0;
																										}
																									}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																									{
																										for (integer ii = 1; ii <= n_a[14]; ii++) {
																											error_approx_coarse13[ii] = (rand() / ((doublerealT)RAND_MAX));
																										}
																									}



																									//for (integer i_37 = 1; i_37 <= igam; i_37++)
																									{
																										// pre smothing
																										for (integer iter = 0; iter < nu1; iter++) {
																											integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																											integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																											seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																										}


																										move_down(nu1, nu2);

																										if (ilevel > 15) {
																											// 14 сентября 2015 Москва на работе в пн. 

																											// residual
																											//doublerealT *residual_fine14 = new doublerealT[n_a[14] + 1];
																											integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																											integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																											residual(Amat, n1, n2, error_approx_coarse13, residual_coarse13, flag, n_a[14], residual_fine14);


																											//doublerealT *residual_coarse14 = new doublerealT[n_a[15] + 1];

																											// restriction
																											integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																											integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																											restriction(R, n3, n4, flag, residual_fine14, residual_coarse14, n_a[14], n_a[15]);

																											// Amat*e=r;
																											//doublerealT* error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																											if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																												for (integer ii = 1; ii <= n_a[15]; ii++) {
																													error_approx_coarse14[ii] = 0.0;
																												}
																											}
																											if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																												for (integer ii = 1; ii <= n_a[15]; ii++) {
																													error_approx_coarse14[ii] = (rand() / ((doublerealT)RAND_MAX));
																												}
																											}

																											//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																											{
																												// pre smothing
																												for (integer iter = 0; iter < nu1; iter++) {
																													integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																													integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																													seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																												}


																												move_down(nu1, nu2);

																												if (ilevel > 16) {
																													// 10 октября 2015. 

																													// residual
																													//doublerealT *residual_fine15 = new doublerealT[n_a[15] + 1];
																													integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																													integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																													residual(Amat, n1, n2, error_approx_coarse14, residual_coarse14, flag, n_a[15], residual_fine15);


																													//doublerealT *residual_coarse15 = new doublerealT[n_a[16] + 1];

																													// restriction
																													integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																													integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																													restriction(R, n3, n4, flag, residual_fine15, residual_coarse15, n_a[15], n_a[16]);

																													// Amat*e=r;
																													//doublerealT* error_approx_coarse15 = new doublerealT[n_a[16] + 1];

																													if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																														for (integer ii = 1; ii <= n_a[16]; ii++) {
																															error_approx_coarse15[ii] = 0.0;
																														}
																													}
																													if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																														for (integer ii = 1; ii <= n_a[16]; ii++) {
																															error_approx_coarse15[ii] = (rand() / ((doublerealT)RAND_MAX));
																														}
																													}

																													//for (integer i_37 = 1; i_37 <= igam; i_37++)
																													{
																														// pre smothing
																														for (integer iter = 0; iter < nu1; iter++) {
																															integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																															integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																															seidel(Amat, n5, n6, error_approx_coarse15, residual_coarse15, flag, n_a[16]);
																														}


																														move_down(nu1, nu2);

																														if (ilevel > 17) {
																															// 10 октября 2015. 

																															// residual
																															//doublerealT *residual_fine16 = new doublerealT[n_a[16] + 1];
																															integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																															integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																															residual(Amat, n1, n2, error_approx_coarse15, residual_coarse15, flag, n_a[16], residual_fine16);


																															//doublerealT *residual_coarse16 = new doublerealT[n_a[17] + 1];

																															// restriction
																															integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																															integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																															restriction(R, n3, n4, flag, residual_fine16, residual_coarse16, n_a[16], n_a[17]);

																															// Amat*e=r;
																															//doublerealT* error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																															if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																																for (integer ii = 1; ii <= n_a[17]; ii++) {
																																	error_approx_coarse16[ii] = 0.0;
																																}
																															}
																															if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																																for (integer ii = 1; ii <= n_a[17]; ii++) {
																																	error_approx_coarse16[ii] = (rand() / ((doublerealT)RAND_MAX));
																																}
																															}


																															//for (integer i_37 = 1; i_37 <= igam; i_37++)
																															{
																																// pre smothing
																																for (integer iter = 0; iter < nu1; iter++) {
																																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																	seidel(Amat, n5, n6, error_approx_coarse16, residual_coarse16, flag, n_a[17]);
																																}

																																move_down(nu1, nu2);


																																if (ilevel > 18) {
																																	// 5 декабря 2015. 

																																	// residual
																																	//doublerealT *residual_fine17 = new doublerealT[n_a[17] + 1];
																																	integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																																	integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																	residual(Amat, n1, n2, error_approx_coarse16, residual_coarse16, flag, n_a[17], residual_fine17);


																																	//doublerealT *residual_coarse17 = new doublerealT[n_a[18] + 1];

																																	// restriction
																																	integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																																	integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17];
																																	restriction(R, n3, n4, flag, residual_fine17, residual_coarse17, n_a[17], n_a[18]);

																																	// Amat*e=r;
																																	//doublerealT* error_approx_coarse17 = new doublerealT[n_a[18] + 1];

																																	if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
																																		for (integer ii = 1; ii <= n_a[18]; ii++) {
																																			error_approx_coarse17[ii] = 0.0;
																																		}
																																	}
																																	if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
																																		for (integer ii = 1; ii <= n_a[18]; ii++) {
																																			error_approx_coarse17[ii] = (rand() / ((doublerealT)RAND_MAX));
																																		}
																																	}


																																	//for (integer i_37 = 1; i_37 <= igam; i_37++)
																																	{
																																		// pre smothing
																																		for (integer iter = 0; iter < nu1; iter++) {
																																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17] + nnz_a[18];
																																			seidel(Amat, n5, n6, error_approx_coarse17, residual_coarse17, flag, n_a[18]);
																																		}

																																		// post smothing
																																		for (integer iter = 0; iter < nu2; iter++) {
																																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17] + nnz_a[18];
																																			seidel(Amat, n5, n6, error_approx_coarse17, residual_coarse17, flag, n_a[18]);
																																		}
																																	}

																																	// prolongation
																																	// residual_r
																																	//doublerealT *error_approx_fine17 = new doublerealT[n_a[17] + 1];
																																	for (integer ii = 1; ii <= n_a[17]; ii++) {
																																		error_approx_fine17[ii] = 0.0;
																																	}



																																	integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																																	integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17];
																																	prolongation(P, n7, n8, flag, error_approx_fine17, error_approx_coarse17, n_a[17], n_a[18]);

																																	// correction
																																	for (integer ii = 1; ii <= n_a[17]; ii++) {
																																		error_approx_coarse16[ii] += error_approx_fine17[ii];
																																	}

																																	// free
																																	//delete[] error_approx_fine17;
																																	//delete[] error_approx_coarse17;
																																	//delete[] residual_coarse17;
																																	//delete[] residual_fine17;

																																}



																																// post smothing
																																for (integer iter = 0; iter < nu2; iter++) {
																																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																	seidel(Amat, n5, n6, error_approx_coarse16, residual_coarse16, flag, n_a[17]);
																																}
																															}
																															move_up(nu1, nu2);

																															// prolongation
																															// residual_r
																															//doublerealT *error_approx_fine16 = new doublerealT[n_a[16] + 1];
																															for (integer ii = 1; ii <= n_a[16]; ii++) {
																																error_approx_fine16[ii] = 0.0;
																															}



																															integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																															integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																															prolongation(P, n7, n8, flag, error_approx_fine16, error_approx_coarse16, n_a[16], n_a[17]);

																															// correction
																															for (integer ii = 1; ii <= n_a[16]; ii++) {
																																error_approx_coarse15[ii] += error_approx_fine16[ii];
																															}

																															// free
																															//delete[] error_approx_fine16;
																															//delete[] error_approx_coarse16;
																															//delete[] residual_coarse16;
																															//delete[] residual_fine16;

																														}


																														// post smothing
																														for (integer iter = 0; iter < nu2; iter++) {
																															integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																															integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																															seidel(Amat, n5, n6, error_approx_coarse15, residual_coarse15, flag, n_a[16]);
																														}
																													}
																													move_up(nu1, nu2);

																													// prolongation
																													// residual_r
																													//doublerealT *error_approx_fine15 = new doublerealT[n_a[15] + 1];
																													for (integer ii = 1; ii <= n_a[15]; ii++) {
																														error_approx_fine15[ii] = 0.0;
																													}



																													integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																													integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																													prolongation(P, n7, n8, flag, error_approx_fine15, error_approx_coarse15, n_a[15], n_a[16]);

																													// correction
																													for (integer ii = 1; ii <= n_a[15]; ii++) {
																														error_approx_coarse14[ii] += error_approx_fine15[ii];
																													}

																													// free
																													//delete[] error_approx_fine15;
																													//delete[] error_approx_coarse15;
																													//delete[] residual_coarse15;
																													//delete[] residual_fine15;

																												}

																												// post smothing
																												for (integer iter = 0; iter < nu2; iter++) {
																													integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																													integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																													seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																												}
																											}
																											move_up(nu1, nu2);

																											// prolongation
																											// residual_r
																											//doublerealT *error_approx_fine14 = new doublerealT[n_a[14] + 1];
																											for (integer ii = 1; ii <= n_a[14]; ii++) {
																												error_approx_fine14[ii] = 0.0;
																											}



																											integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																											integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																											prolongation(P, n7, n8, flag, error_approx_fine14, error_approx_coarse14, n_a[14], n_a[15]);

																											// correction
																											for (integer ii = 1; ii <= n_a[14]; ii++) {
																												error_approx_coarse13[ii] += error_approx_fine14[ii];
																											}

																											// free
																											//delete[] error_approx_fine14;
																											//delete[] error_approx_coarse14;
																											//delete[] residual_coarse14;
																											//delete[] residual_fine14;

																										}


																										// post smothing
																										for (integer iter = 0; iter < nu2; iter++) {
																											integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																											integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																											seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																										}
																									}

																									move_up(nu1, nu2);

																									// prolongation
																									// residual_r
																									//doublerealT *error_approx_fine13 = new doublerealT[n_a[13] + 1];
																									for (integer ii = 1; ii <= n_a[13]; ii++) {
																										error_approx_fine13[ii] = 0.0;
																									}

#if doubleintprecision == 1
																									//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																									//printf("error_approx_coarse13[%lld]=%e\n",ii, error_approx_coarse13[ii]);

																									//printf("residual_coarse13[%lld]=%e\n", ii, residual_coarse13[ii]);
																									//getchar();
																									//}
																									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																									//if (ii % 20 == 0) getchar();
																									//}
#else
																									//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																									//printf("error_approx_coarse13[%d]=%e\n",ii, error_approx_coarse13[ii]);

																									//printf("residual_coarse13[%d]=%e\n", ii, residual_coarse13[ii]);
																									//getchar();
																									//}
																									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																									//if (ii % 20 == 0) getchar();
																									//}
#endif
																									

																									integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																									integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																									prolongation(P, n7, n8, flag, error_approx_fine13, error_approx_coarse13, n_a[13], n_a[14]);

																									// correction
																									for (integer ii = 1; ii <= n_a[13]; ii++) {
																										error_approx_coarse12[ii] += error_approx_fine13[ii];
																									}

																									// free
																									//delete[] error_approx_fine13;
																									//delete[] error_approx_coarse13;
																									//delete[] residual_coarse13;
																									//delete[] residual_fine13;

																								}


																								// post smothing
																								for (integer iter = 0; iter < nu2; iter++) {
																									integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																									integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																									seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
																								}
																							}

																							move_up(nu1, nu2);

																							// prolongation
																							// residual_r
																							//doublerealT *error_approx_fine12 = new doublerealT[n_a[12] + 1];
																							for (integer ii = 1; ii <= n_a[12]; ii++) {
																								error_approx_fine12[ii] = 0.0;
																							}

#if doubleintprecision == 1
																							//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
																							//printf("error_approx_coarse12[%lld]=%e\n",ii, error_approx_coarse12[ii]);

																							//printf("residual_coarse12[%lld]=%e\n", ii, residual_coarse12[ii]);
																							//getchar();
																							//}
																							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
																							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																							//if (ii % 20 == 0) getchar();
																							//}
#else
																							//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
																							//printf("error_approx_coarse12[%d]=%e\n",ii, error_approx_coarse12[ii]);

																							//printf("residual_coarse12[%d]=%e\n", ii, residual_coarse12[ii]);
																							//getchar();
																							//}
																							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
																							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																							//if (ii % 20 == 0) getchar();
																							//}
#endif

																							

																							integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																							integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																							prolongation(P, n7, n8, flag, error_approx_fine12, error_approx_coarse12, n_a[12], n_a[13]);

																							// correction
																							for (integer ii = 1; ii <= n_a[12]; ii++) {
																								error_approx_coarse11[ii] += error_approx_fine12[ii];
																							}

																							// free
																							//delete[] error_approx_fine12;
																							//delete[] error_approx_coarse12;
																							//delete[] residual_coarse12;
																							//delete[] residual_fine12;

																						}



																						// post smothing
																						for (integer iter = 0; iter < nu2; iter++) {
																							integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																							integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																							seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
																						}
																					}
																					move_up(nu1, nu2);

																					// prolongation
																					// residual_r
																					//doublerealT *error_approx_fine11 = new doublerealT[n_a[11] + 1];
																					for (integer ii = 1; ii <= n_a[11]; ii++) {
																						error_approx_fine11[ii] = 0.0;
																					}

#if doubleintprecision == 1
																					//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
																					//printf("error_approx_coarse11[%lld]=%e\n",ii, error_approx_coarse11[ii]);

																					//printf("residual_coarse11[%lld]=%e\n", ii, residual_coarse11[ii]);
																					//getchar();
																					//}
																					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
																					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																					//if (ii % 20 == 0) getchar();
																					//}
#else
																					//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
																					//printf("error_approx_coarse11[%d]=%e\n",ii, error_approx_coarse11[ii]);

																					//printf("residual_coarse11[%d]=%e\n", ii, residual_coarse11[ii]);
																					//getchar();
																					//}
																					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
																					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																					//if (ii % 20 == 0) getchar();
																					//}
#endif

																					

																					integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																					integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																					prolongation(P, n7, n8, flag, error_approx_fine11, error_approx_coarse11, n_a[11], n_a[12]);

																					// correction
																					for (integer ii = 1; ii <= n_a[11]; ii++) {
																						error_approx_coarse10[ii] += error_approx_fine11[ii];
																					}

																					// free
																					//delete[] error_approx_fine11;
																					//delete[] error_approx_coarse11;
																					//delete[] residual_coarse11;
																					//delete[] residual_fine11;

																				}


																				// post smothing
																				for (integer iter = 0; iter < nu2; iter++) {
																					integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																					integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																					seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
																				}
																			}
																			move_up(nu1, nu2);

																			// prolongation
																			// residual_r
																			//doublerealT *error_approx_fine10 = new doublerealT[n_a[10] + 1];
																			for (integer ii = 1; ii <= n_a[10]; ii++) {
																				error_approx_fine10[ii] = 0.0;
																			}

#if doubleintprecision == 1
																			//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
																			//printf("error_approx_coarse10[%lld]=%e\n",ii, error_approx_coarse10[ii]);

																			//printf("residual_coarse10[%lld]=%e\n", ii, residual_coarse10[ii]);
																			//getchar();
																			//}
																			//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
																			//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																			//if (ii % 20 == 0) getchar();
																			//}
#else
																			//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
																			//printf("error_approx_coarse10[%d]=%e\n",ii, error_approx_coarse10[ii]);

																			//printf("residual_coarse10[%d]=%e\n", ii, residual_coarse10[ii]);
																			//getchar();
																			//}
																			//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
																			//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																			//if (ii % 20 == 0) getchar();
																			//}
#endif

																			

																			integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																			integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																			prolongation(P, n7, n8, flag, error_approx_fine10, error_approx_coarse10, n_a[10], n_a[11]);

																			// correction
																			for (integer ii = 1; ii <= n_a[10]; ii++) {
																				error_approx_coarse9[ii] += error_approx_fine10[ii];
																			}

																			// free
																			//delete[] error_approx_fine10;
																			//delete[] error_approx_coarse10;
																			//delete[] residual_coarse10;
																			//delete[] residual_fine10;

																		}



																		// post smothing
																		for (integer iter = 0; iter < nu2; iter++) {
																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																			seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
																		}
																	}

																	move_up(nu1, nu2);

																	// prolongation
																	// residual_r
																	//doublerealT *error_approx_fine9 = new doublerealT[n_a[9] + 1];
																	for (integer ii = 1; ii <= n_a[9]; ii++) {
																		error_approx_fine9[ii] = 0.0;
																	}

#if doubleintprecision == 1
																	//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
																	//printf("error_approx_coarse9[%lld]=%e\n",ii, error_approx_coarse9[ii]);

																	//printf("residual_coarse9[%lld]=%e\n", ii, residual_coarse9[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
																	//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#else
																	//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
																	//printf("error_approx_coarse9[%d]=%e\n",ii, error_approx_coarse9[ii]);

																	//printf("residual_coarse9[%d]=%e\n", ii, residual_coarse9[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
																	//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#endif

																	

																	integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
																	integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																	prolongation(P, n7, n8, flag, error_approx_fine9, error_approx_coarse9, n_a[9], n_a[10]);

																	// correction
																	for (integer ii = 1; ii <= n_a[9]; ii++) {
																		error_approx_coarse8[ii] += error_approx_fine9[ii];
																	}

																	// free
																	//delete[] error_approx_fine9;
																	//delete[] error_approx_coarse9;
																	//delete[] residual_coarse9;
																	//delete[] residual_fine9;

																}

																// post smothing
																for (integer iter = 0; iter < nu2; iter++) {
																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																	seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
																}
															}

															move_up(nu1, nu2);

															// prolongation
															// residual_r
															//doublerealT *error_approx_fine8 = new doublerealT[n_a[8] + 1];
															for (integer ii = 1; ii <= n_a[8]; ii++) {
																error_approx_fine8[ii] = 0.0;
															}

#if doubleintprecision == 1
															//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
															//printf("error_approx_coarse8[%lld]=%e\n",ii, error_approx_coarse8[ii]);

															//printf("residual_coarse8[%lld]=%e\n", ii, residual_coarse8[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
															//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#else
															//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
															//printf("error_approx_coarse8[%d]=%e\n",ii, error_approx_coarse8[ii]);

															//printf("residual_coarse8[%d]=%e\n", ii, residual_coarse8[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
															//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#endif

															

															integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
															integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
															prolongation(P, n7, n8, flag, error_approx_fine8, error_approx_coarse8, n_a[8], n_a[9]);

															// correction
															for (integer ii = 1; ii <= n_a[8]; ii++) {
																error_approx_coarse7[ii] += error_approx_fine8[ii];
															}

															// free
															//delete[] error_approx_fine8;
															//delete[] error_approx_coarse8;
															//delete[] residual_coarse8;
															//delete[] residual_fine8;

														}




														// post smothing
														for (integer iter = 0; iter < nu2; iter++) {
															seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
														}
													}
													move_up(nu1, nu2);

													// prolongation
													// residual_r
													//doublerealT *error_approx_fine7 = new doublerealT[n_a[7] + 1];
													for (integer ii = 1; ii <= n_a[7]; ii++) {
														error_approx_fine7[ii] = 0.0;
													}

#if doubleintprecision == 1
													//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
													//printf("error_approx_coarse7[%lld]=%e\n",ii, error_approx_coarse7[ii]);

													//printf("residual_coarse7[%lld]=%e\n", ii, residual_coarse7[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
													//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#else
													//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
													//printf("error_approx_coarse7[%d]=%e\n",ii, error_approx_coarse7[ii]);

													//printf("residual_coarse7[%d]=%e\n", ii, residual_coarse7[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
													//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#endif

													

													prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, error_approx_fine7, error_approx_coarse7, n_a[7], n_a[8]);

													// correction
													for (integer ii = 1; ii <= n_a[7]; ii++) {
														error_approx_coarse6[ii] += error_approx_fine7[ii];
													}

													// free
													//delete[] error_approx_fine7;
													//delete[] error_approx_coarse7;
													//delete[] residual_coarse7;
													//delete[] residual_fine7;

												}

												// post smothing
												//doublerealT R0_7 = 0.0;
												//doublerealT Rprev_7 = 0.0, Rnext_7 = 0.0;
												if (process_flow_logic) {
													// calculate initial residual.
													//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);



													//Rprev_7 = norma(residual_fine7, n_a[7]);


													// smother
													integer iter = 0;
													for (iter = 0; iter < nu2; iter++) {
														//quick seidel
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}

														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);


														Rnext_7 = norma(residual_fine7, n_a[7]);
														// this is process flow logic
														if (Rnext_7 < process_flow_alpha*R0_7) {
															// Смысл модификации в том что мы экономим итерации на пресмутере.
															break; // досрочно опускаемся на следующий уровень если он есть конечно.
														}
														else {
															Rprev_7 = Rnext_7;
														}
													}

													if (iter == nu2) {
														printf("level 7 limit postsmother iteration is reached\n");
													}

												}
												else {
													for (integer iter = 0; iter < nu2; iter++) {
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
													}
												}
											}

											move_up(nu1, nu2);


											// prolongation
											// residual_r
											//doublerealT *error_approx_fine6 = new doublerealT[n_a[6] + 1];
											for (integer ii = 1; ii <= n_a[6]; ii++) {
												error_approx_fine6[ii] = 0.0;
											}

#if doubleintprecision == 1
											//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
											//printf("error_approx_coarse6[%lld]=%e\n",ii, error_approx_coarse6[ii]);

											//printf("residual_coarse6[%lld]=%e\n", ii, residual_coarse6[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
											//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#else
											//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
											//printf("error_approx_coarse6[%d]=%e\n",ii, error_approx_coarse6[ii]);

											//printf("residual_coarse6[%d]=%e\n", ii, residual_coarse6[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
											//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#endif

											

											prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, error_approx_fine6, error_approx_coarse6, n_a[6], n_a[7]);

											// correction
											for (integer ii = 1; ii <= n_a[6]; ii++) {
												error_approx_coarse5[ii] += error_approx_fine6[ii];
											}

											// free
											//delete[] error_approx_fine6;
											//delete[] error_approx_coarse6;
											//delete[] residual_coarse6;
											//delete[] residual_fine6;

										}



										// post smothing
										if (process_flow_logic) {
											// calculate initial residual.
											//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);



											//Rprev_6 = norma(residual_fine6, n_a[6]);


											// smother
											integer iter = 0;
											for (iter = 0; iter < nu2; iter++) {
												//quick seidel
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}

												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);



												Rnext_6 = norma(residual_fine6, n_a[6]);
												// this is process flow logic
												if (Rnext_6 < process_flow_alpha*R0_6) {
													// Смысл модификации в том что мы экономим итерации на пресмутере.
													break; // досрочно опускаемся на следующий уровень если он есть конечно.
												}
												else {
													Rprev_6 = Rnext_6;
												}
											}

											if (iter == nu2) {
												printf("level 6 limit postsmother iteration is reached\n");
											}

										}
										else {
											for (integer iter = 0; iter < nu2; iter++) {
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
											}
										}
									}

									move_up(nu1, nu2);

									// prolongation
									// residual_r
									//doublerealT *error_approx_fine5 = new doublerealT[n_a[5] + 1];
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_fine5[ii] = 0.0;
									}

#if doubleintprecision == 1
									//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
									//printf("error_approx_coarse5[%lld]=%e\n",ii, error_approx_coarse5[ii]);

									//printf("residual_coarse5[%lld]=%e\n", ii, residual_coarse5[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#else
									//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
									//printf("error_approx_coarse5[%d]=%e\n",ii, error_approx_coarse5[ii]);

									//printf("residual_coarse5[%d]=%e\n", ii, residual_coarse5[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#endif

									

									prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, error_approx_fine5, error_approx_coarse5, n_a[5], n_a[6]);

									// correction
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] += error_approx_fine5[ii];
									}

									// free
									//delete[] error_approx_fine5;
									//delete[] error_approx_coarse5;
									//delete[] residual_coarse5;
									//delete[] residual_fine5;

								}



								// post smothing
								if (process_flow_logic) {
									// calculate initial residual.
									//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] , residual_fine5);



									//Rprev_5 = norma(residual_fine5, n_a[5]);


									// smother
									integer iter = 0;
									for (iter = 0; iter < nu2; iter++) {
										//quick seidel
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
										else {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}

										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] , residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);


										Rnext_5 = norma(residual_fine5, n_a[5]);
										// this is process flow logic
										if (Rnext_5 < process_flow_alpha*R0_5) {
											// Смысл модификации в том что мы экономим итерации на пресмутере.
											break; // досрочно опускаемся на следующий уровень если он есть конечно.
										}
										else {
											Rprev_5 = Rnext_5;
										}
									}

									if (iter == nu2) {
										printf("level 5 limit postsmother iteration is reached\n");
									}

								}
								else {
									for (integer iter = 0; iter < nu2; iter++) {
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
										else
										{
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
									}
								}
							}

							move_up(nu1, nu2);

							// prolongation
							// residual_r
							//doublerealT *error_approx_fine4 = new doublerealT[n_a[4] + 1];
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_fine4[ii] = 0.0;
							}


#if doubleintprecision == 1
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%lld]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%lld]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#else
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%d]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%d]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#endif

							

							prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, error_approx_fine4, error_approx_coarse4, n_a[4], n_a[5]);

							// correction
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] += error_approx_fine4[ii];
							}

							// free
							//delete[] error_approx_fine4;
							//delete[] error_approx_coarse4;
							//delete[] residual_coarse4;
							//delete[] residual_fine4;

							}




							// post smothing
							if (process_flow_logic) {


								// smother
								integer iter = 0;
								for (iter = 0; iter < nu2; iter++) {
									//quick seidel
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}

									//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] , residual_fine4);
									residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);


									Rnext_4 = norma(residual_fine4, n_a[4]);
									// this is process flow logic
									if (Rnext_4 < process_flow_alpha*R0_4) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_4 = Rnext_4;
									}
								}

								if (iter == nu2) {
									printf("level 4 limit postsmother iteration is reached\n");
								}

							}
							else {
								for (integer iter = 0; iter < nu2; iter++) {
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
								}
							}
						}
						move_up(nu1, nu2);

						// prolongation
						// residual_r
						//doublerealT *error_approx_fine3 = new doublerealT[n_a[3] + 1];
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_fine3[ii] = 0.0;
						}

#if doubleintprecision == 1
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%lld]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%lld]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#else
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%d]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%d]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#endif

						

						prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, error_approx_fine3, error_approx_coarse3, n_a[3], n_a[4]);

						// correction
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] += error_approx_fine3[ii];
						}

						// free
						//delete[] error_approx_fine3;
						//delete[] error_approx_coarse3;
						//delete[] residual_coarse3;
						//delete[] residual_fine3;

						}



						// post smothing
						if (process_flow_logic) {


							// smother
							integer iter = 0;
							for (iter = 0; iter < nu2; iter++) {
								//quick seidel
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}

								//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] , residual_fine3);
								residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);


								Rnext_3 = norma(residual_fine3, n_a[3]);
								// this is process flow logic
								if (Rnext_3 < process_flow_alpha*R0_3) {
									// Смысл модификации в том что мы экономим итерации на пресмутере.
									break; // досрочно опускаемся на следующий уровень если он есть конечно.
								}
								else {
									Rprev_3 = Rnext_3;
								}
							}

							if (iter == nu2) {
								printf("level 3 limit postsmother iteration is reached\n");
							}

						}
						else {
							for (integer iter = 0; iter < nu2; iter++) {
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
							}
						}
					}

					move_up(nu1, nu2);

					// prolongation
					// residual_r
					//doublerealT *error_approx_fine2 = new doublerealT[n_a[2] + 1];
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_fine2[ii] = 0.0;
					}

#if doubleintprecision == 1
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%lld]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%lld]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#else
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%d]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%d]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#endif

					

					prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, error_approx_fine2, error_approx_coarse2, n_a[2], n_a[3]);

					// correction
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] += error_approx_fine2[ii];
					}

					// free
					//delete[] error_approx_fine2;
					//delete[] error_approx_coarse2;
					//delete[] residual_coarse2;
					//delete[] residual_fine2;

					}


					// post smothing
					if (process_flow_logic) {


						// smother
						integer iter = 0;
						for (iter = 0; iter < nu2; iter++) {
							//quick seidel
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}

							//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
							residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);



							Rnext_2 = norma(residual_fine2, n_a[2]);
							// this is process flow logic
							if (Rnext_2 < process_flow_alpha*R0_2) {
								// Смысл модификации в том что мы экономим итерации на пресмутере.
								break; // досрочно опускаемся на следующий уровень если он есть конечно.
							}
							else {
								Rprev_2 = Rnext_2;
							}
						}

						if (iter == nu2) {
							printf("level 2 limit postsmother iteration is reached\n");
						}

					}
					else {
						for (integer iter = 0; iter < nu2; iter++) {
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
						}
					}
				}

				move_up(nu1, nu2);

				// prolongation
				// residual_r
				//doublerealT *error_approx_fine1 = new doublerealT[n_a[1] + 1];
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_fine1[ii] = 0.0;
				}


#if doubleintprecision == 1
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%lld]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%lld]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#else
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%d]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%d]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#endif

			

				prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, error_approx_fine1, error_approx_coarse1, n_a[1], n_a[2]);

				// correction
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] += error_approx_fine1[ii];
				}

				// free
				//delete[] error_approx_fine1;
				//delete[] error_approx_coarse1;
				//delete[] residual_coarse1;
				//delete[] residual_fine1;

				}



				// post smothing
				if (process_flow_logic) {


					// smother
					integer iter = 0;
					for (iter = 0; iter < nu2; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}

						//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0] , residual_fine1);
						residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);


						Rnext_1 = norma(residual_fine1, n_a[1]);
						// this is process flow logic
						if (Rnext_1 < process_flow_alpha*R0_1) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_1 = Rnext_1;
						}
					}

					if (iter == nu2) {
						printf("level 1 limit postsmother iteration is reached\n");
					}

				}
				else {
					for (integer iter = 0; iter < nu2; iter++) {
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}
					}
				}
			}

			move_up(nu1, nu2);

			// prolongation
			// residual_r
			//doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				error_approx_fine[ii] = 0.0;
			}

			prolongation(P, 1, nnz_aRP[0], flag, error_approx_fine, error_approx_coarse, n_a[0], n_a[1]);

			// correction
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				x[ii] += error_approx_fine[ii];
			}

			// free
			//delete[] error_approx_fine;
			//delete[] error_approx_coarse;
			//delete[] residual_coarse;
			//delete[] residual_fine;
		}



		//doublerealT R0_0 = 0.0;
		//doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		// post smothing
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
			Rprev_0 = norma(residual_fine, n_a[0]);

			// smother
			//integer iter = 0;
			//for (iter = 0; iter < nu2; iter++) {
			//quick seidel
			if (bonly_serial) {
				//	seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
			}
			else {
				//seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
			}
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			//	residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine,diag0);
			//	Rnext_0 = norma(residual_fine, n_a[0]);
			// this is process flow logic
			//	if (Rnext_0 < process_flow_alpha*R0_0) {
			// Смысл модификации в том что мы экономим итерации на пресмутере.
			//		break; // досрочно опускаемся на следующий уровень если он есть конечно.
			//	}
			//	else {
			//		Rprev_0 = Rnext_0;
			//	}
			//	}
			//if (iter == nu1) {
			//	printf("level 0 limit postsmother iteration is reached\n");
			//}

		}
		//else {
		// nFinnestSweeps new logic 14 jan 2016.
		// smother
		//for (integer iter = 0; iter < nu2; iter++) {
		//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
		//quick seidel
		if (bonly_serial) {
			//	seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
		}
		else {
			//seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
		}
		//			}
		//}






		//system("pause");
	}

	if (debug_reshime) system("pause");
	//system("pause");




	// free
	/*
	delete[] diag0;
	delete[] error_approx_fine;
	if (ilevel > 1) {
	delete[] diag1;
	delete[] error_approx_coarse;
	delete[] residual_coarse;
	if (ilevel > 2) {
	// free
	delete[] diag2;
	delete[] error_approx_fine1;
	delete[] error_approx_coarse1;
	delete[] residual_coarse1;
	delete[] residual_fine1;
	if (ilevel > 3) {
	// free
	delete[] diag3;
	delete[] error_approx_fine2;
	delete[] error_approx_coarse2;
	delete[] residual_coarse2;
	delete[] residual_fine2;
	if (ilevel > 4) {
	// free
	delete[] diag4;
	delete[] error_approx_fine3;
	delete[] error_approx_coarse3;
	delete[] residual_coarse3;
	delete[] residual_fine3;
	if (ilevel > 5) {
	// free
	delete[] diag5;
	delete[] error_approx_fine4;
	delete[] error_approx_coarse4;
	delete[] residual_coarse4;
	delete[] residual_fine4;
	if (ilevel > 6) {
	// free
	delete[] diag6;
	delete[] error_approx_fine5;
	delete[] error_approx_coarse5;
	delete[] residual_coarse5;
	delete[] residual_fine5;
	if (ilevel > 7) {
	// free
	delete[] diag7;
	delete[] error_approx_fine6;
	delete[] error_approx_coarse6;
	delete[] residual_coarse6;
	delete[] residual_fine6;
	if (ilevel > 8) {
	// free
	delete[] diag8;
	delete[] error_approx_fine7;
	delete[] error_approx_coarse7;
	delete[] residual_coarse7;
	delete[] residual_fine7;
	if (ilevel > 9) {
	// free
	delete[] error_approx_fine8;
	delete[] error_approx_coarse8;
	delete[] residual_coarse8;
	delete[] residual_fine8;
	if (ilevel > 10) {
	// free
	delete[] error_approx_fine9;
	delete[] error_approx_coarse9;
	delete[] residual_coarse9;
	delete[] residual_fine9;
	if (ilevel > 11) {
	// free
	delete[] error_approx_fine10;
	delete[] error_approx_coarse10;
	delete[] residual_coarse10;
	delete[] residual_fine10;
	if (ilevel > 12) {
	// free
	delete[] error_approx_fine11;
	delete[] error_approx_coarse11;
	delete[] residual_coarse11;
	delete[] residual_fine11;
	if (ilevel > 13) {
	// free
	delete[] error_approx_fine12;
	delete[] error_approx_coarse12;
	delete[] residual_coarse12;
	delete[] residual_fine12;
	if (ilevel > 14) {
	// free
	delete[] error_approx_fine13;
	delete[] error_approx_coarse13;
	delete[] residual_coarse13;
	delete[] residual_fine13;
	if (ilevel > 15) {
	// free
	delete[] error_approx_fine14;
	delete[] error_approx_coarse14;
	delete[] residual_coarse14;
	delete[] residual_fine14;
	if (ilevel > 16) {
	// free
	delete[] error_approx_fine15;
	delete[] error_approx_coarse15;
	delete[] residual_coarse15;
	delete[] residual_fine15;
	if (ilevel > 17) {
	// free
	delete[] error_approx_fine16;
	delete[] error_approx_coarse16;
	delete[] residual_coarse16;
	delete[] residual_fine16;
	if (ilevel > 18) {
	// free
	delete[] error_approx_fine17;
	delete[] error_approx_coarse17;
	delete[] residual_coarse17;
	delete[] residual_fine17;

	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	*/

	// free
	free(diag0);
	free(bnested_desection_global_amg);  // Глобальная память.
	free(nested_desection0);
	free(error_approx_fine);
	if (ilevel > 1) {
		free(diag1);
		free(nested_desection1);
		free(error_approx_coarse);
		free(residual_coarse);
		if (ilevel > 2) {
			// free
			free(diag2);
			free(nested_desection2);
			free(error_approx_fine1);
			free(error_approx_coarse1);
			free(residual_coarse1);
			free(residual_fine1);
			if (ilevel > 3) {
				// free
				free(diag3);
				free(nested_desection3);
				free(error_approx_fine2);
				free(error_approx_coarse2);
				free(residual_coarse2);
				free(residual_fine2);
				if (ilevel > 4) {
					// free
					free(diag4);
					free(nested_desection4);
					free(error_approx_fine3);
					free(error_approx_coarse3);
					free(residual_coarse3);
					free(residual_fine3);
					if (ilevel > 5) {
						// free
						free(diag5);
						free(nested_desection5);
						free(error_approx_fine4);
						free(error_approx_coarse4);
						free(residual_coarse4);
						free(residual_fine4);
						if (ilevel > 6) {
							// free
							free(diag6);
							free(nested_desection6);
							free(error_approx_fine5);
							free(error_approx_coarse5);
							free(residual_coarse5);
							free(residual_fine5);
							if (ilevel > 7) {
								// free
								free(diag7);
								free(nested_desection7);
								free(error_approx_fine6);
								free(error_approx_coarse6);
								free(residual_coarse6);
								free(residual_fine6);
								if (ilevel > 8) {
									// free
									free(diag8);
									free(nested_desection8);
									free(error_approx_fine7);
									free(error_approx_coarse7);
									free(residual_coarse7);
									free(residual_fine7);
									if (ilevel > 9) {
										// free
										free(error_approx_fine8);
										free(error_approx_coarse8);
										free(residual_coarse8);
										free(residual_fine8);
										if (ilevel > 10) {
											// free
											free(error_approx_fine9);
											free(error_approx_coarse9);
											free(residual_coarse9);
											free(residual_fine9);
											if (ilevel > 11) {
												// free
												free(error_approx_fine10);
												free(error_approx_coarse10);
												free(residual_coarse10);
												free(residual_fine10);
												if (ilevel > 12) {
													// free
													free(error_approx_fine11);
													free(error_approx_coarse11);
													free(residual_coarse11);
													free(residual_fine11);
													if (ilevel > 13) {
														// free
														free(error_approx_fine12);
														free(error_approx_coarse12);
														free(residual_coarse12);
														free(residual_fine12);
														if (ilevel > 14) {
															// free
															free(error_approx_fine13);
															free(error_approx_coarse13);
															free(residual_coarse13);
															free(residual_fine13);
															if (ilevel > 15) {
																// free
																free(error_approx_fine14);
																free(error_approx_coarse14);
																free(residual_coarse14);
																free(residual_fine14);
																if (ilevel > 16) {
																	// free
																	free(error_approx_fine15);
																	free(error_approx_coarse15);
																	free(residual_coarse15);
																	free(residual_fine15);
																	if (ilevel > 17) {
																		// free
																		free(error_approx_fine16);
																		free(error_approx_coarse16);
																		free(residual_coarse16);
																		free(residual_fine16);
																		if (ilevel > 18) {
																			// free
																			free(error_approx_fine17);
																			free(error_approx_coarse17);
																			free(residual_coarse17);
																			free(residual_fine17);

																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}


	//delete[] residual_fine;
	free(residual_fine);

	//delete[] row_ptr_start;
	//delete[] row_ptr_end;
	free(row_ptr_start);
	free(row_ptr_end);


	//delete[] flag_shadow;
	free(flag_shadow);


	//delete[] flag;
	free(flag);
	return 0;

} // classic_aglomerative_amg3

// Быстрая сортировка Хоара.
// Запрограммировано с использованием ДЖ. Макконелл Анализ алгоритмов
// стр. 106.
// Объявление функции которая нужна уже здесь но её реализация
// встретится лишь ниже по тексту в файле my_linalg.c.
template <typename MY_IND_TYPE>
void QuickSortCSIR(MY_IND_TYPE* &jptr, doublereal* &altr, integer first, integer last);



// Объявление структуры LEVEL_ADDITIONAL_DATA см. в файле ilut.c:
// 11 августа 2016.

// Объявление структуры LEVEL_ADDITIONAL_DATA0 см. в файле ilut.c:
// 11 августа 2016.

// Выделение оперативной памяти для: 
// LEVEL_ADDITIONAL_DATA_BUFER milu_gl_buffer
void memory_allocation_apostoriory_buffer_ilu(LEVEL_ADDITIONAL_DATA* &milu2, integer ilevel) {
	if (milu_gl_buffer.alu_copy != nullptr) {
		delete[] milu_gl_buffer.alu_copy;
		milu_gl_buffer.alu_copy = nullptr;
	}
	if (milu_gl_buffer.jlu_copy != nullptr) {
		delete[] milu_gl_buffer.jlu_copy;
		milu_gl_buffer.jlu_copy = nullptr;
	}
	if (milu_gl_buffer.ju_copy != nullptr) {
		delete[] milu_gl_buffer.ju_copy;
		milu_gl_buffer.ju_copy = nullptr;
	}

	// Определяем максимум памяти чтобы хватило универсально на все уровни.
	integer iwk = -1;
	integer maxelm_plus_maxbound = -1;
	for (integer i = 0; i <= ilevel; i++) {
		if (iwk < milu2[i].iwk) iwk = milu2[i].iwk;
		if (maxelm_plus_maxbound < milu2[i].maxelm_plus_maxbound) {
			maxelm_plus_maxbound = milu2[i].maxelm_plus_maxbound;
		}
	}

	milu_gl_buffer.alu_copy = new doublereal[iwk + 2]; // +2 запас по памяти.
	milu_gl_buffer.jlu_copy = new integer[iwk + 2];
	milu_gl_buffer.ju_copy = new integer[maxelm_plus_maxbound + 2];
} // memory_allocation_apostoriory_buffer_ilu

// 15 11 2016 метод полностью на malloc с контролем через handle_error.
// Мы усилим РУМБА0.14 алгоритм ILU2 предобуславливанием на каждом уровне вложенности.
// Преобразует equation3D  формат хранения в CRS формат.
// Цель написания этого преобразователя: экономия оперативной памяти компьютера.
// Т.к. формат SIMPLESPARSE требует слишком много памяти.
void equation3DtoCRSRUMBA1(LEVEL_ADDITIONAL_DATA &milu2,
	bool ballocmemory, Ak1* &Amat, integer istartq, integer iendq, 
	integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, integer ilevel) {

	// Если ballocmemory равен true то происходит выделение памяти.
	const bool bonly_negative_connections = false;
	bool flag = true;
	integer n = 0; // число ненулевых элементов
	integer maxelm_plus_maxbound = 0; // Число уравнений в СЛАУ.

	const doublereal nonzeroEPS = 1e-37; // для отделения вещественного нуля

	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;


	// подсчёт количества ненулевых элементов
	// во всех точках расчётной области как внутренних так и граничных.
	for (integer ii = startpos; ii <= endpos; ii++) {
		maxelm_plus_maxbound++;
		integer istr = ii - iadd;
		if (fabs(Amat[row_ptr_start[ii]].aij) < 1.0e-20)
		{
#if doubleintprecision == 1
			printf("zero diagonal coefficient in level = %lld, istr=%lld\n", ilevel, istr);
#else
			printf("zero diagonal coefficient in level = %d, istr=%d\n", ilevel, istr);
#endif
			
			//getchar();
			system("PAUSE");
			exit(1);
		}
		doublereal ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

		//if (fabs(ap_now)> 1e10*nonzeroEPS) n++; // диагональный элемент
		if (ap_now > nonzeroEPS) n++; // Диагональный элемент.
		else {
			// 5 августа 2016. 
			flag = false;
			printf("internal zero diagonal element.\n");
			//printf("ae=%e aw=%e an=%e as=%e at=%e ab=%e sum_nb=%e", sl[k].ae, sl[k].aw, sl[k].an, sl[k].as, sl[k].at, sl[k].ab, sl[k].ae + sl[k].aw + sl[k].an + sl[k].as + sl[k].at + sl[k].ab);
			if (ap_now < 0.0) {
				printf("found negativ diagonal coefficient=%e...\n", ap_now);
			}
			printf("fatal error equation3DtoCRS in RUMBA...\n");
			//getchar();
			system("PAUSE");
			exit(1);
			//n++;
			//sl[k].ap = fabs(sl[k].ae) + fabs(sl[k].aw) + fabs(sl[k].an) + fabs(sl[k].as) + fabs(sl[k].at) + fabs(sl[k].ab);
		}

		integer is1 = row_ptr_start[ii] + 1;
		integer is2 = row_ptr_end[ii];

		for (integer ii1 = is1; ii1 <= is2; ii1++)
		{
			if (bonly_negative_connections) {
				if (Amat[ii1].aij < -nonzeroEPS) {
					n++;
				}
			}
			else {
				if (fabs(Amat[ii1].aij) > nonzeroEPS) n++;
			}
		}
	}


	if (flag) {
		// memory +15N
		// Теперь выделение памяти будет происходить централизованно, вне данного кода.
		// Это сделано для кода BICGSTAB_internal3. дата изменения 12 апреля 2013.
		// Другой код, использующий equation3dtoCRS может оказаться неработоспособным после этого изменения.
		if (ballocmemory) {
			// Важно выделить память с запасом, т.к. одна и таже память используется и для компонент скорости и для поправки давления.
			//val = new doublereal[7 * (maxelm + maxbound) + 2 * maxbound + 2];
			//col_ind = new integer[7 * (maxelm + maxbound) + 2 * maxbound + 2];
			
			//milu2.val = new doublereal[n + 2];
			milu2.val = (doublereal*)malloc((n+2) * sizeof(doublereal));
			char c1[11] = "milu2.val";
			char c2[23] = "equation3DtoCRSRUMBA1";
			handle_error<doublereal>(milu2.val,  c1, c2, (n + 2));
			//milu2.col_ind = new integer[n + 2];
			milu2.col_ind = (integer*)malloc((n + 2) * sizeof(integer));
			char c3[14] = "milu2.col_ind";
			handle_error<integer>(milu2.col_ind, c3, c2, (n + 2));
			//row_ptr = new integer[(maxelm + maxbound) + 1];
			//milu2.row_ptr = new integer[maxelm_plus_maxbound + 1];
			milu2.row_ptr= (integer*)malloc((maxelm_plus_maxbound + 1) * sizeof(integer));
			char c4[14] = "milu2.row_ptr";
			handle_error<integer>(milu2.row_ptr, c4, c2, (maxelm_plus_maxbound + 1));

			if ((milu2.val == nullptr) || (milu2.col_ind == nullptr) || (milu2.row_ptr == nullptr)) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
		}


		// инициализация
#pragma omp parallel for
		for (integer k = 0; k<(n); k++) {
			milu2.val[k] = 0.0;
			milu2.col_ind[k] = -1;
		}
#pragma omp parallel for
		for (integer k = 0; k <= (maxelm_plus_maxbound); k++) {
			milu2.row_ptr[k] = n; // присваиваем количество ненулевых элементов плюс 1 с учётом того что нумерация массива начинается с 0
		}

		// Быстрая Сортировка Хоара.
		// упорядочивание по строкам
		//QuickSort(...); не требуется,
		// т.к. сама структура хранения 
		// подразумевает упорядочивание по строкам.

		/*
		// заполнение разреженной матрицы
		for (integer k=0; k<M.n; k++) {
		val[k]=M.a[k].aij;
		col_ind[k]=M.a[k].j;
		row_ptr[M.a[k].i]=min(k,row_ptr[M.a[k].i]);
		}
		*/
		integer ik = 0; // счётчик ненулевых элементов СЛАУ

		// для всех узлов расчётной области как внутренних так и внешних:
		for (integer ii = startpos; ii <= endpos; ii++) {
			 integer istr = ii - iadd;
			 integer k = istr-1; // нумерация с нуля.
			 doublereal ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;
		

			 // Диагональный коэффициент.
			if (fabs(ap_now) > nonzeroEPS) {
				milu2.val[ik] = ap_now;
				milu2.col_ind[ik] = istr-1; // Нуменрация начинается с нуля.
				milu2.row_ptr[k] = (ik < milu2.row_ptr[k] ? ik : milu2.row_ptr[k]);
				ik++;
			}

			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];

			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				if (bonly_negative_connections) {
					if (Amat[ii1].aij < -nonzeroEPS) {
						milu2.val[ik] = Amat[ii1].aij; // уже с учётом знака.
						milu2.col_ind[ik] = Amat[ii1].j - 1; // Нумерация начинается с нуля.
						milu2.row_ptr[k] = (ik < milu2.row_ptr[k] ? ik : milu2.row_ptr[k]);
						ik++;
					}
				}
				else {
					if (fabs(Amat[ii1].aij) > nonzeroEPS) {
						milu2.val[ik] = Amat[ii1].aij; // уже с учётом знака.
						milu2.col_ind[ik] = Amat[ii1].j - 1; // Нумерация начинается с нуля.
						milu2.row_ptr[k] = (ik < milu2.row_ptr[k] ? ik : milu2.row_ptr[k]); 
						ik++;
					}
				}
			}
		}	

		// в каждой строке элементы отсортированы по номерам столбцов:
#pragma omp parallel for
		for (integer k = 0; k<(maxelm_plus_maxbound); k++) QuickSortCSIR(milu2.col_ind, milu2.val, milu2.row_ptr[k] + 1, milu2.row_ptr[k + 1] - 1);

#if doubleintprecision == 1
		//printf("n==%lld row_ptr=%lld\n", n, milu2.row_ptr[maxelm_plus_maxbound]);
#else
		//printf("n==%d row_ptr=%d\n", n, milu2.row_ptr[maxelm_plus_maxbound]);
#endif
		
		//getchar();

		milu2.maxelm_plus_maxbound = maxelm_plus_maxbound;
#pragma omp parallel for
		for (integer i = 0; i<milu2.row_ptr[maxelm_plus_maxbound]; i++) {
			milu2.col_ind[i] = milu2.col_ind[i] + 1;
		}
#pragma omp parallel for
		for (integer i = 0; i<maxelm_plus_maxbound + 1; i++) {
			milu2.row_ptr[i] = milu2.row_ptr[i] + 1;
		}

		/*
		FILE *fp;
		errno_t err;
		// создание файла для записи.
		if ((err = fopen_s( &fp, "matr.txt", "w")) != 0) {
		printf("Create File Error\n");
		}
		else {

		// debug
		for (k=0; k<=maxelm+maxbound; k++) {
		#if doubleintprecision == 1
			fprintf(fp,"%lld ",milu2.row_ptr[k]);
		#else
			fprintf(fp,"%d ",milu2.row_ptr[k]);
		#endif
		
		}
		fprintf(fp,"\n");
		for (k=0; k<milu2.row_ptr[maxelm+maxbound]; k++) {
		#if doubleintprecision == 1
			fprintf(fp, "%e %lld\n",milu2.val[k],milu2.col_ind[k]);
		#else
			fprintf(fp, "%e %d\n",milu2.val[k],milu2.col_ind[k]);
		#endif
		
		}

		fclose(fp);
		}
		printf("ready");
		getchar();
		*/
		doublereal radd = 0.0;
		/*
		if (ilevel == 0) {
			radd = 1.8;
		}
		else if (ilevel == 1) {
			radd = 4.2;
		}
		else if ((ilevel >=2)&&(ilevel<=5)) {
			radd = 7.0;
		}
		else if (ilevel==6) {
			radd = 7.0;
		}
		else {
			radd = 8.0;
		}
		*/
		if (1||milu2.lfil == 0) {
			//radd = 3.3*(n / (5.0*maxelm_plus_maxbound));
			//milu2.iwk = (integer)((milu2.lfil + 1 + radd) * n + 4 * maxelm_plus_maxbound);
			milu2.iwk = n + 4; // ilu0 не требует лишней памяти.
		}

		 // размерность памяти под матрицу предобуславливания.
		// Выделение оперативной памяти может быть 
		// повторным, поэтому необходимо освободить оперативную память,
		// перед повторным выделением.
		if (milu2.alu != nullptr) {
			//delete[] milu2.alu;
			free(milu2.alu);
			milu2.alu = nullptr;
		}
		//milu2.alu = new doublereal[milu2.iwk + 2]; // +2 запас по памяти.
		milu2.alu = (doublereal*)malloc((milu2.iwk + 2) * sizeof(doublereal));
		char c1[23] = "equation3DtoCRSRUMBA1";
		char c2[11] = "milu2.alu";
		handle_error<doublereal>(milu2.alu, c2 ,  c1, (milu2.iwk + 2));
		// Выделение оперативной памяти может быть 
		// повторным, поэтому необходимо освободить оперативную память,
		// перед повторным выделением.
		if (milu2.jlu != nullptr) {
			//delete[] milu2.jlu;
			free(milu2.jlu);
			milu2.jlu = nullptr;
		}
		//milu2.jlu = new integer[milu2.iwk + 2];
		milu2.jlu = (integer*)malloc((milu2.iwk + 2) * sizeof(integer));
		char c3[11] = "milu2.jlu";
		handle_error<integer>(milu2.jlu, c3,  c1, (milu2.iwk + 2));
		// Выделение оперативной памяти может быть 
		// повторным, поэтому необходимо освободить оперативную память,
		// перед повторным выделением.
		if (milu2.ju != nullptr) {
			//delete[] milu2.ju;
			free(milu2.ju);
			milu2.ju = nullptr;
		}
		//milu2.ju = new integer[maxelm_plus_maxbound + 2];
		milu2.ju = (integer*)malloc((maxelm_plus_maxbound + 2) * sizeof(integer));
		char c4[10] = "milu2.ju";
		handle_error<integer>(milu2.ju, c4,  c1, (maxelm_plus_maxbound + 2));
		//milu2.levs = new integer[milu2.iwk + 2]; // уровень.
		milu2.levs = (integer*)malloc((milu2.iwk + 2) * sizeof(integer));
		char c5[12] = "milu2.levs";
		handle_error<integer>(milu2.levs, c5,  c1, (milu2.iwk + 2));
		//milu2.w = new doublereal[maxelm_plus_maxbound + 2]; // +2 запас по памяти.
		milu2.w = (doublereal*)malloc((maxelm_plus_maxbound + 2) * sizeof(doublereal));
		char c6[9] = "milu2.w";
		handle_error<doublereal>(milu2.w, c6 ,  c1, (maxelm_plus_maxbound + 2));
		char c7[10] = "milu2.jw";
		if (1 || milu2.lfil == 0) {
			//milu2.jw = new integer[3 * maxelm_plus_maxbound + 2]; // +2 запас по памяти.
			milu2.jw = (integer*)malloc((3 * maxelm_plus_maxbound + 2) * sizeof(integer));			
			handle_error<integer>(milu2.jw, c7,  c1, (3 * maxelm_plus_maxbound + 2));
		}
		else {
			if (ilevel < 6) {
				///milu2.jw = new integer[5 * maxelm_plus_maxbound + 2]; // +2 запас по памяти.
				milu2.jw = (integer*)malloc((5 * maxelm_plus_maxbound + 2) * sizeof(integer));
				handle_error<integer>(milu2.jw, c7,  c1, (5 * maxelm_plus_maxbound + 2));
			}
			else {
				//milu2.jw = new integer[12 * maxelm_plus_maxbound + 2]; // +2 запас по памяти.
				milu2.jw = (integer*)malloc((12 * maxelm_plus_maxbound + 2) * sizeof(integer));
				handle_error<integer>(milu2.jw, c7,  c1, (12 * maxelm_plus_maxbound + 2));
			}
		}
		if ((milu2.alu == nullptr) || (milu2.jlu == nullptr) || (milu2.levs == nullptr) || (milu2.ju == nullptr) || (milu2.w == nullptr) || (milu2.jw == nullptr)) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}

		// копии объектов
		// 9 ноября 2016 Копии объектов теперь хранятся централизованно:
		// см. LEVEL_ADDITIONAL_DATA_BUFER milu_gl_buffer; in ilut.c module.
		//milu2.alu_copy = new doublereal[milu2.iwk + 2]; // +2 запас по памяти.
		//milu2.jlu_copy = new integer[milu2.iwk + 2];
		//milu2.ju_copy = new integer[maxelm_plus_maxbound + 2];
		//milu2.b_copy = new doublereal[maxelm_plus_maxbound + 2];
		char c8[13] = "milu2.b_copy";
		milu2.b_copy = (doublereal*)malloc((maxelm_plus_maxbound + 2) * sizeof(doublereal));
		handle_error<doublereal>(milu2.b_copy, c8 ,  c1, (maxelm_plus_maxbound + 2));
		//milu2.x_copy = new doublereal[maxelm_plus_maxbound + 2];
		milu2.x_copy = (doublereal*)malloc((maxelm_plus_maxbound + 2) * sizeof(doublereal));
		char c9[13] = "milu2.x_copy";
		handle_error<doublereal>(milu2.x_copy, c9,  c1, (maxelm_plus_maxbound + 2));
		// Выделение оперативной памяти может быть 
		// повторным, поэтому необходимо освободить оперативную память,
		// перед повторным выделением.
		if (milu2.zbuf != nullptr) {
			//delete[] milu2.zbuf;
			free(milu2.zbuf);
			milu2.zbuf = nullptr;
		}
		//milu2.zbuf = new doublereal[maxelm_plus_maxbound + 2];
		milu2.zbuf = (doublereal*)malloc((maxelm_plus_maxbound + 2) * sizeof(doublereal));
		char c10[11] = "milu2.zbuf";
		handle_error<doublereal>(milu2.zbuf, c10,  c1, (maxelm_plus_maxbound + 2));
		// Выделение оперативной памяти может быть 
		// повторным, поэтому необходимо освободить оперативную память,
		// перед повторным выделением.
		if (milu2.zbuf2 != nullptr) {
			//delete[] milu2.zbuf2;
			free(milu2.zbuf2);
			milu2.zbuf2 = nullptr;
		}
		//milu2.zbuf2 = new doublereal[maxelm_plus_maxbound + 2];
		milu2.zbuf2 = (doublereal*)malloc((maxelm_plus_maxbound + 2) * sizeof(doublereal));
		char c11[12] = "milu2.zbuf2";
		handle_error<doublereal>(milu2.zbuf2, c11,  c1, (maxelm_plus_maxbound + 2));

		//if ((milu2.alu_copy == nullptr) || (milu2.jlu_copy == nullptr) || (milu2.ju_copy == nullptr) || (milu2.b_copy == nullptr) || (milu2.x_copy == nullptr) || (milu2.zbuf==nullptr)||(milu2.zbuf2==nullptr)) {
		if ((milu2.b_copy == nullptr) || (milu2.x_copy == nullptr) || (milu2.zbuf == nullptr) || (milu2.zbuf2 == nullptr)) {
		    // недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}

		//milu2.lfil = 2;
		integer ierr=0;
		iluk_(maxelm_plus_maxbound, milu2.val, milu2.col_ind, milu2.row_ptr, 0/*milu2.lfil*/, milu2.alu, milu2.jlu, milu2.ju, milu2.levs, milu2.iwk, milu2.w, milu2.jw, ierr);
		if (ierr != 0) {
#if doubleintprecision == 1
			printf("ierr=%lld\n", ierr);
#else
			printf("ierr=%d\n", ierr);
#endif
			
			//getchar();
			system("PAUSE");
			exit(1);
		}

		if ((ierr == -2) || (ierr == -3)) {

			integer ipassage = 1;
			do {
				printf("\nPlease WAIT... ... ...\n");

				// задаче не хватило памяти, значит нужно перевыделить !
				//if (milu2.alu != nullptr) delete[] milu2.alu;
				//if (milu2.jlu != nullptr) delete[] milu2.jlu;
				//if (milu2.levs != nullptr) delete[] milu2.levs;
				if (milu2.alu != nullptr) free(milu2.alu);
				if (milu2.jlu != nullptr) free(milu2.jlu);
				if (milu2.levs != nullptr) free(milu2.levs);
				//if (milu2.alu_copy != nullptr) delete[] milu2.alu_copy;
				//if (milu2.jlu_copy != nullptr) delete[] milu2.jlu_copy;

				// инициализация !
				milu2.alu = nullptr;
				milu2.jlu = nullptr;
				milu2.levs = nullptr;
				//milu2.alu_copy = nullptr;
				//milu2.jlu_copy = nullptr;

				milu2.iwk = (integer)((milu2.lfil + 1 + radd) * n + ((1 + 3 + 3 * ipassage)*maxelm_plus_maxbound));
				//milu2.alu = new doublereal[milu2.iwk + 2]; // +2 запас по памяти.
				milu2.alu = (doublereal*)malloc((milu2.iwk + 2) * sizeof(doublereal));
				char c12[11] = "milu2.alu";
				handle_error<doublereal>(milu2.alu, c12,  c1, (milu2.iwk + 2));
				//milu2.jlu = new integer[milu2.iwk + 2];
				milu2.jlu = (integer*)malloc((milu2.iwk + 2) * sizeof(integer));
				char c13[11] = "milu2.jlu";
				handle_error<integer>(milu2.jlu, c13,  c1, (milu2.iwk + 2));
				//milu2.levs = new integer[milu2.iwk + 2]; // уровень.
				milu2.levs = (integer*)malloc((milu2.iwk + 2) * sizeof(integer));
				char c14[11] = "milu2.levs";
				handle_error<integer>(milu2.levs, c14,  c1, (milu2.iwk + 2));
				//milu2.alu_copy = new doublereal[milu2.iwk + 2]; // +2 запас по памяти.
				//milu2.jlu_copy = new integer[milu2.iwk + 2];

				//if ((milu2.alu_copy != nullptr) && (milu2.jlu_copy != nullptr) && (milu2.alu != nullptr) && (milu2.jlu != nullptr) && (milu2.levs != nullptr)) {
				if ((milu2.alu != nullptr) && (milu2.jlu != nullptr) && (milu2.levs != nullptr)) {
					iluk_(maxelm_plus_maxbound, milu2.val, milu2.col_ind, milu2.row_ptr, milu2.lfil, milu2.alu, milu2.jlu, milu2.ju, milu2.levs, milu2.iwk, milu2.w, milu2.jw, ierr);
				}
				else {
					// недостаточно памяти на данном оборудовании.
					ipassage = 4;
					printf("Problem: not enough memory on your equipment...\n");
					printf("Please any key to exit...\n");
					exit(1);
				}

				ipassage++;
				// Пока просто контролируем, в добавок хорошо бы выводить информацию на каком уровне это произошло.
#if doubleintprecision == 1
				printf("control memory allocation for ilu2 in RUMBA0.14 in level=%lld\n", ilevel);
#else
				printf("control memory allocation for ilu2 in RUMBA0.14 in level=%d\n", ilevel);
#endif
				
				system("PAUSE");
			} while ((ierr != 0) && (ipassage<4));

			if (ipassage == 4) {
				printf("Error memory alloc !!!\n");
				printf("failed to obtain an expansion for the 4 approaches...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("PAUSE");
				exit(1);
			}
		}

		for (integer k = 0; k<n; k++) if (milu2.col_ind[k] == (-1)) {
			printf("Error equation3D to CRS.\n");
			//getchar();
			system("pause");
		}

		// Нумерация начинается с единицы (это важно).
		for (integer k = 0; k<maxelm_plus_maxbound; k++) {
			if (milu2.val[milu2.row_ptr[k] - 1]<nonzeroEPS) {
#if doubleintprecision == 1
				printf("negativ diagonal element equation3DtoCRS %lld\n", k);
#else
				printf("negativ diagonal element equation3DtoCRS %d\n", k);
#endif
				
				//getchar();
				system("pause");
			}
		}

		if (1 || milu2.lfil == 0) {
			// экономим оперативную память.
			//if (milu2.val != nullptr) delete[] milu2.val;
			//if (milu2.col_ind != nullptr) delete[] milu2.col_ind;
			//if (milu2.row_ptr != nullptr) delete[] milu2.row_ptr;
			if (milu2.val != nullptr) free(milu2.val);
			if (milu2.col_ind != nullptr) free(milu2.col_ind);
			if (milu2.row_ptr != nullptr) free(milu2.row_ptr);
			milu2.val = nullptr;
			milu2.col_ind = nullptr;
			milu2.row_ptr = nullptr;
		}

	}

	if (!flag) {
		printf("Error equation 3D to CRS: zero diagonal element...\n");
		//getchar();
		system("pause");
	}	


} // equation3DtoCRSRUMBA1


  // Мы усилим РУМБА0.14 алгоритм ILU0 предобуславливанием (сглаживателем) на каждом уровне вложенности.
  // Преобразует equation3D  формат хранения в CRS формат.
  // Цель написания этого преобразователя: экономия оперативной памяти компьютера.
  // Т.к. формат SIMPLESPARSE требует слишком много памяти.
// Для многих задач сходимость мульгрида на базе Зейдель сглаживателя недостаточна. 
// Судя по документации ILU0 smoother more effective по сравнению с Зейдель сглаживателем.
// ILU0 - универсален и не накладывает ограничений на структуру матрицы СЛАУ. ILU0 потребляет мало пользователей.
void equation3DtoCRSRUMBA0(LEVEL_ADDITIONAL_DATA0 &milu0,
	bool ballocmemory, Ak1* &Amat, integer istartq, integer iendq,
	integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, integer ilevel) {


	// iadd_now=n_a[0]+...+n_a[ilevel_detector-1];
	//equation3DtoCRSRUMBA0(milu0[ilevel_detector], true,
		//Amat, 1, n_a[ilevel_detector], row_ptr_start, row_ptr_end, iadd_now, ilevel_detector);

	// Если ballocmemory равен true то происходит выделение памяти.
	const bool bonly_negative_connections = false;
	bool flag = true;
	integer n = 0; // число ненулевых элементов
	integer maxelm_plus_maxbound = 0; // Число уравнений в СЛАУ.

	const doublereal nonzeroEPS = 1e-37; // для отделения вещественного нуля

	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;


	// подсчёт количества ненулевых элементов
	// во всех точках расчётной области как внутренних так и граничных.
	for (integer ii = startpos; ii <= endpos; ii++) {
		maxelm_plus_maxbound++;
		integer istr = ii - iadd;
		if (fabs(Amat[row_ptr_start[ii]].aij) < 1.0e-20)
		{
#if doubleintprecision == 1
			printf("zero diagonal coefficient in level = %lld, istr=%lld\n", ilevel, istr);
#else
			printf("zero diagonal coefficient in level = %d, istr=%d\n", ilevel, istr);
#endif
			
			//getchar();
			system("PAUSE");
			exit(1);
		}
		doublereal ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

		//if (fabs(ap_now)> 1e10*nonzeroEPS) n++; // диагональный элемент
		if (ap_now > nonzeroEPS) n++; // Диагональный элемент.
		else {
			// 5 августа 2016. 
			flag = false;
			printf("internal zero diagonal element.\n");
			//printf("ae=%e aw=%e an=%e as=%e at=%e ab=%e sum_nb=%e", sl[k].ae, sl[k].aw, sl[k].an, sl[k].as, sl[k].at, sl[k].ab, sl[k].ae + sl[k].aw + sl[k].an + sl[k].as + sl[k].at + sl[k].ab);
			if (ap_now < 0.0) {
				printf("found negativ diagonal coefficient=%e...\n", ap_now);
			}
			printf("fatal error equation3DtoCRS in RUMBA...\n");
			//getchar();
			system("PAUSE");
			exit(1);
			//n++;
			//sl[k].ap = fabs(sl[k].ae) + fabs(sl[k].aw) + fabs(sl[k].an) + fabs(sl[k].as) + fabs(sl[k].at) + fabs(sl[k].ab);
		}

		integer is1 = row_ptr_start[ii] + 1;
		integer is2 = row_ptr_end[ii];

		for (integer ii1 = is1; ii1 <= is2; ii1++)
		{
			if (bonly_negative_connections) {
				if (Amat[ii1].aij < -nonzeroEPS) {
					n++;
				}
			}
			else {
				if (fabs(Amat[ii1].aij) > nonzeroEPS) {
					n++;
				}
				else {
#if doubleintprecision == 1
					printf("igmoring a[%d][%d]=%e istr=%lld\n", Amat[ii1].i, Amat[ii1].j, fabs(Amat[ii1].aij), istr);
#else
					printf("igmoring a[%d][%d]=%e istr=%d\n", Amat[ii1].i, Amat[ii1].j, fabs(Amat[ii1].aij), istr);
#endif
					
				}
			}
		}
	}

#if doubleintprecision == 1
	printf("nnz=%lld, %lld startpos=%lld endpos=%lld\n", n, row_ptr_end[endpos] - row_ptr_start[startpos] + 1, startpos, endpos);
#else
	printf("nnz=%d, %d startpos=%d endpos=%d\n", n, row_ptr_end[endpos] - row_ptr_start[startpos] + 1, startpos, endpos);
#endif
	
	system("PAUSE");

	if (flag) {
		// memory +15N
		// Теперь выделение памяти будет происходить централизованно, вне данного кода.
		// Это сделано для кода BICGSTAB_internal3. дата изменения 12 апреля 2013.
		// Другой код, использующий equation3dtoCRS может оказаться неработоспособным после этого изменения.
		if (ballocmemory) {
			// Важно выделить память с запасом, т.к. одна и таже память используется и для компонент скорости и для поправки давления.
			//val = new doublereal[7 * (maxelm + maxbound) + 2 * maxbound + 2];
			//col_ind = new integer[7 * (maxelm + maxbound) + 2 * maxbound + 2];
			milu0.val = new doublereal[n + 2];
			milu0.col_ind = new integer[n + 2];
			//row_ptr = new integer[(maxelm + maxbound) + 1];
			milu0.row_ptr = new integer[maxelm_plus_maxbound + 1];
			if ((milu0.val == nullptr) || (milu0.col_ind == nullptr) || (milu0.row_ptr == nullptr)) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for ILU0 decomposition...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
		}


		// инициализация
#pragma omp parallel for
		for (integer k = 0; k<(n); k++) {
			milu0.val[k] = 0.0;
			milu0.col_ind[k] = -1;
		}
#pragma omp parallel for
		for (integer k = 0; k <= (maxelm_plus_maxbound); k++) {
			milu0.row_ptr[k] = n; // присваиваем количество ненулевых элементов плюс 1 с учётом того что нумерация массива начинается с 0
		}

		// Быстрая Сортировка Хоара.
		// упорядочивание по строкам
		//QuickSort(...); не требуется,
		// т.к. сама структура хранения 
		// подразумевает упорядочивание по строкам.

		/*
		// заполнение разреженной матрицы
		for (integer k=0; k<M.n; k++) {
		val[k]=M.a[k].aij;
		col_ind[k]=M.a[k].j;
		row_ptr[M.a[k].i]=min(k,row_ptr[M.a[k].i]);
		}
		*/
		integer ik = 0; // счётчик ненулевых элементов СЛАУ

					// для всех узлов расчётной области как внутренних так и внешних:
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			integer k = istr - 1; // нумерация с нуля.
			doublereal ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;


			// Диагональный коэффициент.
			if (fabs(ap_now) > nonzeroEPS) {
				milu0.val[ik] = ap_now;
				milu0.col_ind[ik] = istr - 1; // Нуменрация начинается с нуля.
				milu0.row_ptr[k] = (ik < milu0.row_ptr[k] ? ik : milu0.row_ptr[k]); 
				ik++;
			}

			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];

			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				if (bonly_negative_connections) {
					if (Amat[ii1].aij < -nonzeroEPS) {
						milu0.val[ik] = Amat[ii1].aij; // уже с учётом знака.
						milu0.col_ind[ik] = Amat[ii1].j - 1; // Нумерация начинается с нуля.
						milu0.row_ptr[k] = (ik < milu0.row_ptr[k] ? ik : milu0.row_ptr[k]);
						ik++;
					}
				}
				else {
					if (fabs(Amat[ii1].aij) > nonzeroEPS) {
						milu0.val[ik] = Amat[ii1].aij; // уже с учётом знака.
						milu0.col_ind[ik] = Amat[ii1].j - 1; // Нумерация начинается с нуля.
						milu0.row_ptr[k] = (ik < milu0.row_ptr[k] ? ik : milu0.row_ptr[k]);
						ik++;
					}
				}
			}
		}

		// в каждой строке элементы отсортированы по номерам столбцов:
#pragma omp parallel for
		for (integer k = 0; k<(maxelm_plus_maxbound); k++) QuickSortCSIR(milu0.col_ind, milu0.val, milu0.row_ptr[k] + 1, milu0.row_ptr[k + 1] - 1);

#if doubleintprecision == 1
		//printf("n==%lld row_ptr=%lld\n", n, milu0.row_ptr[maxelm_plus_maxbound]);
#else
		//printf("n==%d row_ptr=%d\n", n, milu0.row_ptr[maxelm_plus_maxbound]);
#endif
		
		//getchar();
#pragma omp parallel for
		for (integer i = 0; i<milu0.row_ptr[maxelm_plus_maxbound]; i++) {
			milu0.col_ind[i] = milu0.col_ind[i] + 1;
		}
#pragma omp parallel for
		for (integer i = 0; i<maxelm_plus_maxbound + 1; i++) {
			milu0.row_ptr[i] = milu0.row_ptr[i] + 1;
		}

		/*
		FILE *fp;
		errno_t err;
		// создание файла для записи.
		if ((err = fopen_s( &fp, "matr.txt", "w")) != 0) {
		printf("Create File Error\n");
		}
		else {
		#if doubleintprecision == 1
			// debug
			for (k=0; k<=maxelm+maxbound; k++) {
				fprintf(fp,"%lld ",milu0.row_ptr[k]);
			}
			fprintf(fp,"\n");
			for (k=0; k<milu0.row_ptr[maxelm+maxbound]; k++) {
				fprintf(fp, "%e %lld\n",milu0.val[k],milu0.col_ind[k]);
			}
		#else
			// debug
			for (k=0; k<=maxelm+maxbound; k++) {
				fprintf(fp,"%d ",milu0.row_ptr[k]);
			}
			fprintf(fp,"\n");
			for (k=0; k<milu0.row_ptr[maxelm+maxbound]; k++) {
				fprintf(fp, "%e %d\n",milu0.val[k],milu0.col_ind[k]);
			}
		#endif

		

		fclose(fp);
		}
		printf("ready");
		getchar();
		*/
		doublereal radd = 0.0;
		/*
		if (ilevel == 0) {
			radd = 1.8;
		}
		else if (ilevel == 1) {
			radd = 4.2;
		}
		else if ((ilevel >= 2) && (ilevel <= 5)) {
			radd = 6.5;
		}
		else if (ilevel == 6) {
			radd = 7.0;
		}
		else {
			radd = 8.0;
		}
		*/

		// ILU0 не требует памяти больше чем размер исходных матриц. 
		// Новых ненулевых элементов для него не появляется.
		milu0.iwk = milu0.row_ptr[maxelm_plus_maxbound];
		milu0.alu = new doublereal[milu0.row_ptr[maxelm_plus_maxbound]  + 2];
		milu0.jlu = new integer[milu0.row_ptr[maxelm_plus_maxbound]  + 2];

		milu0.ju = new integer[maxelm_plus_maxbound + 2];

		
		milu0.iw = new integer[maxelm_plus_maxbound + 2]; // +2 запас по памяти.
		
		if ((milu0.alu == nullptr) || (milu0.jlu == nullptr) || (milu0.ju == nullptr) || (milu0.iw == nullptr)) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for ILU0 decomposition: alu, jlu, ju, iw...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}

		// копии объектов

		// ILU0 не требует памяти больше чем размер исходных матриц. 
		// Новых ненулевых элементов для него не появляется.
		milu0.alu_copy = new doublereal[milu0.row_ptr[maxelm_plus_maxbound] + 2];
		milu0.jlu_copy = new integer[milu0.row_ptr[maxelm_plus_maxbound] + 2];

		milu0.ju_copy = new integer[maxelm_plus_maxbound + 2];

		milu0.b_copy = new doublereal[maxelm_plus_maxbound + 2];
		milu0.x_copy = new doublereal[maxelm_plus_maxbound + 2];
		milu0.zbuf = new doublereal[maxelm_plus_maxbound + 2];
		milu0.zbuf2 = new doublereal[maxelm_plus_maxbound + 2];

		if ((milu0.alu_copy == nullptr) || (milu0.jlu_copy == nullptr) || (milu0.ju_copy == nullptr) || (milu0.b_copy == nullptr) || (milu0.x_copy == nullptr) || (milu0.zbuf == nullptr) || (milu0.zbuf2 == nullptr)) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for ILU0 decomposition: alu_copy, jlu_copy, ju_copy etc...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}

		// Построение ILU0 декомпозиции.
		integer ierr = 0;
	    ilu0_(maxelm_plus_maxbound, milu0.val, milu0.col_ind, milu0.row_ptr, milu0.alu, milu0.jlu, milu0.ju, milu0.iw, ierr);
		if (ierr != 0) {
#if doubleintprecision == 1
			printf("ierr=%lld\n", ierr);
#else
			printf("ierr=%d\n", ierr);
#endif
			
			//getchar();
			system("PAUSE");
			exit(1);
		}

		if ((ierr == -2) || (ierr == -3)) {

			integer ipassage = 1;
			do {
				printf("\nPlease WAIT... ... ...\n");

				// задаче не хватило памяти, значит нужно перевыделить !
				if (milu0.alu != nullptr) delete milu0.alu;
				if (milu0.jlu != nullptr) delete milu0.jlu;
				if (milu0.alu_copy != nullptr) delete milu0.alu_copy;
				if (milu0.jlu_copy != nullptr) delete milu0.jlu_copy;

				// инициализация !
				milu0.alu = nullptr;
				milu0.jlu = nullptr;
				milu0.alu_copy = nullptr;
				milu0.jlu_copy = nullptr;

				// При использовании ILU0 новой памяти не требуется должно хватать размера исходной матрицы.
			    integer iwk = milu0.row_ptr[maxelm_plus_maxbound] + 2; // ИЗМЕНИТЬ ЭТУ СТРОКУ для увеличения памяти.
				milu0.iwk = iwk - 2;
				milu0.alu = new doublereal[iwk + 2]; // +2 запас по памяти.
				milu0.jlu = new integer[iwk + 2];
				milu0.alu_copy = new doublereal[iwk + 2]; // +2 запас по памяти.
				milu0.jlu_copy = new integer[iwk + 2];

				if ((milu0.alu_copy != nullptr) && (milu0.jlu_copy != nullptr) && (milu0.alu != nullptr) && (milu0.jlu != nullptr)) {
					ilu0_(maxelm_plus_maxbound, milu0.val, milu0.col_ind, milu0.row_ptr, milu0.alu, milu0.jlu, milu0.ju, milu0.iw, ierr);
				}
				else {
					// недостаточно памяти на данном оборудовании.
					ipassage = 4;
					printf("Problem: not enough memory on your equipment...\n");
					printf("Please any key to exit...\n");
					exit(1);
				}

				ipassage++;
				// Пока просто контролируем, в добавок хорошо бы выводить информацию на каком уровне это произошло.
#if doubleintprecision == 1
				printf("control memory allocation for ilu0 in RUMBA0.14 in level=%lld\n", ilevel);
#else
				printf("control memory allocation for ilu0 in RUMBA0.14 in level=%d\n", ilevel);
#endif
				
				system("PAUSE");
			} while ((ierr != 0) && (ipassage<4));

			if (ipassage == 4) {
				printf("Error memory alloc !!!\n");
				printf("failed to obtain an expansion for the 4 approaches...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("PAUSE");
				exit(1);
			}
		}

		// По идее здесь уже можно освободить ОЗУ от milu0.val, milu0.col_ind, milu0.row_ptr.
		// 7 ноября 2016.

	}

	if (!flag) {
		printf("Error equation 3D to CRS: zero diagonal element...\n");
		//getchar();
		system("pause");
	}

	for (integer k = 0; k<n; k++) if (milu0.col_ind[k] == (-1)) {
		printf("Error equation3D to CRS.\n");
		//getchar();
		system("pause");
	}

	// Нумерация начинается с единицы (это важно).
	for (integer k = 0; k<maxelm_plus_maxbound; k++) {
		if (milu0.val[milu0.row_ptr[k] - 1]<nonzeroEPS) {
#if doubleintprecision == 1
			printf("negativ diagonal element equation3DtoCRS %lld\n", k);
#else
			printf("negativ diagonal element equation3DtoCRS %d\n", k);
#endif
			
			//getchar();
			system("pause");
		}
	}


} // equation3DtoCRSRUMBA0


// Выделение оперативной памяти.
void init_level_additional_data(LEVEL_ADDITIONAL_DATA* &milu2_loc, integer max_levels) {
	if (milu2_loc == nullptr) {
		milu2_loc = new LEVEL_ADDITIONAL_DATA[max_levels];
		if (milu2_loc == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}
		// Инициализация. 
		// Конкретное выделение оперативной памяти происходит внутри 
		// equation3DtoCRSRUMBA1.
#pragma omp parallel for
		for (integer i = 0; i < max_levels; i++) {
			milu2_loc[i].val = nullptr;
			milu2_loc[i].col_ind = nullptr;
			milu2_loc[i].row_ptr = nullptr;
			// для хранения ilu2 декомпозиции.
			milu2_loc[i].alu = nullptr;
			milu2_loc[i].jlu = nullptr;
			milu2_loc[i].ju = nullptr;
			milu2_loc[i].levs = nullptr;
			milu2_loc[i].w = nullptr;
			milu2_loc[i].jw = nullptr;
			milu2_loc[i].iwk = 0;
			//milu2_loc[i].alu_copy = nullptr;
			//milu2_loc[i].jlu_copy = nullptr;
			//milu2_loc[i].ju_copy = nullptr;
			milu2_loc[i].b_copy = nullptr;
			milu2_loc[i].x_copy = nullptr;
			milu2_loc[i].zbuf = nullptr;
			milu2_loc[i].zbuf2 = nullptr;
		}
	}
} // init_level_additional_data

// Освобождение оперативной памяти.
void free_level_additional_data(LEVEL_ADDITIONAL_DATA* &milu2_loc, integer max_levels) {
	if (milu2_loc != nullptr) {
#pragma omp parallel for
		for (integer i = 0; i < max_levels; i++) {
			if (milu2_loc[i].val != nullptr) {
				//delete[] milu2_loc[i].val;
				free(milu2_loc[i].val);
				milu2_loc[i].val = nullptr;
			}
			if (milu2_loc[i].col_ind != nullptr) {
				///delete[] milu2_loc[i].col_ind;
				free(milu2_loc[i].col_ind);
				milu2_loc[i].col_ind = nullptr;
			}
			if (milu2_loc[i].row_ptr != nullptr) {
				//delete[] milu2_loc[i].row_ptr;
				free(milu2_loc[i].row_ptr);
				milu2_loc[i].row_ptr = nullptr;
			}
			// Освобождение оперативной памяти из под хранения ilu2 декомпозиции.
			if (milu2_loc[i].alu != nullptr) {
				//delete[] milu2_loc[i].alu;
				free(milu2_loc[i].alu);
				milu2_loc[i].alu = nullptr;
			}
			if (milu2_loc[i].jlu != nullptr) {
				//delete[] milu2_loc[i].jlu;
				free(milu2_loc[i].jlu);
				milu2_loc[i].jlu = nullptr;
			}
			if (milu2_loc[i].ju != nullptr) {
				//delete[] milu2_loc[i].ju;
				free(milu2_loc[i].ju);
				milu2_loc[i].ju = nullptr;
			}
			if (milu2_loc[i].levs != nullptr) {
				//delete[] milu2_loc[i].levs;
				free(milu2_loc[i].levs);
				milu2_loc[i].levs = nullptr;
			}
			if (milu2_loc[i].w != nullptr) {
				//delete[] milu2_loc[i].w;
				free(milu2_loc[i].w);
				milu2_loc[i].w = nullptr;
			}
			if (milu2_loc[i].jw != nullptr) {
				//delete[] milu2_loc[i].jw;
				free(milu2_loc[i].jw);
				milu2_loc[i].jw = nullptr;
			}
			milu2_loc[i].iwk = 0;
			// Освобождение памяти из под копий объектов:
	        // 9 ноября 2016 память под alu_copy, jlu_copy, ju_copy 
			// теперь выделяется централизованно в буфере.
			//if (milu2_loc[i].alu_copy != nullptr) {
				//delete[] milu2_loc[i].alu_copy;
				//milu2_loc[i].alu_copy = nullptr;
			//}
			//if (milu2_loc[i].jlu_copy != nullptr) {
				//delete[] milu2_loc[i].jlu_copy;
				//milu2_loc[i].jlu_copy = nullptr;
			//}
			//if (milu2_loc[i].ju_copy != nullptr) {
				//delete[] milu2_loc[i].ju_copy;
				//milu2_loc[i].ju_copy = nullptr;
			//}
			if (milu2_loc[i].b_copy != nullptr) {
				//delete[] milu2_loc[i].b_copy;
				free(milu2_loc[i].b_copy);
				milu2_loc[i].b_copy = nullptr;
			}
			if (milu2_loc[i].x_copy != nullptr) {
				//delete[] milu2_loc[i].x_copy;
				free(milu2_loc[i].x_copy);
				milu2_loc[i].x_copy = nullptr;
			}
			if (milu2_loc[i].zbuf != nullptr) {
				//delete[] milu2_loc[i].zbuf;
				free(milu2_loc[i].zbuf);
				milu2_loc[i].zbuf = nullptr;
			}
			if (milu2_loc[i].zbuf2 != nullptr) {
				//delete[] milu2_loc[i].zbuf2;
				free(milu2_loc[i].zbuf2);
				milu2_loc[i].zbuf2 = nullptr;
			}
		}
		delete[] milu2_loc;
		milu2_loc = nullptr;
	}
} // free_level_additional_data

// ILU0 4 ноября 2016.
// Выделение оперативной памяти.
void init_level_additional_data(LEVEL_ADDITIONAL_DATA0* &milu0, integer max_levels) {
	if (milu0 == nullptr) {
		milu0 = new LEVEL_ADDITIONAL_DATA0[max_levels];
		if (milu0 == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for ILU0...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}
		// Инициализация. 
		// Конкретное выделение оперативной памяти происходит внутри 
		// equation3DtoCRSRUMBA1.
#pragma omp parallel for
		for (integer i = 0; i < max_levels; i++) {
			milu0[i].val = nullptr;
			milu0[i].col_ind = nullptr;
			milu0[i].row_ptr = nullptr;
			// для хранения ilu0 декомпозиции.
			milu0[i].alu = nullptr;
			milu0[i].jlu = nullptr;
			milu0[i].ju = nullptr;
			milu0[i].iw = nullptr;
			milu0[i].iwk = 0;
			
			milu0[i].alu_copy = nullptr;
			milu0[i].jlu_copy = nullptr;
			milu0[i].ju_copy = nullptr;
			milu0[i].b_copy = nullptr;
			milu0[i].x_copy = nullptr;
			milu0[i].zbuf = nullptr;
			milu0[i].zbuf2 = nullptr;
		}
	}
} // init_level_additional_data ILU0

// ILU0 4 november 2016.
  // Освобождение оперативной памяти.
void free_level_additional_data(LEVEL_ADDITIONAL_DATA0* &milu0, integer max_levels) {
	if (milu0 != nullptr) {

#pragma omp parallel for
		for (integer i = 0; i < max_levels; i++) {
			if (milu0[i].val != nullptr) {
				delete[] milu0[i].val;
				milu0[i].val = nullptr;
			}
			if (milu0[i].col_ind != nullptr) {
				delete[] milu0[i].col_ind;
				milu0[i].col_ind = nullptr;
			}
			if (milu0[i].row_ptr != nullptr) {
				delete[] milu0[i].row_ptr;
				milu0[i].row_ptr = nullptr;
			}
			// Освобождение оперативной памяти из под хранения ilu2 декомпозиции.
			if (milu0[i].alu != nullptr) {
				delete[] milu0[i].alu;
				milu0[i].alu = nullptr;
			}
			if (milu0[i].jlu != nullptr) {
				delete[] milu0[i].jlu;
				milu0[i].jlu = nullptr;
			}
			if (milu0[i].ju != nullptr) {
				delete[] milu0[i].ju;
				milu0[i].ju = nullptr;
			}
			
			if (milu0[i].iw != nullptr) {
				delete[] milu0[i].iw;
				milu0[i].iw = nullptr;
			}

			milu0[i].iwk = 0;
			// Освобождение памяти из под копий объектов:
			if (milu0[i].alu_copy != nullptr) {
				delete[] milu0[i].alu_copy;
				milu0[i].alu_copy = nullptr;
			}
			if (milu0[i].jlu_copy != nullptr) {
				delete[] milu0[i].jlu_copy;
				milu0[i].jlu_copy = nullptr;
			}
			if (milu0[i].ju_copy != nullptr) {
				delete[] milu0[i].ju_copy;
				milu0[i].ju_copy = nullptr;
			}
			if (milu0[i].b_copy != nullptr) {
				delete[] milu0[i].b_copy;
				milu0[i].b_copy = nullptr;
			}
			if (milu0[i].x_copy != nullptr) {
				delete[] milu0[i].x_copy;
				milu0[i].x_copy = nullptr;
			}
			if (milu0[i].zbuf != nullptr) {
				delete[] milu0[i].zbuf;
				milu0[i].zbuf = nullptr;
			}
			if (milu0[i].zbuf2 != nullptr) {
				delete[] milu0[i].zbuf2;
				milu0[i].zbuf2 = nullptr;
			}
		}
		delete[] milu0;
		milu0 = nullptr;
	}
} // free_level_additional_data ILU0


static bool bfirst_now_speed = true;

static integer iglnumberSimpleit = 0;

// 3 ноября 2016.
// Вызывается единожды лишь в случае нехватки выделеной памяти под оператор 
// интерполяции.
// Это происходит очень редко - на узком классе задач.
// Здесь происходит перевыделение оперативной памяти и увеличение значения nsizePR.
void deallocate_prolongation(integer &nsizePR, // Память под P в количествах n.
	integer n, // Количество неизвестных в СЛАУ на нулевом уровне.
	Ak1* &R, // restriction
	Ak1* &P // prolongation
)
{

	// Синтакис вызова:
	//deallocate_prolongation(nsizePR,n,R,P);

	// Для большинства реальных задач нам достаточно объёма памяти в nsizePR==12.
	// Однако встречаются задачи для котрыхнужно существенно большее количество памяти.
	// В этом случае я предлагаю увеличить её количество до nsizePR==35.
	if (nsizePR < 100) {

		Ak1* R_copy = nullptr; // restriction
		Ak1* P_copy = nullptr; // prolongation

		// Увеличиваем количество памяти до nsizePR==35.
		//Ak1* &R_copy = new Ak1[nsizePR*n + 1];
		//Ak1* &P_copy = new Ak1[nsizePR*n + 1];
		//R = new Ak1[(integer)(35 * n) + 1]; // 3*nnz 2.4 // 35
		R_copy = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
		if (R_copy == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for R_copy matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		//P = new Ak1[(integer)(35 * n) + 1]; // 3*nnz 2.4 // 35
		P_copy = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
		if (P_copy == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for P_copy matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}

		if ((R_copy != nullptr) && (P_copy != nullptr)) {
			for (integer i = 0; i <= (nsizePR * n); i++) {
				R_copy[i] = R[i];
				P_copy[i] = P[i];
			}
			if (R != nullptr) {
				free(R);
			}
			if (P != nullptr) {
				free(P);
			}
			R = nullptr;
			P = nullptr;
			integer nsizePR_old = nsizePR;
			// Было значение 35 до 26,06,2021.
			nsizePR = 1450; // Этого должно хватить с запасом.

			R = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
			if (R == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for R matrix in my_agregat_amg.cpp algorithm...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}
			//P = new Ak1[(integer)(35 * n) + 1]; // 3*nnz 2.4 // 35
			P = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
			if (P == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for P matrix in my_agregat_amg.cpp algorithm...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}

			if ((P != nullptr) && (R != nullptr)) {
				for (integer i = 0; i <= (nsizePR_old * n); i++) {
					R[i] = R_copy[i];
					P[i] = P_copy[i];
				}
			}

			// Обязательно освобождаем оперативную память.
			if (R_copy != nullptr) {
				free(R_copy);
				R_copy = nullptr;
			}
			if (P_copy != nullptr) {
				free(P_copy);
				P_copy = nullptr;
			}
		}
	}
	else {
#if doubleintprecision == 1
		printf("FATALL error!!! nsizePR=%lld\n", nsizePR);
#else
		printf("FATALL error!!! nsizePR=%d\n", nsizePR);
#endif
		
		printf("not enough memory for the interpolation operator.");
		printf("absolute fatal. see deallocate_prolongation in my_agregat_amg.cpp\n");
		system("PAUSE");
		exit(1);
	}

} // deallocate_prolongation



// 3 ноября 2016.
// Вызывается единожды лишь в случае нехватки выделеной памяти под оператор 
// интерполяции.
// Это происходит очень редко - на узком классе задач.
// Здесь происходит перевыделение оперативной памяти и увеличение значения nsizePR.
void deallocate_prolongation(integer &nsizePR, // Память под P в количествах n.
	integer n, // Количество неизвестных в СЛАУ на нулевом уровне.
	Ak1* &R, // restriction
	Ak1* &P, // prolongation
	bool* &bamg_bound
)
{

	// Синтакис вызова:
	//deallocate_prolongation(nsizePR,n,R,P);

	// Для большинства реальных задач нам достаточно объёма памяти в nsizePR==12.
	// Однако встречаются задачи для котрыхнужно существенно большее количество памяти.
	// В этом случае я предлагаю увеличить её количество до nsizePR==35.
	if (nsizePR < 130) {

		Ak1* R_copy = nullptr; // restriction
		Ak1* P_copy = nullptr; // prolongation
		bool* bamg_bound_copy = nullptr; // для граничных условий Дирихле.

							// Увеличиваем количество памяти до nsizePR==35.
							//Ak1* &R_copy = new Ak1[nsizePR*n + 1];
							//Ak1* &P_copy = new Ak1[nsizePR*n + 1];
							//R = new Ak1[(integer)(35 * n) + 1]; // 3*nnz 2.4 // 35
		R_copy = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
		if (R_copy == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for R_copy matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		//P = new Ak1[(integer)(35 * n) + 1]; // 3*nnz 2.4 // 35
		P_copy = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
		if (P_copy == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for P_copy matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		//bamg_bound_copy = (bool*)malloc(((nsizePR * n) + 1) * sizeof(bool));
		bamg_bound_copy = new bool[(nsizePR * n) + 1];
		if (bamg_bound_copy == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for bamg_bound_copy matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}

		if ((R_copy != nullptr) && (P_copy != nullptr)&&(bamg_bound_copy != nullptr)) {
			for (integer i = 0; i <= (nsizePR * n); i++) {
				R_copy[i] = R[i];
				P_copy[i] = P[i];
				bamg_bound_copy[i] = bamg_bound[i];
			}
			if (R != nullptr) {
				free(R);
			}
			if (P != nullptr) {
				free(P);
			}
			if (bamg_bound != nullptr) {
				//free(bamg_bound);
				delete[] bamg_bound;
			}
			R = nullptr;
			P = nullptr;
			bamg_bound = nullptr;
			integer nsizePR_old = nsizePR;
			// Было значение 35 до 26,06,2021.
			nsizePR = 1450; // Этого должно хватить с запасом.

			R = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
			if (R == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for R matrix in my_agregat_amg.cpp algorithm...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}
			//P = new Ak1[(integer)(35 * n) + 1]; // 3*nnz 2.4 // 35
			P = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
			if (P == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for P matrix in my_agregat_amg.cpp algorithm...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}
			bamg_bound = new bool[(nsizePR * n) + 1];
			if (bamg_bound == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for bamg_bound matrix in my_agregat_amg.cpp algorithm...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}

			if ((P != nullptr) && (R != nullptr)&&(bamg_bound!= nullptr)) {
				for (integer i = 0; i <= (nsizePR_old * n); i++) {
					R[i] = R_copy[i];
					P[i] = P_copy[i];
					bamg_bound[i] = bamg_bound_copy[i];
				}
				for (integer i = (nsizePR_old * n) + 1; i <= (nsizePR * n); i++) {
					bamg_bound[i] = false;
				}
			}

			// Обязательно освобождаем оперативную память.
			if (R_copy != nullptr) {
				free(R_copy);
				R_copy = nullptr;
			}
			if (P_copy != nullptr) {
				free(P_copy);
				P_copy = nullptr;
			}
			if (bamg_bound_copy != nullptr) {
				//free(bamg_bound_copy);
				delete[] bamg_bound_copy;
				bamg_bound_copy = nullptr;
			}
		}
	}
	else {
#if doubleintprecision == 1
		printf("FATALL error!!! nsizePR=%lld\n", nsizePR);
#else
		printf("FATALL error!!! nsizePR=%d\n", nsizePR);
#endif
		
		printf("not enough memory for the interpolation operator.");
		printf("absolute fatal. see deallocate_prolongation in my_agregat_amg.cpp\n");
		system("PAUSE");
		exit(1);
	}

}

// 08.01.2018 Перенесено в отдельную функцию, т.к. используется неоднократно. Передаётся большое число параметров.
//  A*z76=s76; 891 строка.
template <typename doublerealT>
void V_cycle_solve(Ak1* &Amat, doublereal* &z76, doublereal* &s76, bool process_flow_logic, integer* &row_ptr_start, 
	integer* &row_ptr_end, doublerealT** &residual_fine, doublerealT** &diag, integer* n_a, bool bonly_serial, 
	doublerealT process_flow_beta, bool* &F_false_C_true, integer &nu1, integer &nu2, integer bILU2smoother, 
	integer ilevel, integer inumberVcyclelocbicgstab, INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14 imyinit, const integer idim_diag, 
	LEVEL_ADDITIONAL_DATA* &milu2, LEVEL_ADDITIONAL_DATA0* milu0, bool** &nested_desection,
	Ak1* &R, // restriction
	Ak1* &P, // prolongation
	integer* nnz_aRP, bool* &flag, doublerealT** &residual_coarse, integer igam, integer* nnz_a,
	doublerealT** &error_approx_coarse, doublerealT dapply_ilu_max_pattern_size,
	doublerealT process_flow_alpha, doublerealT** &error_approx_fine, 
	integer nFinestSweeps) {
	
	// Один V - цикл алгебраического многосеточного метода.
	// A*z76=s76;

	

	for (integer i_13 = 0; i_13<inumberVcyclelocbicgstab; i_13++)
	{


		doublerealT R0_0 = 0.0;
		doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
			residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
			R0_0 = norma(residual_fine[0], n_a[0]);
			Rprev_0 = R0_0;

			// smother
			integer iter = 0;
			for (iter = 0; iter < nu1; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, nested_desection[0], row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
				}
				//residualq(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
				residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
				Rnext_0 = norma(residual_fine[0], n_a[0]);
				// this is process flow logic
				if (Rnext_0 > process_flow_beta*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nu1) {
				printf("level 0 limit presmother iteration is reached\n");
			}

		}
		else {
			// smoother
			for (integer iter = 0; iter < nu1; iter++) {
				//seidel(Amat, 1, nnz_a[0], z76, s76, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					if (bILU2smoother == 1) {
						// ILU0
						seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
						residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu0[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu0[0].zbuf, milu0[0].zbuf2, milu0[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							z76[i43 + 1] += milu0[0].zbuf2[i43 + 1];
						}
					}
					else if ((bILU2smoother == 2) || (my_amg_manager.iFinnest_ilu == 1)) {
						seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
						residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu2[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu2[0].zbuf, milu2[0].zbuf2, milu2[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							z76[i43 + 1] += milu2[0].zbuf2[i43 + 1];
						}
					}
					else {
						seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
					}
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, nested_desection[0], row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
				}
			}
		}

		//exporttecplot(x, n);

		move_down(nu1, nu2);

		if (!process_flow_logic) {
			// residual_r
			//doublerealT *residual_fine[0] = new doublerealT[n_a[0] + 1];
			//residual<doublereal>(Amat, 1, nnz_a[0], z76, s76, flag, n_a[0], residual_fine[0]);
			//residualq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
			residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
		}



		//if (iprohod%5==0) getchar();
		if (ilevel > 1) {

			//doublerealT *residual_coarse = new doublerealT[n_a[1] + 1];
#pragma omp parallel for
			for (integer ii = 1; ii <= n_a[1]; ii++) {
				residual_coarse[0][ii] = 0.0;
			}

			// restriction
			restriction(R, 1, nnz_aRP[0], flag, residual_fine[0], residual_coarse[0], n_a[0], n_a[1]);


			// Amat*e=r;
			//doublerealT* error_approx_coarse = new doublerealT[n_a[1] + 1];
			if ((imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)) {
#pragma omp parallel for
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[0][ii] = 0.0;
				}
			}

			if ((imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)) {
				// (1,110); (0.8, 37); (0.7, 29); (0.6, 25); (0.5, 20); (0.4, 17); (0.3, 18); (0.0, 19);
#pragma omp parallel for
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[0][ii] = (doublerealT)(0.4*fabs(residual_coarse[0][ii])*(1.0*rand() / ((doublerealT)(1.0*RAND_MAX))));
				}
			}


			for (integer i_37 = 1; i_37 <= igam; i_37++) {
				doublerealT R0_1 = 0.0;
				doublerealT Rprev_1 = 0.0, Rnext_1 = 0.0;
				if (process_flow_logic) {
					// calculate initial residual.
					//residualq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1]);
					residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);

					R0_1 = norma(residual_fine[1], n_a[1]);
					Rprev_1 = R0_1;

					// smother
					integer iter = 0;
					for (iter = 0; iter < nu1; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 0);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], nested_desection[1], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 0);
						}

						//residualq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1]);
						residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);

						Rnext_1 = norma(residual_fine[1], n_a[1]);
						// this is process flow logic
						if (Rnext_1 > process_flow_beta*Rprev_1) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_1 = Rnext_1;
						}
					}

					if (iter == nu1) {
						printf("level 1 limit presmother iteration is reached\n");
					}

				}
				else {

					// pre smothing
					for (integer iter = 0; iter < nu1; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
						if (bonly_serial) {
							if (bILU2smoother == 1) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 0);
								residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu0[1].zbuf[i43 + 1] = residual_fine[1][i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu0[1].zbuf, milu0[1].zbuf2, milu0[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[0][i43 + 1] += (doublerealT)(milu0[1].zbuf2[i43 + 1]);
								}


							}
							else if (1 && bILU2smoother == 2) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 0);
								residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu2[1].zbuf[i43 + 1] = residual_fine[1][i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu2[1].zbuf, milu2[1].zbuf2, milu2[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[0][i43 + 1] += (doublerealT)(milu2[1].zbuf2[i43 + 1]);
								}


							}
							else {
								seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 0);
							}
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], nested_desection[1], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 0);
						}
					}
				}





				doublerealT* R0_21 = new doublerealT[idim_diag];
				doublerealT* Rprev_21 = new doublerealT[idim_diag];
				doublerealT* Rnext_21 = new doublerealT[idim_diag];

				//3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
				for (integer i_id_level_local = 2; i_id_level_local < idim_diag; i_id_level_local++) {

					move_down(nu1, nu2);


					if (ilevel > i_id_level_local) {
						// Впервые создан универсальный програмный код на произвольное количество уровней вложенности 
						// в solution phase.
						// Нужно только написать универсальный обработчик для R0_21.
						// 4 декабря 2016. 

						// residual
						if (!process_flow_logic) {
							integer in_a_loc = 0;
							for (integer i_72 = 0; i_72 < i_id_level_local - 1; i_72++) {
								// sum(n_a[0]+n_a[19];
								in_a_loc += n_a[i_72];
							}
							//doublerealT *residual_fine[i_id_level_local-1] = new doublerealT[n_a[i_id_level_local-1] + 1];
							//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15]+ nnz_a[16]+nnz_a[17]+nnz_a[18]+nnz_a[19], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15]+ nnz_a[16]+ nnz_a[17]+nnz_a[18]+nnz_a[19]+nnz_a[20], error_approx_coarse[i_id_level_local - 2], residual_coarse[i_id_level_local - 2], flag, n_a[i_id_level_local - 1], residual_fine[i_id_level_local - 1]);
							//residualq(Amat, 1, n_a[i_id_level_local-1], error_approx_coarse[i_id_level_local - 2], residual_coarse[i_id_level_local - 2], row_ptr_start, row_ptr_end,  in_a_loc , residual_fine[i_id_level_local - 1]);
							//residualq2(Amat, 1, n_a[i_id_level_local-1], error_approx_coarse[i_id_level_local - 2], residual_coarse[i_id_level_local - 2], row_ptr_start, row_ptr_end, in_a_loc, residual_fine[i_id_level_local - 1], diag[i_id_level_local - 1]);
							residualq2(Amat, 1, n_a[i_id_level_local - 1], error_approx_coarse[i_id_level_local - 2], residual_coarse[i_id_level_local - 2], row_ptr_start, row_ptr_end, in_a_loc, residual_fine[i_id_level_local - 1], diag[i_id_level_local - 1]);

						}

						//doublerealT *residual_coarse[i_id_level_local-1] = new doublerealT[n_a[i_id_level_local] + 1];

						// restriction

						integer innz_aRP_loc = 1;
						for (integer i_72 = 0; i_72 < i_id_level_local - 1; i_72++) {
							innz_aRP_loc += nnz_aRP[i_72];
						}
						//restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17] + nnz_aRP[18] + nnz_aRP[19], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17] + nnz_aRP[18] + nnz_aRP[19] + nnz_aRP[20], flag, residual_fine[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], n_a[i_id_level_local - 1], n_a[i_id_level_local]);
						restriction(R, innz_aRP_loc, innz_aRP_loc - 1 + nnz_aRP[i_id_level_local - 1], flag, residual_fine[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], n_a[i_id_level_local - 1], n_a[i_id_level_local]);



						// Amat*e=r;
						//doublerealT* error_approx_coarse[i_id_level_local-1] = new doublerealT[n_a[i_id_level_local] + 1];

						if (0) {
							//if (icount_V_cycle == 1) {
							//	for (integer ii = 1; ii <= n_a[i_id_level_local]; ii++) {
							// обнуление только на первом проходе.
							//		error_approx_coarse[i_id_level_local - 1][ii] = 0.0;
							//error_approx_coarse[i_id_level_local - 1][ii] = (rand() / ((doublerealT)RAND_MAX));
							//	}
							//}
							// На задаче BSK_Dmitrii random оптимизация оказалась гораздо хуже, но сходимость тоже присутствовала.
#pragma omp parallel for
							for (integer ii = 1; ii <= n_a[i_id_level_local]; ii++) {
								// 0.4*fabs(residual_coarse[i_id_level_local - 1][ii]) - амплитуда.
								// 0.4 - демпфирующий множитель.
								// diag[i_id_level_local]
								// (1,110); (0.8, 37); (0.7, 29); (0.6, 25); (0.5, 20); (0.4, 17); (0.3, 18); (0.0, 19);
								error_approx_coarse[i_id_level_local - 1][ii] = (doublerealT)(0.4*fabs(residual_coarse[i_id_level_local - 1][ii])*(1.0*rand() / ((doublerealT)(1.0*RAND_MAX))));
							}
						}
						else {
							if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT) {
#pragma omp parallel for
								for (integer ii = 1; ii <= n_a[i_id_level_local]; ii++) {
									error_approx_coarse[i_id_level_local - 1][ii] = 0.0;
								}
							}
							if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT) {
#pragma omp parallel for
								for (integer ii = 1; ii <= n_a[i_id_level_local]; ii++) {
									// (1,110); (0.8, 37); (0.7, 29); (0.6, 25); (0.5, 20); (0.4, 17); (0.3, 18); (0.0, 19);
									error_approx_coarse[i_id_level_local - 1][ii] = (doublerealT)(0.4*fabs(residual_coarse[i_id_level_local - 1][ii])*(1.0*rand() / ((doublerealT)(1.0*RAND_MAX))));
								}
							}
						}


						//for (integer i_37 = 1; i_37 <= igam; i_37++)
						{
							// pre smothing
							//doublerealT R0_21 = 0.0;
							//doublerealT Rprev_21 = 0.0, Rnext_21 = 0.0;
							R0_21[i_id_level_local] = 0.0;
							Rprev_21[i_id_level_local] = 0.0;
							Rnext_21[i_id_level_local] = 0.0;
							if (process_flow_logic) {

								integer in_a_loc = 0;
								for (integer i_72 = 0; i_72 < i_id_level_local - 1; i_72++) {
									// sum(n_a[0]+n_a[19];
									in_a_loc += n_a[i_72];
								}

								// calculate initial residual.
								//residualq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local-1], residual_coarse[i_id_level_local-1], row_ptr_start, row_ptr_end,in_a_loc + n_a[i_id_level_local-1] , residual_fine[i_id_level_local]);
								residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);



								R0_21[i_id_level_local] = norma(residual_fine[i_id_level_local], n_a[i_id_level_local]);
								Rprev_21[i_id_level_local] = R0_21[i_id_level_local];



								// smother
								integer iter = 0;
								integer nu1_count = nu1;
								if (i_id_level_local == ilevel - 1) {
									// на самом грубом уровне нам требуется точное решение.
									//nu1_count = 100;

									printf("Direct method is start.../n");

									IMatrix sparseS; // разреженная матрица в формате IMatrix
									initIMatrix(&sparseS, n_a[i_id_level_local]);

									integer istartpos = 1 + in_a_loc + n_a[i_id_level_local - 1];
									integer iendpos = n_a[i_id_level_local] + in_a_loc + n_a[i_id_level_local - 1];

									for (integer i56 = istartpos; i56 <= iendpos; i56++) {

										//setValueIMatrix(&sparseS, Amat[row_ptr_start[i56]].i - 1, Amat[row_ptr_start[i56]].i - 1, 1.0 / Amat[row_ptr_start[i56]].aij);
										setValueIMatrix(&sparseS, i56 - istartpos, i56 - istartpos, 1.0 / Amat[row_ptr_start[i56]].aij);//3.02.2019
										//if (Amat[row_ptr_start[i56]].i != i56 - istartpos + 1) {
											//printf("Amat[row_ptr_start[i56]].i=%lld i56 - istartpos + 1=%lld\n", Amat[row_ptr_start[i56]].i,i56 - istartpos + 1);
											//getchar();
										//}
										const doublerealT nonzeroEPS = 1e-37; // для отделения вещественного нуля

										integer is15 = row_ptr_start[i56] + 1;
										integer is25 = row_ptr_end[i56];

										for (integer ii17 = is15; ii17 <= is25; ii17++)
										{

											if ((fabs(Amat[ii17].aij) > nonzeroEPS)) {
												//setValueIMatrix(&sparseS, Amat[ii17].i - 1, Amat[ii17].j - 1, Amat[ii17].aij);
												setValueIMatrix(&sparseS, ii17- is15, Amat[ii17].j - 1, Amat[ii17].aij);
											}

										}
									}

									doublereal* dX025 = new doublereal[n_a[i_id_level_local]];
									doublereal* dV25 = new doublereal[n_a[i_id_level_local]];
#pragma omp parallel for
									for (integer i57 = 0; i57 < n_a[i_id_level_local]; i57++) {
										dX025[i57] = error_approx_coarse[i_id_level_local - 1][i57 + 1];
										dV25[i57] = residual_coarse[i_id_level_local - 1][i57 + 1];
									}

									// главный метод, возвращающий решение x,
									// принимает вектор свободных членов b и 
									// квадратную матрицу xO в специальном разреженном формате.
									// реализация без барьера и итерационного уточнения.
									calculateSPARSEgaussArray(&sparseS, dX025, dV25);
#pragma omp parallel for
									for (integer i57 = 0; i57 < n_a[i_id_level_local]; i57++) {
										error_approx_coarse[i_id_level_local - 1][i57 + 1] = (doublerealT)(dX025[i57]);
									}

									delete[] dX025;
									delete[] dV25;


									freeIMatrix(&sparseS);

									//residualq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local-1], residual_coarse[i_id_level_local-1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local]);
									residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);


									Rnext_21[i_id_level_local] = norma(residual_fine[i_id_level_local], n_a[i_id_level_local]);
									// this is process flow logic
									if (Rnext_21[i_id_level_local] > process_flow_beta*Rprev_21[i_id_level_local]) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_21[i_id_level_local] = Rnext_21[i_id_level_local];
									}
								}
								else {
									for (iter = 0; iter < nu1_count; iter++) {
										//quick seidel
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 0);
										}
										else {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], nested_desection[i_id_level_local], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 0);
										}

										//residualq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local-1], residual_coarse[i_id_level_local-1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local]);
										residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);


										Rnext_21[i_id_level_local] = norma(residual_fine[i_id_level_local], n_a[i_id_level_local]);
										// this is process flow logic
										if (Rnext_21[i_id_level_local] > process_flow_beta*Rprev_21[i_id_level_local]) {
											// Смысл модификации в том что мы экономим итерации на пресмутере.
											break; // досрочно опускаемся на следующий уровень если он есть конечно.
										}
										else {
											Rprev_21[i_id_level_local] = Rnext_21[i_id_level_local];
										}
									}
								}

								if (iter == nu1) {
#if doubleintprecision == 1
									printf("level %lld limit presmother iteration is reached\n", i_id_level_local);
#else
									printf("level %d limit presmother iteration is reached\n", i_id_level_local);
#endif

								}

							}
							else {
								integer nu1_count = nu1;
								if (i_id_level_local == ilevel - 1) {
									// на самом грубом уровне нам требуется точное решение.
									//nu1_count = 100;
								}
								for (integer iter = 0; iter < nu1_count; iter++) {

									integer in_a_loc = 0;
									for (integer i_72 = 0; i_72 < i_id_level_local - 1; i_72++) {
										// sum(n_a[0]+n_a[19];
										in_a_loc += n_a[i_72];
									}

									if (bonly_serial) {

										bool bflag56 = false;
										if (my_amg_manager.iFinnest_ilu == 1) {
											if (my_amg_manager.b_ilu_smoothers_in_nnz_n_LE_6) {
												doublerealT dn = (doublerealT)(1.0*n_a[i_id_level_local]);
												doublerealT dnnz = (doublerealT)(1.0*nnz_a[i_id_level_local]);
												if (dnnz / dn <= dapply_ilu_max_pattern_size) {
													bflag56 = true;
												}
											}
										}

										if (bILU2smoother == 1) {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 0);
											residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												milu0[i_id_level_local].zbuf[i43 + 1] = residual_fine[i_id_level_local][i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[i_id_level_local], milu0[i_id_level_local].zbuf, milu0[i_id_level_local].zbuf2, milu0[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												error_approx_coarse[i_id_level_local - 1][i43 + 1] += (doublerealT)(milu0[i_id_level_local].zbuf2[i43 + 1]);
											}

										}
										else if (1 && ((bILU2smoother == 2) || bflag56)) {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 0);
											residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												milu2[i_id_level_local].zbuf[i43 + 1] = residual_fine[i_id_level_local][i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[i_id_level_local], milu2[i_id_level_local].zbuf, milu2[i_id_level_local].zbuf2, milu2[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												error_approx_coarse[i_id_level_local - 1][i43 + 1] += (doublerealT)(milu2[i_id_level_local].zbuf2[i43 + 1]);
											}

										}
										else {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 0);
										}
									}
									else {
										seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], nested_desection[i_id_level_local], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 0);
									}
								}
							}
						}

					}

				}







				//center
				// ЭТО сердцевина SOLUTION PHASE.

				// TODO нижний 3.12.2016 (осталось один нижний и один верхний).


				// 21
				for (integer i_id_level_local = idim_diag - 1; i_id_level_local >= 2; i_id_level_local--) {

					if (ilevel > i_id_level_local) {

						{

							integer in_a_loc = 0;
							for (integer i_72 = 0; i_72 < i_id_level_local - 1; i_72++) {
								// sum(n_a[0]+n_a[19];
								in_a_loc += n_a[i_72];
							}

							// post smoothing
							// doublerealT R0_20 = 0.0;
							///doublerealT Rprev_20 = 0.0, Rnext_20 = 0.0;
							if (process_flow_logic) {
								// calculate initial residual.
								//residualq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc  + n_a[i_id_level_local - 1], residual_fine[i_id_level_local]);



								//Rprev_21[i_id_level_local] = norma(residual_fine[i_id_level_local], n_a[i_id_level_local]);


								// smother
								integer iter = 0;
								integer nu2_count = nu2;
								if (i_id_level_local == ilevel - 1) {
									// на самом грубом уровне нам требуется точное решение.
									//nu2_count = 100;																												
								}
								else {
									for (iter = 0; iter < nu2_count; iter++) {
										//quick seidel
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 1);
										}
										else {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], nested_desection[i_id_level_local], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 1);
										}

										//residualq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local-1], residual_fine[i_id_level_local]);
										residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);


										Rnext_21[i_id_level_local] = norma(residual_fine[i_id_level_local], n_a[i_id_level_local]);
										// this is process flow logic
										if (Rnext_21[i_id_level_local] < process_flow_alpha*R0_21[i_id_level_local]) {
											// Смысл модификации в том что мы экономим итерации на пресмутере.
											break; // досрочно опускаемся на следующий уровень если он есть конечно.
										}
										else {
											Rprev_21[i_id_level_local] = Rnext_21[i_id_level_local];
										}
									}
								}

								if (iter == nu2) {
#if doubleintprecision == 1
									printf("level %lld limit postsmother iteration is reached\n", i_id_level_local);
#else
									printf("level %d limit postsmother iteration is reached\n", i_id_level_local);
#endif

								}

							}
							else {
								integer nu2_count = nu2;
								if (i_id_level_local == ilevel - 1) {
									// на самом грубом уровне нам требуется точное решение.
									//nu2_count = 100;																																					
								}
								for (integer iter = 0; iter < nu2_count; iter++) {
									if (bonly_serial) {

										bool bflag56 = false;
										if (my_amg_manager.iFinnest_ilu == 1) {
											if (my_amg_manager.b_ilu_smoothers_in_nnz_n_LE_6) {
												doublerealT dn = (doublerealT)(1.0*n_a[i_id_level_local]);
												doublerealT dnnz = (doublerealT)(1.0*nnz_a[i_id_level_local]);
												if (dnnz / dn <= dapply_ilu_max_pattern_size) {
													bflag56 = true;
												}
											}
										}

										if (bILU2smoother == 1) {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 1);
											residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												milu0[i_id_level_local].zbuf[i43 + 1] = residual_fine[i_id_level_local][i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[i_id_level_local], milu0[i_id_level_local].zbuf, milu0[i_id_level_local].zbuf2, milu0[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												error_approx_coarse[i_id_level_local - 1][i43 + 1] += (doublerealT)(milu0[i_id_level_local].zbuf2[i43 + 1]);
											}
										}
										else if (1 && ((bILU2smoother == 2) || bflag56)) {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 1);
											residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												milu2[i_id_level_local].zbuf[i43 + 1] = residual_fine[i_id_level_local][i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[i_id_level_local], milu2[i_id_level_local].zbuf, milu2[i_id_level_local].zbuf2, milu2[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												error_approx_coarse[i_id_level_local - 1][i43 + 1] += (doublerealT)(milu2[i_id_level_local].zbuf2[i43 + 1]);
											}
										}
										else {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 1);
										}
									}
									else {
										seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], nested_desection[i_id_level_local], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 1);
									}
								}
							}


						}

						// prolongation
						// residual_r
						//doublerealT *error_approx_fine[i_id_level_local - 1] = new doublerealT[n_a[i_id_level_local - 1] + 1];
#pragma omp parallel for
						for (integer ii = 1; ii <= n_a[i_id_level_local - 1]; ii++) {
							error_approx_fine[i_id_level_local - 1][ii] = 0.0;
						}

						integer innz_aRP_loc = 1;
						for (integer i_72 = 0; i_72 < i_id_level_local - 1; i_72++) {
							innz_aRP_loc += nnz_aRP[i_72];
						}
						prolongation(P, innz_aRP_loc, innz_aRP_loc - 1 + nnz_aRP[i_id_level_local - 1], flag, error_approx_fine[i_id_level_local - 1], error_approx_coarse[i_id_level_local - 1], n_a[i_id_level_local - 1], n_a[i_id_level_local]);



						// correction
#pragma omp parallel for
						for (integer ii = 1; ii <= n_a[i_id_level_local - 1]; ii++) {
							error_approx_coarse[i_id_level_local - 2][ii] += error_approx_fine[i_id_level_local - 1][ii];
						}

						// free
						//delete[] error_approx_fine[i_id_level_local - 1];
						//delete[] error_approx_coarse[i_id_level_local - 1];
						//delete[] residual_coarse[i_id_level_local - 1];
						//delete[] residual_fine[i_id_level_local - 1];

					} // 21
				}



				


				// post smothing
				if (process_flow_logic) {


					// smother
					integer iter = 0;
					for (iter = 0; iter < nu2; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 1);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], nested_desection[1], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 1);
						}

						//residualq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0] , residual_fine[1]);
						residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);


						Rnext_1 = norma(residual_fine[1], n_a[1]);
						// this is process flow logic
						if (Rnext_1 < process_flow_alpha*R0_1) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_1 = Rnext_1;
						}
					}

					if (iter == nu2) {
						printf("level 1 limit postsmother iteration is reached\n");
					}

				}
				else {
					for (integer iter = 0; iter < nu2; iter++) {
						if (bonly_serial) {
							if (bILU2smoother == 1) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 1);
								residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu0[1].zbuf[i43 + 1] = residual_fine[1][i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu0[1].zbuf, milu0[1].zbuf2, milu0[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[0][i43 + 1] += (doublerealT)(milu0[1].zbuf2[i43 + 1]);
								}
							}
							else if (1 && bILU2smoother == 2) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 1);
								residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu2[1].zbuf[i43 + 1] = residual_fine[1][i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu2[1].zbuf, milu2[1].zbuf2, milu2[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[0][i43 + 1] += (doublerealT)(milu2[1].zbuf2[i43 + 1]);
								}
							}
							else {
								seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 1);
							}
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], nested_desection[1], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 1);
						}
					}
				}

				delete[] R0_21; 
				delete[] Rprev_21;
				delete[] Rnext_21;

				R0_21 = nullptr;
				Rprev_21 = nullptr;
				Rnext_21 = nullptr;

			}

			move_up(nu1, nu2);

			// prolongation
			// residual_r
			//doublerealT *error_approx_fine[0] = new doublerealT[n_a[0] + 1];
#pragma omp parallel for
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				error_approx_fine[0][ii] = 0.0;
			}

			prolongation(P, 1, nnz_aRP[0], flag, error_approx_fine[0], error_approx_coarse[0], n_a[0], n_a[1]);

			// correction
#pragma omp parallel for
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				//if (row_ptr_start[ii] != row_ptr_end[ii]) {
					// Не условие Дирихле.
					z76[ii] += error_approx_fine[0][ii];
			//	}
			}

			// free
			//delete[] error_approx_fine[0];
			//delete[] error_approx_coarse[0];
			//delete[] residual_coarse[0];
			//delete[] residual_fine[0];
		}



		//doublerealT R0_0 = 0.0;
		//doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		// post smothing
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
			residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
			Rprev_0 = norma(residual_fine[0], n_a[0]);

			// smother
			integer iter = 0;
			for (iter = 0; iter < nFinestSweeps; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 1);
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, nested_desection[0], row_ptr_start, row_ptr_end, 0, F_false_C_true, 1);
				}
				//residualq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
				residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
				Rnext_0 = norma(residual_fine[0], n_a[0]);
				// this is process flow logic
				if (Rnext_0 < process_flow_alpha*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nFinestSweeps) {
				printf("level 0 limit postsmother iteration is reached\n");
			}

		}
		else {
			// nFinnestSweeps new logic 14 jan 2016.
			// smother
			for (integer iter = 0; iter < nFinestSweeps; iter++) {
				//seidel<doublereal>(Amat, 1, nnz_a[0], z76, s76, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					if (bILU2smoother == 1) {
						seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 1);
						residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu0[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu0[0].zbuf, milu0[0].zbuf2, milu0[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							z76[i43 + 1] += milu0[0].zbuf2[i43 + 1];
						}
					}
					else if ((bILU2smoother == 2) || (my_amg_manager.iFinnest_ilu == 1)) {
						seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 1);
						residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu2[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu2[0].zbuf, milu2[0].zbuf2, milu2[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							z76[i43 + 1] += milu2[0].zbuf2[i43 + 1];
						}
					}
					else {
						seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 1);
					}
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, nested_desection[0], row_ptr_start, row_ptr_end, 0, F_false_C_true, 1);
				}
			}
		}

	}
}

// Функции необходимые для работы алгоритма FGMRes - гибкого варианта обобщённого метода минимальных невязок.
// FGMRes - Саад и Шульц 1986 год.
// Данные функции реализованы в файле gmres.cpp.
// НАЧАЛО. функции необходимые для работы FGMRes.
//void Update(doublereal* &x, integer k, integer n, doublereal** &h, doublereal* &s, doublereal** &v);
//void GeneratePlaneRotation(doublereal &dx, doublereal &dy, doublereal &cs, doublereal &sn);
//void ApplyPlaneRotation(doublereal &dx, doublereal &dy, doublereal &cs, doublereal &sn);
// Норма вектора
// как корень квадратный из суммы квадратов.
//doublereal NormaV_for_gmres( doublereal *dV, int isize);
// ОКОНЧАНИЕ. функции необходимые для работы FGMRes.

// Вычисление средних температур в К на границах вакуумных промежутков:
// Это нужно для surface - 2 - surface модели излучения внутри Prism Object.
// Модифицировано с учётом АЛИС сетки 20 сентября 2016.
void update_avg_temperatures(doublereal* &potent, BLOCK &b);

// Модификация матрицы СЛАУ для учёта влияния radiosity Prism Object.
//void radiosity_patch_for_vacuum_Prism_Object(equation3D* &sl, equation3D_bon* &slb, BLOCK* &b, integer lb, integer maxelm)
// 26.09.2016 Работает и для АЛИС сетки тоже.
void radiosity_patch_for_vacuum_Prism_Object_(doublereal* &rthdsd, BLOCK* &b, integer lb, integer maxelm, int *&whot_is_block);

// 19.04.2018 Печатает информацию о количестве контрольных объёмов.
// 04.06.2019
void print_control_volume_statistics(integer* &n_a, integer* &nnz_a, integer ilevel,
	bool bprint_mesage_diagnostic, bool debug_reshime)
{
#if doubleintprecision == 1

	if (bprint_mesage_diagnostic) {
		// level info.		

		if ((ilevel >= 2) && (ilevel <= 200)) {
			printf("number of levels=%lld\n", ilevel);
			printf("levels   unknowns   nonzeros  sample_pattern\n");
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("%3lld \t %8lld  %9lld \t %3lld\n", i_1, n_a[i_1],  nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if (ilevel > 200) {
			printf("very big matrix (mesh). no programming.\n");
			printf("you may send your message on mail kirill7785@mail.ru\n");
			system("pause");
			exit(1);
		}
	}

#else

if (bprint_mesage_diagnostic) {
	// level info.
	if (ilevel == 2) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		printf("%2d \t %8d  %9d \t %3d\n", 0, n_a[0], nnz_a[0], (integer)(nnz_a[0] / n_a[0]));
		printf("%2d \t %8d  %9d \t %3d\n", 1, n_a[1], nnz_a[1], (integer)(nnz_a[1] / n_a[1]));
		if (debug_reshime) system("pause");
	}
	if (ilevel == 3) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		printf("%2d \t %8d  %9d \t %3d\n", 0, n_a[0], nnz_a[0], (integer)(nnz_a[0] / n_a[0]));
		printf("%2d \t %8d  %9d \t %3d\n", 1, n_a[1], nnz_a[1], (integer)(nnz_a[1] / n_a[1]));
		printf("%2d \t %8d  %9d \t %3d\n", 2, n_a[2], nnz_a[2], (integer)(nnz_a[2] / n_a[2]));
		if (debug_reshime) system("pause");
	}
	if (ilevel == 4) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		printf("%2d \t %8d  %9d \t %3d\n", 0, n_a[0], nnz_a[0], (integer)(nnz_a[0] / n_a[0]));
		printf("%2d \t %8d  %9d \t %3d\n", 1, n_a[1], nnz_a[1], (integer)(nnz_a[1] / n_a[1]));
		printf("%2d \t %8d  %9d \t %3d\n", 2, n_a[2], nnz_a[2], (integer)(nnz_a[2] / n_a[2]));
		printf("%2d \t %8d  %9d \t %3d\n", 3, n_a[3], nnz_a[3], (integer)(nnz_a[3] / n_a[3]));
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 21) || (ilevel == 22) || (ilevel == 23) || (ilevel == 24) || (ilevel == 25)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 26) || (ilevel == 27) || (ilevel == 28) || (ilevel == 29) || (ilevel == 30)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 31) || (ilevel == 32) || (ilevel == 33) || (ilevel == 34) || (ilevel == 35)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 36) || (ilevel == 37) || (ilevel == 38) || (ilevel == 39) || (ilevel == 40)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 41) || (ilevel == 42) || (ilevel == 43) || (ilevel == 44) || (ilevel == 45)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 46) || (ilevel == 47) || (ilevel == 48) || (ilevel == 49) || (ilevel == 50)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d  \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 51) || (ilevel == 52) || (ilevel == 53) || (ilevel == 54) || (ilevel == 55)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 56) || (ilevel == 57) || (ilevel == 58) || (ilevel == 59) || (ilevel == 60)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 61) || (ilevel == 62) || (ilevel == 63) || (ilevel == 64) || (ilevel == 65)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 66) || (ilevel == 67) || (ilevel == 68) || (ilevel == 69) || (ilevel == 70)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 71) || (ilevel == 72) || (ilevel == 73) || (ilevel == 74) || (ilevel == 75)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 76) || (ilevel == 77) || (ilevel == 78) || (ilevel == 79) || (ilevel == 80)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 81) || (ilevel == 82) || (ilevel == 83) || (ilevel == 84) || (ilevel == 85)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 86) || (ilevel == 87) || (ilevel == 88) || (ilevel == 89) || (ilevel == 90)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 91) || (ilevel == 92) || (ilevel == 93) || (ilevel == 94) || (ilevel == 95)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 96) || (ilevel == 97) || (ilevel == 98) || (ilevel == 99) || (ilevel == 100)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel >= 101) && (ilevel <= 200)) {
		printf("number of levels=%lld\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%3lld \t %8lld  %9lld \t %3lld\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if (ilevel > 200) {
		printf("very big matrix (mesh). no programming.\n");
		printf("you may send your message on mail kirill7785@mail.ru\n");
		system("pause");
		exit(1);
	}
}

#endif

}

// 19.04.2018 Печатает информацию о количестве контрольных объёмов.
void print_control_volume_statistics_old(integer*& n_a, integer*& nnz_a, integer ilevel,
	bool bprint_mesage_diagnostic, bool debug_reshime)
{
#if doubleintprecision == 1

	if (bprint_mesage_diagnostic) {
		// level info.
		if (ilevel == 2) {
			printf("ilevel=%lld", ilevel);
			printf("n_a[0]=%lld  nnz_a[0]=%lld  sample pattern=%lld\n", n_a[0], nnz_a[0], (integer)(nnz_a[0] / n_a[0]));
			printf("n_a[1]=%lld  nnz_a[1]=%lld sample pattern=%lld\n", n_a[1], nnz_a[1], (integer)(nnz_a[1] / n_a[1]));
			if (debug_reshime) system("pause");
		}
		if (ilevel == 3) {
			printf("ilevel=%lld", ilevel);
			printf("n_a[0]=%lld  nnz_a[0]=%lld  sample pattern=%lld\n", n_a[0], nnz_a[0], (integer)(nnz_a[0] / n_a[0]));
			printf("n_a[1]=%lld  nnz_a[1]=%lld sample pattern=%lld\n", n_a[1], nnz_a[1], (integer)(nnz_a[1] / n_a[1]));
			printf("n_a[2]=%lld  nnz_a[2]=%lld sample pattern=%lld\n", n_a[2], nnz_a[2], (integer)(nnz_a[2] / n_a[2]));
			if (debug_reshime) system("pause");
		}
		if (ilevel == 4) {
			printf("ilevel=%lld", ilevel);
			printf("n_a[0]=%lld  nnz_a[0]=%lld  sample pattern=%lld\n", n_a[0], nnz_a[0], (integer)(nnz_a[0] / n_a[0]));
			printf("n_a[1]=%lld  nnz_a[1]=%lld sample pattern=%lld\n", n_a[1], nnz_a[1], (integer)(nnz_a[1] / n_a[1]));
			printf("n_a[2]=%lld  nnz_a[2]=%lld sample pattern=%lld\n", n_a[2], nnz_a[2], (integer)(nnz_a[2] / n_a[2]));
			printf("n_a[3]=%lld  nnz_a[3]=%lld sample pattern=%lld\n", n_a[3], nnz_a[3], (integer)(nnz_a[3] / n_a[3]));
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld  sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 21) || (ilevel == 22) || (ilevel == 23) || (ilevel == 24) || (ilevel == 25)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 26) || (ilevel == 27) || (ilevel == 28) || (ilevel == 29) || (ilevel == 30)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 31) || (ilevel == 32) || (ilevel == 33) || (ilevel == 34) || (ilevel == 35)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 36) || (ilevel == 37) || (ilevel == 38) || (ilevel == 39) || (ilevel == 40)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 41) || (ilevel == 42) || (ilevel == 43) || (ilevel == 44) || (ilevel == 45)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 46) || (ilevel == 47) || (ilevel == 48) || (ilevel == 49) || (ilevel == 50)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 51) || (ilevel == 52) || (ilevel == 53) || (ilevel == 54) || (ilevel == 55)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 56) || (ilevel == 57) || (ilevel == 58) || (ilevel == 59) || (ilevel == 60)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 61) || (ilevel == 62) || (ilevel == 63) || (ilevel == 64) || (ilevel == 65)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 66) || (ilevel == 67) || (ilevel == 68) || (ilevel == 69) || (ilevel == 70)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 71) || (ilevel == 72) || (ilevel == 73) || (ilevel == 74) || (ilevel == 75)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 76) || (ilevel == 77) || (ilevel == 78) || (ilevel == 79) || (ilevel == 80)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 81) || (ilevel == 82) || (ilevel == 83) || (ilevel == 84) || (ilevel == 85)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 86) || (ilevel == 87) || (ilevel == 88) || (ilevel == 89) || (ilevel == 90)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 91) || (ilevel == 92) || (ilevel == 93) || (ilevel == 94) || (ilevel == 95)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 96) || (ilevel == 97) || (ilevel == 98) || (ilevel == 99) || (ilevel == 100)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld  sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}


		if (ilevel > 99) {
			printf("very big matrix (mesh). no programming.\n");
			system("pause");
			exit(1);
		}
	}

#else

	if (bprint_mesage_diagnostic) {
		// level info.
		if (ilevel == 2) {
			printf("ilevel=%d", ilevel);
			printf("n_a[0]=%d n_a[1]=%d nnz_a[0]=%d nnz_a[1]=%d \n", n_a[0], n_a[1], nnz_a[0], nnz_a[1]);
			if (debug_reshime) system("pause");
		}
		if (ilevel == 3) {
			printf("ilevel=%d", ilevel);
			printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d \n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2]);
			if (debug_reshime) system("pause");
		}
		if (ilevel == 4) {
			printf("ilevel=%d", ilevel);
			printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d n_a[3]=%d \n", n_a[0], n_a[1], n_a[2], n_a[3]);
			printf("nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d nnz_a[3]=%d \n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3]);
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 21) || (ilevel == 22) || (ilevel == 23) || (ilevel == 24) || (ilevel == 25)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 26) || (ilevel == 27) || (ilevel == 28) || (ilevel == 29) || (ilevel == 30)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 31) || (ilevel == 32) || (ilevel == 33) || (ilevel == 34) || (ilevel == 35)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 36) || (ilevel == 37) || (ilevel == 38) || (ilevel == 39) || (ilevel == 40)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 41) || (ilevel == 42) || (ilevel == 43) || (ilevel == 44) || (ilevel == 45)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 46) || (ilevel == 47) || (ilevel == 48) || (ilevel == 49) || (ilevel == 50)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 51) || (ilevel == 52) || (ilevel == 53) || (ilevel == 54) || (ilevel == 55)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 56) || (ilevel == 57) || (ilevel == 58) || (ilevel == 59) || (ilevel == 60)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 61) || (ilevel == 62) || (ilevel == 63) || (ilevel == 64) || (ilevel == 65)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 66) || (ilevel == 67) || (ilevel == 68) || (ilevel == 69) || (ilevel == 70)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 71) || (ilevel == 72) || (ilevel == 73) || (ilevel == 74) || (ilevel == 75)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 76) || (ilevel == 77) || (ilevel == 78) || (ilevel == 79) || (ilevel == 80)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 81) || (ilevel == 82) || (ilevel == 83) || (ilevel == 84) || (ilevel == 85)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 86) || (ilevel == 87) || (ilevel == 88) || (ilevel == 89) || (ilevel == 90)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 91) || (ilevel == 92) || (ilevel == 93) || (ilevel == 94) || (ilevel == 95)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 96) || (ilevel == 97) || (ilevel == 98) || (ilevel == 99) || (ilevel == 100)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}


		if (ilevel > 99) {
			printf("very big matrix (mesh). no programming.\n");
			system("pause");
			exit(1);
		}
	}
#endif

}

// Интерполяционная процедура №10.
template <typename doublerealT>
void my_interpolation_procedure_number10(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor, 
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA, 
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublerealT RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublerealT &theta, integer &n, Ak1* &R, integer* &C_numerate)
{
// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.

the_number_of_neighbors_that_are_not_C_nodes = 0;
number_of_F_nodes_with_one_single_strong_C_neighbor = 0;
// Построение пролонгации для узлов которые составляют F nodes.
// Каждый F-nodes окружён C-nodes.
for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

	// Нам нужен разреженный оператор Галёркина.
	// 5 декабря 2015 года мы попробуем увеличить разреженность
	// оператора интерполяции а значит и оператора Галёркина.
	doublerealT maxelem_threshold = -1.0;
	// O(log2(nnz))
	//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
	// O(1)
	integer ii1 = row_startA[i8];

	if (bpositive_connections) {
		for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			if (Amat[is0].j != Amat[ii1].i) {
				// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
				//if (this_is_C_node[Amat[is0].j]  ) {
				if (fabs(Amat[is0].aij) > maxelem_threshold) {
					maxelem_threshold = fabs(Amat[is0].aij);
				}
				//}
			}
		}
	}
	else {
		// 23_10_2016 только negative connections.
		for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			if (Amat[is0].j != Amat[ii1].i) {
				// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
				//if (this_is_C_node[Amat[is0].j]  ) {
				if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
					maxelem_threshold = fabs(Amat[is0].aij);
				}
				//}
			}
		}
	}
	// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

	// Найти соседей данного F-node которые C-node.
	integer icsos = 0;

	// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
	// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
	doublerealT sumP = 0.0;
	if (bpositive_connections) {
		for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			if (Amat[is0].j != Amat[ii1].i) {
				if (this_is_C_node[Amat[is0].j]  ) {
					//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
					if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
						sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
						icsos++;
					}
				}
				else {
					// Подсчитываем количество соседей которые не являются С узлами.
					the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
				}
			}
		}
	}
	else {
		for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			if (Amat[is0].j != Amat[ii1].i) {
				if (this_is_C_node[Amat[is0].j]  ) {
					//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
					if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
						sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
						icsos++;
					}
				}
				else {
					// Подсчитываем количество соседей которые не являются С узлами.
					the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
				}
			}
		}
	}
	if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.



	if ((false) && (icsos == 1)) {
		// 1 января 2016 Один сосед это недостаточно.
		// Поэтому в случае одного соседа делаем такой узел С узлом.
		this_is_F_node[i8] = false;
		this_is_C_node[i8] = true;
		bweSholdbeContinue = true;
	}
	else {



		for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			if (Amat[is0].j != Amat[ii1].i) {
				if (this_is_C_node[Amat[is0].j]  ) {

					if (fabs(sumP) < RealZERO) {
						//printf("error interpolation zero diagonal sumP.\n");
						//printf("Fnode all neighbour is F");
						//system("pause");
						//printf("i8 is Dirichlet node\n");
						if (this_is_C_node[i8] == false) iadditionalCstatistic++;
						this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
						//exit(1);
						// здесь нужна непрямая интерполяция.
					}
					else {

						// Внедиагональный элемент из множества С узлов.

						if (bpositive_connections) {

							// Данная вставка должна существенно сохранять 
							// разреженность оператора Галёркина на глубоких 
							// сеточных уровнях.
							// Модификация 5 декабря 2015.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								P[icount1].j = (integer_mix_precision)(i8);
								P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
								P[icount1].aij = fabs(Amat[is0].aij) / sumP;
								icount1++;
								if (icount1 >= nsizePR*n) {
									printf("memory error!!!\n");
									printf("not enough memory for the interpolation operator.\n");
									//system("PAUSE");
									//exit(1);
									deallocate_prolongation(nsizePR, n, R, P);
								}
							}
						}
						else {
							// Данная вставка должна существенно сохранять 
							// разреженность оператора Галёркина на глубоких 
							// сеточных уровнях.
							// Модификация 5 декабря 2015.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								P[icount1].j = (integer_mix_precision)(i8);
								P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
								P[icount1].aij = fabs(Amat[is0].aij) / sumP;
								icount1++;
								if (icount1 >= nsizePR*n) {
									printf("memory error!!!\n");
									printf("not enough memory for the interpolation operator.\n");
									//system("PAUSE");
									//exit(1);
									deallocate_prolongation(nsizePR, n, R, P);
								}
							}
						}

					}

				}
			}
		}

	}

}
} // my_interpolation_procedure_number10

  // Интерполяционная процедура №7.
template <typename doublerealT>
void my_interpolation_procedure_number7(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublerealT RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublerealT &theta, integer &n, Ak1* &R, integer* &C_numerate)
{
	// Немного более экономичная по памяти. Коэффициент не превышал 3.

	// Прямая интерполяция с элементам непрямой.
	// Непрямая интерполяция применяется только для F узлов которые
	// не имеют С соседей.
	// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.
	// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.
	// Узел F не имеющий Strong C соседей, получает значение из Strong C соседей соседних Strong F узлов в
	// в результате сканирования списка Strong F соседей.
	// Если на встречаются два Strongly связанных F узла у которых в совокупности нет вообще ни одного Strong C соседа
	// то один из этих Strong F узлов тановится С узлом и сканирование списка сильных Strong F соседов данного узла F прекращается.
	// Потом мы повторно запускаем алгоритм построения с учётом уже добавленных С узлов.


	the_number_of_neighbors_that_are_not_C_nodes = 0;
	number_of_F_nodes_with_one_single_strong_C_neighbor = 0;
	// Построение пролонгации для узлов которые составляют F nodes.
	// Каждый F-nodes окружён C-nodes.
	for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

		// Нам нужен разреженный оператор Галёркина.
		// 5 декабря 2015 года мы попробуем увеличить разреженность
		// оператора интерполяции а значит и оператора Галёркина.
		doublerealT maxelem_threshold = -1.0;
		// O(log2(nnz))
		//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		// O(1)
		integer ii1 = row_startA[i8];
		if (bpositive_connections) {
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j]  ) {
					if (fabs(Amat[is0].aij) > maxelem_threshold) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
		}
		else {
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j]  ) {
					if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
		}
		// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

		// Найти соседей данного F-node которые C-node.
		integer icsos = 0;

		// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
		// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
		doublerealT sumP = 0.0;
		doublerealT SumPall = 0.0;
		integer icount_StronglyF = 0;
		if (bpositive_connections) {
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j]  ) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j]  ) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
		}
		else {
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j]  ) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j]  ) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
		}
		if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.


		// 1 января 2015 Один сосед это недостаточно.
		// Поэтому в случае одного соседа делаем такой узел С узлом.
		if ((false) && (icsos == 1)) {
			this_is_F_node[i8] = false;
			this_is_C_node[i8] = true;
			bweSholdbeContinue = true;
		}
		else {

			if (fabs(sumP) < RealZERO) {
				//printf("error interpolation zero diagonal sumP.\n");
				//printf("Fnode all neighbour is F");
				//system("pause");
				//printf("i8 is Dirichlet node\n");

				//exit(1);
				// здесь нужна непрямая интерполяция.
				bool* empty_interpol = nullptr;
				//empty_interpol = new bool[icount_StronglyF];
				empty_interpol = (bool*)malloc(icount_StronglyF * sizeof(bool));
				char c1[27] = "classic_aglomerative_amg_4";
				char c2[15] = "empty_interpol";
				handle_error<bool>(empty_interpol, c2,  c1, icount_StronglyF);

				for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
					empty_interpol[i_38] = false; // initialization
				}

				integer i_38_count = 0;

				bool bCinsert = false;

				if (bpositive_connections) {

					// Сканируем сильных F соседей данного F узла для которого надо построить интерполяцию.
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_F_node[Amat[is0].j]  ) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

									integer iFpoint = Amat[is0].j;
									doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
									// сканируем всех соседей iFpointeger 
									// чтобы найти среди них С узлы.

									// Идентифицируем локальный порог.
									doublerealT maxelem_threshold_loc = -1.0;
									//O(log2(nnz))
									//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									// O(1)
									integer ii1_loc = row_startA[iFpoint];
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											//if (this_is_C_node[Amat[is0_loc].j]  ) {
											// Будем рассматривать только действительно сильных C кандидатов второго уровня.
											if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
												maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
											}
											//}
										}
									}


									// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

									// Найти соседей данного F-node которые C-node.
									integer icsos_loc = 0;
									bool bvisit_sumPloc = false;

									// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
									// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
									doublerealT sumP_loc = 0.0;
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {




											if (this_is_C_node[Amat[is0_loc].j]  ) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
													sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
													icsos_loc++;
													bvisit_sumPloc = true;
													empty_interpol[i_38_count] = true;
												}
											}
											else {
												// Подсчитываем количество соседей которые не являются С узлами.
												//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
											}
										}
									}


									if (bvisit_sumPloc) {
										// В общем это двойная интерполяционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}
									}
									else {
										// не было С соседей интерполяция может испытывать проблемы.
										// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
										// Данная проблема проявляется уже на втором уровне.
										//printf("problem situation");
										//getchar();
										this_is_F_node[iFpoint] = false;
										this_is_C_node[iFpoint] = true;
										bweSholdbeContinue = true;
										bCinsert = true;
										// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполлчяцию,
										// Иначе я боюсь мы можем добавить слишком много С узлов на грубосеточных уровнях.
										break;
										// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых уровнях сетки.

									}

									i_38_count++;

								}
							}
						}
					}

				}
				else {
					// Сканируем сильных F соседей данного F узла для которого надо построить интерполяцию.
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_F_node[Amat[is0].j]  ) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

									integer iFpoint = Amat[is0].j;
									doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
									// сканируем всех соседей iFpointeger 
									// чтобы найти среди них С узлы.

									// Идентифицируем локальный порог.
									doublerealT maxelem_threshold_loc = -1.0;
									//O(log2(nnz))
									//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									// O(1)
									integer ii1_loc = row_startA[iFpoint];
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											//if (this_is_C_node[Amat[is0_loc].j]  ) {
											// Будем рассматривать только действительно сильных C кандидатов второго уровня.
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
												maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
											}
											//}
										}
									}


									// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

									// Найти соседей данного F-node которые C-node.
									integer icsos_loc = 0;
									bool bvisit_sumPloc = false;

									// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
									// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
									doublerealT sumP_loc = 0.0;
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {




											if (this_is_C_node[Amat[is0_loc].j]  ) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
													sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
													icsos_loc++;
													bvisit_sumPloc = true;
													empty_interpol[i_38_count] = true;
												}
											}
											else {
												// Подсчитываем количество соседей которые не являются С узлами.
												//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
											}
										}
									}


									if (bvisit_sumPloc) {
										// В общем это двойная интерполяционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}
									}
									else {
										// не было С соседей интерполяция может испытывать проблемы.
										// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
										// Данная проблема проявляется уже на втором уровне.
										//printf("problem situation");
										//getchar();
										this_is_F_node[iFpoint] = false;
										this_is_C_node[iFpoint] = true;
										bweSholdbeContinue = true;
										bCinsert = true;
										// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполлчяцию,
										// Иначе я боюсь мы можем добавить слишком много С узлов на грубосеточных уровнях.
										break;
										// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых уровнях сетки.

									}

									i_38_count++;

								}
							}
						}
					}
				}

				if (!bCinsert) {
					// Ибиранее этой добавки даёт ускорение вместо 3мин 42с до 3мин 29с.

					bool bstandart_vjzov = true;
					for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
						// 3 января. На самом деле здесь хорошо бы посмотреть вариант
						// когда с не менее чем двух сторон интерполяция сработала, здесь 
						// же срабатывание было лишь с одной из сторон как минимум.
						if (empty_interpol[i_38]  ) {
							bstandart_vjzov = false;
						}
					}
					if (bstandart_vjzov) {
						if (this_is_C_node[i8] == false) iadditionalCstatistic++;
						this_is_F_node[i8] = false;
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
					}
				}

				free(empty_interpol);

			}



			else {

				if (bpositive_connections) {
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j]  ) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									P[icount1].j = (integer_mix_precision)(i8);
									P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
									P[icount1].aij = fabs(Amat[is0].aij) / sumP;
									icount1++;
									if (icount1 >= nsizePR*n) {
										printf("memory error!!!\n");
										printf("not enough memory for the interpolation operator.\n");
										//system("PAUSE");
										//exit(1);
										deallocate_prolongation(nsizePR, n, R, P);
									}
								}

							}
						}
					}

				}
				else {
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j]  ) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									P[icount1].j = (integer_mix_precision)(i8);
									P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
									P[icount1].aij = fabs(Amat[is0].aij) / sumP;
									icount1++;
									if (icount1 >= nsizePR*n) {
										printf("memory error!!!\n");
										printf("not enough memory for the interpolation operator.\n");
										//system("PAUSE");
										//exit(1);
										deallocate_prolongation(nsizePR, n, R, P);
									}
								}

							}
						}
					}

				}
			} // standart

		} // i8

	}

} // my_interpolation_procedure_number7

  // Интерполяционная процедура №2.
template <typename doublerealT>
void my_interpolation_procedure_number2(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublerealT RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublerealT &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF)
{
	// Немного более экономичная по памяти. Коэффициент не превышал 3.

	// Прямая интерполяция с элементам непрямой. Экспериментальный вариант. TODO.
	// Непрямая интерполяция применяется только для F узлов которые
	// не имеют С соседей или имеют недостаточное число С соседей.
	// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.

	// Надо сохранить разреженность оператора Галёркина но при этом усилить интерполяцию.
	// Идея в том чтобы узел F имеющий лишь одного Strong С соседа обработать так чтобы у него было не менее 
	// двух  C соседей учитывая эффект непрямой интерполяции.


	the_number_of_neighbors_that_are_not_C_nodes = 0;
	number_of_F_nodes_with_one_single_strong_C_neighbor = 0;
	number_of_F_nodes_with_one_single_strong_C_neighborF = 0;

	if (bpositive_connections) {
		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполяции а значит и оператора Галёркина.
			doublerealT maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j]  ) {
					if (fabs(Amat[is0].aij) > maxelem_threshold) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsosF = 0;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublerealT sumP = 0.0;
			doublerealT SumPall = 0.0;
			integer icount_StronglyF = 0;
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j]  ) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j]  ) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполяцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным C соседом и к тому-же не имеющих сильных F соседов.
			}


			// 1 января 2015 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {

				if (fabs(sumP) < RealZERO) {
					//printf("error interpolation zero diagonal sumP.\n");
					//printf("Fnode all neighbour is F");
					//system("pause");
					//printf("i8 is Dirichlet node\n");

					//exit(1);
					// здесь нужна непрямая интерполяция.
					bool* empty_interpol = nullptr;
					//empty_interpol = new bool[icount_StronglyF];
					empty_interpol = (bool*)malloc(icount_StronglyF * sizeof(bool));
					char c1[27] = "classic_aglomerative_amg_4";
					char c2[15] = "empty_interpol";
					handle_error<bool>(empty_interpol, c2,  c1, icount_StronglyF);

					for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
						empty_interpol[i_38] = false; // initialization
					}

					integer i_38_count = 0;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_F_node[Amat[is0].j]  ) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

									integer iFpoint = Amat[is0].j;
									doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
									// сканируем всех соседей iFpointeger 
									// чтобы найти среди них С узлы.

									// Идентифицируем локальный порог.
									doublerealT maxelem_threshold_loc = -1.0;
									//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									integer ii1_loc = row_startA[iFpoint];
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											//if (this_is_C_node[Amat[is0_loc].j]  ) {
											// Будем рассматривать только действительно сильных С кандидатов второго уровня.
											if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
												maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
											}
											//}
										}
									}


									// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

									// Найти соседей данного F-node которые C-node.
									integer icsos_loc = 0;
									bool bvisit_sumPloc = false;

									// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
									// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
									doublerealT sumP_loc = 0.0;
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {




											if (this_is_C_node[Amat[is0_loc].j]  ) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
													sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
													icsos_loc++;
													bvisit_sumPloc = true;
													empty_interpol[i_38_count] = true;
												}
											}
											else {
												// Подсчитываем количество соседей которые не являются С узлами.
												//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
											}
										}
									}


									if (bvisit_sumPloc) {
										// В общем это двойная интерполяционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}
									}
									else {
										// не было С соседей интерполяция может испытывать проблемы.
										// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
										// Данная проблема проявляется уже на втором уровне вложенности.
										//printf("problem situation");
										//getchar();
										this_is_F_node[iFpoint] = false;
										this_is_C_node[iFpoint] = true;
										bweSholdbeContinue = true;
										// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполяцию,
										// Иначе я боюсь мы можем добавить слишком много С узлов на грубых уровнях влженности.
										break;
										// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых урвнях сетки.
									}

									i_38_count++;

								}
							}
						}
					}

					bool bstandart_vjzov = true;
					for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
						// 3 января. На самом деле здесь хорошо бы посмотреть вариант
						// когда с не менее чем двух сторон интерполяция сработала, здесь 
						// же срабатывание было лишь с одной из сторон как минимум.
						if (empty_interpol[i_38]  ) {
							bstandart_vjzov = false;
						}
					}
					if (bstandart_vjzov) {
						this_is_F_node[i8] = false;
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
						iadditionalCstatistic++;
					}

					free(empty_interpol);

				}
				else if ((icsos == 1) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					SumPall += sumP;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								if (this_is_C_node[Amat[is0].j]  ) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {
										// Это как раз единственная Strong C связь. 
										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											P[icount1].j = (integer_mix_precision)(i8);
											P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j]  ) {

										// Рассматриваем Strong F связи.

										// Смысл:
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

										integer iFpoint = Amat[is0].j;
										doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublerealT maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}


										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublerealT sumP_loc = 0.0;
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {




												if (this_is_C_node[Amat[is0_loc].j]  ) {
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}
												}
												else {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
												}
											}
										}

										// В общем это двойная интерполяционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}


										//}
									}
							}
						}
					}
				}
				else {

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j]  ) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									P[icount1].j = (integer_mix_precision)(i8);
									P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
									P[icount1].aij = fabs(Amat[is0].aij) / sumP;
									icount1++;
									if (icount1 >= nsizePR*n) {
										printf("memory error!!!\n");
										printf("not enough memory for the interpolation operator.\n");
										//system("PAUSE");
										//exit(1);
										deallocate_prolongation(nsizePR, n, R, P);
									}
								}



							}
						}
					}
				} // standart

			} // i8


		} ///
	}
	else {
		// Только negative connections:


		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполяции а значит и оператора Галёркина.
			doublerealT maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j]  ) {
					if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsosF = 0;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublerealT sumP = 0.0;
			doublerealT SumPall = 0.0;
			integer icount_StronglyF = 0;
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j]  ) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j]  ) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполяцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}


			// 1 января 2015 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {

				if (fabs(sumP) < RealZERO) {
					//printf("error interpolation zero diagonal sumP.\n");
					//printf("Fnode all neighbour is F");
					//system("pause");
					//printf("i8 is Dirichlet node\n");

					//exit(1);
					// здесь нужна непрямая интерполяция.
					bool* empty_interpol = nullptr;
					//empty_interpol = new bool[icount_StronglyF];
					empty_interpol = (bool*)malloc(icount_StronglyF * sizeof(bool));
					char c1[27] = "classic_aglomerative_amg_4";
					char c2[15] = "empty_interpol";
					handle_error<bool>(empty_interpol, c2,  c1, icount_StronglyF);

					for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
						empty_interpol[i_38] = false; // initialization
					}

					integer i_38_count = 0;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_F_node[Amat[is0].j]  ) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

									integer iFpoint = Amat[is0].j;
									doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
									// сканируем всех соседей iFpointeger 
									// чтобы найти среди них С узлы.

									// Идентифицируем локальный порог.
									doublerealT maxelem_threshold_loc = -1.0;
									//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									integer ii1_loc = row_startA[iFpoint];
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											//if (this_is_C_node[Amat[is0_loc].j]  ) {
											// Будем рассматривать только действительно сильных С кандидатов второго уровня.
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
												maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
											}
											//}
										}
									}


									// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

									// Найти соседей данного F-node которые C-node.
									integer icsos_loc = 0;
									bool bvisit_sumPloc = false;

									// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
									// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
									doublerealT sumP_loc = 0.0;
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {




											if (this_is_C_node[Amat[is0_loc].j]  ) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
													sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
													icsos_loc++;
													bvisit_sumPloc = true;
													empty_interpol[i_38_count] = true;
												}
											}
											else {
												// Подсчитываем количество соседей которые не являются С узлами.
												//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
											}
										}
									}


									if (bvisit_sumPloc) {
										// В общем это двойная интерполяционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}
									}
									else {
										// не было С соседей интерполяция может испытывать проблемы.
										// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
										// Данная проблема проявляется уже на втором уровне вложенности.
										//printf("problem situation");
										//getchar();
										this_is_F_node[iFpoint] = false;
										this_is_C_node[iFpoint] = true;
										bweSholdbeContinue = true;
										// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполяцию,
										// Иначе я боюсь мы можем добавить слишком много С узлов на грубых уровнях влженности.
										break;
										// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых урвнях сетки.
									}

									i_38_count++;

								}
							}
						}
					}

					bool bstandart_vjzov = true;
					for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
						// 3 января. На самом деле здесь хорошо бы посмотреть вариант
						// когда с не менее чем двух сторон интерполяция сработала, здесь 
						// же срабатывание было лишь с одной из сторон как минимум.
						if (empty_interpol[i_38]  ) {
							bstandart_vjzov = false;
						}
					}
					if (bstandart_vjzov) {
						this_is_F_node[i8] = false;
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
						iadditionalCstatistic++;
					}

					free(empty_interpol);

				}
				else if ((icsos == 1) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					SumPall += sumP;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								if (this_is_C_node[Amat[is0].j]  ) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {
										// Это как раз единственная Strong C связь. 
										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											P[icount1].j = (integer_mix_precision)(i8);
											P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j]  ) {

										// Рассматриваем Strong F связи.

										// Смысл:
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

										integer iFpoint = Amat[is0].j;
										doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublerealT maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}


										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublerealT sumP_loc = 0.0;
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {




												if (this_is_C_node[Amat[is0_loc].j]  ) {
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}
												}
												else {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
												}
											}
										}

										// В общем это двойная интерполяционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}


										//}
									}
							}
						}
					}
				}
				else {

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j]  ) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									P[icount1].j = (integer_mix_precision)(i8);
									P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
									P[icount1].aij = fabs(Amat[is0].aij) / sumP;
									icount1++;
									if (icount1 >= nsizePR*n) {
										printf("memory error!!!\n");
										printf("not enough memory for the interpolation operator.\n");
										//system("PAUSE");
										//exit(1);
										deallocate_prolongation(nsizePR, n, R, P);
									}
								}



							}
						}
					}
				} // standart

			} // i8


		}

	}

} // my_interpolation_procedure_number2

#include "my_amg_interpolation.cpp"

  // Интерполяционная процедура №3.
template <typename doublerealT>
void my_interpolation_procedure_number3(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublerealT RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublerealT &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF,
	doublerealT &theta83, bool &btreshold_on_new_vetv, integer& ifrom_re_operation_protection,
	bool &from_re_operation_protection0, doublerealT &magic82, doublerealT* &threshold_quick_all, 
	doublerealT* &threshold_quick_only_negative)
{

	// 6 december 2016.
	// Подлежит удалению Refactoring.
	const integer itypemodifyinterpol=0; // номер модификации интерполяции. // Подлежит удалению Refactoring.
	integer inumberadaptpass=0; // максимальное количество сканов-проходов с модификациями. // Подлежит удалению Refactoring.


	//theta = 0.24;
	// theta_strong_F iter_number time,s
	// 0.21 56 22.63
	// 0.22 55 21.769
	// 0.23 52 21.488
	// 0.24 52 21.741 == theta // optimum
	// 0.26 69 24.623
	//doublerealT theta_strong_F = 0.23; // оптимальный выбор.
	doublerealT theta_strong_F = theta83; // 3 июля 2016


							  // четвёртая версия интерполяции.
	integer ioneStrongC_and_0_StrongF = 0;

	// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
	// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
	// сильных F узлов.

	//6interpolation 0.4 6.77 11 26 28.355
	//6interpolation 0.45 6.6 10 27 28.151
	//6interpolation 0.5 6.42 12 32 28.735
	//4interpolation 0.4 3.7  52 24.736 // best
	//4interpolation 0.3 3.78 13 59 27.525
	//4interpolation 0.5 3.61 12 55 25.533
	//4interpolation 0.45 3.65 10 63 30.24

	// the begining

	bool byes_add = false;
	// Быстрое добавление недостающих С узлов.
	if (1) {
		// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
		//doublerealT magic = 0.4; // 0.4 optimum


		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

		if (bpositive_connections) {


			integer i8_candidate_count = 0;
			integer* i8_candidate_arr = nullptr;
			i8_candidate_arr = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
			char c1[18] ="i8_candidate_arr";
			char c2[26] = "classic_aglomerative_amg4";
			handle_error<integer>(i8_candidate_arr,  c1, c2, (n_a[ilevel - 1] + 1));
			doublereal* i8_candidate_val_arr = nullptr;
			i8_candidate_val_arr = (doublereal*)malloc((n_a[ilevel - 1] + 1) * sizeof(doublereal));
			char c3[22] = "i8_candidate_val_arr";
			handle_error<doublereal>(i8_candidate_val_arr, c3, c2, (n_a[ilevel - 1] + 1));

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

#if doubleintprecision == 1
				//printf("i8=%lld n=%lld\n", i8, n_a[ilevel - 1]);
#else
				//printf("i8=%d n=%d\n", i8, n_a[ilevel - 1]);
#endif

				//getchar();


				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполяции а значит и оператора Галёркина.
				doublerealT maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
				if (!btreshold_on_new_vetv) {
					for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j]  ) {
							if (fabs(Amat[is0].aij) > maxelem_threshold) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
				}
				else {
					maxelem_threshold = threshold_quick_all[Amat[ii1].i];
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublerealT sumP = 0.0;
				doublerealT SumPall = 0.0;
				integer icount_StronglyF = 0;
				doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
				doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
				for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j]  ) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j]  ) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
								if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполяцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				{

					if ((icsos == 1) && (icsosF == 0)) {
						// Накапливаем информацию.

if (itypemodifyinterpol > 0)
						{

							if (itypemodifyinterpol > 1) {
								// запоминаем позицию кандидата на С узел.
								i8_candidate_arr[i8_candidate_count] = i8;
								// Запоминаем силу внедиагональной связи, 
								// чтобы потом выбрать наиболее сильную.
								i8_candidate_val_arr[i8_candidate_count] = sumP;
								i8_candidate_count++;
							}

							if (itypemodifyinterpol == 1) {
								// Добавляем только в том случае если количество проходов меньше максмального.
								if (ifrom_re_operation_protection < inumberadaptpass) {
									// 3 december 2016 rundom
									// не более сотни случайных добавлений на каждом уровне.
									integer id_size_873 = (integer)(n_a[ilevel - 1] / 100);
									integer id_873 = rand() % id_size_873 + 1;
									if (id_873 == 1) {
										// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
										// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
										// модификация 2 декабря 2016 года.
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true; // Были добавления узлов.
									}
								}
							}
						}

					}
					else if ((icsos == 1) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						//SumPall += sumP;

						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
									if (this_is_C_node[Amat[is0].j]  ) {

										// 20 января 2016.
										// По-моему этой ситуации вообще быть не может так как у нас 
										// заведомо один С сосед.
										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all neighbour is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											byes_add = true; // Были добавления узлов.
															 //exit(1);
															 // здесь нужна непрямая интерполяция.
										}


									}

								}
							}
						}
					}
					else {

						integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
						for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
							if (this_is_C_node[Amat[is0].j]  ) {
								if (Amat[is0].j != Amat[ii1].i) {


									// 20 jan 2016.
									// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


									if (fabs(sumP) < RealZERO) {
										// Это случай когда вообще нет сильных С соседей.


										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true; // Были добавления узлов.
														 //exit(1);
														 // здесь нужна непрямая интерполяция.
									}


								}
							}
						}
					}

				}

			}
			/////
if (itypemodifyinterpol > 0) 
			{

				if (i8_candidate_arr != nullptr) {
					i8_candidate_arr = (integer*)realloc(i8_candidate_arr, (i8_candidate_count + 2) * sizeof(integer));
				}
				if (i8_candidate_val_arr != nullptr) {
					i8_candidate_val_arr = (doublereal*)realloc(i8_candidate_val_arr, (i8_candidate_count + 2) * sizeof(doublereal));
				}


				// Выбираем integer i_gold_i8 наиболее сильных.
				integer i_gold_i8 = i_my_min(i8_candidate_count/20, 100);// 100
				if (i8_candidate_count < 100) {
					i_gold_i8 = i8_candidate_count - 3;
				}
				if (1 && from_re_operation_protection0) {
					// Сортировка по возрастанию.
					// Сортировка Быстрая Ч. Хоара заимствована из модуля my_nested_dissection.cpp
					QuickSortnd(i8_candidate_arr, i8_candidate_val_arr, 0, i8_candidate_count - 1);

					if (itypemodifyinterpol == 2) {
						// minimum
						//for (integer i_9 = i8_candidate_count - 1; i_9 >= i8_candidate_count - 1 - i_gold_i8; i_9--) {
						for (integer i_9 = 0; i_9 < i_gold_i8; i_9++) {
							// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
							// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
							// модификация 2 декабря 2016 года.
							this_is_F_node[i8_candidate_arr[i_9]] = false; // Этот узел Дирихле станет С нодом.
							this_is_C_node[i8_candidate_arr[i_9]] = true;
							bweSholdbeContinue = true;
							iadditionalCstatistic++;
							byes_add = true; // Были добавления узлов.
						}
					}
					if (itypemodifyinterpol == 3) {
						// maximum
						for (integer i_9 = i8_candidate_count - 1; i_9 >= i8_candidate_count - 1 - i_gold_i8; i_9--) {
							//for (integer i_9 = 0; i_9 < i_gold_i8; i_9++) {
							// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
							// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
							// модификация 2 декабря 2016 года.
							this_is_F_node[i8_candidate_arr[i_9]] = false; // Этот узел Дирихле станет С нодом.
							this_is_C_node[i8_candidate_arr[i_9]] = true;
							bweSholdbeContinue = true;
							iadditionalCstatistic++;
							byes_add = true; // Были добавления узлов.
						}
					}

				}

				ifrom_re_operation_protection++;
				if (ifrom_re_operation_protection > inumberadaptpass) {
					from_re_operation_protection0 = false;
				}


			}

			if (i8_candidate_arr != nullptr) {
				free(i8_candidate_arr);
				i8_candidate_arr = nullptr;
			}
			if (i8_candidate_val_arr != nullptr) {
				free(i8_candidate_val_arr);
				i8_candidate_val_arr = nullptr;
			}

		}
		else {
			// only negative connections

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {



				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполяции а значит и оператора Галёркина.
				doublerealT maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
				if (!btreshold_on_new_vetv) {
					for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j]  ) {
							if ((Amat[is0].aij < 0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
				}
				else {
					maxelem_threshold = threshold_quick_only_negative[Amat[ii1].i];
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublerealT sumP = 0.0;
				doublerealT SumPall = 0.0;
				integer icount_StronglyF = 0;
				doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
				doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
				for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j]  ) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j]  ) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполяцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				{

					if ((icsos == 1) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						//SumPall += sumP;

						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
									if (this_is_C_node[Amat[is0].j]  ) {

										// 20 января 2016.
										// По-моему этой ситуации вообще быть не может так как у нас 
										// заведомо один С сосед.
										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all neighbour is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											byes_add = true; // Были добавления узлов.
															 //exit(1);
															 // здесь нужна непрямая интерполяция.
										}


									}

								}
							}
						}
					}
					else {

						integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
						for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
							if (this_is_C_node[Amat[is0].j]  ) {
								if (Amat[is0].j != Amat[ii1].i) {


									// 20 jan 2016.
									// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


									if (fabs(sumP) < RealZERO) {
										// Это случай когда вообще нет сильных С соседей.


										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true; // Были добавления узлов.
														 //exit(1);
														 // здесь нужна непрямая интерполяция.
									}


								}
							}
						}
					}

				}

			}


		}

	}



	if (!byes_add) {

		// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
		//------>doublerealT magic = 0.4; // 0.4 optimum
								 //magic = 0.3; // 3 июля 2016 для конвективных задач
								 // линейный прогноз не дает улучшений
								 // ни по быстрдействию ни по числу V циклов.
								 //magic = 0.5 - 0.2*ilevel / 12.0;
		const doublerealT magic = magic82;// 0.4 is recomended.



		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

		if (bpositive_connections) {

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполяции а значит и оператора Галёркина.
				doublerealT maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				integer istr_etalon1 = Amat[ii1].i;
				integer iend_for1 = -1;
				if (!btreshold_on_new_vetv) {
					for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
						iend_for1 = is0;
						if (Amat[is0].j != istr_etalon1) {
							// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j]  ) {
							if (fabs(Amat[is0].aij) > maxelem_threshold) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
				}
				else {
					for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
						iend_for1 = is0;
					}
					maxelem_threshold = threshold_quick_all[istr_etalon1];
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
				doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublerealT sumP = 0.0;
				doublerealT SumPall = 0.0;
				integer icount_StronglyF = 0;
				//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				for (integer is0 = ii1; is0 <= iend_for1; is0++) {
					if (Amat[is0].j != istr_etalon1) {
						if (this_is_C_node[Amat[is0].j]  ) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j]  ) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
								if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполяцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false) && (icsos == 1)) {
					this_is_F_node[i8] = false;
					this_is_C_node[i8] = true;
					bweSholdbeContinue = true;
				}
				else {

					if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
						//if (((icsos == 1) || (icsos == 2) || (icsos == 3) || (icsos >= 4)) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						SumPall += sumP;

						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.


								if (this_is_C_node[Amat[is0].j]  ) {
									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all neighbour is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполяция.
										}
										else {
											// Это как раз единственная Strong C связь. 
											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
												P[icount1].j = (integer_mix_precision)(i8);
												P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
												//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												if (fabs(SumPall) < 1.0e-33) {
													printf("error 1.0 ! division by zero. SumPall =%e\n", SumPall);
													//getchar();
													system("PAUSE");
													exit(1);
												}
												P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}

										}
									}

								}
								else
									if (this_is_F_node[Amat[is0].j]  ) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
										if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
											// Рассматриваем Strong F связи.

											// Смысл:
											// 



											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											// Это лишнее условие, ранее уже было проверено что мы имеем дело
											// с сильной F связью.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

											integer iFpoint = Amat[is0].j;
											if (fabs(SumPall) < 1.0e-33) {
												printf("error 2.0 ! division by zero. SumPall =%e\n", SumPall);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublerealT maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											integer istr_etalon = Amat[ii1_loc].i;
											integer iend_for = -1;
											integer iend_marker_position = row_startA[istr_etalon + 1] - 1;
											for (integer is0_loc = ii1_loc; (is0_loc <= iend_marker_position); is0_loc++) {
												iend_for = is0_loc;
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														if (Amat[is0_loc].j != istr_etalon) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}

											doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc = 0.0;
											//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

												// Будем отсекать сразу наибольшее число вариантов.
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {






													if (this_is_C_node[Amat[is0_loc].j]  ) {

														if (Amat[is0_loc].j != istr_etalon) {

															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}

													}
													else {

														//if (Amat[is0_loc].j != istr_etalon) {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
														//}
													}

												}
											}

											doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

											// В общем это двойная интерполяционная сумма 
											//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

												// При многоуровневом сравнении в первую очередь надо отсекать наибольшее число вариантов.


												// Внедиагональный элемент из множества С узлов.

												// Данная вставка должна существенно сохранять 
												// разреженность оператора Галёркина на глубоких 
												// сеточных уровнях.
												// Модификация 5 декабря 2015.
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
													//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {

													if (this_is_C_node[Amat[is0_loc].j]  ) {
														if (Amat[is0_loc].j != istr_etalon) {

															P[icount1].j = (integer_mix_precision)(i8);
															P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															if (fabs(sumP_loc) < 1.0e-33) {
																printf("error 3.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
																//getchar();
																system("PAUSE");
																exit(1);
															}
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P);
															}

														}
													}
												}
											}


											//}
										}
									}
							}

						}
					}
					else {

						// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
						// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
						// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
						// bmodify_interpol4_amg = false;
						// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
						bool bmodify_interpol4_amg = false;
						doublerealT magic2 = 0.5;
						//magic2 = magic83;

						// Подготовительный этап к усилению четвертой интерполяции 
						// Усиление интерполяции происходит без добавления новых С узлов.
						// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
						// имеется конечно.
						// Подготовительный этап заключается в определении положения is0_candidate самой сильной
						// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
						doublerealT sum1 = 0.0;
						integer is0_candidate = -1;
						if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
										if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
											if (fabs(Amat[is0].aij) > sum1) {
												sum1 = fabs(Amat[is0].aij);
												is0_candidate = is0;
											}
										}
									}
								}
							}

							if (sum1 / sumP < magic2) {
								// Если найденный элемент слишком слабый ничего не делаем с этим С,
								// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
								sum1 = 0.0;
								is0_candidate = -1;

								// Тогда ищем среди Weakly F узлов кандидата.
								for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j]  ) {
											//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
											if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
												if (fabs(Amat[is0].aij) > sum1) {
													sum1 = fabs(Amat[is0].aij);
													is0_candidate = is0;
												}
											}
										}
									}
								}

								// такой узел F должен стать новым С узлом.
								if (sum1 / sumP >= magic2) {
									this_is_F_node[i8] = false; // Этот узел  станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									byes_add = true;
									iadditionalCstatistic++;

								}
								// Обязательный сброс перед рестартом чтобы не было деления на ноль.
								sum1 = 0.0;
								is0_candidate = -1;

							}
						}


						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {



									if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
										// Мы усиливаем силу интерполяции без добавления новых узлов за
										// счёт одной дополнительной самой сильной Weakly C связи.
										// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

										ioneStrongC_and_0_StrongF++;
										if (is0_candidate != -1) {
											P[icount1].j = (integer_mix_precision)(i8);
											P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_candidate].j]);
											P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
											P[icount1].j = (integer_mix_precision)(i8);
											P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
											P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}
									}
									else {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all neighbour is F");
											//system("pause");
											//printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполяция.
										}
										else {

											// интерполяция только по ближайшим С узлам.

											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
												P[icount1].j = (integer_mix_precision)(i8);
												P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
												if (fabs(sumP) < 1.0e-33) {
													// Несколько опорных С узлов, они являются главными опорами при интерполяции.
													// (fabs(Amat[is0].aij) / sumP) не может быть больше единицы по определению. 
													if ((fabs(sumP) < 1.0e-100) || (/*(fabs(sumP) >= 1.0e-100) &&*/ ((fabs(Amat[is0].aij) / sumP) < 0.1))) {
														printf("error 4.0 ! division by zero. sumP =%e\n", sumP);
														// Ситуация: fabs(Amat[is0].aij) / sumP==1.0, Amat[is0].aij<1.0e-33;
														printf("diagnostic: aij=%e aij/sumP=%e\n", Amat[is0].aij, fabs(Amat[is0].aij) / sumP);
														//getchar();
														system("PAUSE");
														exit(1);
													}
												}
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}

										}

									}

								}
							}
						}
					}

				}
			}
			////
		}
		else {
			// only negative connections.

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполяции а значит и оператора Галёркина.
				doublerealT maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				integer istr_etalon1 = Amat[ii1].i;
				integer iend_for1 = -1;
				if (!btreshold_on_new_vetv) {
					for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
						iend_for1 = is0;
						if (Amat[is0].j != istr_etalon1) {
							// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j]  ) {
							if ((Amat[is0].aij < 0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
				}
				else {
					for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
						iend_for1 = is0;
					}
					maxelem_threshold = threshold_quick_only_negative[istr_etalon1];
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
				doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublerealT sumP = 0.0;
				doublerealT SumPall = 0.0;
				integer icount_StronglyF = 0;
				//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				for (integer is0 = ii1; is0 <= iend_for1; is0++) {
					if (Amat[is0].j != istr_etalon1) {
						if (this_is_C_node[Amat[is0].j]  ) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j]  ) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполяцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false) && (icsos == 1)) {
					this_is_F_node[i8] = false;
					this_is_C_node[i8] = true;
					bweSholdbeContinue = true;
				}
				else {

					if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						SumPall += sumP;

						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.


								if (this_is_C_node[Amat[is0].j]  ) {
									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all neighbour is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполяция.
										}
										else {
											// Это как раз единственная Strong C связь. 
											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
												P[icount1].j = (integer_mix_precision)(i8);
												P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
												//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												if (fabs(SumPall) < 1.0e-23) {
													printf("error 5.0 ! division by zero. SumPall =%e\n", SumPall);
													//getchar();
													system("PAUSE");
													exit(1);
												}
												P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}

										}
									}

								}
								else
									if (this_is_F_node[Amat[is0].j]  ) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
											// Рассматриваем Strong F связи.

											// Смысл:
											// 



											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											// Это лишнее условие, ранее уже было проверено что мы имеем дело
											// с сильной F связью.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

											integer iFpoint = Amat[is0].j;
											doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublerealT maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											integer istr_etalon = Amat[ii1_loc].i;
											integer iend_for = -1;
											integer iend_marker_position = row_startA[istr_etalon + 1] - 1;
											for (integer is0_loc = ii1_loc; (is0_loc <= iend_marker_position); is0_loc++) {
												iend_for = is0_loc;
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														if (Amat[is0_loc].j != istr_etalon) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}

											doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc = 0.0;
											//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

												// Будем отсекать сразу наибольшее число вариантов.
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {






													if (this_is_C_node[Amat[is0_loc].j]  ) {

														if (Amat[is0_loc].j != istr_etalon) {

															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}

													}
													else {

														//if (Amat[is0_loc].j != istr_etalon) {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
														//}
													}

												}
											}

											doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

											// В общем это двойная интерполяционная сумма 
											//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

												// При многоуровневом сравнении в первую очередь надо отсекать наибольшее число вариантов.


												// Внедиагональный элемент из множества С узлов.

												// Данная вставка должна существенно сохранять 
												// разреженность оператора Галёркина на глубоких 
												// сеточных уровнях.
												// Модификация 5 декабря 2015.
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
													//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {

													if (this_is_C_node[Amat[is0_loc].j]  ) {
														if (Amat[is0_loc].j != istr_etalon) {

															P[icount1].j = (integer_mix_precision)(i8);
															P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															if (fabs(sumP_loc) < 1.0e-23) {
																printf("error 6.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
																//getchar();
																system("PAUSE");
																exit(1);
															}
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P);
															}

														}
													}
												}
											}


											//}
										}
									}
							}

						}
					}
					else {

						// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
						// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
						// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
						// bmodify_interpol4_amg = false;
						// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
						bool bmodify_interpol4_amg = false;
						doublerealT magic2 = 0.5;
						//magic2 = magic83;

						// Подготовительный этап к усилению четвертой интерполяции 
						// Усиление интерполяции происходит без добавления новых С узлов.
						// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
						// имеется конечно.
						// Подготовительный этап заключается в определении положения is0_candidate самой сильной
						// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
						doublerealT sum1 = 0.0;
						integer is0_candidate = -1;
						if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
										if ((Amat[is0].aij>0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold_theta)) {
											if (fabs(Amat[is0].aij) > sum1) {
												sum1 = fabs(Amat[is0].aij);
												is0_candidate = is0;
											}
										}
									}
								}
							}

							if (sum1 / sumP < magic2) {
								// Если найденный элемент слишком слабый ничего не делаем с этим С,
								// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
								sum1 = 0.0;
								is0_candidate = -1;

								// Тогда ищем среди Weakly F узлов кандидата.
								for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j]  ) {
											//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
											if ((Amat[is0].aij>0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold_theta)) {
												if (fabs(Amat[is0].aij) > sum1) {
													sum1 = fabs(Amat[is0].aij);
													is0_candidate = is0;
												}
											}
										}
									}
								}

								// такой узел F должен стать новым С узлом.
								if (sum1 / sumP >= magic2) {
									this_is_F_node[i8] = false; // Этот узел  станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									byes_add = true;
									iadditionalCstatistic++;

								}
								// Обязательный сброс перед рестартом чтобы не было деления на ноль.
								sum1 = 0.0;
								is0_candidate = -1;

							}
						}


						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {



									if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
										// Мы усиливаем силу интерполяции без добавления новых узлов за
										// счёт одной дополнительной самой сильной Weakly C связи.
										// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

										ioneStrongC_and_0_StrongF++;
										if (is0_candidate != -1) {
											P[icount1].j = (integer_mix_precision)(i8);
											P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_candidate].j]);
											P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											P[icount1].j = (integer_mix_precision)(i8);
											P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
											P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}
									}
									else {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all neighbour is F");
											//system("pause");
											//printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполяция.
										}
										else {

											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
												P[icount1].j = (integer_mix_precision)(i8);
												P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
												if (fabs(sumP) < 1.0e-23) {
													printf("error 7.0 ! division by zero. sumP =%e\n", sumP);
													//getchar();
													system("PAUSE");
													exit(1);
												}
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}

										}

									}

								}
							}
						}
					}

				}
			} // end only negative connections

		}

	}

#if doubleintprecision == 1
	//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
	//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif

	//system("pause");

	// marker END.
} // my_interpolation_procedure_number3

  // Интерполяционная процедура №1.
template <typename doublerealT>
void my_interpolation_procedure_number1(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublerealT RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublerealT &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF,
	doublerealT &theta83, bool &btreshold_on_new_vetv, integer& ifrom_re_operation_protection,
	bool &from_re_operation_protection0, doublerealT &magic82, doublerealT* &threshold_quick_all,
	doublerealT* &threshold_quick_only_negative)
{

	// 6 december 2016.
	// Подлежит удалению Refactoring.
	const integer itypemodifyinterpol = 0; // номер модификации интерполяции. // Подлежит удалению Refactoring.
	integer inumberadaptpass = 0; // максимальное количество сканов-проходов с модификациями. // Подлежит удалению Refactoring.


	// 1.04.2017
	// Главная идея в том чтобы разделить интерполяцию по знакам,
	// отдельно положительные коэффициенты и отдельно положительные,
	// в итоге учитывается и то и то.


	//theta = 0.24;
	// theta_strong_F iter_number time,s
	// 0.21 56 22.63
	// 0.22 55 21.769
	// 0.23 52 21.488
	// 0.24 52 21.741 == theta // optimum
	// 0.26 69 24.623
	//doublerealT theta_strong_F = 0.23; // оптимальный выбор.
	doublerealT theta_strong_F = theta83; // 3 июля 2016


							  // четвёртая версия интерполяции.
	integer ioneStrongC_and_0_StrongF = 0;

	// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
	// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
	// сильных F узлов.

	//6interpolation 0.4 6.77 11 26 28.355
	//6interpolation 0.45 6.6 10 27 28.151
	//6interpolation 0.5 6.42 12 32 28.735
	//4interpolation 0.4 3.7  52 24.736 // best
	//4interpolation 0.3 3.78 13 59 27.525
	//4interpolation 0.5 3.61 12 55 25.533
	//4interpolation 0.45 3.65 10 63 30.24

	// the begining

	bool byes_add = false;
	// Быстрое добавление недостающих С узлов.
	if (1) {
		// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
		//doublerealT magic = 0.4; // 0.4 optimum


		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;



		integer i8_candidate_count = 0;
		integer* i8_candidate_arr = nullptr;
		i8_candidate_arr = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		char c1[26] = "classic_aglomerative_amg4";
		char c2[17] = "i8_candidate_arr";
		char c3[21] = "i8_candidate_val_arr";
		handle_error<integer>(i8_candidate_arr, c2,  c1, (n_a[ilevel - 1] + 1));
		doublereal* i8_candidate_val_arr = nullptr;
		i8_candidate_val_arr = (doublereal*)malloc((n_a[ilevel - 1] + 1) * sizeof(doublereal));		
		handle_error<doublereal>(i8_candidate_val_arr, c3,  c1, (n_a[ilevel - 1] + 1));

		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

#if doubleintprecision == 1
			//printf("i8=%lld n=%lld\n", i8, n_a[ilevel - 1]);
#else
			//printf("i8=%d n=%d\n", i8, n_a[ilevel - 1]);
#endif

			//getchar();


			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполяции а значит и оператора Галёркина.
			doublerealT maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
			if (!btreshold_on_new_vetv) {
				for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
						//if (this_is_C_node[Amat[is0].j]  ) {
						if (fabs(Amat[is0].aij) > maxelem_threshold) {
							maxelem_threshold = fabs(Amat[is0].aij);
						}
						//}
					}
				}
			}
			else {
				maxelem_threshold = threshold_quick_all[Amat[ii1].i];
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsos_pos = 0;
			integer icsosF = 0;
			integer icsosF_pos = 0;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublerealT sumP = 0.0;
			doublerealT sumP_pos = 0.0;
			doublerealT SumPall = 0.0;
			doublerealT SumPall_pos = 0.0;
			integer icount_StronglyF = 0;
			integer icount_StronglyF_pos = 0;

			doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
			doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
			for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j]  ) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
						if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
							sumP_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos_pos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j]  ) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
							if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
								SumPall_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF_pos++;
								icsosF_pos++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполяцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}



			// 1 января 2016 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			{

				if ((icsos == 1) && (icsosF == 0)) {



					// Накапливаем информацию.
if (itypemodifyinterpol > 0) 
					{



						if (itypemodifyinterpol > 1) {
							// запоминаем позицию кандидата на С узел.
							i8_candidate_arr[i8_candidate_count] = i8;
							// Запоминаем силу внедиагональной связи, 
							// чтобы потом выбрать наиболее сильную.
							i8_candidate_val_arr[i8_candidate_count] = sumP;
							i8_candidate_count++;
						}

						if (itypemodifyinterpol == 1) {
							// Добавляем только в том случае если количество проходов меньше максмального.
							if (ifrom_re_operation_protection < inumberadaptpass) {
								// 3 december 2016 rundom
								// не более сотни случайных добавлений на каждом уровне.
								integer id_size_873 = (integer)(n_a[ilevel - 1] / 100);
								integer id_873 = rand() % id_size_873 + 1;
								if (id_873 == 1) {
									// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
									// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
									// модификация 2 декабря 2016 года.
									this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
									byes_add = true; // Были добавления узлов.
								}
							}
						}
					}

				}
				else if ((icsos == 1) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					//SumPall += sumP;

					for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
								if (this_is_C_node[Amat[is0].j]  ) {

									// 20 января 2016.
									// По-моему этой ситуации вообще быть не может так как у нас 
									// заведомо один С сосед.
									if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true; // Были добавления узлов.
														 //exit(1);
														 // здесь нужна непрямая интерполяция.
									}


								}

							}
						}
					}
				}
				else {

					integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
					for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
						if (this_is_C_node[Amat[is0].j]  ) {
							if (Amat[is0].j != Amat[ii1].i) {


								// 20 jan 2016.
								// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


								if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
									// Это случай когда вообще нет сильных С соседей.


									//printf("error interpolation zero diagonal sumP.\n");
									//printf("Fnode all neighbour is F");
									//system("pause");
									//printf("i8 is Dirichlet node\n");
									this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
									byes_add = true; // Были добавления узлов.
													 //exit(1);
													 // здесь нужна непрямая интерполяция.
								}


							}
						}
					}
				}

			}

		}
		/////
if (itypemodifyinterpol > 0) 
		{

			if (i8_candidate_arr != nullptr) {
				i8_candidate_arr = (integer*)realloc(i8_candidate_arr, (i8_candidate_count + 2) * sizeof(integer));
			}
			if (i8_candidate_val_arr != nullptr) {
				i8_candidate_val_arr = (doublereal*)realloc(i8_candidate_val_arr, (i8_candidate_count + 2) * sizeof(doublereal));
			}


			// Выбираем integer i_gold_i8 наиболее сильных.
			integer i_gold_i8 = i_my_min(i8_candidate_count/20, 100);// 100
			if (i8_candidate_count < 100) {
				i_gold_i8 = i8_candidate_count - 3;
			}
			if (1 && from_re_operation_protection0) {
				// Сортировка по возрастанию.
				// Сортировка Быстрая Ч. Хоара заимствована из модуля my_nested_dissection.cpp
				QuickSortnd(i8_candidate_arr, i8_candidate_val_arr, 0, i8_candidate_count - 1);

				if (itypemodifyinterpol == 2) {
					// minimum
					//for (integer i_9 = i8_candidate_count - 1; i_9 >= i8_candidate_count - 1 - i_gold_i8; i_9--) {
					for (integer i_9 = 0; i_9 < i_gold_i8; i_9++) {
						// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
						// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
						// модификация 2 декабря 2016 года.
						this_is_F_node[i8_candidate_arr[i_9]] = false; // Этот узел Дирихле станет С нодом.
						this_is_C_node[i8_candidate_arr[i_9]] = true;
						bweSholdbeContinue = true;
						iadditionalCstatistic++;
						byes_add = true; // Были добавления узлов.
					}
				}
				if (itypemodifyinterpol == 3) {
					// maximum
					for (integer i_9 = i8_candidate_count - 1; i_9 >= i8_candidate_count - 1 - i_gold_i8; i_9--) {
						//for (integer i_9 = 0; i_9 < i_gold_i8; i_9++) {
						// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
						// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
						// модификация 2 декабря 2016 года.
						this_is_F_node[i8_candidate_arr[i_9]] = false; // Этот узел Дирихле станет С нодом.
						this_is_C_node[i8_candidate_arr[i_9]] = true;
						bweSholdbeContinue = true;
						iadditionalCstatistic++;
						byes_add = true; // Были добавления узлов.
					}
				}

			}

			ifrom_re_operation_protection++;
			if (ifrom_re_operation_protection > inumberadaptpass) {
				from_re_operation_protection0 = false;
			}


		}


		if (i8_candidate_arr != nullptr) {
			free(i8_candidate_arr);
			i8_candidate_arr = nullptr;
		}
		if (i8_candidate_val_arr != nullptr) {
			free(i8_candidate_val_arr);
			i8_candidate_val_arr = nullptr;
		}



	}



	if (!byes_add) {

		// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
		//---->doublerealT magic = 0.4; // 0.4 optimum
								 //magic = 0.3; // 3 июля 2016 для конвективных задач
								 // линейный прогноз не дает улучшений
								 // ни по быстрдействию ни по числу V циклов.
								 //magic = 0.5 - 0.2*ilevel / 12.0;
		const doublerealT magic = magic82; // 0.4 is recomended.



		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;



		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполяции а значит и оператора Галёркина.
			doublerealT maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			integer istr_etalon1 = Amat[ii1].i;
			integer iend_for1 = -1;
			if (!btreshold_on_new_vetv) {
				for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
					iend_for1 = is0;
					if (Amat[is0].j != istr_etalon1) {
						// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
						//if (this_is_C_node[Amat[is0].j]  ) {
						if (fabs(Amat[is0].aij) > maxelem_threshold) {
							maxelem_threshold = fabs(Amat[is0].aij);
						}
						//}
					}
				}
			}
			else {
				for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
					iend_for1 = is0;
				}
				maxelem_threshold = threshold_quick_all[istr_etalon1];
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsosF = 0;
			integer icsos_pos = 0;
			integer icsosF_pos = 0;

			doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
			doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublerealT sumP = 0.0;
			doublerealT SumPall = 0.0;
			integer icount_StronglyF = 0;
			doublerealT sumP_pos = 0.0;
			doublerealT SumPall_pos = 0.0;
			integer icount_StronglyF_pos = 0;

			//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			for (integer is0 = ii1; is0 <= iend_for1; is0++) {
				if (Amat[is0].j != istr_etalon1) {
					if (this_is_C_node[Amat[is0].j]  ) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
						if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
							sumP_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos_pos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j]  ) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
							if ((Amat[is0].aij > 0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
								SumPall_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF_pos++;
								icsosF_pos++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполяцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}



			// 1 января 2016 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {

				if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
					//if (((icsos == 1) || (icsos == 2) || (icsos == 3) || (icsos >= 4)) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					SumPall += sumP;
					SumPall_pos += sumP_pos;


					for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.


							if (this_is_C_node[Amat[is0].j]  ) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
									if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {
										// Это как раз единственная Strong C связь. 
										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											if (fabs(SumPall) < 1.0e-33) {
												printf("error 1.0 ! division by zero. SumPall =%e\n", SumPall);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}
										if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											if (fabs(SumPall_pos) < 1.0e-33) {
												printf("error 1.0 ! division by zero. SumPall_pos =%e\n", SumPall_pos);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											// Внимание !!! именно минус.
											P[icount1].aij = -fabs(Amat[is0].aij) / SumPall_pos;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}


									}
								}

							}
							else
								if (this_is_F_node[Amat[is0].j]  ) {
									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
										// Рассматриваем Strong F связи.

										// Смысл:
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall) < 1.0e-33) {
											printf("error 2.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublerealT maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										integer istr_etalon = Amat[ii1_loc].i;
										integer iend_for = -1;
										integer iend_marker_position = row_startA[istr_etalon + 1] - 1;
										for (integer is0_loc = ii1_loc; (is0_loc <= iend_marker_position); is0_loc++) {
											iend_for = is0_loc;
											if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if (Amat[is0_loc].j != istr_etalon) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}

										doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublerealT sumP_loc = 0.0;
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// Будем отсекать сразу наибольшее число вариантов.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {






												if (this_is_C_node[Amat[is0_loc].j]  ) {

													if (Amat[is0_loc].j != istr_etalon) {

														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}

												}
												else {

													//if (Amat[is0_loc].j != istr_etalon) {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
													//}
												}

											}
										}

										doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

										// В общем это двойная интерполяционная сумма 
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// При многоуровневом сравнении в первую очередь надо отсекать наибольшее число вариантов.


											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
												//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {

												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if (Amat[is0_loc].j != istr_etalon) {

														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-33) {
															printf("error 3.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}

													}
												}
											}
										}


										//}
									}
									// todo
									if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
										// Рассматриваем Strong F связи.

										// Смысл:
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall_pos) < 1.0e-33) {
											printf("error 2.0 ! division by zero. SumPall_pos =%e\n", SumPall_pos);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										// Внимание минус.
										doublerealT multiplyer_nu = -fabs(Amat[is0].aij) / SumPall_pos;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublerealT maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										integer istr_etalon = Amat[ii1_loc].i;
										integer iend_for = -1;
										integer iend_marker_position = row_startA[istr_etalon + 1] - 1;
										for (integer is0_loc = ii1_loc; (is0_loc <= iend_marker_position); is0_loc++) {
											iend_for = is0_loc;
											if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if (Amat[is0_loc].j != istr_etalon) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}

										doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublerealT sumP_loc = 0.0;
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// Будем отсекать сразу наибольшее число вариантов.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {






												if (this_is_C_node[Amat[is0_loc].j]  ) {

													if (Amat[is0_loc].j != istr_etalon) {

														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}

												}
												else {

													//if (Amat[is0_loc].j != istr_etalon) {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
													//}
												}

											}
										}

										doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

										// В общем это двойная интерполяционная сумма 
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// При многоуровневом сравнении в первую очередь надо отсекать наибольшее число вариантов.


											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
												//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {

												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if (Amat[is0_loc].j != istr_etalon) {

														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-33) {
															printf("error 3.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}

													}
												}
											}
										}


										//}
									}

								}
						}

					}
				}
				else {

					// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
					// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
					// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
					// bmodify_interpol4_amg = false;
					// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
					bool bmodify_interpol4_amg = false;
					// 01.04.2017 
					// bmodify_interpol4_amg = true совершенно не проработана
					// и её нельзя использовать.

					doublerealT magic2 = 0.5;
					//magic2 = magic83;

					// Подготовительный этап к усилению четвертой интерполяции 
					// Усиление интерполяции происходит без добавления новых С узлов.
					// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
					// имеется конечно.
					// Подготовительный этап заключается в определении положения is0_candidate самой сильной
					// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
					doublerealT sum1 = 0.0;
					integer is0_candidate = -1;
					if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
									if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
										if (fabs(Amat[is0].aij) > sum1) {
											sum1 = fabs(Amat[is0].aij);
											is0_candidate = is0;
										}
									}
								}
							}
						}

						if (sum1 / sumP < magic2) {
							// Если найденный элемент слишком слабый ничего не делаем с этим С,
							// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
							sum1 = 0.0;
							is0_candidate = -1;

							// Тогда ищем среди Weakly F узлов кандидата.
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_F_node[Amat[is0].j]  ) {
										//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
										if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
											if (fabs(Amat[is0].aij) > sum1) {
												sum1 = fabs(Amat[is0].aij);
												is0_candidate = is0;
											}
										}
									}
								}
							}

							// такой узел F должен стать новым С узлом.
							if (sum1 / sumP >= magic2) {
								this_is_F_node[i8] = false; // Этот узел  станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								byes_add = true;
								iadditionalCstatistic++;

							}
							// Обязательный сброс перед рестартом чтобы не было деления на ноль.
							sum1 = 0.0;
							is0_candidate = -1;

						}
					}


					for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j]  ) {



								if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
									// Мы усиливаем силу интерполяции без добавления новых узлов за
									// счёт одной дополнительной самой сильной Weakly C связи.
									// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

									ioneStrongC_and_0_StrongF++;
									if (is0_candidate != -1) {
										P[icount1].j = i8;
										P[icount1].i = C_numerate[Amat[is0_candidate].j];
										P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P);
										}
									}

									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
										P[icount1].j = i8;
										P[icount1].i = C_numerate[Amat[is0].j];
										P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P);
										}
									}
								}
								else {

									if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {

										// интерполяция только по ближайшим С узлам.

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											if (fabs(sumP) < 1.0e-33) {
												printf("error 4.0 ! division by zero. sumP =%e\n", sumP);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

										if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											if (fabs(sumP_pos) < 1.0e-33) {
												printf("error 4.0 ! division by zero. sumP_pos =%e\n", sumP_pos);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = -fabs(Amat[is0].aij) / sumP_pos;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}

							}
						}
					}
				}

			}
		}
		////

	}

#if doubleintprecision == 1
	//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
	//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif

	//system("pause");
	
} // my_interpolation_procedure_number1

  // Интерполяционная процедура №0.
template <typename doublerealT>
void my_interpolation_procedure_number0(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublerealT RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublerealT &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF,
	doublerealT &theta83, bool &btreshold_on_new_vetv, integer& ifrom_re_operation_protection,
	bool &from_re_operation_protection0, doublerealT &magic82, doublerealT* &threshold_quick_all,
	doublerealT* &threshold_quick_only_negative)
{

	// 6 december 2016.
	// Подлежит удалению Refactoring.
	const integer itypemodifyinterpol = 0; // номер модификации интерполяции. // Подлежит удалению Refactoring.
	integer inumberadaptpass = 0; // максимальное количество сканов-проходов с модификациями. // Подлежит удалению Refactoring.


	// 1.04.2017; 28.04.2017;
	// Главная идея в том чтобы разделить интерполяцию по знакам, отдельно положительные коэффициенты и отдельно положительные,
	// в итоге учитывается и то и то.


	//theta = 0.24;
	// theta_strong_F iter_number time,s
	// 0.21 56 22.63
	// 0.22 55 21.769
	// 0.23 52 21.488
	// 0.24 52 21.741 == theta // optimum
	// 0.26 69 24.623

	// PIONER RS2
	// theta_interpol magic iter_number residual #levels
	// 0.24 0.24  0.4 21 1.850831e7 13
	// 0.24 0.23 0.4 21 1.661238e+07 14 
	// 0.24 0.22 0.4 21 1.268147e+07 14 optimum
	// 0.24 0.21 0.4 20 1.086504e+07 14
	// 0.24 0.2 0.4 21 2.116516e+07 14
	// 0.25 0.2 0.4 21 1.756896e+07 13
	// 0.25 0.2 0.4 21 1.631888e+07 10 RS1
	// 0.25 0.2 0.4 21 1.928085e+07 11 RS1
	// 0.25 0.2 0.35 21 1.426122e+07 11 RS1
	// 0.25 0.2 0.35 21 1.342786e+07 10 RS1 0.5pos con
	// 0.25 0.2 0.4 21 1.148286e+07 11 RS1 0.5pos con
	// 0.25 0.22 0.4 22 1.430474e+07 11 RS1 0.5pos con
	// 0.25 0.25 0.4


	//doublerealT theta_strong_C = 0.23;
	//doublerealT theta_strong_F = 0.23; // оптимальный выбор.
	doublerealT theta_strong_F = theta83; // 3 июля 2016
	doublerealT theta_strong_C = theta83;
	//theta_strong_F = 0.22; // 29 апреля 2017
	//theta_strong_C = 0.22;
	// четвёртая версия интерполяции.
	integer ioneStrongC_and_0_StrongF = 0;

	// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
	// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
	// сильных F узлов.

	//6interpolation 0.4 6.77 11 26 28.355
	//6interpolation 0.45 6.6 10 27 28.151
	//6interpolation 0.5 6.42 12 32 28.735
	//4interpolation 0.4 3.7  52 24.736 // best
	//4interpolation 0.3 3.78 13 59 27.525
	//4interpolation 0.5 3.61 12 55 25.533
	//4interpolation 0.45 3.65 10 63 30.24

	// the begining

	bool byes_add = false;
	// Быстрое добавление недостающих С узлов.
	if (1) {
		// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
		//doublerealT magic = 0.4; // 0.4 optimum


		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;



		integer i8_candidate_count = 0;
		integer* i8_candidate_arr = nullptr;
		i8_candidate_arr = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		char c1[26] = "classic_aglomerative_amg4";
		char c2[17] = "i8_candidate_arr";
		char c3[21] = "i8_candidate_val_arr";
		handle_error<integer>(i8_candidate_arr, c2,  c1, (n_a[ilevel - 1] + 1));
		doublereal* i8_candidate_val_arr = nullptr;
		i8_candidate_val_arr = (doublereal*)malloc((n_a[ilevel - 1] + 1) * sizeof(doublereal));
		handle_error<doublereal>(i8_candidate_val_arr, c3,  c1, (n_a[ilevel - 1] + 1));

		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

#if doubleintprecision == 1
			//printf("i8=%lld n=%lld\n", i8, n_a[ilevel - 1]);
#else
			//printf("i8=%d n=%d\n", i8, n_a[ilevel - 1]);
#endif

			//getchar();


			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполяции а значит и оператора Галёркина.
			doublerealT maxelem_threshold_plus = -1.0;
			doublerealT maxelem_threshold_minus = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
			for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j]  ) {
					if ((Amat[is0].aij>0) && (fabs(Amat[is0].aij) > maxelem_threshold_plus)) {
						maxelem_threshold_plus = fabs(Amat[is0].aij);
					}
					if ((Amat[is0].aij<0) && (fabs(Amat[is0].aij) > maxelem_threshold_minus)) {
						maxelem_threshold_minus = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsos_pos = 0;
			integer icsosF = 0;
			integer icsosF_pos = 0;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublerealT sumP = 0.0;
			doublerealT sumP_pos = 0.0;
			doublerealT SumPall = 0.0;
			doublerealT SumPall_pos = 0.0;
			integer icount_StronglyF = 0;
			integer icount_StronglyF_pos = 0;

			doublerealT maxelem_threshold_theta_plus = maxelem_threshold_plus*theta_strong_C;
			doublerealT maxelem_threshold_theta_strong_F_plus = maxelem_threshold_plus*theta_strong_F;
			// сомнительно.
			//doublerealT maxelem_threshold_theta_plus = maxelem_threshold_plus*0.5;
			//doublerealT maxelem_threshold_theta_strong_F_plus = maxelem_threshold_plus*0.5;
			doublerealT maxelem_threshold_theta_minus = maxelem_threshold_minus*theta_strong_C;
			doublerealT maxelem_threshold_theta_strong_F_minus = maxelem_threshold_minus*theta_strong_F;
			for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j]  ) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
						if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_plus)) {
							sumP_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos_pos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j]  ) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_minus)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
							if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_plus)) {
								SumPall_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF_pos++;
								icsosF_pos++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполяцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}



			// 1 января 2016 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			{

				if ((icsos == 1) && (icsosF == 0)) {



					// Накапливаем информацию.
if (itypemodifyinterpol > 0)
					{



						if (itypemodifyinterpol > 1) {
							// запоминаем позицию кандидата на С узел.
							i8_candidate_arr[i8_candidate_count] = i8;
							// Запоминаем силу внедиагональной связи, 
							// чтобы потом выбрать наиболее сильную.
							i8_candidate_val_arr[i8_candidate_count] = sumP;
							i8_candidate_count++;
						}

						if (itypemodifyinterpol == 1) {
							// Добавляем только в том случае если количество проходов меньше максмального.
							if (ifrom_re_operation_protection < inumberadaptpass) {
								// 3 december 2016 rundom
								// не более сотни случайных добавлений на каждом уровне.
								integer id_size_873 = (integer)(n_a[ilevel - 1] / 100);
								integer id_873 = rand() % id_size_873 + 1;
								if (id_873 == 1) {
									// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
									// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
									// модификация 2 декабря 2016 года.
									this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
									byes_add = true; // Были добавления узлов.
								}
							}
						}
					}

				}
				else if ((icsos == 1) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					//SumPall += sumP;

					for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							if (((Amat[is0].aij<0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) || (((Amat[is0].aij>0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_plus)))) {
								if (this_is_C_node[Amat[is0].j]  ) {

									// 20 января 2016.
									// По-моему этой ситуации вообще быть не может так как у нас 
									// заведомо один С сосед.
									if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true; // Были добавления узлов.
														 //exit(1);
														 // здесь нужна непрямая интерполяция.
									}


								}

							}
						}
					}
				}
				else {

					integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
					for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
						if (this_is_C_node[Amat[is0].j]  ) {
							if (Amat[is0].j != Amat[ii1].i) {


								// 20 jan 2016.
								// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


								if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
									// Это случай когда вообще нет сильных С соседей.


									//printf("error interpolation zero diagonal sumP.\n");
									//printf("Fnode all neighbour is F");
									//system("pause");
									//printf("i8 is Dirichlet node\n");
									this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
									byes_add = true; // Были добавления узлов.
													 //exit(1);
													 // здесь нужна непрямая интерполяция.
								}


							}
						}
					}
				}

			}

		}
		/////
if (itypemodifyinterpol > 0) 
		{


			if (i8_candidate_arr != nullptr) {
				i8_candidate_arr = (integer*)realloc(i8_candidate_arr, (i8_candidate_count + 2) * sizeof(integer));
			}
			if (i8_candidate_val_arr != nullptr) {
				i8_candidate_val_arr = (doublereal*)realloc(i8_candidate_val_arr, (i8_candidate_count + 2) * sizeof(doublereal));
			}


			// Выбираем integer i_gold_i8 наиболее сильных.
			integer i_gold_i8 = i_my_min(i8_candidate_count/20, 100);// 100
			if (i8_candidate_count < 100) {
				i_gold_i8 = i8_candidate_count - 3;
			}
			if (1 && from_re_operation_protection0) {
				// Сортировка по возрастанию.
				// Сортировка Быстрая Ч. Хоара заимствована из модуля my_nested_dissection.cpp
				QuickSortnd(i8_candidate_arr, i8_candidate_val_arr, 0, i8_candidate_count - 1);

				if (itypemodifyinterpol == 2) {
					// minimum
					//for (integer i_9 = i8_candidate_count - 1; i_9 >= i8_candidate_count - 1 - i_gold_i8; i_9--) {
					for (integer i_9 = 0; i_9 < i_gold_i8; i_9++) {
						// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
						// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
						// модификация 2 декабря 2016 года.
						this_is_F_node[i8_candidate_arr[i_9]] = false; // Этот узел Дирихле станет С нодом.
						this_is_C_node[i8_candidate_arr[i_9]] = true;
						bweSholdbeContinue = true;
						iadditionalCstatistic++;
						byes_add = true; // Были добавления узлов.
					}
				}
				if (itypemodifyinterpol == 3) {
					// maximum
					for (integer i_9 = i8_candidate_count - 1; i_9 >= i8_candidate_count - 1 - i_gold_i8; i_9--) {
						//for (integer i_9 = 0; i_9 < i_gold_i8; i_9++) {
						// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
						// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
						// модификация 2 декабря 2016 года.
						this_is_F_node[i8_candidate_arr[i_9]] = false; // Этот узел Дирихле станет С нодом.
						this_is_C_node[i8_candidate_arr[i_9]] = true;
						bweSholdbeContinue = true;
						iadditionalCstatistic++;
						byes_add = true; // Были добавления узлов.
					}
				}

			}

			ifrom_re_operation_protection++;
			if (ifrom_re_operation_protection > inumberadaptpass) {
				from_re_operation_protection0 = false;
			}


		}


		if (i8_candidate_arr != nullptr) {
			free(i8_candidate_arr);
			i8_candidate_arr = nullptr;
		}
		if (i8_candidate_val_arr != nullptr) {
			free(i8_candidate_val_arr);
			i8_candidate_val_arr = nullptr;
		}



	}



	if (!byes_add) {

		// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
		//doublerealT magic = 0.4; // 0.4 optimum
								 //magic = 0.3; // 3 июля 2016 для конвективных задач
								 // линейный прогноз не дает улучшений
								 // ни по быстрдействию ни по числу V циклов.
								 //magic = 0.5 - 0.2*ilevel / 12.0;
		const doublerealT magic = magic82; // 0.4 is recomended.
		//magic = 0.35;



		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;



		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполяции а значит и оператора Галёркина.
			doublerealT maxelem_threshold_plus = -1.0;
			doublerealT maxelem_threshold_minus = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			integer istr_etalon1 = Amat[ii1].i;
			integer iend_for1 = -1;
			for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
				iend_for1 = is0;
				if (Amat[is0].j != istr_etalon1) {
					// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j]  ) {
					if ((Amat[is0].aij>0) && (fabs(Amat[is0].aij) > maxelem_threshold_plus)) {
						maxelem_threshold_plus = fabs(Amat[is0].aij);
					}
					if ((Amat[is0].aij<0) && (fabs(Amat[is0].aij) > maxelem_threshold_minus)) {
						maxelem_threshold_minus = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsosF = 0;
			integer icsos_pos = 0;
			integer icsosF_pos = 0;

			doublerealT maxelem_threshold_theta_plus = maxelem_threshold_plus*theta_strong_C;
			doublerealT maxelem_threshold_theta_strong_F_plus = maxelem_threshold_plus*theta_strong_F;
			//doublerealT maxelem_threshold_theta_plus = maxelem_threshold_plus*0.5;
			//doublerealT maxelem_threshold_theta_strong_F_plus = maxelem_threshold_plus*0.5;
			doublerealT maxelem_threshold_theta_minus = maxelem_threshold_minus*theta_strong_C;
			doublerealT maxelem_threshold_theta_strong_F_minus = maxelem_threshold_minus*theta_strong_F;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublerealT sumP = 0.0;
			doublerealT SumPall = 0.0;
			integer icount_StronglyF = 0;
			doublerealT sumP_pos = 0.0;
			doublerealT SumPall_pos = 0.0;
			integer icount_StronglyF_pos = 0;

			//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			for (integer is0 = ii1; is0 <= iend_for1; is0++) {
				if (Amat[is0].j != istr_etalon1) {
					if (this_is_C_node[Amat[is0].j]  ) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
						if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_plus)) {
							sumP_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos_pos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j]  ) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_minus)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
							if ((Amat[is0].aij > 0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_plus)) {
								SumPall_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF_pos++;
								icsosF_pos++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполяцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}



			// 1 января 2016 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {

				if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
					// так лучше всего.
					//if ((((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0))||(((icsos_pos == 1) || (icsos_pos == 2) || (icsos_pos == 3)) && (icsosF_pos != 0))) {
					//	if (((icsos == 1) || (icsos == 2) || (icsos == 3) || (icsos >= 4)) && (icsosF != 0)) {
					//if ((((icsos == 1) || (icsos == 2) || (icsos == 3) || (icsos >= 4)) && (icsosF != 0)) || (((icsos_pos == 1) || (icsos_pos == 2) || (icsos_pos == 3) || (icsos_pos >= 4)) && (icsosF_pos != 0))) {

					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					SumPall += sumP;
					SumPall_pos += sumP_pos;


					for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.


							if (this_is_C_node[Amat[is0].j]  ) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								if (((Amat[is0].aij<0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) || ((Amat[is0].aij>0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_plus))) {
									if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {
										// Это как раз единственная Strong C связь. 
										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											if (fabs(SumPall) < 1.0e-33) {
												printf("error 1.0 ! division by zero. SumPall =%e\n", SumPall);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}
										if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_plus)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											if (fabs(SumPall_pos) < 1.0e-33) {
												printf("error 1.0 ! division by zero. SumPall_pos =%e\n", SumPall_pos);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											// Внимание !!! именно минус.
											P[icount1].aij = -fabs(Amat[is0].aij) / SumPall_pos;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}


									}
								}

							}
							else
								if (this_is_F_node[Amat[is0].j]  ) {
									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_minus)) {
										// Рассматриваем Strong F связи.

										// Смысл:
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall) < 1.0e-33) {
											printf("error 2.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublerealT maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										integer istr_etalon = Amat[ii1_loc].i;
										integer iend_for = -1;
										integer iend_marker_position = row_startA[istr_etalon + 1] - 1;
										for (integer is0_loc = ii1_loc; (is0_loc <= iend_marker_position); is0_loc++) {
											iend_for = is0_loc;
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if (Amat[is0_loc].j != istr_etalon) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}

										doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublerealT sumP_loc = 0.0;
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// Будем отсекать сразу наибольшее число вариантов.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {






												if (this_is_C_node[Amat[is0_loc].j]  ) {

													if (Amat[is0_loc].j != istr_etalon) {

														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}

												}
												else {

													//if (Amat[is0_loc].j != istr_etalon) {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
													//}
												}

											}
										}

										doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

										// В общем это двойная интерполяционная сумма 
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// При многоуровневом сравнении в первую очередь надо отсекать наибольшее число вариантов.


											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
												//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {

												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if (Amat[is0_loc].j != istr_etalon) {

														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-33) {
															printf("error 3.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}

													}
												}
											}
										}


										//}
									}
									// todo
									if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_plus)) {
										// Рассматриваем Strong F связи.

										// Смысл:
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall_pos) < 1.0e-33) {
											printf("error 2.0 ! division by zero. SumPall_pos =%e\n", SumPall_pos);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										// Внимание минус.
										doublerealT multiplyer_nu = -fabs(Amat[is0].aij) / SumPall_pos;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublerealT maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										integer istr_etalon = Amat[ii1_loc].i;
										integer iend_for = -1;
										integer iend_marker_position = row_startA[istr_etalon + 1] - 1;
										for (integer is0_loc = ii1_loc; (is0_loc <= iend_marker_position); is0_loc++) {
											iend_for = is0_loc;
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if (Amat[is0_loc].j != istr_etalon) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}

										doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublerealT sumP_loc = 0.0;
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// Будем отсекать сразу наибольшее число вариантов.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {






												if (this_is_C_node[Amat[is0_loc].j]  ) {

													if (Amat[is0_loc].j != istr_etalon) {

														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}

												}
												else {

													//if (Amat[is0_loc].j != istr_etalon) {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
													//}
												}

											}
										}

										doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

										// В общем это двойная интерполяционная сумма 
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// При многоуровневом сравнении в первую очередь надо отсекать наибольшее число вариантов.


											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
												//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {

												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if (Amat[is0_loc].j != istr_etalon) {

														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-33) {
															printf("error 3.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}

													}
												}
											}
										}


										//}
									}

								}
						}

					}
				}
				else {

					// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
					// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
					// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
					// bmodify_interpol4_amg = false;
					// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
					bool bmodify_interpol4_amg = false;
					// 01.04.2017 
					// bmodify_interpol4_amg = true совершенно не проработана
					// и её нельзя использовать.

					doublerealT magic2 = 0.5;
					//magic2 = magic83;

					// Подготовительный этап к усилению четвертой интерполяции 
					// Усиление интерполяции происходит без добавления новых С узлов.
					// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
					// имеется конечно.
					// Подготовительный этап заключается в определении положения is0_candidate самой сильной
					// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
					doublerealT sum1 = 0.0;
					integer is0_candidate = -1;
					if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) <= maxelem_threshold_theta_minus)) {
										if (fabs(Amat[is0].aij) > sum1) {
											sum1 = fabs(Amat[is0].aij);
											is0_candidate = is0;
										}
									}
								}
							}
						}

						if (sum1 / sumP < magic2) {
							// Если найденный элемент слишком слабый ничего не делаем с этим С,
							// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
							sum1 = 0.0;
							is0_candidate = -1;

							// Тогда ищем среди Weakly F узлов кандидата.
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_F_node[Amat[is0].j]  ) {
										//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) <= maxelem_threshold_theta_minus)) {
											if (fabs(Amat[is0].aij) > sum1) {
												sum1 = fabs(Amat[is0].aij);
												is0_candidate = is0;
											}
										}
									}
								}
							}

							// такой узел F должен стать новым С узлом.
							if (sum1 / sumP >= magic2) {
								this_is_F_node[i8] = false; // Этот узел  станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								byes_add = true;
								iadditionalCstatistic++;

							}
							// Обязательный сброс перед рестартом чтобы не было деления на ноль.
							sum1 = 0.0;
							is0_candidate = -1;

						}
					}


					for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j]  ) {



								if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
									// Мы усиливаем силу интерполяции без добавления новых узлов за
									// счёт одной дополнительной самой сильной Weakly C связи.
									// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

									ioneStrongC_and_0_StrongF++;
									if (is0_candidate != -1) {
										P[icount1].j = i8;
										P[icount1].i = C_numerate[Amat[is0_candidate].j];
										P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P);
										}
									}

									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) {
										P[icount1].j = i8;
										P[icount1].i = C_numerate[Amat[is0].j];
										P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P);
										}
									}
								}
								else {

									if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {

										// интерполяция только по ближайшим С узлам.

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											if (fabs(sumP) < 1.0e-33) {
												printf("error 4.0 ! division by zero. sumP =%e\n", sumP);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

										if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_plus)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											if (fabs(sumP_pos) < 1.0e-33) {
												printf("error 4.0 ! division by zero. sumP_pos =%e\n", sumP_pos);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = -fabs(Amat[is0].aij) / sumP_pos;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}

							}
						}
					}
				}

			}
		}
		////

	}

#if doubleintprecision == 1
	//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
	//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif

	//system("pause");


} // my_interpolation_procedure_number0


  // Интерполяционная процедура №4.
template <typename doublerealT>
void my_interpolation_procedure_number4(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublerealT RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublerealT &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF,
	doublerealT &theta83, bool &btreshold_on_new_vetv, integer& ifrom_re_operation_protection,
	bool &from_re_operation_protection0, doublerealT &magic82, doublerealT* &threshold_quick_all,
	doublerealT* &threshold_quick_only_negative)
{
	// пятая попытка.
	// показывает время 1.22 против времени в 1.36 в четвертой попытке.

	// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
	// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
	// сильных F узлов.

	the_number_of_neighbors_that_are_not_C_nodes = 0;
	number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

	if (bpositive_connections) {

		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {



			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполяции а значит и оператора Галёркина.
			doublerealT maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j]  ) {
					if (fabs(Amat[is0].aij) > maxelem_threshold) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsosF = 0;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublerealT sumP = 0.0;
			doublerealT SumPall = 0.0;
			integer icount_StronglyF = 0;
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j]  ) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j]  ) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполяцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}



			// 1 января 2016 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {

				if ((icsos == 1) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					SumPall += sumP;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								if (this_is_C_node[Amat[is0].j]  ) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										if (this_is_C_node[i8] == false) iadditionalCstatistic++;
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {
										// Это как раз единственная Strong C связь. 
										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											P[icount1].j = (integer_mix_precision)(i8);
											P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											if (fabs(SumPall) < 1.0e-23) {
												printf("error 1.0 ! division by zero. SumPall =%e\n", SumPall);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j]  ) {

										// Рассматриваем Strong F связи.

										// Смысл:
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall) < 1.0e-23) {
											printf("error 2.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublerealT maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}


										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublerealT sumP_loc = 0.0;
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {




												if (this_is_C_node[Amat[is0_loc].j]  ) {
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}
												}
												else {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
												}
											}
										}

										// В общем это двойная интерполяционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-23) {
															printf("error 3.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}


										//}
									}
							}
						}
					}
				}
				else {

					SumPall += sumP;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {

							if (this_is_C_node[Amat[is0].j]  ) {

								if (fabs(sumP) < RealZERO) {
									//printf("error interpolation zero diagonal sumP.\n");
									//printf("Fnode all neighbour is F");
									//system("pause");
									//printf("i8 is Dirichlet node\n");
									if (this_is_C_node[i8] == false) iadditionalCstatistic++;
									this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									//exit(1);
									// здесь нужна непрямая интерполяция.
								}
								else {

									// Внедиагональный элемент из множества С узлов.

									// Данная вставка должна существенно сохранять 
									// разреженность оператора Галёркина на глубоких 
									// сеточных уровнях.
									// Модификация 5 декабря 2015.
									//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										P[icount1].j = (integer_mix_precision)(i8);
										P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
										if (fabs(SumPall) < 1.0e-23) {
											printf("error 4.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
										//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P);
										}
									}

								}

							}
							else
								if (this_is_F_node[Amat[is0].j]  ) {

									// Рассматриваем Strong F связи.
									// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
									// Смысл:
									//



									//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									// Это лишнее условие, ранее уже было проверено что мы имеем дело
									// с сильной F связью.
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall) < 1.0e-23) {
											printf("error 5.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpoint
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublerealT maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}


										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublerealT sumP_loc = 0.0;
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {




												if (this_is_C_node[Amat[is0_loc].j]  ) {
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}
												}
												else {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции
												}
											}
										}

										// В общем это двойная интерполяционная сумма
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять
													// разреженность оператора Галёркина на глубоких
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-23) {
															printf("error 6.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}


										//}
									}
								}


						}
					}
				}

			}

		}
		//// positive connections
	}
	else {
		// only negative connections


		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполяции а значит и оператора Галёркина.
			doublerealT maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j]  ) {
					if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsosF = 0;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublerealT sumP = 0.0;
			doublerealT SumPall = 0.0;
			integer icount_StronglyF = 0;
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j]  ) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j]  ) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполяцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}



			// 1 января 2016 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {

				if ((icsos == 1) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					SumPall += sumP;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								if (this_is_C_node[Amat[is0].j]  ) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										if (this_is_C_node[i8] == false) iadditionalCstatistic++;
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {
										// Это как раз единственная Strong C связь. 
										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											P[icount1].j = (integer_mix_precision)(i8);
											P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											if (fabs(SumPall) < 1.0e-23) {
												printf("error 7.0 ! division by zero. SumPall =%e\n", SumPall);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j]  ) {

										// Рассматриваем Strong F связи.

										// Смысл:
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall) < 1.0e-23) {
											printf("error 8.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublerealT maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}


										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublerealT sumP_loc = 0.0;
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {




												if (this_is_C_node[Amat[is0_loc].j]  ) {
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}
												}
												else {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
												}
											}
										}

										// В общем это двойная интерполяционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-23) {
															printf("error 9.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}


										//}
									}
							}
						}
					}
				}
				else {

					SumPall += sumP;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {

							if (this_is_C_node[Amat[is0].j]  ) {

								if (fabs(sumP) < RealZERO) {
									//printf("error interpolation zero diagonal sumP.\n");
									//printf("Fnode all neighbour is F");
									//system("pause");
									//printf("i8 is Dirichlet node\n");
									if (this_is_C_node[i8] == false) iadditionalCstatistic++;
									this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									//exit(1);
									// здесь нужна непрямая интерполяция.
								}
								else {

									// Внедиагональный элемент из множества С узлов.

									// Данная вставка должна существенно сохранять 
									// разреженность оператора Галёркина на глубоких 
									// сеточных уровнях.
									// Модификация 5 декабря 2015.
									//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
										P[icount1].j = (integer_mix_precision)(i8);
										P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
										if (fabs(SumPall) < 1.0e-23) {
											printf("error 10.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
										//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P);
										}
									}

								}

							}
							else
								if (this_is_F_node[Amat[is0].j]  ) {

									// Рассматриваем Strong F связи.
									// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
									// Смысл:
									//



									//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									// Это лишнее условие, ранее уже было проверено что мы имеем дело
									// с сильной F связью.
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

										integer iFpoint = Amat[is0].j;
										doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpoint
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublerealT maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}


										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublerealT sumP_loc = 0.0;
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {




												if (this_is_C_node[Amat[is0_loc].j]  ) {
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}
												}
												else {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции
												}
											}
										}

										// В общем это двойная интерполяционная сумма
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j]  ) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять
													// разреженность оператора Галёркина на глубоких
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-23) {
															printf("error 11.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}


										//}
									}
								}


						}
					}
				}

			}

		}

	} // end only negative connections

} // my_interpolation_procedure_number4

  // Интерполяционная процедура №5.
template <typename doublerealT>
void my_interpolation_procedure_number5(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublerealT RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublerealT &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF,
	doublerealT &theta83, bool &btreshold_on_new_vetv, integer& ifrom_re_operation_protection,
	bool &from_re_operation_protection0, doublerealT &magic82, doublerealT* &threshold_quick_all,
	doublerealT* &threshold_quick_only_negative)
{
	bool byes_add = false;
	//  быстрая проверка на добавление.
	if (1) {
		// шестая попытка.
		// CGHV1J amg1r5 time 0.26
		// cl_agl_amg_v0_14 time:
		// magic  time number V cycles grid complexity
		// 0.25   0:48  29  6.55A
		// 0.3    0:45  28  6.19A 
		// 0.35  0:43   28  5.98A
		// 0.4   0:41   27  5.77A // отыграно 14% производительности.
		// tgf2023_10 amg1r5 time 1:00
		// cl_agl_amg_v0_14 time
		// magic  time number V cycles grid complexity
		// 0.25 1:49 27 3.61
		// 0.3 1:47 26 3.47
		// 0.35 1:46 27 3.51
		// 0.4 1:44 28 3.413 // отыграно 5% производительности.
		// Electric potencial in FET2 amg1r5 time 1:38
		// cl_agl_amg_v0_14 time:
		// magic  time number V cycles grid complexity
		// 0.25 3:19 36 6.65
		// 0.3 3:02 34 6.34
		// 0.35 2:52 33 6.091
		// 0.4 2:46 33 5.91 // отыграно 20% производительности.

		// magic=0.4 is optimum.11 jan 2016
		doublerealT magic = 0.4; // 0.4

								 // Здесь узел F не имеющий Strong С соседей сам становится С узлом.
								 // Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
								 // сильных F узлов.

		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

		if (bpositive_connections) {

			// positive connections:

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполяции а значит и оператора Галёркина.
				doublerealT maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
						//if (this_is_C_node[Amat[is0].j]  ) {
						if (fabs(Amat[is0].aij) > maxelem_threshold) {
							maxelem_threshold = fabs(Amat[is0].aij);
						}
						//}
					}
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublerealT sumP = 0.0;
				doublerealT SumPall = 0.0;
				integer icount_StronglyF = 0;
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j]  ) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполяцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				{

					if ((icsos == 1) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						SumPall += sumP;

						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if (this_is_C_node[Amat[is0].j]  ) {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all neighbour is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											byes_add = true;
											//exit(1);
											// здесь нужна непрямая интерполяция.
										}


									}

								}
							}
						}
					}
					else {



						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {

								if (this_is_C_node[Amat[is0].j]  ) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}


								}



							}
						}



					}

				}

			}

			/////
		}
		else {
			// only negative connections:

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполяции а значит и оператора Галёркина.
				doublerealT maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
						//if (this_is_C_node[Amat[is0].j]  ) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
							maxelem_threshold = fabs(Amat[is0].aij);
						}
						//}
					}
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublerealT sumP = 0.0;
				doublerealT SumPall = 0.0;
				integer icount_StronglyF = 0;
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j]  ) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j]  ) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполяцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				{

					if ((icsos == 1) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						SumPall += sumP;

						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									if (this_is_C_node[Amat[is0].j]  ) {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all neighbour is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											byes_add = true;
											//exit(1);
											// здесь нужна непрямая интерполяция.
										}


									}

								}
							}
						}
					}
					else {



						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {

								if (this_is_C_node[Amat[is0].j]  ) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}


								}



							}
						}



					}

				}

			}


		} // end only negative connecions.
	}


	// Проверка на добавление пройдена успешно, 
	// добавлений не было и можно интерполировать !!!.
	if (byes_add == false) {

		// шестая попытка.
		// CGHV1J amg1r5 time 0.26
		// cl_agl_amg_v0_14 time:
		// magic  time number V cycles grid complexity
		// 0.25   0:48  29  6.55A
		// 0.3    0:45  28  6.19A 
		// 0.35  0:43   28  5.98A
		// 0.4   0:41   27  5.77A // отыграно 14% производительности.
		// tgf2023_10 amg1r5 time 1:00
		// cl_agl_amg_v0_14 time
		// magic  time number V cycles grid complexity
		// 0.25 1:49 27 3.61
		// 0.3 1:47 26 3.47
		// 0.35 1:46 27 3.51
		// 0.4 1:44 28 3.413 // отыграно 5% производительности.
		// Electric potencial in FET2 amg1r5 time 1:38
		// cl_agl_amg_v0_14 time:
		// magic  time number V cycles grid complexity
		// 0.25 3:19 36 6.65
		// 0.3 3:02 34 6.34
		// 0.35 2:52 33 6.091
		// 0.4 2:46 33 5.91 // отыграно 20% производительности.

		// magic=0.4 is optimum.11 jan 2016
		doublerealT magic = 0.4; // 0.4

								 // Здесь узел F не имеющий Strong С соседей сам становится С узлом.
								 // Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
								 // сильных F узлов.

		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

		if (bpositive_connections) {

			// positive connections:

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполяции а значит и оператора Галёркина.
				doublerealT maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
						//if (this_is_C_node[Amat[is0].j]  ) {
						if (fabs(Amat[is0].aij) > maxelem_threshold) {
							maxelem_threshold = fabs(Amat[is0].aij);
						}
						//}
					}
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublerealT sumP = 0.0;
				doublerealT SumPall = 0.0;
				integer icount_StronglyF = 0;
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j]  ) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполяцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false) && (icsos == 1)) {
					this_is_F_node[i8] = false;
					this_is_C_node[i8] = true;
					bweSholdbeContinue = true;
				}
				else {

					//if ((icsos == 1) && (icsosF != 0)) {
					// 28.01.2017
					if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						SumPall += sumP;

						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if (this_is_C_node[Amat[is0].j]  ) {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all neighbour is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполяция.
										}
										else {
											// Это как раз единственная Strong C связь. 
											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												P[icount1].j = (integer_mix_precision)(i8);
												P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
												//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}

										}

									}
									else
										if (this_is_F_node[Amat[is0].j]  ) {

											// Рассматриваем Strong F связи.

											// Смысл:
											// 



											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											// Это лишнее условие, ранее уже было проверено что мы имеем дело
											// с сильной F связью.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

											integer iFpoint = Amat[is0].j;
											doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublerealT maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j]  ) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
													}
												}
											}

											// В общем это двойная интерполяционная сумма 
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
															P[icount1].j = (integer_mix_precision)(i8);
															P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P);
															}
														}
													}
												}
											}


											//}
										}
								}
							}
						}
					}
					else {

						SumPall += sumP;
						doublerealT sum_ok = 0.0;
						bool bbackreturn = false;
						integer icount1_mem = icount1;
						bool* bbackrarr = nullptr;
						//bbackrarr = new bool[icount_StronglyF];
						bbackrarr = (bool*)malloc(icount_StronglyF * sizeof(bool));
						char c1[27] = "classic_aglomerative_amg_4";
						char c2[10] = "bbackrarr";
						handle_error<bool>(bbackrarr, c2,  c1, icount_StronglyF);

						for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
							bbackrarr[i_63] = false;
						}
						integer icounter_bbackarr = -1;

						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {

								if (this_is_C_node[Amat[is0].j]  ) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											P[icount1].j = (integer_mix_precision)(i8);
											P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
											//P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											P[icount1].aij = fabs(Amat[is0].aij);
											sum_ok += fabs(Amat[is0].aij);
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j]  ) {

										// Рассматриваем Strong F связи.
										// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
										// Смысл:
										//



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

											icounter_bbackarr++;

											integer iFpoint = Amat[is0].j;
											//doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											doublerealT mult1 = fabs(Amat[is0].aij);
											// сканируем всех соседей iFpoint
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublerealT maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j]  ) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции
													}
												}
											}

											icsos_loc = 0;
											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc1 = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j]  ) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
															//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc)>maxelem_threshold*theta) {
															sumP_loc1 += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
															//	}
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции
													}
												}
											}

											if (icsos_loc > 0) {
												// В общем это двойная интерполяционная сумма
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j]  ) {
															// Внедиагональный элемент из множества С узлов.

															// Данная вставка должна существенно сохранять
															// разреженность оператора Галёркина на глубоких
															// сеточных уровнях.
															// Модификация 5 декабря 2015.
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc) > maxelem_threshold*theta) {
																P[icount1].j = (integer_mix_precision)(i8);
																P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
																//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																//P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc1;
																P[icount1].aij = mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																sum_ok += mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																icount1++;
																if (icount1 >= nsizePR*n) {
																	printf("memory error!!!\n");
																	printf("not enough memory for the interpolation operator.\n");
																	//system("PAUSE");
																	//exit(1);
																	deallocate_prolongation(nsizePR, n, R, P);
																}
															}
															//}
														}
													}
												}
											}
											else {
												//bbackreturn = true;
												bbackrarr[icounter_bbackarr] = true;
											}


											//}
										}
									}


							}
						}


						//bbackreturn = true;
						//for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
						//if (!bbackrarr[i_63]) {
						//	bbackreturn = false;
						//}
						//}

						//if (bbackreturn) {
						// сильные F связи не дали результата, поэтому мы возвращаемся к исходному 
						// варианту интерполяции.
						//for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
						//P[i_95].aij = P[i_95].aij*SumPall / sumP;
						//}
						//}

						// Апосториорная коррекция
						for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
							P[i_95].aij = P[i_95].aij / sum_ok;
						}

						free(bbackrarr);

					}

				}

			}

			////
		}
		else {
			// only negative connections

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполяции а значит и оператора Галёркина.
				doublerealT maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
						//if (this_is_C_node[Amat[is0].j]  ) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
							maxelem_threshold = fabs(Amat[is0].aij);
						}
						//}
					}
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublerealT sumP = 0.0;
				doublerealT SumPall = 0.0;
				integer icount_StronglyF = 0;
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j]  ) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j]  ) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполяцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false) && (icsos == 1)) {
					this_is_F_node[i8] = false;
					this_is_C_node[i8] = true;
					bweSholdbeContinue = true;
				}
				else {

					if ((icsos == 1) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						SumPall += sumP;

						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									if (this_is_C_node[Amat[is0].j]  ) {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all neighbour is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполяция.
										}
										else {
											// Это как раз единственная Strong C связь. 
											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												P[icount1].j = (integer_mix_precision)(i8);
												P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
												//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}

										}

									}
									else
										if (this_is_F_node[Amat[is0].j]  ) {

											// Рассматриваем Strong F связи.

											// Смысл:
											// 



											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											// Это лишнее условие, ранее уже было проверено что мы имеем дело
											// с сильной F связью.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

											integer iFpoint = Amat[is0].j;
											doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublerealT maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j]  ) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
													}
												}
											}

											// В общем это двойная интерполяционная сумма 
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
															P[icount1].j = (integer_mix_precision)(i8);
															P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P);
															}
														}
													}
												}
											}


											//}
										}
								}
							}
						}
					}
					else {

						SumPall += sumP;
						doublerealT sum_ok = 0.0;
						bool bbackreturn = false;
						integer icount1_mem = icount1;
						bool* bbackrarr = nullptr;
						//bbackrarr = new bool[icount_StronglyF];
						bbackrarr = (bool*)malloc(icount_StronglyF * sizeof(bool));
						char c1[27] = "classic_aglomerative_amg_4";
						char c2[10] = "bbackrarr";
						handle_error<bool>(bbackrarr,c2 ,  c1, icount_StronglyF);

						for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
							bbackrarr[i_63] = false;
						}
						integer icounter_bbackarr = -1;

						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {

								if (this_is_C_node[Amat[is0].j]  ) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											P[icount1].j = (integer_mix_precision)(i8);
											P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
											//P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											P[icount1].aij = fabs(Amat[is0].aij);
											sum_ok += fabs(Amat[is0].aij);
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j]  ) {

										// Рассматриваем Strong F связи.
										// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
										// Смысл:
										//



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

											icounter_bbackarr++;

											integer iFpoint = Amat[is0].j;
											//doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											doublerealT mult1 = fabs(Amat[is0].aij);
											// сканируем всех соседей iFpoint
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublerealT maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j]  ) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции
													}
												}
											}

											icsos_loc = 0;
											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc1 = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j]  ) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
															//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc)>maxelem_threshold*theta) {
															sumP_loc1 += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
															//	}
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции
													}
												}
											}

											if (icsos_loc > 0) {
												// В общем это двойная интерполяционная сумма
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j]  ) {
															// Внедиагональный элемент из множества С узлов.

															// Данная вставка должна существенно сохранять
															// разреженность оператора Галёркина на глубоких
															// сеточных уровнях.
															// Модификация 5 декабря 2015.
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
															if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
																//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc) > maxelem_threshold*theta) {
																P[icount1].j = (integer_mix_precision)(i8);
																P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
																//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																//P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc1;
																P[icount1].aij = mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																sum_ok += mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																icount1++;
																if (icount1 >= nsizePR*n) {
																	printf("memory error!!!\n");
																	printf("not enough memory for the interpolation operator.\n");
																	//system("PAUSE");
																	//exit(1);
																	deallocate_prolongation(nsizePR, n, R, P);
																}
															}
															//}
														}
													}
												}
											}
											else {
												//bbackreturn = true;
												bbackrarr[icounter_bbackarr] = true;
											}


											//}
										}
									}


							}
						}


						//bbackreturn = true;
						//for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
						//if (!bbackrarr[i_63]) {
						//	bbackreturn = false;
						//}
						//}

						//if (bbackreturn) {
						// сильные F связи не дали результата, поэтому мы возвращаемся к исходному 
						// варианту интерполяции.
						//for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
						//P[i_95].aij = P[i_95].aij*SumPall / sumP;
						//}
						//}

						// Апосториорная коррекция
						for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
							P[i_95].aij = P[i_95].aij / sum_ok;
						}

						free(bbackrarr);

					}

				}

			}


		} // end only negative connections 

	}

} // my_interpolation_procedure_number5


  // Интерполяционная процедура №6.
template <typename doublerealT>
void my_interpolation_procedure_number6(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublerealT RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublerealT &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF,
	doublerealT &theta83, bool &btreshold_on_new_vetv, integer& ifrom_re_operation_protection,
	bool &from_re_operation_protection0, doublerealT &magic82, doublerealT* &threshold_quick_all,
	doublerealT* &threshold_quick_only_negative)
{
	// INTERPOLATION SIX

	// Экспериментальная интерполяция 1 января 2016.
	printf("interpolation SIX: experimental version 1 jan 2016\n");
	system("PAUSE");

	the_number_of_neighbors_that_are_not_C_nodes = 0;
	number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

	if (bpositive_connections) {

		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполяции а значит и оператора Галёркина.
			doublerealT maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Наверно разумно что threshold определён по всей строке, а не только по С узлам в строке.
					//if (this_is_C_node[Amat[is0].j]  ) {
					if (fabs(Amat[is0].aij) > maxelem_threshold) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;

			doublerealT SumPall = 0.0;
			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublerealT sumP = 0.0;
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {

					// Сумма вообще всех внедиагональных элементов.
					//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
					if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
						SumPall += fabs(Amat[is0].aij);
					}


					if (this_is_C_node[Amat[is0].j]  ) {
						//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
							icsos++;
						}
					}
					else {
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.


																				   // 1 января 2015 Один сосед это недостаточно.
																				   // Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {



				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j]  ) {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all neighbour is F");
								//system("pause");
								//	printf("i8 is Dirichlet node\n");
								this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								iadditionalCstatistic++;
								//exit(1);
								// здесь нужна непрямая интерполяция.
							}
							else {

								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									P[icount1].j = (integer_mix_precision)(i8);
									P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
									//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
									P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
									icount1++;
									if (icount1 >= nsizePR*n) {
										printf("memory error!!!\n");
										printf("not enough memory for the interpolation operator.\n");
										//system("PAUSE");
										//exit(1);
										deallocate_prolongation(nsizePR, n, R, P);
									}
								}

							}

						}
						else
							if (this_is_F_node[Amat[is0].j]  ) {

								// Смысл:
								// 



								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

									integer iFpoint = Amat[is0].j;
									doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
									// сканируем всех соседей iFpointeger 
									// чтобы найти среди них С узлы.

									// Идентифицируем локальный порог.
									doublerealT maxelem_threshold_loc = -1.0;
									//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									integer ii1_loc = row_startA[iFpoint];
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											if (this_is_C_node[Amat[is0_loc].j]  ) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
													maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
												}
											}
										}
									}


									// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

									// Найти соседей данного F-node которые C-node.
									integer icsos_loc = 0;

									// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
									// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
									doublerealT sumP_loc = 0.0;
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {




											if (this_is_C_node[Amat[is0_loc].j]  ) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
													sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
													icsos_loc++;
												}
											}
											else {
												// Подсчитываем количество соседей которые не являются С узлами.
												//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
											}
										}
									}

									// В общем это двойная интерполяционная сумма 
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											if (this_is_C_node[Amat[is0_loc].j]  ) {
												// Внедиагональный элемент из множества С узлов.

												// Данная вставка должна существенно сохранять 
												// разреженность оператора Галёркина на глубоких 
												// сеточных уровнях.
												// Модификация 5 декабря 2015.
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
													P[icount1].j = (integer_mix_precision)(i8);
													P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
													//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
													P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
													icount1++;
													if (icount1 >= nsizePR*n) {
														printf("memory error!!!\n");
														printf("not enough memory for the interpolation operator.\n");
														//system("PAUSE");
														//exit(1);
														deallocate_prolongation(nsizePR, n, R, P);
													}
												}
											}
										}
									}


								}
							}
					}
				}

			}


		}
		////
	}
	else {
		// only negative connections

		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполяции а значит и оператора Галёркина.
			doublerealT maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Наверно разумно что threshold определён по всей строке, а не только по С узлам в строке.
					//if (this_is_C_node[Amat[is0].j]  ) {
					if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;

			doublerealT SumPall = 0.0;
			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublerealT sumP = 0.0;
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {

					// Сумма вообще всех внедиагональных элементов.
					//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
					if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
						SumPall += fabs(Amat[is0].aij);
					}


					if (this_is_C_node[Amat[is0].j]  ) {
						//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
							icsos++;
						}
					}
					else {
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.


																				   // 1 января 2015 Один сосед это недостаточно.
																				   // Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {



				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j]  ) {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all neighbour is F");
								//system("pause");
								//	printf("i8 is Dirichlet node\n");
								this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								iadditionalCstatistic++;
								//exit(1);
								// здесь нужна непрямая интерполяция.
							}
							else {

								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									P[icount1].j = (integer_mix_precision)(i8);
									P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
									//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
									P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
									icount1++;
									if (icount1 >= nsizePR*n) {
										printf("memory error!!!\n");
										printf("not enough memory for the interpolation operator.\n");
										//system("PAUSE");
										//exit(1);
										deallocate_prolongation(nsizePR, n, R, P);
									}
								}

							}

						}
						else
							if (this_is_F_node[Amat[is0].j]  ) {

								// Смысл:
								// 



								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

									integer iFpoint = Amat[is0].j;
									doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
									// сканируем всех соседей iFpointeger 
									// чтобы найти среди них С узлы.

									// Идентифицируем локальный порог.
									doublerealT maxelem_threshold_loc = -1.0;
									//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									integer ii1_loc = row_startA[iFpoint];
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											if (this_is_C_node[Amat[is0_loc].j]  ) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
													maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
												}
											}
										}
									}


									// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

									// Найти соседей данного F-node которые C-node.
									integer icsos_loc = 0;

									// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
									// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
									doublerealT sumP_loc = 0.0;
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {




											if (this_is_C_node[Amat[is0_loc].j]  ) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
													sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
													icsos_loc++;
												}
											}
											else {
												// Подсчитываем количество соседей которые не являются С узлами.
												//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
											}
										}
									}

									// В общем это двойная интерполяционная сумма 
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											if (this_is_C_node[Amat[is0_loc].j]  ) {
												// Внедиагональный элемент из множества С узлов.

												// Данная вставка должна существенно сохранять 
												// разреженность оператора Галёркина на глубоких 
												// сеточных уровнях.
												// Модификация 5 декабря 2015.
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
													P[icount1].j = (integer_mix_precision)(i8);
													P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
													//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
													P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
													icount1++;
													if (icount1 >= nsizePR*n) {
														printf("memory error!!!\n");
														printf("not enough memory for the interpolation operator.\n");
														//system("PAUSE");
														//exit(1);
														deallocate_prolongation(nsizePR, n, R, P);
													}
												}
											}
										}
									}


								}
							}
					}
				}

			}


		}

	} // end only negative connections

	 
} // my_interpolation_procedure_number6


#include "classic_aglomerative_amg6_2018year.cpp" // amg6 версия кода 2018 года.

// 25.04.2018 Версия четыре classic_aglomerative_amg4 это основная поддерживаемая версия.
// Пятая версия classic_aglomerative_amg5 давно не поддерживается (заморожена).
// июнь 2017 - добавлен Рунге-Кутта smoother, улучшена поддержка ilu0 разложения в алгоритме. 
// июнь 2017 - Поддерживается максимальное количество уровней вложенности 100 и менее. 
// зимние каникулы 2016-2017 года - добавлен bicgStab.
// Лето 2017 - алгебраический многосеточный метод теперь всё чаще и чаще используется как
// предобуславливатель
// к алгоритму Хенка ван дер Ворста BiCGStab. Эта связка показывает более стабильную и
// надежную работу чем просто отдельно amg.
// 4-6 ноября 2016. Добавлен ILU0. Полностью удалён устаревший код из Solution Phase.
// 9 августа 2016. Зейдель не справляется с большими спектральными радиусами матриц даже 
// в составе данного amg,
// это же проявляется и на классическом amg1r5. 9 августа решено уменьшить спектральный 
// радиус в Зейделе 
// на каждом уровне вложенности с помощью ILU2 декомпозиции. Это подтверждает статья 
// Е.М.Андреева, Г.В.Муратова
// "Многосеточный метод решения сильно нессиметричных систем" ЮГИНФО РГУ, Ростов-на-Дону,
// Россия. Там они
// показывают расходимость мультигрида на основе Зейделя для задач с существенным спектральным
/// радиусом и
// рекомендуют заменить Зейделя на ТКМ2 метод (треугольный кососимметричный метод). В данной 
//программе у нас есть 
// успешный опыт использования ILU2 предобуславливателя из библиотеки SPARSKIT2 Ю.Саада 
// поэтому вместо ТКМ2 у нас 
// будет ILU2.
// 22 января текущий работоспособный вариант кода.
// Планы: 1. сделать версию amg3. 
// В ней: 2. заменить все проверки на невыделение оперативной памяти на универсальную 
// функцию единую для всего.
// это очевидно немного сократит программный код.
// В ней 3. код V цикла оформить в виде цикла for. Тогда же можно будет попробовать вставить
// direct метод для самого грубого уровня.
// Это же откроет возможности сделать из amg алгоритма предобуславливатель для BiCGStab.
// 15 января экономим память переходим на Ak1.
// 10 января 2016 двоичный поиск заменён на хеширование.
// 15 декабря 2015. Данная версия кода будет полностью очищена от устаревшего кода.
// 13 декабря 2015. Внедрено АВЛ дерево. При внедрении АВЛ дерева исправлена логическая ошибка в
// построении С-F разбиения, теперь C/F разбиение строится корректно.
// Исправлен и внедрён quicksort (qs,qsj)
// который в рять раз быстрее пирамидальной сортировки.
// Полный отказ от band_size!!!.
// Время работы алгоритма на 1.7М неизвестных в 3D составило ровно 1 минуту.
// 18 октября 2015. Полностью работоспособный мультигрид.
// Тестировалось на условиях Дирихле но должно работать на любых 
// краевых задачах. 18 октября датируется версия 0.04. Версия 0.04 на треть
// быстрее версии 0.03. Были ускорены как операции построения C/F разбиения, 
// так и нахождение оператора Галёркина. При нахождении С/F разбиения 
// учитывается уже построенная его часть и поэтому число сканирований на
// на поздних циклах сокращается охватывая только не построенную часть.
// При нахождении произведения Галёркина получена самая оптимальная по 
// быстродействию версия,
// Основанная на алгоритме слияния отсортированных списков.
// 4 октября правильное построение последовательности вложенных графов.
// 30 сентября продолжаем исправление метода. Делаем классический 
// алгебраический многосеточный метод на основе  C/F разбиения.
// 16 сентября 2015 года обнаружено что операции 
// сгрубления и интерполяции сделаны совершенно неверно,
// и если сгрубление еще в какой-то мере проецирует то интерполяция просто никакая.
// Операции сгрубления и интерполяции будут сделаны заново на основе статьи 
// К.Н. Волкова в новой версии солвера.
// 3 september 2015 Villa Borgese.
// Возвращает divergence detected.
template <typename doublerealT>
bool classic_aglomerative_amg4(Ak1* &Amat,
	integer nsizeA, // количество ячеек выделенное извне для хранилища матриц А
	integer &nsizePR, // Память под P в количествах n.
	integer nnz, // number of non zero elements
	integer n, // dimension of vectors x and b.
	Ak1* &R, // restriction
	Ak1* &P, // prolongation
	doublereal* &x, doublereal* &b,
	doublerealT &theta, doublerealT &theta83,
	doublerealT &magic82, doublerealT &magic83,
	doublerealT &ret74,	integer iVar,
	bool bmemory_savings,
	BLOCK* &my_body, int &lb, integer maxelm_out,
	int * &whot_is_block,
	INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14 imyinit = INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT	
) {


	// Для ускорения паралельной версии пролонгации 1.08.2021.
	initQuickProlongation(n);

	// 0 - используем сбалансированное дерево поиска.
	// 1 - используем хеш-таблицу.
	const integer btree_vs_hash = 1;
	if (btree_vs_hash == 1) {
		construct_hash_table_Gus_struct01(n);
	}

	// 23.12.2016 ускорение счёта нелинейных задач:
	// лучистые потоки обновляются после каждого V цикла,
	// для этого внутрь передаётся 
	// b и lb.

	integer iaddFCcolor = 0;
	integer nsize;
	integer istart4;
	integer iend4;
	integer* row_ind_PE = nullptr;
	integer* row_ind_PS = nullptr;
	integer istart2;
	integer* row_ind_AS = nullptr;
	integer* row_ind_AE = nullptr;
	integer istartAnew2;
	integer index_size = 0;
	integer* index_visit = nullptr;
	doublerealT* vector_sum = nullptr;
	integer istartAnew_mem;
	integer istart3;
	integer iend3;
	integer* row_ind_SA = nullptr;
	integer* row_ind_EA = nullptr;
	integer istart1;
	integer iend1;
	integer* row_ind_ER = nullptr;
	integer* row_ind_SR = nullptr;
	integer iend_marker_position;
	doublerealT* ap_coarse = nullptr;
	integer icounter = 1;
	integer icount1;
	integer numberofcoarcenodes;
	integer* C_numerate = nullptr;
	const bool FUTURE_INJECTION = false; // раскоментировать если это будет реализовано.
	Ak1* P_injection = nullptr;
	Ak1* R_injection = nullptr;
	bool bweSholdbeContinue = true;
	integer the_number_of_neighbors_that_are_not_C_nodes = 0;
	integer number_of_F_nodes_with_one_single_strong_C_neighbor = 0;
	integer number_of_F_nodes_with_one_single_strong_C_neighborF = 0;

	integer iadditionalCstatistic = 0;
	node_AVL_Gus* root_Gus_set = 0;

	integer newCcount = 0;

	bool bAVL = true;
	bool bAVL_deb = false;
	node_AVL* root = 0;
	Tree_splay* root_splay = 0;
	size_splay_Tree = 0;
	TreapNode* random_tree_root = nullptr;
	RBtree RBroot; // Корень Красно-Чёрного дерева.

	integer istartflag_scan = 1;
	bool *bmarkervisit = nullptr;

	integer n_coarce = 1; // начальный номер C узла.

	const integer NULL_NEIGHBOUR = -1;
	integer vacant = NULL_NEIGHBOUR;
	bool bcontinue = true;

	// Построение C/F разбиения.
	//while (icandidate != 0)
	integer icountprohod = 0;

	integer maxneighbour = 0;
	integer icandidate = 0;

	integer* row_startA = nullptr;
	integer* count_neighbour = nullptr;

	bool identiti = true;
	

	// Вершина технологии решения плохообусловленных разреженных СЛАУ: BiCGStab + camg(РУМБА).
	// 1. многосеточные технологии.
	// 2. предобуславливание.
	// 3. стабилизация.
	// Если my_amg_manager.istabilization == 1 то мы используем метод бисопряженных градиентов со стабилизацией с предобуславливанием 
	// классическим алгебраическим многосеточным методом РУМБА.
	// Начало реализации 5.01.2017.(more robust).
	// Если my_amg_manager.istabilization == 0 - То просто используется 
	// многосеточный решатель без какого либо метода Крыловского подпространства.
	// Если my_amg_manager.istabilization == 2 - То используется fgmres - 
	// алгоритм Саада и Шульца (гибкий вариант обобщённого метода минимальных невязок) в котором 
	// на каждой итерации алгоритма fgmres делается одно многосеточное предобуславливание (один V цикл). 
	//bool bBiCGStab_plus_RUMBA_camg = true;
	//if (my_amg_manager.istabilization == 0) {
	    // Просто многосеточный метод без какого-либо Крыловского подпространства.
		// none
		//bBiCGStab_plus_RUMBA_camg = false;
	//}


	bfirst_jacoby_start = true;

	bool from_re_operation_protection0 = true;
	integer ifrom_re_operation_protection = 0;

	// Универсальные сглаживающие процедуры. 4 ноября 2016.
	// ILU2 smoother
	// 0 - ILU не используется. используется Gaus-Seidel.
	// 1 - ILU0 используется.
	// 2 - ILU2 используется.
	integer bILU2smoother = 0;
	if (my_amg_manager.ilu2_smoother == 1) {
		// Включаем ILU0 сглаживатель. 
		// он ест больше памяти но более быстро сходится.
		// Есть надежда что он справится с гораздо более плохообусловленными матрицами.

		bILU2smoother = 1; // ILU0

						   // По - видимому алгоритм 
						   // ilu0_(maxelm_plus_maxbound, milu0.val, milu0.col_ind, milu0.row_ptr, milu0.alu, milu0.jlu, milu0.ju, milu0.iw, ierr);
						   // является дефектным. Я не получил с ним сходимости как ни пытался. Зато алгоритм iluk с lfil=0 проявил себя наилучшим 
						   // образом и я его рекомендую к использованию. Это реализовано в ветке кода my_amg_manager.ilu2_smoother == 2.
						   // Причём iluk с lfil=0 работает на всех уровнях и прекрасно себя провляет.

						   // Перенаправление.
		bILU2smoother = 2; // ILU0
	}
	if (my_amg_manager.ilu2_smoother == 2) {
		// Включаем ILU2 сглаживатель. 
		// он ест больше памяти но более быстро сходится.

		// Его рекомендуется применять только для исходной матрицы - уровень ноль.
		// Если его применять на более глубоких уровнях то сходимость лишь замедляется.

		bILU2smoother = 2; // ILU2

						   // ILU2 ест слишком много оперативной памяти и я его заменил на ILU0 сглаживатель на каждом уровне: iluk с lfil=0.
						   // Возможно я ещё вернусь к ilu2 хотябы на нулевом уровне, т.к. там он особенно хорош.
	}
	//bILU2smoother = 0; // only seidel sor smoother.
	const doublerealT dapply_ilu_max_pattern_size = (doublerealT)(9.2);

	// Параметры отвечающие за автоматическую настройку SOR.
	// По трём точкам мы построим параболу и на её основе 
	// спрогнозируем улучшенный параметр релаксации omega_optimal.
	// Парабола представляется намного лучшей чем простая линейная экстрополяция.
	bproblem_amg_convergence1 = false;
	bproblem_amg_convergence2 = false;
	bproblem_amg_convergence3 = false;
	gold_const = 0.2;

	bool bprint_mesage_diagnostic = true;
	if (my_amg_manager.iprint_log == 0) {
		bprint_mesage_diagnostic = false;
	}


	bool bpositive_connections_CF_decomp = true;
	MY_AMG_SPLITTING_COARSENING_ALGORITHM memo_icoarseningtype = my_amg_manager.icoarseningtype;
	if (my_amg_manager.icoarseningtype == MY_AMG_SPLITTING_COARSENING_ALGORITHM::CLASSICAL_NEG_CONNECTION) {
		// only negative connections 
		// Внедиагональные положительные связи игнорируются при создании C/F разбиения.
		bpositive_connections_CF_decomp = false;
		my_amg_manager.icoarseningtype = MY_AMG_SPLITTING_COARSENING_ALGORITHM::CLASSICAL_ALL_CONNECTION;
	}
	if (my_amg_manager.icoarseningtype == MY_AMG_SPLITTING_COARSENING_ALGORITHM::RS2_NEG_CONNECTION) {
		// only negative connections 
		// Внедиагональные положительные связи игнорируются при создании C/F разбиения.
		bpositive_connections_CF_decomp = false;
		my_amg_manager.icoarseningtype = MY_AMG_SPLITTING_COARSENING_ALGORITHM::RS2_ALL_CONNECTION;
	}
	if (my_amg_manager.icoarseningtype == MY_AMG_SPLITTING_COARSENING_ALGORITHM::CLASSICAL_ST_NEG_CONNECTION) {
		// only negative connections 
		// Внедиагональные положительные связи игнорируются при создании C/F разбиения.
		bpositive_connections_CF_decomp = false;
		my_amg_manager.icoarseningtype = MY_AMG_SPLITTING_COARSENING_ALGORITHM::CLASSICAL_ST_ALL_CONNECTION;
	}
	if (my_amg_manager.icoarseningtype == MY_AMG_SPLITTING_COARSENING_ALGORITHM::RS2_ST_NEG_CONNECTION) {
		// only negative connections 
		// Внедиагональные положительные связи игнорируются при создании C/F разбиения.
		bpositive_connections_CF_decomp = false;
		my_amg_manager.icoarseningtype = MY_AMG_SPLITTING_COARSENING_ALGORITHM::RS2_ST_ALL_CONNECTION;
	}

	if ((my_amg_manager.icoarseningtype == MY_AMG_SPLITTING_COARSENING_ALGORITHM::PMIS) ||
		(my_amg_manager.icoarseningtype == MY_AMG_SPLITTING_COARSENING_ALGORITHM::HMIS)) {
		printf("ERROR in classical_aglomerative_amg4 PMIS or HMIS undefined situation.\n");
		system("PAUSE");
		exit(1);
	}
	//if (my_amg_manager.icoarseningtype >= 4) {
		// only negative connections 
		// Внедиагональные положительные связи игнорируются при создании C/F разбиения.
		//bpositive_connections_CF_decomp = false;
		//my_amg_manager.icoarseningtype -= 4;
	//}
	// 19.01.2016 Для построения C/F разбиения и интерполяции используется разная логика
	// в области игнорирования и не игнорирования positive connections.
	// Требует обсуждения следующий вопрос: 
	// 1. При построениии процедуры интерполяции важны все связи как позитив так и негатив.
	// 2. При построении C/F декомпозиции важны только негатив связи. 
	// Это гипотеза требующая подтверждения.
	// Разделение между bpositive_connections_CF_decomp используемом при построении C/F декомпозиции и bpositive_connections
	// Произошло 19.01.2017.


	bool bpositive_connections = true;
	// 23 октября 2016
	if (bSIMPLErun_now_for_temperature) {
		// Решаем cfd задачи.
		//bprint_mesage_diagnostic = false;

		// Гипотеза в том, что positive connections 
		// ускоряющие задачи теплопередачи в твёрдом теле приводят 
		// к расходимости в гидродинамических задачах:
		// гипотеза неверна, с убранными positive connections сходимость только хуже.
		//bpositive_connections = false;
	}

	// Задача 12mm hfet thermal resistance. 1.7млн неизвестных.
	// AVL_TREE_ID   3мин 29с 590мс      {5}
	// SPLAY_TREE_ID  3мин 16с 430мс {2}
	// BINARY_HEAP 3мин 4с 0мс {1 *самая быстрая.}
	// RANDOM_TREE_ID (Дерамида) 3мин 28с 90мс {4}
	// RED_BLACK_TREE_ID 3мин 27с 210мс {3}


	//const integer AVL_TREE_ID = 0;   // АВЛ дерево поиска. 12.12.2015.
	//const integer SPLAY_TREE_ID = 1; // Скошенное дерево поиска.
	//const integer BINARY_HEAP = 2; // Двоичная куча. 16.06.2017.
	//const integer RANDOM_TREE_ID = 3; // (Дерамида) Рандомизированное дерево поиска. 24.08.2017.
	//const integer RED_BLACK_TREE_ID = 4; // Красно-Чёрное дерево поиска. 22.06.2018.
	//const integer FIBONACCI_HEAP_ID = 5; // Фибоначчиева куча. 11.07.2018.
	//const integer VAN_EMDE_BOAS_TREE_ID = 6; // ван Эмде Боас дерево поиска. 30.06.2018
	//integer id_tree = BINARY_HEAP; // AVL_TREE_ID; // SPLAY_TREE_ID; // BINARY_HEAP; // RANDOM_TREE_ID; // RED_BLACK_TREE_ID;
	// 28.01.2018 На выбор пользователя.
	RS_COARSENING_KERNEL_DATA_STRUCTURE id_tree = my_amg_manager.iCFalgorithm_and_data_structure;
	
	// Выделяем память под двоичную кучу.
	// Деструктор вызывается автоматом при уходе из области видимости области определения.
	const integer isize_priority_queue01 = (integer)(0.4*n); // 0.238
	integer ikonst1=isize_priority_queue01, ikonst2=n;
	if (id_tree!= RS_COARSENING_KERNEL_DATA_STRUCTURE::BINARY_HEAP) {
	    ikonst1=0;
	    ikonst2=0;
	}
	PQ<integer> binary_heap(ikonst1, ikonst2); // 500K для 2.1M

	FibonacciHeap<integer> fibo_heap;

	if (id_tree == RS_COARSENING_KERNEL_DATA_STRUCTURE::FIBONACCI_HEAP) {
		fibo_heap.WakeUp2(n+1);// alloc memory hash table
		//if (id_tree == FIBONACCI_HEAP_ID) {
			//fibo_heap.~FibonacciHeap(); // Очистка
			//fibo_heap.WakeUp();
			//fibo_heap.Clear();
		//}
	}

	

	// Для вычисления grid complexity оператора интерполяции:
	integer nnz_P_memo_0 = 0;
	integer nnz_P_memo_all = 0;

	// Надо заменить все new на malloc.
	//theta = 0.25;

	bool bonly_serial = true;
//#ifdef _OPENMP
	//omp_set_num_threads(2);
//#endif

	// barjer=0.0001; optimum. для 1M задач.
	// Для зачачи с 3.2M неизвестных (теплопередача в 5mm СВЧ транзисторе без дырок.)
	// для константы 1.0e-8 получено сокращение времени счёта с 9мин до 4мин (Количество итераций 213 вместо 1003).
	// Пик использования оперативной памяти при этом приложению составил 2373Мб.
	// Для BiCGStab+ILU2 время счёта равно 1мин 50с против 4мин в данной версии алгоритма.
	// 14 января 2016 подобраны оптимальными и равными 1e-7 каждый.
	// 22 10 2016. первый  barjer полностью отключён.
	doublerealT barjer = (doublerealT)(1.0e-7); // 1.0e-7 
	// 22 10 2016. Второй барьер можно использовать и у него большой потенциал,
	// но надо им правильно пользоваться в соответствии с теорией, это не просто импирическое изменение константы.
	// Если барьер А не используется то его значение отрицательно.
	// значение без барьера А называется мультигридом Галёркина.
	doublerealT barjerA = (doublerealT)(-1.0e-7); // 1.0e-7

	//if (iVar == PAM) {
	//barjer = 1.0e-10; // 1.0e-7 
	//barjerA = 1.0e-10; // 1.0e-7
	//}

	// контроль числа сильных связей между переменными.
	// doublerealT theta = 0.25;  // 0.25 for 2D and 0.5 for 3D 

	
	//const integer MY_SORT_ALGORITHM:: QUICK_SORT = 1; // Быстрая сортировка Хоара.
	// Использовать ли quicksort qs and qsj.
	// Сортировка с подсчётом быстрее quickSort.
	// Использовать ли сортировку подсчётом которая 
	//потребляет килотонну памяти (Короче для машин у которых море оперативки).
	//const integer MY_SORT_ALGORITHM:: COUNTING_SORT = 0; // Сортировка с подсчётом лучший выбор.
    // Сортировка с посчётом подходит потому что ключи целочисленны и 
	// лежат в заданном интервале непрерывно.
	//const integer MY_SORT_ALGORITHM:: HEAP_SORT = 2; // пирмидальная сортировка.
	// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
	// В компиляторе надо увеличить размер стека до 4Мб.
	//bmemory_savings =false при MY_SORT_ALGORITHM:: QUICK_SORT и MY_SORT_ALGORITHM:: HEAP_SORT;
	MY_SORT_ALGORITHM imy_sort_algorithm = my_amg_manager.imySortAlgorithm;// MY_SORT_ALGORITHM:: COUNTING_SORT;

	const doublerealT RealZERO = (doublerealT)(1.0e-30);// 1.0e-10;
	const doublerealT divisionZERO = (doublerealT)(1.0e-30);
	const doublerealT RealMAXIMUM = (doublerealT)(1.0e37);
	// включение/отключение отладочного режима.
	bool debug_reshime = false;

	const integer max_neighbour = 111400;
	// Мы будем поддерживать информацию о максимальном количестве соседей.
	integer Maximumneighbourcount = -1;
	// мы получим порядковый номер элемента с максимальным число соседей в матрице А,
	// прямо в результате построения C/F разбиения.
	bool bmaxneighbourinfoactive = false;


	// Возможно можно обойтись без ji связи.
	// 17 dec 2015 эксперимент показывает что можно обойтись без учёта ji связи.
	// false без связи. Если false то Atemp вообще ненужен.
	bool bji = false;
	Ak1* Atemp = nullptr;
	if (bji) {
		Atemp = new Ak1[3 * nnz + 1];
	}

	// нумерация начинается с единицы.

	const integer maxlevel = 101; // (51 до 5.06.2017) 30
	integer ilevel = 1;
	integer *n_a = new integer[maxlevel];
	integer *nnz_a = new integer[maxlevel];
	nnz_a[0] = nnz;
	n_a[0] = n;

	const int iKnumber_thread = 8;

	char c1[27] = "classic_aglomerative_amg_4";

//#ifdef _NONAME_STUB29_10_2017
#ifdef _OPENMP 
	// Данные используемые для частичного формирователя суммы.
	// 8 - Это число потоков.
	
	Ak1** AccumulqtorA_m = nullptr;
	AccumulqtorA_m = new Ak1*[iKnumber_thread];
	doublerealT** vector_sum_m = nullptr;
	vector_sum_m = new doublerealT*[iKnumber_thread];
	integer** index_visit_m = nullptr;
	index_visit_m = new integer*[iKnumber_thread];
	bool** hash_table_m = new bool*[iKnumber_thread];
	integer* index_size_m = nullptr;
	integer*  istartAnew_m = new integer[iKnumber_thread];
	index_size_m = new integer[iKnumber_thread];
	for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++) {
		AccumulqtorA_m[i_9] = new Ak1[(integer)(0.125*4.55*nnz + 1)];
		//vector_sum_m[i_9] = new doublerealT[n_a[ilevel - 1] + 1];
		vector_sum_m[i_9] = (doublerealT*)malloc((n + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum_m[i_9], "vector_sum_m[i_9]", "classic_aglomerative_amg_4", (n + 1));

		//index_visit_m[i_9] = new integer[n_a[ilevel - 1] + 1];
		index_visit_m[i_9] = (integer*)malloc((n + 1) * sizeof(integer));
		handle_error<integer>(index_visit_m[i_9], "index_visit_m[i_9]", "classic_aglomerative_amg_4", (n + 1));

		hash_table_m[i_9] = (bool*)malloc((10 * n + 1) * sizeof(bool));
		handle_error<bool>(hash_table_m[i_9], "hash_table_m[i_9]", "classic_aglomerative_amg_4", (10 * n + 1));

		for (integer i_91 = 0; i_91 < 10 * n + 1; i_91++) hash_table_m[i_9][i_91] = false;// inicialization
		index_size_m[i_9] = 0;
		istartAnew_m[i_9] = 0;
	}
#endif

	doublerealT* threshold_quick_all = nullptr;
	threshold_quick_all = (doublerealT*)malloc((n + 1) * sizeof(doublerealT));
	handle_error<doublerealT>(threshold_quick_all, "threshold_quick_all", "classic_aglomerative_amg_4", (n + 1));

	doublerealT* threshold_quick_only_negative = nullptr;
	threshold_quick_only_negative = (doublerealT*)malloc((n + 1) * sizeof(doublerealT));
	handle_error<doublerealT>(threshold_quick_only_negative, "threshold_quick_only_negative", "classic_aglomerative_amg_4", (n + 1));
	bool btreshold_on_new_vetv = true; // false откат изменений назад на старую стабильную ветвь кода.
	

	//bool* flag = new bool[n + 1];
	bool* flag = nullptr;
	flag = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(flag, "flag", "classic_aglomerative_amg_4", (n + 1));

	//bool* flag_shadow = new bool[n + 1];
	bool* flag_shadow = nullptr;
	flag_shadow = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(flag_shadow, "flag_shadow", "classic_aglomerative_amg_4", (n + 1));

	//bool* hash_table = new bool[nnz + 1]; // Огромного размера hash таблица.
	bool* hash_table = nullptr;
	hash_table = (bool*)malloc((nnz + 1) * sizeof(bool));
	handle_error<bool>(hash_table, "hash_table", "classic_aglomerative_amg_4", (nnz + 1));

	// Огромный размер поэтому инициализация делается лишь единожды.
#pragma omp parallel for
	for (integer isc = 0; isc <= nnz; isc++) hash_table[isc] = false; // initialization 
	const integer istack_size_limit = n + 1; // 128000
											 //integer ipool[ipool_size_limit];
	integer* istack = nullptr;
	//istack = new integer[istack_size_limit];
	istack = (integer*)malloc((istack_size_limit) * sizeof(integer));
	handle_error<integer>(istack, "istack", "classic_aglomerative_amg_4", (istack_size_limit));

	// Для построения C/F декомпозиции нам тоже потребуется хеш-таблица
	// и стек для очистки хеш-таблицы.
	bool* hash_table2 = nullptr;
	hash_table2 = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(hash_table2, "hash_table2", "classic_aglomerative_amg_4", (n + 1));

	// Инициализация.
#pragma omp parallel for
	for (integer isc = 0; isc <= n; isc++) hash_table2[isc] = false;
	// И теперь стек для очистки хеш-таблицы.
	integer* istack2 = nullptr;
	//istack2 = new integer[n + 1];
	istack2 = (integer*)malloc((n + 1) * sizeof(integer));
	handle_error<integer>(istack2, "istack2", "classic_aglomerative_amg_4", (n + 1));


	integer iadd = 0;
	integer nnzR = 1;
	integer iaddR = 0;
	integer nnz_aRP[maxlevel];
	bool bcontinue_global = true;
	//bool* this_is_C_node = new bool[n + 1];
	//bool* this_is_F_node = new bool[n + 1];
	bool* this_is_C_node = nullptr;
	this_is_C_node = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(this_is_C_node, "this_is_C_node", "classic_aglomerative_amg_4", (n + 1));

	bool* this_is_F_node = nullptr;
	this_is_F_node = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(this_is_F_node, "this_is_F_node", "classic_aglomerative_amg_4", (n + 1));

	const integer isize_row_ptr_1 = 4 * n + 1;
	bool* F_false_C_true = nullptr;
	F_false_C_true = (bool*)malloc((isize_row_ptr_1) * sizeof(bool));
	handle_error<bool>(F_false_C_true, "F_false_C_true", "classic_aglomerative_amg_4", (isize_row_ptr_1));

	for (integer i_1 = 0; i_1 <  isize_row_ptr_1; i_1++) F_false_C_true[i_1] = false; // инициализация.

	bool bStrongTransposeON = true; // Как в литературе используем Strong Transpose.
	if ((my_amg_manager.icoarseningtype == MY_AMG_SPLITTING_COARSENING_ALGORITHM::CLASSICAL_ALL_CONNECTION) ||
		(my_amg_manager.icoarseningtype == MY_AMG_SPLITTING_COARSENING_ALGORITHM::RS2_ALL_CONNECTION)) {
		bStrongTransposeON = false;
	}
	bool bAVLST_ON = false;
	node_AVLST** hash_StrongTranspose_collection = nullptr;
	Taccumulqtor_list** hash_StrongTranspose_collection1 = nullptr;
	integer isize_memory_alloc_hash_StrongTranspose_collection1=-1;
	integer *isize_hash_StrongTranspose_collection = nullptr;

	while ((ilevel < maxlevel - 1) && (n_a[ilevel - 1] > 50) && (bcontinue_global)) {


		RBroot.Clear();
		if (id_tree == RS_COARSENING_KERNEL_DATA_STRUCTURE::FIBONACCI_HEAP) {
			//fibo_heap.~FibonacciHeap(); // Очистка
			//fibo_heap.WakeUp();
			//fibo_heap.Clear();
			fibo_heap.UpdateSize(n_a[ilevel -1]+1);
		}

		// защита от повторного срабатывания на добавление в интерполяции.
		from_re_operation_protection0 = true;
		ifrom_re_operation_protection = 0;

		/*
		hashlist** hash = new hashlist*[n_a[ilevel - 1]+1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hash[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].i;
		insertion_hash(hash[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hash[i_1]);
		hash[i_1] = 0;
		}
		delete[] hash;

		hashlist** hashj = new hashlist*[n_a[ilevel - 1] + 1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hashj[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].j;
		insertion_hash(hashj[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hashj[i_1]);
		hashj[i_1] = 0;
		}
		delete[] hashj;
		*/


		Maximumneighbourcount = -1;
		bmaxneighbourinfoactive = false;

		//if (ilevel > 1) {
		//if (n_a[ilevel - 2] == n_a[ilevel - 1]) break;
		//}

		//if (ilevel > 10) {
			// 5.01.2017 сделал менее 10.
			// до этого стоял break при менее 300.
			//if (n_a[ilevel - 1] < 10) break;
		//}

		if (ilevel > 1) {
			doublerealT procent = (doublerealT)((100.0*(abs(n_a[ilevel - 1] - n_a[ilevel - 2]))) / (1.0*n_a[ilevel - 2]));
			if (procent<2.0) break;
		}

		if (((ilevel > 1) && (nnz_a[ilevel - 1] > nnz_a[ilevel - 2]))) {
			//break;
		}

		// 19.04.2018
		print_control_volume_statistics(n_a, nnz_a, ilevel, bprint_mesage_diagnostic, debug_reshime); 

		//nnzR = 1;

#pragma omp parallel for
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

#pragma omp parallel for
		for (integer ii = n_a[ilevel - 1] + 1; ii <= n; ii++) {
#if doubleintprecision == 1
			//printf("warning: n!=n_a[ilevel-1]: n=%lld, n_a=%lld, ilevel=%lld\n", n, n_a[ilevel - 1], ilevel);
#else
			//printf("warning: n!=n_a[ilevel-1]: n=%d, n_a=%d, ilevel=%d\n", n, n_a[ilevel - 1], ilevel);
#endif
			
			//getchar();
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		// Сортировка нужна лишь на первом уровне, т.к.
		// результат алгоритма перемножения по Густавсону уже 
		// даёт на выходе отсортированную по строкам матрицу.
		if (ilevel == 1) {
			// сортировка исходной  А  по i.
			//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
			
			// 7 января 2016. Обязательно нужна эта сортировка.
			switch (imy_sort_algorithm) {
			case MY_SORT_ALGORITHM:: COUNTING_SORT:
				Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, bmemory_savings, indx_comparei);
				break;
			case MY_SORT_ALGORITHM:: HEAP_SORT:
				HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, comparei);
				break;
			case MY_SORT_ALGORITHM:: QUICK_SORT:
				// quicksort
				qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparei);
				// Библиотечный алгоритм. O(n*log2(n)).
				// Не использует лишней памяти.
				//std::sort(Amat + 1 + iadd, Amat + nnz_a[ilevel - 1] + iadd + 1, compareAk1R);

				//QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				break;
			default:
				Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, bmemory_savings, indx_comparei);
				break;
			}	
			
		} // ilevel == 1


		if (my_amg_manager.bMatrixPortrait  ) {
			// Печать портрета матрицы.

			FILE* fp_portrait=nullptr;
			
#ifdef MINGW_COMPILLER
			int err_portrait = 0;
			fp_portrait = fopen64("matrix_load.txt", "w");
			if (fp_portrait == NULL) {
				err_portrait = 1;
			}
			else {
				fprintf(fp_portrait, "%lld %lld\n", n_a[ilevel - 1], nnz_a[ilevel - 1]);
				for (integer i58 = 1 + iadd; i58 <= nnz_a[ilevel - 1] + iadd; i58++) {
					fprintf(fp_portrait, "%lld %lld\n", Amat[i58].i, Amat[i58].j);
				}
				fclose(fp_portrait);
			}
#else
			errno_t err_portrait = 0;
			err_portrait = fopen_s(&fp_portrait, "matrix_load.txt", "w");
			if (err_portrait == 0) {
#if INTEGER_MIX_PRECISION_IS_INT
				fprintf_s(fp_portrait, "%lld %lld\n", n_a[ilevel - 1], nnz_a[ilevel - 1]);
				for (integer i58 = 1 + iadd; i58 <= nnz_a[ilevel - 1] + iadd; i58++) {
					fprintf_s(fp_portrait, "%d %d\n", Amat[i58].i, Amat[i58].j);
				}
#else
				fprintf_s(fp_portrait, "%lld %lld\n", n_a[ilevel - 1], nnz_a[ilevel - 1]);
				for (integer i58 = 1 + iadd; i58 <= nnz_a[ilevel - 1] + iadd; i58++) {
					fprintf_s(fp_portrait, "%lld %lld\n", Amat[i58].i, Amat[i58].j);
				}
#endif
				fclose(fp_portrait);
			}
#endif
			
			
			printf("matrix portrait in level export\n");
			system("pause");
		}
		


		if (bji) {
			//  УСТАРЕВШИЙ КОД.

			// Создаём копию в Atemp, копия будет отсортирована по j.
			for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
				Atemp[i_1 - iadd] = Amat[i_1];
			}
			// Сортируем копию по j.
			// Мы сортируем по j, чтобы потом быстро искать по j.
			switch (imy_sort_algorithm) {
			case MY_SORT_ALGORITHM:: COUNTING_SORT:
				// Сортировка с подсчётом за линейное время.
				Counting_Sort(Atemp, 1, nnz_a[ilevel - 1], indx_comparej);
				break;
			case MY_SORT_ALGORITHM:: HEAP_SORT:
				HeapSort(Atemp, 1, nnz_a[ilevel - 1], comparej);
				break;
			case MY_SORT_ALGORITHM:: QUICK_SORT:
				// Быстрая сортировка Чарльза Хоара.
				qs(Atemp, 1, nnz_a[ilevel - 1], indx_comparej);
				// Библиотечный алгоритм. O(n*log2(n)).
				// Не использует лишней памяти.
				//std::sort(Atemp + 1, Atemp + nnz_a[ilevel - 1]+1, compareAk1P);
				break;
			default:
				// Сортировка с подсчётом за линейное время.
				Counting_Sort(Atemp, 1, nnz_a[ilevel - 1], indx_comparej);
				break;
			}
		} // if (bji)

#pragma omp parallel for
		for (integer i_1 = 1; i_1 <= n; i_1++) {
			flag[i_1] = false;
		}

#pragma omp parallel for
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}

		// позиция начала каждой строки в матрице.
		row_startA = nullptr;
		//row_startA = new integer[n_a[ilevel - 1] + 1];
		row_startA = (integer*)malloc((n_a[ilevel - 1] + 2) * sizeof(integer));
		handle_error<integer>(row_startA, "row_startA", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 2));

		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				flag[Amat[ii].i] = true;
				row_startA[Amat[ii].i] = ii;
			}
		}
		row_startA[n_a[ilevel - 1] + 1] = nnz_a[ilevel - 1] + iadd + 1; // заглушка на окончание матрицы.

#pragma omp parallel for
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}


		// вычисляем для кадого узла число его соседей.
		count_neighbour = nullptr;
		//count_neighbour = new integer[n_a[ilevel - 1] + 1];
		count_neighbour = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(count_neighbour, "count_neighbour", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

#pragma omp parallel for
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			count_neighbour[ii] = 0; // нет соседей.
		}



		/*
		// При таком коде узел Дирихле тоже имеет соседа, сосед это
		// внутренний узел который связан с этим узлом Дирихле.
		// Соседей вычисляем на самой первой матрице А (самой левой).
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		if (flag[Amat[ii].i] == false) {
		integer ic = -1;
		integer cand[max_neighbour];
		if (0) {
		for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
		ic++; //i,j
		cand[ic] = Amat[is0].j;
		}
		}
		else {
		// 12 января 2016.
		// Учитываем только Strong соседей.
		doublerealT threshold = -1.0;
		for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
		if (Amat[is0].j != Amat[ii].i) {
		if (fabs(Amat[is0].aij) > threshold) {
		// Определяем максимальный внедиагональный элемент.
		threshold = fabs(Amat[is0].aij);
		}
		}
		}
		for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
		if (Amat[is0].j != Amat[ii].i) {
		if (fabs(Amat[is0].aij) > theta*threshold) {
		// Учитываем только сильно связанных соседей.
		ic++; //i,j
		cand[ic] = Amat[is0].j;
		}
		}
		}
		}
		integer len_neighbour = ic;
		// Найти столбец j который равен индексу Amat[ii].i
		//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
		//if (Amat[ii1].i != Amat[ii].i) {
		//	if (Amat[ii1].j == Amat[ii].i) {
		// j,i
		//		bool foundneighbour = false;
		//		for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
		//			if (Amat[ii1].j == cand[i_1]) foundneighbour = true;
		//		}
		//		if (!foundneighbour) {
		//			ic++;
		//			cand[ic] = Amat[ii1].j;
		//			len_neighbour++;
		//		}
		//	}
		//}
		//}
		if (bji) {
		// Ускоренная версия с бинарным поиском по j.
		integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
		for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == Amat[ii].i); ii1++) {
		if (Atemp[ii1].i != Amat[ii].i) {
		// j,i
		bool foundneighbour = false;
		for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
		if (Atemp[ii1].j == cand[i_1]) foundneighbour = true;
		}
		if (!foundneighbour) {
		ic++;
		cand[ic] = Atemp[ii1].j;
		len_neighbour++;
		}
		}
		}
		}


		count_neighbour[Amat[ii].i] = ic;
		if (ic > Maximumneighbourcount) {
		Maximumneighbourcount = ic;
		bmaxneighbourinfoactive = true;
		}
		flag[Amat[ii].i] = true;
		}
		}
		*/

		if (bStrongTransposeON) {
			// Освобождение ОЗУ.
			if (bAVLST_ON) {
				if (hash_StrongTranspose_collection != nullptr) {
#pragma omp parallel for
					for (integer i_1 = 0; i_1 <= n_a[ilevel - 2]; i_1++) clear_AVL(hash_StrongTranspose_collection[i_1]);
					delete[] hash_StrongTranspose_collection;
					hash_StrongTranspose_collection = nullptr;
				}
				if (isize_hash_StrongTranspose_collection != nullptr) {
					delete[] isize_hash_StrongTranspose_collection;
					isize_hash_StrongTranspose_collection = nullptr;
				}
				// Выделяем память под лес АВЛ деревьев.
				hash_StrongTranspose_collection = new node_AVLST*[n_a[ilevel - 1] + 1];
				isize_hash_StrongTranspose_collection = new integer[n_a[ilevel - 1] + 1];
#pragma omp parallel for
				for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
					hash_StrongTranspose_collection[i_1] = nullptr;
					isize_hash_StrongTranspose_collection[i_1] = 0;
				}
			}
			else {
				// Эта ветвь активна лес АВЛ деревьев ненужен.

				// Обычный накопитель - линейный список с быстрой вставкой.
				if (hash_StrongTranspose_collection1 != nullptr) {
#pragma omp parallel for
					//for (integer i_1 = 0; i_1 <= n_a[ilevel - 2]; i_1++)
					//isize_memory_alloc_hash_StrongTranspose_collection1
					for (integer i_1 = 0; i_1 <= isize_memory_alloc_hash_StrongTranspose_collection1; i_1++)
					{
					 clear_list(hash_StrongTranspose_collection1[i_1]);
					}
					delete[] hash_StrongTranspose_collection1;
					hash_StrongTranspose_collection1 = nullptr;
				}
				if (isize_hash_StrongTranspose_collection != nullptr) {
					delete[] isize_hash_StrongTranspose_collection;
					isize_hash_StrongTranspose_collection = nullptr;
				}
				// Выделяем память под лес линейных однонаправденных списков.
				hash_StrongTranspose_collection1 = new Taccumulqtor_list*[n_a[ilevel - 1] + 1];
				isize_memory_alloc_hash_StrongTranspose_collection1=n_a[ilevel - 1];
				isize_hash_StrongTranspose_collection = new integer[n_a[ilevel - 1] + 1];
#pragma omp parallel for
				for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
					hash_StrongTranspose_collection1[i_1] = nullptr;
					isize_hash_StrongTranspose_collection[i_1] = 0;
				}
			}
		}

		// При таком коде узел Дирихле тоже имеет соседа, сосед это 
		// внутренний узел который связан с этим узлом Дирихле.
		// Соседей вычисляем на самой первой матрице А (самой левой).
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer ic = -1;
				//integer cand[max_neighbour];
				node_AVL_Gus* root_Gus_cand = 0;
				if (0) {
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						ic++; //i,j
						//cand[ic] = Amat[is0].j;
						if (btree_vs_hash == 1) {
							insert_hash_table_Gus_struct01(Amat[is0].j);
						}
						else if (btree_vs_hash == 0) {
							root_Gus_cand = insert_Gus(root_Gus_cand, Amat[is0].j);
						}
					}
				}
				else {
					if (1) {
						// Новейшая ветвь кода: 11.06.2017.
						// Введение новой ветви вызвано желанием ускорить код избегая повторных массовых вычислений threshold.
						// Ни в коем случае не ставить 0 в if.
						// Это новая едиственно верная ветка. Её убирание приводит к неработоспособности всего приложения.
						threshold_quick_all[Amat[ii].i] = -1.0;
						threshold_quick_only_negative[Amat[ii].i] = -1.0;
						for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii].i) {
								if (fabs(Amat[is0].aij) > threshold_quick_all[Amat[ii].i]) {
									// Определяем максимальный внедиагональный элемент.
									threshold_quick_all[Amat[ii].i] = fabs(Amat[is0].aij);
								}
							}
						}
						for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii].i) {
								if (Amat[is0].aij < 0.0) {
									if (fabs(Amat[is0].aij) > threshold_quick_only_negative[Amat[ii].i]) {
										// Определяем максимальный внедиагональный элемент.
										threshold_quick_only_negative[Amat[ii].i] = fabs(Amat[is0].aij);
									}
								}
							}
						}
					}
					else {
						// Безнадёжно устаревшая ветвь кода начиная с 11.06.2017.

						// 12 января 2016.
						// 12 февраля 2016. матрица отсортирована по i.
						// Учитываем только Strong соседей.
						doublerealT threshold = -1.0;

						if (bpositive_connections_CF_decomp) {
							for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii].i) {
									if (fabs(Amat[is0].aij) > threshold) {
										// Определяем максимальный внедиагональный элемент.
										threshold = fabs(Amat[is0].aij);
									}
								}
							}
						}
						else {
							for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii].i) {
									if (Amat[is0].aij < 0.0) {
										if (fabs(Amat[is0].aij) > threshold) {
											// Определяем максимальный внедиагональный элемент.
											threshold = fabs(Amat[is0].aij);
										}
									}
								}
							}
						}
					}
					if (bpositive_connections_CF_decomp) {
						//doublerealT theta_threshold3 = theta*threshold;
						doublerealT theta_threshold3 = theta*threshold_quick_all[Amat[ii].i];
						integer istopmarker3 = row_startA[Amat[ii].i + 1] - 1;
						for (integer is0 = ii; (is0 <= istopmarker3); is0++) {
							if (Amat[is0].j != Amat[ii].i) {
								if (fabs(Amat[is0].aij) > theta_threshold3) {
									// Учитываем только сильно связанных соседей.
									ic++; //i,j
									//cand[ic] = Amat[is0].j;
									if (btree_vs_hash == 1) {
										insert_hash_table_Gus_struct01(Amat[is0].j);
									}
									else if (btree_vs_hash == 0) {
										root_Gus_cand = insert_Gus(root_Gus_cand, Amat[is0].j);
									}

									if (bStrongTransposeON) {
										data_BalTreeST d32;
										d32.i = Amat[ii].i;
										if (bAVLST_ON) {
											hash_StrongTranspose_collection[Amat[is0].j] = insert(hash_StrongTranspose_collection[Amat[is0].j], d32);
										}
										else {
											// O(1) вставка в начало линейного списка.
											insert_list(hash_StrongTranspose_collection1[Amat[is0].j], Amat[ii].i);
										}
										isize_hash_StrongTranspose_collection[Amat[is0].j]++;
									}
								}
							}
						}
					}
					else {
						for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii].i) {
								if (Amat[is0].aij < 0.0) {
									if (fabs(Amat[is0].aij) > theta*threshold_quick_only_negative[Amat[ii].i]) {
										// Учитываем только сильно связанных соседей.
										ic++; //i,j
										//cand[ic] = Amat[is0].j;
										if (btree_vs_hash == 1) {
											insert_hash_table_Gus_struct01(Amat[is0].j);
										}
										else if (btree_vs_hash == 0) {
											root_Gus_cand = insert_Gus(root_Gus_cand, Amat[is0].j);
										}

										if (bStrongTransposeON) {
											data_BalTreeST d32;
											d32.i = Amat[ii].i;
											if (bAVLST_ON) {
												hash_StrongTranspose_collection[Amat[is0].j] = insert(hash_StrongTranspose_collection[Amat[is0].j], d32);
											}
											else {
												// O(1) вставка в начало линейного списка.
												insert_list(hash_StrongTranspose_collection1[Amat[is0].j], Amat[ii].i);
											}
											isize_hash_StrongTranspose_collection[Amat[is0].j]++;
										}
									}
								}
							}
						}
					}
				}
				integer len_neighbour = ic;
				// Найти столбец j который равен индексу Amat[ii].i
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//if (Amat[ii1].i != Amat[ii].i) {
				//	if (Amat[ii1].j == Amat[ii].i) {
				// j,i
				//		bool foundneighbour = false;
				//		//for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
				//			//if (Amat[ii1].j == cand[i_1]) foundneighbour = true;
				//		//}
				//if (btree_vs_hash == 1) {
					//foundneighbour = isfound_hash_table_Gus_struct01(Amat[ii1].j);
					//if (!foundneighbour) {
						//			ic++;
						//			//cand[ic] = Amat[ii1].j;
						//         	insert_hash_table_Gus_struct01(Amat[ii1].j);
						//			len_neighbour++;
						//		}
					
				//}
				//else if (btree_vs_hash == 0) {
					//      foundneighbour = isfound_Gus(root_Gus_cand, Amat[ii1].j);
					//		if (!foundneighbour) {
					//			ic++;
					//			//cand[ic] = Amat[ii1].j;
					//          root_Gus_cand = insert_Gus(root_Gus_cand, Amat[ii1].j);
					//			len_neighbour++;
					//		}
				//}
				//	}
				//}
				//}
				if (bji) {
					// Ускоренная версия с бинарным поиском по j.
					integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
					for (integer ii1 = ii2; (ii1 <= row_startA[Amat[ii2].i + 1] - 1); ii1++) {
						if (Atemp[ii1].i != Amat[ii].i) {
							// j,i
							bool foundneighbour = false;
							//for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
								//if (Atemp[ii1].j == cand[i_1]) foundneighbour = true;
							//}
							if (btree_vs_hash == 1) {
								foundneighbour = isfound_hash_table_Gus_struct01(Atemp[ii1].j);
								if (!foundneighbour) {
									ic++;
									//cand[ic] = Atemp[ii1].j;
									insert_hash_table_Gus_struct01(Atemp[ii1].j);
									len_neighbour++;
								}
							}
							else if (btree_vs_hash == 0) {
								foundneighbour = isfound_Gus(root_Gus_cand, Atemp[ii1].j);
								if (!foundneighbour) {
									ic++;
									//cand[ic] = Atemp[ii1].j;
									root_Gus_cand = insert_Gus(root_Gus_cand, Atemp[ii1].j);
									len_neighbour++;
								}
							}
						}
					}
				}


				count_neighbour[Amat[ii].i] = ic;
				// 22_12_2016
				if (ic == 0) {
					// Большой вопрос уместно ли так делать 8.апреля 2017 ???

					// До начала работы алгоритма все условия Дирихле становятся F узлами.
					this_is_C_node[Amat[ii].i] = false;
					this_is_F_node[Amat[ii].i] = true;

					// До начала работы алгоритма все условия Дирихле становятся C узлами.
					// Внимание так не работает.
					//this_is_C_node[Amat[ii].i] = true;
					//this_is_F_node[Amat[ii].i] = false;
				}
				if (ic > Maximumneighbourcount) {
					Maximumneighbourcount = ic;
					bmaxneighbourinfoactive = true;
				}
				flag[Amat[ii].i] = true;

				if (btree_vs_hash == 1) {
					clear_hash_table_Gus_struct01();
				}
				else if (btree_vs_hash == 0) {
					clear_AVL_Gus(root_Gus_cand);
					root_Gus_cand = 0;
				}
			}
		}

		if (bStrongTransposeON) {
			// 5.01.2017. StrongTranspose.
			// Счётчик labda инициализирован согласно литературным описаниям через Strong Transpose.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
#if doubleintprecision == 1
				//printf("%lld ", count_neighbour[i_1]);
#else
				//printf("%d ", count_neighbour[i_1]);
#endif
				
				//if (hash_StrongTranspose_collection[i_1] == nullptr) {
					//printf(" nullptr");
					//system("PAUSE");
					// Присутствуют элементы с nullptr у которых count_neighbour[i_1] =0;
				//}
				// 20.05.2017 Добавлен быстрый доступ по ключу для количества элементов в дереве.
				//count_neighbour[i_1] = getnumber_AVL_node_global(hash_StrongTranspose_collection[i_1]);
				count_neighbour[i_1] = isize_hash_StrongTranspose_collection[i_1];
				if (count_neighbour[i_1]==0) {
					// 14.04.2017 Важнейшая положительная модификация 
					// сокращающая количество итераций:
					// # задача; число ит. до; число ит. после;
					// 1. passiv_module6 (APPARAT); 179; 97;
					// 2. CGHV 12mm HFET; 18, 8, 6, 3, 2; 17, 8, 6, 3, 2;
					// 3. PIONER; 77; 73;

					// До начала работы алгоритма все условия Дирихле становятся F узлами.
					this_is_C_node[i_1] = false;
					this_is_F_node[i_1] = true;

				}
#if doubleintprecision == 1
				//printf("%lld \n", count_neighbour[i_1]);
#else
				//printf("%d \n", count_neighbour[i_1]);
#endif
				
				//system("PAUSE");
			}
		}


		maxneighbour = 0;
		icandidate = 0;
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}
		// Находим узел с наибольшим числом соседей и запоминаем его.
		// Это первый встретившийся узел с наибольшим числом соседей.
		/*
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		if (flag[Amat[ii].i] == false) {
		if (count_neighbour[Amat[ii].i] > maxneighbour) {
		maxneighbour = count_neighbour[Amat[ii].i];
		icandidate = ii;
		if (bmaxneighbourinfoactive) {
		// организуем досрочный выход из цикла for.
		// Это должно сильно сокращать количество сканирований.
		if (maxneighbour == Maximumneighbourcount) break;
		}
		}
		flag[Amat[ii].i] = true;
		}
		}
		*/
		for (integer i7 = 1; i7 <= n_a[ilevel - 1]; i7++) {
			if (count_neighbour[i7] > maxneighbour) {
				maxneighbour = count_neighbour[i7];
				icandidate = row_startA[i7];
				if (bmaxneighbourinfoactive) {
					// организуем досрочный выход из цикла for.
					// Это должно сильно сокращать количество сканирований.
					if (maxneighbour == Maximumneighbourcount) break;
				}
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}


		// нужно выделить кто попал в coarse, а кто в этот раз попал в Fine Выделить всех кто соседствует
		// с новыми Fine увеличить им счётчик соседей.

		n_coarce = 1; // начальный номер C узла.
		nnzR = 1;

		
		vacant = NULL_NEIGHBOUR;
		bcontinue = true;

		// Построение C/F разбиения.
		//while (icandidate != 0)
		icountprohod = 0;
		// Мы будем заоминать с какой позиции начинаются ещё не помеченные узлы,
		// это сократит количество перебираемых элементов в поиске узла с максимальным 
		// количеством соседей.
		//integer ibegining_start_index_found_maximum = 1 + iadd;
		// храним те узлы которые уже были пройдены при конструировании.
		bmarkervisit = nullptr;
		//bmarkervisit = new bool[n + 1];
		bmarkervisit = (bool*)malloc((n + 1) * sizeof(bool));
		handle_error<bool>(bmarkervisit, "bmarkervisit", "classic_aglomerative_amg_4", (n + 1));

		// поначалу все узлы помечены как непосещенные.
		for (integer i_1 = 1; i_1 <= n; i_1++) bmarkervisit[i_1] = false;



		// увеличение быстродействия достигается 
		// сокращением пределов сканирования
		// здесь хранится индекс начала сканирования flag.
		istartflag_scan = 1;


		// if (bAVL) работа на основе АВЛ дерева.
		bAVL = true;
		bAVL_deb = false;
		root = 0;
		root_splay = 0;
		size_splay_Tree = 0;
		random_tree_root = nullptr;
		
		if (id_tree == RS_COARSENING_KERNEL_DATA_STRUCTURE::BINARY_HEAP) {
			binary_heap.clear();
		}

#if VEB_FLAG
		int64_t res_vanEMDE_BOAS_Tree;
		int64_t universe = 4294967296; // 2 ^32=2^(2^5) (4294 млн)
		TvEB * vanEMDE_BOAS_Tree = nullptr;

		if (id_tree == RS_COARSENING_KERNEL_DATA_STRUCTURE::VAN_EMDE_BOAS_TREE) {
			vanEMDE_BOAS_Tree = new TvEB(universe);
		}
#endif

		newCcount = 0;

		// 4 июля 2016.
		// это случай когда следующий уровень вложенности просто не из чего строить и это 
		// становится понятно только здесь.
		if ((icandidate == 0) && (maxneighbour == 0)) {
#if doubleintprecision == 1
			//printf("maxneighbour==%lld\n",maxneighbour);
#else
			//printf("maxneighbour==%d\n",maxneighbour);
#endif
			
			//getchar();
			// уровень построить нельзя поэтому досрочный выход из цикла.
			break;
		}


		// Нехорошо постоянно выделять и уничтожать память в длинном цикле, 
		// более быстро выделить её один раз. См. выделение памяти под set.
		// 23.04.2017

		//integer set[max_neighbour]; // не более 20 узлов в одном агрегате.
		//integer* set = new integer[max_neighbour];
		root_Gus_set = 0;
		// инициализация убрана потому что она не нужна и она сильно тормозит быстродействие.
		//for (integer js = 0; js < max_neighbour; js++) {
		//set[js] = NULL_NEIGHBOUR;
		//}

		while (bcontinue)
		{


#if doubleintprecision == 1
			//printf("prohod count number %lld\n", icountprohod);
#else
			//printf("prohod count number %d\n", icountprohod);
#endif
			


			
			integer ic = 0;
			integer ic_end_F_SiTranspose = 0;

			integer ii = icandidate;
			if (flag[Amat[ii].i] == false) {

				ic = 0; // Обязательная инициализация.
				if (btree_vs_hash == 0) {
					if (root_Gus_set != 0) {
						clear_AVL_Gus(root_Gus_set);
						root_Gus_set = 0;
					}
				}

				ic_end_F_SiTranspose = 0;
				integer set0= Amat[ii].i;
				



				//A20.05.2017//this_is_C_node[set[0]] = true;
				//A20.05.2017//bmarkervisit[set[0]] = true;
				this_is_C_node[set0] = true;
				bmarkervisit[set0] = true;

				doublerealT max_vnediagonal = -1.0; // максимальное значение модуля вне диагонального элемента. 
												   // добавляем диагональный элемент.
												   // узел set[0]==Amat[is0].i.
												   // Нахождение значения максимального внедиагольного элемента, с 
												   // учётом того что даже узел Дирихле связан с одним внутренним узлом расчётной области.
												   // 17 января 2016 правильное определение максимального внедиагонального элемента.
												   // Обязательная перемотка в самое начало строки.
				integer ii_back = ii;
				while ((ii_back > iadd) && (Amat[ii_back].i == set0)) ii_back--;
				ii_back++;

				doublerealT max_vnediagonal1 = (doublerealT)(-1.0e30);
				doublerealT min_vnediagonal1 = (doublerealT)(1.0e30);
				doublerealT counter_vnediagonal = 0.0;
				doublerealT avg_vnediagonal1 = 0.0;

				// Если делать по максимальному внедиагональному элементу то мы получим очень много элементов на грубых уровнях,
				// и чрезвычайно медленную сходимость.

				if (bpositive_connections_CF_decomp) {
					// 23_10_2016
					for (integer is0 = ii_back; (is0 <= row_startA[set0 + 1] - 1); is0++) {
						if (Amat[is0].j != set0) {
							counter_vnediagonal = (doublerealT)(counter_vnediagonal + 1.0);
							avg_vnediagonal1 += fabs(Amat[is0].aij);
							if (fabs(Amat[is0].aij) > max_vnediagonal1) {
								max_vnediagonal1 = fabs(Amat[is0].aij); //i,j
																	 // Большое количество элементов на грубых уровнях,
																	 // очень медленная сходимость.
																	 //if (Amat[is0].j == set[0]) break; 
							}
							if (fabs(Amat[is0].aij) < min_vnediagonal1) {
								min_vnediagonal1 = fabs(Amat[is0].aij); //i,j

							}
						}
					}
				}
				else {
					for (integer is0 = ii_back; (is0 <= row_startA[set0 + 1] - 1); is0++) {
						if (Amat[is0].j != set0) {
							if (Amat[is0].aij < 0.0) {
								counter_vnediagonal = (doublerealT)(counter_vnediagonal + 1.0);
								avg_vnediagonal1 += fabs(Amat[is0].aij);
								if (fabs(Amat[is0].aij) > max_vnediagonal1) {
									max_vnediagonal1 = fabs(Amat[is0].aij); //i,j
																		 // Большое количество элементов на грубых уровнях,
																		 // очень медленная сходимость.
																		 //if (Amat[is0].j == set[0]) break; 
								}
								if (fabs(Amat[is0].aij) < min_vnediagonal1) {
									min_vnediagonal1 = fabs(Amat[is0].aij); //i,j

								}
							}
						}
					}
				}
				if (fabs(counter_vnediagonal) > 0.5) {
					avg_vnediagonal1 = avg_vnediagonal1 / counter_vnediagonal;
				}
				else {
					avg_vnediagonal1 = max_vnediagonal1;
				}
				//max_vnediagonal = avg_vnediagonal1;
				//max_vnediagonal = max_vnediagonal1;  // 1
				//max_vnediagonal = 0.5* avg_vnediagonal1 + 0.5*max_vnediagonal1;
				//max_vnediagonal = avg_vnediagonal1 + 0.05*(max_vnediagonal1 - avg_vnediagonal1);
				// наиболее близка к оптимальной. -85%. но несомненно лучше max_vnediagonal = -1.0;
				//max_vnediagonal = avg_vnediagonal1 - 0.85*(avg_vnediagonal1 - min_vnediagonal1);
				// 19 января 2016 установлено что важды все связы, не нужно учитывать threshold
				// max_vnediagonal должно быть -1.0. Именно это значение обеспечивает наилучшую 
				// скорость агломерации и наилучшую скорость сходимости.
				max_vnediagonal = (doublerealT)(-1.0e30);  // все связи!!!
				

										 /*
										 // Лишний код 19 января 2016.
										 for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set0); is0++) {
										 if (Amat[is0].j == set0) {

										 // Из-за этого прерывания максимальный внедиагональный элемент может быть определён неверно.
										 // поэтому смотри цикл выше от 17 января 2016 по правильному определению максимального внедиагонального элемента.
										 break;
										 }
										 else {
										 if (fabs(Amat[is0].aij) > max_vnediagonal) {
										 // При стабильной версии требуется расскоментировать
										 // 19 jan 2016.
										 //max_vnediagonal = fabs(Amat[is0].aij); //i,j
										 }
										 }

										 // Этот цикл является добавочным.
										 // Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
										 // Медленный линейный поиск.
										 //for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
										 //if (Amat[ii1].i != set0) {
										 //if (!flag[Amat[ii1].i]) {
										 //	if (Amat[ii1].j == set0) {
										 //		if (fabs(Amat[ii1].aij) > max_vnediagonal) {
										 //			max_vnediagonal = fabs(Amat[ii1].aij); //j,i
										 //		}
										 //	}
										 //}
										 //}
										 //}

										 if (bji) {
										 // Этот цикл является добавочным.
										 // Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
										 // Ускоренная версия на основе двоичного поиска.
										 integer ii2 = BinarySearchAj(Atemp, set0, 1, nnz_a[ilevel - 1]);
										 for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == set0); ii1++)
										 {
										 if (Atemp[ii1].i != set0) {
										 if (!flag[Atemp[ii1].i]) {
										 if (fabs(Atemp[ii1].aij) > max_vnediagonal) {
										 max_vnediagonal = fabs(Atemp[ii1].aij); //j,i
										 }
										 }
										 }
										 }
										 }


										 }
										 */

				ic++;

			

				if ((my_amg_manager.ipatch_number == 3)||(my_amg_manager.ipatch_number == 4)) {
					// Делает только сильно хуже
					// 25.01.2017 
					// F узлы берутся из множества Si transpose.
					integer imarker75_scan = 0;
					if (my_amg_manager.ipatch_number == 3) {
						//formirate_F_SiTranspose(hash_StrongTranspose_collection[Amat[ii].i], set, imarker75_scan);
						// из дерева в дерево.
						if (btree_vs_hash == 1) {
							if (bAVLST_ON) {
								formirate_F_SiTranspose_hash_table_Gus_struct01(hash_StrongTranspose_collection[Amat[ii].i], imarker75_scan);
							}
							else {
								formirate_F_SiTranspose_hash_table_Gus_struct02(hash_StrongTranspose_collection1[Amat[ii].i], imarker75_scan);
							}
						}
						else if (btree_vs_hash == 0) {
							if (bAVLST_ON) {
								formirate_F_SiTranspose_AVL_Gus(hash_StrongTranspose_collection[Amat[ii].i], root_Gus_set, imarker75_scan);
							}
							else {
								// обычный линейный список.
								formirate_F_SiTranspose_AVL_Gus(hash_StrongTranspose_collection1[Amat[ii].i], root_Gus_set, imarker75_scan);
							}
						}
						ic = imarker75_scan+1;
					}
					if (my_amg_manager.ipatch_number == 4) {
						// 28.01.2017
						// Мы берем F узлы из SiTranspose только в пересечении с U так пишут в книге.
					    if (btree_vs_hash == 1) {
							if (bAVLST_ON) {
								formirate_F_SiTranspose_hash_table_Gus2_struct01(hash_StrongTranspose_collection[Amat[ii].i], imarker75_scan, this_is_F_node, this_is_C_node);
							}
							else {
								// Обычный односвязный линейный список.
								formirate_F_SiTranspose_hash_table_Gus2_struct02(hash_StrongTranspose_collection1[Amat[ii].i], imarker75_scan, this_is_F_node, this_is_C_node);
							}
						}
					    else if (btree_vs_hash == 0) {
							if (bAVLST_ON) {
								formirate_F_SiTranspose_AVL_Gus2(hash_StrongTranspose_collection[Amat[ii].i], root_Gus_set, imarker75_scan, this_is_F_node, this_is_C_node);
							}
							else {
								// обычный линейный список.
								formirate_F_SiTranspose_AVL_Gus2(hash_StrongTranspose_collection1[Amat[ii].i], root_Gus_set, imarker75_scan, this_is_F_node, this_is_C_node);
							}
						}
						ic = imarker75_scan+1;

						/*
						// 21.05.2017 Устаревший код, его полностью заменяет 
						// formirate_F_SiTranspose_AVL_Gus2.

						//integer set_s[max_neighbour];
						// ic+2 точно должно хватить, к томуже ic+2 в большинстве случаев 
						// существенно меньше по размеру чем max_neighbour. 
						// Всегда лучше выделять памяти ровно столько сколько потребуется если 
						// точно известно сколько нужно.
						integer* set_s = new integer[ic+2];
						set_s[0] = set0;
						integer i98 = 1;
						for (integer i97 = 1; i97 < ic; i97++) {
							if ((this_is_F_node[set[i97]] == false) && (this_is_C_node[set[i97]] == false)) {
								// Если они из Strong Transpose в пересечении с U. 
								set_s[i98] = set[i97];
								i98++;
							}
						}
						ic = i98;
						for (integer i97 = 1; i97 < ic; i97++) {
							set[i97] = set_s[i97];
						}
						if (set_s != nullptr) {
							delete[] set_s;
							set_s = nullptr;
						}
						*/
					}
				}
				else {


					

					//  В set начиная с единицы и до <ic лежат кандидаты чтобы стать F.
					// 5.01.2017
					// 01.04.2017 Дополняемся F узлами из Si_Transpose связей.
					if ((my_amg_manager.ipatch_number == 7) && (bStrongTransposeON)) {

						integer imarker75_scan = 0;
						if (btree_vs_hash == 1) {
							if (bAVLST_ON) {
								formirate_F_SiTranspose_hash_table_Gus2_struct01(hash_StrongTranspose_collection[Amat[ii].i], imarker75_scan, this_is_F_node, this_is_C_node);
							}
							else {
								// обычный линейный список.
								formirate_F_SiTranspose_hash_table_Gus2_struct02(hash_StrongTranspose_collection1[Amat[ii].i], imarker75_scan, this_is_F_node, this_is_C_node);
							}
						}
						else if (btree_vs_hash == 0) {
							if (bAVLST_ON) {
								formirate_F_SiTranspose_AVL_Gus2(hash_StrongTranspose_collection[Amat[ii].i], root_Gus_set, imarker75_scan, this_is_F_node, this_is_C_node);
							}
							else {
								// обычный линейный список.
								formirate_F_SiTranspose_AVL_Gus2(hash_StrongTranspose_collection1[Amat[ii].i], root_Gus_set, imarker75_scan, this_is_F_node, this_is_C_node);
							}
						}
						ic = imarker75_scan+1; 

						/*

						hashlist_i* set_formirate = nullptr;
						getlist_AVL_node_global(hash_StrongTranspose_collection[Amat[ii].i], set_formirate);
						hashlist_i* set_formirate_marker = set_formirate;

						while (set_formirate_marker != nullptr) {
							// именно так рекомендуют в литературе.
							if ((this_is_F_node[set_formirate_marker->item] == false) && (this_is_C_node[set_formirate_marker->item] == false)) {
								// Если они из Strong Transpose в пересечении с U.
								vacant = set_formirate_marker->item;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_NEIGHBOUR;
									}
								}
								if (vacant != NULL_NEIGHBOUR) {
									set[ic] = vacant; // Si_Transpose связи.
									ic++;

									// А есть ли они в природе ?
									//printf("found Si_Transpose F candidate. my_amg_manager.ipatch_number == 7");
									#if doubleintprecision == 1
										//printf("%lld ", set[0]);
									#else
										//printf("%d ", set[0]);
									#endif
									
									//getchar();

								}
							}
							set_formirate_marker = set_formirate_marker->next;
						}

						set_formirate_marker = nullptr;
						clear_hash_list_i(set_formirate);
						set_formirate = nullptr;
						*/

					}

					ic_end_F_SiTranspose = ic; // С этой позиции заканчиваются F которые из Si_Transpose.

					// если узел j ещё не был добавлен в агрегат.
					if (bpositive_connections_CF_decomp) {
						if (flag[Amat[ii].j] == false) {
							if ((Amat[ii].j != set0) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
								// 21.05.2017
								bool bfound_vacant = false;
								if (btree_vs_hash == 1) {
									bfound_vacant = isfound_hash_table_Gus_struct01(Amat[ii].j);
									if (!bfound_vacant) {
										insert_hash_table_Gus_struct01(Amat[ii].j);
										ic++;
									}
								}
								else if (btree_vs_hash == 0) {
									bfound_vacant = isfound_Gus(root_Gus_set, Amat[ii].j);
									if (!bfound_vacant) {
										root_Gus_set = insert_Gus(root_Gus_set, Amat[ii].j);
										ic++;
									}
								}
								/*
								vacant = Amat[ii].j;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_NEIGHBOUR;
									}
								}
								if (vacant != NULL_NEIGHBOUR) {
									set[ic] = vacant;

									ic++;
								}
								*/
							}
						}
					}
					else {
						if (flag[Amat[ii].j] == false) {
							if ((Amat[ii].j != set0) && (Amat[ii].aij < 0.0) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
								// 21.05.2017
								bool bfound_vacant = false;
								if (btree_vs_hash == 1) {
									bfound_vacant = isfound_hash_table_Gus_struct01(Amat[ii].j);
									if (!bfound_vacant) {
										insert_hash_table_Gus_struct01(Amat[ii].j);
										ic++;
									}
								}
								else if (btree_vs_hash == 0) {
									bfound_vacant = isfound_Gus(root_Gus_set, Amat[ii].j);
									if (!bfound_vacant) {
										root_Gus_set = insert_Gus(root_Gus_set, Amat[ii].j);
										ic++;
									}
								}
								/*
								vacant = Amat[ii].j;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_NEIGHBOUR;
									}
								}
								if (vacant != NULL_NEIGHBOUR) {
									set[ic] = vacant;

									ic++;
								}
								*/
							}
						}
					}

					//printf("sboi start");

					integer iscan = ii + 1;
					iscan = ii_back + 1; // важная модификация 19 января 2016г.
										 // TODO 19 jan 2016.

					if (bpositive_connections_CF_decomp) {
						while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set0)) {
							// 14 февраля 2016 код иногда приводящий к сбою.
							//while (iscan <= row_startA[set0 + 1] - 1) { // код иногда приводящий к сбою по непонятной причине.
							// если узел j ещё не был добавлен в агрегат.
							if (flag[Amat[iscan].j] == false) {
								if ((Amat[iscan].j != set0) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
									// 21.05.2017
									bool bfound_vacant = false;
									if (btree_vs_hash == 1) {
										bfound_vacant = isfound_hash_table_Gus_struct01(Amat[iscan].j);
										if (!bfound_vacant) {
											insert_hash_table_Gus_struct01(Amat[iscan].j);
											ic++;
										}
									}
									else if (btree_vs_hash == 0) {
										bfound_vacant = isfound_Gus(root_Gus_set, Amat[iscan].j);
										if (!bfound_vacant) {
											root_Gus_set = insert_Gus(root_Gus_set, Amat[iscan].j);
											ic++;
										}
									}
									/*
									// Медленная версия с линейным поиском.
									vacant = Amat[iscan].j;
									for (integer js = 0; js < ic; js++) {
										if (vacant == set[js]) {
											vacant = NULL_NEIGHBOUR;
										}
									}
									if (vacant != NULL_NEIGHBOUR) {
										set[ic] = vacant;

										ic++;

									}
									*/
								}
							}

							iscan++;

						} // while
					}
					else {
						while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set0)) {
							// 14 февраля 2016 код иногда приводящий к сбою.
							//while (iscan <= row_startA[set0 + 1] - 1) { // код иногда приводящий к сбою по непонятной причине.
							// если узел j ещё не был добавлен в агрегат.
							if (flag[Amat[iscan].j] == false) {
								if ((Amat[iscan].j != set0) && (Amat[iscan].aij < 0.0) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
									// 21.05.2017
									bool bfound_vacant = false;
									if (btree_vs_hash == 1) {
										bfound_vacant = isfound_hash_table_Gus_struct01(Amat[iscan].j);
										if (!bfound_vacant) {
											insert_hash_table_Gus_struct01(Amat[iscan].j);
											ic++;
										}
									}
									else if (btree_vs_hash == 0) {
										bfound_vacant = isfound_Gus(root_Gus_set, Amat[iscan].j);
										if (!bfound_vacant) {
											root_Gus_set = insert_Gus(root_Gus_set, Amat[iscan].j);
											ic++;
										}
									}
									/*									
									vacant = Amat[iscan].j;
									for (integer js = 0; js < ic; js++) {
										if (vacant == set[js]) {
											vacant = NULL_NEIGHBOUR;
										}
									}
									if (vacant != NULL_NEIGHBOUR) {
										set[ic] = vacant;

										ic++;

									}
									*/
								}
							}

							iscan++;

						} // while
					}

					//printf("sboi end");
					// Это была учтена только связь i,j


					if (1&&(my_amg_manager.ipatch_number == 7) && (bStrongTransposeON)) {
					}
					else {

						// Связи j,i это фактически и есть связи из Si_Transpose.

						// Учёт свяи j,i
						//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
						//if ((Amat[ii1].i != set0) && (Amat[ii1].j == set0)) {
						//if (!flag[Amat[ii1].i]) {
						//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
						//   
						//   // 21.05.2017
						//   bool bfound_vacant = false;
						//if (btree_vs_hash == 1) {
						//	bfound_vacant = isfound_hash_table_Gus_struct01(Amat[ii1].i);
						//	if (!bfound_vacant) {
						//		insert_hash_table_Gus_struct01(Amat[ii1].i);
						//		ic++;
						//	}
						//}
						//else if (btree_vs_hash == 0) {
							//   bfound_vacant = isfound_Gus(root_Gus_set, Amat[ii1].i);
							//   if (!bfound_vacant) {
							//   	root_Gus_set = insert_Gus(root_Gus_set, Amat[ii1].i);
							//  	ic++;
							//   }
						//}
						//
						//   Устаревший код.
						//	vacant = Amat[ii1].i;
						//	for (integer js = 0; js < ic; js++) {
						//		if (vacant == set[js]) {
						//			vacant = NULL_NEIGHBOUR;
						//		}
						//	}
						//	if (vacant != NULL_NEIGHBOUR) {
						//		set[ic] = vacant; // j,i связь.

						//		ic++;
						//	}
						//
						//
						//	}
						//}
						//}
						//}

						// Учёт связи j,i
						// Медленная версия на основе линейного поиска.
						//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
						//if ((Amat[ii1].i != set0) && (Amat[ii1].j == set0)) {
						//if (!flag[Amat[ii1].i]) {
						//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
						//  
						//   21.05.2017
						//   bool bfound_vacant = false;
						//if (btree_vs_hash == 1) {
						//	bfound_vacant = isfound_hash_table_Gus_struct01(Amat[ii1].i);
						//	if (!bfound_vacant) {
						//		insert_hash_table_Gus_struct01(Amat[ii1].i);
						//		ic++;
						//	}
						//}
						//else if (btree_vs_hash == 0) {
							//   bfound_vacant = isfound_Gus(root_Gus_set, Amat[ii1].i);
							//   if (!bfound_vacant) {
							//   	root_Gus_set = insert_Gus(root_Gus_set, Amat[ii1].i);
							//  	ic++;
							//   }
						//}
						//
						//  Устаревший код.
						//	vacant = Amat[ii1].i;
						//	for (integer js = 0; js < ic; js++) {
						//		if (vacant == set[js]) {
						//			vacant = NULL_NEIGHBOUR;
						//		}
						//	}
						//	if (vacant != NULL_NEIGHBOUR) {
						//		set[ic] = vacant; // j,i связь.

						//		ic++;
						//	}
						//}
						//}
						//}
						//}

						if (bpositive_connections_CF_decomp) {
							if (bji) {
								// Учёт свяи j,i
								// Более быстрая версия на основе двоичного поиска.
								integer ii1 = BinarySearchAj(Atemp, set0, 1, nnz_a[ilevel - 1]);
								for (integer ii2 = ii1; (ii2 <= row_startA[set0 + 1] - 1); ii2++) {
									if ((Atemp[ii2].i != set0) && (!flag[Atemp[ii2].i])) {
										if (fabs(Atemp[ii2].aij) >= theta*max_vnediagonal) {

											// 21.05.2017
											bool bfound_vacant = false;
											if (btree_vs_hash == 1) {
												bfound_vacant = isfound_hash_table_Gus_struct01(Atemp[ii2].i);
												if (!bfound_vacant) {
													insert_hash_table_Gus_struct01(Atemp[ii2].i);
													ic++;
												}
											}
											else
											if (btree_vs_hash == 0) {
												bfound_vacant = isfound_Gus(root_Gus_set, Atemp[ii2].i);
												if (!bfound_vacant) {
													root_Gus_set = insert_Gus(root_Gus_set, Atemp[ii2].i);
													ic++;
												}
											}
											/*
											vacant = Atemp[ii2].i;
											for (integer js = 0; js < ic; js++) {
												if (vacant == set[js]) {
													vacant = NULL_NEIGHBOUR;
												}
											}
											if (vacant != NULL_NEIGHBOUR) {
												set[ic] = vacant; // j,i связь.
												ic++;
											}
											*/
										}
									}
								}


							}
						}
						else {
							if (bji) {
								// Учёт свяи j,i
								// Более быстрая версия на основе двоичного поиска.
								integer ii1 = BinarySearchAj(Atemp, set0, 1, nnz_a[ilevel - 1]);
								for (integer ii2 = ii1; (ii2 <= row_startA[set0 + 1] - 1); ii2++) {
									if ((Atemp[ii2].i != set0) && (!flag[Atemp[ii2].i])) {
										if ((Atemp[ii2].aij < 0.0) && (fabs(Atemp[ii2].aij) >= theta*max_vnediagonal)) {

											// 21.05.2017
											bool bfound_vacant = false;
											if (btree_vs_hash == 1) {
												bfound_vacant = isfound_hash_table_Gus_struct01(Atemp[ii2].i);
												if (!bfound_vacant) {
													insert_hash_table_Gus_struct01(Atemp[ii2].i);
													ic++;
												}
											}
											else if (btree_vs_hash == 0) {
												bfound_vacant = isfound_Gus(root_Gus_set, Atemp[ii2].i);
												if (!bfound_vacant) {
													root_Gus_set = insert_Gus(root_Gus_set, Atemp[ii2].i);
													ic++;
												}
											}

											/*
											vacant = Atemp[ii2].i;
											for (integer js = 0; js < ic; js++) {
												if (vacant == set[js]) {
													vacant = NULL_NEIGHBOUR;
												}
											}
											if (vacant != NULL_NEIGHBOUR) {
												set[ic] = vacant; // j,i связь.
												ic++;
											}
											*/
										}
									}
								}


							}
						}
					}

					
				}

				
				/*
				if (my_amg_manager.ipatch_number == 5) {
					// Делает только сильно хуже 

					// 28.01.2017
					// Мы берем узлы из SiTranspose только в пересечении с U так пишут в книге.

					//integer set_s[max_neighbour];
					//integer* set_s = new integer[max_neighbour];
					integer* set_s = new integer[ic + 2];
					set_s[0] = set0;
					integer i98 = 1;
					for (integer i97 = 1; i97 < ic; i97++) {
						if ((this_is_F_node[set[i97]] == false) && (this_is_C_node[set[i97]] == false)) {
							// Если они из Strong Transpose в пересечении с U. 
							set_s[i98] = set[i97];
							i98++;
						}
					}
					ic = i98;
					for (integer i97 = 1; i97 < ic; i97++) {
						set[i97] = set_s[i97];
					}

					if (set_s != nullptr) {
						delete[] set_s;
						set_s = nullptr;
					}
				}
				*/

				// В этом месте множество set успешно сформировано:
				// 1. Перепаковка из root_Gus_set в set.
				// 2. root_Gus_set больше не используется.
				// 3. Именно здесь надо выделить данные под set.
				//integer* set = new integer[max_neighbour];
				integer* set = nullptr;
				set = new integer[ic + 2];
				if (set == nullptr) {
					printf("error!!! memory for set is nullptr. Problem allocate detected.\n");
					printf("in function classic_aglomerative_amg4.\n");
					system("pause");
					exit(1);
				}

				integer ic_986 = 1;
				set[0] = set0;

				if (btree_vs_hash == 1) {

					formirate_hash_table_Gus_struct01__2__set(set, ic_986);

					clear_hash_table_Gus_struct01();
				}
				else if (btree_vs_hash == 0) {

					formirate_root_Gus_set__2__set(root_Gus_set, set, ic_986);

					clear_AVL_Gus(root_Gus_set);
					root_Gus_set = 0;

				}

				for (integer isc = 1; isc < ic; isc++) {
					this_is_F_node[set[isc]] = true; // это только новые F узлы.
					bmarkervisit[set[isc]] = true;
				}




				// Помечаем узлы как включённые в агрегат.
				for (integer js = 0; js < ic; js++) {
					flag[set[js]] = true;
				}






				// Алгоритм (5 декабря 2015 revised) 
				// 1. Сканируем все F которые соседи данного С на данном проходе.
				// 2. Для каждого фиксированного F сканируем его "строчных" соседей.
				// 3. Если узел еще не был включён в агрегат то ищем всех соседей данного узла на предмет 
				// соседства с фиксированным набором F из пункта 1.



				if (bAVL) {
					TreapNode* nrt_temp = nullptr;
					TreapNode* save_root = nullptr;

					/*
					if (id_tree == FIBONACCI_HEAP_ID) {
						if (!fibo_heap.isEmpty()) {
							fibo_heap.removeMinimum();
						}
					}
					*/
					// 12 декабря 2015.
					// Надо удалить из АВЛ дерева C и F узлы.
					// Это удаление очищает АВЛ дерево и приводит его к
					// рабочему состоянию. Удаление несуществующих в дереве узлов
					// производится корректно. Удаление производится за логарифмическое
					// по основанию 2  время от количества элементов в дереве
					// сбалансированность дерева при этом сохраняется.
					for (integer js = 0; js < ic; js++) {
						data_BalTree ddel;
						ddel.i = set[js];
						ddel.count_neighbour = count_neighbour[set[js]];
						// Уникальный ключ для дерева ван Эмде Боаса.
						integer  veb_del_key = (count_neighbour[set[js]])*(n_a[ilevel - 1]+1) + (set[js] );
						//ddel.ii = row_startA[ddel.i];
						switch (id_tree) {
						case RS_COARSENING_KERNEL_DATA_STRUCTURE::AVL_TREE: root = remove_AVL(root, ddel);
							break;
						case RS_COARSENING_KERNEL_DATA_STRUCTURE::SPLAY_TREE: root_splay = delete_splay_Tree(ddel, root_splay);
							break;
						case RS_COARSENING_KERNEL_DATA_STRUCTURE::BINARY_HEAP:
							// Уникальным ключом удаления является set[js].
							binary_heap.remove(set[js]);
							break;
						case RS_COARSENING_KERNEL_DATA_STRUCTURE::TREAP:
							save_root = random_tree_root;
							nrt_temp = search(random_tree_root, ddel);
							random_tree_root = save_root;
							save_root = nullptr;
							if (nrt_temp != nullptr) {
								nrt_temp = nullptr;
								random_tree_root=deleteNode(random_tree_root, ddel);
							}
							break;
						case RS_COARSENING_KERNEL_DATA_STRUCTURE::RED_BLACK_TREE:
							RBroot.Remove(ddel);
							break;
						case RS_COARSENING_KERNEL_DATA_STRUCTURE::FIBONACCI_HEAP:
							if (!fibo_heap.isEmpty()) {
								//fibo_heap.deleteKey(-veb_del_key);
								fibo_heap.deleteKey(ddel);
							}
							//RBroot.Remove(ddel);
							break;


						case RS_COARSENING_KERNEL_DATA_STRUCTURE::VAN_EMDE_BOAS_TREE:
#if VEB_FLAG
							// Если элемент присутствует то мы его удалим.
							res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_del_key);
							if (!res_vanEMDE_BOAS_Tree) {

							}
							else {
								res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_del_key);
								if (!res_vanEMDE_BOAS_Tree) {
									printf("nevozmochno udalit post factum delete %lld %lld\n", ddel.count_neighbour, ddel.i);
									system("pause");
								}
							}
#endif
							break;

						default: root = remove_AVL(root, ddel);
							break;
						}

						if (bAVL_deb)
						{
							printf("remove\n");
						}
					}
				}


				//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
				//flag_shadow[i_1] = flag[i_1];
				//}



				//integer i3 = 1;
				//while ((i3 <= n_a[ilevel - 1]) && (row_startA[i3] < istart)) i3++;
				//integer i4 = n_a[ilevel - 1];
				//while ((i4 >= 1) && (row_startA[i4]>iend)) i4--;


				// Ищем только среди ближайшего окружения вновь добавленного F узла.
				//for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {

				// Старая реализация которой присуща большая нагрузка на операторы new && delete.
#if 0
				if (0) {
					for (integer js = 1; js < ic; js++) {

						// см. новый вариант от 10 января 2016.

						// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
						// элемент lsos_head;
						List *lsos = nullptr;
						List *lsos_head = nullptr;
						lsos = new List;
						lsos->prev = nullptr;
						lsos_head = lsos;
						{
							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart2 = ii_11;
							//while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_11].i)) istart2--;
							//istart2++;
							istart2 = row_startA[Amat[ii_11].i];
							bool bvisitsos = false;
							for (integer is0 = istart2; (is0 <= row_startA[Amat[ii_11].i + 1] - 1); is0++) {
								if (flag[Amat[is0].j] == false) {
									lsos->next = nullptr;
									lsos->i = Amat[is0].j;
									lsos->ii = row_startA[lsos->i];
									// lsos->count_neighbour // не используется.
									List *newnodesos = new List;
									newnodesos->prev = lsos;
									lsos->next = newnodesos;
									newnodesos->next = nullptr;
									lsos = lsos->next;
									newnodesos = nullptr;
									bvisitsos = true;
								}
							}
							if (bvisitsos) {

								List *delsos = lsos;
								lsos = lsos->prev;
								lsos->next = nullptr;
								delsos->prev = nullptr;
								delete delsos;
								delsos = nullptr;
							}
							else {
								// Нет ни одного соседа
								lsos_head = nullptr;
								delete lsos;
								lsos = nullptr;
							}
						}

						lsos = lsos_head;
						// ищем соседа узла set[js].
						//for (integer i5 = i3; i5 <= i4; i5++) {
						while (lsos != nullptr) {


							//integer isc = Amat[ii_2].i;
							//integer ii_2 = row_startA[i5];
							//integer ii_2 = BinarySearchAi(Amat, i5, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							//integer isc = i5;

							integer isc = lsos->i;
							integer ii_2 = lsos->ii;


							//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
							//if (flag[isc] == false) {
							//flag_shadow[isc] = true;
							integer ic2 = 0;
							integer iend7 = nnz_a[ilevel - 1] + iadd;
							integer istart2 = ii_2;
							while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
							istart2++;
							for (integer is0 = istart2; (is0 <= iend7) && (Amat[is0].i == Amat[ii_2].i); is0++) {
								if (Amat[is0].j == set[js]) {
									ic2++;
								}
							}

							data_BalTree dsearch;
							dsearch.count_neighbour = count_neighbour[isc];
							//dsearch.ii = ii_2;
							dsearch.i = isc;
							count_neighbour[isc] += ic2;
							data_BalTree dadd;
							dadd.count_neighbour = count_neighbour[isc];
							//dadd.ii = ii_2;
							dadd.i = isc;

							//node<integer>* fibo_n;
							if (bmaxneighbourinfoactive) {
								// Обновляем информацию о максимальном количестве соседей.
								if (count_neighbour[isc] >= Maximumneighbourcount) {
									Maximumneighbourcount = count_neighbour[isc];
								}

								// Добавляем соседа в любом случае
								// позволило существенным образом 
								// ускорить алгоритм. Если раньше 
								// old = 48595  | 21229
								// new = 433315 | 63031
								// new2 = 19434 | 3698
								// и основное время уходило на old
								// то теперь
								// old = 1449 | 1466
								// new = 472600 | 64525
								// new2= 56544 | 18431
								// Время решения 3D задачи с 1M неизвестными 
								// сократилось с 6мин 48с до 4мин 45с.
								//node<integer>* fibo_n;

								if (bAVL) {

									TreapNode* nrt_temp = nullptr;
									TreapNode* save_root = nullptr;

									// Уникальный ключ для дерева ван Эмде Боаса.
									integer  veb_dadd_key = (dadd.count_neighbour)*(n_a[ilevel - 1]+1) + (dadd.i );
									integer  veb_dsearch_key = (dsearch.count_neighbour )*(n_a[ilevel - 1]+1) + (dsearch.i );

									// добавляем элемент в АВЛ дерево,
									// причём если элемент уже находился в дереве то он модифицируется.
									// 12 декабря 2015.
									// Добавление узла происходит за логарифмическое по основанию 2 время,
									// причём после добавления дерево остаётся сбалансированным.
									// Адельсон-Вельский и Ландис 1962.
									switch (id_tree) {
									case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
									case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
										break;
									case BINARY_HEAP:
										if (binary_heap.isfound(isc)) {
											// Найден
											// Удаляем существующий элемент и вставляем новый.
											binary_heap.remove(isc);
											// Осуществляем вставку нового элемента.
											binary_heap.insert(count_neighbour[isc], isc);
										}
										else {
											// отсутствует.
											// Осуществляем вставку нового элемента.
											binary_heap.insert(count_neighbour[isc], isc);
										}
										break;
									case RANDOM_TREE_ID:
										nrt_temp = nullptr;
										save_root = random_tree_root;
										nrt_temp = search(random_tree_root, dsearch);
										random_tree_root = save_root;
										save_root = nullptr;
										if (nrt_temp == nullptr) {
											// Элемент в дереве отсутствует.
											random_tree_root=insert(random_tree_root, dadd);
										}
										else {
											nrt_temp = nullptr;
											// Удаление
											random_tree_root=deleteNode(random_tree_root, dsearch);
											// Вставка
											random_tree_root=insert(random_tree_root, dadd);
										}
										break;
									case RED_BLACK_TREE_ID:
										RBroot.InsertAndModify(dadd, dsearch);
										break;
									case FIBONACCI_HEAP_ID:
										fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);
										//RBroot.InsertAndModify(dadd, dsearch);
										break;
									case VAN_EMDE_BOAS_TREE_ID:
#if VEB_FLAG
										res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
										if (!res_vanEMDE_BOAS_Tree) {
											// не найден
											res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
											if (!res_vanEMDE_BOAS_Tree) {
												// не найден
												res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
												if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
											}
										}
										else {
											res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
											if (!res_vanEMDE_BOAS_Tree) {
												printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
												system("pause");
											}
											// найден, удален м вставлен == заменен.
											res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
											if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
										}
#endif
										break;
									default: root = insert_and_modify(root, dadd, dsearch);
										break;
									}

									if (bAVL_deb)
									{
										printf("insert and modify\n");
									}
								}


							}
							//}
							lsos = lsos->next;
						}

						// Уничтожение lsos
						// Список постепенно уничтожается с головы.
						lsos = lsos_head;
						while (lsos != nullptr) {
							lsos_head = lsos_head->next;
							if (lsos_head != nullptr) {
								lsos_head->prev = nullptr;
							}
							lsos->next = nullptr;
							delete lsos;
							lsos = lsos_head;
						}

					}
				}
				else if (0) {
					for (integer js = 1; js < ic; js++) {

						// см.ниже  новый вариант от 10 января 2016.
						// 7 января 2016.
						// Новая версия в которой я избавился от лишних оператров new&&delete.
						// Никаких дублирующих линейных списков, никаких операторов new && delete.
						// Код стал намного понятнее.

						// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
						// элемент lsos_head;
						{
							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (flag[Amat[is0].j] == false) {


									integer isc = Amat[is0].j;
									integer ii_2 = row_startA[isc];

									//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
									//if (flag[isc] == false) {
									//flag_shadow[isc] = true;
									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									istart2++;
									for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
										if (Amat[is01].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.count_neighbour = count_neighbour[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									count_neighbour[isc] += ic2;
									data_BalTree dadd;
									dadd.count_neighbour = count_neighbour[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;

									// Уникальный ключ для дерева ван Эмде Боаса.
									integer  veb_dadd_key = (dadd.count_neighbour)*(n_a[ilevel - 1] + 1) + (dadd.i);
									integer  veb_dsearch_key = (dsearch.count_neighbour)*(n_a[ilevel - 1] + 1) + (dsearch.i);

									if (bmaxneighbourinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_neighbour[isc] >= Maximumneighbourcount) {
											Maximumneighbourcount = count_neighbour[isc];
										}

										// Добавляем соседа в любом случае
										// позволило существенным образом 
										// ускорить алгоритм. Если раньше 
										// old = 48595  | 21229
										// new = 433315 | 63031
										// new2 = 19434 | 3698
										// и основное время уходило на old
										// то теперь
										// old = 1449 | 1466
										// new = 472600 | 64525
										// new2= 56544 | 18431
										// Время решения 3D задачи с 1M неизвестными 
										// сократилось с 6мин 48с до 4мин 45с.
										//node<integer>* fibo_n;

										if (bAVL) {

											TreapNode* nrt_temp = nullptr;
											TreapNode* save_root = nullptr;

											// добавляем элемент в АВЛ дерево,
											// причём если элемент уже находился в дереве то он модифицируется.
											// 12 декабря 2015.
											// Добавление узла происходит за логарифмическое по основанию 2 время,
											// причём после добавления дерево остаётся сбалансированным.
											// Адельсон-Вельский и Ландис 1962.
											switch (id_tree)
											{
											case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
											case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch); break;
											case BINARY_HEAP:
												if (binary_heap.isfound(isc)) {
													// Найден
													// Удаляем существующий элемент и вставляем новый.
													binary_heap.remove(isc);
													// Осуществляем вставку нового элемента.
													binary_heap.insert(count_neighbour[isc], isc);
												}
												else {
													
													// отсутствует.
													// Осуществляем вставку нового элемента.
													binary_heap.insert(count_neighbour[isc], isc);
												}
												break;
											case RANDOM_TREE_ID:
												nrt_temp = nullptr;
												save_root = random_tree_root;
												nrt_temp = search(random_tree_root, dsearch);
												random_tree_root = save_root;
												save_root = nullptr;
												if (nrt_temp == nullptr) {
													// Элемент в дереве отсутствует.
													random_tree_root=insert(random_tree_root, dadd);
												}
												else {
													nrt_temp = nullptr;
													// Удаление
													random_tree_root = deleteNode(random_tree_root, dsearch);
													// Вставка
													random_tree_root=insert(random_tree_root, dadd);
												}
												break;
											case RED_BLACK_TREE_ID:
												RBroot.InsertAndModify(dadd, dsearch);
												break;
											case FIBONACCI_HEAP_ID:
												fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);											
												
												//RBroot.InsertAndModify(dadd, dsearch);
												break;
											case VAN_EMDE_BOAS_TREE_ID:
#if VEB_FLAG
												res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
												if (!res_vanEMDE_BOAS_Tree) {
													// не найден
													res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
													if (!res_vanEMDE_BOAS_Tree) {
														// не найден
														res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
														if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
													}
												}
												else {
													res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
													if (!res_vanEMDE_BOAS_Tree) {
														printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
														system("pause");
													}
													// найден, удален м вставлен == заменен.
													res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
													if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
												}

#endif
												break;
											default: root = insert_and_modify(root, dadd, dsearch);
												break;
											}

											if (bAVL_deb)
											{
												printf("insert and modify\n");
											}
										}


									}

								}
							}

						}
					}

				}
				else if (0) {
					// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;
								integer ii_2 = row_startA[isc];

								// При таком подходе некоторые соседи инкрементируются дважды и это
								// даёт хорошую скорость агломерации. Хватает 4 кратного размера памяти под исходную матриу.
								// Количество повторно инкрементируемых узлов составило около 33% в 2D на пятиточечном шаблоне.
								// Было решено оставить этот вариант кода т.к. он даёт хорошую скорость агломерации.


								integer ic2 = 0;
								integer iend2loc = nnz_a[ilevel - 1] + iadd;
								integer istart2 = ii_2;
								while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
								istart2++;
								for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
									if (Amat[is01].j == set[js]) {
										ic2++;
									}
								}

								data_BalTree dsearch;
								dsearch.count_neighbour = count_neighbour[isc];
								//dsearch.ii = ii_2;
								dsearch.i = isc;
								count_neighbour[isc] += ic2;
								data_BalTree dadd;
								dadd.count_neighbour = count_neighbour[isc];
								//dadd.ii = ii_2;
								dadd.i = isc;

								// Уникальный ключ для дерева ван Эмде Боаса.
								integer  veb_dadd_key = (dadd.count_neighbour)*(n_a[ilevel - 1] + 1) + (dadd.i);
								integer  veb_dsearch_key = (dsearch.count_neighbour)*(n_a[ilevel - 1] + 1) + (dsearch.i);

								//node<integer>* fibo_n;

								if (bAVL) {

									TreapNode* nrt_temp = nullptr;
									TreapNode* save_root = nullptr;

									// добавляем элемент в АВЛ дерево,
									// причём если элемент уже находился в дереве то он модифицируется.
									// 12 декабря 2015.
									// Добавление узла происходит за логарифмическое по основанию 2 время,
									// причём после добавления дерево остаётся сбалансированным.
									// Адельсон-Вельский и Ландис 1962.
									switch (id_tree)
									{
									case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
										break;
									case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
										break;
									case BINARY_HEAP:
										if (binary_heap.isfound(isc)) {
											// Найден
											// Удаляем существующий элемент и вставляем новый.
											binary_heap.remove(isc);
											// Осуществляем вставку нового элемента.
											binary_heap.insert(count_neighbour[isc], isc);
										}
										else {
											// отсутствует.
											// Осуществляем вставку нового элемента.
											binary_heap.insert(count_neighbour[isc], isc);
										}
										break;
									case RANDOM_TREE_ID:
										nrt_temp = nullptr;
										save_root = random_tree_root;
										nrt_temp = search(random_tree_root, dsearch);
										random_tree_root = save_root;
										save_root = nullptr;
										if (nrt_temp == nullptr) {
											// Элемент в дереве отсутствует.
											random_tree_root=insert(random_tree_root, dadd);
										}
										else {
											nrt_temp = nullptr;
											// Удаление
											random_tree_root = deleteNode(random_tree_root, dsearch);
											// Вставка
											random_tree_root=insert(random_tree_root, dadd);
										}
										break;
									case RED_BLACK_TREE_ID:
										RBroot.InsertAndModify(dadd, dsearch);
										break;
									case FIBONACCI_HEAP_ID:
										fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);
										
										//RBroot.InsertAndModify(dadd, dsearch);
										break;
									case VAN_EMDE_BOAS_TREE_ID:
#if VEB_FLAG
										res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
										if (!res_vanEMDE_BOAS_Tree) {
											// не найден
											res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
											if (!res_vanEMDE_BOAS_Tree) {
												// не найден
												res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
												if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
											}
										}
										else {
											res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
											if (!res_vanEMDE_BOAS_Tree) {
												printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
												system("pause");
											}
											// найден, удален м вставлен == заменен.
											res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
											if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
										}
#endif
										break;
									default: root = insert_and_modify(root, dadd, dsearch);
										break;
									}

									if (bAVL_deb)
									{
										printf("insert and modify\n");
									}
								}

								if (bmaxneighbourinfoactive) {
									// Обновляем информацию о максимальном количестве соседей.
									if (count_neighbour[isc] >= Maximumneighbourcount) {
										Maximumneighbourcount = count_neighbour[isc];
									}
								}

							}

						}
					}
				}
				else 
#endif
				if (1) {
					//printf("additional and modify new neighbour\n");

					// 10 января 2016. Новая логика.
					// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
					// Эта модификация даёт сокращение количества V циклов которые требуются до сходимости
					// Эта модификация наиболее близка к классической описанной в литературе чем все предыдущие.
					// На момент 13 января 2016 это лучший вариаент по скорости вычислений.
					integer itop_stack2 = 0;

					// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						//integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						//while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						//istart3++;
						istart3 = row_startA[Amat[ii_11].i];
						bool bvisitsos = false;
						for (integer is0 = istart3; (is0 <= row_startA[Amat[ii_11].i + 1] - 1); is0++) {
							//for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							// В пересечении с U!!!
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;

								if ((my_amg_manager.ipatch_number==1)||(my_amg_manager.ipatch_number == 2)) {
								// Избавляемся от повторных инкрементаций.
								// В 2D на пятиточечном шаблоне повторные инкрементации составляют
								// около 33%.
								// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
								// на ряде тестовых задач при таком подходе агломерация проходила очень
								// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
								// Эта проблема проявилась на задачах:
								// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
								// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
								// Проблема не в этом месте кода.
								if (hash_table2[isc] == false) {
									hash_table2[isc] = true;
									istack2[itop_stack2] = isc;
									itop_stack2++;
									// закомментированный лучше.
								}
								if (1) {
									//21_12_2016
									integer ii_2 = row_startA[isc];


									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									//while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									//istart2++;
									istart2 = row_startA[Amat[ii_2].i];
									integer istopmarker2 = row_startA[Amat[ii_2].i + 1] - 1;

#if 0
									if (0) {
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j == set[js]) {
												ic2++;
											}
										}
									}
									else if (0) {
										// 21 _12_2016
										doublerealT max_vnediagonal33 = -1.0e30;
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j != Amat[is01].i) {
												if (fabs(Amat[is01].aij) > max_vnediagonal33) {
													max_vnediagonal33 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (fabs(Amat[is01].aij) > theta*max_vnediagonal33) {
												if (Amat[is01].j == set[js]) {
													ic2++;
												}
											}
											// уменьшить счетчик weakly соседа ?
										}
									}
									else 
#endif
									if ((my_amg_manager.ipatch_number == 2)) {
										// 22 _12_2016
										// Это лучший вариант: обеспечивает корректное построение иерархии
										// уровней на задаче passive module 6 в то время как все остальные 
										// отличные от этого способа давали сбой.
										doublerealT max_vnediagonal33 = (doublerealT)(-1.0e30);
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j != Amat[is01].i) {
												if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > max_vnediagonal33)) {
													max_vnediagonal33 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > theta*max_vnediagonal33)) {
												if (Amat[is01].j == set[js]) {
													ic2++;
												}
											}
											// уменьшить счетчик weakly соседа ?
										}
									}
									else {
										// 22 _12_2016
										// Это лучший вариант: обеспечивает корректное построение иерархии
										// уровней на задаче passive module 6 в то время как все остальные 
										// отличные от этого способа давали сбой.
										doublerealT max_vnediagonal33 = (doublerealT)(-1.0e30);
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j != Amat[is01].i) {
												if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > max_vnediagonal33)) {
													max_vnediagonal33 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											// 0.2375 импирически подобрана для passive module 6.
											if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > 0.2375*max_vnediagonal33)) {
												if (Amat[is01].j == set[js]) {
													ic2++;
												}
											}
											// уменьшить счетчик weakly соседа ?
										}
									}

									data_BalTree dsearch;
									dsearch.count_neighbour = count_neighbour[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									// Увеличиваем на количество связей с новыми F узлами.
									count_neighbour[isc] += ic2;
									//if (ic2 > 0) {
									//count_neighbour[isc] += 1;
									//}
									data_BalTree dadd;
									dadd.count_neighbour = count_neighbour[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;

									// Уникальный ключ для дерева ван Эмде Боаса.
									integer  veb_dadd_key = (dadd.count_neighbour)*(n_a[ilevel - 1] + 1) + (dadd.i);
									integer  veb_dsearch_key = (dsearch.count_neighbour)*(n_a[ilevel - 1] + 1) + (dsearch.i);

									//node<integer>* fibo_n;

									if (bAVL) {

										TreapNode* nrt_temp = nullptr;
										TreapNode* save_root = nullptr;

										// добавляем элемент в АВЛ дерево,
										// причём если элемент уже находился в дереве то он модифицируется.
										// 12 декабря 2015.
										// Добавление узла происходит за логарифмическое по основанию 2 время,
										// причём после добавления дерево остаётся сбалансированным.
										// Адельсон-Вельский и Ландис 1962.
										switch (id_tree)
										{
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::AVL_TREE: root = insert_and_modify(root, dadd, dsearch);
											break;
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::SPLAY_TREE: root_splay = insert_and_modify(root_splay, dadd, dsearch);
											break;
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::BINARY_HEAP:
											if (binary_heap.isfound(isc)) {
												// Найден
												binary_heap.modify(isc, count_neighbour[isc]);
												// Удаляем существующий элемент и вставляем новый.
												//binary_heap.remove(isc);
												// Осуществляем вставку нового элемента.
												//binary_heap.insert(count_neighbour[isc], isc);
											}
											else {
												// отсутствует.
												// Осуществляем вставку нового элемента.
												binary_heap.insert(count_neighbour[isc], isc);
											}
											break;
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::TREAP:
											nrt_temp = nullptr;
											save_root = random_tree_root;
											nrt_temp = search(random_tree_root, dsearch);
											random_tree_root = save_root;
											save_root = nullptr;
											if (nrt_temp == nullptr) {
												// Элемент в дереве отсутствует.
												random_tree_root=insert(random_tree_root, dadd);
											}
											else {
												nrt_temp = nullptr;
												// Удаление
												random_tree_root = deleteNode(random_tree_root, dsearch);
												// Вставка
												random_tree_root=insert(random_tree_root, dadd);
											}
											break;
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::RED_BLACK_TREE:
											RBroot.InsertAndModify(dadd, dsearch);
											break;
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::FIBONACCI_HEAP:
											fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);
											//RBroot.InsertAndModify(dadd, dsearch);
											break;
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::VAN_EMDE_BOAS_TREE:
#if VEB_FLAG
											res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
											if (!res_vanEMDE_BOAS_Tree) {
												// не найден
												res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
												if (!res_vanEMDE_BOAS_Tree) {
													// не найден
													res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
													if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
												}
											}
											else {
												res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
												if (!res_vanEMDE_BOAS_Tree) {
													printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
													system("pause");
												}
												// найден, удален м вставлен == заменен.
												res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
												if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
											}
#endif
											break;
										default: root = insert_and_modify(root, dadd, dsearch);
											break;
										}
										if (bAVL_deb)
										{
											printf("insert and modify\n");
										}
									}

									if (bmaxneighbourinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_neighbour[isc] >= Maximumneighbourcount) {
											Maximumneighbourcount = count_neighbour[isc];
										}
									}
								}
							}
							else {
								// Избавляемся от повторных инкрементаций.
								// В 2D на пятиточечном шаблоне повторные инкрементации составляют
								// около 33%.
								// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
								// на ряде тестовых задач при таком подходе агломерация проходила очень
								// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
								// Эта проблема проявилась на задачах:
								// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
								// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
								// Проблема не в этом месте кода.
								if (hash_table2[isc] == false) {
								    hash_table2[isc] = true;
									istack2[itop_stack2] = isc;
									itop_stack2++;
									// закомментированный лучше.
									//}
									//if (1) {
									//21_12_2016
									integer ii_2 = row_startA[isc];


									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									//while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									//istart2++;
									istart2 = row_startA[Amat[ii_2].i];
									integer istopmarker2 = row_startA[Amat[ii_2].i + 1] - 1;

#if 0
									if (0) {
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j == set[js]) {
												ic2++;
											}
										}
									}
									else if (0) {
										// 21 _12_2016
										doublerealT max_vnediagonal33 = -1.0e30;
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j != Amat[is01].i) {
												if (fabs(Amat[is01].aij) > max_vnediagonal33) {
													max_vnediagonal33 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (fabs(Amat[is01].aij) > theta*max_vnediagonal33) {
												if (Amat[is01].j == set[js]) {
													ic2++;
												}
											}
											// уменьшить счетчик weakly соседа ?
										}
									}
									else if (0) {
										// 22 _12_2016
										// Это лучший вариант: обеспечивает корректное построение иерархии
										// уровней на задаче passive module 6 в то время как все остальные 
										// отличные от этого способа давали сбой.
										doublerealT max_vnediagonal33 = -1.0e30;
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j != Amat[is01].i) {
												if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > max_vnediagonal33)) {
													max_vnediagonal33 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > theta*max_vnediagonal33)) {
												if (Amat[is01].j == set[js]) {
													ic2++;
												}
											}
											// уменьшить счетчик weakly соседа ?
										}
									}
									else
#endif
									{
										// 22 _12_2016
										// Это лучший вариант: обеспечивает корректное построение иерархии
										// уровней на задаче passive module 6 в то время как все остальные 
										// отличные от этого способа давали сбой.
										doublerealT max_vnediagonal33 = (doublerealT)(-1.0e30);
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j != Amat[is01].i) {
												if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > max_vnediagonal33)) {
													max_vnediagonal33 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											// 0.2375 импирически подобрана для passive module 6.
											if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > 0.2375*max_vnediagonal33)) {
												if (Amat[is01].j == set[js]) {
													if ((my_amg_manager.ipatch_number == 7) && (bStrongTransposeON)) {
														if (js < ic_end_F_SiTranspose) {
															// Увеличиваем счётчики только тех соседей F узлов которые
															// являются соседями F узлов которые были получены из Si_Transpose связей.
															// Именно так написано у Руге и Штубена.
															ic2++;
														}
													}
													else {
														ic2++;
													}
													//ic2++;
												}
											}
											// уменьшить счетчик weakly соседа ?
										}
									}

									data_BalTree dsearch;
									dsearch.count_neighbour = count_neighbour[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									// Увеличиваем на количество связей с новыми F узлами.
									count_neighbour[isc] += ic2;
									//if (ic2 > 0) {
									//count_neighbour[isc] += 1;
									//}
									data_BalTree dadd;
									dadd.count_neighbour = count_neighbour[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;

									// Уникальный ключ для дерева ван Эмде Боаса.
									integer  veb_dadd_key = (dadd.count_neighbour)*(n_a[ilevel - 1] + 1) + (dadd.i);
									integer  veb_dsearch_key = (dsearch.count_neighbour)*(n_a[ilevel - 1] + 1) + (dsearch.i);

									//node<integer>* fibo_n;

									if (bAVL) {

										TreapNode* nrt_temp = nullptr;
										TreapNode* save_root = nullptr;

										// добавляем элемент в АВЛ дерево,
										// причём если элемент уже находился в дереве то он модифицируется.
										// 12 декабря 2015.
										// Добавление узла происходит за логарифмическое по основанию 2 время,
										// причём после добавления дерево остаётся сбалансированным.
										// Адельсон-Вельский и Ландис 1962.
										switch (id_tree)
										{
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::AVL_TREE: root = insert_and_modify(root, dadd, dsearch);
											break;
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::SPLAY_TREE: root_splay = insert_and_modify(root_splay, dadd, dsearch);
											break;
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::BINARY_HEAP:
											if (binary_heap.isfound(isc)) {
												// Найден
												// Удаляем существующий элемент и вставляем новый.
												binary_heap.remove(isc);
												// Осуществляем вставку нового элемента.
												binary_heap.insert(count_neighbour[isc], isc);
											}
											else {
												// отсутствует.
												// Осуществляем вставку нового элемента.
												binary_heap.insert(count_neighbour[isc], isc);
											}
											break;
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::TREAP:
											nrt_temp = nullptr;
											save_root = random_tree_root;
											nrt_temp = search(random_tree_root, dsearch);
											random_tree_root = save_root;
											save_root = nullptr;
											if (nrt_temp == nullptr) {
												// Элемент в дереве отсутствует.
												random_tree_root=insert(random_tree_root, dadd);
											}
											else {
												nrt_temp = nullptr;
												// Удаление
												random_tree_root = deleteNode(random_tree_root, dsearch);
												// Вставка
												random_tree_root=insert(random_tree_root, dadd);
											}
											break;
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::RED_BLACK_TREE:
											RBroot.InsertAndModify(dadd, dsearch);
											break;
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::FIBONACCI_HEAP:
											fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);
											//RBroot.InsertAndModify(dadd, dsearch);
											break;
										case RS_COARSENING_KERNEL_DATA_STRUCTURE::VAN_EMDE_BOAS_TREE:
#if VEB_FLAG
											res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
											if (!res_vanEMDE_BOAS_Tree) {
												// не найден
												res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
												if (!res_vanEMDE_BOAS_Tree) {
													// не найден
													res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
													if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
												}
											}
											else {
												res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
												if (!res_vanEMDE_BOAS_Tree) {
													printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
													system("pause");
												}
												// найден, удален м вставлен == заменен.
												res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
												if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
											}
#endif
											break;
										default: root = insert_and_modify(root, dadd, dsearch);
											break;
										}
										if (bAVL_deb)
										{
											printf("insert and modify\n");
										}
									}

									if (bmaxneighbourinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_neighbour[isc] >= Maximumneighbourcount) {
											Maximumneighbourcount = count_neighbour[isc];
										}
									}
								}
							}

							}

						}
					}

					// Очистка (восстановление хеш-таблицы).
                     // НИ в коем случае не параллелить по OPENMP в этом месте.!!!
					for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
						hash_table2[istack2[i_54]] = false;
					}
					itop_stack2 = 0; // стек снова готов к работе.


				} // the end
				else
 {
					// 13 января 2016. Новая логика.
					// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
					// Отличие в том что мы учитываем лишь Strong связи при инкрементации счётчика.
					// Это привело к 5 уровням вместо 13, и очень медленной сходимости.
					// Это было при magic=0.4
					// Strong связи при инкрементации счётчика не подходят по причине низкой производительности. 13 января 2016.
					integer itop_stack2 = 0;

					if (bpositive_connections_CF_decomp) {

						// На основе  старого варианта просто очищенного от устаревшего кода.
						for (integer js = 1; js < ic; js++) {

							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							doublerealT threshold9 = -1.0;
							if (!btreshold_on_new_vetv) {
								for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
									if (Amat[is0].j != Amat[ii_11].i) {
										if (fabs(Amat[is0].aij) > threshold9) {
											threshold9 = fabs(Amat[is0].aij);
										}
									}
								}
							}
							else {
								// Новейшая ветвь кода: 11.06.2017.
								threshold9 = threshold_quick_all[Amat[ii_11].i];
							}



							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (fabs(Amat[is0].aij) > theta*threshold9) {
									if (flag[Amat[is0].j] == false) {


										integer isc = Amat[is0].j;

										// Избавляемся от повторных инкрементаций.
										// В 2D на пятиточечном шаблоне повторные инкрементации составляют
										// около 33%.
										// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
										// на ряде тестовых задач при таком подходе агломерация проходила очень
										// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
										// Эта проблема проявилась на задачах:
										// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
										// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
										// Проблема не в этом месте кода.
										if (hash_table2[isc] == false) {
											hash_table2[isc] = true;
											istack2[itop_stack2] = isc;
											itop_stack2++;

											integer ii_2 = row_startA[isc];


											integer ic2 = 0;
											integer iend2loc = nnz_a[ilevel - 1] + iadd;
											integer istart2 = ii_2;
											while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
											istart2++;
											// Определяем модуль максимального внедиагонального элемента.
											doublerealT threshold_loc1 = -1.0; // инициализация порога.
											if (!btreshold_on_new_vetv) {
												for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
													// Только внедиагональные элементы.
													if (Amat[is01].j != Amat[ii_2].i) {
														if (fabs(Amat[is01].aij) > threshold_loc1) {
															threshold_loc1 = fabs(Amat[is01].aij);
														}
													}
												}
											}
											else {
												// Новейшая ветвь кода: 11.06.2017.
												threshold_loc1 = threshold_quick_all[Amat[ii_2].i];
											}
											for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
												// Только внедиагональные элементы.
												if (Amat[is01].j != Amat[ii_2].i) {
													if (Amat[is01].j == set[js]) {
														// только Strong связи
														// по крайней мере именно так рекомендуют в литературе.
														if (fabs(Amat[is01].aij) > theta*threshold_loc1) {
															ic2++;
														}
													}
												}
											}

											if (ic2 > 0) {
												// Только если были Strong связи приводящие к инкрементации счётчика ic2.


												data_BalTree dsearch;
												dsearch.count_neighbour = count_neighbour[isc];
												//dsearch.ii = ii_2;
												dsearch.i = isc;
												count_neighbour[isc] += ic2;
												data_BalTree dadd;
												dadd.count_neighbour = count_neighbour[isc];
												//dadd.ii = ii_2;
												dadd.i = isc;

												// Уникальный ключ для дерева ван Эмде Боаса.
												integer  veb_dadd_key = (dadd.count_neighbour)*(n_a[ilevel - 1] + 1) + (dadd.i);
												integer  veb_dsearch_key = (dsearch.count_neighbour)*(n_a[ilevel - 1] + 1) + (dsearch.i);

												//node<integer>* fibo_n;

												if (bAVL) {

													TreapNode* nrt_temp = nullptr;
													TreapNode* save_root = nullptr;

													// добавляем элемент в АВЛ дерево,
													// причём если элемент уже находился в дереве то он модифицируется.
													// 12 декабря 2015.
													// Добавление узла происходит за логарифмическое по основанию 2 время,
													// причём после добавления дерево остаётся сбалансированным.
													// Адельсон-Вельский и Ландис 1962.
													switch (id_tree)
													{
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::AVL_TREE: root = insert_and_modify(root, dadd, dsearch);
														break;
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::SPLAY_TREE: root_splay = insert_and_modify(root_splay, dadd, dsearch);
														break;
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::BINARY_HEAP:
														if (binary_heap.isfound(isc)) {
															// Найден
															// Удаляем существующий элемент и вставляем новый.
															binary_heap.remove(isc);
															// Осуществляем вставку нового элемента.
															binary_heap.insert(count_neighbour[isc], isc);
														}
														else {
															// отсутствует.
															// Осуществляем вставку нового элемента.
															binary_heap.insert(count_neighbour[isc], isc);
														}
														break;
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::TREAP:
														nrt_temp = nullptr;
														save_root = random_tree_root;
														nrt_temp = search(random_tree_root, dsearch);
														random_tree_root = save_root;
														save_root = nullptr;
														if (nrt_temp == nullptr) {
															// Элемент в дереве отсутствует.
															random_tree_root=insert(random_tree_root, dadd);
														}
														else {
															nrt_temp = nullptr;
															// Удаление
															random_tree_root = deleteNode(random_tree_root, dsearch);
															// Вставка
															random_tree_root=insert(random_tree_root, dadd);
														}
														break;
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::RED_BLACK_TREE:
														RBroot.InsertAndModify(dadd, dsearch);
														break;
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::FIBONACCI_HEAP:
														fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);
														//RBroot.InsertAndModify(dadd, dsearch);
														break;
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::VAN_EMDE_BOAS_TREE:
#if VEB_FLAG
														res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
														if (!res_vanEMDE_BOAS_Tree) {
															// не найден
															res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
															if (!res_vanEMDE_BOAS_Tree) {
																// не найден
																res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
																if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
															}
														}
														else {
															res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
															if (!res_vanEMDE_BOAS_Tree) {
																printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
																system("pause");
															}
															// найден, удален м вставлен == заменен.
															res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
															if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
														}
#endif
														break;
													default: root = insert_and_modify(root, dadd, dsearch);
														break;
													}
													if (bAVL_deb)
													{
														printf("insert and modify\n");
													}
												}
											}

											if (bmaxneighbourinfoactive) {
												// Обновляем информацию о максимальном количестве соседей.
												if (count_neighbour[isc] >= Maximumneighbourcount) {
													Maximumneighbourcount = count_neighbour[isc];
												}
											}
										}

									}
								}

							}


						}
					}
					else {

						// На основе  старого варианта просто очищенного от устаревшего кода.
						for (integer js = 1; js < ic; js++) {

							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							doublerealT threshold9 = -1.0;
							if (!btreshold_on_new_vetv) {
								for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
									if (Amat[is0].j != Amat[ii_11].i) {
										if ((Amat[is0].aij < 0.0) && (fabs(Amat[is0].aij) > threshold9)) {
											threshold9 = fabs(Amat[is0].aij);
										}
									}
								}
							}
							else {
								// Новейшая ветвь кода: 11.06.2017.
								threshold9 = threshold_quick_only_negative[Amat[ii_11].i];
							}



							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > theta*threshold9)) {
									if (flag[Amat[is0].j] == false) {


										integer isc = Amat[is0].j;

										// Избавляемся от повторных инкрементаций.
										// В 2D на пятиточечном шаблоне повторные инкрементации составляют
										// около 33%.
										// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
										// на ряде тестовых задач при таком подходе агломерация проходила очень
										// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
										// Эта проблема проявилась на задачах:
										// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
										// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
										// Проблема не в этом месте кода.
										if (hash_table2[isc] == false) {
											hash_table2[isc] = true;
											istack2[itop_stack2] = isc;
											itop_stack2++;

											integer ii_2 = row_startA[isc];


											integer ic2 = 0;
											integer iend2loc = nnz_a[ilevel - 1] + iadd;
											integer istart2 = ii_2;
											while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
											istart2++;
											// Определяем модуль максимального внедиагонального элемента.
											doublerealT threshold_loc1 = -1.0; // инициализация порога.
											if (!btreshold_on_new_vetv) {
												for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
													// Только внедиагональные элементы.
													if (Amat[is01].j != Amat[ii_2].i) {
														if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > threshold_loc1)) {
															threshold_loc1 = fabs(Amat[is01].aij);
														}
													}
												}
											}
											else {
												// Новейшая ветвь кода: 11.06.2017.
												threshold_loc1 = threshold_quick_only_negative[Amat[ii_2].i];
											}
											for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
												// Только внедиагональные элементы.
												if (Amat[is01].j != Amat[ii_2].i) {
													if (Amat[is01].j == set[js]) {
														// только Strong связи
														// по крайней мере именно так рекомендуют в литературе.
														if ((Amat[is01].aij<0.0) && (fabs(Amat[is01].aij) > theta*threshold_loc1)) {
															ic2++;
														}
													}
												}
											}

											if (ic2 > 0) {
												// Только если были Strong связи приводящие к инкрементации счётчика ic2.


												data_BalTree dsearch;
												dsearch.count_neighbour = count_neighbour[isc];
												//dsearch.ii = ii_2;
												dsearch.i = isc;
												count_neighbour[isc] += ic2;
												data_BalTree dadd;
												dadd.count_neighbour = count_neighbour[isc];
												//dadd.ii = ii_2;
												dadd.i = isc;

												// Уникальный ключ для дерева ван Эмде Боаса.
												integer  veb_dadd_key = (dadd.count_neighbour)*(n_a[ilevel - 1] + 1) + (dadd.i);
												integer  veb_dsearch_key = (dsearch.count_neighbour)*(n_a[ilevel - 1] + 1) + (dsearch.i);

												//node<integer>* fibo_n;

												if (bAVL) {

													TreapNode* nrt_temp = nullptr;
													TreapNode* save_root = nullptr;

													// добавляем элемент в АВЛ дерево,
													// причём если элемент уже находился в дереве то он модифицируется.
													// 12 декабря 2015.
													// Добавление узла происходит за логарифмическое по основанию 2 время,
													// причём после добавления дерево остаётся сбалансированным.
													// Адельсон-Вельский и Ландис 1962.
													switch (id_tree)
													{
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::AVL_TREE: root = insert_and_modify(root, dadd, dsearch);
														break;
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::SPLAY_TREE: root_splay = insert_and_modify(root_splay, dadd, dsearch);
														break;
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::BINARY_HEAP:
														if (binary_heap.isfound(isc)) {
															// Найден
															// Удаляем существующий элемент и вставляем новый.
															binary_heap.remove(isc);
															// Осуществляем вставку нового элемента.
															binary_heap.insert(count_neighbour[isc], isc);
														}
														else {
															// отсутствует.
															// Осуществляем вставку нового элемента.
															binary_heap.insert(count_neighbour[isc], isc);
														}
														break;
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::TREAP:
														nrt_temp = nullptr;
														save_root = random_tree_root;
														nrt_temp = search(random_tree_root, dsearch);
														random_tree_root = save_root;
														save_root = nullptr;
														if (nrt_temp == nullptr) {
															// Элемент в дереве отсутствует.
															random_tree_root=insert(random_tree_root, dadd);
														}
														else {
															nrt_temp = nullptr;
															// Удаление
															random_tree_root=deleteNode(random_tree_root, dsearch);
															// Вставка
															random_tree_root=insert(random_tree_root, dadd);
														}
														break;
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::RED_BLACK_TREE:
														RBroot.InsertAndModify(dadd, dsearch);
														break;
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::FIBONACCI_HEAP:
														fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);
														
														//RBroot.InsertAndModify(dadd, dsearch);
														break;
													case RS_COARSENING_KERNEL_DATA_STRUCTURE::VAN_EMDE_BOAS_TREE:
#if VEB_FLAG
														res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
														if (!res_vanEMDE_BOAS_Tree) {
															// не найден
															res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
															if (!res_vanEMDE_BOAS_Tree) {
																// не найден
																res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
																if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
															}
														}
														else {
															res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
															if (!res_vanEMDE_BOAS_Tree) {
																printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
																system("pause");
															}
															// найден, удален м вставлен == заменен.
															res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
															if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
														}
#endif
														break;
													default: root = insert_and_modify(root, dadd, dsearch);
														break;
													}
													if (bAVL_deb)
													{
														printf("insert and modify\n");
													}
												}
											}

											if (bmaxneighbourinfoactive) {
												// Обновляем информацию о максимальном количестве соседей.
												if (count_neighbour[isc] >= Maximumneighbourcount) {
													Maximumneighbourcount = count_neighbour[isc];
												}
											}
										}

									}
								}

							}


						}


					}

					// Очистка (восстановление хеш-таблицы).
					for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
						hash_table2[istack2[i_54]] = false;
					}
					itop_stack2 = 0; // стек снова готов к работе.


				}

				if (set != nullptr) {
					delete[] set;
					set = nullptr;
				}

				n_coarce++; // Увеличено количество С узлов.

							// Один агрегат создан.

			} // узел не был ещё включён в агрегат.



			bcontinue = false;
			for (integer i_1 = istartflag_scan; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (flag[i_1] == false) {
					bcontinue = true;
					istartflag_scan = i_1; // сокращаем пределы сканирования.
					break; // досрочный выход из цикла for.
						   //if (maxneighbour == -1) {
#if doubleintprecision == 1
						   //printf("ERROR!!!!  i_1=%lld\n", i_1);
#else
						   //printf("ERROR!!!!  i_1=%d\n", i_1);
#endif
						   
						   //system("pause");
						   //}
				}
			}

			// Вычисление узла с максимальным количеством соседей.
			maxneighbour = -1;
			icandidate = 0;


			// TODO 6 november
			//integer isize_p = -1;
			/*
			if (0) {

			// На основе линейного поиска (медленный вариант на больших размерностях).

			const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			integer* ipool = new integer[ipool_size_limit];

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			if (i_7 < ipool_size_limit) {
			if (ipool[i_7] == icandidateq) {
			found1 = true;
			}
			}
			else {
			#if doubleintprecision == 1
				printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			system("pause");
			exit(1);
			}
			}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;
			if (isize_p < ipool_size_limit) {
			ipool[isize_p] = icandidateq;
			}
			else {
			#if doubleintprecision == 1
				printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			system("pause");
			exit(1);
			}
			}
			ii_c++;
			}
			}
			delete[] ipool;

			}
			else if (0){

			// 4 января 2016. Медленный линейный поиск заменён на обработку АВЛ дерева.

			// На основе АВЛ дерева.
			//const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			//integer* ipool = new integer[ipool_size_limit];

			node_AVL_Gus* root_Gus = 0;

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			found1 = isfound_Gus(root_Gus, icandidateq);
			//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			//if (i_7 < ipool_size_limit) {
			//if (ipool[i_7] == icandidateq) {
			//found1 = true;
			//}
			//}
			//else {
			#if doubleintprecision == 1
				//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			//}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;

			root_Gus = insert_Gus(root_Gus, icandidateq);

			//if (isize_p < ipool_size_limit) {
			//ipool[isize_p] = icandidateq;
			//}
			//else {
			#if doubleintprecision == 1
				//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			}
			ii_c++;
			}
			}
			//delete[] ipool;
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

			// На основе сбалансированного АВЛ дерева поиска.
			}
			else {

			// 6 января 2016. Медленный линейный поиск заменён на обработку hash таблицы.

			// На основе hash таблицы.
			//const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			//integer* ipool = new integer[ipool_size_limit];

			//node_AVL_Gus* root_Gus = 0;
			// Нельзя это вызывать это очень медленно.
			//for (integer isc = 0; isc <= nnz_a[ilevel - 1]; isc++) hash_table[isc] = false; // initialization
			integer itop = 0; // указатель на вершину стека.

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			//found1 = isfound_Gus(root_Gus, icandidateq);
			found1 = hash_table[icandidateq - iadd];

			//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			//if (i_7 < ipool_size_limit) {
			//if (ipool[i_7] == icandidateq) {
			//found1 = true;
			//}
			//}
			//else {
			#if doubleintprecision == 1
				//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			//}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;

			//root_Gus = insert_Gus(root_Gus, icandidateq);
			hash_table[icandidateq - iadd] = true;
			if (itop < istack_size_limit ) {
			istack[itop] = icandidateq - iadd;
			itop++;
			}
			else {
			printf("itop>=istack_size_limit need to increase istack_size_limit");
			}

			//if (isize_p < ipool_size_limit) {
			//ipool[isize_p] = icandidateq;
			//}
			//else {
			#if doubleintprecision == 1
				//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			}
			ii_c++;
			}
			}
			//delete[] ipool;
			//clear_AVL_Gus(root_Gus);
			//root_Gus = 0;

			for (integer isc = itop - 1; isc >= 0; isc--) {
			hash_table[istack[isc]] = false;
			}
			itop = 0;

			// На основе сбалансированного АВЛ дерева поиска.
			}
			*/




			//	ibegining_start_index_found_maximum += isize_p + 1;

			if (bAVL) {
				if (bAVL_deb)
				{
					printf("found max");
				}
				// Данный код чрезвычайно компактен.
				bmaxneighbourinfoactive = true;
				// Надо найти максимальный элемент в АВЛ дереве.
				node_AVL* emax = 0;
				Tree_splay* emax_splay = 0;
				TreapNode* emax_random_tree = nullptr;
				TreapNode* save_root = nullptr;
				data_BalTree dbt_emax;// , dbt_emax2;

				integer ui_emax;

				switch (id_tree)
				{
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::AVL_TREE: emax = findmax(root);
					break;
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::SPLAY_TREE: emax_splay = findmax(root_splay);
					break;
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::BINARY_HEAP:
					if (!binary_heap.empty()) {
						// Куча не пуста.
						icandidate = row_startA[binary_heap.readkeymaxelm()];
					}
					else {
						size_splay_Tree = 0;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;
					}
					break;
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::TREAP:
					save_root = random_tree_root;
					if (emax_random_tree!=nullptr) {
					   delete[] emax_random_tree;
					   emax_random_tree=nullptr;
					}
 					emax_random_tree = findmax_random_tree(random_tree_root);
					random_tree_root = save_root;
					save_root = nullptr;

					break;
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::RED_BLACK_TREE:
					dbt_emax = RBroot.GetMaxElm();
					break;
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::FIBONACCI_HEAP:
					if (fibo_heap.isEmpty()) {
						dbt_emax.i = -1;
					//	fibo_heap.~FibonacciHeap();
					}
					else {
						ui_emax = -fibo_heap.getMinimum();
						dbt_emax.i = ((ui_emax) % (n_a[ilevel - 1] + 1));
						dbt_emax.count_neighbour = ((ui_emax) / (n_a[ilevel - 1] + 1));

						//if (dbt_emax.count_neighbour < 4) {
							//printf("Hipo\n");
							///getchar();
						//}

						//dbt_emax2 = RBroot.GetMaxElm();
						//if ((dbt_emax.count_neighbour != dbt_emax2.count_neighbour) || (dbt_emax.i!= dbt_emax2.i)) {
						  //  printf("%d %d %d %d\n", dbt_emax.count_neighbour, dbt_emax.i, dbt_emax2.count_neighbour, dbt_emax2.i);
						    //getchar();
						//}

						//if ((flag[Amat[row_startA[dbt_emax.i]].i]  )) dbt_emax.i = -1;

						//printf(" %d %d\n",  dbt_emax.count_neighbour, dbt_emax.i);
						//getchar();
					}
					break;
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::VAN_EMDE_BOAS_TREE:
#if VEB_FLAG
					if (!((vanEMDE_BOAS_Tree == nullptr) || (vanEMDE_BOAS_Tree->summary == nullptr) || (vanEMDE_BOAS_Tree->cluster == nullptr))) {
						vEB_max(vanEMDE_BOAS_Tree, ui_emax);
						if (ui_emax <= 0) {
							// дерево ван Эмде Боаса пустое.
							dbt_emax.i = -1;
							dbt_emax.count_neighbour = -1;
						}
						else {
							dbt_emax.i = ((ui_emax) % (n_a[ilevel - 1] + 1));
							dbt_emax.count_neighbour = ((ui_emax) / (n_a[ilevel - 1] + 1));
						}

					}
					else {
						// дерево ван Эмде Боаса пустое.
						dbt_emax.i = -1;
						dbt_emax.count_neighbour = -1;
					}
#endif
					break;
				default: emax = findmax(root);
					break;
				}


				switch (id_tree) {
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::AVL_TREE:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;

					}
					break;
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::SPLAY_TREE:
					// SPLAY tree
					if (emax_splay != 0) {


						//icandidate = emax_splay->item.ii; 23 jan 2016
						icandidate = row_startA[emax_splay->item.i];
						emax_splay = 0;

					}
					else {
						RBroot.Clear();
						root_splay = 0;
						size_splay_Tree = 0;
						random_tree_root = nullptr;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;

					}
					break;
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::BINARY_HEAP:
					break;
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::TREAP:
					// Random TREE
					if (emax_random_tree != nullptr) {
						icandidate = row_startA[emax_random_tree->key.i];
						if (emax_random_tree!=nullptr) {
					        delete emax_random_tree;
					        emax_random_tree=nullptr;
					    }
						emax_random_tree = nullptr;
					}
					else {
						RBroot.Clear();
						root_splay = 0;
						size_splay_Tree = 0;
						random_tree_root = nullptr;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;
					}
					break;
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::RED_BLACK_TREE:
					if (RBroot.Find(dbt_emax)) {
						icandidate = row_startA[dbt_emax.i];
					}
					else {
						RBroot.Clear();
						root_splay = 0;
						size_splay_Tree = 0;
						random_tree_root = nullptr;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;
					}
					break;
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::FIBONACCI_HEAP:
					if (dbt_emax.i == -1)
					{
						// Дерево пусто.
						RBroot.Clear();
						root_splay = 0;
						size_splay_Tree = 0;
						random_tree_root = nullptr;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;
					}
					else {
						// искомый узел и дерево ван Эмде Боаса не пусто.
						icandidate = row_startA[dbt_emax.i];
						//printf("row_startA = %d %d\n", icandidate, dbt_emax.i);

					}
					break;
				case RS_COARSENING_KERNEL_DATA_STRUCTURE::VAN_EMDE_BOAS_TREE:
					if (dbt_emax.i == -1)
				    {
						// Дерево пусто.
					    RBroot.Clear();
					    root_splay = 0;
					    size_splay_Tree = 0;
					    random_tree_root = nullptr;
					    icandidate = 0;
					    maxneighbour = -1;
					    bcontinue = false;
				    }
					else {
						// искомый узел и дерево ван Эмде Боаса не пусто.
						icandidate = row_startA[dbt_emax.i];
						//printf("row_startA = %d\n", icandidate);
					}
					break;
				default:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;

					}
					break;
				}


				

			}

		
#if doubleintprecision == 1
			//printf("maximum number of neighbour=%lld\n",maxneighbour);
#else
			//printf("maximum number of neighbour=%d\n",maxneighbour);
#endif
			
			if (maxneighbour == -1) if (debug_reshime) system("pause");
			//getchar();

			if ((icandidate == 0) && (maxneighbour == -1)) {
				bcontinue = false;
			}
			// 4 june 2016
#if doubleintprecision == 1
			//printf("icandidate=%lld, maxneighbour=%lld\n",icandidate, maxneighbour);
#else
			//printf("icandidate=%d, maxneighbour=%d\n",icandidate, maxneighbour);
#endif
			

			if (bAVL_deb)
			{
				print_AVL(root);
				system("pause");
			}

			icountprohod++;

		} // Построение C/F разбиения. создано.

		/*
		if (set != nullptr) {
			delete[] set;
			set = nullptr;
		}
		*/

		  //delete[] count_neighbour;
		if (count_neighbour != nullptr) {
			free(count_neighbour);
			count_neighbour = nullptr;
		}

		  //delete[] bmarkervisit;
		if (bmarkervisit != nullptr) {
			free(bmarkervisit);
			bmarkervisit = nullptr;
		}

		if (bprint_mesage_diagnostic) {
			if (n_a[ilevel - 1] == 0) {
				printf("n_a is zero\n");
				system("pause");
			}
			printf("additional C=%3.1f\n", (doublerealT)(100.0*newCcount / n_a[ilevel - 1]));
			//system("pause");
		}

		if (bAVL)
		{
			// Освобождение оперативной памяти из под АВЛ дерева.
			// 12 декабря 2015.
			switch (id_tree)
			{
			case RS_COARSENING_KERNEL_DATA_STRUCTURE::AVL_TREE: clear_AVL(root);
				root = 0;
				break;
			case RS_COARSENING_KERNEL_DATA_STRUCTURE::SPLAY_TREE:
				clear_SPLAY(root_splay);
				root_splay = 0;
				break;
			case RS_COARSENING_KERNEL_DATA_STRUCTURE::BINARY_HEAP:
				binary_heap.clear();
				break;
			case RS_COARSENING_KERNEL_DATA_STRUCTURE::TREAP:
				clear_random_tree(random_tree_root);
				random_tree_root = nullptr;
				break;
			case RS_COARSENING_KERNEL_DATA_STRUCTURE::RED_BLACK_TREE:
				RBroot.Clear();
				break;
			case RS_COARSENING_KERNEL_DATA_STRUCTURE::VAN_EMDE_BOAS_TREE:
#if VEB_FLAG
				if (!((vanEMDE_BOAS_Tree == nullptr) || (vanEMDE_BOAS_Tree->summary == nullptr) || (vanEMDE_BOAS_Tree->cluster == nullptr))) {
					vanEMDE_BOAS_Tree->~TvEB();
				}
				//vanEMDE_BOAS_Tree = nullptr;
				//vanEMDE_BOAS_Tree = new TvEB(universe);
#endif
				break;
			default: clear_AVL(root);
				root = 0;
				break;
			}

		}


		// В методе стандартной интерполяции присутствует шаг уменьшения разреженности,
		// для того чтобы правильно аппроксимировать все F переменные C переменными надо
		// увеличить количество С переменных.
		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;
		number_of_F_nodes_with_one_single_strong_C_neighborF = 0;

		iadditionalCstatistic = 0;

		bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			bool *bvacant_candidates = nullptr;
			bvacant_candidates = new bool[n_a[ilevel - 1] + 1];
			if (bvacant_candidates == nullptr) {
				printf("error memory alloc in bvacant_candidates\n");
				system("pause");
				exit(1);
			}
#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) bvacant_candidates[i_1] = false;

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (this_is_F_node[i_1]  ) {
					// Найти соседей данного F-node которые C-node.
					integer icsos = 0;
					// старая версия до 10 января 2016.
					//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					// Быстрый вариант без поиска, просто индексирование на основе "хеш-таблицы".
					// 10 января 2016. на основе хеширования.
					integer i_2 = row_startA[i_1];

					bool bvisit = false;
					//for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
					integer iend_merker_position = row_startA[Amat[i_2].i + 1] - 1;
					for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
						if (Amat[is0].j != Amat[i_2].i) {
							bvisit = true;
							if (this_is_C_node[Amat[is0].j]  ) {
								icsos++;
							}
							else {
								//the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
							}
						}
					}
					//if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным С соседом.
												   // Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
					if ((icsos == 0) && (bvisit)) {

						// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
						// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
						// поглощены агломератами внутренних узлов и всё было впорядке.
						// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

						// Нет С соседей, этот узел станет С узлом.
						bvacant_candidates[i_1] = true;
					}
				}
			}

			if (0)
			{

				// Однопоточная версия.

				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.

				for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]  ) {

					

					// Найти соседей данного F-node которые C-node.
					integer icsos = 0;
					// старая версия до 10 января 2016.
					//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					// Быстрый вариант без поиска, просто индексирование на основе "хеш-таблицы".
					// 10 января 2016. на основе хеширования.
					integer i_2 = row_startA[i_1];

					bool bvisit = false;
					//for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
					integer iend_merker_position = row_startA[Amat[i_2].i + 1] - 1;
					for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
						if (Amat[is0].j != Amat[i_2].i) {
							bvisit = true;
							if (this_is_C_node[Amat[is0].j]  ) {
								icsos++;
							}
							else {
								the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
								
							}
						}
					}
					if (icsos == 1) {
							number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным С соседом.
						
					}
					// Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
					if ((icsos == 0) && (bvisit)) {

						// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
						// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
						// поглощены агломератами внутренних узлов и всё было впорядке.
						// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

						integer i_5 = 0;
						for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
							if (Amat[is0].j != Amat[i_2].i) {
								if (bvacant_candidates[Amat[is0].j]) i_5++;
							}
						}

						if (i_5 > 0) {
							// Была сделана проверка в коде и соседних узлов с признаком
							// bvacant_candidates не было обнаружено.
#if doubleintprecision == 1
#if INTEGER_MIX_PRECISION_IS_INT
							printf("problem string %d %lld\n", Amat[i_2].i, i_1);
#else
							printf("problem string %lld %lld\n", Amat[i_2].i, i_1);
#endif
#else
							printf("problem string %d %d\n", Amat[i_2].i, i_1);
#endif
							
							//system("pause");
						}

						// Нет С соседей, этот узел станет С узлом.
						this_is_F_node[i_1] = false;
						this_is_C_node[i_1] = true;
						// F node стал C_node!!! Идея стандартной интерполяции 
						// приводит к уменьшению разреженности оператора Галёркина.
						bweSholdbeContinue = true;
						newCcount++;
						
					}

					// 1 января 2015 Один сосед это недостаточно.
					// Поэтому в случае одного соседа делаем такой узел С узлом.
					if ((false) && (icsos == 1)) {
						// bvisit и так true т.к. icsos==1.
						this_is_F_node[i_1] = false;
						this_is_C_node[i_1] = true;
						bweSholdbeContinue = true;
					}



				}
			}
			else {


#ifdef _OPENMP

				// Параллельное исполнение не более чем в 40 потоков
				integer newCcount_arr[40];
				integer the_number_of_neighbors_that_are_not_C_nodes_arr[40];
				integer number_of_F_nodes_with_one_single_strong_C_neighbor_arr[40];
				bool bweSholdbeContinue_arr[40];

				for (integer i_1 = 0; i_1 < 40; i_1++) {
					newCcount_arr[i_1] = 0;
					the_number_of_neighbors_that_are_not_C_nodes_arr[i_1] = 0;
					number_of_F_nodes_with_one_single_strong_C_neighbor_arr[i_1] = 0;
					bweSholdbeContinue_arr[i_1] = false;
				}

				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
#pragma omp parallel for
				for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) 
				{
					if (this_is_F_node[i_1]  ) {

#ifdef _OPENMP 
						int tid = omp_get_thread_num();
#else
						int tid = 0;
#endif

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						// старая версия до 10 января 2016.
						//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// Быстрый вариант без поиска, просто индексирование на основе "хеш-таблицы".
						// 10 января 2016. на основе хеширования.
						integer i_2 = row_startA[i_1];

						bool bvisit = false;
						//for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
						integer iend_merker_position = row_startA[Amat[i_2].i + 1] - 1;
						for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
							if (Amat[is0].j != Amat[i_2].i) {
								bvisit = true;
								if (this_is_C_node[Amat[is0].j]  ) {
									icsos++;
								}
								else {
									//the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
									the_number_of_neighbors_that_are_not_C_nodes_arr[tid]++;
								}
							}
						}
						if (icsos == 1) {
							//	number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
							number_of_F_nodes_with_one_single_strong_C_neighbor_arr[tid]++;
						}
						// Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
						if ((icsos == 0) && (bvisit)) {

							// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
							// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
							// поглощены агломератами внутренних узлов и всё было впорядке.
							// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

							integer i_5 = 0;
							for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
								if (Amat[is0].j != Amat[i_2].i) {
									if (bvacant_candidates[Amat[is0].j]) i_5++;
								}
							}

							if (i_5 > 0) {
								// Была сделана проверка в коде и соседних узлов с признаком
								// bvacant_candidates не было обнаружено.
#if doubleintprecision == 1
#if INTEGER_MIX_PRECISION_IS_INT
								printf("problem string %d %lld\n", Amat[i_2].i, i_1);
#else
								printf("problem string %lld %lld\n", Amat[i_2].i, i_1);
#endif
#else
								printf("problem string %d %d\n", Amat[i_2].i, i_1);
#endif
								
								//system("pause");
							}

							// Нет С соседей, этот узел станет С узлом.
							this_is_F_node[i_1] = false;
							this_is_C_node[i_1] = true;
							// F node стал C_node!!! Идея стандартной интерполяции 
							// приводит к уменьшению разреженности оператора Галёркина.
							//bweSholdbeContinue = true;
							//newCcount++;
							bweSholdbeContinue_arr[tid] = true;
							newCcount_arr[tid]++;
						}

						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							// bvisit и так true т.к. icsos==1.
							this_is_F_node[i_1] = false;
							this_is_C_node[i_1] = true;
							//bweSholdbeContinue = true;
							bweSholdbeContinue_arr[tid] = true;
						}

					}

				}

				for (integer i_1 = 0; i_1 < 40; i_1++) {
					newCcount += newCcount_arr[i_1];
					the_number_of_neighbors_that_are_not_C_nodes += the_number_of_neighbors_that_are_not_C_nodes_arr[i_1];
					number_of_F_nodes_with_one_single_strong_C_neighbor += number_of_F_nodes_with_one_single_strong_C_neighbor_arr[i_1];
					if (bweSholdbeContinue_arr[i_1]) {
						bweSholdbeContinue = true;
					}
				}

#else

// Параллельное исполнение не более чем в 40 потоков
integer newCcount_arr = 0;
integer the_number_of_neighbors_that_are_not_C_nodes_arr = 0;
integer number_of_F_nodes_with_one_single_strong_C_neighbor_arr = 0;
bool bweSholdbeContinue_arr = false;


// Построение пролонгации для узлов которые составляют F nodes.
// Каждый F-nodes окружён C-nodes.
for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++)
{
	if (this_is_F_node[i_1]  ) {


		// Найти соседей данного F-node которые C-node.
		integer icsos = 0;
		// старая версия до 10 января 2016.
		//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		// Быстрый вариант без поиска, просто индексирование на основе "хеш-таблицы".
		// 10 января 2016. на основе хеширования.
		integer i_2 = row_startA[i_1];

		bool bvisit = false;
		//for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
		integer iend_merker_position = row_startA[Amat[i_2].i + 1] - 1;
		for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
			if (Amat[is0].j != Amat[i_2].i) {
				bvisit = true;
				if (this_is_C_node[Amat[is0].j]  ) {
					icsos++;
				}
				else {
					//the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					the_number_of_neighbors_that_are_not_C_nodes_arr++;
				}
			}
		}
		if (icsos == 1) {
			//	number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
			number_of_F_nodes_with_one_single_strong_C_neighbor_arr++;
		}
		// Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
		if ((icsos == 0) && (bvisit)) {

			// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
			// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
			// поглощены агломератами внутренних узлов и всё было впорядке.
			// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.							

			// Нет С соседей, этот узел станет С узлом.
			this_is_F_node[i_1] = false;
			this_is_C_node[i_1] = true;
			// F node стал C_node!!! Идея стандартной интерполяции 
			// приводит к уменьшению разреженности оператора Галёркина.
			bweSholdbeContinue_arr = true;
			newCcount_arr++;
		}

		// 1 января 2015 Один сосед это недостаточно.
		// Поэтому в случае одного соседа делаем такой узел С узлом.
		if ((false) && (icsos == 1)) {
			// bvisit и так true т.к. icsos==1.
			this_is_F_node[i_1] = false;
			this_is_C_node[i_1] = true;
			//bweSholdbeContinue = true;
			bweSholdbeContinue_arr = true;
		}

	}

}

newCcount += newCcount_arr;
the_number_of_neighbors_that_are_not_C_nodes += the_number_of_neighbors_that_are_not_C_nodes_arr;
number_of_F_nodes_with_one_single_strong_C_neighbor += number_of_F_nodes_with_one_single_strong_C_neighbor_arr;
if (bweSholdbeContinue_arr) {
	bweSholdbeContinue = true;
}


#endif


			}


			if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
				printf("newCcount=%lld, n_a=%lld %e\n", newCcount, n_a[ilevel - 1], 100.0*newCcount / n_a[ilevel - 1]);
#else
				printf("newCcount=%d, n_a=%d %e\n", newCcount, n_a[ilevel - 1], 100.0*newCcount / n_a[ilevel - 1]);
#endif
				
			}
			if (bvacant_candidates != nullptr) {
				delete[] bvacant_candidates;
			}

			if (bprint_mesage_diagnostic) {
				if (bweSholdbeContinue) {
					printf(" prohod succseful\n");
				}
				else {
					printf("prohod empty\n");
				}
			}

		}


		// 01.01.2017 Алгоритм улучшения качества C/F разбиения. Проход 2. 
		// Цикл по всем F переменным, полученным после первого прохода.
		// Пусть Fi текущая F переменная и у неё множество соседей не пусто.
		// Сканируем строку элементов где Fi есть диагональный элемент.
		// Amat. Определяем порог - threshold для каждой строки.
		// В. Заносим всех сильных С соседей в специальный линейный список.
		// C. Еслимы встретили сильного F соседа  (Fj), так что Fi и Fj сильно связаны,
		// то ищем всех сильных С соседей узла Fj и формируем из них линейный список.
		// С помощью алгоритма слияния за линейное время сравниваем два предварительно отсортированных линейных
		// списка на предмет общих С узлов.
		// D. Если общий С узел есть то ничего не меняем.
		// E. Если общего сильного С узла не обнаружено то один из узлов Fi или Fj становится С узлом.
		// Среди Fi и Fj тот становится С узлом у которого больше сильных F соседей. Если С узлом стал Fj 
		// то линейный список С соседей узла Fi обновляется. Если С узлом стал узел Fi то мы заканчиваем обработку Fi 
		// возвращая всех помеченных Fj снова в F тип.
		//  30.12.2016
		// 11.06.2017 Здесь для сортировки используется библиотечный std::sort на массиве.
		if ((my_amg_manager.icoarseningtype== MY_AMG_SPLITTING_COARSENING_ALGORITHM::RS2_ALL_CONNECTION)||
			(my_amg_manager.icoarseningtype == MY_AMG_SPLITTING_COARSENING_ALGORITHM::RS2_ST_ALL_CONNECTION)) { // RS2 Проход 2.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]  ) {
				// i_1 это F переменная Fi.
				//Amat.Определяем порог - threshold для каждой строки.
				doublerealT thresholdRS = -1.0;
				integer i_2 = row_startA[i_1];
				if (!bAVLST_ON) {
					// Очистка хеш-таблицы.
					clear_hash_table_Gus_struct01();
					// занесение данных из линейного списка в хеш-таблицу для дерева с корнем в Amat[i_2].i.
					integer imarker75_scan = 0;
					formirate_F_SiTranspose_hash_table_Gus_struct02(hash_StrongTranspose_collection1[Amat[i_2].i], imarker75_scan);
				}

				integer iend_merker_position = row_startA[Amat[i_2].i + 1] - 1;
				if (!btreshold_on_new_vetv) {
					for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
						if (Amat[is0].j != Amat[i_2].i) {
							if (Amat[is0].aij < 0.0) {
								if (fabs(Amat[is0].aij) > thresholdRS) thresholdRS = fabs(Amat[is0].aij);
							}
						}
					}
				}
				else {
					// Новейшая ветвь кода: 11.06.2017.
					thresholdRS = threshold_quick_only_negative[Amat[i_2].i];
				}
				if (thresholdRS > 0.0) {
					// Множество соседей не пусто а порог равен thresholdRS.
					hashlist_i* ivacant_F2C = nullptr;
					//  В. Заносим всех сильных С соседей в специальный линейный список.
					hashlist_i* ibuffer_strongC = nullptr;
					//integer ibuffer_strongC[1000];
					integer ibuffer_strongC_marker = -1;
					integer inumber_strongF_count_Fi = 0;
					//integer ibuffer_strongF[1000];
					hashlist_i* ibuffer_strongF = nullptr;
					integer ibuffer_strongF_marker = -1;
					for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
						if (Amat[is0].j != Amat[i_2].i) {
							if (Amat[is0].aij < 0.0) {
								if (fabs(Amat[is0].aij) > theta*thresholdRS) {
									if (this_is_C_node[Amat[is0].j]  ) {
										ibuffer_strongC_marker++;
										//if (ibuffer_strongC_marker < 1000) {
											//ibuffer_strongC[ibuffer_strongC_marker] = Amat[is0].j;
										//}
										//else {
											//printf("Error!!! ibuffer_strongC: buffer overflow.\n");
											//system("PAUSE");
											//exit(1);
										//}
										insertion_list_i(ibuffer_strongC, Amat[is0].j);
									}
									if (this_is_F_node[Amat[is0].j]  ) {

										if (1) {
											// Добавок 19.01.2017
											if (!bAVLST_ON) {
												if (hash_StrongTranspose_collection != nullptr) {
													data_BalTreeST dat_key;
													dat_key.i = Amat[is0].j;
													if (isfound(hash_StrongTranspose_collection[Amat[is0].i], dat_key)) {
														// конец добавка 19.01.2017

															// Сильный Fj сосед найден.
															// Элементы Fi и Fj сильно связаны.
														inumber_strongF_count_Fi++;
														ibuffer_strongF_marker++;
														//if (ibuffer_strongF_marker < 1000) {
															//ibuffer_strongF[ibuffer_strongF_marker] = Amat[is0].j;
														//}
														//else {
															//printf("Error!!! ibuffer_strongF: buffer overflow.\n");
															//system("PAUSE");
															//exit(1);
														//}
														insertion_list_i(ibuffer_strongF, Amat[is0].j);
													}
												}
												else {
													// Сильный Fj сосед найден.
													// Элементы Fi и Fj сильно связаны.
													inumber_strongF_count_Fi++;
													ibuffer_strongF_marker++;
													//if (ibuffer_strongF_marker < 1000) {
													//ibuffer_strongF[ibuffer_strongF_marker] = Amat[is0].j;
													//}
													//else {
													//printf("Error!!! ibuffer_strongF: buffer overflow.\n");
													//system("PAUSE");
													//exit(1);
													//}
													insertion_list_i(ibuffer_strongF, Amat[is0].j);
												}
											}
											else {
												// Обычный линейный список.
												if (hash_StrongTranspose_collection1 != nullptr) {
													data_BalTreeST dat_key;
													dat_key.i = Amat[is0].j;
													//if (isfound(hash_StrongTranspose_collection[Amat[is0].i], dat_key)) {
													if (isfound_hash_table_Gus_struct01(Amat[is0].j)) {
													    // конец добавка 19.01.2017

														// Сильный Fj сосед найден.
														// Элементы Fi и Fj сильно связаны.
														inumber_strongF_count_Fi++;
														ibuffer_strongF_marker++;
														//if (ibuffer_strongF_marker < 1000) {
														//ibuffer_strongF[ibuffer_strongF_marker] = Amat[is0].j;
														//}
														//else {
														//printf("Error!!! ibuffer_strongF: buffer overflow.\n");
														//system("PAUSE");
														//exit(1);
														//}
														insertion_list_i(ibuffer_strongF, Amat[is0].j);
													}
												}
												else {
													// Сильный Fj сосед найден.
													// Элементы Fi и Fj сильно связаны.
													inumber_strongF_count_Fi++;
													ibuffer_strongF_marker++;
													//if (ibuffer_strongF_marker < 1000) {
													//ibuffer_strongF[ibuffer_strongF_marker] = Amat[is0].j;
													//}
													//else {
													//printf("Error!!! ibuffer_strongF: buffer overflow.\n");
													//system("PAUSE");
													//exit(1);
													//}
													insertion_list_i(ibuffer_strongF, Amat[is0].j);
												}
											}
										}
										else {
											// Сильный Fj сосед найден.
											// Элементы Fi и Fj сильно связаны.
											inumber_strongF_count_Fi++;
											ibuffer_strongF_marker++;
											//if (ibuffer_strongF_marker < 1000) {
											//ibuffer_strongF[ibuffer_strongF_marker] = Amat[is0].j;
											//}
											//else {
											//printf("Error!!! ibuffer_strongF: buffer overflow.\n");
											//system("PAUSE");
											//exit(1);
											//}
											insertion_list_i(ibuffer_strongF, Amat[is0].j);
										}
									}
								}
							}
						}
					}
					// Очистка хеш-таблицы.
					clear_hash_table_Gus_struct01();
					// Сортировка буффера ibuffer_strongC по возрастанию.
					integer* ibuffer_strong_C_bs = nullptr;
					// рекомендуется использовать iusage_old_version = 0
					// при котором активируется использование быстродействующей хеш-таблицы.
					// Достигается ускорение полного цикла решения задачи при включённом RS2 coarsening
					// на 7.5% по сравнению с двоичным поиском на массиве. 
					// Полностью отпадает необходимость в использовании алгоритма сортировки.
					// 11.06.2017.
					integer iusage_old_version = 0; // 1 старая рабочая версия. // 0 новая версия на основе хеш-таблицы.
					integer i_5 = 0;
					if (iusage_old_version) {
						// Выделяем память сразу с запасом, чтобы избежать перевыделений и уничтожений.
						//ibuffer_strong_C_bs = (integer*)malloc((ibuffer_strongC_marker + ibuffer_strongF_marker + 1) * sizeof(integer));
						//handle_error<integer>(ibuffer_strong_C_bs, "ibuffer_strong_C_bs", "classic_aglomerative_amg_4", (ibuffer_strongC_marker + ibuffer_strongF_marker + 1));
						// iend_merker_position - i_2 +3
						ibuffer_strong_C_bs = (integer*)malloc((iend_merker_position - i_2 + 3) * sizeof(integer));
						handle_error<integer>(ibuffer_strong_C_bs, "ibuffer_strong_C_bs", "classic_aglomerative_amg_4", (iend_merker_position - i_2 + 3));
						hashlist_i* ibuffer_strongC_scan = ibuffer_strongC;
						i_5 = 0;
						while (ibuffer_strongC_scan != nullptr) {
							ibuffer_strong_C_bs[i_5] = ibuffer_strongC_scan->item;
							i_5++;
							ibuffer_strongC_scan = ibuffer_strongC_scan->next;
						}
						ibuffer_strongC_scan = nullptr;
					}
					else {
						// Вместо сортировки и двоичного поиска используем хеш-таблицу.
						clear_hash_table_Gus_struct01();
						hashlist_i* ibuffer_strongC_scan = ibuffer_strongC;
						while (ibuffer_strongC_scan != nullptr) {
							insert_hash_table_Gus_struct01(ibuffer_strongC_scan->item);
							ibuffer_strongC_scan = ibuffer_strongC_scan->next;
						}
						ibuffer_strongC_scan = nullptr;
					}
					
					// Сортировка целочисленного массива при индексации с нуля!!!
					if (iusage_old_version) {
						/*
						if ((i_5 - 1 <= 7)) {
							// Сортировка по возрастанию.
							// Сортировка вставками до  10 элементов чрезвычайно эффективна.
							for (integer i_8 = 1; i_8 <= i_5 - 1; i_8++) {
								integer i_7 = i_8;
								while ((i_7>0)&&(ibuffer_strong_C_bs[i_7] < ibuffer_strong_C_bs[i_7 - 1])) {
									integer ibuf31 = ibuffer_strong_C_bs[i_7];
									ibuffer_strong_C_bs[i_7] = ibuffer_strong_C_bs[i_7 - 1];
									ibuffer_strong_C_bs[i_7 - 1] = ibuf31;
									i_7--;
								}
							}
						}
						else {
							// Сюда подключим библиотечную быструю сортировку
							// Это стандартная функция языка СИ.
							qsort(ibuffer_strong_C_bs, i_5, sizeof(integer), intcompare);

						}
						*/
						// 3 января 2017.
						std::sort(ibuffer_strong_C_bs, ibuffer_strong_C_bs + i_5);
					}
					// Все сильные F соседи занесены в буффер ibuffer_strongF. 
					hashlist_i* ibuffer_strongF_current = ibuffer_strongF;
					for (integer i_3 = 0; i_3 <= ibuffer_strongF_marker; i_3++) {
						if (ibuffer_strongF_current!=nullptr) {
						// Сканируем всех сильных F соседей последовательно.
						//1. Определяем threshold для Fj.
						doublerealT thresholdRS1 = -1.0;
						integer i_4 = row_startA[ibuffer_strongF_current->item];
						integer iend_merker_position1 = row_startA[Amat[i_4].i + 1] - 1;
						if (!btreshold_on_new_vetv) {
							for (integer is01 = i_4; (is01 <= iend_merker_position1); is01++) {
								if (Amat[is01].j != Amat[i_4].i) {
									if (Amat[is01].aij < 0.0) {
										if (fabs(Amat[is01].aij) > thresholdRS1) thresholdRS1 = fabs(Amat[is01].aij);
									}
								}
							}
						}
						else {
							// Новейшая ветвь кода: 11.06.2017.
							thresholdRS1 = threshold_quick_only_negative[Amat[i_4].i];
						}
						integer inumber_strongF_count_Fj = 0;
						// искомый порог thresholdRS1.
						//integer ibuffer_strongCFj[1000];
						hashlist_i* ibuffer_strongCFj = nullptr;
						integer ibuffer_strongCFj_marker = -1;
						for (integer is01 = i_4; (is01 <= iend_merker_position1); is01++) {
							if (Amat[is01].j != Amat[i_4].i) {
								if (Amat[is01].aij < 0.0) {
									if (fabs(Amat[is01].aij) > theta*thresholdRS1) {
										if (this_is_C_node[Amat[is01].j]  ) {
											ibuffer_strongCFj_marker++;
											insertion_list_i(ibuffer_strongCFj, Amat[is01].j);
											//if (ibuffer_strongCFj_marker < 1000) {
											//	ibuffer_strongCFj[ibuffer_strongCFj_marker] = Amat[is01].j;
											//}
											//else {
											//	printf("Error!!! ibuffer_strongCFj: buffer overflow.\n");
											//	system("PAUSE");
											//	exit(1);
											//}
										}
										if (this_is_F_node[Amat[is01].j]  ) {
											inumber_strongF_count_Fj++;
										}
									}
								}
							}
						}
						// В ibuffer_strongCFj список сильных С соседей.

						// Есть ли общие С узлы за линейное время.
						// Создаём на основе списка ibuffer_strongC
						// целочисленный массив.
						// Сортируем его. Делаем  ibuffer_strongCFj_marker 
						// двоичных поисков в этом отсортированном массиве 
						// до тех пор пока не встретится успешный поиск.
						bool bfound_32 = false;
						hashlist_i* ibuffer_strongCFj_scan = ibuffer_strongCFj;
						if (iusage_old_version) {
							while ((bfound_32 == false) && (ibuffer_strongCFj_scan != nullptr)) {
								if (BinarySearch(ibuffer_strong_C_bs, ibuffer_strongCFj_scan->item, i_5 - 1) > -1) {
									// Совпадение найдено мы ничего не делаем.
									bfound_32 = true;
								}
								ibuffer_strongCFj_scan = ibuffer_strongCFj_scan->next;
							}
						}
						else {
							// Версия на основе хеш-таблицы.
							while ((bfound_32 == false) && (ibuffer_strongCFj_scan != nullptr)) {
								// Совпадение найдено мы ничего не делаем.
								bfound_32 = isfound_hash_table_Gus_struct01(ibuffer_strongCFj_scan->item);
								ibuffer_strongCFj_scan = ibuffer_strongCFj_scan->next;
							}
						}
						ibuffer_strongCFj_scan = nullptr;
						if (bfound_32 == false) {
							// Один из них станет С узлом.
							if ((ibuffer_strongF_current->item > i_1) && (inumber_strongF_count_Fj >= inumber_strongF_count_Fi)) {
								// Если Fj находится в ещё непросмотренной части списка F узлов и
								// унего по сравнению с F узлом Fi больше сильных F связей.								

								// Fj становится С.
								insertion_list_i(ivacant_F2C, ibuffer_strongF_current->item);
								this_is_C_node[ibuffer_strongF_current->item] = true;
								this_is_F_node[ibuffer_strongF_current->item] = false;
								ibuffer_strongC_marker++;
								inumber_strongF_count_Fi--;
								insertion_list_i(ibuffer_strongC, ibuffer_strongF_current->item);
								// Переформировываем налету массив в котором делаем двоичные поиски.
								// Мы сразу выделили весь необходимый объём оперативной памяти, 
								// заранее поэтому частые malloc и free вовсе ненужны.
								// 2.01.2017
								//if (ibuffer_strong_C_bs != nullptr) {
									//free(ibuffer_strong_C_bs);
								//}
								//ibuffer_strong_C_bs = (integer*)malloc((ibuffer_strongC_marker + 1) * sizeof(integer));
								//handle_error<integer>(ibuffer_strong_C_bs, "ibuffer_strong_C_bs", "classic_aglomerative_amg_4", (ibuffer_strongC_marker + 1));

								hashlist_i* ibuffer_strongC_scan = ibuffer_strongC;
								integer i_5 = 0;
								
								if (iusage_old_version) {
									
									while (ibuffer_strongC_scan != nullptr) {
										ibuffer_strong_C_bs[i_5] = ibuffer_strongC_scan->item;
										i_5++;
										ibuffer_strongC_scan = ibuffer_strongC_scan->next;
									}
								}
								else {
									// Очищаем хеш-таблицу и заполняем её по новой.
									clear_hash_table_Gus_struct01();
									while (ibuffer_strongC_scan != nullptr) {
										insert_hash_table_Gus_struct01(ibuffer_strongC_scan->item);
										ibuffer_strongC_scan = ibuffer_strongC_scan->next;
									}
								}
									
								
								ibuffer_strongC_scan = nullptr;
								// Сортировка целочисленного массива при индексации с нуля!!!
								if (iusage_old_version) {
									/*
									if ((i_5 - 1 <= 7)) {
										// Сортировка по возрастанию.
										// Сортировка вставками до  10 элементов чрезвычайно эффективна.
										for (integer i_8 = 1; i_8 <= i_5 - 1; i_8++) {
											integer i_7 = i_8;
											while ((i_7>0)&&(ibuffer_strong_C_bs[i_7] < ibuffer_strong_C_bs[i_7 - 1])) {
												integer ibuf31 = ibuffer_strong_C_bs[i_7];
												ibuffer_strong_C_bs[i_7] = ibuffer_strong_C_bs[i_7 - 1];
												ibuffer_strong_C_bs[i_7 - 1] = ibuf31;
												i_7--;
											}
										}
									}
									else {
										// Сюда подключим библиотечную быструю сортировку
										// Это стандартная функция языка СИ.
										qsort(ibuffer_strong_C_bs, i_5, sizeof(integer), intcompare);

									}
									*/
									// 3 января 2017.
									std::sort(ibuffer_strong_C_bs, ibuffer_strong_C_bs + i_5);
								}
							}
							else {
								// Fi становится С.
								this_is_C_node[i_1] = true;
								this_is_F_node[i_1] = false;
								// Возвращаем все Fj с С на F.
								hashlist_i* ivacant_F2C_marker = ivacant_F2C;
								while (ivacant_F2C_marker != nullptr) {
									this_is_F_node[ivacant_F2C_marker->item] = true;
									this_is_C_node[ivacant_F2C_marker->item] = false;
									ivacant_F2C_marker = ivacant_F2C_marker->next;
								}
								ivacant_F2C_marker = nullptr;
								if (ivacant_F2C != nullptr) {
									clear_hash_list_i(ivacant_F2C);
									ivacant_F2C = nullptr;
								}
								ivacant_F2C = nullptr;
								// Очищаем ОЗУ.
								if (ibuffer_strongCFj != nullptr) {
									clear_hash_list_i(ibuffer_strongCFj);
									ibuffer_strongCFj = nullptr;
								}
								ibuffer_strongCFj = nullptr;
								// Досрочно прерываем текущее сканирование 
								// списка сильных F узлов.
								break;
							}

						}


						// Очищаем ОЗУ.
						if (ibuffer_strongCFj != nullptr) {
							clear_hash_list_i(ibuffer_strongCFj);
							ibuffer_strongCFj = nullptr;
						}
						ibuffer_strongCFj = nullptr;
						// Переход к следующему кандидату.
						ibuffer_strongF_current = ibuffer_strongF_current->next;
					}
					}

					// Освобождение ОЗУ.
					if (ibuffer_strong_C_bs != nullptr) {
						free(ibuffer_strong_C_bs);
						ibuffer_strong_C_bs = nullptr;
					}
					if (ibuffer_strongC != nullptr) {
						clear_hash_list_i(ibuffer_strongC);
						ibuffer_strongC = nullptr;
					}
					ibuffer_strongC = nullptr;
					if (ibuffer_strongF != nullptr) {
						clear_hash_list_i(ibuffer_strongF);
						ibuffer_strongF = nullptr;
					}
					ibuffer_strongF = nullptr;
					if (ivacant_F2C != nullptr) {
						clear_hash_list_i(ivacant_F2C);
						ivacant_F2C = nullptr;
					}
					ivacant_F2C = nullptr;

				}
			}
		} // Алгоритм улучшения качества C/F разбиения. Проход 2.

		// TODO 22_10_2016
		
		P_injection = nullptr;
		R_injection = nullptr;


		// Нужно корректно обработать узлы Дирихле,
		// Если F узел окажется узлом Дирихле без соседей то его надо сделать С узлом,
		// Но узнать такой узел можно лишь в процессе выполнения алгоритма дальше по ходу исполнения.
		// Поэтому может потребоваться вернуться и начать заново (обратная связь).


		C_numerate = nullptr;
		//C_numerate = new integer[n_a[ilevel - 1] + 1];
		C_numerate = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(C_numerate, "C_numerate", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		icounter = 1;
		ap_coarse = nullptr;

		bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			integer n_coarce15 = 0;
#pragma omp parallel for reduction(+:n_coarce15)
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (this_is_C_node[i_1]) {
					n_coarce15++;
				}
			}
			n_coarce += n_coarce15;
			n_coarce--;


			// debug
			// проверка качества C/F разбиения.
			//doublerealT* exp1 = new doublerealT[n_a[ilevel - 1] + 1];
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) exp1[i_1] = 0.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) exp1[i_1] = 2.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]) exp1[i_1] = 1.0;
			//exporttecplot(exp1,n);
			//delete[] exp1;

			//printf("export ready");

			//system("pause");



			// C/F разбиение построено, самое время построить оператор интерполяции.
			// потом найти оператор проекции, как транспонированный оператор интерполяции.
			// Всё завершает построение матрицы нового сеточного уровня и можно запускать новый уровень.

			// Построение оператора интерполяции: 
			// coarse 2 fine.
			//P*coarse==fine


			// Занумеруем (упорядочим) узлы грубой сетки.
#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) C_numerate[i_1] = 0;
			icounter = 1;
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]  ) {
#if doubleintprecision == 1
				//printf("C ind= %lld", i_1); getchar();
#else
				//printf("C ind= %d", i_1); getchar();
#endif
				
				C_numerate[i_1] = icounter;
				icounter++;
			}

			// TODO 22_10_2016
			integer icount1_injection = 1 + iaddR;

			// C_numerate - перенумерация на множестве Coarse узлов.
			// Построение пролонгации для узлов которые составляют грубую сетку.
			icount1 = 1 + iaddR; // nnz_R
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]  ) {
				P[icount1].aij = 1.0;
				P[icount1].i = (integer_mix_precision)(C_numerate[i_1]); // coarse number
				P[icount1].j = (integer_mix_precision)(i_1); // fine number.
				icount1++;
				if (icount1 >= nsizePR*n) {
					printf("memory error!!!\n");
					printf("not enough memory for the interpolation operator.\n");
					//system("PAUSE");
					//exit(1);
					deallocate_prolongation(nsizePR, n, R, P);
				}
			}


			// значение icount1 нужно далее.НЕ трогать !!!.
			numberofcoarcenodes = icount1 - 1 - iaddR;

			if (FUTURE_INJECTION) {
				// Это нужно для регуляции барьера barjerA.
				if (P_injection != nullptr) {
					delete[] P_injection;
					P_injection = nullptr;
				}
				if (R_injection != nullptr) {
					delete[] R_injection;
					R_injection = nullptr;
				}
				P_injection = new Ak1[numberofcoarcenodes]; // нумерация с нуля.
				R_injection = new Ak1[numberofcoarcenodes]; // нумерация с нуля.
				integer i_21 = 0;
				for (integer i_22 = icount1_injection; i_22 < icount1; i_22++) {
					P_injection[i_21] = P[i_22];
					R_injection[i_21] = P[i_22];
					i_21++;
				}
			}

			// Для модификации R  надо transpose(P)/ap.
			if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
				printf("countloc=%lld\n", numberofcoarcenodes);
#else
				printf("countloc=%d\n", numberofcoarcenodes);
#endif
				
				if (debug_reshime) system("pause");
			}

			//ap_coarse = new doublerealT[numberofcoarcenodes + 1];
			if (ap_coarse != nullptr) {
				free(ap_coarse);
				ap_coarse = nullptr;
			}
			ap_coarse = (doublerealT*)malloc((numberofcoarcenodes + 1) * sizeof(doublerealT));
			handle_error<doublerealT>(ap_coarse, "ap_coarse", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));

			ap_coarse[0] = 0.0;




			// Для каждого С узла запоминаем в ap_coarse[C_numerate[i8]] 
			// модуль диагонального элемента.
#pragma omp parallel for
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) {
				if (this_is_C_node[i8]  ) {
					// Старая версия до 10 января 2016. Время O(log2(nnz))
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					// 10 января 2016 новая версия на основе хеширования. Время O(1).
					integer ii1 = row_startA[i8];
					// бинарный поиск должен гарантирует нахождение самого левого представителя.
					//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
					for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
#if doubleintprecision == 1
						//printf("i=%lld j=%lld Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#else
						//printf("i=%d j=%d Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#endif
						
						if (Amat[is0].j == Amat[ii1].i) {

							if (fabs(Amat[is0].aij) > RealMAXIMUM) {
								printf("perepolnenie error!");
								//getchar();
								system("pause");
							}
							ap_coarse[C_numerate[i8]] = fabs(Amat[is0].aij);
							//printf("find = %e", fabs(Amat[is0].aij));
						}
					}
				}
				//printf("\n");
				//getchar();
			}

#if doubleintprecision == 1
			//printf("incoming=%lld\n", my_amg_manager.number_interpolation_procedure);
#else
			//printf("incoming=%d\n", my_amg_manager.number_interpolation_procedure);
#endif
			
			//getchar();

			// верно 2 октября.

			bool the_good_old_interpolation = true;

			if (the_good_old_interpolation) {

				// Старая добрая верная, проверенная интерполяция.
				// К тому же чрезвычайно простая.

				//my_amg_manager.number_interpolation_procedure == 0
				// 0
				if (my_amg_manager.number_interpolation_procedure == 10) {
					
					// Интерполяционная процедура №10. 
					my_interpolation_procedure_number10(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel, iadd, theta, n, R, C_numerate);
						
				}
				//my_amg_manager.number_interpolation_procedure == 1
				// 0
				if (my_amg_manager.number_interpolation_procedure == 7) {

					// Прямая интерполяция с элементам непрямой.
					// Непрямая интерполяция применяется только для F узлов которые
					// не имеют С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.
					// Узел F не имеющий Strong C соседей, получает значение из Strong C соседей соседних Strong F узлов в
					// в результате сканирования списка Strong F соседей.
					// Если нам встречаются два Strongly связанных F узла у которых в совокупности нет вообще ни одного Strong C соседа
					// то один из этих Strong F узлов тановится С узлом и сканирование списка сильных Strong F соседов данного узла F прекращается.
					// Потом мы повторно запускаем алгоритм построения с учётом уже добавленных С узлов.

					
					// Интерполяционная процедура №7. 
					my_interpolation_procedure_number7(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate);
						
				}
				//my_amg_manager.number_interpolation_procedure == 2
				// 0
				if (my_amg_manager.number_interpolation_procedure == 2) {
					
					
					// Интерполяционная процедура №2.
					my_interpolation_procedure_number2(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate, number_of_F_nodes_with_one_single_strong_C_neighborF);
						

				}
				//my_amg_manager.number_interpolation_procedure == 3
				// 1
				if (my_amg_manager.number_interpolation_procedure == 3) 
				{
					// Базовая, наиболее часто используемая интерполяционная процедура.

					// Интерполяционная процедура №3.
					my_interpolation_procedure_number3(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);
				}

				//my_amg_manager.number_interpolation_procedure == 7
				// 1
				if (my_amg_manager.number_interpolation_procedure == 1) {
					
					// 1.04.2017
					// Главная идея в том чтобы разделить интерполяцию по знакам,
					// отдельно положительные коэффициенты и отдельно положительные,
					// в итоге учитывается и то и то.

					// Интерполяционная процедура №1.
					/*
					my_interpolation_procedure_number1(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);
						*/

						// Интерполяционная процедура №3.amg1r5 Ruge-Stuben
					my_interpolation_procedure_number3B(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);
				}

				if (my_amg_manager.number_interpolation_procedure == 0) {

					// 1.04.2017; 28.04.2017;
					// Главная идея в том чтобы разделить интерполяцию по знакам, отдельно положительные коэффициенты и отдельно положительные,
					// в итоге учитывается и то и то.

					// Интерполяционная процедура №0.
					/*
					my_interpolation_procedure_number0(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);
					*/

					// Интерполяционная процедура №3.
					// Улучшенный базовый вариант.
					my_interpolation_procedure_number3A(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);

				}

				//my_amg_manager.number_interpolation_procedure == 4
				// 0
				if (my_amg_manager.number_interpolation_procedure == 4) {
					
					// пятая попытка (Рабочая).
					// показывает время 1.22 против времени в 1.36 в четвертой попытке.

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					// Интерполяционная процедура №4.
					my_interpolation_procedure_number4(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);

				}
				//my_amg_manager.number_interpolation_procedure == 5
				// 0
				if (my_amg_manager.number_interpolation_procedure == 5) {

					// Рабочая.

					// Интерполяционная процедура №5.
					my_interpolation_procedure_number5(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);
				}

			}
			else if (true) {

				// INTERPOLATION SIX

				// Экспериментальная интерполяция 1 января 2016.

				// Интерполяционная процедура №6.
				my_interpolation_procedure_number6(the_number_of_neighbors_that_are_not_C_nodes,
					number_of_F_nodes_with_one_single_strong_C_neighbor,
					n_a, this_is_F_node, row_startA,
					nnz_a, bpositive_connections, Amat,
					bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
					RealZERO, icount1, P, nsizePR, ilevel,
					iadd, theta, n, R, C_numerate,
					number_of_F_nodes_with_one_single_strong_C_neighborF,
					theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
					from_re_operation_protection0, magic82, threshold_quick_all,
					threshold_quick_only_negative);
			}
			else {
				// От интерполяции зависит очень много поэтому
				// реализуем следующую экспериментальную идею интерполяции.
				// Эта интерполяция претендует быть единственно теоретически верной,
				// сделанной на основе литературных данных.

				printf("interpolation SIX: Theoretical approach in Montenegro.\n");
				system("PAUSE");

				the_number_of_neighbors_that_are_not_C_nodes = 0;
				number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

				if (bpositive_connections) {

					// positive connections.

					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						//integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT sumPindicator = 0.0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
										// Weak connectors
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																  //icsos++;
									}
									else {
										sumPindicator += fabs(Amat[is0].aij);
									}
								}
								else {
									// Подсчитываем количество соседей которые не являются С узлами.
									if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
										// Weak connectors
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																  //icsos++;
									}
									the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
								}
							}
							else {
								// Диагональный элемент.
								sumP += fabs(Amat[is0].aij);
							}
						}
						//if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.


						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						//if ((false) && (icsos == 1)) {
						//this_is_F_node[i8] = false;
						//this_is_C_node[i8] = true;
						//bweSholdbeContinue = true;
						//}
						//else
						{

							if (fabs(sumPindicator) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all neighbour is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");
								this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								iadditionalCstatistic++;
								//exit(1);
								// здесь нужна непрямая интерполяция.

								// Мы не будем добалять С узлы, мы будем использовать непрямую интерполяцию.



							}
							else {

								integer icount1_frozen = icount1;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j]  ) {

											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												// Strongly C connectors.

												P[icount1].j = (integer_mix_precision)(i8);
												P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}


										}
									}
								}

								integer ilength_n = icount1 - icount1_frozen;
								integer* jposition_in_P = nullptr;
								//jposition_in_P = new integer[ilength_n];
								jposition_in_P = (integer*)malloc(ilength_n * sizeof(integer));
								handle_error<integer>(jposition_in_P, "jposition_in_P", "classic_aglomerative_amg_4", ilength_n);



								integer i_97 = 0;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j]  ) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												// Strongly C connections j position.
												jposition_in_P[i_97] = Amat[is0].j;
												i_97++;
											}
										}
									}
								}


								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j]  ) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												// Strong F connections
												doublerealT my_mult = fabs(Amat[is0].aij);
												integer iFpoint = Amat[is0].j;
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												integer ii1_loc = row_startA[iFpoint];

												// Смотрим всех соседей узла iFpoint
												// если среди них окажутся сильные С соседи 
												// первоначально рассматриваемого узла Amat[ii1].i
												// то мы будем накапливать в сумматоре sum23 
												// модули значеий матрицы.
												doublerealT sum23 = 0.0;
												bool bvisit23 = false;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j]  ) {
															for (i_97 = 0; i_97 < ilength_n; i_97++) {
																if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																	sum23 += fabs(Amat[is0_loc].aij);
																	bvisit23 = true;
																	break;
																}
															}
														}
													}
												}

												//if (fabs(sum23) > RealZERO) {
												if (bvisit23) {
													// мы точно не делим на ноль.

													// Сканируем всех соседей узла F.
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																for (i_97 = 0; i_97 < ilength_n; i_97++) {
																	if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																		//P[icount1_frozen + i_97].j = i8;
																		//P[icount1_frozen+i_97].i = C_numerate[Amat[is0].j];
																		P[icount1_frozen + i_97].aij += (my_mult*fabs(Amat[is0_loc].aij)) / (sumP*sum23);
																		break;
																	}
																}
															}
														}
													}
												}


											}
										}
									}
								}

								//delete[] jposition_in_P;
								free(jposition_in_P);

							}

						}


					}

				}
				else {
					// only negative connections

					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						//integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT sumPindicator = 0.0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									if ((Amat[is0].aij>0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold*theta)) {
										// Weak connectors
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																  //icsos++;
									}
									else {
										sumPindicator += fabs(Amat[is0].aij);
									}
								}
								else {
									// Подсчитываем количество соседей которые не являются С узлами.
									if ((Amat[is0].aij>0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold*theta)) {
										// Weak connectors
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																  //icsos++;
									}
									the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
								}
							}
							else {
								// Диагональный элемент.
								sumP += fabs(Amat[is0].aij);
							}
						}
						//if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.


						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						//if ((false) && (icsos == 1)) {
						//this_is_F_node[i8] = false;
						//this_is_C_node[i8] = true;
						//bweSholdbeContinue = true;
						//}
						//else
						{

							if (fabs(sumPindicator) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all neighbour is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");
								this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								iadditionalCstatistic++;
								//exit(1);
								// здесь нужна непрямая интерполяция.

								// Мы не будем добалять С узлы, мы будем использовать непрямую интерполяцию.



							}
							else {

								integer icount1_frozen = icount1;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j]  ) {

											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												// Strongly C connectors.

												P[icount1].j = (integer_mix_precision)(i8);
												P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}


										}
									}
								}

								integer ilength_n = icount1 - icount1_frozen;
								integer* jposition_in_P = nullptr;
								//jposition_in_P = new integer[ilength_n];
								jposition_in_P = (integer*)malloc(ilength_n * sizeof(integer));
								handle_error<integer>(jposition_in_P, "jposition_in_P", "classic_aglomerative_amg_4", ilength_n);



								integer i_97 = 0;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j]  ) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												// Strongly C connections j position.
												jposition_in_P[i_97] = Amat[is0].j;
												i_97++;
											}
										}
									}
								}


								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j]  ) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												// Strong F connections
												doublerealT my_mult = fabs(Amat[is0].aij);
												integer iFpoint = Amat[is0].j;
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												integer ii1_loc = row_startA[iFpoint];

												// Смотрим всех соседей узла iFpoint
												// если среди них окажутся сильные С соседи 
												// первоначально рассматриваемого узла Amat[ii1].i
												// то мы будем накапливать в сумматоре sum23 
												// модули значеий матрицы.
												doublerealT sum23 = 0.0;
												bool bvisit23 = false;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j]  ) {
															for (i_97 = 0; i_97 < ilength_n; i_97++) {
																if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																	sum23 += fabs(Amat[is0_loc].aij);
																	bvisit23 = true;
																	break;
																}
															}
														}
													}
												}

												//if (fabs(sum23) > RealZERO) {
												if (bvisit23) {
													// мы точно не делим на ноль.

													// Сканируем всех соседей узла F.
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																for (i_97 = 0; i_97 < ilength_n; i_97++) {
																	if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																		//P[icount1_frozen + i_97].j = i8;
																		//P[icount1_frozen+i_97].i = C_numerate[Amat[is0].j];
																		P[icount1_frozen + i_97].aij += (my_mult*fabs(Amat[is0_loc].aij)) / (sumP*sum23);
																		break;
																	}
																}
															}
														}
													}
												}


											}
										}
									}
								}

								//delete[] jposition_in_P;
								free(jposition_in_P);

							}

						}


					}


				} // end only negatyive connections

			}



			if (bweSholdbeContinue) {
				//delete[] ap_coarse;
				if (ap_coarse != nullptr) {
					free(ap_coarse);
					ap_coarse = nullptr;
				}
				if (bprint_mesage_diagnostic) {
					printf("obratnaq svqz restart...\n");
				}
			}

			if (bprint_mesage_diagnostic) {
				printf("addition C nodes procent %3.1f", (doublerealT)(100.0*iadditionalCstatistic / n_a[ilevel - 1]));
			}
			iadditionalCstatistic = 0;
			//system("pause");


		}

		nnzR = icount1 - iaddR;



		// нужно определить nnzR количество ненулевых элементов в матрице R и P.

		// оператор restriction построен и он упорядочен по i.
		// число ненулевых элементов nnzR-1.
		// P=Copy(R);
		iend_marker_position = iaddR + nnzR - 1;

		// truncation of interpolation.
		// 30.04.2017.
		if (my_amg_manager.itruncation_interpolation==1) {

			/*
			// Однопоточный вариант работает и без сортировки, 
			// что говорит о том что оператор интерполяции уже предварительно был отсортирован по j.
			switch (imy_sort_algorithm ) {
			case MY_SORT_ALGORITHM:: COUNTING_SORT:
			   //Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1, false);
			   qsj(P, 1 + iaddR, iaddR + nnzR - 1);
			   //HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
			break;
			case MY_SORT_ALGORITHM:: QUICK_SORT:
			        qsj(P, 1 + iaddR, iaddR + nnzR - 1);
					// Библиотечный алгоритм. O(n*log2(n)).
					// Не использует лишней памяти.
					//std::sort(P + (1 + iaddR, P + iaddR + nnzR - 1+1, compareAk1P);
			break;
			case MY_SORT_ALGORITHM:: HEAP_SORT:
			    HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
			break;
			default:
			   //Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1, false);
			   qsj(P, 1 + iaddR, iaddR + nnzR - 1);
			   //HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
			break;
			}
			*/


			// Большое число связей увеличивает сложность оператора Галеркина.
			// Наличие слабых связей в процедуре интерполяции, приводит к замедлению 
			// сходимости или расходимости.
			// Алгоритм усранения слабых связей:
			//doublerealT const alpha_truncation = 0.2;
			doublerealT alpha_truncation = (doublerealT)(my_amg_manager.truncation_interpolation);
			// Рассмотрим каждую строку оператора интерполяции.
			// Найдем сумму элементов данной строки каждого знака.
			// Найдём максимальный по модулю элемент каждого знака.
			// Удалим все элементы в операторе интерполяции каждого знака 
			// которые меньше максимального по модулю того-же знака * на alpha_truncation.
			// Проведём перемасштабирование чтобы сумма осталась неизменной.
			// Сделаем это в памяти R.
#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= n; i_1++) {
				flag[i_1] = false; // init flag.
			}
			integer icounter_truncation = 1 + iaddR;

			if (1) {
				// Многопоточная версия.

				integer i_size_75 = 0;
				// Это нельзя распараллелить.
				for (integer ii = 1 + iaddR; ii <= iend_marker_position; ii++) {
					if (flag[P[ii].j] == false) {
						//row_ind_SRloc[P[ii].j] = ii;
						flag[P[ii].j] = true;
						//i_size_75++;
						if (P[ii].j > i_size_75) i_size_75 = P[ii].j;
					}
				}

#pragma omp parallel for
				for (integer i_1 = 1; i_1 <= n; i_1++) {
					flag[i_1] = false; // init flag.
				}

				integer* row_ind_SRloc = nullptr;
				//row_ind_SR = new integer[numberofcoarcenodes + 1];
				//row_ind_SRloc = (integer*)malloc((numberofcoarcenodes + 1) * sizeof(integer));
				//handle_error<integer>(row_ind_SRloc, "row_ind_SRloc", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));
				row_ind_SRloc = (integer*)malloc((i_size_75 + 1) * sizeof(integer));
				handle_error<integer>(row_ind_SRloc, "row_ind_SRloc", "classic_aglomerative_amg_4", (i_size_75 + 1));

#if doubleintprecision == 1
				//printf("numberofcoarcenodes=%lld i_size_75=%lld\n", numberofcoarcenodes, i_size_75);
#else
				//printf("numberofcoarcenodes=%d i_size_75=%d\n", numberofcoarcenodes, i_size_75);
#endif
				
				//system("pause");
/*
#pragma omp parallel for
				for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
					row_ind_SRloc[i_1] = -1;
				}
				*/
				// inicialization
#pragma omp parallel for
				for (integer i_1 = 1; i_1 <= i_size_75; i_1++) {
					row_ind_SRloc[i_1] = -1;
				}

				
				// Это нельзя распараллелить.
				for (integer ii = 1 + iaddR; ii <= iend_marker_position; ii++) {
					if (flag[P[ii].j] == false) {
						row_ind_SRloc[P[ii].j] = ii;
						flag[P[ii].j] = true;
					}
				}

				//for (integer ii = 1 + iaddR; ii <= iend_marker_position; ii++) {
#pragma omp parallel for
				for (integer i_75=1; i_75<=i_size_75; i_75++) {
					if (row_ind_SRloc[i_75]!=-1) {
						integer ii = row_ind_SRloc[i_75];

					//if (flag[P[ii].j] == false) {
						//flag[P[ii].j] = true;
						integer istr_65 = P[ii].j;
						integer ii_65 = ii;
						doublerealT dsum_plus = 0.0;
						doublerealT dsum_minus = 0.0;
						doublerealT dmax_plus = -1.0;
						doublerealT dmax_minus = -1.0;
						while ((ii_65 <= iend_marker_position) && (P[ii_65].j == istr_65)) {
							if (P[ii_65].aij > 0) {
								dsum_plus += P[ii_65].aij;
								if (P[ii_65].aij > dmax_plus) dmax_plus = P[ii_65].aij;
							}
							if (P[ii_65].aij < 0) {
								dsum_minus += fabs(P[ii_65].aij);
								if (fabs(P[ii_65].aij) > dmax_minus) dmax_minus = fabs(P[ii_65].aij);
							}
							ii_65++;
						}
						ii_65 = ii;
						doublerealT dsum_plus_new = 0.0;
						doublerealT dsum_minus_new = 0.0;
						while ((ii_65 <= iend_marker_position) && (P[ii_65].j == istr_65)) {
							if ((P[ii_65].aij > 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_plus)) {
								dsum_plus_new += fabs(P[ii_65].aij);
							}
							if ((P[ii_65].aij < 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_minus)) {
								dsum_minus_new += fabs(P[ii_65].aij);
							}
							ii_65++;
						}
						// заполнение перемасштабированными.
						ii_65 = ii;
						while ((ii_65 <= iend_marker_position) && (P[ii_65].j == istr_65)) {
							if ((P[ii_65].aij > 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_plus)) {
								R[icounter_truncation] = P[ii_65];
								R[icounter_truncation].aij = fabs(dsum_plus / dsum_plus_new)*P[ii_65].aij;
								icounter_truncation++;
							}
							if ((P[ii_65].aij < 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_minus)) {
								R[icounter_truncation] = P[ii_65];
								R[icounter_truncation].aij = fabs(dsum_minus / dsum_minus_new)*P[ii_65].aij;
								icounter_truncation++;
							}
							ii_65++;
						}

					}
				}

				free(row_ind_SRloc);
			    row_ind_SRloc = nullptr;
			}
			else {

				// Однопоточная версия.

				for (integer ii = 1 + iaddR; ii <= iend_marker_position; ii++) {
					if (flag[P[ii].j] == false) {
						flag[P[ii].j] = true;
						integer istr_65 = P[ii].j;
						integer ii_65 = ii;
						doublerealT dsum_plus = 0.0;
						doublerealT dsum_minus = 0.0;
						doublerealT dmax_plus = -1.0;
						doublerealT dmax_minus = -1.0;
						while ((ii_65 <= iend_marker_position) && (P[ii_65].j == istr_65)) {
							if (P[ii_65].aij > 0) {
								dsum_plus += P[ii_65].aij;
								if (P[ii_65].aij > dmax_plus) dmax_plus = P[ii_65].aij;
							}
							if (P[ii_65].aij < 0) {
								dsum_minus += fabs(P[ii_65].aij);
								if (fabs(P[ii_65].aij) > dmax_minus) dmax_minus = fabs(P[ii_65].aij);
							}
							ii_65++;
						}
						ii_65 = ii;
						doublerealT dsum_plus_new = 0.0;
						doublerealT dsum_minus_new = 0.0;
						while ((ii_65 <= iend_marker_position) && (P[ii_65].j == istr_65)) {
							if ((P[ii_65].aij > 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_plus)) {
								dsum_plus_new += fabs(P[ii_65].aij);
							}
							if ((P[ii_65].aij < 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_minus)) {
								dsum_minus_new += fabs(P[ii_65].aij);
							}
							ii_65++;
						}
						// заполнение перемасштабированными.
						ii_65 = ii;
						while ((ii_65 <= iend_marker_position) && (P[ii_65].j == istr_65)) {
							if ((P[ii_65].aij > 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_plus)) {
								R[icounter_truncation] = P[ii_65];
								R[icounter_truncation].aij = fabs(dsum_plus / dsum_plus_new)*P[ii_65].aij;
								icounter_truncation++;
							}
							if ((P[ii_65].aij < 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_minus)) {
								R[icounter_truncation] = P[ii_65];
								R[icounter_truncation].aij = fabs(dsum_minus / dsum_minus_new)*P[ii_65].aij;
								icounter_truncation++;
							}
							ii_65++;
						}

					}
				}
			}

			//iend_marker_position = iaddR + nnzR - 1;
		
			iend_marker_position = icounter_truncation - 1;
			nnzR = iend_marker_position - iaddR + 1;
			//nnzR = icount1 - iaddR;
			icount1 = nnzR + iaddR;

#pragma omp parallel for
			for (integer ii = 1 + iaddR; ii <= iend_marker_position; ii++) {
				P[ii] = R[ii];
			}

#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= n; i_1++) {
				flag[i_1] = false; // init flag.
			}
		}

#pragma omp parallel for
		for (integer ii = 1 + iaddR; ii <= iend_marker_position; ii++) {
			R[ii] = P[ii];
			//if ((ilevel == 2) && (ii >= iaddR + nnzR - 1-30)) {
#if doubleintprecision == 1
			//printf("ii=%lld aij=%e, i=%lld j=%lld\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#else
			//printf("ii=%d aij=%e, i=%d j=%d\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#endif
			
			//getchar();
			//}
		}

		// Этот оператор нужен для вычисления grid complexity для оператора 
		// интерполяции и проекции. Данная информация важна для оптимизации количества выделяемой памяти.
		if (ilevel - 1 == 0) {
			nnz_P_memo_0 = iend_marker_position - (iaddR + 1) + 1;
		}
		else {
			nnz_P_memo_all = iend_marker_position;
		}

		// heapsort(P,key==j,iaddR+1,iaddR+nnzR - 1);

		/*
		// 10 января 2016. Эта сортировка не требуется.
		switch (imy_sort_algorithm) {
		case MY_SORT_ALGORITHM:: COUNTING_SORT:
		     Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		case MY_SORT_ALGORITHM:: HEAP_SORT:
		     HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		case MY_SORT_ALGORITHM:: QUICK_SORT:
		    // Быстрая сортировка Хоара.
		    qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		    // Библиотечный алгоритм. O(nlog(n)).
		    // Не использует лишней памяти.
		    //std::sort(P+1+iaddR, P+iaddR+ nnzR-1+1, compareAk1P);
		break;
		default:
		    Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		}		
		*/


		// где то надо разделить на ap, т.к. 
		// R=P/ap. ????  
		// НЕТ делить НЕ НАДО!!! т.к. в теории R=transpose(P).
		


		// heapsort(R,key==i,iaddR+1,iaddR+nnzR - 1);

		switch (imy_sort_algorithm) {
		case MY_SORT_ALGORITHM:: COUNTING_SORT:
			Counting_Sort(R, 1 + iaddR, iaddR + nnzR - 1, false, indx_comparei);
			break;
		case MY_SORT_ALGORITHM:: QUICK_SORT:
			qs(R, 1 + iaddR, iaddR + nnzR - 1, indx_comparei);
			// Библиотечный алгоритм. O(n*log2(n)).
			// Не использует лишней памяти.
			//std::sort(R + 1 + iaddR, R + iaddR + nnzR - 1+1, compareAk1R);
			break;
		case MY_SORT_ALGORITHM:: HEAP_SORT:
			HeapSort(R, 1 + iaddR, iaddR + nnzR - 1,comparei);
			break;
		default:
			Counting_Sort(R, 1 + iaddR, iaddR + nnzR - 1, false, indx_comparei);
			break;
		}

		

		// TODO 22_10_2016.
		if (FUTURE_INJECTION) {
			switch (imy_sort_algorithm) {
			case MY_SORT_ALGORITHM:: COUNTING_SORT:
				Counting_Sort(R_injection, 0, numberofcoarcenodes - 1, false, indx_comparei);
				break;
			case MY_SORT_ALGORITHM:: QUICK_SORT:
				qs(R_injection, 0, numberofcoarcenodes - 1, indx_comparei);
				// Библиотечный алгоритм. O(nlog(n)).
				// Не использует лишней памяти.
				//std::sort(R_injection, R_injection + numberofcoarcenodes - 1+1, compareAk1R);
				break;
			case MY_SORT_ALGORITHM:: HEAP_SORT:
				HeapSort(R_injection, 0, numberofcoarcenodes - 1,comparei);
				break;
			default:
				Counting_Sort(R_injection, 0, numberofcoarcenodes - 1, false, indx_comparei);
				break;
			}
		}
		



		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("first level size n=%lld numberofcoarcenodes=%lld\n", n, numberofcoarcenodes);
#else
			printf("first level size n=%d numberofcoarcenodes=%d\n", n, numberofcoarcenodes);
#endif
			
		}

		// Проверка Restriction нет ли пропусков строк при интерполяции: 
		if (1) {
#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				flag[i_1] = false; // init flag.
			}
			for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
				if (flag[R[i_1].i] == false)
				{
					doublerealT dsum27 = 0.0;
					for (integer i_2 = i_1; (i_2 <= iaddR + nnzR - 1) && (R[i_2].i == R[i_1].i); i_2++) {
						dsum27 += fabs(R[i_2].aij);
					}
					if (dsum27 < 1.0e-37) {
#if doubleintprecision == 1
						printf("fatal error!!! zero string R[%d][j]=%e\n", R[i_1].i, dsum27);
#else
						printf("fatal error!!! zero string R[%d][j]=%e\n", R[i_1].i, dsum27);
#endif
						
						system("PAUSE");
					}
					flag[R[i_1].i] = true;
				}
			}
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				if (flag[i_1] == false) {
					// пропуск строки номер i_1
#if doubleintprecision == 1
					printf("fatal error!!! string number %lld propushena\n", i_1);
#else
					printf("fatal error!!! string number %d propushena\n", i_1);
#endif
					
					system("PAUSE");
				}
			}
#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				flag[i_1] = false; // init flag.
			}
		}

		// Корректировка диагонали restriction
		if (0) {
			// убрано 2 января 2015 года.
			// Убирание этого сомнительного шага дало сокращение 
			// времени счтёта для 1M неизвестных с 51с(131 итерация) до 42с (91 итерации).
			// на задаче tgf2023_01 включение данного шага приводит к расходимости вычислительного процесса.

			if (debug_reshime) system("pause");
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				flag[i_1] = false; // init flag.
			}

			for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
				if (flag[R[i_1].i] == false)
				{
					for (integer i_2 = i_1; (i_2 <= iaddR + nnzR - 1) && (R[i_2].i == R[i_1].i); i_2++) {
						if ((R[i_1].i<1) || (R[i_1].i>numberofcoarcenodes)) {
#if doubleintprecision == 1
							printf("error R[%lld].i=%d\n", i_1, R[i_1].i);
#else
							printf("error R[%d].i=%d\n", i_1, R[i_1].i);
#endif
							
							system("pause");
						}
						if (fabs(ap_coarse[R[i_1].i]) < divisionZERO) {
							printf("error division by zero\n");
							system("pause");
						}
						doublerealT delitel;
						if (ap_coarse[R[i_1].i] > 1.0) {
							// internal node
							delitel = (doublerealT)(0.5*ap_coarse[R[i_1].i]);
						}
						else {
							// Dirichlet
							delitel = ap_coarse[R[i_1].i];
						}
						R[i_2].aij = R[i_2].aij / (delitel);
					}
					flag[R[i_1].i] = true;
				}
			}
		}

		//delete[] ap_coarse;
		if (ap_coarse != nullptr) {
			free(ap_coarse);
			ap_coarse = nullptr;
		}




		// Сортировка А по j.
		//heapsort(Amat, key=j*n_a[ilevel - 1] + i, 1, nnz_a[ilevel - 1]);

		// Лишний код потомучто потом сразу же следует сортировка по i.
		/*
		// 7 января 2016. закомментировано.
		switch ( imy_sort_algorithm ) {
		case MY_SORT_ALGORITHM:: COUNTING_SORT:
		    Counting_Sortj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		case MY_SORT_ALGORITHM:: QUICK_SORT:
		    qsj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
	    	// Библиотечный алгоритм. O(nlog(n)).
	    	// Не использует лишней памяти.
	    	//std::sort(Amat + 1 + iadd, Amat + nnz_a[ilevel - 1] + iadd+1, compareAk1P);
		break;
		case MY_SORT_ALGORITHM:: HEAP_SORT :
		    HeapSort_j(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		default:
		    Counting_Sortj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		}
		*/

		// MARKER GUSTAVSON

		// Нахождение матрицы грубосеточного уровня:
		// Acorse=R*Afine*P;
		// часть 1: R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", nnzR, nnz_a[ilevel - 1]);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", nnzR, nnz_a[ilevel - 1]);
#endif
			
		}

		integer istartAnew;


		// Фред Густавсон IBM 1978.
		// 23 октября 2015 года.

		// часть 1: R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]
		// Сортировка А по строкам.
		/*
		// 7 января 2016. Сортировка матрицы А была выполнена единожды при начале обработке данного уровня.
		switch (imy_sort_algorithm) {
		case MY_SORT_ALGORITHM:: COUNTING_SORT:
		  Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		case MY_SORT_ALGORITHM:: QUICK_SORT :
     		qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
	    	// Библиотечный алгоритм. O(n*log2(n)).
	    	// Не использует лишней памяти.
	    	//std::sort(Amat + 1 + iadd, Amat + nnz_a[ilevel - 1] + iadd+1, compareAk1R);
		break;
		case MY_SORT_ALGORITHM:: HEAP_SORT:
		     HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		default:
		  Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		}
		*/
		// Преобразование к формату CRS.

		row_ind_SR = nullptr;
		//row_ind_SR = new integer[numberofcoarcenodes + 1];
		row_ind_SR = (integer*)malloc((numberofcoarcenodes + 1) * sizeof(integer));
		handle_error<integer>(row_ind_SR, "row_ind_SR", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));

		 row_ind_ER = nullptr;
		//row_ind_ER = new integer[numberofcoarcenodes + 1];
		row_ind_ER = (integer*)malloc((numberofcoarcenodes + 1) * sizeof(integer));
		handle_error<integer>(row_ind_ER, "row_ind_ER", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));

#pragma omp parallel for
		for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			row_ind_SR[i_1] = -1;
			row_ind_ER[i_1] = -2;
		}
		istart1 = 1 + iaddR;
		iend1 = nnzR - 1 + iaddR;
#pragma omp parallel for
		for (integer i = 1; i <= icounter - 1; i++) {
			flag[i] = false;
		}

		if (0) {
			for (integer ii = istart1; ii <= iend1; ii++) {
				if (flag[R[ii].i] == false) {
					integer istr = R[ii].i;
					integer ic = ii;
					integer kf = ic;

					while ((kf <= iend1) && (R[kf].i == istr)) {
						kf++;
					}
					kf--;
					row_ind_SR[istr] = ic;
					row_ind_ER[istr] = kf;
					flag[R[ii].i] = true;
				}
			}
		}
		else {
			integer i_size_75 = 0;
			// Это нельзя распараллелить.
			for (integer ii = istart1; ii <= iend1; ii++) if (flag[R[ii].i] == false) {
				row_ind_SR[R[ii].i] = ii; 
				flag[R[ii].i] = true;
				i_size_75++;
			}
#pragma omp parallel for
			for (integer istr = 1; istr <= i_size_75; istr++) {
				integer kf = row_ind_SR[istr];
				while ((kf <= iend1) && (R[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_ER[istr] = kf;
			}
		}

		// Пустые строки просто отсутствуют.
#if doubleintprecision == 1
		//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			//if (row_ind_SR[i_1] == -1) {
				//printf("empty string %lld\n", row_ind_ER[i_1]);
			//}
		//}
#else
		//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			//if (row_ind_SR[i_1] == -1) {
				//printf("empty string %d\n", row_ind_ER[i_1]);
			//}
		//}
#endif
		

		row_ind_SA = nullptr;
		//row_ind_SA = new integer[n_a[ilevel - 1] + 1];
		row_ind_SA = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(row_ind_SA, "row_ind_SA", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		row_ind_EA = nullptr;
		//	row_ind_EA = new integer[n_a[ilevel - 1] + 1];
		row_ind_EA = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(row_ind_EA, "row_ind_EA", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		istart3 = 1 + iadd;
		iend3 = nnz_a[ilevel - 1] + iadd;
#pragma omp parallel for
		for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
			flag[i] = false;
		}

		if (0) {
			// Однопоточная версия.

			// Базовая верная версия цикла:
			for (integer ii = istart3; ii <= iend3; ii++) {
				if (flag[Amat[ii].i] == false) {
					integer istr = Amat[ii].i;
					integer ic = ii;
					integer kf = ic;

					while ((kf <= iend3) && (Amat[kf].i == istr)) {
						kf++;
					}
					kf--;
					row_ind_SA[istr] = ic;
					row_ind_EA[istr] = kf;
					flag[Amat[ii].i] = true;
					// Ускорение 22_10_2016: 
					ii = kf;
				}
			}
		}
		else {
			// Многопоточная версия.

			integer i_size_75 = 0;
			// Это нельзя распараллелить.
			for (integer ii = istart3; ii <= iend3; ii++) {
				if (flag[Amat[ii].i] == false) {
					row_ind_SA[Amat[ii].i] = ii;
					flag[Amat[ii].i] = true;
					i_size_75++;
				}
			}
#pragma omp parallel for
			for (integer istr = 1; istr <= i_size_75; istr++) {
				integer kf = row_ind_SA[istr];
				while ((kf <= iend3) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_EA[istr] = kf;

			}
		}





		istartAnew = nnz_a[ilevel - 1] + 1 + iadd;
		istartAnew_mem = istartAnew;

		// Данные используемые для частичного формирователя суммы.
		vector_sum = nullptr;
		//vector_sum = new doublerealT[n_a[ilevel - 1] + 1];
		vector_sum = (doublerealT*)malloc((n_a[ilevel - 1] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		//bool* b_visit_vec_sum = new bool[n_a[ilevel - 1] + 1];
		//integer size_v = sizeof(doublerealT)*(1 + n_a[ilevel - 1]);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		index_visit = nullptr;
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		index_size = 0;



//#ifdef _NONAME_STUB29_10_2017
#ifdef _OPENMP

		// Данные используемые для частичного формирователя суммы.
		
		for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++) {

			for (integer i_91 = 0; i_91 < 10*n + 1; i_91++) hash_table_m[i_9][i_91] = false;// inicialization
			index_size_m[i_9] = 0;
			istartAnew_m[i_9] = 0;
		}

		// Сканируем первый операнд построчно.
		// глобальные переменные не перечисляются.
#pragma omp parallel for 
		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {
			int tid = omp_get_thread_num();
			
			// на основе hash таблицы. 

			// Сканируем текущую i-ую строку поэлементно
			for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
				integer col_ind = R[ii].j;
				// Сканируем col_ind строку второго операнда

				// Общую переменную объяим на уровень выше.
				doublerealT left_operand = R[ii].aij;
				for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {

					doublerealT right_operand = Amat[i_1].aij;
					integer iaddind = Amat[i_1].j;
					bool foundnow = false;
					

					foundnow = hash_table_m[tid][iaddind];
					

					if (foundnow) {

							vector_sum_m[tid][iaddind] += left_operand*right_operand;
					}
					else {
						// Первое добавление.

							index_size_m[tid]++;
							index_visit_m[tid][index_size_m[tid]] = iaddind;

							hash_table_m[tid][iaddind] = true;

							vector_sum_m[tid][iaddind] = left_operand*right_operand;
						
					}
				}
			}

			doublerealT maxth = -1.0;
			// 22 октября 2016 Мы искоренили барьер из части P*Amat.
			for (integer i_6 = 1; i_6 <= index_size_m[tid]; i_6++) {
				integer jstr = index_visit_m[tid][i_6];
				hash_table_m[tid][jstr] = false; // инициализируем hash таблицу для следующих проходов.
			}

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем
			// проверками.
			bool bCheck_ok = false; // прооверяет наличие диагонали в строке матрицы.
			integer istartAnew_8 = istartAnew; // запоминаем для вылечивания строки.
			doublerealT barjer_maxth = barjer*maxth;
			doublerealT mbarjer_maxth = -barjer_maxth;
			if (nsizeA > istartAnew + index_size_m[tid]) {
				for (integer i_6 = 1; i_6 <= index_size_m[tid]; i_6++) {
					integer jstr = index_visit_m[tid][i_6];

					doublerealT vs1 = vector_sum_m[tid][jstr];

					if ((istr == jstr) && (vs1 > 1.0e-20)) {
						bCheck_ok = true;
					}

					

					// 7 ноября 2016 игнорируем чистые нули:
					if (fabs(vs1) > 1.0e-37) {
						// Мы не записываем в матрицу чистый ноль.
						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = (integer_mix_precision)(istr);
						Atemp.j = (integer_mix_precision)(jstr);


					
						AccumulqtorA_m[tid][istartAnew_m[tid]++] = Atemp;
					
					}


				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			

			index_size_m[tid] = 0; // Сброс индикатора, строка обработана.			

		}

		

		printf("oK. Counting Sort start.\n");
		for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++)
		{
			for (integer i_92 = 0; i_92 < istartAnew_m[i_9]; i_92++) {
				Amat[istartAnew++] = AccumulqtorA_m[i_9][i_92];
			}
		}

		Counting_Sort(Amat, istartAnew_mem, istartAnew-1, false, indx_comparei);
		printf("Counting Sort End. \n");
		
		//getchar();

#else

		// Сканируем первый операнд построчно.
		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Начинаем обрабатывать новую строку.
			// Сброс формирователя суммы в ноль.
			//#pragma omp parallel for
			//for (integer i_2 = 1; i_2 <= n_a[ilevel - 1]; i_2++) {
			//vector_sum[i_2] = 0.0; // инициализация // 18.5
			//b_visit_vec_sum[i_2] = false;
			//}
			// Более быстрое обнуление
			// По времени в лучшем случае также. Но может сильно ухудшиться из-за занятости системной dll-ки.
			//memset(vector_sum, 0,size_v );

			node_AVL_Gus* root_Gus = 0;

			if (0) {

				// линейный поиск очень медленный на больших размерностях.

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else if (0) {

				// закомментировано т.к. это медленная ветвь кода.
				// Ситуация такая. Ранее на небольших задачах до 1М включительно,
				// данная ветвь кода не показывала выигрыша в быстродействии и возможно 
				// даже была слегка медленее (совсем немного). 
				// Это быстрая часть кода на больших размерностях.
				// Гораздо лучше линейного поиска. Сейчас это подтверждается
				// на непрямой интерполяции при задаче в 3.2М неизвестных.
				// Там на линейный поиск в данном месте тратится не менее 80% фазы построения грубосеточных операторов.

				// На основе АВЛ
				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							root_Gus = insert_Gus(root_Gus, iaddind);
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else {

				// на основе hash таблицы. 

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					// Общую переменную объяим на уровень выше.
					doublerealT left_operand = R[ii].aij;
					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {

						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						//foundnow = isfound_Gus(root_Gus, iaddind);
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							//root_Gus = insert_Gus(root_Gus, iaddind);
							hash_table[iaddind] = true;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}


			doublerealT maxth = -1.0;
			if (0) {

				// 22 октября 2016 Мы искоренили барьер из части P*Amat.
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					hash_table[jstr] = false; // инициализируем hash таблицу для следующих проходов.
					if (istr != jstr) {
						// 14 января 2016.
						// Правильнее определить величину барьера только по внедиагональным элементам.
						if (fabs(vector_sum[jstr]) > maxth) maxth = fabs(vector_sum[jstr]);
					}
				}
			}
			else {
				// 22 октября 2016 Мы искоренили барьер из части P*Amat.
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					hash_table[jstr] = false; // инициализируем hash таблицу для следующих проходов.
				}
			}

			/*
			if (nsizeA > istartAnew + index_size) {
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
			integer jstr = index_visit[i_6];
			if (istr != jstr) {
			// 5 декабря 2015. threshold.
			//if (fabs(vector_sum[jstr]) > 1.0e-30) {
			if (fabs(vector_sum[jstr]) > barjer*maxth) {
			Amat[istartAnew].aij = vector_sum[jstr];
			Amat[istartAnew].i = istr;
			Amat[istartAnew].j = jstr;
			istartAnew++;
			}
			}
			else {
			// диагональный элемент записываем обязательно.
			Amat[istartAnew].aij = vector_sum[jstr];
			Amat[istartAnew].i = istr;
			Amat[istartAnew].j = jstr;
			istartAnew++;
			}
			}
			}
			else {
			// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
			// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
			printf("Amat lack of memory\n");
			printf("yuo mast increase the size of the matrix Amat and restart solver\n");
			printf("please, press any key to exit.\n");
			system("pause");
			exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем
			// проверками.
			bool bCheck_ok = false; // прооверяет наличие диагонали в строке матрицы.
			integer istartAnew_8 = istartAnew; // запоминаем для вылечивания строки.
			doublerealT barjer_maxth = barjer*maxth;
			doublerealT mbarjer_maxth = -barjer_maxth;
			if (nsizeA > istartAnew + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];

					doublerealT vs1 = vector_sum[jstr];

					if ((istr == jstr) && (vs1 > 1.0e-20)) {
						bCheck_ok = true;
					}

					// 22 октября 2016. Полностью искоренён барьер из части P*Amat произведения.
					//if ((vs1 < mbarjer_maxth) || (vs1 > barjer_maxth)) {
					//Amat[istartAnew].aij = vs1;
					//Amat[istartAnew].i = istr;
					//Amat[istartAnew].j = jstr;
					//istartAnew++;

					// 7 ноября 2016 игнорируем чистые нули:
					if (fabs(vs1) > 1.0e-37) {
						// Мы не записываем в матрицу чистый ноль.
						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = istr;
						Atemp.j = jstr;
						Amat[istartAnew++] = Atemp;
					}
#if doubleintprecision == 1
					//if (fabs(vs1) < 1.0e-37) {
					//  	printf("error!!! i=%lld j=%lld val=%e\n",istr,jstr,vs1);
					//}

					//}
#else
					//if (fabs(vs1) < 1.0e-37) {
					//  	printf("error!!! i=%d j=%d val=%e\n",istr,jstr,vs1);
					//}

					//}
#endif
					
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			if (!bCheck_ok) {
#if doubleintprecision == 1
				/*
				printf("bad string %lld\n",istr);
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];

				doublerealT vs1 = vector_sum[jstr];
				printf("%lld %lld %e\n",istr,jstr,vs1);
				}
				*/
#else
				/*
				printf("bad string %d\n",istr);
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];

				doublerealT vs1 = vector_sum[jstr];
				printf("%d %d %e\n",istr,jstr,vs1);
				}
				*/
#endif
				
				// Ненадо ничего лечить здесь, т.к. даже на правильно 
				// рассчитываемых тестах диагональ либо отрицательна либо вообще отсутствует.
				// С этим надо детально разбираться 25_11_2016.
				/*
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];

				doublerealT vs1 = vector_sum[jstr];
				#if doubleintprecision == 1
					//printf("%lld %lld %e\n", istr, jstr, vs1);
				#else
					//printf("%d %d %e\n", istr, jstr, vs1);
				#endif
				
				// Здесь мы как бы делаем из этой плохой строки С узел.
				if (istr == jstr) {
				Amat[istartAnew_8++].aij = 1.0;
				}
				else {
				Amat[istartAnew_8++].aij = 0.0;
				}
				}
				system("pause");
				*/
			}

			index_size = 0; // Сброс индикатора, строка обработана.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

		}

#endif

		//delete[] index_visit;
		//delete[] row_ind_SR;
		//delete[] row_ind_ER;
		//delete[] row_ind_SA;
		//delete[] row_ind_EA;
		//delete[] vector_sum;

		free(index_visit);
		index_visit = nullptr;
		free(row_ind_SR);
		row_ind_SR = nullptr;
		free(row_ind_ER);
		row_ind_ER = nullptr;
		free(row_ind_SA);
		row_ind_SA = nullptr;
		free(row_ind_EA);
		row_ind_EA = nullptr;
		free(vector_sum);
		vector_sum = nullptr;


		// Сортировка А по i (оригинала.).
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);

		/*
		// Лишняя сортировка до этого уже была выполнена сортировка по i.
		// 7 января 2016.
		switch (imy_sort_algorithm ) {
		case MY_SORT_ALGORITHM:: COUNTING_SORT:
		    Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		case MY_SORT_ALGORITHM:: QUICK_SORT:
		    qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		    // Библиотечный алгоритм. O(nlog(n)).
		    // Не использует лишней памяти.
		    //std::sort(Amat + 1 + iadd, Amat + nnz_a[ilevel - 1] + iadd+1, compareAk1R);
		break;
		case MY_SORT_ALGORITHM:: HEAP_SORT:
		     HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		default:
		    Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		}		
		*/


		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
		//if (Amat[i_1].j < 0) {
		//	printf("error: negativ j index\n");
		//	system("pause");
		//}
#if doubleintprecision == 1
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}



		// Часть 2. [R*Afine]*P=Abuf*P.
		// Сортировка [R*А] по i.
		//heapsort(Amat, key=i*n_coarce + j, 1, nnz_a[ilevel - 1]);

		// В результате работы алгоритма разреженного матричного умножения по Густавсону,
		// мы и так имеем отсортированный по строкам результат, поэтому дополнительная 
		// сортировка не требуется. Это проверено 11 января 2016.
		// 11 января 2016.
		/*
		// Обязательно нужна сортировка.
		switch (imy_sort_algorithm ) {
		case MY_SORT_ALGORITHM:: COUNTING_SORT:
		    Counting_Sort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		break;
		case MY_SORT_ALGORITHM:: QUICK_SORT:
		    qs(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
	    	// Библиотечный алгоритм. O(nlog(n)).
	    	// Не использует лишней памяти.
	    	//std::sort(Amat + nnz_a[ilevel - 1] + 1 + iadd, Amat + istartAnew - 1+1, compareAk1R);
		break;
		case MY_SORT_ALGORITHM:: HEAP_SORT:
		     HeapSort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		break;
		default:
		     Counting_Sort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		break;
		}
		*/



		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
		//if (Amat[i_1].j < 0) {
		//	printf("error: negativ j index\n");
		//	system("pause");
		//}
#if doubleintprecision == 1
		//-->	//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//-->	//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}




		/*
		// 10 января 2016. Данная сортировка не требуется.
		switch (imy_sort_algorithm ) {
		case MY_SORT_ALGORITHM:: COUNTING_SORT:
		    Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		case MY_SORT_ALGORITHM:: QUICK_SORT:
		    qs(P, 1 + iaddR, iaddR + nnzR - 1);
		    // Библиотечный алгоритм. O(nlog(n)).
		    // Не использует лишней памяти.
		    //std::sort(P +  1 + iaddR, P + iaddR + nnzR - 1+1, compareAk1R);
		break;
		case MY_SORT_ALGORITHM:: HEAP_SORT:
		      HeapSort(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		default:
		    Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		}

		*/


		// Prolongation должна быть упорядочена по j.
		// Начальная позиция элементов матрицы грубосеточного уровня.
		istartAnew2 = istartAnew;



		// Быстрее этого кода на основе идеи слияния списков уже не будет.
		// 17 октября 2015. Нужно двигаться в сторону Писсанецки.
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#endif
			
		}



		// Фред Густавсон IBM 1978
		// В ядре кода Густавсона нету ни одного ветвления,
		// а мы знаем что в результате профайлинга предыдущих версий кода:
		// (наивный, слияние, Писсанецки) львиная доля вычислительной работы уходила
		// на сравнения (ветвления) в отношении примерно 30 к 1. 30 сравнений на одно суммирование.
		// 23 октября 2015 года.
		// 6 января 2016 года Добавлено АВЛ дерево.


		// Рабочая версия алгоритма Фреда Густавсона.
		// IBM 1978 Sparse Matrix multiplication.

		// Сортировка обязательно требуется.
		// Преобразование обоих матриц в формат CRS.
		switch (imy_sort_algorithm) {
		case MY_SORT_ALGORITHM::COUNTING_SORT :
			Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
			break;
		case MY_SORT_ALGORITHM::QUICK_SORT :
			qs(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
			// Библиотечный алгоритм. O(n*log2(n)).
			// Не использует лишней памяти.
			//std::sort(P + 1 + iaddR, P + iaddR + nnzR - 1+1, compareAk1P);
			break;
		case MY_SORT_ALGORITHM::HEAP_SORT :
			HeapSort(P, 1 + iaddR, iaddR + nnzR - 1, comparej);
			break;
		default:
			Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
			break;
		}
		

		row_ind_AS = nullptr;
		//row_ind_AS = new integer[numberofcoarcenodes + 1];
		row_ind_AS = (integer*)malloc((numberofcoarcenodes + 1) * sizeof(integer));
		handle_error<integer>(row_ind_AS, "row_ind_AS", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));

		row_ind_AE = nullptr;
		//row_ind_AE = new integer[numberofcoarcenodes + 1];
		row_ind_AE = (integer*)malloc((numberofcoarcenodes + 1) * sizeof(integer));
		handle_error<integer>(row_ind_AE, "row_ind_AE", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));

		istart2 = nnz_a[ilevel - 1] + 1 + iadd;
		integer iend2_glob = istartAnew - 1;
#pragma omp parallel for
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		//int istr_memo = -1;
		for (integer ii = istart2; ii <= iend2_glob; ii++) {
			if (flag[Amat[ii].i] == false) {
				// сканируем построчно.
				integer istr = Amat[ii].i;
				integer ic = ii;
				//istr_memo = istr;
				integer kf = ic;

				while ((kf <= iend2_glob) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_AS[istr] = ic;
				row_ind_AE[istr] = kf;
				//if (ii > istart2) {
					//row_ind_AE[istr - 1] = ic - 1;
				//}
				flag[Amat[ii].i] = true;
				ii = kf;

			}
		}
		//row_ind_AE[istr_memo] = iend2_glob;

		row_ind_PS = nullptr;
		//row_ind_PS = new integer[n_a[ilevel - 1] + 1];
		row_ind_PS = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(row_ind_PS, "row_ind_PS", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		 row_ind_PE = nullptr;
		//row_ind_PE = new integer[n_a[ilevel - 1] + 1];
		row_ind_PE = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(row_ind_PE, "row_ind_PE", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));


		// Инициализация чрезвычайно важна, т.к. 
		// обязательно присутствуют пустые строки которые
		// надо корректно обрабатывать.
#pragma omp parallel for
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			row_ind_PS[ii] = -1; // инициализация.
			row_ind_PE[ii] = -2;
		}
		istart4 = 1 + iaddR;
		iend4 = nnzR - 1 + iaddR;
#pragma omp parallel for
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = istart4; ii <= iend4; ii++) {
			if (flag[P[ii].j] == false) {
				// сканируем построчно.
				integer istr = P[ii].j;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend4) && (P[kf].j == istr)) {
					kf++;
				}
				kf--;
				row_ind_PS[istr] = ic;
				row_ind_PE[istr] = kf;
				flag[P[ii].j] = true;
				ii = kf;

			}
		}

		// Данный код подтверждает что обязательно присутствуют
		// пустые строки.
		//for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
		//if (row_ind_PS[ii] == -1) {
#if doubleintprecision == 1
		//printf("propusk string %lld\n", row_ind_PE[ii]);
#else
		//printf("propusk string %d\n", row_ind_PE[ii]);
#endif
		
		//getchar();
		//}
		//}

		// Накопитель результата.
		//vector_sum = new doublerealT[numberofcoarcenodes + 1];
		if (vector_sum != nullptr) {
			free(vector_sum);
			vector_sum = nullptr;
		}
		vector_sum = (doublerealT*)malloc((numberofcoarcenodes + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));

		//integer size_v = sizeof(doublerealT)*(1 + numberofcoarcenodes);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		if (index_visit != nullptr) {
			free(index_visit);
			index_visit = nullptr;
		}
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		index_visit[0] = 0;
		index_size = 0;

//#ifdef _NONAME_STUB29_10_2017
#ifdef _OPENMP

		// Данные используемые для частичного формирователя суммы.

		for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++) {

			for (integer i_91 = 0; i_91 < 10 * n + 1; i_91++) hash_table_m[i_9][i_91] = false;// inicialization
			index_size_m[i_9] = 0;
			istartAnew_m[i_9] = 0;
		}
		

		// Мы будем сканировать левый операнд построчно, а
		// после окончания обработки одной строки левого операнда
		// получать готовую строку результата.

		// Сканируем первый операнд построчно.
		// глобальные переменные не перечисляются.
#pragma omp parallel for 
		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

#ifdef _OPENMP 
			int tid = omp_get_thread_num();
#else
			int tid = 0;
#endif			

			// На основе hash таблицы.
			// сканируем все элементы строки левого операнда.
			for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
				integer col_ind = Amat[ii1].j;
				doublerealT left_operand = Amat[ii1].aij;

				// Сканируем col_ind строку правого операнда накапливая сумму.
				for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {

					doublerealT right_operand = P[ii2].aij;

					integer iaddind = P[ii2].i;
					bool foundnow = false;
					
					// мгновенный поиск за O(1).
					foundnow = hash_table_m[tid][iaddind];

					if (foundnow) {
						//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
						vector_sum_m[tid][iaddind] += left_operand*right_operand;
					}
					else {
						// Первое добавление.
						index_size_m[tid]++;
						index_visit_m[tid][index_size_m[tid]] = iaddind;
						
						// Мгновенная вставка в hash table за O(1).
						hash_table_m[tid][iaddind] = true;

						//ifoundind = index_size;
						//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
						vector_sum_m[tid][iaddind] = left_operand*right_operand;
					}
					// требуется реализовать следующую логику:
					// 1. поиск элемента по ключу 
					// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
					// Если элемент найден то нужно просто изменить foundnow на true. 
					// Т.е. достаточно просто поиска и вставки.
					// 3. В конце дерево необходимо ликвидировать.
					// Тип данных целочисленный ключ.


					//vector_sum[P[ii2].i] += rleft*rright;
				}
			}

			doublerealT maxth = -1.0;
			for (integer i_6 = 1; i_6 <= index_size_m[tid]; i_6++) {
				integer jstr = index_visit_m[tid][i_6];
				hash_table_m[tid][jstr] = false; // initialization hash.
				if (istr != jstr) {
					// 14 января 2016 года.
					// Правильно определить барьер только по внедиагональным элементам.
					if (fabs(vector_sum_m[tid][jstr]) > maxth) maxth = fabs(vector_sum_m[tid][jstr]);
				}
			}
			
			// huck: 16.04.2017

			for (integer i_61 = 1; i_61 <= index_size_m[tid]; i_61++) {

				integer jstr61 = index_visit_m[tid][i_61];
				doublerealT vs161 = vector_sum_m[tid][jstr61];
#if doubleintprecision == 1
				//printf("i=%lld j=%lld aij=%e\n", istr, jstr61, vs161);
#else
				//printf("i=%d j=%d aij=%e\n", istr, jstr61, vs161);
#endif


				if ((istr == jstr61) && (vs161 < 1.0e-20)) {
					// отрицательный элемент на диагонали.

					printf("Negative diagonal coefficient found. No panic. Upwind patching. 16.04.2017. \n");

					printf("bad string: \n");
					for (integer i_63 = 1; i_63 <= index_size_m[tid]; i_63++) {

						integer jstr63 = index_visit_m[tid][i_63];
						doublerealT vs163 = vector_sum_m[tid][jstr63];
#if doubleintprecision == 1
						printf("i=%lld j=%lld aij=%e\n", istr, jstr63, vs163);
#else
						printf("i=%d j=%d aij=%e\n", istr, jstr63, vs163);
#endif

					}


					// Адаптированные три правила бак-труба:
					// Amat. Диагонали присваиваем сумма модулей только отрицательных внедиагональных коэффициентов +
					// вычитаем из этого отрицательную диагональ. Потом умножаем на два.
					// B. Удвоение отрицательных внедиагональных коэффициентов.
					// C. Полное зануление положительных внедиагональных коэффициентов (игнорирование).
					printf("patching string 16.04.2017: \n");
					for (integer i_62 = 1; i_62 <= index_size_m[tid]; i_62++) {
						integer jstr62 = index_visit_m[tid][i_62];
						if (istr != jstr62) {
							if (vector_sum_m[tid][jstr62] > 0.0) {
								index_visit_m[tid][i_62] = -1; // не существует такого элемента (игнорирование).
								vector_sum_m[tid][jstr61] += vector_sum_m[tid][jstr62];
								vector_sum_m[tid][jstr62] = 0.0;
							}
						}
					}

					if (vector_sum_m[tid][jstr61] < 0.0) {
						vector_sum_m[tid][jstr61] = 0.0;
						for (integer i_62 = 1; i_62 <= index_size_m[tid]; i_62++) {
							integer jstr62 = index_visit_m[tid][i_62];
							if (jstr62 > -1) {
								if (istr != jstr62) {
									if (vector_sum_m[tid][jstr62] < 0.0) {
										vector_sum_m[tid][jstr61] += fabs(vector_sum_m[tid][jstr62]);
									}
								}
							}
						}
					}

					// Выход из цикла for по переменной i_61.
					break;
				}


			}


			bool bCheck_ok = false; // прооверяет наличие диагонали в строке матрицы.
									// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем проверками.
			doublerealT barjerA_maxth = barjerA*maxth;
			doublerealT mbarjerA_maxth = -barjerA_maxth;
			if (nsizeA > istartAnew2 + index_size_m[tid]) {
				for (integer i_6 = 1; i_6 <= index_size_m[tid]; i_6++) {

					integer jstr = index_visit_m[tid][i_6];
					doublerealT vs1 = vector_sum_m[tid][jstr];
					//if (fabs(vs1) < 1.0e-37) {
#if doubleintprecision == 1
					//printf("zero vs1=%e, i==%lld j==%lld\n",vs1,istr,jstr);
#else
					//printf("zero vs1=%e, i==%d j==%d\n",vs1,istr,jstr);
#endif

					//}
					// 7 ноября 2016 игнорируем чистые нули:
					if ((jstr>-1) && (fabs(vs1) > 1.0e-37)) {
						// Мы игнорируем чистые нули. 
						// Но вообще говоря непонятно почему они появляются.

						if (barjerA < 0.0) {
							// алгебраический мультигрид Галёркина.
							// 22_10_2016.
							Ak1 Atemp;
							Atemp.aij = vs1;
							Atemp.i = (integer_mix_precision)(istr);
							Atemp.j = (integer_mix_precision)(jstr);

							if (istr == jstr) bCheck_ok = true;

							if ((istr == jstr) && (vs1 < 1.0e-20)) {
								// Ошибка проявляется в отсутствии диагонального элемента в результирующей матрице первого
								// произведения Галеркина. Надо смотреть ситуацию выше по коду.
								// 22737
								// сканируем все элементы строки левого операнда.
								//for (integer ii1_8 = row_ind_AS[istr]; ii1_8 <= row_ind_AE[istr]; ii1_8++) {
								//if (Amat[ii1_8].i == 22737) {
#if doubleintprecision == 1
								//printf("i=%lld j=%lld aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
#else
								//printf("i=%d j=%d aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
#endif

								//}
								//integer col_ind = Amat[ii1_8].j;
								//}
#if doubleintprecision == 1
								printf("bad string %lld\n", istr);
#else
								printf("bad string %d\n", istr);
#endif

								printf("error: diagonal element is negative...\n");
								switch (iVar) {
								case PAM: printf("PAM equation\n"); break;
								case VELOCITY_X_COMPONENT: printf("VX equation\n"); break;
								case VELOCITY_Y_COMPONENT: printf("VY equation\n"); break;
								case VELOCITY_Z_COMPONENT: printf("VZ equation\n"); break;
								case TEMP: printf("TEMP equation\n"); break;
								case TOTALDEFORMATIONVAR: printf("STRESS system equation\n"); break;
								}
#if doubleintprecision == 1
								//for (integer ii1_8 = row_ind_AS[istr]; ii1_8 <= row_ind_AE[istr]; ii1_8++) {
								//printf("i=%lld j=%lld aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
								//}
#else
								//for (integer ii1_8 = row_ind_AS[istr]; ii1_8 <= row_ind_AE[istr]; ii1_8++) {
								//printf("i=%d j=%d aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
								//}
#endif

								for (integer i_61 = 1; i_61 <= index_size_m[tid]; i_61++) {

									integer jstr61 = index_visit_m[tid][i_61];
									doublerealT vs161 = vector_sum_m[tid][jstr61];
#if doubleintprecision == 1
									printf("i=%lld j=%lld aij=%e\n", istr, jstr61, vs161);
#else
									printf("i=%d j=%d aij=%e\n", istr, jstr61, vs161);
#endif

								}
								//getchar();
								system("pause");
								// прекращаем строить иерархию уровней.
								bcontinue_global = false;
								//goto BAD_STRING_MARKER;
								printf("fatall error bad string: goto BAD_STRING_MARKER;\n");
								system("pause");
								exit(1);

								doublerealT sum_dia = 0.0;
								for (integer i_8 = 1; i_8 <= index_size_m[tid]; i_8++) {
									if (i_8 != i_6) {
										integer jstr_8 = index_visit_m[tid][i_8];
										doublerealT vs1_8 = vector_sum_m[tid][jstr_8];
										sum_dia += fabs(vs1_8);
									}
								}
								// принудительное сильнейшее усиление диагонали.
								Atemp.aij = sum_dia;
								// ошибка признана не являющейся фатальной.
								// 22 декабря 2016
								//system("pause");
							}

							//Amat[istartAnew2].aij = vs1;
							//Amat[istartAnew2].i = istr;
							//Amat[istartAnew2].j = jstr;
							//istartAnew2++;

							//Amat[istartAnew2++] = Atemp;
							AccumulqtorA_m[tid][istartAnew_m[tid]++] = Atemp;
						}
						else {
							// TODO non Galerking amg.
							if ((vs1 < mbarjerA_maxth) || (vs1 > barjerA_maxth)) {
								Ak1 Atemp;
								Atemp.aij = vs1;
								Atemp.i = (integer_mix_precision)(istr);
								Atemp.j = (integer_mix_precision)(jstr);

								//Amat[istartAnew2].aij = vs1;
								//Amat[istartAnew2].i = istr;
								//Amat[istartAnew2].j = jstr;
								//istartAnew2++;

								//Amat[istartAnew2++] = Atemp;
								AccumulqtorA_m[tid][istartAnew_m[tid]++] = Atemp;

							}
						}
					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			if (!bCheck_ok) {
#if doubleintprecision == 1
				printf("bad string %lld\n", istr);
#else
				printf("bad string %d\n", istr);
#endif

				// прекращаем строить иерархию уровней.
				bcontinue_global = false;
				//goto BAD_STRING_MARKER;
				printf("fatall error bad string: goto BAD_STRING_MARKER 2;\n");
				system("pause");
				exit(1);

				for (integer i_6 = 1; i_6 <= index_size_m[tid]; i_6++) {

					integer jstr = index_visit_m[tid][i_6];
					doublerealT vs1 = vector_sum_m[tid][jstr];
#if doubleintprecision == 1
					printf("%lld %lld %e\n", istr, jstr, vs1);
#else
					printf("%d %d %e\n", istr, jstr, vs1);
#endif

				}
				system("pause");
			}

			index_size_m[tid] = 0;
			
		}

	    integer istartAnew_mem2;
		istartAnew_mem2 = istartAnew2;
		printf("oK2. Counting Sort start.\n");
		for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++)
		{
			for (integer i_92 = 0; i_92 < istartAnew_m[i_9]; i_92++) {
				Amat[istartAnew2++] = AccumulqtorA_m[i_9][i_92];
			}
		}

		Counting_Sort(Amat, istartAnew_mem2, istartAnew2 - 1, false, indx_comparei);
		printf("Counting Sort End. \n");

#else

		// Мы будем сканировать левый операнд построчно, а
		// после окончания обработки одной строки левого операнда
		// получать готовую строку результата.

		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Переход к новой строке, сброс накопителя результата.
			//#pragma omp parallel for
			//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			//vector_sum[i_1] = 0.0; // обнуление.
			//}
			// хоть профайлер и показывает что на memset тратиться меньше процессорного времени,
			// но там возникает системный вызов на который тратиться столько же времени что и раньше.
			// работа перекочевала из одного места в другое.
			// Более быстрое обнуление.
			//memset(vector_sum, 0, size_v);

			node_AVL_Gus* root_Gus = 0;

			if (0) {
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;
					doublerealT left_operand = Amat[ii1].aij;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						// здесь объявляем только текущий локальный множитель.
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику:
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else if (0) {

				// На основе АВЛ дерева.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						// Бинарный поиск в АВЛ дереве.
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							root_Gus = insert_Gus(root_Gus, iaddind);

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику:
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else {

				// На основе hash таблицы.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;
					doublerealT left_operand = Amat[ii1].aij;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {

						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						// Бинарный поиск в АВЛ дереве.
						//foundnow = isfound_Gus(root_Gus, iaddind);
						// мгновенный поиск за O(1).
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							//root_Gus = insert_Gus(root_Gus, iaddind);
							// Мгновенная вставка в hash table за O(1).
							hash_table[iaddind] = true;

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику:
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}


			doublerealT maxth = -1.0;
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];
				hash_table[jstr] = false; // initialization hash.
				if (istr != jstr) {
					// 14 января 2016 года.
					// Правильно определить барьер только по внедиагональным элементам.
					if (fabs(vector_sum[jstr]) > maxth) maxth = fabs(vector_sum[jstr]);
				}
			}

			/*
			if (nsizeA > istartAnew2 + index_size) {
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
			// 15 декабря 2015.
			// Если не принять специальных мер элементы не будут упорядочены
			// и двоичным поиском воспользоваться нельзя.
			//if (index_visit[i_6] < index_visit[i_6 - 1]) {
			//printf("Gipotesa uporqdochennosti in Fred Gustavson neverna\n");
			//system("pause");
			//}

			integer jstr = index_visit[i_6];
			if (istr != jstr) {
			// 5 декабря 2015 года. Сохранение разреженности.
			//if (fabs(vector_sum[jstr]) > 1.0e-30) {
			if (fabs(vector_sum[jstr]) > barjerA*maxth) {
			Amat[istartAnew2].aij = vector_sum[jstr];
			Amat[istartAnew2].i = istr;
			Amat[istartAnew2].j = jstr;
			istartAnew2++;
			}
			}
			else {
			Amat[istartAnew2].aij = vector_sum[jstr];
			Amat[istartAnew2].i = istr;
			Amat[istartAnew2].j = jstr;
			istartAnew2++;
			}
			}
			}
			else {
			// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
			// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
			printf("Amat lack of memory\n");
			printf("yuo mast increase the size of the matrix Amat and restart solver\n");
			printf("please, press any key to exit.\n");
			system("pause");
			exit(1);
			}
			*/

			// huck: 16.04.2017

			for (integer i_61 = 1; i_61 <= index_size; i_61++) {

				integer jstr61 = index_visit[i_61];
				doublerealT vs161 = vector_sum[jstr61];
#if doubleintprecision == 1
				//printf("i=%lld j=%lld aij=%e\n", istr, jstr61, vs161);
#else
				//printf("i=%d j=%d aij=%e\n", istr, jstr61, vs161);
#endif
				

				if ((istr == jstr61) && (vs161 < 1.0e-20)) {
					// отрицательный элемент на диагонали.

					printf("Negative diagonal coefficient found. No panic. Upwind patching. 16.04.2017. \n");

					printf("bad string: \n");
					for (integer i_63 = 1; i_63 <= index_size; i_63++) {

						integer jstr63 = index_visit[i_63];
						doublerealT vs163 = vector_sum[jstr63];
#if doubleintprecision == 1
						printf("i=%lld j=%lld aij=%e\n", istr, jstr63, vs163);
#else
						printf("i=%d j=%d aij=%e\n", istr, jstr63, vs163);
#endif
						
					}


					// Адаптированные три правила бак-труба:
					// Amat. Диагонали присваиваем сумма модулей только отрицательных внедиагональных коэффициентов +
					// вычитаем из этого отрицательную диагональ. Потом умножаем на два.
					// B. Удвоение отрицательных внедиагональных коэффициентов.
					// C. Полное зануление положительных внедиагональных коэффициентов (игнорирование).
					printf("patching string 16.04.2017: \n");
					for (integer i_62 = 1; i_62 <= index_size; i_62++) {
						integer jstr62 = index_visit[i_62];
						if (istr != jstr62) {
							if (vector_sum[jstr62] > 0.0) {
								index_visit[i_62] = -1; // не существует такого элемента (игнорирование).
								vector_sum[jstr61] += vector_sum[jstr62];
								vector_sum[jstr62] = 0.0;
							}
						}
					}

					if (vector_sum[jstr61] < 0.0) {
						vector_sum[jstr61] = 0.0;
						for (integer i_62 = 1; i_62 <= index_size; i_62++) {
							integer jstr62 = index_visit[i_62];
							if (jstr62 > -1) {
								if (istr != jstr62) {
									if (vector_sum[jstr62] < 0.0) {
										vector_sum[jstr61] += fabs(vector_sum[jstr62]);
									}
								}
							}
						}
					}

					// Выход из цикла for по переменной i_61.
					break;
				}


			}


			bool bCheck_ok = false; // прооверяет наличие диагонали в строке матрицы.
									// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем проверками.
			doublerealT barjerA_maxth = barjerA*maxth;
			doublerealT mbarjerA_maxth = -barjerA_maxth;
			if (nsizeA > istartAnew2 + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {

					integer jstr = index_visit[i_6];
					doublerealT vs1 = vector_sum[jstr];
					//if (fabs(vs1) < 1.0e-37) {
#if doubleintprecision == 1
					//printf("zero vs1=%e, i==%lld j==%lld\n",vs1,istr,jstr);
#else
					//printf("zero vs1=%e, i==%d j==%d\n",vs1,istr,jstr);
#endif
					
					//}
					// 7 ноября 2016 игнорируем чистые нули:
					if ((jstr>-1)&&(fabs(vs1) > 1.0e-37)) {
						// Мы игнорируем чистые нули. 
						// Но вообще говоря непонятно почему они появляются.

						if (barjerA < 0.0) {
							// алгебраический мультигрид Галёркина.
							// 22_10_2016.
							Ak1 Atemp;
							Atemp.aij = vs1;
							Atemp.i = istr;
							Atemp.j = jstr;

							if (istr == jstr) bCheck_ok = true;

							if ((istr == jstr) && (vs1 < 1.0e-20)) {
								// Ошибка проявляется в отсутствии диагонального элемента в результирующей матрице первого
								// произведения Галеркина. Надо смотреть ситуацию выше по коду.
								// 22737
								// сканируем все элементы строки левого операнда.
								//for (integer ii1_8 = row_ind_AS[istr]; ii1_8 <= row_ind_AE[istr]; ii1_8++) {
								//if (Amat[ii1_8].i == 22737) {
#if doubleintprecision == 1
								//printf("i=%lld j=%lld aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
#else
								//printf("i=%d j=%d aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
#endif
								
								//}
								//integer col_ind = Amat[ii1_8].j;
								//}
#if doubleintprecision == 1
								printf("bad string %lld\n", istr);
#else
								printf("bad string %d\n", istr);
#endif
								
								printf("error: diagonal element is negative...\n");
								switch (iVar) {
								case PAM: printf("PAM equation\n"); break;
								case VELOCITY_X_COMPONENT: printf("VX equation\n"); break;
								case VELOCITY_Y_COMPONENT: printf("VY equation\n"); break;
								case VELOCITY_Z_COMPONENT: printf("VZ equation\n"); break;
								case TEMP: printf("TEMP equation\n"); break;
								case TOTALDEFORMATIONVAR: printf("STRESS system equation\n"); break;
								}
#if doubleintprecision == 1
								//for (integer ii1_8 = row_ind_AS[istr]; ii1_8 <= row_ind_AE[istr]; ii1_8++) {
								//printf("i=%lld j=%lld aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
								//}
#else
								//for (integer ii1_8 = row_ind_AS[istr]; ii1_8 <= row_ind_AE[istr]; ii1_8++) {
								//printf("i=%d j=%d aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
								//}
#endif
								
								for (integer i_61 = 1; i_61 <= index_size; i_61++) {

									integer jstr61 = index_visit[i_61];
									doublerealT vs161 = vector_sum[jstr61];
#if doubleintprecision == 1
									printf("i=%lld j=%lld aij=%e\n", istr, jstr61, vs161);
#else
									printf("i=%d j=%d aij=%e\n", istr, jstr61, vs161);
#endif
									
								}
								// Принимаем меры.
								doublerealT sum_dia = 0.0;
								for (integer i_8 = 1; i_8 <= index_size; i_8++) {
									if (i_8 != i_6) {
										integer jstr_8 = index_visit[i_8];
										doublerealT vs1_8 = vector_sum[jstr_8];
										sum_dia += fabs(vs1_8);
									}
								}
								// принудительное сильнейшее усиление диагонали.
								Atemp.aij = sum_dia;
								// ошибка признана не являющейся фатальной.
								// 22 декабря 2016
								//system("pause");
								//getchar();
								system("pause");
								// прекращаем строить иерархию уровней.
								bcontinue_global = false;
								//goto BAD_STRING_MARKER;
							}

							//Amat[istartAnew2].aij = vs1;
							//Amat[istartAnew2].i = istr;
							//Amat[istartAnew2].j = jstr;
							//istartAnew2++;

							Amat[istartAnew2++] = Atemp;
						}
						else {
							// TODO non Galerking amg.
							if ((vs1 < mbarjerA_maxth) || (vs1 > barjerA_maxth)) {
								Ak1 Atemp;
								Atemp.aij = vs1;
								Atemp.i = istr;
								Atemp.j = jstr;

								//Amat[istartAnew2].aij = vs1;
								//Amat[istartAnew2].i = istr;
								//Amat[istartAnew2].j = jstr;
								//istartAnew2++;

								Amat[istartAnew2++] = Atemp;

							}
						}
					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			if (!bCheck_ok) {
#if doubleintprecision == 1
				printf("bad string %lld\n", istr);
#else
				printf("bad string %d\n", istr);
#endif
				
				
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {

					integer jstr = index_visit[i_6];
					doublerealT vs1 = vector_sum[jstr];
#if doubleintprecision == 1
					printf("%lld %lld %e\n", istr, jstr, vs1);
#else
					printf("%d %d %e\n", istr, jstr, vs1);
#endif
					
				}
				system("pause");

				// прекращаем строить иерархию уровней.
				bcontinue_global = false;
				//goto BAD_STRING_MARKER;
			}

			index_size = 0;
			// Освобождение памяти из под АВЛ дерева.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;
		}

#endif

		//delete[] vector_sum;
		//delete[] index_visit;
		if (vector_sum != nullptr) {
			free(vector_sum);
			vector_sum = nullptr;
		}
		if (index_visit != nullptr) {
			free(index_visit);
			index_visit = nullptr;
		}



		//delete[] row_ind_AS;
		//delete[] row_ind_AE;
		//delete[] row_ind_PS;
		//delete[] row_ind_PE;
		if (row_ind_AS != nullptr) {
			free(row_ind_AS);
			row_ind_AS = nullptr;
		}
		if (row_ind_AE != nullptr) {
			free(row_ind_AE);
			row_ind_AE = nullptr;
		}
		if (row_ind_PS != nullptr) {
			free(row_ind_PS);
			row_ind_PS = nullptr;
		}
		if (row_ind_PE != nullptr) {
			free(row_ind_PE);
			row_ind_PE = nullptr;
		}

		// TODO 22_10_2016
		// Это нужно для регуляции барьера barjerA.
		if (P_injection != nullptr) {
			delete[] P_injection;
			P_injection = nullptr;
		}
		if (R_injection != nullptr) {
			delete[] R_injection;
			R_injection = nullptr;
		}

		// Есть подозрение что это избыточный код и его не надо вызывать.
		// 13  декабря 2015.
		// Это полностью подтвердилось 13 декабря 2015 года.
		/*

		switch (imy_sort_algorithm ) {
		case MY_SORT_ALGORITHM:: COUNTING_SORT :
		    Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		case MY_SORT_ALGORITHM:: QUICK_SORT:
		    // Быстрая сортировка Хоара.
		   qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		   // Библиотечный алгоритм. O(nlog(n)).
		   // Не использует лишней памяти.
		   //std::sort(P + 1 + iaddR, P + iaddR + nnzR - 1+1, compareAk1P);
		break;
		case MY_SORT_ALGORITHM:: HEAP_SORT:
		     HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		default:
		    Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		}

		*/

		// Копируем матрицу А следующего уровня влево вплотную к матице первоначального уровня.
		//integer icounter3 = 1;
		nsize = istartAnew2 - (istartAnew);
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd, i_2 = 1; i_2 <= nsize; i_1++, i_2++) {
			integer i_right_position = istartAnew - 1 + i_2;
			Amat[i_1] = Amat[i_right_position];
		}

		if (bprint_mesage_diagnostic) {
			printf("Prolongation is construct.\n");
			// Общее количество узлов не являющихся соседемя, но не С соседями 
#if doubleintprecision == 1
			printf("diagnostic: the number of neighbors that are not Coarse (C) nodes %lld\n", the_number_of_neighbors_that_are_not_C_nodes);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic: the number of Fine (F) nodes with one single strong Coarse (C) neighbor=%lld \n", number_of_F_nodes_with_one_single_strong_C_neighbor);
			printf("diagnostic: the number of Fine (F) nodes with one single strong Coarse (C) neighbor\n");
			printf("and to the same not having strong Fine(F) neighbors %lld\n", number_of_F_nodes_with_one_single_strong_C_neighborF);
			//system("pause");
#else
			printf("diagnostic: the number of neighbors that are not Coarse (C) nodes %d\n", the_number_of_neighbors_that_are_not_C_nodes);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic: the number of Fine (F) nodes with one single strong Coarse (C) neighbor=%d \n", number_of_F_nodes_with_one_single_strong_C_neighbor);
			printf("diagnostic: the number of Fine (F) nodes with one single strong Coarse (C) neighbor\n");
			printf("and to the same not having strong Fine(F) neighbors %d\n", number_of_F_nodes_with_one_single_strong_C_neighborF);
			//system("pause");
#endif
			
		}
		if (debug_reshime) system("pause");


		//delete[] C_numerate;
		if (C_numerate != nullptr) {
			free(C_numerate);
			C_numerate = nullptr;
		}

		// Использование упорядочивания типа F-C ускоряет сходимость вычислительного процесса,
		// сокращая число V циклов требуемых для достижения сходимости.
	    iaddFCcolor = 0;
		for (integer i_71 = 0; i_71 < ilevel - 1; i_71++) iaddFCcolor += n_a[i_71];
		for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]  ) {
			F_false_C_true[iaddFCcolor+i_1] = true;
		}

		nnz_aRP[ilevel - 1] = nnzR - 1;
		iaddR += nnzR - 1;
		n_a[ilevel] = icounter - 1;
		nnz_a[ilevel] = nsize;
		iadd += nnz_a[ilevel - 1];

		

		if (bcontinue_global) {
			// если bad string не встречалось.
			ilevel++;

			if (bStrongTransposeON) {
				// Освобождение ОЗУ.
				if (bAVLST_ON) {
					if (hash_StrongTranspose_collection != nullptr) {
						for (integer i_1 = 0; i_1 <= n_a[ilevel - 2]; i_1++) clear_AVL(hash_StrongTranspose_collection[i_1]);
						delete[] hash_StrongTranspose_collection;
						hash_StrongTranspose_collection = nullptr;
					}
				}
				else {
					// Обычный линейный список.
					if (hash_StrongTranspose_collection1 != nullptr) {
						// otkl_parr_aug2017
#pragma omp parallel for
						//for (integer i_1 = 0; i_1 <= n_a[ilevel - 2]; i_1++) {
						//isize_memory_alloc_hash_StrongTranspose_collection1
						for (integer i_1 = 0; i_1 <= isize_memory_alloc_hash_StrongTranspose_collection1; i_1++) {
							clear_list(hash_StrongTranspose_collection1[i_1]);
						}
						delete[] hash_StrongTranspose_collection1;
						hash_StrongTranspose_collection1 = nullptr;
					}
				}
				if (isize_hash_StrongTranspose_collection != nullptr) {
					delete[] isize_hash_StrongTranspose_collection;
					isize_hash_StrongTranspose_collection = nullptr;
				}
			}
		}
		else {
			if (bStrongTransposeON) {
				// Освобождение ОЗУ.
				if (bAVLST_ON) {
					if (hash_StrongTranspose_collection != nullptr) {
						for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) clear_AVL(hash_StrongTranspose_collection[i_1]);
						delete[] hash_StrongTranspose_collection;
						hash_StrongTranspose_collection = nullptr;
					}
				}
				else {
					// Обычный линейный список.
					if (hash_StrongTranspose_collection1 != nullptr) {
						//for (integer i_1 = 0; i_1 <= n_a[ilevel - 2]; i_1++)
						//isize_memory_alloc_hash_StrongTranspose_collection1
						for (integer i_1 = 0; i_1 <= isize_memory_alloc_hash_StrongTranspose_collection1; i_1++)
						{
						 clear_list(hash_StrongTranspose_collection1[i_1]);
						}
						delete[] hash_StrongTranspose_collection1;
						hash_StrongTranspose_collection1 = nullptr;
					}
				}
				if (isize_hash_StrongTranspose_collection != nullptr) {
					delete[] isize_hash_StrongTranspose_collection;
					isize_hash_StrongTranspose_collection = nullptr;
				}
			}
		}

		//delete[] count_neighbour;
		if (count_neighbour != nullptr) {
			free(count_neighbour);
			count_neighbour = nullptr;
		}
		//delete[] row_startA;
		if (row_startA != nullptr) {
			free(row_startA);
			row_startA = nullptr;
		}


		// построение иерархии уровней досрочно прекращено.
		//BAD_STRING_MARKER: 

		// сортировка А по i.
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		/*

		if (nnz_a[ilevel - 1] < heapsortsizelimit) {
		HeapSort(Amat, n_a[ilevel - 1], 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		Ak1* Aorig = &Amat[1 + iadd];
		MergeSort(Aorig, nnz_a[ilevel - 1]);
		Aorig = nullptr;
		}

		*/

#if doubleintprecision == 1
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%lld ",Amat[i_1].j);
		//}
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#else
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%d ",Amat[i_1].j);
		//}
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#endif
		


		//exit(1);
		if (bprint_mesage_diagnostic) {
			printf("one level construct OK.\n");
		}
		if (debug_reshime) system("pause");


		//printf("export b\n");
		//exporttecplot(b,n);

		//doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

		// restriction
		//restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
		//for (integer ii = 1; ii <= n_a[0]; ii++) {
		//b[ii] = 0.0;
		//}

		/*{
		doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		for (integer ii = 1; ii <= n_a[1]; ii++) {
		test_coarse[ii] = 0.0;
		}

		{
		doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		for (integer ii = 1; ii <= n_a[2]; ii++) {
		test_coarse1[ii] = 0.0;
		}

		prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		}

		prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		}
		*/
		//prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

		//exporttecplot(b, n);
		// proverka start
		// на сетке 81х81 проверка успешно проходится.

		/*
		printf("proverka start\n");
		// первый уровень вложенности.
		if (ilevel > 1) {
		for (integer i = 1; i <= n; i++) {
		flag[i] = false;
		}

		for (integer ii77 = nnz_a[0] + 1; ii77 <= nnz_a[0] + nnz_a[1]; ii77++) {
		if (flag[Amat[ii77].i] == false) {
		integer istr77 = Amat[ii77].i;
		integer ic77 = ii77;
		//integer icdiag = ii77;
		doublerealT ap = 0.0;
		//x[istr] = b[istr];
		while ((ic77 <= nnz_a[0] + nnz_a[1]) && (Amat[ic77].i == istr77)) {
		if (Amat[ic77].j != istr77) {
		//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
		}
		else {
		ap = Amat[ic77].aij;
		//icdiag = ic77;
		}
		ic77++;
		}
		if (fabs(ap) < RealZERO) {
		#if doubleintprecision == 1
			printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr77);
		#else
			printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr77);
		#endif
		
		system("PAUSE");
		//exit(1);
		}

		flag[Amat[ii77].i] = true;

		}
		}
		}
		*/

		//проверка конец

		

	}// иерархия сеток построена.

	ilevel--; // 4.01.2017
	if (n_a[ilevel] < 5) {
		// Чтобы не было последних уровней где меньше 5 узлов сетки.
		ilevel--;
	}

	// Вычисляем и запоминаем grid complexity
	// Операторная сложность.
	doublerealT dr_grid_complexity = (doublerealT)((((double)(1.0*iadd)) / ((double)(1.0*nnz_a[0]))));
	if (bprint_mesage_diagnostic) {
		printf("grid complexity is %1.2f\n", dr_grid_complexity);
		printf("Prolongation operator complexity is %1.2f %1.2f\n", (doublerealT)(nnz_P_memo_all / nnz_P_memo_0), (doublerealT)(nnz_P_memo_all / n_a[0]));
		doublereal sizegb = 16 * iadd / 1.0e9;
		printf("memory usage is %e Gb. reserved %e Gb. ratio is equal = %e\n", sizegb, 16 * nsizeA / 1.0e9, sizegb / (16 * nsizeA / 1.0e9));
	}

	if (bji) {
		delete[] Atemp;
		Atemp = nullptr;
	}

	// 31.224s [50.986] 2D m=81 debug x64 acumulqtor
	// 13.792 [18.156] 2D m=81 realese x64 acumulqtor
	// 8.028s 2D m=81 debug x64 rozetka
	// 3.827 2D m=81 realese x64 rozetka

#if doubleintprecision == 1
	if (bprint_mesage_diagnostic) {
		printf("ilevel=%lld\n", ilevel);
		// <= ilevel 4.01.2017
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%lld]=%lld nnz_a[%lld]=%lld nnz_a[%lld]/n_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], i_1, i_1, (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	}
#else
	if (bprint_mesage_diagnostic) {
		printf("ilevel=%d\n", ilevel);
		// <= ilevel 4.01.2017
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%d]=%d nnz_a[%d]=%d nnz_a[%d]/n_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1], i_1, i_1, (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	}
#endif
	
	if (debug_reshime) system("pause");
	//system("pause");
	//exit(1);

	if (bprint_mesage_diagnostic) {
		printf("memory optimization 13 november 2016.\n");
		printf("ierarhion matrix Amat...");
	}
	// Уменьшение памяти отводимой под хранение матрицы А.
	// Матрица должна занимать в памяти не более чем под неё нужно и не мегабайтом больше.
	if (Amat != nullptr) {
		Ak1* Amat_tmp = nullptr;
		Amat_tmp = (Ak1*)realloc(Amat, (iadd + 2) * sizeof(Ak1));
		if (Amat_tmp == nullptr) {
			printf("application crash for Amat. Please send message on email: kirill7785@mail.ru\n");
			system("pause");
			exit(1);
		}
		else {
			Amat = Amat_tmp;
			Amat_tmp = nullptr;
		}
	}
	
	if (bprint_mesage_diagnostic) {
		printf(" 1 of 3 compleated.  OK!! ierarhion matrix Amat realloc successfully...\n");
	}

	if (bprint_mesage_diagnostic) {
		printf("Prolongation ierarhion...\n");
	}
	if (P != nullptr) {
		Ak1* P_tmp = nullptr;
		P_tmp = (Ak1*)realloc(P, ((integer)(nnz_P_memo_all)+2) * sizeof(Ak1));
		if (P_tmp == nullptr) {
			printf("application crash for P. Please send message on email: kirill7785@mail.ru\n");
			system("pause");
			exit(1);
		}
		else {
			P = P_tmp;
			P_tmp = nullptr;
		}
	}
	
	if (bprint_mesage_diagnostic) {
		printf("2 of 3 compleated. OK!! ierarhion matrix Prolongation realloc successfully...\n");
	}

	if (bprint_mesage_diagnostic) {
		printf("Restriction ierarhion...\n");
	}
	if (R != nullptr) {
		Ak1* R_tmp = nullptr;
		R_tmp = (Ak1*)realloc(R, ((integer)(nnz_P_memo_all)+2) * sizeof(Ak1));
		if (R_tmp == nullptr) {
			printf("application crash for R. Please send message on email: kirill7785@mail.ru\n");
			system("pause");
			exit(1);
		}
		else {
			R = R_tmp;
			R_tmp = nullptr;
		}
	}
	
	if (bprint_mesage_diagnostic) {
		printf("3 of 3 compleated. OK!! ierarhion matrix Restriction realloc successfully...\n");
		printf("memory optimization successfully.\n");
	}

	/*
	//exporttecplot(b,n);

	doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

	// restriction
	restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
	for (integer ii = 1; ii <= n_a[0]; ii++) {
	b[ii] = 0.0;
	}

	{
	doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

	// restriction
	restriction(R, 1+nnz_aRP[0], nnz_aRP[0]+nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	for (integer ii = 1; ii <= n_a[1]; ii++) {
	test_coarse[ii] = 0.0;
	}

	{
	doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

	// restriction
	restriction(R, 1 + nnz_aRP[0]+nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1]+nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	for (integer ii = 1; ii <= n_a[2]; ii++) {
	test_coarse1[ii] = 0.0;
	}

	prolongation(P, 1 + nnz_aRP[0]+ nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	}

	prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	}

	prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

	exporttecplot(b, n);
	*/

	// подготовка матрицы к cycling:
	/*
	// smoother.
	// 1 september 2015.
	void seidel(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
	{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	doublerealT ap = 0.0;
	x[istr] = b[istr];
	while ((ic<=iend)&&(Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else ap = Amat[ic].aij;
	ic++;
	}
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld",istr);
	#else
		printf("zero diagonal elements in string %d",istr);
	#endif
	
	getchar();
	exit(1);
	}
	else {
	x[istr] /= ap;
	}
	flag[Amat[ii].i] = true;
	}
	}


	} // seidel


	*/

	/*
	// Т.к. деление очень медленное то мы поделим лишь один раз.
	doublerealT *diag0 = new doublerealT[n_a[0] + 1];
	doublerealT *diag1=nullptr;
	if (ilevel > 1) {
	diag1 = new doublerealT[n_a[1] + 1];
	}
	doublerealT *diag2=nullptr;
	if (ilevel > 2) {
	diag2 = new doublerealT[n_a[2] + 1];
	}
	doublerealT *diag3 = nullptr;
	if (ilevel > 3) {
	diag3 = new doublerealT[n_a[3] + 1];
	}
	doublerealT *diag4 = nullptr;
	if (ilevel > 4) {
	diag4 = new doublerealT[n_a[4] + 1];
	}
	doublerealT *diag5 = nullptr;
	if (ilevel > 5) {
	diag5 = new doublerealT[n_a[5] + 1];
	}
	doublerealT *diag6 = nullptr;
	if (ilevel > 6) {
	diag6 = new doublerealT[n_a[6] + 1];
	}
	doublerealT *diag7 = nullptr;
	if (ilevel > 7) {
	diag7 = new doublerealT[n_a[7] + 1];
	}
	doublerealT *diag8 = nullptr;
	if (ilevel > 8) {
	diag8 = new doublerealT[n_a[8] + 1];
	}
	doublerealT *diag9 = nullptr;
	if (ilevel > 9) {
	diag9 = new doublerealT[n_a[9] + 1];
	}
	doublerealT *diag10 = nullptr;
	if (ilevel > 10) {
	diag10 = new doublerealT[n_a[10] + 1];
	}
	doublerealT *diag11 = nullptr;
	if (ilevel > 11) {
	diag11 = new doublerealT[n_a[11] + 1];
	}
	doublerealT *diag12 = nullptr;
	if (ilevel > 12) {
	diag12 = new doublerealT[n_a[12] + 1];
	}
	doublerealT *diag13 = nullptr;
	if (ilevel > 13) {
	diag13 = new doublerealT[n_a[13] + 1];
	}
	doublerealT *diag14 = nullptr;
	if (ilevel > 14) {
	diag14 = new doublerealT[n_a[14] + 1];
	}
	doublerealT *diag15 = nullptr;
	if (ilevel > 15) {
	diag15 = new doublerealT[n_a[15] + 1];
	}
	doublerealT *diag16 = nullptr;
	if (ilevel > 16) {
	diag16 = new doublerealT[n_a[16] + 1];
	}
	*/

	// 4-5-6 30-31 dec 2016 Поддерживается не более 50 уровней вложенности
    //  5.06.2017 Поддерживается не более 100 уровней вложенности.
    // включительно.
	const integer idim_diag = 101;
	doublerealT **diag = nullptr;
	diag = new doublerealT*[idim_diag];
	if (diag == nullptr) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem: not enough memory on your equipment for diag my_gregat_amg.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	for (integer i_id_level_local = 0; i_id_level_local < idim_diag; i_id_level_local++) {
		diag[i_id_level_local] = nullptr; // инициализация.
		if (i_id_level_local == 0) {
			// Т.к. деление очень медленное то мы поделим лишь один раз.
			//doublerealT *diag0 = nullptr;
			//diag[0] = new doublerealT[n_a[0] + 1];
			diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
			handle_error<doublerealT>(diag[i_id_level_local], "diag[0]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
		}
		else if (i_id_level_local == 1) {
			//doublerealT *diag1 = nullptr;
			if (ilevel > i_id_level_local) {
				//diag[1] = new doublerealT[n_a[1] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[1]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 2) {
			//doublerealT *diag2 = nullptr;
			if (ilevel > i_id_level_local) {
				//diag[2] = new doublerealT[n_a[2] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[2]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 3) {
			//doublerealT *diag3 = nullptr;
			if (ilevel > i_id_level_local) {
				//diag[3] = new doublerealT[n_a[3] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[3]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 4) {
			//doublerealT *diag4 = nullptr;
			if (ilevel > i_id_level_local) {
				//diag[4] = new doublerealT[n_a[4] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[4]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 5) {
			//doublerealT *diag5 = nullptr;
			if (ilevel > i_id_level_local) {
				//diag[5] = new doublerealT[n_a[5] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[5]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 6) {
			//doublerealT *diag6 = nullptr;
			if (ilevel > i_id_level_local) {
				//diag[6] = new doublerealT[n_a[6] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[6]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 7) {
			//doublerealT *diag7 = nullptr;
			if (ilevel > i_id_level_local) {
				//diag[7] = new doublerealT[n_a[7] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[7]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 8) {
			//doublerealT *diag8 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[8] = new doublerealT[n_a[8] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[8]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 9) {
			//doublerealT *diag9 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[9] = new doublerealT[n_a[9] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[9]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 10) {
			//doublerealT *diag10 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[10] = new doublerealT[n_a[10] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[10]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 11) {
			//doublerealT *diag11 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[11] = new doublerealT[n_a[11] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[11]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 12) {
			//doublerealT *diag12 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[12] = new doublerealT[n_a[12] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[12]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 13) {
			//doublerealT *diag13 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[13] = new doublerealT[n_a[13] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[13]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 14) {
			//doublerealT *diag14 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[14] = new doublerealT[n_a[14] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[14]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 15) {
			//doublerealT *diag15 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[15] = new doublerealT[n_a[15] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[15]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 16) {
			//doublerealT *diag16 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[16] = new doublerealT[n_a[16] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[16]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 17) {
			//doublerealT *diag17 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[17] = new doublerealT[n_a[17] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[17]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 18) {
			//doublerealT *diag18 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[18] = new doublerealT[n_a[18] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[18]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 19) {
			//doublerealT *diag19 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[19] = new doublerealT[n_a[19] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[19]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 20) {
			//doublerealT *diag20 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[20] = new doublerealT[n_a[20] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[20]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 21) {
			//doublerealT *diag21 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[21] = new doublerealT[n_a[21] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[21]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 22) {
			//doublerealT *diag22 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[22] = new doublerealT[n_a[22] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[22]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 23) {
			//doublerealT *diag23 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[23] = new doublerealT[n_a[23] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[23]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 24) {
			//doublerealT *diag24 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[24] = new doublerealT[n_a[24] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[24]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 25) {
			//doublerealT *diag25 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[25] = new doublerealT[n_a[25] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[25]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 26) {
			//doublerealT *diag26 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[26] = new doublerealT[n_a[26] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[26]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 27) {
			//doublerealT *diag27 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[27] = new doublerealT[n_a[27] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[27]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 28) {
			//doublerealT *diag28 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[28] = new doublerealT[n_a[28] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[28]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 29) {
			//doublerealT *diag29 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[29] = new doublerealT[n_a[29] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[29]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 30) {
			//doublerealT *diag30 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[30] = new doublerealT[n_a[30] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[30]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 31) {
			//doublerealT *diag31 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[31] = new doublerealT[n_a[31] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[31]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 32) {
			//doublerealT *diag32 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[32] = new doublerealT[n_a[32] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[32]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 33) {
			//doublerealT *diag33 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[33] = new doublerealT[n_a[33] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[33]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 34) {
			//doublerealT *diag34 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[34] = new doublerealT[n_a[34] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[34]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 35) {
			//doublerealT *diag35 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[35] = new doublerealT[n_a[35] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[35]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 36) {
			//doublerealT *diag36 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[36] = new doublerealT[n_a[36] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[36]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 37) {
			//doublerealT *diag37 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[37] = new doublerealT[n_a[37] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[37]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 38) {
			//doublerealT *diag38 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[38] = new doublerealT[n_a[38] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[38]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 39) {
			//doublerealT *diag39 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[39] = new doublerealT[n_a[39] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[39]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 40) {
			//doublerealT *diag40 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[40] = new doublerealT[n_a[40] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[40]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 41) {
			//doublerealT *diag41 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[41] = new doublerealT[n_a[41] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[41]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 42) {
			//doublerealT *diag42 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[42] = new doublerealT[n_a[42] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[42]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 43) {
			//doublerealT *diag43 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[43] = new doublerealT[n_a[43] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[43]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 44) {
			//doublerealT *diag44 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[44] = new doublerealT[n_a[44] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[44]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 45) {
			//doublerealT *diag45 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[45] = new doublerealT[n_a[45] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[45]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 46) {
			//doublerealT *diag46 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[46] = new doublerealT[n_a[46] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[46]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 47) {
			//doublerealT *diag47 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[47] = new doublerealT[n_a[47] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[47]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 48) {
			//doublerealT *diag48 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[48] = new doublerealT[n_a[48] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[48]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 49) {
			//doublerealT *diag49 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[49] = new doublerealT[n_a[49] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[49]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 50) {
			//doublerealT *diag50 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[50] = new doublerealT[n_a[50] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[50]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 51) {
			//doublerealT *diag51 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[51] = new doublerealT[n_a[51] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[51]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 52) {
			//doublerealT *diag52 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[52] = new doublerealT[n_a[52] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[52]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 53) {
			//doublerealT *diag53 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[53] = new doublerealT[n_a[53] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[53]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 54) {
			//doublerealT *diag54 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[54] = new doublerealT[n_a[54] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[54]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 55) {
			//doublerealT *diag55 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[55] = new doublerealT[n_a[55] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[55]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 56) {
			//doublerealT *diag56 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[56] = new doublerealT[n_a[56] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[56]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 57) {
			//doublerealT *diag57 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[57] = new doublerealT[n_a[57] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[57]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 58) {
			//doublerealT *diag58 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[58] = new doublerealT[n_a[58] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[58]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 59) {
			//doublerealT *diag59 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[59] = new doublerealT[n_a[59] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[59]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 60) {
			//doublerealT *diag60 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[60] = new doublerealT[n_a[60] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[60]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 61) {
			//doublerealT *diag61 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[61] = new doublerealT[n_a[61] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[61]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 62) {
			//doublerealT *diag62 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[62] = new doublerealT[n_a[62] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[62]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 63) {
			//doublerealT *diag63 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[63] = new doublerealT[n_a[63] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[63]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 64) {
			//doublerealT *diag64 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[64] = new doublerealT[n_a[64] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[64]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 65) {
			//doublerealT *diag65 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[65] = new doublerealT[n_a[65] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[65]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 66) {
			//doublerealT *diag66 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[66] = new doublerealT[n_a[66] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[66]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 67) {
			//doublerealT *diag67 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[67] = new doublerealT[n_a[67] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[67]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 68) {
			//doublerealT *diag68 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[68] = new doublerealT[n_a[68] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[68]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 69) {
			//doublerealT *diag69 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[69] = new doublerealT[n_a[69] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[69]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 70) {
			//doublerealT *diag70 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[70] = new doublerealT[n_a[70] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[70]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 71) {
			//doublerealT *diag71 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[71] = new doublerealT[n_a[71] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[71]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 72) {
			//doublerealT *diag72 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[72] = new doublerealT[n_a[72] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[72]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 73) {
			//doublerealT *diag73 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[73] = new doublerealT[n_a[73] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[73]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 74) {
			//doublerealT *diag74 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[74] = new doublerealT[n_a[74] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[74]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 75) {
			//doublerealT *diag75 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[75] = new doublerealT[n_a[75] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[75]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 76) {
			//doublerealT *diag76 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[76] = new doublerealT[n_a[76] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[76]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 77) {
			//doublerealT *diag77 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[77] = new doublerealT[n_a[77] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[77]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		if (i_id_level_local == 78) {
			//doublerealT *diag78 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[78] = new doublerealT[n_a[78] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[78]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 79) {
			//doublerealT *diag79 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[79] = new doublerealT[n_a[79] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[79]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 80) {
			//doublerealT *diag80 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[80] = new doublerealT[n_a[80] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[80]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 81) {
			//doublerealT *diag81 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[81] = new doublerealT[n_a[81] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[81]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 82) {
			//doublerealT *diag82 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[82] = new doublerealT[n_a[82] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[82]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 83) {
			//doublerealT *diag83 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[83] = new doublerealT[n_a[83] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[83]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 84) {
			//doublerealT *diag84 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[84] = new doublerealT[n_a[84] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[84]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 85) {
			//doublerealT *diag85 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[85] = new doublerealT[n_a[85] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[85]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 86) {
			//doublerealT *diag86 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[86] = new doublerealT[n_a[86] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[86]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 87) {
			//doublerealT *diag87 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[87] = new doublerealT[n_a[87] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[87]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 88) {
			//doublerealT *diag88 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[88] = new doublerealT[n_a[88] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[88]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 89) {
			//doublerealT *diag89 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[89] = new doublerealT[n_a[89] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[89]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 90) {
			//doublerealT *diag90 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[90] = new doublerealT[n_a[90] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[90]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 91) {
			//doublerealT *diag91 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[91] = new doublerealT[n_a[91] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[91]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 92) {
			//doublerealT *diag92 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[92] = new doublerealT[n_a[92] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[92]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 93) {
			//doublerealT *diag93 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[93] = new doublerealT[n_a[93] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[93]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 94) {
			//doublerealT *diag94 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[94] = new doublerealT[n_a[94] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[94]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 95) {
			//doublerealT *diag95 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[95] = new doublerealT[n_a[95] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[95]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 96) {
			//doublerealT *diag96 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[96] = new doublerealT[n_a[96] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[96]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 97) {
			//doublerealT *diag97 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[97] = new doublerealT[n_a[97] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[97]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 98) {
			//doublerealT *diag98 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[98] = new doublerealT[n_a[98] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[98]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 99) {
			//doublerealT *diag99 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[99] = new doublerealT[n_a[99] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[99]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 100) {
			//doublerealT *diag100 = nullptr;
			if (ilevel > i_id_level_local) {
				// diag[100] = new doublerealT[n_a[100] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[100]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
	}


	bnested_desection_global_amg = nullptr;
	bool **nested_desection = nullptr;
	nested_desection = new bool*[idim_diag];
	if (nested_desection == nullptr) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem: not enough memory on your equipment for nested_desection my_gregat_amg.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	for (integer i_id_level_local = 0; i_id_level_local < idim_diag; i_id_level_local++) {
		nested_desection[i_id_level_local] = nullptr;
	}

	if (!bonly_serial) {
		// nested desection start
		bnested_desection_global_amg = (bool*)malloc((n_a[0] + 1) * sizeof(bool));
		handle_error<bool>(bnested_desection_global_amg, "bnested_desection_global_amg", "classic_aglomerative_amg_4", (n_a[0] + 1));


		nested_desection[0] = (bool*)malloc((n_a[0] + 1) * sizeof(bool));
		handle_error<bool>(nested_desection[0], "nested_desection[0]", "classic_aglomerative_amg_4", (n_a[0] + 1));


		if (ilevel > 1) {
			nested_desection[1] = (bool*)malloc((n_a[1] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[1], "nested_desection[1]", "classic_aglomerative_amg_4", (n_a[1] + 1));
		}

		if (ilevel > 2) {
			nested_desection[2] = (bool*)malloc((n_a[2] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[2], "nested_desection[2]", "classic_aglomerative_amg_4", (n_a[2] + 1));
		}

		if (ilevel > 3) {
			nested_desection[3] = (bool*)malloc((n_a[3] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[3], "nested_desection[3]", "classic_aglomerative_amg_4", (n_a[3] + 1));
		}

		if (ilevel > 4) {
			nested_desection[4] = (bool*)malloc((n_a[4] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[4], "nested_desection[4]", "classic_aglomerative_amg_4", (n_a[4] + 1));
		}

		if (ilevel > 5) {
			nested_desection[5] = (bool*)malloc((n_a[5] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[5], "nested_desection[5]", "classic_aglomerative_amg_4", (n_a[5] + 1));
		}

		if (ilevel > 6) {
			nested_desection[6] = (bool*)malloc((n_a[6] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[6], "nested_desection[6]", "classic_aglomerative_amg_4", (n_a[6] + 1));
		}

		if (ilevel > 7) {
			nested_desection[7] = (bool*)malloc((n_a[7] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[7], "nested_desection[7]", "classic_aglomerative_amg_4", (n_a[7] + 1));
		}

		if (ilevel > 8) {
			nested_desection[8] = (bool*)malloc((n_a[8] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[8], "nested_desection[8]", "classic_aglomerative_amg_4", (n_a[8] + 1));
		}

		if (ilevel > 9) {
			nested_desection[9] = (bool*)malloc((n_a[9] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[9], "nested_desection[9]", "classic_aglomerative_amg_4", (n_a[9] + 1));
		}

		if (ilevel > 10) {
			nested_desection[10] = (bool*)malloc((n_a[10] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[10], "nested_desection[10]", "classic_aglomerative_amg_4", (n_a[10] + 1));
		}

		if (ilevel > 11) {
			nested_desection[11] = (bool*)malloc((n_a[11] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[11], "nested_desection[11]", "classic_aglomerative_amg_4", (n_a[11] + 1));
		}

		if (ilevel > 12) {
			nested_desection[12] = (bool*)malloc((n_a[12] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[12], "nested_desection[12]", "classic_aglomerative_amg_4", (n_a[12] + 1));
		}

		if (ilevel > 13) {
			nested_desection[13] = (bool*)malloc((n_a[13] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[13], "nested_desection[13]", "classic_aglomerative_amg_4", (n_a[13] + 1));
		}

		if (ilevel > 14) {
			nested_desection[14] = (bool*)malloc((n_a[14] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[14], "nested_desection[14]", "classic_aglomerative_amg_4", (n_a[14] + 1));
		}

		if (ilevel > 15) {
			nested_desection[15] = (bool*)malloc((n_a[15] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[15], "nested_desection[15]", "classic_aglomerative_amg_4", (n_a[15] + 1));
		}

		if (ilevel > 16) {
			nested_desection[16] = (bool*)malloc((n_a[16] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[16], "nested_desection[16]", "classic_aglomerative_amg_4", (n_a[16] + 1));
		}

		if (ilevel > 17) {
			nested_desection[17] = (bool*)malloc((n_a[17] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[17], "nested_desection[17]", "classic_aglomerative_amg_4", (n_a[17] + 1));
		}

		if (ilevel > 18) {
			nested_desection[18] = (bool*)malloc((n_a[18] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[18], "nested_desection[18]", "classic_aglomerative_amg_4", (n_a[18] + 1));
		}
		if (ilevel > 19) {
			nested_desection[19] = (bool*)malloc((n_a[19] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[19], "nested_desection[19]", "classic_aglomerative_amg_4", (n_a[19] + 1));
		}
		if (ilevel > 20) {
			nested_desection[20] = (bool*)malloc((n_a[20] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[20], "nested_desection[20]", "classic_aglomerative_amg_4", (n_a[20] + 1));
		}
		if (ilevel > 21) {
			nested_desection[21] = (bool*)malloc((n_a[21] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[21], "nested_desection[21]", "classic_aglomerative_amg_4", (n_a[21] + 1));
		}
		if (ilevel > 22) {
			nested_desection[22] = (bool*)malloc((n_a[22] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[22], "nested_desection[22]", "classic_aglomerative_amg_4", (n_a[22] + 1));
		}
		if (ilevel > 23) {
			nested_desection[23] = (bool*)malloc((n_a[23] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[23], "nested_desection[23]", "classic_aglomerative_amg_4", (n_a[23] + 1));
		}
		if (ilevel > 24) {
			nested_desection[24] = (bool*)malloc((n_a[24] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[24], "nested_desection[24]", "classic_aglomerative_amg_4", (n_a[24] + 1));
		}
		if (ilevel > 25) {
			nested_desection[25] = (bool*)malloc((n_a[25] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[25], "nested_desection[25]", "classic_aglomerative_amg_4", (n_a[25] + 1));
		}
		if (ilevel > 26) {
			nested_desection[26] = (bool*)malloc((n_a[26] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[26], "nested_desection[26]", "classic_aglomerative_amg_4", (n_a[26] + 1));
		}
		if (ilevel > 27) {
			nested_desection[27] = (bool*)malloc((n_a[27] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[27], "nested_desection[27]", "classic_aglomerative_amg_4", (n_a[27] + 1));
		}
		if (ilevel > 28) {
			nested_desection[28] = (bool*)malloc((n_a[28] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[28], "nested_desection[28]", "classic_aglomerative_amg_4", (n_a[28] + 1));
		}
		if (ilevel > 29) {
			nested_desection[29] = (bool*)malloc((n_a[29] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[29], "nested_desection[29]", "classic_aglomerative_amg_4", (n_a[29] + 1));
		}
		if (ilevel > 30) {
			nested_desection[30] = (bool*)malloc((n_a[30] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[30], "nested_desection[30]", "classic_aglomerative_amg_4", (n_a[30] + 1));
		}
		if (ilevel > 31) {
			nested_desection[31] = (bool*)malloc((n_a[31] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[31], "nested_desection[31]", "classic_aglomerative_amg_4", (n_a[31] + 1));
		}
		if (ilevel > 32) {
			nested_desection[32] = (bool*)malloc((n_a[32] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[32], "nested_desection[32]", "classic_aglomerative_amg_4", (n_a[32] + 1));
		}
		if (ilevel > 33) {
			nested_desection[33] = (bool*)malloc((n_a[33] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[33], "nested_desection[33]", "classic_aglomerative_amg_4", (n_a[33] + 1));
		}
		if (ilevel > 34) {
			nested_desection[34] = (bool*)malloc((n_a[34] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[34], "nested_desection[34]", "classic_aglomerative_amg_4", (n_a[34] + 1));
		}
		if (ilevel > 35) {
			nested_desection[35] = (bool*)malloc((n_a[35] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[35], "nested_desection[35]", "classic_aglomerative_amg_4", (n_a[35] + 1));
		}
		if (ilevel > 36) {
			nested_desection[36] = (bool*)malloc((n_a[36] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[36], "nested_desection[36]", "classic_aglomerative_amg_4", (n_a[36] + 1));
		}
		if (ilevel > 37) {
			nested_desection[37] = (bool*)malloc((n_a[37] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[37], "nested_desection[37]", "classic_aglomerative_amg_4", (n_a[37] + 1));
		}
		if (ilevel > 38) {
			nested_desection[38] = (bool*)malloc((n_a[38] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[38], "nested_desection[38]", "classic_aglomerative_amg_4", (n_a[38] + 1));
		}
		if (ilevel > 39) {
			nested_desection[39] = (bool*)malloc((n_a[39] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[39], "nested_desection[39]", "classic_aglomerative_amg_4", (n_a[39] + 1));
		}
		if (ilevel > 40) {
			nested_desection[40] = (bool*)malloc((n_a[40] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[40], "nested_desection[40]", "classic_aglomerative_amg_4", (n_a[40] + 1));
		}
		if (ilevel > 41) {
			nested_desection[41] = (bool*)malloc((n_a[41] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[41], "nested_desection[41]", "classic_aglomerative_amg_4", (n_a[41] + 1));
		}
		if (ilevel > 42) {
			nested_desection[42] = (bool*)malloc((n_a[42] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[42], "nested_desection[42]", "classic_aglomerative_amg_4", (n_a[42] + 1));
		}
		if (ilevel > 43) {
			nested_desection[43] = (bool*)malloc((n_a[43] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[43], "nested_desection[43]", "classic_aglomerative_amg_4", (n_a[43] + 1));
		}
		if (ilevel > 44) {
			nested_desection[44] = (bool*)malloc((n_a[44] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[44], "nested_desection[44]", "classic_aglomerative_amg_4", (n_a[44] + 1));
		}
		if (ilevel > 45) {
			nested_desection[45] = (bool*)malloc((n_a[45] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[45], "nested_desection[45]", "classic_aglomerative_amg_4", (n_a[45] + 1));
		}
		if (ilevel > 46) {
			nested_desection[46] = (bool*)malloc((n_a[46] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[46], "nested_desection[46]", "classic_aglomerative_amg_4", (n_a[46] + 1));
		}
		if (ilevel > 47) {
			nested_desection[47] = (bool*)malloc((n_a[47] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[47], "nested_desection[47]", "classic_aglomerative_amg_4", (n_a[47] + 1));
		}
		if (ilevel > 48) {
			nested_desection[48] = (bool*)malloc((n_a[48] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[48], "nested_desection[48]", "classic_aglomerative_amg_4", (n_a[48] + 1));
		}
		if (ilevel > 49) {
			nested_desection[49] = (bool*)malloc((n_a[49] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[49], "nested_desection[49]", "classic_aglomerative_amg_4", (n_a[49] + 1));
		}
		if (ilevel > 50) {
			nested_desection[50] = (bool*)malloc((n_a[50] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[50], "nested_desection[50]", "classic_aglomerative_amg_4", (n_a[50] + 1));
		}
	
		//idim_diag==101
		for (integer i_17 = 51; i_17 <= idim_diag-1; i_17++) {
			if (ilevel > i_17) {
				nested_desection[i_17] = (bool*)malloc((n_a[i_17] + 1) * sizeof(bool));
				handle_error<bool>(nested_desection[i_17], "nested_desection[i_17]", "classic_aglomerative_amg_4", (n_a[i_17] + 1));
			}
		}

	}
	// nested_desection_end

	integer *row_ptr_start = nullptr;
	const integer isize_row_ptr = 4 * n_a[0] + 1;
	//row_ptr_start = new integer[4 * n_a[0] + 1];
	row_ptr_start = (integer*)malloc((isize_row_ptr) * sizeof(integer));
	handle_error<integer>(row_ptr_start, " row_ptr_start", "classic_aglomerative_amg_4", (isize_row_ptr));

	integer *row_ptr_end = nullptr;
	//row_ptr_end = new integer[4 * n_a[0] + 1];
	row_ptr_end = (integer*)malloc((isize_row_ptr) * sizeof(integer));
	handle_error<integer>(row_ptr_end, " row_ptr_end", "classic_aglomerative_amg_4", (isize_row_ptr));

	// ILU2
	LEVEL_ADDITIONAL_DATA* milu2 = nullptr;
	// инициализация.
	init_level_additional_data(milu2, ilevel);

	// ILU0
	LEVEL_ADDITIONAL_DATA0* milu0 = nullptr;
	// инициализация.
	init_level_additional_data(milu0, ilevel);

	// Освобождение общей памяти в ILU буффере.
	if (milu_gl_buffer.alu_copy != nullptr) delete[] milu_gl_buffer.alu_copy;
	if (milu_gl_buffer.jlu_copy != nullptr) delete[] milu_gl_buffer.jlu_copy;
	if (milu_gl_buffer.ju_copy != nullptr) delete[] milu_gl_buffer.ju_copy;
	milu_gl_buffer.alu_copy = nullptr;
	milu_gl_buffer.jlu_copy = nullptr;
	milu_gl_buffer.ju_copy = nullptr;

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
#pragma omp parallel for
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = 1; ii <= nnz_a[0]; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			integer icdiag = ii;
			if (istr >= isize_row_ptr) {
#if doubleintprecision == 1
				printf("need to increase isize_row_ptr %lld", istr);
#else
				printf("need to increase isize_row_ptr %d", istr);
#endif
				
				//getchar();
				system("PAUSE");
				exit(1);
			}
			row_ptr_start[istr] = ii;
			doublerealT ap = 0.0; // значение на диагонали.
								 //x[istr] = b[istr];
			while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					// Все внедиагональные элементы должны быть строго отрицательны.
					// Если это не так то надо выдавать предупреждение о логической ошибке пользователю.
					if (Amat[ic].aij >= 0.0) {
#if doubleintprecision == 1
						//printf("polochitelnji vnediagonalnj element %e in matrix level 0 in string %lld...\n", Amat[ic].aij, istr);
#else
						//printf("polochitelnji vnediagonalnj element %e in matrix level 0 in string %d...\n", Amat[ic].aij, istr);
#endif
						
						// Вдруг это не страшно 26 октября 2016.
						// Ну да на задача с конвекцией встречается даже и на нулевом уровне вложенности.
						//system("PAUSE");
					}
				}
				else {
					// дмагональный элемент строго положителен.
					ap = Amat[ic].aij;
					icdiag = ic;
				}
				ic++;
			}
			if (istr >= isize_row_ptr) {
#if doubleintprecision == 1
				printf("need to increase isize_row_ptr %lld", istr);
#else
				printf("need to increase isize_row_ptr %d", istr);
#endif
				
				//getchar();
				system("PAUSE");
				exit(1);
			}
			row_ptr_end[istr] = ic - 1;
			if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld in basic matrix", istr);
#else
				printf("zero diagonal elements in string %d in basic matrix", istr);
#endif
				
				system("PAUSE");
				exit(1);
			}
			else {
				//x[istr] /= ap;
			}

			flag[Amat[ii].i] = true;
			Ak1 temp = Amat[ii];
			Amat[ii] = Amat[icdiag];
			Amat[icdiag] = temp;
			if (bmemory_savings) {
				// По исходному номеру получаем текущий,
				// но теперь два текущих поменялись.
				the_original_order_of_values[the_original_order_of_values_reverse[ii]] = icdiag;
				the_original_order_of_values[the_original_order_of_values_reverse[icdiag]] = ii;
			}

			diag[0][Amat[ii].i] = ap; // для ускорения вычисления невязки.
			Amat[ii].aij = (real_mix_precision)(1.0 / ap); // умножение быстрей деления.
		}
	}

	if (bILU2smoother == 2) {
		// ILU2
		printf("apply ilu0 smoother for number 0 level\n");
		equation3DtoCRSRUMBA1(milu2[0], true, Amat, 1, n_a[0], row_ptr_start, row_ptr_end, 0, 0);
	}
	else if (bILU2smoother == 1) {
		// ILU0
		printf("apply ilu0 smoother for number 0 level\n");
		equation3DtoCRSRUMBA0(milu0[0], true, Amat, 1, n_a[0], row_ptr_start, row_ptr_end, 0, 0);
	}
	else if (my_amg_manager.iFinnest_ilu == 1) {
		// ILU0 но только на самой подробной сетке.
		printf("apply ilu0 smoother for number 0 level\n");
		equation3DtoCRSRUMBA1(milu2[0], true, Amat, 1, n_a[0], row_ptr_start, row_ptr_end, 0, 0);
	}
	bool bstop = false;


	// 14 сентября 2015 понедельник четвёртый уровень вложенности.
	// Уровни вложенности с первого по седьмой сразу. 12.07.2016.

	// Заголовок 29.10.2016.
	if (bprint_mesage_diagnostic) {
		printf("1. positive connections %%, 2. max positive/ diagonal %%\n");
	}

	for (integer ilevel_detector = 1; ilevel_detector <= idim_diag - 1; ilevel_detector++) {

		// Обработка матрицы действует до 99 уровня включительно, но
		// сбор статистики желательно сделать для всех уровней.
		const integer istop_level_scan = idim_diag - 2;

		if (ilevel > ilevel_detector) {

			doublerealT inum_vnediagonal_all = 0.0;
			doublerealT inum_only_positive_vnediagonal = 0.0;
			doublerealT memo_diagonal_element = 0.0;
			doublerealT max_positive_connections_element = -1.0;
			doublerealT ratio_positive_connections_by_diagonalelement = -1.0;
			doublerealT ratio_positive_connections_by_diagonalelement_avg = 0.0;
			bool b_ne_menee_2_positive_con_in_string = false;
			doublerealT inum_only_positive_vnediagonal_ne_menee2_in_string = 0.0;

			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}
			integer ist = 1;
			for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
				ist += nnz_a[ilev];
			}
			integer iend = 0;
			for (integer ilev = 0; ilev <= ilevel_detector; ilev++) {
				iend += nnz_a[ilev];
			}
			integer istPR = 1;
			for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
				istPR += nnz_aRP[ilev];
			}
			integer iendPR = 0;
			for (integer ilev = 0; ilev <= ilevel_detector; ilev++) {
				iendPR += nnz_aRP[ilev];
			}
			double dn_num = 0.0;
			for (integer ii = ist; ii <= iend; ii++) {
				if (flag[Amat[ii].i] == false) {

					integer istr = Amat[ii].i;
					integer ic = ii;
					integer icdiag = ii;
					integer istart_row_ptr = istr;
					for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
						istart_row_ptr += n_a[ilev];
					}

					

					max_positive_connections_element = -1.0;
					dn_num += 1.0;

					bool b_bad_string = false;
					max_positive_connections_element = -1.0;
					
					
					if (istart_row_ptr >= isize_row_ptr) {
#if doubleintprecision == 1
						printf("need to increase isize_row_ptr %lld", istart_row_ptr);
#else
						printf("need to increase isize_row_ptr %d", istart_row_ptr);
#endif
						
						//getchar();
						system("PAUSE");
						exit(1);
					}
					if (ilevel_detector <= istop_level_scan) {
						row_ptr_start[istart_row_ptr] = ii;
					}
					doublerealT ap = 0.0;
					doublerealT sum_4 = 0.0;
					
					


					const doublerealT theta7 = theta; // передаётся в функцию извне.
					b_ne_menee_2_positive_con_in_string = false;
					integer inum_pos_con_in_string = 0;
					doublerealT threshold7 = -1.0;
					integer ic7 = ic;
					while ((ic7 <= iend) && (Amat[ic7].i == istr)) {
						if (Amat[ic7].j != istr) {
							if (Amat[ic7].aij >= 0.0) {
								inum_pos_con_in_string++;
								if (fabs(Amat[ic7].aij) > threshold7) threshold7 = fabs(Amat[ic7].aij);
							}
						}
						ic7++;
					}
					// мы обнаружили не менее двух положительных связей в данной строке.
					if (inum_pos_con_in_string >= 2) {
						inum_pos_con_in_string = 0;
						ic7 = ic;
						while ((ic7 <= iend) && (Amat[ic7].i == istr)) {
							if (Amat[ic7].j != istr) {
								if ((Amat[ic7].aij >= 0.0) && (fabs(Amat[ic7].aij) >= theta7*threshold7)) {
									inum_pos_con_in_string++;
								}
							}
							ic7++;
						}

						if (inum_pos_con_in_string >= 2) {
							b_ne_menee_2_positive_con_in_string = true;
						}
					}

					
						//x[istr] = b[istr];
					while ((ic <= iend) && (Amat[ic].i == istr)) {
						if (Amat[ic].j != istr) {
							//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
							inum_vnediagonal_all += 1.0;
							// Все внедиагональные элементы должны быть строго отрицательны.
							// Если это не так то надо выдавать предупреждение о логической ошибке пользователю.
							if (Amat[ic].aij >= 0.0) {
#if doubleintprecision == 1
								//printf("polochitelnji vnediagonalnj element %e in matrix level %lld in string %lld...\n", Amat[ic].aij, ilevel_detector, istr);
#else
								//printf("polochitelnji vnediagonalnj element %e in matrix level %d in string %d...\n", Amat[ic].aij, ilevel_detector, istr);
#endif
								//system("PAUSE");
								inum_only_positive_vnediagonal += 1.0;

								if (b_ne_menee_2_positive_con_in_string) {
									if (fabs(Amat[ic7].aij) >= theta7*threshold7) {
										inum_only_positive_vnediagonal_ne_menee2_in_string += 1.0;
									}
								}

								// Определение величины максимальной внедиагональной связи.
								if (max_positive_connections_element < Amat[ic].aij) {
									max_positive_connections_element = Amat[ic].aij;
								}
							}
						}
						else {
							ap = Amat[ic].aij;
							memo_diagonal_element = ap;
							icdiag = ic;
							if (ap < 1.0e-20) {
								b_bad_string = true;
								// прекращаем строить иерархию уровней.
								bcontinue_global = false;
								//goto BAD_STRING_MARKER;
								printf("FATAL ERROR !!! amg4 function string 60806");
								system("PAUSE");
								exit(1);
								integer ic_4 = ii;
								printf("bad string:\n");

								while ((ic_4 <= iend) && (Amat[ic_4].i == istr)) {
									if (Amat[ic_4].j != istr) {
										sum_4 += fabs(Amat[ic_4].aij);
									}
									printf("%e ", Amat[ic_4].aij);
									ic_4++;
								}
								printf("\n");
								ic_4 = ii;
#if doubleintprecision == 1
								printf("i==%lld\n", istr);
								while ((ic_4 <= iend) && (Amat[ic_4].i == istr)) {
									printf("%d ", Amat[ic_4].j);
									ic_4++;
								}
#else
								printf("i==%d\n", istr);
								while ((ic_4 <= iend) && (Amat[ic_4].i == istr)) {
									printf("%d ", Amat[ic_4].j);
									ic_4++;
								}
#endif

								printf("\n");
								printf("sum_4=%e\n", sum_4);




								system("pause");
							}
						}
						ic++;
					}

					if (b_bad_string) {

						integer ic_4 = ii;
#if doubleintprecision == 1
						printf("cure line %lld:\n", istr);
#else
						printf("cure line %d:\n", istr);
#endif

						// прекращаем строить иерархию уровней.
						bcontinue_global = false;
						//goto BAD_STRING_MARKER;
						printf("FATAL ERROR !!! amg4 function string 60859");
						system("PAUSE");
						exit(1);

						while ((ic_4 <= iend) && (Amat[ic_4].i == istr)) {
							if (Amat[ic_4].j != istr) {
								//sum_4 += fabs(Amat[ic_4].aij);
								Amat[ic_4].aij = 0.0;
							}
							//printf("%e ", Amat[ic_4].aij);
							ic_4++;
						}
						for (integer ii_5 = istPR; ii_5 <= iendPR; ii_5++) {
							if (P[ii_5].i == istr) {
								if (P[ii_5].j == istr) {
									P[ii_5].aij = 1.0;
								}
								else {
									P[ii_5].aij = 0.0;
								}
							}
							if (R[ii_5].i == istr) {
								if (R[ii_5].j == istr) {
									R[ii_5].aij = 1.0;
								}
								else {
									R[ii_5].aij = 0.0;
								}
							}
						}

						// лечим строку, хотя возможно проблема истинная проблема сидит гораздо выше по коду.
						// Делаем очень сильное диагональное преобладание в этой дефектной строке.
						sum_4 = 1.0;
						Amat[icdiag].aij = sum_4;
						memo_diagonal_element = sum_4;
						ap = sum_4;

						// лечим строку, хотя возможно проблема истинная проблема сидит гораздо выше по коду.
						/*
						ic_4 = ii;
						while ((ic_4 <= iend) && (Amat[ic_4].i == istr)) {
						if (Amat[ic_4].j != istr) {
						//sum_4 += fabs(Amat[ic_4].aij);
						Amat[ic_4].aij = 0.0;
						}
						//printf("%e ", Amat[ic_4].aij);
						ic_4++;
						}
						*/

						//Amat[icdiag].aij = 1.0;
						//memo_diagonal_element = 1.0;
						//ap = 1.0;
					}
					

					if (istart_row_ptr >= isize_row_ptr) {
#if doubleintprecision == 1
						printf("need to increase isize_row_ptr %lld", istart_row_ptr);
#else
						printf("need to increase isize_row_ptr %d", istart_row_ptr);
#endif

						//getchar();
						system("PAUSE");
						exit(1);
					}
					if (ilevel_detector <= istop_level_scan) {
						row_ptr_end[istart_row_ptr] = ic - 1;
					}
					if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
						printf("zero diagonal elements in string %lld in level %lld matrix", istr, ilevel);
#else
						printf("zero diagonal elements in string %d in level %d matrix", istr, ilevel);
#endif

						system("PAUSE");
						exit(1);
					}
					else {
						//x[istr] /= ap;
					}
					

					ratio_positive_connections_by_diagonalelement_avg += fabs(max_positive_connections_element / memo_diagonal_element);
					if (ratio_positive_connections_by_diagonalelement < fabs(max_positive_connections_element / memo_diagonal_element)) {
						ratio_positive_connections_by_diagonalelement = fabs(max_positive_connections_element / memo_diagonal_element);
					}
					flag[Amat[ii].i] = true;
					if (ilevel_detector <= istop_level_scan) {
						Ak1 temp = Amat[ii];
						Amat[ii] = Amat[icdiag];
						Amat[icdiag] = temp;
						switch (ilevel_detector) {
						case 1: diag[1][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 2: diag[2][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 3: diag[3][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 4: diag[4][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 5: diag[5][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 6: diag[6][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 7: diag[7][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 8: diag[8][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 9: diag[9][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 10: diag[10][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 11: diag[11][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 12: diag[12][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 13: diag[13][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 14: diag[14][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 15: diag[15][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 16: diag[16][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 17: diag[17][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 18: diag[18][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 19: diag[19][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 20: diag[20][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 21: diag[21][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 22: diag[22][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 23: diag[23][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 24: diag[24][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 25: diag[25][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 26: diag[26][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 27: diag[27][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 28: diag[28][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 29: diag[29][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 30: diag[30][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 31: diag[31][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 32: diag[32][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 33: diag[33][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 34: diag[34][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 35: diag[35][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 36: diag[36][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 37: diag[37][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 38: diag[38][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 39: diag[39][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 40: diag[40][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 41: diag[41][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 42: diag[42][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 43: diag[43][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 44: diag[44][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 45: diag[45][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 46: diag[46][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 47: diag[47][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 48: diag[48][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 49: diag[49][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 50: diag[50][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 51: diag[51][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 52: diag[52][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 53: diag[53][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 54: diag[54][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 55: diag[55][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 56: diag[56][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 57: diag[57][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 58: diag[58][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 59: diag[59][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 60: diag[60][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 61: diag[61][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 62: diag[62][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 63: diag[63][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 64: diag[64][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 65: diag[65][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 66: diag[66][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 67: diag[67][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 68: diag[68][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 69: diag[69][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 70: diag[70][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 71: diag[71][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 72: diag[72][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 73: diag[73][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 74: diag[74][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 75: diag[75][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 76: diag[76][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 77: diag[77][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 78: diag[78][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 79: diag[79][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 80: diag[80][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 81: diag[81][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 82: diag[82][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 83: diag[83][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 84: diag[84][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 85: diag[85][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 86: diag[86][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 87: diag[87][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 88: diag[88][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 89: diag[89][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 90: diag[90][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 91: diag[91][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 92: diag[92][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 93: diag[93][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 94: diag[94][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 95: diag[95][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 96: diag[96][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 97: diag[97][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 98: diag[98][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 99: diag[99][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 100: diag[100][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						default: printf("ilevel_detector incorrect\n");
							//getchar();
							system("PAUSE");
							break;
						}

						Amat[ii].aij = (real_mix_precision)(1.0 / ap); // умножение быстрей деления.
					}


				}
			}

			integer iadd_now = 0;
			for (integer i54 = 1; i54 <= ilevel_detector; i54++) {
				iadd_now += n_a[i54 - 1];
			}
			if (ilevel_detector <= istop_level_scan) {
				if (bILU2smoother == 2) {
#if doubleintprecision == 1
					printf("apply ilu0 smoother for number %lld level\n", ilevel_detector);
#else
					printf("apply ilu0 smoother for number %d level\n", ilevel_detector);
#endif
					
					equation3DtoCRSRUMBA1(milu2[ilevel_detector], true,
						Amat, 1, n_a[ilevel_detector], row_ptr_start, row_ptr_end, iadd_now, ilevel_detector);
				}
			}
			if (ilevel_detector <= istop_level_scan) {
				if (bILU2smoother == 1) {
#if doubleintprecision == 1
					// ILU0
					printf("apply ilu0 smoother for number %lld level\n", ilevel_detector);
#else
					// ILU0
					printf("apply ilu0 smoother for number %d level\n", ilevel_detector);
#endif
					
					// iadd_now=n_a[0]+...+n_a[ilevel_detector-1];
					equation3DtoCRSRUMBA0(milu0[ilevel_detector], true,
						Amat, 1, n_a[ilevel_detector], row_ptr_start, row_ptr_end, iadd_now, ilevel_detector);
				}
			}
			if (ilevel_detector <= istop_level_scan) {
				if (my_amg_manager.iFinnest_ilu == 1) {
					if (my_amg_manager.b_ilu_smoothers_in_nnz_n_LE_6) {
						doublerealT dn = (doublerealT)(1.0*n_a[ilevel_detector]);
						doublerealT dnnz = (doublerealT)(1.0*nnz_a[ilevel_detector]);
						if (dnnz / dn <= dapply_ilu_max_pattern_size) {
							// маленький (компактный) шаблон.
#if doubleintprecision == 1
							printf("apply ilu0 smoother for number %lld level\n", ilevel_detector);
#else
							printf("apply ilu0 smoother for number %d level\n", ilevel_detector);
#endif
							
							equation3DtoCRSRUMBA1(milu2[ilevel_detector], true,
								Amat, 1, n_a[ilevel_detector], row_ptr_start, row_ptr_end, iadd_now, ilevel_detector);
						}
					}
				}
			}


			// statistic log:
			if (bprint_mesage_diagnostic) {
				//printf("procent positive connections %e \n", 100.0*inum_only_positive_vnediagonal / inum_vnediagonal_all);
				//printf("the ratio of the maximum positive connections to the diagonal\n");
				//printf("element in the row, in procent %e\n", 100.0*ratio_positive_connections_by_diagonalelement);
				//printf("\n");
#if doubleintprecision == 1
				printf("%lld %2.1f %% [ %2.2f %% ] %3.1f  [%2.2f ]\n", ilevel_detector, 1.00*inum_only_positive_vnediagonal / inum_vnediagonal_all, 100 * inum_only_positive_vnediagonal_ne_menee2_in_string / inum_vnediagonal_all, 1e-4*ratio_positive_connections_by_diagonalelement, 1e-4*ratio_positive_connections_by_diagonalelement_avg / dn_num);

#else
				printf("%d %2.1f %% [ %2.2f %% ] %3.1f  [%2.2f ]\n", ilevel_detector, 1.00*inum_only_positive_vnediagonal / inum_vnediagonal_all, 100 * inum_only_positive_vnediagonal_ne_menee2_in_string / inum_vnediagonal_all, 1e-4*ratio_positive_connections_by_diagonalelement, 1e-4*ratio_positive_connections_by_diagonalelement_avg / dn_num);

#endif
							}
		}


	}


	


	if (bstop) exit(1);
	if (bILU2smoother > 0) {
		// Пауза только в случае применения ILU декомпозиции.
		//system("PAUSE");
		if (bILU2smoother == 2) {
			// Осторожно возможно код быстро устареет.
			// Выделение оперативной памяти под централизованное хранилище 
			// для ILU.
			memory_allocation_apostoriory_buffer_ilu(milu2, ilevel - 1);
			//memory_allocation_apostoriory_buffer_ilu(milu2, ilevel-1);// 4.01.2017
		}
	}
	else if (my_amg_manager.iFinnest_ilu == 1) {
		// ILU0 но только на самой подробной сетке.
		memory_allocation_apostoriory_buffer_ilu(milu2, ilevel - 1); // 7.06.2017.
	}


	// закомментировАННЫЙ КОД ОТНОСИТСЯ К УСТАРЕВШЕМУ. 
	// 4 ноября 2016 прописано 15 уровней вложенности.
	// восьмой уровень вложенности.
	/*
	if (ilevel > 8) {
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + 1;
	integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
	for (integer ii = ist; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	integer icdiag = ii;
	row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ii;
	doublerealT ap = 0.0;
	//x[istr] = b[istr];
	while ((ic <= iend) && (Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else {
	ap = Amat[ic].aij;
	icdiag = ic;
	}
	ic++;
	}
	row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ic - 1;
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld in level 7 matrix", istr);
	#else
		printf("zero diagonal elements in string %d in level 7 matrix", istr);
	#endif
	
	system("PAUSE");
	exit(1);
	}
	else {
	//x[istr] /= ap;
	}

	flag[Amat[ii].i] = true;
	Ak1 temp = Amat[ii];
	Amat[ii] = Amat[icdiag];
	Amat[icdiag] = temp;
	diag[8][Amat[ii].i] = ap; // для ускорения вычисления невязки.
	Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
	}
	}
	}
	*/


	if (!bonly_serial) {
		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 0.
		// nested_desection[0]
		nested_desection_patch(Amat, n_a[0], nested_desection[0], row_ptr_start, row_ptr_end, 0);
		if (bprint_mesage_diagnostic) {
			printf("part1\n");
		}


		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 1.
		// nested_desection[1]
		if (ilevel > 1) {
			nested_desection_patch(Amat, n_a[1], nested_desection[1], row_ptr_start, row_ptr_end, n_a[0]);
			if (bprint_mesage_diagnostic) {
				printf("part2\n");
			}
		}
		if (ilevel > 2) {
			nested_desection_patch(Amat, n_a[2], nested_desection[2], row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
			if (bprint_mesage_diagnostic) {
				printf("part3\n");
			}
		}
		if (ilevel > 3) {
			nested_desection_patch(Amat, n_a[3], nested_desection[3], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
			if (bprint_mesage_diagnostic) {
				printf("part4\n");
			}
		}
		if (ilevel > 4) {
			nested_desection_patch(Amat, n_a[4], nested_desection[4], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
			if (bprint_mesage_diagnostic) {
				printf("part5\n");
			}
		}
		if (ilevel > 5) {
			nested_desection_patch(Amat, n_a[5], nested_desection[5], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
			if (bprint_mesage_diagnostic) {
				printf("part6\n");
			}
		}
		if (ilevel > 6) {
			nested_desection_patch(Amat, n_a[6], nested_desection[6], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
			if (bprint_mesage_diagnostic) {
				printf("part7\n");
			}
		}
		if (ilevel > 7) {
			nested_desection_patch(Amat, n_a[7], nested_desection[7], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
			if (bprint_mesage_diagnostic) {
				printf("part8 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 8) {
			nested_desection_patch(Amat, n_a[8], nested_desection[8], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
			if (bprint_mesage_diagnostic) {
				printf("part9 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 9) {
			nested_desection_patch(Amat, n_a[9], nested_desection[9], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
			if (bprint_mesage_diagnostic) {
				printf("part10 \n");
				printf("nested desection is finish\n");
			}
		}
		
		// idim_diag==101
		for (integer i_17 = 10; i_17 <= idim_diag - 1; i_17++) {
			if (ilevel > i_17) {
				integer inasum = 0;
				for (integer i_18 = 0; i_18 < i_17; i_18++) inasum += n_a[i_18];
				nested_desection_patch(Amat, n_a[i_17], nested_desection[i_17], row_ptr_start, row_ptr_end, inasum);
				if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
					printf("part%lld \n", i_17);
#else
					printf("part%d \n", i_17);
#endif
					
					printf("nested desection is finish\n");
				}
			}
		}


	}


	// smoother.
	// 9 september 2015.
	// q - quick.
	// seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
	//void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
	//{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	//integer startpos = istartq + iadd;
	//integer endpos = iendq+iadd;
	//for (integer ii = startpos; ii <= endpos; ii++) {
	//integer istr = ii - iadd;
	//x[istr] = b[istr];
	//for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
	//{
	//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
	//}
	//x[istr] *= Amat[row_ptr_start[ii]].aij;
	//}


	//} // seidelq

	// Освобождение памяти используемой на этапе построения иерархии матриц.

	//delete[] this_is_C_node;
	//delete[] this_is_F_node;
	if (this_is_C_node!=nullptr) {
	   free(this_is_C_node);
	   this_is_C_node=nullptr;
	}
	if (this_is_F_node!=nullptr) {
	   free(this_is_F_node);
	   this_is_F_node=nullptr;
	}
	//delete[] hash_table;
	if (hash_table != nullptr) {
		free(hash_table);
		hash_table = nullptr;
	}
	if (hash_table2 != nullptr) {
		free(hash_table2);
		hash_table2 = nullptr;
	}
	//delete[] istack;
	//delete[] istack2;
	if (istack != nullptr) {
		free(istack);
		istack = nullptr;
	}
	if (istack2 != nullptr) {
		free(istack2);
		istack2 = nullptr;
	}


	if (bprint_mesage_diagnostic) {
		printf("cycling: V cycle.\n");
#if doubleintprecision == 1
		printf("level=%lld\n", ilevel);
#else
		printf("level=%d\n", ilevel);
#endif
		
		printf("multigrid R.P.Fedorenko 1961.\n");
		printf("standart aglomerative algebraic multigrid method.\n");
	}
	if (debug_reshime) system("pause");
	//exit(1);

	// 10 11 21 multigrid tutorial Вильм Бригг.
	// Высокорейнольдсовое обтекание квадрата в DavisTest,
	// решатель работал на x-компоненте скорости. Сетка сгущалась
	// к поверхности квадрата достаточно сильно. Это дало расходимость
	// amg v0.08 решателя на данной задаче с параметрами nu1=4, nu2=3.
	// Параметры nu1=8, nu2=7 обеспечили сходимость вычислительного процесса.

	// Возможно имеет смысл сделать управляемый выход из сглаживателя, допустим
	// если невязка опустилась ниже первоначальной в 0.1 раз то имеет смысл досрочно 
	// оборвать итерации сглаживателя.


	// nu1=0; nu2=2; nFinestSweeps=2 is recomended 
	// Masashi Imano. Optimization of parameter setting for GAMG
	// solver in simple solver. 
	// Aug 26th 2012. OpeanFOAM study. 
	// nu1=0 имеем расходимость на BSK Dmitrii.
	// nFinestSweeps=2 имеем расходимость на BSK Dmitrii.
	// BSK Dmitrii сходится при nu1=1, nu2=2, nFinestSweeps=3.

	integer nu1 = 1; // minimum value 1 // 4 // 8
	integer nu2 = 2; // minimum value 2 // 3 // 7

					 // на задаче Finned Heat Sync из первого туториала Icepak была обнаружена расходимость 
					 // для Y скорости и поправки давления. При этом обтекание куба отлично считалось на равномерной
					 // сетки с nu1=1, nu2=2 даже при весьма больших числах Рейнольдса.
					 // при nu1=10, nu2=10 скорости разрешаются хорошо и проблем с ними нет, но поправка давления по прежнему даёт сбой.
					 // при nu==20 сбой всё равно есть.
					 // не помогло.
					 //nu1 = 40;
					 //nu2 = 40;

	integer nFinestSweeps = 2;


	// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
	// Т.к. есть трудносходящиеся задачи, то этинастройки должны помоч.
	nu1 = my_amg_manager.nu1;
	nu2 = my_amg_manager.nu2;
	nFinestSweeps = my_amg_manager.nFinnest;

	//if (iVar == PAM) {
	//nFinestSweeps = 300;
	//nu1 = 0;
	//nu2 = 20;
	//}
	// для Finner Heat Sink надо усилить сглаживания.
	// Это не помогает будет перенаправление на другой алгоритм.
	//if (iVar == PAM) {
	//nu1 = 3;
	//nu2 = 3;
	//nFinestSweeps = 6;
	//}
	const bool btheoryGuideANSYSFluent = false;
	if (iVar != PAM) {
		if (btheoryGuideANSYSFluent) {
			// Так написано в Theory Guide ANSYS Fluent.
			nu1 = 0;
			nu2 = 1;
			nFinestSweeps = 1;
		}
	}



	// Двойной вакуумный промежуток вызывает проблемы сходимости:
	//nu1 = 10;
	//nu2 = 20;

	// Смысл этих параметров в том что они экономят ресурсы процессора
	// в теории осуществляя досрочный выход из пред и пост сглаживаний.
	// Т.е. параметры nu1,nu2 задаются с запасом и алгоритм сам использует
	// сколько ему взять итераций для оптимальной работы (сходимости). 
	// Пользователь не ломает голову какие задавать параметры nu1, nu2 
	// а задаёт их верхние предельные значения. 
	doublerealT process_flow_beta = (doublerealT)(0.7);
	doublerealT process_flow_alpha = (doublerealT)(0.1);
	bool process_flow_logic = false;

	if (process_flow_logic) {
		nu1 = 40;
		nu2 = 40;
	}

	if (bprint_mesage_diagnostic) {
		printf("grid complexity is %1.2f\n", dr_grid_complexity);
		printf("Prolongation operator complexity is %1.2f  %1.2f\n", (doublerealT)(nnz_P_memo_all / nnz_P_memo_0), (doublerealT)(nnz_P_memo_all / n_a[0]));
#if doubleintprecision == 1
		printf("nu1=%lld, nu2=%lld\n", nu1, nu2);
#else
		printf("nu1=%d, nu2=%d\n", nu1, nu2);
#endif
		
	}

	//ilevel = 1; //debug
	doublerealT rho = 1.0;
	doublerealT dres = 1.0;
	integer iiter = 1;
	//const doublerealT tolerance = 1.0e-12;
	// 13 февраля 2016 калибруем точность солвера с целью ускорения получения результата.
	// Т.к. нам ненужна точность выше чем десятая доля градуса по температуре.
	// начальное значение невязки составляет примерно 7000.0.
	doublerealT tolerance = (doublerealT)(0.0001); // точность выхода по классическому определению L2 нормы.
								   // 23 октября 2016
	if (bSIMPLErun_now_for_temperature) {
		// Решаем cfd задачи.
		tolerance = (doublerealT)(1.0e-8);
	}

	doublerealT **residual_fine = nullptr;
	residual_fine = new doublerealT*[idim_diag];
	if (residual_fine == nullptr) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem: not enough memory on your equipment for residual_fine my_gregat_amg4.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	doublerealT **residual_coarse = nullptr;
	residual_coarse = new doublerealT*[idim_diag];
	if (residual_coarse == nullptr) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem: not enough memory on your equipment for residual_coarse my_gregat_amg4.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	doublerealT **error_approx_coarse = nullptr;
	error_approx_coarse = new doublerealT*[idim_diag];
	if (error_approx_coarse == nullptr) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem: not enough memory on your equipment for error_approx_coarse my_gregat_amg4.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	doublerealT **error_approx_fine = nullptr;
	error_approx_fine = new doublerealT*[idim_diag];
	if (error_approx_fine == nullptr) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem: not enough memory on your equipment for error_approx_fine my_gregat_amg4.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	for (integer i_id_level_local = 0; i_id_level_local < idim_diag; i_id_level_local++) {
		residual_fine[i_id_level_local] = nullptr;
		residual_coarse[i_id_level_local] = nullptr;
		error_approx_coarse[i_id_level_local] = nullptr;
		error_approx_fine[i_id_level_local] = nullptr;
	}

	
	// Устаревший код инициализации значением nullptr 4 декабря 2016. 
	
	// закомментированный код безнадёжно устарел. В данный момент 
	//5.06.2017 поддерживается 100 уровней вложенности.

	// 25.04.2018 На этом месте удалён большой фрагмент устаревшего кода.

	// лучше выделять оперативную память небольшими блоками т.к.
	// оперативная память фрагментирована системными dll и
	// большого свободного блока может не найтись.


	

	// idim_diag==101
	for (integer i_17 = 1; i_17 <= idim_diag-1; i_17++) {
		// 05.06.2017
		integer i_17_prev = i_17 - 1;

		if (ilevel+1 > i_17) {

		    // residual
		    //residual_fine[i_17_prev] = new doublerealT[n_a[i_17_prev] + 1];
		    residual_fine[i_17_prev] = (doublerealT*)malloc((n_a[i_17_prev] + 1) * sizeof(doublerealT));
		    handle_error<doublerealT>(residual_fine[i_17_prev], "residual_fine[",i_17_prev,"]", "classic_aglomerative_amg_4", (n_a[i_17_prev] + 1));

		
			//residual_coarse[i_17_prev] = new doublerealT[n_a[i_17] + 1];
			residual_coarse[i_17_prev] = (doublerealT*)malloc((n_a[i_17] + 1) * sizeof(doublerealT));
			handle_error<doublerealT>(residual_coarse[i_17_prev], "residual_coarse[",i_17_prev,"]", "classic_aglomerative_amg_4", (n_a[i_17] + 1));

			//error_approx_coarse[i_17_prev] = new doublerealT[n_a[i_17] + 1];
			error_approx_coarse[i_17_prev] = (doublerealT*)malloc((n_a[i_17] + 1) * sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_coarse[i_17_prev], "error_approx_coarse[",i_17_prev,"]", "classic_aglomerative_amg_4", (n_a[i_17] + 1));

			//error_approx_fine[i_17_prev] = new doublerealT[n_a[i_17_prev] + 1];
			error_approx_fine[i_17_prev] = (doublerealT*)malloc((n_a[i_17_prev] + 1) * sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_fine[i_17_prev], "error_approx_fine[",i_17_prev,"]", "classic_aglomerative_amg_4", (n_a[i_17_prev] + 1));
		}
	}




	// 2 jan 2016. 
	integer igam = 1; // 1-V; 2-W
	//INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14 imyinit = INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT; // ZERO_INIT optimum

	doublereal* x_copy = nullptr;
	x_copy = (doublereal*)malloc((n_a[0] + 1) * sizeof(doublereal));
	handle_error<doublereal>(x_copy, "x_copy", "classic_aglomerative_amg_4", (n_a[0] + 1));

	// для ускорения счёта в вакуумном промежутке.
	doublereal* x_old = nullptr;
	x_old = (doublereal*)malloc((n_a[0] + 1) * sizeof(doublereal));
	handle_error<doublereal>(x_old, "x_old", "classic_aglomerative_amg_4", (n_a[0] + 1));

#pragma omp parallel for
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_copy[i47] = x[i47];
		x_old[i47] = x[i47];
		//x_copy[i47] = 0.0; // 28.07.2016
	}

	doublereal* x_best_search = nullptr;
	x_best_search = (doublereal*)malloc((n_a[0] + 1) * sizeof(doublereal));
	handle_error<doublereal>(x_best_search, "x_best_search", "classic_aglomerative_amg_4", (n_a[0] + 1));

	doublerealT res_best_search = (doublerealT)(1e37);
#pragma omp parallel for
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search[i47] = x[i47];
		//x_best_search[i47] = 0.0; // 28.07.2016
	}


	// Для поправки давления возникает задача когда на всех границах стоит условие Неймана,
	// это приводит к тому что метод работает бесконечно долго и не может сойтись, поэтому нужно 
	// заложить критерий останова по превышению количества допустимых итераций (не более 1000 итераций).
	// 1000 итераций это очень долго поэтому для поправки давления надо подобрать разумное количество 
	// итераций т.к. от этого существенным образом зависит быстродействие гидродинамического алгоритма.
	integer iter_limit = 0;
	integer istop_porog_reconst = 5000;// 50

	bool ret_value = false;
	doublerealT dres_previos = (doublerealT)(1.0e37);
	integer icount_bad_convergence_Vcycles = 0;
	integer i_count_stagnation = 0;
	doublerealT res0start = (doublerealT)(1.0e-36);
	bool bfirst_divergence = true;

	residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
	doublerealT dres_initial = norma(residual_fine[0], n_a[0]);
	if (((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) && (dres_initial > 20.0)) {
		// Это признак ошибки в сборке матрицы СЛАУ на компоненты скорости.
		printf("my be problem convergence: very big dres0=%e\n", dres_initial);
		printf("run residualq2 analysys.\n");
		residualq2_analysys(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
	}

	/*
	// код заимствованный из amg5:
	integer iflag_cont = 1;
	if (iVar != PAM) {
	dres = fabs(dres_initial);

	if (iVar != TEMP) {
	if (dres < dterminatedTResudual) {
	// Вектор и так точно удовлетворяет решению, его не надо уточнять из решения СЛАУ.
	iflag_cont = 0;
	}
	}
	else {
	if (dres < 1.0e-4*dterminatedTResudual) {
	// Вектор и так точно удовлетворяет решению, его не надо уточнять из решения СЛАУ.
	iflag_cont = 0;
	}
	}
	}
	iflag_cont = 1;
	*/

	if (bprint_mesage_diagnostic) {
		// start residual.
#if doubleintprecision == 1
		printf("%d %e rho=%e\n", 0, dres_initial, dres_initial / rho);
#else
		printf("%d %e rho=%e\n", 0, dres_initial, dres_initial / rho);
#endif
		
	}

	// TODO 25 10 2016
	integer iflag_cont = 1;
	if (iVar != PAM) {
		dres = fabs(dres_initial);
	}


	integer count_iter_for_film_coef = 0;
	// Если число расходимостей превысит оговорённую константу то произойдёт выход из алгоритма.
	integer i_signal_break_pam_opening = 0;
	// x хорошее значение.
	const integer i_limit_signal_pam_break_opening = 1000; // 8
	doublerealT delta_old_iter = 1.0e10;



	//if (iVar == PAM) {// бред
	//for (integer iter = 0; iter < 2; iter++) {
	//seidelq(Amat, 1, n_a[0], b, x, row_ptr_start, row_ptr_end, 0);
	//}
	//}
	integer icount_V_cycle = 0;

	doublerealT dres_initial_ = (doublerealT)(1e-6);


	doublereal maxold = -1.0e30;
	for (integer i = 1; i <= n_a[0]; i++) {
		if (x[i] > maxold) maxold = x[i];
	}

	// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
	// Т.к. есть трудносходящиеся задачи, то этинастройки должны помоч.
	// Отсекаем уровни которые выше порогового значения указанного пользователем.
	//if (ilevel > my_amg_manager.maximum_levels) {
	//ilevel = my_amg_manager.maximum_levels;
	//}
	ilevel -= my_amg_manager.maximum_delete_levels;



	doublereal* x_best_search2 = nullptr;
	x_best_search2 = new doublereal[n_a[0] + 1];
	if (x_best_search2 == nullptr) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem: not enough memory on your equipment for x_best_search2 my_agregat_amg.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	doublereal* x_best_search_init = nullptr;
	x_best_search_init = new doublereal[n_a[0] + 1];
	if (x_best_search_init == nullptr) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem: not enough memory on your equipment for x_best_search_init my_agregat_amg.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
#pragma omp parallel for
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search_init[i47] = x[i47];
		x_best_search2[i47] = x[i47];
	}


	integer istop_speed_cycling = 10;

	if ((my_amg_manager.istabilization == 0)||((iVar==TEMP)&&(my_amg_manager.istabilization == 3))) {


		// ((iVar==TEMP)&&(my_amg_manager.istabilization == 3)) - нелинейное граничное условие в уравнении теплопередачи.

		// Только алгебраический многосеточный метод.
		
		if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) tolerance *= (doublerealT)(1e-11);
		if (iVar == PAM) tolerance *= (doublerealT)(1e-14);
		if (iVar == TEMP) tolerance *= (doublerealT)(1e-6);
		if (iVar == TOTALDEFORMATIONVAR) tolerance = (doublerealT)(1.0e-17);
		doublereal minx_gl = 1.0e36;
		doublereal maxx_gl = -1.0e36;
	//for (integer iprohod = 0; iprohod < 20; iprohod++) {
	//while ((iflag_cont == 1) && ((dres>tolerance) || ((iVar != TEMP) && (icount_V_cycle<5)))) {
	///	while ((iflag_cont == 1) && ((dres>tolerance) )) {
	while (((iflag_cont == 1) && ((dres>tolerance))) || ((iVar == TEMP) && 
		bSIMPLErun_now_for_temperature && (icount_V_cycle<9))||
		((iVar== TOTALDEFORMATIONVAR)&&(icount_V_cycle<9))) {

		// Обеспечивает коллосальное быстродействие без потери сходимости.
		
		if (bSIMPLErun_now_for_temperature) {
			// гидродинамика.

			//  Этот код непонятен, надо тестировать.
			if (icount_V_cycle > istop_speed_cycling) {

				

				if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) {
					if (dres < 1.0e-3*dres_initial) {
						break;
					}
					else {
						istop_speed_cycling += 2;
					}
				}
				if (iVar == PAM) {
					if (dres < 1.0e-1*dres_initial) {
						//break;
					}
					else {
						istop_speed_cycling += 2;
					}
				}
			}
		}
	

		if (fabs(dres / rho)<1.0) {
#pragma omp parallel for
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x_best_search2[i47] = x[i47];
			}
		}

		if (bPhysics_stop  ) {
			if (icount_V_cycle > 0) {
				doublereal maxnew = (doublereal)(-1.0e30);
				for (integer i = 1; i <= n_a[0]; i++) {
					if (x[i] > maxnew) maxnew = x[i];
				}
				if (iVar == TOTALDEFORMATIONVAR) {
					if ((fabs(dres) < 1.0e-2) && (fabs(maxnew - maxold) < 1.0e-9)) {
						printf("break bPhysics_stop, dres<1e-2 && (fabs(maxnew - maxold) < 1.0e-9)\n");
						break;
					}
					else {
						maxold = maxnew;
					}
				}
				else {
					if ((fabs(dres) < 1.0e-2) && (fabs(maxnew - maxold) < 0.0005)) {
						printf("break bPhysics_stop, dres<1e-2 && (fabs(maxnew - maxold) < 0.0005)\n");
						break;
					}
					else {
						maxold = maxnew;
					}
				}

			}
		}


		if (icount_V_cycle > 0) {
			// установить 0 в случае отката на предыдущую стабильную локально-линейную версию алгоритма.
			// главная причина установки значения 1 является сокращение числа проходов для устранения
			// нелинейности в системе с 26 до 4. При установке 1 в данном месте кода надо в модуле
			// mysolver_v0_03 установить fHORF=1.0; 
			if ((iVar == TEMP) && (my_amg_manager.istabilization == 3)) {
				if (bonly_solid_calculation  ) {
					if (bvacuumPrism) {
						// предполагается неизменый порядок следования позиций в x
						// и rthdsd.

						doublereal* x_temper = nullptr;
						//x_temper = new doublerealT[n_a[0] + 1];
						x_temper = (doublereal*)malloc(((integer)(n_a[0])+1) * sizeof(doublereal));
						if (x_temper == nullptr) {
							// недостаточно памяти на данном оборудовании.
							printf("Problem: not enough memory on your equipment for x_temper my_agregat_amg.cpp...\n");
							printf("Please any key to exit...\n");
							exit(1);
						}
#pragma omp parallel for
						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							if (x[i23 + 1] < -272.15) x[i23 + 1] = -272.15;
							//x_temper[i23] = x[i23 + 1];
							// 0.01 параметр нижней релаксации.
							// 0.25
							x_temper[i23] = x_old[i23 + 1] + 0.2*(x[i23 + 1] - x_old[i23 + 1]);
							if (x_temper[i23] < -272.15) x_temper[i23] = -272.15;
							x[i23 + 1] = x_temper[i23];
						}

						// На старте мы блокируем Стефана Больцмана дав сойтись лучистым потокам.
						// Вычисление осреднённых температур в К на границах вакуумных промежутков:
						for (integer i23 = 0; i23 < lb; i23++) {
							update_avg_temperatures(x_temper, my_body[i23]);
						}
						// Вычисление плотностей радиационных тепловых потоков:
						for (integer i23 = 0; i23 < lb; i23++) {
							calculation_density_radiation_heat_flux(my_body[i23]);
						}


						doublereal* rthdsd_loc123 = nullptr;
						//rthdsd_loc123 = new doublerealT[n_a[0] + 1];
						rthdsd_loc123 = (doublereal*)malloc(((integer)(n_a[0]) + 1) * sizeof(doublereal));
						if (rthdsd_loc123 == nullptr) {
							// недостаточно памяти на данном оборудовании.
							printf("Problem: not enough memory on your equipment for rthdsd_loc123 my_agregat_amg.cpp...\n");
							printf("Please any key to exit...\n");
							exit(1);
						}

						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							rthdsd_loc123[i23] = rthdsd_no_radiosity_patch[i23];
							if ((i23 >= iadd_qnbc_maxelm) && (qnbc[i23 - iadd_qnbc_maxelm].bactive) && (qnbc[i23 - iadd_qnbc_maxelm].bStefanBolcman_q_on)) {
								doublerealT alpha_relax142 = 0.25;
								rthdsd_loc123[i23] = alpha_relax142 *(-qnbc[i23 - iadd_qnbc_maxelm].emissivity*STEFAN_BOLCMAN_CONST*((273.15 + x_temper[i23])*(273.15 + x_temper[i23])*(273.15 + x_temper[i23])*(273.15 + x_temper[i23]) - (273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb))) +
									(1.0 - alpha_relax142)*(-qnbc[i23 - iadd_qnbc_maxelm].emissivity*STEFAN_BOLCMAN_CONST*((273.15 + x_old[i23 + 1])*(273.15 + x_old[i23 + 1])*(273.15 + x_old[i23 + 1])*(273.15 + x_old[i23 + 1]) - (273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)));
								rthdsd_loc123[i23] *= qnbc[i23 - iadd_qnbc_maxelm].dS;
							}
						}

						radiosity_patch_for_vacuum_Prism_Object_(rthdsd_loc123, my_body, lb, maxelm_out, whot_is_block);
#pragma omp parallel for
						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							x_old[i23 + 1] = x_temper[i23];
							//x_old[i23 + 1] = x[i23 + 1];
						}
#pragma omp parallel for
						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							b[i23 + 1] = rthdsd_loc123[i23];
						}

						
						free(rthdsd_loc123);
						rthdsd_loc123 = nullptr;

						if (x_temper != nullptr) {
							free(x_temper);
						}
						x_temper = nullptr;
					}
					else if (b_sign_on_nonlinear_bc) {
						//  25 декабря 2015. Ускорение сходимости при использовании 
						// нелинейных граничных условий.
						doublereal* x_temper = nullptr;
						//x_temper = new doublerealT[n_a[0] + 1];
						x_temper = (doublereal*)malloc(((integer)(n_a[0]) + 1) * sizeof(doublereal));
						if (x_temper == nullptr) {
							// недостаточно памяти на данном оборудовании.
							printf("Problem: not enough memory on your equipment for x_temper my_agregat_amg.cpp...\n");
							printf("Please any key to exit...\n");
							exit(1);
						}
#pragma omp parallel for
						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							if (x[i23 + 1] < -272.15) x[i23 + 1] = -272.15;
							//x_temper[i23] = x[i23 + 1];
							// 0.01 параметр нижней релаксации.
							// 0.25
							// 0.2
							// 10 июня 2018 года заменил на коэффициент нижней релаксации равный 0.9.
							x_temper[i23] = x_old[i23 + 1] + 0.9*(x[i23 + 1] - x_old[i23 + 1]);
							if (x_temper[i23] < -272.15) x_temper[i23] = -272.15;
							x[i23 + 1] = x_temper[i23];
						}

						doublereal* rthdsd_loc123 = nullptr;
						//rthdsd_loc123 = new doublerealT[n_a[0] + 1];
						rthdsd_loc123 = (doublereal*)malloc(((integer)(n_a[0]) + 1) * sizeof(doublereal));
						if (rthdsd_loc123 == nullptr) {
							// недостаточно памяти на данном оборудовании.
							printf("Problem: not enough memory on your equipment for rthdsd_loc123 my_agregat_amg.cpp...\n");
							printf("Please any key to exit...\n");
							exit(1);
						}

						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							rthdsd_loc123[i23] = rthdsd_no_radiosity_patch[i23];
							if ((i23 >= iadd_qnbc_maxelm) && (qnbc[i23 - iadd_qnbc_maxelm].bactive) && (qnbc[i23 - iadd_qnbc_maxelm].bStefanBolcman_q_on) && (qnbc[i23 - iadd_qnbc_maxelm].bNewtonRichman_q_on==false)) {
								// Стефан Больцман.
								doublerealT alpha_relax142 = 0.25;
								rthdsd_loc123[i23] = alpha_relax142 *(-qnbc[i23 - iadd_qnbc_maxelm].emissivity*STEFAN_BOLCMAN_CONST*((273.15 + x_temper[i23])*(273.15 + x_temper[i23])*(273.15 + x_temper[i23])*(273.15 + x_temper[i23]) - (273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb))) +
									(1.0 - alpha_relax142)*(-qnbc[i23 - iadd_qnbc_maxelm].emissivity*STEFAN_BOLCMAN_CONST*((273.15 + x_old[i23 + 1])*(273.15 + x_old[i23 + 1])*(273.15 + x_old[i23 + 1])*(273.15 + x_old[i23 + 1]) - (273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)));
								rthdsd_loc123[i23] *= qnbc[i23 - iadd_qnbc_maxelm].dS;
							}
							if ((i23 >= iadd_qnbc_maxelm) && (qnbc[i23 - iadd_qnbc_maxelm].bactive) && (qnbc[i23 - iadd_qnbc_maxelm].bNewtonRichman_q_on) && (qnbc[i23 - iadd_qnbc_maxelm].bStefanBolcman_q_on == false)) {
								// Ньютон-Рихман.
								//doublerealT alpha_relax142 = 0.25;
								rthdsd_loc123[i23]  = -qnbc[i23 - iadd_qnbc_maxelm].film_coefficient*(x_temper[i23] - qnbc[i23 - iadd_qnbc_maxelm].Tamb);
								rthdsd_loc123[i23] *= qnbc[i23 - iadd_qnbc_maxelm].dS;
							}
							if ((i23 >= iadd_qnbc_maxelm) && (qnbc[i23 - iadd_qnbc_maxelm].bactive) && (qnbc[i23 - iadd_qnbc_maxelm].bNewtonRichman_q_on) && (qnbc[i23 - iadd_qnbc_maxelm].bStefanBolcman_q_on)) {
								// Условие смешанного типа.
								//doublerealT alpha_relax142 = 0.25;
								rthdsd_loc123[i23] = (-qnbc[i23 - iadd_qnbc_maxelm].emissivity*STEFAN_BOLCMAN_CONST*((273.15 + x_temper[i23])*(273.15 + x_temper[i23])*(273.15 + x_temper[i23])*(273.15 + x_temper[i23]) - (273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)));
								rthdsd_loc123[i23] += -qnbc[i23 - iadd_qnbc_maxelm].film_coefficient*(x_temper[i23] - qnbc[i23 - iadd_qnbc_maxelm].Tamb);
								rthdsd_loc123[i23] *= qnbc[i23 - iadd_qnbc_maxelm].dS;
							}
						}
#pragma omp parallel for
						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							x_old[i23 + 1] = x_temper[i23];
							//x_old[i23 + 1] = x[i23 + 1];
						}
#pragma omp parallel for
						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							b[i23 + 1] = rthdsd_loc123[i23];
						}

						if (rthdsd_loc123 != nullptr) {
							free(rthdsd_loc123);
						}
						rthdsd_loc123 = nullptr;

						if (x_temper != nullptr) {
							free(x_temper);
						}
						x_temper = nullptr;

					}
				}
			}
		}

		//getchar();
		icount_V_cycle++;
		//if (icount_V_cycle > 8) break;
		count_iter_for_film_coef++;
		// В случае задачи Ньютона - Рихмана, Стефана-Больцмана и миксового условия не итерируем до конца обрываем, 
		// т.к. нам требуется частая пересборка матрицы. 13 марта 2016.
		if (((adiabatic_vs_heat_transfer_coeff > DEFAULT_CABINET_BOUNDARY_CONDITION::ADIABATIC_WALL_BC) ||
			(breakRUMBAcalc_for_nonlinear_boundary_condition)) && (count_iter_for_film_coef>1250)) break;

		// 1 dec 2016.
		//  Прерывание после 2 или 5 V циклов обязательно необходимо иначе не будет сходимости.
		if (bvacuumPrism) {
			// 5
			// 250
			if (icount_V_cycle > 250) break;
		}


		if ((iter_limit == 5000) || ((iVar == PAM) && (fabs(dres)>7.0e3))) {
#pragma omp parallel for
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x[i47] = x_copy[i47];
			}
			if (iVar == PAM) {
				printf("pressure amendment divergence...\n");
			}
			printf("amg divergence detected dres=%e...\n", dres);
#if doubleintprecision == 1
			printf("nV=%lld dres0=%e\n", icount_V_cycle, dres_initial);
#else
			printf("nV=%d dres0=%e\n", icount_V_cycle, dres_initial);
#endif
			
			printf("CopA=%1.2f  CopP=%1.2f...\n", dr_grid_complexity, (doublerealT)(nnz_P_memo_all / n_a[0]));
			printf("res_best_search=%e\n", res_best_search);
			//getchar();
			// пауза убрана 22 12 2016
			//system("PAUSE");
			break;
		}

		if (iter_limit == 1) {
			// начальная невязка.
			res0start = fabs(dres);
		}

		// Невязка по температуре:
		// НЕТ сходимости для поля температур в гидродинамическом решателе и параметры не помогают.
		//if (iVar == TEMP) printf("temp res=%e\n", fabs(dres));

		if (fabs(dres) < res_best_search)
		{
			// Запоминаем лучшую попытку.
			res_best_search = fabs(dres);
#pragma omp parallel for
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x_best_search[i47] = x[i47];
			}
		}
		/*
		if (iVar == PAM) {
		if (fabs(dres) < 1.0) {
		// Идея в том что нам нужна хоть какая-то поправка давления,
		// всё лучше чем тождественно нулевое распределение.
		// невязка при этом у нас менеее 1.0 что гарантирует что мы не сильно улетели.
		for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search[i47] = x[i47];
		}
		}
		}
		*/

		// debug 7 июня 2016
		//if (iter_limit > 300) {
		//printf("amg divergense detected...9 june 2016\n");
		//system("pause");
		//break;
		//}

		//if (dres < 1.0e-14) break;

		// 100
		if (iter_limit > 5000) { // Finned Heat Sink



			if (bfirst_divergence) {
				iter_limit = 3;
				nu1 += 2;
				nu2 += 2;
				nFinestSweeps += 2;
				bfirst_divergence = false;
			}
			else {
				if ((fabs((doublereal)(res_best_search / res0start)) < 0.23) && (fabs(res_best_search) < 1.0e-3*sqrt((doublereal)(n_a[0])))) {
					// Если невязка меньше первоначальной на два порядка.
					// Обратное копирование и выход и алгоритма.
#pragma omp parallel for
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				else if ((fabs((doublereal)(res_best_search / res0start)) <= 1.0) && (fabs(res_best_search) < 1.0e-4*sqrt((doublereal)(n_a[0])))) {
					// Если невязка меньше первоначальной на два порядка.
					// Обратное копирование и выход и алгоритма.
#pragma omp parallel for
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				// Обратное копирование и выход и алгоритма.
#pragma omp parallel for
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = x_best_search[i47];
				}
				break;
				// закомментировал 11.01.2020
				// как недостижимый код.
				// Эта ветвь кода вообще никогда не вызовется.
				/*
				printf("Fatal amg error: Strong divergence amg solver...%e \n", fabs(res_best_search / res0start));
				printf("res_best_search=%e, res0start=%e\n", fabs(res_best_search), fabs(res0start));
				printf("BiCGStab+ILU2 is start now...\n");
				printf("please wait...");
				system("pause");
				break; // досрочный выход из while цикла.
				*/
			}
		}
		iter_limit++;

		if (fabs(dres) < fabs(dres_previos)) {
			// все нормально процесс сходится.
			icount_bad_convergence_Vcycles = 0;
		}
		else {
			icount_bad_convergence_Vcycles++;
		}

		//if (_finite(dres) == 0) {
		//if (fabs(dres) > 1.0e30)
		//{
		//printf("\ndivergence AMG detected...solver will be restart... please wait... ... ...\n");
		//printf("\a\a\a\a\a\a\a\a");
		//system("pause");
		//exit(1);
		//return true;
		//for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		//	x[i47] = x_copy[i47];
		//}
		//if (iter_limit > 100) {
		//	ret_value = true;
		//	break;
		//}
		//else {
		// Увеличение количества сглаживающих итераций ни коим образом не 
		// исправляет факт расходимости. 
		//	nu1++;
		//	nu2++;
		//	nFinestSweeps++;
		// По видимому надо действовать очень тонкой настройкой параметра верхней релаксации omega optimal.
		// Настройка omega optimal должна быть самообучающейся (адаптированной к задаче).
		//}
		//}

		// 24 10 2016
		if (icount_bad_convergence_Vcycles > 40) break;

		if ((icount_bad_convergence_Vcycles >= istop_porog_reconst) || (fabs(dres) / sqrt((doublereal)(n_a[0])) > 1.0e30)) {
			// детектировано 10 шагов расходимости подряд по-видимому метод расходится.
			// Также о расходимости говорит невязка большая 1.0e30.

			//if (fabs(dres) < 1.0e-3) break; // Будем считать сходимость достигнута успешно.
			if ((fabs((doublereal)(res_best_search / res0start)) < 1.0e-1) && (fabs(dres) / sqrt((doublereal)(n_a[0])) < 1.0e-3)) {
				// Если невязка меньше первоначальной на два порядка.
				// Обратное копирование и выход и алгоритма.
#pragma omp parallel for
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = x_best_search[i47];
				}
				printf("stagnaion break out\n");
				break;
			}
			i_count_stagnation++;

			printf("\ndivergence AMG detected...solver will be restart... please wait... ... ...\n");
			//printf("\a\a\a\a\a\a\a\a");
			//system("pause");
			//exit(1);
			//return true;
			if (i_count_stagnation < 20) {
#pragma omp parallel for
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					//x[i47] = x_copy[i47];
					x[i47] = x_best_search[i47]; // лучшее найденное решение
				}
			}
			if (i_count_stagnation == 20 || i_count_stagnation == 21) gold_const = 0.2;
			if ((i_count_stagnation >= 20) && (i_count_stagnation < 30)) {
#pragma omp parallel for
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					//x[i47] = x_copy[i47];
					// Можно еще единократно немного улучшить nu1 и nu2.
					doublerealT signumnow = 1.0;
					if (rand() % 2 == 0) signumnow = -1.0;
					doublereal drand = (doublereal)(((double)(rand())) / ((double)(RAND_MAX + 1)));
					x[i47] = signumnow *1.0*drand; // Случайное число в интервале от 0 до 1.
				}
			}
			if (i_count_stagnation == 30 || i_count_stagnation == 31) gold_const = 0.2;
			if (i_count_stagnation >= 30) {
#pragma omp parallel for
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = 1.0;
				}
			}
			if (bproblem_amg_convergence1) {
				if (bproblem_amg_convergence2) {
					if (bproblem_amg_convergence3) {
						// выход к вызову BiCGStab+ILU2.
						ret_value = true;
						break;
					}
					else {
						// смена omega.
						bproblem_amg_convergence3 = true;
						icount_bad_convergence_Vcycles = 0;
						buffers3omega = dres / dres_previos;
						printf("buffers1omega=%1.4f, buffers2omega=%1.4f, buffers3omega=%1.4f\n", buffers1omega, buffers2omega, buffers3omega);
					}
				}
				else {
					// смена omega.
					bproblem_amg_convergence2 = true;
					icount_bad_convergence_Vcycles = 0;
					buffers2omega = dres / dres_previos;
					printf("buffers1omega=%1.4f, buffers2omega=%1.4f\n", buffers1omega, buffers2omega);
					//istop_porog_reconst += 50; // 10, 20, 30, 40
					// Увеличение количества сглаживающих итераций ничего не даёт.
					//nu1++;
					//nu2++;
					//nFinestSweeps++;
				}
			}
			else {

				bproblem_amg_convergence1 = true; // переход с SOR на стабильный Зейдель.
				icount_bad_convergence_Vcycles = 0;
				buffers1omega = dres / dres_previos;
			}
		}


		dres_previos = dres;


		doublerealT R0_0 = 0.0;
		doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
			R0_0 = norma(residual_fine[0], n_a[0]);
			Rprev_0 = R0_0;

			// smother
			integer iter = 0;
			for (iter = 0; iter < nu1; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, nested_desection[0], row_ptr_start, row_ptr_end, 0);
				}
				//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
				residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
				Rnext_0 = norma(residual_fine[0], n_a[0]);
				// this is process flow logic
				if (Rnext_0 > process_flow_beta*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nu1) {
				printf("level 0 limit presmother iteration is reached\n");
			}

		}
		else {
			// smoother
			for (integer iter = 0; iter < nu1; iter++) {
				//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					if (bILU2smoother == 1) {
						// ILU0
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
						residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu0[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu0[0].zbuf, milu0[0].zbuf2, milu0[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							x[i43 + 1] += milu0[0].zbuf2[i43 + 1];
						}
					}
					else if ((bILU2smoother == 2)||(my_amg_manager.iFinnest_ilu == 1)) {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
						residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu2[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu2[0].zbuf, milu2[0].zbuf2, milu2[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							x[i43 + 1] += milu2[0].zbuf2[i43 + 1];
						}
					}
					else {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
					}
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, nested_desection[0], row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
				}
			}
		}

		//exporttecplot(x, n);

		move_down(nu1, nu2);

		if (!process_flow_logic) {
			// residual_r
			//doublerealT *residual_fine[0] = new doublerealT[n_a[0] + 1];
			//residual(Amat, 1, nnz_a[0], x, b, flag, n_a[0], residual_fine[0]);
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
		}
		dres = norma(residual_fine[0], n_a[0]);
		ret74 += fabs(dres);
		if (bprint_mesage_diagnostic) {


			doublereal minx = 1.0e30;
			doublereal maxx = -1.0e30;
			for (integer i_83 = 1; i_83 <= n_a[0]; i_83++) {
				if (x[i_83] < minx) minx = x[i_83];
				if (x[i_83] > maxx) maxx = x[i_83];
			}

			if (((iVar == TEMP) && (my_amg_manager.istabilization == 3))) {
				//  Сходимость достинута - досрочный выход из решения нелинейной задачи.
				if ((fabs(minx - minx_gl) < 1.0e-2) && (fabs(maxx - maxx_gl) < 1.0e-2)) {
					printf("Solution nonlinear problem converged succsefull. Ok...\n");
					break;
				}
		}

			minx_gl = minx;
			maxx_gl = maxx;

#if doubleintprecision == 1
			printf("%lld %e rho=%e min=%e max=%e\n", iiter, dres, dres / rho, minx, maxx);
#else
			printf("%d %e rho=%e min=%e max=%e\n", iiter, dres, dres / rho, minx, maxx);
#endif
			
			if (!((iVar == TEMP) && (my_amg_manager.istabilization == 3))) {
				if (fabs(1.0 - fabs(dres / rho)) < 1.0e-3) {
					printf("stagnation in amg solver determinate ...\n");
					// 28_10_2016.
					// Осуществляем досрочный выход из итерирования, 
					// т.к. невязка перестала меняться.
					break;
				}
			}
			if (icount_V_cycle == 1) {
				if (fabs(dres / rho)<1.0) {
#pragma omp parallel for
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x_best_search[i47] = x[i47];
					}
				}
			}
		}
		iiter++;
		// 28.07.2016

		if (fabs(dres) > 1.0e9) {

			printf("amg solver divergence detected.\n");
			system("pause");

#pragma omp parallel for
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				///x[i47] = x_best_search[i47];
				//x_copy[i47] = x[i47]; // 4 ноября 2016.
				x[i47] = x_copy[i47];
			}
			residualq2_analysys(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);

			printf("dres_initial=%e res_best_search=%e dres=%e current=%e\n", dres_initial, res_best_search, dres, norma(residual_fine[0], n_a[0]));
			printf("break. amg divergence detected. fabs(dres) > 1.0e7\n");
			//getchar();
			if ((bILU2smoother == 2)||(bILU2smoother == 0)) {
				printf("apply ilu2 smoother for number 0 level\n");
				equation3DtoCRSRUMBA1(milu2[0], true, Amat, 1, n_a[0], row_ptr_start, row_ptr_end, 0, 0);
				
			}
			if (bILU2smoother == 0) {
				// переключение.
				memory_allocation_apostoriory_buffer_ilu(milu2, ilevel - 1);
				bILU2smoother = 2;
			}

			// Это по умолчанию для поправки давления.
			doublereal dresfinish_probably = 0.1*norma(residual_fine[0], n_a[0]);
			if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) {
				// Это по умолчанию для компонент скорости внутри SIMPLE алгоритма.
				dresfinish_probably = 1.0e-3*norma(residual_fine[0], n_a[0]);
			}
			if (bSIMPLErun_now_for_temperature  ) {
				if (iVar == TEMP) {
					// Для поля температур при гидродинамическом расчёте.
					// В BiCGStab Internal 3 домножается на 1e-10.
					dresfinish_probably = 1.0e-3*norma(residual_fine[0], n_a[0]);
				}
			}
			if (iVar == TOTALDEFORMATIONVAR) {
				// Для механических деформаций
				dresfinish_probably = 1.0e-3*norma(residual_fine[0], n_a[0]);
			}
			if (bonly_solid_calculation) {
				dresfinish_probably = 1.0e-5*norma(residual_fine[0], n_a[0]);
			}
			integer i943 = 0;
			for (integer i_prob_detect_i = 0; i_prob_detect_i < 1000; i_prob_detect_i++) {
				i943 = i_prob_detect_i;
				seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
				residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);

				doublereal minx = 1.0e30;
				doublereal maxx = -1.0e30;
				for (integer i_83 = 1; i_83 <= n_a[0]; i_83++) {
					if (x[i_83] < minx) minx = x[i_83];
					if (x[i_83] > maxx) maxx = x[i_83];
			}

#if doubleintprecision == 1
				printf("%lld residual=%e min=%e max=%e \n", i_prob_detect_i, norma(residual_fine[0], n_a[0]), minx, maxx);
#else
				printf("%d residual=%e min=%e max=%e \n", i_prob_detect_i, norma(residual_fine[0], n_a[0]), minx, maxx);
#endif
				
				// Досрочный выход из цикла.
				if (norma(residual_fine[0], n_a[0]) < dresfinish_probably) {
					printf("Ok!!! calculation local compleate... \n");
					break;
				}
#pragma omp parallel for
				for (integer i43 = 0; i43 < n_a[0]; i43++) {
					milu2[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
				}
				lusol_1patchforRUMBA(n_a[0], milu2[0].zbuf, milu2[0].zbuf2, milu2[0]);
#pragma omp parallel for
				for (integer i43 = 0; i43 < n_a[0]; i43++) {
					x[i43 + 1] += milu2[0].zbuf2[i43 + 1];
				}
			}

			// Детектируем возможные проблемы со сходимостью:
			if (norma(residual_fine[0], n_a[0]) >= dresfinish_probably) {
				printf("Fatal error !!! ilu2 divergence detected... \n");
				printf("residual curent=%e target residual=%e\n", norma(residual_fine[0], n_a[0]), dresfinish_probably);
				if (i943 < 997) {
					break;
				}
			}
#pragma omp parallel for
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x_best_search[i47] = x[i47];
				x_copy[i47] = x[i47]; // 4 ноября 2016.
			}
			system("PAUSE");

			goto FULL_DIVERGENCE_DETECTED;
			//break;
		}

		if (iVar == PAM) {
			if ((fabs(dres / rho) > 0.99999) || (fabs(dres) > 1.0e7)) {
				// Выход из мультигрида ести достигнуто 20 циклов расходимости.
				delta_old_iter = fabs(dres);
				i_signal_break_pam_opening++;
				if (i_signal_break_pam_opening > i_limit_signal_pam_break_opening) {
#if doubleintprecision == 1
					printf("iter = %lld\n", iiter);
#else
					printf("iter = %d\n", iiter);
#endif
					
					// Обратное копирование и выход и алгоритма.
#pragma omp parallel for
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
			}
		}


		//rho=norma(residual_fine[0], n_a[0]);
		rho = dres;
		// start 08.01.2018
		V_cycle_solve<doublerealT>(Amat, x, b, process_flow_logic, row_ptr_start,
			row_ptr_end, residual_fine, diag, n_a, bonly_serial,
			process_flow_beta, F_false_C_true, nu1, nu2, bILU2smoother,
			ilevel, 1, imyinit, idim_diag, milu2, milu0, nested_desection,
			R, P, nnz_aRP, flag, residual_coarse, igam, nnz_a,
			error_approx_coarse, dapply_ilu_max_pattern_size,
			process_flow_alpha,
			error_approx_fine, nFinestSweeps);
		// end 08.01.2018

		//if (bfirst_start_nonlinear_process) {
		// Во избежании расходимости по начальному условию в двойном 
		// вакуумном промежутке.
		//bfirst_start_nonlinear_process = false;
		//break;
		//}
		if (iVar != PAM) {
			if (btheoryGuideANSYSFluent) break; // Делаем лишь один V  цикл.
		}
		//system("pause");
	}
	} // bBiCGStab_plus_RUMBA_camg if (my_amg_manager.istabilization == 1)
	else if (my_amg_manager.istabilization == 1) {
		// Рекомендуется использовать гибридную точность: двойную для BiCGStab и одинарную для предобуславливания с помощью V - цикла.
		// Алгебраический Многосеточный Метод как предобуславливатель
		// к алгоритму Крыловского типа Хенка Ван Дер Ворста BiCGStab
		// со стабилизацией.
		// Требует ещё одну память под матрицу А на самом подробном уровне.
		// 5.01.2017 Алгоритм BiCGStab изобретён в 1992 году.

		integer inumberVcyclelocbicgstab = 1;

		// нумерация векторов начинается с нуля.
		integer n75 = n_a[0]; // число неизвестных на подробном уровне.
		doublereal* val75 = nullptr;
		val75 = new doublereal[nnz_a[0]];
		integer* col_ind75 = nullptr;
		col_ind75 = new integer[nnz_a[0]];
		integer* row_ptr75 = nullptr;
		row_ptr75 = new integer[n_a[0] + 1];
		if ((val75 == nullptr) || (col_ind75 == nullptr) || (row_ptr75 == nullptr)) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for val, col_ind or row_ptr: bicgStab + camg...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}
		// инициализация матрицы.
		/*
		for (integer i_1 = 1; i_1 <= n_a[0]; i_1++) {
			val75[row_ptr_start[i_1] - 1] = diag[0][Amat[row_ptr_start[i_1]].i];
			col_ind75[row_ptr_start[i_1] - 1] = Amat[row_ptr_start[i_1]].i-1;
			for (integer i_2 = row_ptr_start[i_1] + 1; i_2 <= row_ptr_end[i_1]; i_2++) {
				val75[i_2 - 1] = Amat[i_2].aij;
				col_ind75[i_2 - 1] = Amat[i_2].j-1;
			}
			row_ptr75[i_1 - 1] = row_ptr_start[i_1] - 1;
		}
		*/
		// инициализация матрицы.
#pragma omp parallel for
		for (integer i_1 = 1; i_1 <= n_a[0]; i_1++) {
			
			for (integer i_2 = row_ptr_start[i_1] ; i_2 <= row_ptr_end[i_1]; i_2++) {
				if (Amat[i_2].i == Amat[i_2].j) {
					if (i_1 != Amat[i_2].i) {
						printf("err i!=i\n");
						system("PAUSE");
					}
					val75[i_2-1] = diag[0][i_1];
					col_ind75[i_2 - 1] = i_1-1;
				}
				else {
					val75[i_2 - 1] = Amat[i_2].aij;
					col_ind75[i_2 - 1] = Amat[i_2].j-1;
				}
			}
			row_ptr75[i_1 - 1] = row_ptr_start[i_1] - 1;
		}	
#if doubleintprecision == 1
		//printf("nnz=%lld rpe=%lld rps=%lld\n",nnz_a[0], row_ptr_end[n_a[0]], row_ptr_start[n_a[0]+1]-1);
#else
		//printf("nnz=%d rpe=%d rps=%d\n",nnz_a[0], row_ptr_end[n_a[0]], row_ptr_start[n_a[0]+1]-1);
#endif
		
		//system("PAUSE");
		row_ptr75[n_a[0]] = row_ptr_end[n_a[0]];
		// Вектора необходимые для работы BiCGStab.
		doublereal* ri75 = nullptr;
		doublereal* roc75 = nullptr;
		doublereal* s75 = nullptr;
		doublereal* t75 = nullptr;
		doublereal* vec75 = nullptr;
		doublereal* vi75 = nullptr;
		doublereal* pi75 = nullptr;
		doublereal* dx75 = nullptr;
		doublereal* dax75 = nullptr;
		doublereal* y75 = nullptr;
		doublereal* z75 = nullptr;
		// Первое предобуславливание:
		doublereal* y76 = nullptr;
		doublereal* pi76 = nullptr;
		y76 = new doublereal[n75+1];
		pi76 = new doublereal[n75+1];
		// Второе предобуславливание:
		doublereal* z76 = nullptr;
		doublereal* s76 = nullptr;
		z76 = new doublereal[n75 + 1];
		s76 = new doublereal[n75 + 1];

		ri75 = new doublereal[n75];
		roc75 = new doublereal[n75];
		s75 = new doublereal[n75];
		t75 = new doublereal[n75];
		vec75 = new doublereal[n75];
		vi75 = new doublereal[n75];
		pi75 = new doublereal[n75];
		dx75 = new doublereal[n75];
		dax75 = new doublereal[n75];
		y75 = new doublereal[n75];
		z75 = new doublereal[n75];
		if ((ri75 == nullptr) || (roc75 == nullptr) || (s75 == nullptr) || (t75 == nullptr) || (vi75 == nullptr) || (pi75 == nullptr) || (dx75 == nullptr) || (dax75 == nullptr) || (y75 == nullptr) || (z75 == nullptr)) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for: bicgStab + camg...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}

		integer iflag75 = 1, icount75 = 0;
		doublereal delta075 = 1.0e30, deltai75 = 1.0e30;
		doublereal bet75 = 0.0, roi75 = 0.0;
		doublereal roim175 = 1.0, al75 = 1.0, wi75 = 1.0;

		doublereal epsilon75 = dterminatedTResudual;  // точность вычисления
		if (iVar == TEMP) {
			epsilon75 *= 1.0e-4; // 1.0e-4
		}
		if (iVar == TOTALDEFORMATIONVAR) {
			epsilon75 *= 1.0e-4; // 1.0e-4
			//epsilon75 *= 1.0e-12;
		}
		integer i75 = 0;

		// initialize
#pragma omp parallel for
		for (i75 = 0; i75<n75; i75++) {
				s75[i75] = 0.0;
				t75[i75] = 0.0;
				vi75[i75] = 0.0;
				pi75[i75] = 0.0;
				// инициализатор массивов для предобуславливания
				y75[i75] = 0.0;
				z75[i75] = 0.0;
				// результат умножения матрицы на вектор.
				dax75[i75] = 0.0;
				// Начальное приближение.
				dx75[i75] = x[i75 + 1];
			}

		// Умножение матрицы на вектор. Нумерации векторов начинаются с нуля.
		MatrixCRSByVector(val75, col_ind75, row_ptr75, dx75, dax75, n75); // результат занесён в  dax75

		// Вычисление ri75 и roc75.
#pragma omp parallel for
		for (i75 = 0; i75 < n75; i75++) {
			ri75[i75] = b[i75 + 1] - dax75[i75];
			roc75[i75] = 1.0;
		}
		delta075 = NormaV(ri75, n75);
		

		// Если решение сразу хорошее то не считать:
		if (iVar == TEMP) {
			if (fabs(delta075)<1.0e-4*dterminatedTResudual) iflag75 = 0;
		}
		else {
			if (fabs(delta075)<dterminatedTResudual) iflag75 = 0;
		}
		integer iflag175 = 1;
		if (fabs(delta075)<1e-14) iflag175 = 0;
		if ((iVar == TEMP) && (iflag75 == 0) && (iflag175 == 0)) {
#if doubleintprecision == 1
			printf("bicgStab+camg: iflag=%lld, iflag1=%lld, delta0=%e\n", iflag75, iflag175, delta075);
#else
			printf("bicgStab+camg: iflag=%d, iflag1=%d, delta0=%e\n", iflag75, iflag175, delta075);
#endif
			
			system("PAUSE");
		}

		integer iN75 = 10;
		if (n75<30000) {
			// задача очень малой размерности !
			if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) {
				iN75 = 1; // обязательно нужна хотя бы одна итерация.
						// если этого будет недостаточно то мы всё равно будем итерировать до тех пор пока невязка не станет меньше epsilon.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
			}
			if (iVar == TEMP) {
				iN75 = 2;
				epsilon75 = fmin(0.1*fabs(delta075), epsilon75);
				if (bSIMPLErun_now_for_temperature  ) {
					//printf("epsilon=%e \n",epsilon);
					//getchar();
					// Экспериментальным образом обнаружена недоэтерированость по температуре для гидродинамического решателя.
					// поэтому точность было решено увеличить на 5 порядков.
					// 27.07.2016
					epsilon75 *= 1e-10;
					iN75 = 20;
					//epsilon75 *= 1e-16;
					//iN75 = 30;
				}
			}
			if (iVar == PAM) {
				iN75 = 3; // решение для поправки давления должно быть получено точно.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				//printf("%e",epsilon75); getchar();
			}
		}
		else if ((n75 >= 30000) && (n75 < 100000)) {
			// Здесь я немного увеличил число итераций и 
			// скорректировал условие окончания чтобы считало 
			// поточнее, но это не повлияло.
			// Главный вопрос в том что невязка по температуре почему-то не меняется.
			// задача небольшой размерности.
			if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) {
				iN75 = 3; // обязательно нужна хотя бы одна итерация.
						// если этого будет недостаточно то мы всё равно будем итерировать до тех пор пока невязка не станет меньше epsilon.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				// 27.07.2016
				iN75 = 12;
				epsilon75 *= 1e-2;
			}
			if (iVar == TEMP) {
				iN75 = 4;
				epsilon75 = fmin(0.1*fabs(delta075), epsilon75);
				if (bSIMPLErun_now_for_temperature  ) {
					//printf("epsilon75=%e \n",epsilon75);
					//getchar();
					// Экспериментальным образом обнаружена недоэтерированость по температуре для гидродинамического решателя.
					// поэтому точность было решено увеличить на 5 порядков.
					// 27.07.2016
					epsilon75 *= 1e-10;
					iN75 = 20;
					//epsilon75 *= 1e-16;
					//iN75 = 30;
				}
			}
			if (iVar == PAM) {
				iN75 = 6; // решение для поправки давления должно быть получено точно.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				//printf("%e",epsilon75); getchar();
				// 27.07.2016.
				epsilon75 *= 1e-2;
				iN75 = 20;
			}
		}
		else if ((n75 >= 100000) && (n75<300000)) {
			// задача небольшой средней размерности.
			if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) {
				iN75 = 3; // обязательно нужна хотя бы одна итерация.
						// Вообще говоря невязка для скоростей падает очень быстро поэтому всегда достаточно iN итераций для скорости.
						// если этого будет недостаточно то мы всё равно будем итерировать до тех пор пока невязка не станет меньше epsilon.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
			}
			if (iVar == TEMP) {
				iN75 = 4;
				epsilon75 = fmin(0.1*fabs(delta075), epsilon75);
				if (bSIMPLErun_now_for_temperature  ) {
					//printf("epsilon75=%e \n",epsilon75);
					//getchar();
					// Экспериментальным образом обнаружена недоэтерированость по температуре для гидродинамического решателя.
					// поэтому точность было решено увеличить на 5 порядков.
					// 27.07.2016
					epsilon75 *= 1e-10;
					iN75 = 20;
					//epsilon75 *= 1e-16;
					//iN75 = 30;
				}
			}
			if (iVar == PAM) {
				iN75 = 8; // решение для поправки давления должно быть получено точно.
				if (1.0e-4*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-4*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				//printf("%e",epsilon75); getchar();
			}
		}
		else if ((n75 >= 300000) && (n75<1000000)) {
			// задача истинно средней размерности.
			if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) {
				iN75 = 3; // обязательно нужна хотя бы одна итерация.
						// если этого будет недостаточно то мы всё равно будем итерировать до тех пор пока невязка не станет меньше epsilon.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
			}
			if (iVar == TEMP) {
				iN75 = 4;
				epsilon75 = 1e-5*fmin(0.1*fabs(delta075), epsilon75);
				if (bSIMPLErun_now_for_temperature  ) {
					//printf("epsilon75=%e \n",epsilon75);
					//getchar();
					// Экспериментальным образом обнаружена недоэтерированость по температуре для гидродинамического решателя.
					// поэтому точность было решено увеличить на 5 порядков.
					// 27.07.2016
					epsilon75 *= 1e-8;
					iN75 = 20;
					//epsilon75 *= 1e-16;
					//iN75 = 30;
				}
			}
			if (iVar == PAM) {
				iN75 = 16; // решение для поправки давления должно быть получено точно.
				if (1.0e-4*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-4*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				//printf("%e",epsilon75); getchar();
			}
		}
		else if ((n75 >= 1000000) && (n75<3000000)) {
			// задача достаточно большой размерности.
			if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) {
				iN75 = 6; // обязательно нужна хотя бы одна итерация.
						// если этого будет недостаточно то мы всё равно будем итерировать до тех пор пока невязка не станет меньше epsilon.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
			}
			if (iVar == TEMP) {
				iN75 = 8;
				epsilon75 = 1e-5*fmin(0.1*fabs(delta075), epsilon75);
				if (bSIMPLErun_now_for_temperature  ) {
					//printf("epsilon75=%e \n",epsilon75);
					//getchar();
					// Экспериментальным образом обнаружена недоэтерированость по температуре для гидродинамического решателя.
					// поэтому точность было решено увеличить на 5 порядков.
					// 27.07.2016
					epsilon75 *= 1e-8;
					iN75 = 20;
					//epsilon75 *= 1e-16;
					//iN75 = 30;
				}
			}
			if (iVar == PAM) {
				iN75 = 23; // решение для поправки давления должно быть получено точно.
				if (1.0e-4*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-4*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				//printf("%e",epsilon75); getchar();
			}
		}
		else if (n75 >= 3000000) {
			// задача очень большой размерности.
			if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) {
				iN75 = 6; // обязательно нужна хотя бы одна итерация.
						// если этого будет недостаточно то мы всё равно будем итерировать до тех пор пока невязка не станет меньше epsilon.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
			}
			if (iVar == TEMP) {
				iN75 = 8;
				epsilon75 = 1e-10*fmin(0.1*fabs(delta075), epsilon75);
			}
			if (iVar == PAM) {
				iN75 = 36; // решение для поправки давления должно быть получено точно.
				if (1.0e-4*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-4*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				//printf("%e",epsilon); getchar();
			}
		}

		integer maxit75 = 2000;
		if (iVar == TEMP) {
			maxit75 = 2000;
		}
		if (iVar == PAM) {
			maxit75 = 2000; // 2000
		}
		if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) {
			maxit75 = 100;//100
		}
		if (iVar == TOTALDEFORMATIONVAR) {
			maxit75 = 2000; // 2000
			if (1.0e-4*fabs(delta075) < epsilon75) {
				epsilon75 = 1.0e-4*fabs(delta075);
			}
			epsilon75 = 1.0e-16;
			iN75 = 8; // Обязательное минимально необходимое число итераций.
			if (iflag175 == 1) {
				iflag75 = 1;
			}

		}

		// Если число расходимостей превысит оговорённую константу то произойдёт выход из алгоритма.
		integer i_signal_break_pam_opening75 = 0;
		// x хорошее значение.
		const integer i_limit_signal_pam_break_opening75 = 4000;//20
		doublereal delta_old_iter75 = 1.0e10;

		integer count_iter_for_film_coef75 = 0;


		// Мы обязательно должны сделать несколько итераций. (не менее 10).
		// Если только решение не удовлетворяет уравнению тождественно.
		while (((icount75 < iN75) && (iflag175 != 0)) || (iflag75 != 0 && icount75 < maxit75)) {
		
			// 6.01.2017: Body BiCGStab + AMG. (BiCGStab_internal4).


			icount75++;

			count_iter_for_film_coef75++;
			// В случае задачи Ньютона - Рихмана, Стефана-Больцмана и миксового условия не итерируем до конца обрываем, 
			// т.к. нам требуется частая пересборка матрицы. 13 марта 2016.
			//if (((adiabatic_vs_heat_transfer_coeff > ADIABATIC_WALL_BC) || (breakRUMBAcalc_for_nonlinear_boundary_condition)) && (count_iter_for_film_coef75>5)) break;

			roi75 = Scal(roc75, ri75, n75);
			bet75 = (roi75 / roim175)*(al75 / wi75);
			

			//printf("%e %e %e %e\n",roi75,roim175,al75,wi75);
			//getchar();

#pragma omp parallel for 
			for (i75 = 0; i75<n75; i75++) {
				doublereal pibuf75 = ri75[i75] + (pi75[i75] - vi75[i75] * wi75)*bet75;
				pi75[i75] = pibuf75;
			}

			// Первое предобуславливание.
			// Ky=pi
#pragma omp parallel for
			for (i75 = 0; i75 < n75; i75++) {
				y75[i75] = 0.0; // Если начинать не с нуля то небудет сходимости для PAM !.
				y76[i75 + 1] = 0.0;
				pi76[i75 + 1] = pi75[i75];
			}

			// multigrid RUMBA preconditioner
			// TODO begin
			// Вставлено 6.01.2017 begin
			// одного V цикла недостаточно.
			// A*y76=pi76;
			V_cycle_solve<doublerealT>(Amat, y76, pi76, process_flow_logic, row_ptr_start,
				row_ptr_end, residual_fine, diag, n_a, bonly_serial,
				process_flow_beta, F_false_C_true, nu1, nu2, bILU2smoother,
				ilevel, inumberVcyclelocbicgstab, imyinit, idim_diag, milu2, milu0, nested_desection,
				R, P, nnz_aRP, flag, residual_coarse, igam, nnz_a,
				error_approx_coarse, dapply_ilu_max_pattern_size,
				process_flow_alpha,
				error_approx_fine, nFinestSweeps);
			// TODO end
			// Вставлено 6.01.2017 end

			// Возвращение результата.
#pragma omp parallel for
			for (i75 = 0; i75 < n75; i75++) {
				y75[i75] = y76[i75 + 1];
			}

			MatrixCRSByVector(val75, col_ind75, row_ptr75, y75, vi75, n75); // vi==A*y;

			if ((fabs(roi75)<1e-30) && (fabs(Scal(roc75, vi75, n75))<1e-30)) {
				al75 = 1.0;
			}
			else if (fabs(roi75)<1e-30) {
				al75 = 0.0;
			}
			else {
				al75 = roi75 / Scal(roc75, vi75, n75);
			}

			
#pragma omp parallel for
			for (i75 = 0; i75<n75; i75++) {
				s75[i75] = ri75[i75] - al75*vi75[i75];
			}

			// Второе предобуславливание.
			// Kz=s

#pragma omp parallel for
			for (i75 = 0; i75<n75; i75++) z75[i75] = 0.0; // Если начинать не с нуля то небудет сходимости для PAM !.

#pragma omp parallel for
			for (i75 = 0; i75 < n75; i75++) {
				vec75[i75] = s75[i75];
			    z76[i75 + 1] = 0.0;
				s76[i75 + 1] = s75[i75];
			}

			// multigrid RUMBA preconditioner
			// Вставлено 6.01.2017 begin
			// одного V цикла недостаточно.
			// A*z76=s76;
			V_cycle_solve<doublerealT>(Amat, z76, s76, process_flow_logic, row_ptr_start,
				row_ptr_end, residual_fine, diag, n_a, bonly_serial,
				process_flow_beta, F_false_C_true, nu1, nu2, bILU2smoother,
				ilevel, inumberVcyclelocbicgstab, imyinit, idim_diag, milu2, milu0, nested_desection,
				R, P, nnz_aRP, flag, residual_coarse, igam, nnz_a,
				error_approx_coarse, dapply_ilu_max_pattern_size,
				process_flow_alpha,
				error_approx_fine, nFinestSweeps);
			// Вставлено 6.01.2017 end

#pragma omp parallel for
			for (i75 = 0; i75 < n75; i75++) {
				s75[i75] = vec75[i75];
				// Возвращаем результат.
				z75[i75] = z76[i75 + 1];
			}

			MatrixCRSByVector(val75, col_ind75, row_ptr75, z75, t75, n75); // t==A*z;

			wi75 = Scal(t75, s75, n75) / Scal(t75, t75, n75);
			// printf("%e %e",Scal(t75,s75,n75),Scal(t75,t75,n75));

#pragma omp parallel for
			for (i75 = 0; i75<n75; i75++) {
				//dx75[i75]+=al75*pi75[i75]+wi75*s75[i75]; // так было без предобуславливателя
				dx75[i75] += al75*y75[i75] + wi75*z75[i75]; // так стало с предобуславливателем
				ri75[i75] = s75[i75] - wi75*t75[i75];
			}
			deltai75 = NormaV(ri75, n75);

			//printf("deltai75=%e\n",deltai75); getchar();

			// печать невязки на консоль
			if (bprint_mesage_diagnostic) {
				if ((icount75 % 10) == 0) {
					std::cout << "iter  residual" << std::endl;					
				}
				std::cout << icount75 <<" "<< deltai75 << std::endl;				
			}

			// 28.07.2016.
			//std::cout << icount75 <<" " << deltai75 << std::endl;
			
			//getchar();
			if (deltai75 > delta_old_iter75) i_signal_break_pam_opening75++;
			delta_old_iter75 = deltai75;
			if (iVar == PAM) {
				if (i_signal_break_pam_opening75 > i_limit_signal_pam_break_opening75) {
					// досрочный выход из цикла.
					std::cout << "icount PAM="<< icount75<< std::endl;					
					break;
				}
			}

			if (deltai75 <epsilon75) iflag75 = 0; // конец вычисления
			else roim175 = roi75;

			if (iVar == TEMP) {
#if doubleintprecision == 1
				//printf("epsilon=%e deltai=%e icount=%lld\n",epsilon75,deltai75, icount75);
#else
				//printf("epsilon=%e deltai=%e icount=%d\n",epsilon75,deltai75, icount75);
#endif
				
				//getchar();
			}

			icount_V_cycle = icount75; // количество итераций в BiCGStabP для лога.

			if (icount75 > 2600) break; // 15.02.2017

		}

		// Возвращение результата вычислений.
#pragma omp parallel for
		for (i75 = 0; i75 < n75; i75++) {
			x[i75 + 1] = dx75[i75];
			x_best_search[i75 + 1] = dx75[i75];
		}

		// Освобождение оперативной памяти.
		// Первое предобуславливание
		if (pi76 != nullptr) {
			delete[] pi76;
			pi76 = nullptr;
		}
		if (y76 != nullptr) {
			delete[] y76;
			y76 = nullptr;
		}
		// Второе предобуславливание
		if (z76 != nullptr) {
			delete[] z76;
			z76 = nullptr;
		}
		if (s76 != nullptr) {
			delete[] s76;
			s76 = nullptr;
		}
		if (ri75 != nullptr) {
			delete[] ri75;
			ri75 = nullptr;
		}
		if (roc75 != nullptr) {
			delete[] roc75;
			roc75 = nullptr;
		}
		if (s75 != nullptr) {
			delete[] s75;
			s75 = nullptr;
		}
		if (t75 != nullptr) {
			delete[] t75;
			t75 = nullptr;
		}
		if (vec75 != nullptr) {
			delete[] vec75;
			vec75 = nullptr;
		}
		if (vi75 != nullptr) {
			delete[] vi75;
			vi75 = nullptr;
		}
		if (pi75 != nullptr) {
			delete[] pi75;
			pi75 = nullptr;
		}
		if (dx75 != nullptr) {
			delete[] dx75;
			dx75 = nullptr;
		}
		if (dax75 != nullptr) {
			delete[] dax75;
			dax75 = nullptr;
		}
		if (y75 != nullptr) {
			delete[] y75;
			y75 = nullptr;
		}
		if (z75 != nullptr) {
			delete[] z75;
			z75 = nullptr;
		}

		// Освобождение оперативной памяти.
		if (val75 != nullptr) {
			delete[] val75;
			val75 = nullptr;
		}
		if (col_ind75 != nullptr) {
			delete[] col_ind75;
			col_ind75 = nullptr;
		}
		if (row_ptr75 != nullptr) {
			delete[] row_ptr75;
			row_ptr75 = nullptr;
		}

	}
	else
	{   //  09.01.2018
		// Рекомендуется использовать гибридную точность: двойную для FGMRES и одинарную для предобуславливания с помощью V - цикла.
	    // FGMRes if (my_amg_manager.istabilization == 2)
	    // Гибкий вариант обобщённого метода минимальных невязок в котором на каждой итерации
	    // однократно применяется многосеточный предобуславливатель. Алгорим Саада и Шульца 1986 года.

		integer inumberVcyclelocbicgstab = 1;

		// нумерация векторов начинается с нуля.
		integer n75 = n_a[0]; // число неизвестных на подробном уровне.
		doublereal* val75 = nullptr;
		val75 = new doublereal[nnz_a[0]];
		integer* col_ind75 = nullptr;
		col_ind75 = new integer[nnz_a[0]];
		integer* row_ptr75 = nullptr;
		row_ptr75 = new integer[n_a[0] + 1];
		if ((val75 == nullptr) || (col_ind75 == nullptr) || (row_ptr75 == nullptr)) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for val, col_ind or row_ptr: bicgStab + camg...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}
		// инициализация матрицы.
		/*
		for (integer i_1 = 1; i_1 <= n_a[0]; i_1++) {
		val75[row_ptr_start[i_1] - 1] = diag[0][Amat[row_ptr_start[i_1]].i];
		col_ind75[row_ptr_start[i_1] - 1] = Amat[row_ptr_start[i_1]].i-1;
		for (integer i_2 = row_ptr_start[i_1] + 1; i_2 <= row_ptr_end[i_1]; i_2++) {
		val75[i_2 - 1] = Amat[i_2].aij;
		col_ind75[i_2 - 1] = Amat[i_2].j-1;
		}
		row_ptr75[i_1 - 1] = row_ptr_start[i_1] - 1;
		}
		*/
		// инициализация матрицы.
#pragma omp parallel for
		for (integer i_1 = 1; i_1 <= n_a[0]; i_1++) {

			for (integer i_2 = row_ptr_start[i_1]; i_2 <= row_ptr_end[i_1]; i_2++) {
				if (Amat[i_2].i == Amat[i_2].j) {
					if (i_1 != Amat[i_2].i) {
						printf("err i!=i\n");
						system("PAUSE");
					}
					val75[i_2 - 1] = diag[0][i_1];
					col_ind75[i_2 - 1] = i_1 - 1;
				}
				else {
					val75[i_2 - 1] = Amat[i_2].aij;
					col_ind75[i_2 - 1] = Amat[i_2].j - 1;
				}
			}
			row_ptr75[i_1 - 1] = row_ptr_start[i_1] - 1;
		}
#if doubleintprecision == 1
		//printf("nnz=%lld rpe=%lld rps=%lld\n",nnz_a[0], row_ptr_end[n_a[0]], row_ptr_start[n_a[0]+1]-1);
#else
		//printf("nnz=%d rpe=%d rps=%d\n",nnz_a[0], row_ptr_end[n_a[0]], row_ptr_start[n_a[0]+1]-1);
#endif

		//system("PAUSE");
		row_ptr75[n_a[0]] = row_ptr_end[n_a[0]];


		bool bnorelax = true; // Для уравнения теплопроводности не используется релаксация.
		integer m_restart = my_amg_manager.m_restart;

		doublereal resid;
		integer i, j = 1, k;
		//Vector s(m + 1), cs(m + 1), sn(m + 1), w;
		doublereal* w = new doublereal[n75];
		doublereal* s = new doublereal[m_restart + 2];
		doublereal* cs = new doublereal[m_restart + 2];
		doublereal* sn = new doublereal[m_restart + 2];

		doublereal *dx = new doublereal[n75];
		doublereal *buffer = new doublereal[n75];
		doublereal *Zcopy = new doublereal[n75 + 1];
		doublereal *vCopy = new doublereal[n75 + 1];

		// A*x=b, x - решение, b - правая часть. 
		// Индексация в х и b начинается с единицы.

		// начальное приближение
		for (i = 0; i<n75; i++) dx[i] = x[i + 1];


		//doublereal normb = norm(M.solve(b));
		doublereal normb = 0.0;
		// здесь реализованы все три нормы
		// вообще говоря они все эквивалентны



		normb = NormaV_for_gmres(&b[1], n75);
		//normb = NormaV(buffer, n75);

		//Vector r = &b[1] - A * x;
		doublereal *r = new doublereal[n75];
		MatrixCRSByVector(val75, col_ind75, row_ptr75, dx, r, n75); // результат занесён в  r
		for (i = 0; i < n75; i++) r[i] = b[i + 1] - r[i];

		//  calculate residual precontidioning;


		//doublereal beta = norm(r);
		doublereal beta = 0.0;



		beta = NormaV_for_gmres(r, n75);

		if (fabs(normb) < 1.0e-30)
			normb = 1;

		doublereal norm_r = 0.0;


		norm_r = NormaV_for_gmres(r, n75);

		integer maxit = 2000;

		if ((resid = norm_r / normb) <= dterminatedTResudual) {
			//tol = resid;
			maxit = 0;
			return 0;
		}

		//integer i_1 = 0; // счётчик цикла for

		doublereal** H = new doublereal*[m_restart + 2]; // Hessenberg
		for (integer i_1 = 0; i_1 < m_restart + 2; i_1++) H[i_1] = new doublereal[m_restart + 2];


		for (integer i_1 = 0; i_1 < m_restart + 2; i_1++)
		{
			for (integer j_1 = 0; j_1 < m_restart + 2; j_1++)
			{
				H[i_1][j_1] = 0.0;
			}
		}

		//Vector *v = new Vector[m_restart + 1];
		doublereal** v = new doublereal*[m_restart + 2];
		for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) v[i_1] = new doublereal[n75];


		for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) {
			for (integer j_1 = 0; j_1 < n75; j_1++)
			{
				v[i_1][j_1] = 0.0;
			}
		}

		doublereal** Z = new doublereal*[m_restart + 2];
		for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) Z[i_1] = new doublereal[n75];

		for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) {
			for (integer j_1 = 0; j_1 < n75; j_1++)
			{
				Z[i_1][j_1] = 0.0;
			}
		}

		j = 1; // номер первой итерации
	    //doublereal delta = 1.0e-3;// DOPOLNENIE

		integer i_copy;

		while (j <= maxit) {

			//v[0] = r * (1.0 / beta);    // ??? r / beta
			for (integer j_1 = 0; j_1 < n75; j_1++)
			{
				v[0][j_1] = r[j_1] * (1.0 / beta);
			}

			//s = 0.0;
			for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) s[i_1] = 0.0;
			s[0] = beta;
			//s[0] = 1.0;


			for (integer i_1 = 0; i_1 < m_restart + 2; i_1++)
			{ // DOPOLNENIE
				for (integer j_1 = 0; j_1 < m_restart + 2; j_1++)
				{
					H[i_1][j_1] = 0.0;
				}
			}


			// Ортогонализация Арнольди.
			for (i = 0; i < m_restart && j <= maxit; i++, j++) {

				i_copy = i;


				// KZ[i]=v[i]

				// (LU)Z[i]=v[i];

				// multigrid Ruge and Stuben preconditioning [1986].
				// достаточно одного V цикла.
				// K*Z = v;
				for (integer i_1 = 0; i_1 < n75; i_1++) {
					Zcopy[i_1 + 1] = 0.0;
					vCopy[i_1 + 1] = v[i][i_1];
				}

				// Предобуславливание с помощью V цикла многосеточного метода.
				// Нулевое начальное приближение
				for (integer i_numberV_cycle = 0; i_numberV_cycle < 1; i_numberV_cycle++) {
					// достаточно одного V цикла.
					// A*Zcopy=vCopy;
					// В Zcopy и vCopy нумерация начинается с единицы.
					V_cycle_solve<doublerealT>(Amat, Zcopy, vCopy, process_flow_logic, row_ptr_start,
						row_ptr_end, residual_fine, diag, n_a, bonly_serial,
						process_flow_beta, F_false_C_true, nu1, nu2, bILU2smoother,
						ilevel, inumberVcyclelocbicgstab, imyinit, idim_diag, milu2, milu0, nested_desection,
						R, P, nnz_aRP, flag, residual_coarse, igam, nnz_a,
						error_approx_coarse, dapply_ilu_max_pattern_size,
						process_flow_alpha,
						error_approx_fine, nFinestSweeps);
					//getchar();
				}

				for (integer i_1 = 0; i_1 < n75; i_1++) {
					Z[i][i_1] = Zcopy[i_1 + 1];
				}
				

				// Совсем без предобуславливателя.
				//for (i_1 = 0; i_1 < n75; i_1++) Z[i][i_1] = v[i][i_1];

				// закомментировано без предобуславливания.
				//w = A * Z[i];
				MatrixCRSByVector(val75, col_ind75, row_ptr75, Z[i], w, n75); // результат занесён в  w

				for (k = 0; k <= i; k++) {
					H[k][i] = Scal(w, v[k], n75);

					for (integer j_1 = 0; j_1 < n75; j_1++)
					{
						w[j_1] -= H[k][i] * v[k][j_1];
					}
				}
				H[i + 1][i] = NormaV_for_gmres(w, n75);



				for (integer j_1 = 0; j_1 < n75; j_1++)
				{
					v[i + 1][j_1] = w[j_1] * (1.0 / H[i + 1][i]); // ??? w / H(i+1, i)
				}
				// Окончание ортогонализации Арнольди.
				// В v - хранится ортонормированный базис подпространства Крылова размерности m_restart.
				// H - Верхнетреугольная матрица Хессенберга - матрица коэффициентов ортогонализации.


				// 26.11.2017
				// Это проверенный и испытанный кусок кода.
				for (k = 0; k < i; k++)
					ApplyPlaneRotation(H[k][i], H[k + 1][i], cs[k], sn[k]);

				GeneratePlaneRotation(H[i][i], H[i + 1][i], cs[i], sn[i]);
				ApplyPlaneRotation(H[i][i], H[i + 1][i], cs[i], sn[i]);
				ApplyPlaneRotation(s[i], s[i + 1], cs[i], sn[i]);



				// Вручную устраняем случай полного совпадения невязок на двух соседних итерациях,
				// т.к. иначе это приводит к развалу решения.
				//if (fabs(s[i] - s[i + 1]) < 1.0e-37) s[i + 1] = 1.05*s[i];

				printf("%lld %e \n", j, fabs(s[i + 1]) / normb);
				//printf("%d %e \n", j, beta*fabs(s[i + 1]));
				//getchar();

				resid = fabs(s[i + 1]) / normb;
				//resid = beta*fabs(s[i + 1]);

				if ((resid) < dterminatedTResudual) {
					printf("dosrochnji vjhod\n");
					//getchar();				
					Update(dx, i, n75, H, s, Z);
					//tol = resid;
					//maxit = j;

					for (integer i_1 = 0; i_1<n75; i_1++) {
						x[i_1 + 1] = dx[i_1];
						x_best_search[i_1 + 1] = dx[i_1];
					}

					for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) delete[] v[i_1];
					delete[] v;
					for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) delete[] Z[i_1];
					delete[] Z;
					for (integer i_1 = 0; i_1 < m_restart + 2; i_1++) delete[] H[i_1];
					delete[] H;
					delete[] dx;
					delete[] buffer;
					delete[] r;
					delete[] w;
					delete[] s;
					delete[] cs;
					delete[] sn;
					delete[] Zcopy;
					delete[] vCopy;

					// Освобождение оперативной памяти.
					if (val75 != nullptr) {
						delete[] val75;
						val75 = nullptr;
					}
					if (col_ind75 != nullptr) {
						delete[] col_ind75;
						col_ind75 = nullptr;
					}
					if (row_ptr75 != nullptr) {
						delete[] row_ptr75;
						row_ptr75 = nullptr;
					}

					goto LABEL_FGMRES_CONTINUE;

				}
			}



			// i-1 -> m_restart-1
			Update(dx, i - 1, n75, H, s, Z);//i-1 //ERROR

			//r = M.solve(b - A * x);
			MatrixCRSByVector(val75, col_ind75, row_ptr75, dx, r, n75); // Результат занесён в r
			for (integer  i_1 = 0; i_1 < n75; i_1++) r[i_1] = b[i_1 + 1] - r[i_1];

			//beta = norm(r);
			beta = NormaV_for_gmres(r, n75);

			resid = beta / normb;
			//resid = beta;

			if ((resid) < dterminatedTResudual) {
				//tol = resid;
				//maxit = j;

				printf("end\n");
				//getchar();

				for (integer i_1 = 0; i_1 < n75; i_1++) {
					x[i_1 + 1] = dx[i_1];
					x_best_search[i_1 + 1] = dx[i_1];
				}

				for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) delete[] v[i_1];
				delete[] v;
				for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) delete[] Z[i_1];
				delete[] Z;
				for (integer i_1 = 0; i_1 < m_restart + 2; i_1++) delete[] H[i_1];
				delete[] H;
				delete[] dx;
				delete[] buffer;
				delete[] r;
				delete[] w;
				delete[] s;
				delete[] cs;
				delete[] sn;
				delete[] Zcopy;
				delete[] vCopy;

				// Освобождение оперативной памяти.
				if (val75 != nullptr) {
					delete[] val75;
					val75 = nullptr;
				}
				if (col_ind75 != nullptr) {
					delete[] col_ind75;
					col_ind75 = nullptr;
				}
				if (row_ptr75 != nullptr) {
					delete[] row_ptr75;
					row_ptr75 = nullptr;
				}

				goto LABEL_FGMRES_CONTINUE;


			}
		}

		//tol = resid;
		for (integer i_1 = 0; i_1<n75; i_1++) {
			x[i_1 + 1] = dx[i_1];
			x_best_search[i_1 + 1] = dx[i_1];
		}

		for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) delete[] v[i_1];
		delete[] v;
		for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) delete[] Z[i_1];
		delete[] Z;
		for (integer i_1 = 0; i_1 < m_restart + 2; i_1++) delete[] H[i_1];
		delete[] H;
		delete[] dx;
		delete[] buffer;
		delete[] r;
		delete[] w;
		delete[] s;
		delete[] cs;
		delete[] sn;
		delete[] Zcopy;
		delete[] vCopy;

		// Освобождение оперативной памяти.
		if (val75 != nullptr) {
			delete[] val75;
			val75 = nullptr;
		}
		if (col_ind75 != nullptr) {
			delete[] col_ind75;
			col_ind75 = nullptr;
		}
		if (row_ptr75 != nullptr) {
			delete[] row_ptr75;
			row_ptr75 = nullptr;
		}
		goto LABEL_FGMRES_CONTINUE;


	

	}

LABEL_FGMRES_CONTINUE:

	if (debug_reshime) system("pause");
	//system("pause");




	// Внимание: именно эта строчка обеспечивает сходимость.
#pragma omp parallel for
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x[i47] = x_best_search[i47];
	}

	identiti = true;
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		if (fabs(x[i47] - x_best_search_init[i47]) > 1e-5) {
			identiti = false;
		}
	}
	if (identiti) {
		if (iVar != TOTALDEFORMATIONVAR) {
			printf("identity situation\n");
			// если техника x_best_search вообще не дала результатов.
#pragma omp parallel for
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x[i47] = x_best_search2[i47];
			}
		}
	}

	// Метка к которой мы приходим если значение невязки превысило 1.0e7.
FULL_DIVERGENCE_DETECTED:

	// диагностическое сообщение какую переменную мы решаем.
	if (bprint_mesage_diagnostic) {
		switch (iVar) {
		case PAM: printf("PAM\n");  break;
		case VELOCITY_X_COMPONENT:  printf("VX\n"); break;
		case VELOCITY_Y_COMPONENT:  printf("VY\n"); break;
		case VELOCITY_Z_COMPONENT:  printf("VZ\n"); break;
		case TEMP:  printf("TEMP\n"); break;
		case TOTALDEFORMATIONVAR: printf("Stress system\n"); break;
		}
	}
	else {
#if doubleintprecision == 1
		//switch (iVar) {
		// Радиатор водяного охлаждения 3л/мин ilevel_VX_VY_VZ=10, ilevel_PAM=5 или 6.

		//case PAM: printf("PAM %lld %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel-2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]);  break;
		//case VX:  printf("VX %lld %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case VY:  printf("VY %lld %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case VZ:  printf("VZ %lld %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case TEMP:  printf("TEMP %lld %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case TOTALDEFORMATIONVAR:  printf("Stress system %lld %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//}
#else
		//switch (iVar) {
		// модуль ВУМ с радиатором жидкостного охлаждения ilevel_VX_VY_VZ=10, ilevel_PAM=5 или 6.

		//case PAM: printf("PAM %d %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel-2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]);  break;
		//case VX:  printf("VX %d %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case VY:  printf("VY %d %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case VZ:  printf("VZ %d %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case TEMP:  printf("TEMP %d %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case TOTALDEFORMATIONVAR:  printf("Stress system %d %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//}
#endif
		

#if doubleintprecision == 1
		switch (iVar) {
			// модуль ВУМ с радиатором жидкостного охлаждения ilevel_VX_VY_VZ=10, ilevel_PAM=5 или 6.

		case PAM: printf("PAM level=%lld  CopA=%1.2f CopP=%1.2f nV=%lld res0=%e %lld %lld %lld\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]);  break;
		case VELOCITY_X_COMPONENT:  printf("VX level=%lld CopA=%1.2f CopP=%1.2f nV=%lld res0=%e %lld %lld %lld\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VELOCITY_Y_COMPONENT:  printf("VY level=%lld CopA=%1.2f CopP=%1.2f nV=%lld res0=%e %lld %lld %lld\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VELOCITY_Z_COMPONENT:  printf("VZ level=%lld CopA=%1.2f CopP=%1.2f nV=%lld res0=%e %lld %lld %lld\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case TEMP:  printf("TEMP level=%lld CopA=%1.2f CopP=%1.2f nV=%lld res0=%e %lld %lld %lld\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case TOTALDEFORMATIONVAR:  printf("Stress system level=%lld CopA=%1.2f CopP=%1.2f nV=%lld res0=%e %lld %lld %lld\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		}
#else
		switch (iVar) {
			// модуль ВУМ с радиатором жидкостного охлаждения ilevel_VX_VY_VZ=10, ilevel_PAM=5 или 6.

		case PAM: printf("PAM level=%d  CopA=%1.2f CopP=%1.2f nV=%d res0=%e %d %d %d\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]);  break;
		case VELOCITY_X_COMPONENT:  printf("VX level=%d CopA=%1.2f CopP=%1.2f nV=%d res0=%e %d %d %d\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VELOCITY_Y_COMPONENT:  printf("VY level=%d CopA=%1.2f CopP=%1.2f nV=%d res0=%e %d %d %d\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VELOCITY_Z_COMPONENT:  printf("VZ level=%d CopA=%1.2f CopP=%1.2f nV=%d res0=%e %d %d %d\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case TEMP:  printf("TEMP level=%d CopA=%1.2f CopP=%1.2f nV=%d res0=%e %d %d %d\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case TOTALDEFORMATIONVAR:  printf("Stress system  level=%d CopA=%1.2f CopP=%1.2f nV=%d res0=%e %d %d %d\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		}
#endif
	
	}
	//getchar();

	// free
	if (x_best_search2 != nullptr) {
		delete[] x_best_search2;
		x_best_search2 = nullptr;
	}
	if (x_best_search_init != nullptr) {
		delete[] x_best_search_init;
		x_best_search_init = nullptr;
	}
	
	
	// free	
	if (bnested_desection_global_amg != nullptr) {
		free(bnested_desection_global_amg);  // Глобальная память.
		bnested_desection_global_amg = nullptr;
	}
	for (integer i_scan_levels = 0; i_scan_levels <= maxlevel-1; i_scan_levels++) {
		if (ilevel +1 > i_scan_levels) {
			// free
			if (i_scan_levels <= maxlevel - 1) {
				if (diag[i_scan_levels] != nullptr) {
					free(diag[i_scan_levels]);
					diag[i_scan_levels] = nullptr;
				}
				if (nested_desection[i_scan_levels] != nullptr) {
					free(nested_desection[i_scan_levels]);
					nested_desection[i_scan_levels] = nullptr;
				}
				integer i_scan_levels_prev = i_scan_levels - 1;
				if (i_scan_levels_prev >= 0) {
					if (error_approx_fine[i_scan_levels_prev] != nullptr) {
						free(error_approx_fine[i_scan_levels_prev]);
						error_approx_fine[i_scan_levels_prev] = nullptr;
					}
					if (error_approx_coarse[i_scan_levels_prev] != nullptr) {
						free(error_approx_coarse[i_scan_levels_prev]);
						error_approx_coarse[i_scan_levels_prev] = nullptr;
					}
					if (residual_coarse[i_scan_levels_prev] != nullptr) {
						free(residual_coarse[i_scan_levels_prev]);
						residual_coarse[i_scan_levels_prev] = nullptr;
					}
				}
				if (residual_fine[i_scan_levels] != nullptr) {
					free(residual_fine[i_scan_levels]);
					residual_fine[i_scan_levels] = nullptr;
				}
			}
		}
	}
	

	// метод огрубления.
	my_amg_manager.icoarseningtype = memo_icoarseningtype;


	// Для ускорения паралельной версии пролонгации 1.08.2021.
	freeQuickProlongation();

	if (F_false_C_true != nullptr) {
		free(F_false_C_true);
		F_false_C_true = nullptr;
	}

	delete[] diag;
	diag = nullptr;
	
	delete[] nested_desection;
	nested_desection = nullptr;

//#ifdef	_NONAME_STUB29_10_2017
#ifdef _OPENMP
	// Освобождение озу ГУСТАВСОН умножение разреженных матриц.
	// Единожды!!!
	for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++) {
		free(vector_sum_m[i_9]);
		free(index_visit_m[i_9]);
		free(hash_table_m[i_9]);
	}
	delete[] vector_sum_m;
	delete[] index_visit_m;
	delete[] hash_table_m;
	delete[] index_size_m;
	vector_sum_m = nullptr;
	index_visit_m = nullptr;
	hash_table_m = nullptr;
	index_size_m = nullptr;

	for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++) {
		delete[] AccumulqtorA_m[i_9];
	}
	delete[] AccumulqtorA_m;
	AccumulqtorA_m = nullptr;
	delete[] istartAnew_m;
	istartAnew_m = nullptr;
#endif

	delete[] n_a;
	delete[] nnz_a;

	// освобождение оперативной памяти.
	free_level_additional_data(milu0, ilevel);
	free_level_additional_data(milu2, ilevel);

	// Освобождение общей памяти в ILU буффере.
	if (milu_gl_buffer.alu_copy != nullptr) delete[] milu_gl_buffer.alu_copy;
	if (milu_gl_buffer.jlu_copy != nullptr) delete[] milu_gl_buffer.jlu_copy;
	if (milu_gl_buffer.ju_copy != nullptr) delete[] milu_gl_buffer.ju_copy;
	milu_gl_buffer.alu_copy = nullptr;
	milu_gl_buffer.jlu_copy = nullptr;
	milu_gl_buffer.ju_copy = nullptr;

	//delete[] residual_fine[0];
	if (residual_fine[0] != nullptr) {
		free(residual_fine[0]);
		residual_fine[0] = nullptr;
	}

	
	delete[] residual_fine;
	residual_fine = nullptr;	

	delete[] error_approx_fine;
	error_approx_fine = nullptr;
	
	delete[] error_approx_coarse;
	error_approx_coarse = nullptr;
	

	delete[] residual_coarse;
	residual_coarse = nullptr;
	

	//delete[] row_ptr_start;
	//delete[] row_ptr_end;
	if (row_ptr_start != nullptr) {
		free(row_ptr_start);
		row_ptr_start = nullptr;
	}
	if (row_ptr_end != nullptr) {
		free(row_ptr_end);
		row_ptr_end = nullptr;
	}



	//delete[] flag_shadow;
	if (flag_shadow != nullptr) {
		free(flag_shadow);
		flag_shadow = nullptr;
	}


	//delete[] flag;
	if (flag != nullptr) {
		free(flag);
		flag = nullptr;
	}
	if (x_copy != nullptr) {
		free(x_copy);
		x_copy = nullptr;
	}
	if (x_old != nullptr) {
		free(x_old);
		x_old = nullptr;
	}
	if (x_best_search != nullptr) {
		free(x_best_search);
		x_best_search = nullptr;
	}

	// Для подстраховки:

	if (row_ptr_start != nullptr) {
		free(row_ptr_start);
		row_ptr_start = nullptr;
	}
	if (row_ptr_end != nullptr) {
		free(row_ptr_end);
		row_ptr_end = nullptr;
	}


	
	delete[] x_jacoby_buffer;
	x_jacoby_buffer = nullptr;
	

	if (btree_vs_hash == 1) {
		free_hash_table_Gus_struct01();
	}

	// Освобождение оперативной памяти.
	if (threshold_quick_all != nullptr) {
		free(threshold_quick_all);
		threshold_quick_all = nullptr;
	}

	if (threshold_quick_only_negative != nullptr) {
		free(threshold_quick_only_negative);
		threshold_quick_only_negative = nullptr;
	}

	//return false;
	return ret_value;

} // classic_aglomerative_amg4



// объявление функционала который потребуется уже здесь а реализован далее по коду.
void exporttecplotxy360T_3D_part2amg(doublereal* u, bool bextendedprint, integer imove);

// 25.04.2018 пятая версия classic_aglomerative_amg5 давно не поддерживается.
// Основная версия четыре classic_aglomerative_amg4.
// 4-6, 26 ноября 2016. Добавлен ILU0. Полностью удалён устаревший код из Solution Phase.
// 15 августа 2016. Черногория. Проблема нефизичных positive connections.
// 9 августа 2016. Зейдель не справляется с большими спектральными радиусами матриц даже в составе данного amg,
// это же проявляется и на классическом amg1r5. 9 августа решено уменьшить спектральный радиус в Зейделе 
// на каждом уровне вложенности с помощью ILU2 декомпозиции. Это подтверждает статья Е.М.Андреева, Г.В.Муратова
// "Многосеточный метод решения сильно нессиметричных систем" ЮГИНФО РГУ, Ростов-на-Дону, Россия. Там они
// показывают расходимость мультигрида на основе Зейделя для задач с существенным спектральным радиусом и
// рекомендуют заменить Зейделя на ТКМ2 метод (треугольный кососимметричный метод). В данной программе у нас есть 
// успешный опыт использования ILU2 предобуславливателя из библиотеки SPARSKIT2 Ю.Саада поэтому вместо ТКМ2 у нас 
// будет ILU2.
// 22 января текущий работоспособный вариант кода.
// Планы: 1. сделать версию amg3. 
// В ней: 2. заменить все проверки на невыделение оперативной памяти на универсальную функцию единую для всего.
// это очевидно немного сократит программный код.
// В ней 3. код V цикла оформить в виде цикла for. Тогда же можно будет попробовать вставить direct метод для самого грубого уровня.
// Это же откроет возможности сделать из amg алгоритма предобуславливатель для BiCGStab.
// 15 января экономим память переходим на Ak1.
// 10 января 2016 двоичный поиск заменён на хеширование.
// 15 декабря 2015. Данная версия кода будет полностью очищена от устаревшего кода.
// 13 декабря 2015. Внедрено АВЛ дерево. При внедрении АВЛ дерева исправлена логическая ошибка в
// построении С-F разбиения, теперь C/F разбиение строится корректно.
// Исправлен и внедрён quicksort (qs,qsj)
// который в рять раз быстрее пирамидальной сортировки.
// Полный отказ от band_size!!!.
// Время работы алгоритма на 1.7М неизвестных в 3D составило ровно 1 минуту.
// 18 октября 2015. Полностью работоспособный мультигрид.
// Тестировалось на условиях Дирихле но должно работать на любых 
// краевых задачах. 18 октября датируется версия 0.04. Версия 0.04 на треть
// быстрее версии 0.03. Были ускорены как операции построения C/F разбиения, 
// так и нахождение оператора Галёркина. При нахождении С/F разбиения 
// учитывается уже построенная его часть и поэтому число сканирований на
// на поздних циклах сокращается охватывая только не построенную часть.
// При нахождении произведения Галёркина получена самая оптимальная по быстродействию версия,
// Основанная на алгоритме слияния отсортированных списков.
// 4 октября правильное построение последовательности вложенных графов.
// 30 сентября продолжаем исправление метода. Делаем классический 
// алгебраический многосеточный метод на основе  C/F разбиения.
// 16 сентября 2015 года обнаружено что операции 
// сгрубления и интерполяции сделаны совершенно неверно,
// и если сгрубление еще в какой-то мере проецирует то интерполяция просто никакая.
// Операции сгрубления и интерполяции будут сделаны заново на основе статьи
// К.Н. Волкова в новой версии солвера.
// 3 september 2015 Villa Borgese.
// Возвращает divergence detected.
template <typename doublerealT>
bool classic_aglomerative_amg5(Ak1* &Amat,
	integer nsizeA, // количество ячеек выделенное извне для хранилища матриц А
	integer &nsizePR, // Память под P в количествах n.
	integer nnz, // number of non zero elements
	integer n, // dimension of vectors x and b.
	Ak1* &R, // restriction
	Ak1* &P, // prolongation
	doublereal* &x, doublereal* &b,
	bool* &bamg_bound, // true - граничный узел, false - внутренний.
	doublerealT &theta, doublerealT &theta83, doublerealT &magic82, doublerealT &magic83, doublerealT &ret74,
	integer iVar,
	bool bmemory_savings,
	INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14 imyinit = INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT
	) {

	// Для ускорения паралельной версии пролонгации 1.08.2021.
	initQuickProlongation(n);


	bfirst_jacoby_start = true;

	signal_omega_correct = false;

	// Универсальные сглаживающие процедуры. 4 ноября 2016.
	// ILU2 smoother
	// 0 - ILU не используется. используется Gaus-Seidel.
	// 1 - ILU0 используется.
	// 2 - ILU2 используется.
	integer bILU2smoother = 0;
	if (my_amg_manager.ilu2_smoother == 1) {
		// Включаем ILU0 сглаживатель. 
		// он ест больше памяти но более быстро сходится.
		// Есть надежда что он справится с гораздо более плохообусловленными матрицами.

		bILU2smoother = 1; // ILU0

						   // По - видимому алгоритм 
						   // ilu0_(maxelm_plus_maxbound, milu0.val, milu0.col_ind, milu0.row_ptr, milu0.alu, milu0.jlu, milu0.ju, milu0.iw, ierr);
						   // является дефектным. Я не получил с ним сходимости как ни пытался. Зато алгоритм iluk с lfil=0 проявил себя наилучшим 
						   // образом и я его рекомендую к использованию. Это реализовано в ветке кода my_amg_manager.ilu2_smoother == 2.
						   // Причём iluk с lfil=0 работает на всех уровнях и прекрасно себя провляет.

						   // Перенаправление.
		bILU2smoother = 2; // ILU0
	}
	if (my_amg_manager.ilu2_smoother == 2) {
		// Включаем ILU2 сглаживатель. 
		// он ест больше памяти но более быстро сходится.

		// Его рекомендуется применять только для исходной матрицы - уровень ноль.
		// Если его применять на более глубоких уровнях то сходимость лишь замедляется.

		bILU2smoother = 2; // ILU2

						   // ILU2 ест слишком много оперативной памяти и я его заменил на ILU0 сглаживатель на каждом уровне: iluk с lfil=0.
						   // Возможно я ещё вернусь к ilu2 хотябы на нулевом уровне, т.к. там он особенно хорош.
	}
	//bILU2smoother = 0; // only seidel sor smoother.
		
	

	// Параметры отвечающие за автоматическую настройку SOR.
	// По трём точкам мы построим параболу и на её основе 
	// спрогнозируем улучшенный параметр релаксации omega_optimal.
	// Парабола представляется намного лучшей чем простая линейная экстрополяция.
	bproblem_amg_convergence1 = false;
	bproblem_amg_convergence2 = false;
	bproblem_amg_convergence3 = false;
	gold_const = 0.2;

	bool bprint_mesage_diagnostic = true;
	if (bSIMPLErun_now_for_temperature) {
		// Решаем cfd задачи.
		bprint_mesage_diagnostic = false;
	}

	if (my_amg_manager.iprint_log == 0) {
		bprint_mesage_diagnostic = false;
	}

	const integer AVL_TREE_ID = 0;
	const integer SPLAY_TREE_ID = 1;
	integer id_tree = SPLAY_TREE_ID;


	// Для вычисления grid complexity оператора интерполяции:
	integer nnz_P_memo_0 = 0;
    integer nnz_P_memo_all = 0;

	// Надо заменить все new на malloc.
	//theta = 0.25;

	bool bonly_serial = true;
//#ifdef _OPENMP
	//omp_set_num_threads(2);
//#endif

	// barjer=0.0001; optimum. для 1M задач.
	// Для зачачи с 3.2M неизвестных (теплопередача в 5mm СВЧ транзисторе без дырок.)
	// для константы 1.0e-8 получено сокращение времени счёта с 9мин до 4мин (Количество итераций 213 вместо 1003).
	// Пик использования оперативной памяти при этом приложению составил 2373Мб.
	// Для BiCGStab+ILU2 время счёта равно 1мин 50с против 4мин в данной версии алгоритма.
	// 14 января 2016 подобраны оптимальными и равными 1e-7 каждый.
	// 23 10 2016 первый барьер полностью отключен.
	doublerealT barjer = (doublerealT)(1.0e-7); // 1.0e-7 
	// 22 10 2016. Второй барьер можно использовать и у него большой потенциал,
	// но надо им правильно пользоваться в соответствии с теорией, это не просто импирическое изменение константы.
	// Если барьер А не используется то его значение отрицательно.
	// значение без барьера А называется мультигридом Галёркина.
	doublerealT barjerA = (doublerealT)(-1.0e-7); // 1.0e-7

	//if (iVar == PAM) {
	//barjer = 1.0e-10; // 1.0e-7 
	//barjerA = 1.0e-10; // 1.0e-7
	//}

	// контроль числа сильных связей между переменными.
	// doublerealT theta = 0.25;  // 0.25 for 2D and 0.5 for 3D 

	// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
	// В компиляторе надо увеличить размер стека до 4Мб.
	// Если bqs == false то используется пирамидальная сортировка.
	bool bqs = false; // Использовать ли quicksort qs and qsj.
	// Сортировка с подсчётом быстрее quickSort.
	bool bCounting_Sort = true; // Использовать ли сортировку подсчётом которая потребляет килотонну памяти (Короче для машин у которых море оперативки).


	const doublereal RealZERO = 1.0e-300;// 1.0e-10;
	const doublereal divisionZERO = 1.0e-300;
	const doublereal RealMAXIMUM = 1.0e300;
	// включение/отключение отладочного режима.
	bool debug_reshime = false;

	const integer max_neighbour = 27850;
	// Мы будем поддерживать информацию о максимальном количестве соседей.
	integer Maximumneighbourcount = -1;
	// мы получим порядковый номер элемента с максимальным число соседей в матрице А,
	// прямо в результате построения C/F разбиения.
	bool bmaxneighbourinfoactive = false;


	// Возможно можно обойтись без ji связи.
	// 17 dec 2015 эксперимент показывает что можно обойтись без учёта ji связи.
	// false без связи. Если false то Atemp вообще ненужен.
	bool bji = false;
	Ak1* Atemp = nullptr;
	if (bji) {
		Atemp = new Ak1[3 * nnz + 1];
	}

	// нумерация начинается с единицы.

	const integer maxlevel = 30;
	integer ilevel = 1;
	integer nnz_a[maxlevel];
	integer n_a[maxlevel];
	nnz_a[0] = nnz;
	n_a[0] = n;
	//bool* flag = new bool[n + 1];
	bool* flag = nullptr;
	flag = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(flag, "flag", "classic_aglomerative_amg_5", (n + 1));
	bool* flag85 = nullptr;
	flag85 = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(flag85, "flag", "classic_aglomerative_amg_5", (n + 1));
	
	

	//bool* flag_shadow = new bool[n + 1];
	bool* flag_shadow = nullptr;
	flag_shadow = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(flag_shadow, "flag_shadow", "classic_aglomerative_amg_5", (n + 1));

	//bool* hash_table = new bool[nnz + 1]; // Огромного размера hash таблица.
	bool* hash_table = nullptr;
	hash_table = (bool*)malloc((nnz + 1) * sizeof(bool));
	handle_error<bool>(hash_table, "hash_table", "classic_aglomerative_amg_5", (nnz + 1));

	// Огромный размер поэтому инициализация делается лишь единожды.
	for (integer isc = 0; isc <= nnz; isc++) hash_table[isc] = false; // initialization 
	const integer istack_size_limit = n + 1; // 128000
	//integer ipool[ipool_size_limit];
	integer* istack = nullptr;
	//istack = new integer[istack_size_limit];
	istack = (integer*)malloc((istack_size_limit)*sizeof(integer));
	handle_error<integer>(istack, "istack", "classic_aglomerative_amg_5", (istack_size_limit));

	// Для построения C/F декомпозиции нам тоже потребуется хеш-таблица
	// и стек для очистки хеш-таблицы.
	bool* hash_table2 = nullptr;
	hash_table2 = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(hash_table2, "hash_table2", "classic_aglomerative_amg_5", (n + 1));

	// Инициализация.
	for (integer isc = 0; isc <= n; isc++) hash_table2[isc] = false;
	// И теперь стек для очистки хеш-таблицы.
	integer* istack2 = nullptr;
	//istack2 = new integer[n + 1];
	istack2 = (integer*)malloc((n + 1)*sizeof(integer));
	handle_error<integer>(istack2, "istack2", "classic_aglomerative_amg_5", (n + 1));

	integer iadd = 0;
	integer nnzR = 1;
	integer iaddR = 0;
	integer nnz_aRP[maxlevel];
	
	//bool* this_is_C_node = new bool[n + 1];
	//bool* this_is_F_node = new bool[n + 1];
	bool* this_is_C_node = nullptr;
	this_is_C_node = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(this_is_C_node, "this_is_C_node", "classic_aglomerative_amg_5", (n + 1));

	bool* this_is_F_node = nullptr;
	this_is_F_node = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(this_is_F_node, "this_is_F_node", "classic_aglomerative_amg_5", (n + 1));


	while ((ilevel < maxlevel - 1) && (n_a[ilevel - 1] > 50)) {


		/*
		hashlist** hash = new hashlist*[n_a[ilevel - 1]+1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hash[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].i;
		insertion_hash(hash[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hash[i_1]);
		hash[i_1] = 0;
		}
		delete[] hash;

		hashlist** hashj = new hashlist*[n_a[ilevel - 1] + 1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hashj[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].j;
		insertion_hash(hashj[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hashj[i_1]);
		hashj[i_1] = 0;
		}
		delete[] hashj;
		*/


		Maximumneighbourcount = -1;
		bmaxneighbourinfoactive = false;

		//if (ilevel > 1) {
		//if (n_a[ilevel - 2] == n_a[ilevel - 1]) break;
		//}

		if (ilevel > 10) {
			if (n_a[ilevel - 1] < 300) break;
		}

		if (ilevel > 1) {
			doublerealT procent = (doublerealT)((100.0*(abs(n_a[ilevel - 1] - n_a[ilevel - 2]))) / (1.0*n_a[ilevel - 2]));
			if (procent<2.0) break;
		}

		if (((ilevel > 1) && (nnz_a[ilevel - 1] > nnz_a[ilevel - 2]))) {
			//break;
		}

#if doubleintprecision == 1
		if (bprint_mesage_diagnostic) {
			// level info.
			if (ilevel == 2) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld nnz_a[0]=%lld nnz_a[1]=%lld iadd=%lld\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 3) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld iadd=%lld\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 4) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld n_a[3]=%lld \n", n_a[0], n_a[1], n_a[2], n_a[3]);
				printf("nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld nnz_a[3]=%lld iadd=%lld\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if (ilevel > 17) {
				printf("very big matrix (mesh). no programming.\n");
				system("pause");
				exit(1);
			}
		}
#else
		if (bprint_mesage_diagnostic) {
			// level info.
			if (ilevel == 2) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d nnz_a[0]=%d nnz_a[1]=%d iadd=%d\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 3) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d iadd=%d\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 4) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d n_a[3]=%d \n", n_a[0], n_a[1], n_a[2], n_a[3]);
				printf("nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d nnz_a[3]=%d iadd=%d\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if (ilevel > 17) {
				printf("very big matrix (mesh). no programming.\n");
				system("pause");
				exit(1);
			}
		}
#endif

		

		//nnzR = 1;

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		for (integer ii = n_a[ilevel - 1]+1; ii <= n; ii++) {
#if doubleintprecision == 1
			//printf("warning: n!=n_a[ilevel-1]: n=%lld, n_a=%lld, ilevel=%lld\n", n, n_a[ilevel - 1], ilevel);
#else
			//printf("warning: n!=n_a[ilevel-1]: n=%d, n_a=%d, ilevel=%d\n", n, n_a[ilevel - 1], ilevel);
#endif
			
			//getchar();
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		// Сортировка нужна лишь на первом уровне, т.к.
		// результат алгоритма перемножения по Густавсону уже 
		// даёт на выходе отсортированную по строкам матрицу.
		if (ilevel == 1) {
			// сортировка исходной  А  по i.
			//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);


			// 7 января 2016. Обязательно нужна эта сортировка.
			if (bqs) {
				if (bCounting_Sort) {
					Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, bmemory_savings, indx_comparei);
				}
				else {
					// quicksort
					qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, indx_comparei);
				}
			}
			else {
				HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd,comparei);
			}
			//QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}





		if (bji) {
			// Создаём копию в Atemp, копия будет отсортирована по j.
			for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
				Atemp[i_1 - iadd] = Amat[i_1];
			}
			// Сортируем копию по j.
			// Мы сортируем по j, чтобы потом быстро искать по j.
			if (bqs) {
				if (bCounting_Sort) {
					// Сортировка с подсчётом за линейное время.
					Counting_Sort(Atemp, 1, nnz_a[ilevel - 1], indx_comparej);
				}
				else {
					// Быстрая сортировка Чарльза Хоара.
					qs(Atemp, 1, nnz_a[ilevel - 1], indx_comparej);
				}
			}
			else {
				HeapSort(Atemp, 1, nnz_a[ilevel - 1], comparej);
			}
		}

		for (integer i_1 = 1; i_1 <= n; i_1++) {
			flag[i_1] = false;
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}

		// позиция начала каждой строки в матрице.
		integer* row_startA = nullptr;
		//row_startA = new integer[n_a[ilevel - 1] + 1];
		row_startA = (integer*)malloc((n_a[ilevel - 1] + 2)*sizeof(integer));
		handle_error<integer>(row_startA, "row_startA", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 2));

		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				flag[Amat[ii].i] = true;
				row_startA[Amat[ii].i] = ii;
			}
		}
		row_startA[n_a[ilevel - 1] + 1] = nnz_a[ilevel - 1] + iadd + 1; // заглушка на окончание матрицы.

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}


		// вычисляем для кадого узла число его соседей.
		integer* count_neighbour = nullptr;
		//count_neighbour = new integer[n_a[ilevel - 1] + 1];
		count_neighbour = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(count_neighbour, "count_neighbour", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			count_neighbour[ii] = 0; // нет соседей.
		}



		/*
		// При таком коде узел Дирихле тоже имеет соседа, сосед это
		// внутренний узел который связан с этим узлом Дирихле.
		// Соседей вычисляем на самой первой матрице А (самой левой).
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		if (flag[Amat[ii].i] == false) {
		integer ic = -1;
		integer cand[max_neighbour];
		if (0) {
		for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
		ic++; //i,j
		cand[ic] = Amat[is0].j;
		}
		}
		else {
		// 12 января 2016.
		// Учитываем только Strong соседей.
		doublerealT threshold = -1.0;
		for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
		if (Amat[is0].j != Amat[ii].i) {
		if (fabs(Amat[is0].aij) > threshold) {
		// Определяем максимальный внедиагональный элемент.
		threshold = fabs(Amat[is0].aij);
		}
		}
		}
		for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
		if (Amat[is0].j != Amat[ii].i) {
		if (fabs(Amat[is0].aij) > theta*threshold) {
		// Учитываем только сильно связанных соседей.
		ic++; //i,j
		cand[ic] = Amat[is0].j;
		}
		}
		}
		}
		integer len_neighbour = ic;
		// Найти столбец j который равен индексу Amat[ii].i
		//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
		//if (Amat[ii1].i != Amat[ii].i) {
		//	if (Amat[ii1].j == Amat[ii].i) {
		// j,i
		//		bool foundneighbour = false;
		//		for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
		//			if (Amat[ii1].j == cand[i_1]) foundneighbour = true;
		//		}
		//		if (!foundneighbour) {
		//			ic++;
		//			cand[ic] = Amat[ii1].j;
		//			len_neighbour++;
		//		}
		//	}
		//}
		//}
		if (bji) {
		// Ускоренная версия с бинарным поиском по j.
		integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
		for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == Amat[ii].i); ii1++) {
		if (Atemp[ii1].i != Amat[ii].i) {
		// j,i
		bool foundneighbour = false;
		for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
		if (Atemp[ii1].j == cand[i_1]) foundneighbour = true;
		}
		if (!foundneighbour) {
		ic++;
		cand[ic] = Atemp[ii1].j;
		len_neighbour++;
		}
		}
		}
		}


		count_neighbour[Amat[ii].i] = ic;
		if (ic > Maximumneighbourcount) {
		Maximumneighbourcount = ic;
		bmaxneighbourinfoactive = true;
		}
		flag[Amat[ii].i] = true;
		}
		}
		*/

		// При таком коде узел Дирихле тоже имеет соседа, сосед это 
		// внутренний узел который связан с этим узлом Дирихле.
		// Соседей вычисляем на самой первой матрице А (самой левой).
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer ic = -1;
				integer cand[max_neighbour];
				if (0) {
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						ic++; //i,j
						cand[ic] = Amat[is0].j;
					}
				}
				else {
					// 12 января 2016.
					// 12 февраля 2016. матрица отсортирована по i.
					// Учитываем только Strong соседей.
					doublerealT threshold = -1.0;
					for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii].i) {
							if (Amat[is0].aij < 0.0) {
								if (fabs(Amat[is0].aij) > threshold) {
									// Определяем максимальный внедиагональный элемент.
									threshold = fabs(Amat[is0].aij);
								}
							}
						}
					}
					for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii].i) {
							if (Amat[is0].aij < 0.0) {
								if (fabs(Amat[is0].aij) > theta*threshold) {
									// Учитываем только сильно связанных соседей.
									ic++; //i,j
									cand[ic] = Amat[is0].j;
								}
							}
						}
					}
				}
				integer len_neighbour = ic;
				// Найти столбец j который равен индексу Amat[ii].i
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//if (Amat[ii1].i != Amat[ii].i) {
				//	if (Amat[ii1].j == Amat[ii].i) {
				// j,i
				//		bool foundneighbour = false;
				//		for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
				//			if (Amat[ii1].j == cand[i_1]) foundneighbour = true;
				//		}
				//		if (!foundneighbour) {
				//			ic++;
				//			cand[ic] = Amat[ii1].j;
				//			len_neighbour++;
				//		}
				//	}
				//}
				//}
				if (bji) {
					// Ускоренная версия с бинарным поиском по j.
					integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
					for (integer ii1 = ii2; (ii1 <= row_startA[Amat[ii2].i + 1] - 1); ii1++) {
						if (Atemp[ii1].i != Amat[ii].i) {
							// j,i
							bool foundneighbour = false;
							for (integer i_1 = 0; i_1 <= len_neighbour; i_1++) {
								if (Atemp[ii1].j == cand[i_1]) foundneighbour = true;
							}
							if (!foundneighbour) {
								ic++;
								cand[ic] = Atemp[ii1].j;
								len_neighbour++;
							}
						}
					}
				}


				count_neighbour[Amat[ii].i] = ic;
				if (ic > Maximumneighbourcount) {
					Maximumneighbourcount = ic;
					bmaxneighbourinfoactive = true;
				}
				flag[Amat[ii].i] = true;
			}
		}



		integer maxneighbour = 0;
		integer icandidate = 0;
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}
		// Находим узел с наибольшим числом соседей и запоминаем его.
		// Это первый встретившийся узел с наибольшим числом соседей.
		/*
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		if (flag[Amat[ii].i] == false) {
		if (count_neighbour[Amat[ii].i] > maxneighbour) {
		maxneighbour = count_neighbour[Amat[ii].i];
		icandidate = ii;
		if (bmaxneighbourinfoactive) {
		// организуем досрочный выход из цикла for.
		// Это должно сильно сокращать количество сканирований.
		if (maxneighbour == Maximumneighbourcount) break;
		}
		}
		flag[Amat[ii].i] = true;
		}
		}
		*/
		for (integer i7 = 1; i7 <= n_a[ilevel - 1]; i7++) {
			if (count_neighbour[i7] > maxneighbour) {
				maxneighbour = count_neighbour[i7];
				icandidate = row_startA[i7];
				if (bmaxneighbourinfoactive) {
					// организуем досрочный выход из цикла for.
					// Это должно сильно сокращать количество сканирований.
					if (maxneighbour == Maximumneighbourcount) break;
				}
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}


		// нужно выделить кто попал в coarse, а кто в этот раз попал в Fine Выделить всех кто соседствует
		// с новыми Fine увеличить им счётчик соседей.

		integer n_coarce = 1; // начальный номер C узла.
		nnzR = 1;

		const integer NULL_NEIGHBOUR = -1;
		integer vacant = NULL_NEIGHBOUR;
		

		// Построение C/F разбиения.
		//while (icandidate != 0)
		integer icountprohod = 0;
		// Мы будем заоминать с какой позиции начинаются ещё не помеченные узлы,
		// это сократит количество перебираемых элементов в поиске узла с максимальным 
		// количеством соседей.
		//integer ibegining_start_index_found_maximum = 1 + iadd;
		// храним те узлы которые уже были пройдены при конструировании.
		bool *bmarkervisit = nullptr;
		//bmarkervisit = new bool[n + 1];
		bmarkervisit = (bool*)malloc((n + 1)*sizeof(bool));
		handle_error<bool>(bmarkervisit, "bmarkervisit", "classic_aglomerative_amg_5", (n + 1));

		// поначалу все узлы помечены как непосещенные.
		for (integer i_1 = 1; i_1 <= n; i_1++) bmarkervisit[i_1] = false;

		// Сразу заносим граничные условия Дирихле в С узлы.
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			integer iadd42 = 0;
			for (integer i42 = 0; i42 < ilevel - 1; i42++) {
				iadd42 += n_a[i42];
			}
			if (bamg_bound[ii+iadd42]) {
				flag[ii] = true; // init flag
				bmarkervisit[ii] = true;
				this_is_C_node[ii] = true;
				this_is_F_node[ii] = false;
			}
		}

		// увеличение быстродействия достигается 
		// сокращением пределов сканирования
		// здесь хранится индекс начала сканирования flag.
		integer istartflag_scan = 1;


		// if (bAVL) работа на основе АВЛ дерева.
		bool bAVL = true;
		bool bAVL_deb = false;
		node_AVL* root = 0;
		Tree_splay* root_splay = 0;
		size_splay_Tree = 0;

		integer newCcount = 0;

		// 4 июля 2016.
		// это случай когда следующий уровень вложенности просто не из чего строить и это 
		// становится понятно только здесь.
		if ((icandidate == 0) && (maxneighbour == 0)) {
#if doubleintprecision == 1
			//printf("maxneighbour==%lld\n",maxneighbour);
#else
			//printf("maxneighbour==%d\n",maxneighbour);
#endif
			
			//getchar();
			// уровень построить нельзя поэтому досрочный выход из цикла.
			break;
		}

		bool bcontinue = true;

		while (bcontinue)
		{


#if doubleintprecision == 1
			//printf("prohod count number %lld\n", icountprohod);
#else
			//printf("prohod count number %d\n", icountprohod);
#endif
			


			integer set[max_neighbour]; // не более 20 узлов в одном агрегате.
			// инициализация убрана потому что она не нужна и она сильно тормозит быстродействие.
			//for (integer js = 0; js < max_neighbour; js++) {
			//set[js] = NULL_NEIGHBOUR;
			//}
			integer ic = 0;

			integer ii = icandidate;
			if (flag[Amat[ii].i] == false) {

				ic = 0; // Обязательная инициализация.
				set[ic] = Amat[ii].i;



				this_is_C_node[set[0]] = true;
				bmarkervisit[set[0]] = true;

				doublerealT max_vnediagonal = -1.0; // максимальное значение модуля вне диагонального элемента. 
				// добавляем диагональный элемент.
				// узел set[0]==Amat[is0].i.
				// Нахождение значения максимального внедиагольного элемента, с 
				// учётом того что даже узел Дирихле связан с одним внутренним узлом расчётной области.
				// 17 января 2016 правильное определение максимального внедиагонального элемента.
				// Обязательная перемотка в самое начало строки.
				integer ii_back = ii;
				while ((ii_back > iadd) && (Amat[ii_back].i == set[0])) ii_back--;
				ii_back++;

				doublerealT max_vnediagonal1 = -1.0;
				doublerealT min_vnediagonal1 = (doublerealT)(1.0e30);
				doublerealT counter_vnediagonal = 0.0;
				doublerealT avg_vnediagonal1 = 0.0;

				// Если делать по максимальному внедиагональному элементу то мы получим очень много элементов на грубых уровнях,
				// и чрезвычайно медленную сходимость.

				for (integer is0 = ii_back; (is0 <= row_startA[set[0] + 1] - 1); is0++) {
					if (Amat[is0].j != set[0]) {
						if (Amat[is0].aij < 0.0) {
							counter_vnediagonal = (doublerealT)(counter_vnediagonal + 1.0);
							avg_vnediagonal1 += fabs(Amat[is0].aij);
							if (fabs(Amat[is0].aij) > max_vnediagonal1) {
								max_vnediagonal1 = fabs(Amat[is0].aij); //i,j
								// Большое количество элементов на грубых уровнях,
								// очень медленная сходимость.
								//if (Amat[is0].j == set[0]) break; 
							}
							if (fabs(Amat[is0].aij) < min_vnediagonal1) {
								min_vnediagonal1 = fabs(Amat[is0].aij); //i,j

							}
						}
					}
				}
				if (fabs(counter_vnediagonal) > 0.5) {
					avg_vnediagonal1 = avg_vnediagonal1 / counter_vnediagonal;
				}
				else {
					avg_vnediagonal1 = max_vnediagonal1;
				}
				//max_vnediagonal = avg_vnediagonal1;
				//max_vnediagonal = max_vnediagonal1;  // 1
				//max_vnediagonal = 0.5* avg_vnediagonal1 + 0.5*max_vnediagonal1;
				//max_vnediagonal = avg_vnediagonal1 + 0.05*(max_vnediagonal1 - avg_vnediagonal1);
				// наиболее близка к оптимальной. -85%. но несомненно лучше max_vnediagonal = -1.0;
				//max_vnediagonal = avg_vnediagonal1 - 0.85*(avg_vnediagonal1 - min_vnediagonal1);
				// 19 января 2016 установлено что важды все связы, не нужно учитывать threshold
				// max_vnediagonal должно быть -1.0. Именно это значение обеспечивает наилучшую 
				// скорость агломерации и наилучшую скорость сходимости.
				max_vnediagonal = -1.0;  // все связи!!!

				/*
				// Лишний код 19 января 2016.
				for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
				if (Amat[is0].j == set[0]) {

				// Из-за этого прерывания максимальный внедиагональный элемент может быть определён неверно.
				// поэтому смотри цикл выше от 17 января 2016 по правильному определению максимального внедиагонального элемента.
				break;
				}
				else {
				if (fabs(Amat[is0].aij) > max_vnediagonal) {
				// При стабильной версии требуется расскоментировать
				// 19 jan 2016.
				//max_vnediagonal = fabs(Amat[is0].aij); //i,j
				}
				}

				// Этот цикл является добавочным.
				// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
				// Медленный линейный поиск.
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//if (Amat[ii1].i != set[0]) {
				//if (!flag[Amat[ii1].i]) {
				//	if (Amat[ii1].j == set[0]) {
				//		if (fabs(Amat[ii1].aij) > max_vnediagonal) {
				//			max_vnediagonal = fabs(Amat[ii1].aij); //j,i
				//		}
				//	}
				//}
				//}
				//}

				if (bji) {
				// Этот цикл является добавочным.
				// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
				// Ускоренная версия на основе двоичного поиска.
				integer ii2 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
				for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == set[0]); ii1++)
				{
				if (Atemp[ii1].i != set[0]) {
				if (!flag[Atemp[ii1].i]) {
				if (fabs(Atemp[ii1].aij) > max_vnediagonal) {
				max_vnediagonal = fabs(Atemp[ii1].aij); //j,i
				}
				}
				}
				}
				}


				}
				*/

				ic++;


				// если узел j ещё не был добавлен в агрегат.
				if (flag[Amat[ii].j] == false) {
					if ((Amat[ii].j != set[0]) && (Amat[ii].aij<0.0) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
						vacant = Amat[ii].j;
						for (integer js = 0; js < ic; js++) {
							if (vacant == set[js]) {
								vacant = NULL_NEIGHBOUR;
							}
						}
						if (vacant != NULL_NEIGHBOUR) {
							set[ic] = vacant;

							ic++;
						}
					}
				}

				//printf("sboi start");

				integer iscan = ii + 1;
				iscan = ii_back + 1; // важная модификация 19 января 2016г.

				
					// TODO 19 jan 2016.
					while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set[0])) {
						// 14 февраля 2016 код иногда приводящий к сбою.
						//while (iscan <= row_startA[set[0] + 1] - 1) { // код иногда приводящий к сбою по непонятной причине.
						// если узел j ещё не был добавлен в агрегат.
						if (flag[Amat[iscan].j] == false) {
							if ((Amat[iscan].j != set[0]) && (Amat[iscan].aij < 0.0) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
								vacant = Amat[iscan].j;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_NEIGHBOUR;
									}
								}
								if (vacant != NULL_NEIGHBOUR) {
									set[ic] = vacant;

									ic++;

								}
							}
						}

						iscan++;

					} // while
				

				//printf("sboi end");
				// Это была учтена только связь i,j



				// Учёт свяи j,i
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
				//if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
				//if (!flag[Amat[ii1].i]) {
				//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
				//	vacant = Amat[ii1].i;
				//	for (integer js = 0; js < ic; js++) {
				//		if (vacant == set[js]) {
				//			vacant = NULL_NEIGHBOUR;
				//		}
				//	}
				//	if (vacant != NULL_NEIGHBOUR) {
				//		set[ic] = vacant; // j,i связь.

				//		ic++;
				//	}
				//	}
				//}
				//}
				//}

				// Учёт связи j,i
				// Медленная версия на основе линейного поиска.
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
				//if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
				//if (!flag[Amat[ii1].i]) {
				//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
				//	vacant = Amat[ii1].i;
				//	for (integer js = 0; js < ic; js++) {
				//		if (vacant == set[js]) {
				//			vacant = NULL_NEIGHBOUR;
				//		}
				//	}
				//	if (vacant != NULL_NEIGHBOUR) {
				//		set[ic] = vacant; // j,i связь.

				//		ic++;
				//	}
				//}
				//}
				//}
				//}

				if (bji) {
					// Учёт свяи j,i
					// Более быстрая версия на основе двоичного поиска.
					integer ii1 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
					for (integer ii2 = ii1; (ii2 <= row_startA[set[0] + 1] - 1); ii2++) {
						if ((Atemp[ii2].i != set[0]) && (!flag[Atemp[ii2].i])) {
							if ((Atemp[ii2].aij<0.0)&&(fabs(Atemp[ii2].aij) >= theta*max_vnediagonal)) {
								vacant = Atemp[ii2].i;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_NEIGHBOUR;
									}
								}
								if (vacant != NULL_NEIGHBOUR) {
									set[ic] = vacant; // j,i связь.
									ic++;
								}
							}
						}
					}


				}


				for (integer isc = 1; isc < ic; isc++) {
					this_is_F_node[set[isc]] = true; // это только новые F узлы.
					bmarkervisit[set[isc]] = true;
				}




				// Помечаем узлы как включённые в агрегат.
				for (integer js = 0; js < ic; js++) {
					flag[set[js]] = true;
				}






				// Алгоритм (5 декабря 2015 revised) 
				// 1. Сканируем все F которые соседи данного С на данном проходе.
				// 2. Для каждого фиксированного F сканируем его "строчных" соседей.
				// 3. Если узел еще не был включён в агрегат то ищем всех соседей данного узла на предмет 
				// соседства с фиксированным набором F из пункта 1.



				if (bAVL) {
					// 12 декабря 2015.
					// Надо удалить из АВЛ дерева C и F узлы.
					// Это удаление очищает АВЛ дерево и приводит его к
					// рабочему состоянию. Удаление несуществующих в дереве узлов
					// производится корректно. Удаление производится за логарифмическое
					// по основанию 2  время от количества элементов в дереве
					// сбалансированность дерева при этом сохраняется.
					for (integer js = 0; js < ic; js++) {
						data_BalTree ddel;
						ddel.i = set[js];
						ddel.count_neighbour = count_neighbour[set[js]];
						//ddel.ii = row_startA[ddel.i];
						switch (id_tree) {
						case AVL_TREE_ID: root = remove_AVL(root, ddel);
							break;
						case SPLAY_TREE_ID: root_splay = delete_splay_Tree(ddel, root_splay);
							break;
						default: root = remove_AVL(root, ddel);
							break;
						}

						if (bAVL_deb)
						{
							printf("remove\n");
						}
					}
				}


				//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
				//flag_shadow[i_1] = flag[i_1];
				//}



				//integer i3 = 1;
				//while ((i3 <= n_a[ilevel - 1]) && (row_startA[i3] < istart)) i3++;
				//integer i4 = n_a[ilevel - 1];
				//while ((i4 >= 1) && (row_startA[i4]>iend)) i4--;


				// Ищем только среди ближайшего окружения вновь добавленного F узла.
				//for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {

				// Старая реализация которой присуща большая нагрузка на операторы new && delete.
#if 0
				if (0) {
					for (integer js = 1; js < ic; js++) {

						// см. новый вариант от 10 января 2016.

						// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
						// элемент lsos_head;
						List *lsos = nullptr;
						List *lsos_head = nullptr;
						lsos = new List;
						lsos->prev = nullptr;
						lsos_head = lsos;
						{
							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart2 = ii_11;
							//while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_11].i)) istart2--;
							//istart2++;
							istart2 = row_startA[Amat[ii_11].i];
							bool bvisitsos = false;
							for (integer is0 = istart2; (is0 <= row_startA[Amat[ii_11].i + 1] - 1); is0++) {
								if (flag[Amat[is0].j] == false) {
									lsos->next = nullptr;
									lsos->i = Amat[is0].j;
									lsos->ii = row_startA[lsos->i];
									// lsos->count_neighbour // не используется.
									List *newnodesos = new List;
									newnodesos->prev = lsos;
									lsos->next = newnodesos;
									newnodesos->next = nullptr;
									lsos = lsos->next;
									newnodesos = nullptr;
									bvisitsos = true;
								}
							}
							if (bvisitsos) {

								List *delsos = lsos;
								lsos = lsos->prev;
								lsos->next = nullptr;
								delsos->prev = nullptr;
								delete delsos;
								delsos = nullptr;
							}
							else {
								// Нет ни одного соседа
								lsos_head = nullptr;
								delete lsos;
								lsos = nullptr;
							}
						}

						lsos = lsos_head;
						// ищем соседа узла set[js].
						//for (integer i5 = i3; i5 <= i4; i5++) {
						while (lsos != nullptr) {


							//integer isc = Amat[ii_2].i;
							//integer ii_2 = row_startA[i5];
							//integer ii_2 = BinarySearchAi(Amat, i5, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							//integer isc = i5;

							integer isc = lsos->i;
							integer ii_2 = lsos->ii;


							//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
							//if (flag[isc] == false) {
							//flag_shadow[isc] = true;
							integer ic2 = 0;
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart2 = ii_2;
							while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
							istart2++;
							for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_2].i); is0++) {
								if (Amat[is0].j == set[js]) {
									ic2++;
								}
							}

							data_BalTree dsearch;
							dsearch.count_neighbour = count_neighbour[isc];
							//dsearch.ii = ii_2;
							dsearch.i = isc;
							count_neighbour[isc] += ic2;
							data_BalTree dadd;
							dadd.count_neighbour = count_neighbour[isc];
							//dadd.ii = ii_2;
							dadd.i = isc;
							if (bmaxneighbourinfoactive) {
								// Обновляем информацию о максимальном количестве соседей.
								if (count_neighbour[isc] >= Maximumneighbourcount) {
									Maximumneighbourcount = count_neighbour[isc];
								}

								// Добавляем соседа в любом случае
								// позволило существенным образом 
								// ускорить алгоритм. Если раньше 
								// old = 48595  | 21229
								// new = 433315 | 63031
								// new2 = 19434 | 3698
								// и основное время уходило на old
								// то теперь
								// old = 1449 | 1466
								// new = 472600 | 64525
								// new2= 56544 | 18431
								// Время решения 3D задачи с 1M неизвестными 
								// сократилось с 6мин 48с до 4мин 45с.

								if (bAVL) {

									// добавляем элемент в АВЛ дерево,
									// причём если элемент уже находился в дереве то он модифицируется.
									// 12 декабря 2015.
									// Добавление узла происходит за логарифмическое по основанию 2 время,
									// причём после добавления дерево остаётся сбалансированным.
									// Адельсон-Вельский и Ландис 1962.
									switch (id_tree) {
									case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
									case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
										break;
									default: root = insert_and_modify(root, dadd, dsearch);
										break;
									}

									if (bAVL_deb)
									{
										printf("insert and modify\n");
									}
								}


							}
							//}
							lsos = lsos->next;
						}

						// Уничтожение lsos
						// Список постепенно уничтожается с головы.
						lsos = lsos_head;
						while (lsos != nullptr) {
							lsos_head = lsos_head->next;
							if (lsos_head != nullptr) {
								lsos_head->prev = nullptr;
							}
							lsos->next = nullptr;
							delete lsos;
							lsos = lsos_head;
						}

					}
				}
				else if (0) {
					for (integer js = 1; js < ic; js++) {

						// см.ниже  новый вариант от 10 января 2016.
						// 7 января 2016.
						// Новая версия в которой я избавился от лишних оператров new&&delete.
						// Никаких дублирующих линейных списков, никаких операторов new && delete.
						// Код стал намного понятнее.

						// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
						// элемент lsos_head;
						{
							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (flag[Amat[is0].j] == false) {


									integer isc = Amat[is0].j;
									integer ii_2 = row_startA[isc];

									//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
									//if (flag[isc] == false) {
									//flag_shadow[isc] = true;
									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									istart2++;
									for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
										if (Amat[is01].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.count_neighbour = count_neighbour[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									count_neighbour[isc] += ic2;
									data_BalTree dadd;
									dadd.count_neighbour = count_neighbour[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;
									if (bmaxneighbourinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_neighbour[isc] >= Maximumneighbourcount) {
											Maximumneighbourcount = count_neighbour[isc];
										}

										// Добавляем соседа в любом случае
										// позволило существенным образом 
										// ускорить алгоритм. Если раньше 
										// old = 48595  | 21229
										// new = 433315 | 63031
										// new2 = 19434 | 3698
										// и основное время уходило на old
										// то теперь
										// old = 1449 | 1466
										// new = 472600 | 64525
										// new2= 56544 | 18431
										// Время решения 3D задачи с 1M неизвестными 
										// сократилось с 6мин 48с до 4мин 45с.

										if (bAVL) {

											// добавляем элемент в АВЛ дерево,
											// причём если элемент уже находился в дереве то он модифицируется.
											// 12 декабря 2015.
											// Добавление узла происходит за логарифмическое по основанию 2 время,
											// причём после добавления дерево остаётся сбалансированным.
											// Адельсон-Вельский и Ландис 1962.
											switch (id_tree)
											{
											case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
											case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch); break;
											default: root = insert_and_modify(root, dadd, dsearch);
												break;
											}

											if (bAVL_deb)
											{
												printf("insert and modify\n");
											}
										}


									}

								}
							}

						}
					}

				}
				else if (0) {
					// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;
								integer ii_2 = row_startA[isc];

								// При таком подходе некоторые соседи инкрементируются дважды и это
								// даёт хорошую скорость агломерации. Хватает 4 кратного размера памяти под исходную матриу.
								// Количество повторно инкрементируемых узлов составило около 33% в 2D на пятиточечном шаблоне.
								// Было решено оставить этот вариант кода т.к. он даёт хорошую скорость агломерации.


								integer ic2 = 0;
								integer iend2loc = nnz_a[ilevel - 1] + iadd;
								integer istart2 = ii_2;
								while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
								istart2++;
								for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
									if (Amat[is01].j == set[js]) {
										ic2++;
									}
								}

								data_BalTree dsearch;
								dsearch.count_neighbour = count_neighbour[isc];
								//dsearch.ii = ii_2;
								dsearch.i = isc;
								count_neighbour[isc] += ic2;
								data_BalTree dadd;
								dadd.count_neighbour = count_neighbour[isc];
								//dadd.ii = ii_2;
								dadd.i = isc;

								if (bAVL) {

									// добавляем элемент в АВЛ дерево,
									// причём если элемент уже находился в дереве то он модифицируется.
									// 12 декабря 2015.
									// Добавление узла происходит за логарифмическое по основанию 2 время,
									// причём после добавления дерево остаётся сбалансированным.
									// Адельсон-Вельский и Ландис 1962.
									switch (id_tree)
									{
									case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
										break;
									case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
										break;
									default: root = insert_and_modify(root, dadd, dsearch);
										break;
									}

									if (bAVL_deb)
									{
										printf("insert and modify\n");
									}
								}

								if (bmaxneighbourinfoactive) {
									// Обновляем информацию о максимальном количестве соседей.
									if (count_neighbour[isc] >= Maximumneighbourcount) {
										Maximumneighbourcount = count_neighbour[isc];
									}
								}

							}

						}
					}
				}
				else 
#endif 
				if (1) {
					//printf("additional and modify new neighbour\n");

					// 10 января 2016. Новая логика.
					// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
					// Эта модификация даёт сокращение количества V циклов которые требуются до сходимости
					// Эта модификация наиболее близка к классической описанной в литературе чем все предыдущие.
					// На момент 13 января 2016 это лучший вариаент по скорости вычислений.
					integer itop_stack2 = 0;

					// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						//while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						//istart3++;
						istart3 = row_startA[Amat[ii_11].i];
						bool bvisitsos = false;
						for (integer is0 = istart3; (is0 <= row_startA[Amat[ii_11].i + 1] - 1); is0++) {
							//for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;

								// Избавляемся от повторных инкрементаций.
								// В 2D на пятиточечном шаблоне повторные инкрементации составляют
								// около 33%.
								// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
								// на ряде тестовых задач при таком подходе агломерация проходила очень
								// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
								// Эта проблема проявилась на задачах:
								// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
								// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
								// Проблема не в этом месте кода.
								if (hash_table2[isc] == false) {
									hash_table2[isc] = true;
									istack2[itop_stack2] = isc;
									itop_stack2++;

									integer ii_2 = row_startA[isc];


									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									//while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									//istart2++;
									istart2 = row_startA[Amat[ii_2].i];
									for (integer is01 = istart2; (is01 <= row_startA[Amat[ii_2].i + 1] - 1); is01++) {
										if (Amat[is01].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.count_neighbour = count_neighbour[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									// Увеличиваем на количество связей с новыми F узлами.
									count_neighbour[isc] += ic2;
									//if (ic2 > 0) {
									//count_neighbour[isc] += 1;
									//}
									data_BalTree dadd;
									dadd.count_neighbour = count_neighbour[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;

									if (bAVL) {

										// добавляем элемент в АВЛ дерево,
										// причём если элемент уже находился в дереве то он модифицируется.
										// 12 декабря 2015.
										// Добавление узла происходит за логарифмическое по основанию 2 время,
										// причём после добавления дерево остаётся сбалансированным.
										// Адельсон-Вельский и Ландис 1962.
										switch (id_tree)
										{
										case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
											break;
										case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
											break;
										default: root = insert_and_modify(root, dadd, dsearch);
											break;
										}
										if (bAVL_deb)
										{
											printf("insert and modify\n");
										}
									}

									if (bmaxneighbourinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_neighbour[isc] >= Maximumneighbourcount) {
											Maximumneighbourcount = count_neighbour[isc];
										}
									}
								}

							}

						}
					}

					// Очистка (восстановление хеш-таблицы).
					for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
						hash_table2[istack2[i_54]] = false;
					}
					itop_stack2 = 0; // стек снова готов к работе.


				} // the end
				else {
					// 13 января 2016. Новая логика.
					// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
					// Отличие в том что мы учитываем лишь Strong связи при инкрементации счётчика.
					// Это привело к 5 уровням вместо 13, и очень медленной сходимости.
					// Это было при magic=0.4
					// Strong связи при инкрементации счётчика не подходят по причине низкой производительности. 13 января 2016.
					integer itop_stack2 = 0;

					// На основе  старого варианта просто очищенного от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						doublerealT threshold9 = -1.0;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (Amat[is0].j != Amat[ii_11].i) {
								if ((Amat[is0].aij <0.0)&&(fabs(Amat[is0].aij) > threshold9)) {
									threshold9 = fabs(Amat[is0].aij);
								}
							}
						}

						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > theta*threshold9)) {
								if (flag[Amat[is0].j] == false) {


									integer isc = Amat[is0].j;

									// Избавляемся от повторных инкрементаций.
									// В 2D на пятиточечном шаблоне повторные инкрементации составляют
									// около 33%.
									// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
									// на ряде тестовых задач при таком подходе агломерация проходила очень
									// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
									// Эта проблема проявилась на задачах:
									// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
									// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
									// Проблема не в этом месте кода.
									if (hash_table2[isc] == false) {
										hash_table2[isc] = true;
										istack2[itop_stack2] = isc;
										itop_stack2++;

										integer ii_2 = row_startA[isc];


										integer ic2 = 0;
										integer iend2loc = nnz_a[ilevel - 1] + iadd;
										integer istart2 = ii_2;
										while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
										istart2++;
										// Определяем модуль максимального внедиагонального элемента.
										doublerealT threshold_loc1 = -1.0; // инициализация порога.
										for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
											// Только внедиагональные элементы.
											if (Amat[is01].j != Amat[ii_2].i) {
												if ((Amat[is01].aij<0.0)&&(fabs(Amat[is01].aij) > threshold_loc1)) {
													threshold_loc1 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
											// Только внедиагональные элементы.
											if (Amat[is01].j != Amat[ii_2].i) {
												if (Amat[is01].j == set[js]) {
													// только Strong связи
													// по крайней мере именно так рекомендуют в литературе.
													if ((Amat[is01].aij<0.0)&&(fabs(Amat[is01].aij) > theta*threshold_loc1)) {
														ic2++;
													}
												}
											}
										}

										if (ic2 > 0) {
											// Только если были Strong связи приводящие к инкрементации счётчика ic2.


											data_BalTree dsearch;
											dsearch.count_neighbour = count_neighbour[isc];
											//dsearch.ii = ii_2;
											dsearch.i = isc;
											count_neighbour[isc] += ic2;
											data_BalTree dadd;
											dadd.count_neighbour = count_neighbour[isc];
											//dadd.ii = ii_2;
											dadd.i = isc;

											if (bAVL) {

												// добавляем элемент в АВЛ дерево,
												// причём если элемент уже находился в дереве то он модифицируется.
												// 12 декабря 2015.
												// Добавление узла происходит за логарифмическое по основанию 2 время,
												// причём после добавления дерево остаётся сбалансированным.
												// Адельсон-Вельский и Ландис 1962.
												switch (id_tree)
												{
												case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
													break;
												case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
													break;
												default: root = insert_and_modify(root, dadd, dsearch);
													break;
												}
												if (bAVL_deb)
												{
													printf("insert and modify\n");
												}
											}
										}

										if (bmaxneighbourinfoactive) {
											// Обновляем информацию о максимальном количестве соседей.
											if (count_neighbour[isc] >= Maximumneighbourcount) {
												Maximumneighbourcount = count_neighbour[isc];
											}
										}
									}

								}
							}

						}
					}

					// Очистка (восстановление хеш-таблицы).
					for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
						hash_table2[istack2[i_54]] = false;
					}
					itop_stack2 = 0; // стек снова готов к работе.


				}



				n_coarce++; // Увеличено количество С узлов.

				// Один агрегат создан.

			} // узел не был ещё включён в агрегат.



			bcontinue = false;
			for (integer i_1 = istartflag_scan; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (flag[i_1] == false) {
					bcontinue = true;
					istartflag_scan = i_1; // сокращаем пределы сканирования.
					break; // досрочный выход из цикла for.
					//if (maxneighbour == -1) {
#if doubleintprecision == 1
					//printf("ERROR!!!!  i_1=%lld\n", i_1);
#else
					//printf("ERROR!!!!  i_1=%d\n", i_1);
#endif
					
					//system("pause");
					//}
				}
			}

			// Вычисление узла с максимальным количеством соседей.
			maxneighbour = -1;
			icandidate = 0;


			// TODO 6 november
			//integer isize_p = -1;
			/*
			if (0) {

			// На основе линейного поиска (медленный вариант на больших размерностях).

			const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			integer* ipool = new integer[ipool_size_limit];

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			if (i_7 < ipool_size_limit) {
			if (ipool[i_7] == icandidateq) {
			found1 = true;
			}
			}
			else {
			#if doubleintprecision == 1
				printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			system("pause");
			exit(1);
			}
			}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;
			if (isize_p < ipool_size_limit) {
			ipool[isize_p] = icandidateq;
			}
			else {
			#if doubleintprecision == 1
				printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			system("pause");
			exit(1);
			}
			}
			ii_c++;
			}
			}
			delete[] ipool;

			}
			else if (0){

			// 4 января 2016. Медленный линейный поиск заменён на обработку АВЛ дерева.

			// На основе АВЛ дерева.
			//const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			//integer* ipool = new integer[ipool_size_limit];

			node_AVL_Gus* root_Gus = 0;

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			found1 = isfound_Gus(root_Gus, icandidateq);
			//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			//if (i_7 < ipool_size_limit) {
			//if (ipool[i_7] == icandidateq) {
			//found1 = true;
			//}
			//}
			//else {
			#if doubleintprecision == 1
				//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			//}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;

			root_Gus = insert_Gus(root_Gus, icandidateq);

			//if (isize_p < ipool_size_limit) {
			//ipool[isize_p] = icandidateq;
			//}
			//else {
			#if doubleintprecision == 1
				//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			}
			ii_c++;
			}
			}
			//delete[] ipool;
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

			// На основе сбалансированного АВЛ дерева поиска.
			}
			else {

			// 6 января 2016. Медленный линейный поиск заменён на обработку hash таблицы.

			// На основе hash таблицы.
			//const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			//integer* ipool = new integer[ipool_size_limit];

			//node_AVL_Gus* root_Gus = 0;
			// Нельзя это вызывать это очень медленно.
			//for (integer isc = 0; isc <= nnz_a[ilevel - 1]; isc++) hash_table[isc] = false; // initialization
			integer itop = 0; // указатель на вершину стека.

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			//found1 = isfound_Gus(root_Gus, icandidateq);
			found1 = hash_table[icandidateq - iadd];

			//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			//if (i_7 < ipool_size_limit) {
			//if (ipool[i_7] == icandidateq) {
			//found1 = true;
			//}
			//}
			//else {
			#if doubleintprecision == 1
				//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			//}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;

			//root_Gus = insert_Gus(root_Gus, icandidateq);
			hash_table[icandidateq - iadd] = true;
			if (itop < istack_size_limit ) {
			istack[itop] = icandidateq - iadd;
			itop++;
			}
			else {
			printf("itop>=istack_size_limit need to increase istack_size_limit");
			}

			//if (isize_p < ipool_size_limit) {
			//ipool[isize_p] = icandidateq;
			//}
			//else {
			#if doubleintprecision == 1
				//printf("need to increase ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("need to increase ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			}
			ii_c++;
			}
			}
			//delete[] ipool;
			//clear_AVL_Gus(root_Gus);
			//root_Gus = 0;

			for (integer isc = itop - 1; isc >= 0; isc--) {
			hash_table[istack[isc]] = false;
			}
			itop = 0;

			// На основе сбалансированного АВЛ дерева поиска.
			}
			*/


			//	ibegining_start_index_found_maximum += isize_p + 1;

			if (bAVL) {
				if (bAVL_deb)
				{
					printf("found max");
				}
				// Данный код чрезвычайно компактен.
				bmaxneighbourinfoactive = true;
				// Надо найти максимальный элемент в АВЛ дереве.
				node_AVL* emax = 0;
				Tree_splay* emax_splay = 0;
				switch (id_tree)
				{
				case AVL_TREE_ID: emax = findmax(root);
					break;
				case SPLAY_TREE_ID: emax_splay = findmax(root_splay);
					break;
				default: emax = findmax(root);
					break;
				}


				switch (id_tree) {
				case AVL_TREE_ID:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;

					}
					break;
				case SPLAY_TREE_ID:
					// SPLAY tree
					if (emax_splay != 0) {


						//icandidate = emax_splay->item.ii; 23 jan 2016
						icandidate = row_startA[emax_splay->item.i];
						emax_splay = 0;

					}
					else {
						root_splay = 0;
						size_splay_Tree = 0;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;

					}
					break;
				default:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxneighbour = -1;
						bcontinue = false;

					}
					break;
				}




			}

#if doubleintprecision == 1
			//printf("maximum number of neighbour=%lld\n",maxneighbour);
#else
			//printf("maximum number of neighbour=%d\n",maxneighbour);
#endif
			
			if (maxneighbour == -1) if (debug_reshime) system("pause");
			//getchar();

			if ((icandidate == 0) && (maxneighbour == -1)) {
				bcontinue = false;
			}
			// 4 june 2016
#if doubleintprecision == 1
			//printf("icandidate=%lld, maxneighbour=%lld\n",icandidate, maxneighbour);
#else
			//printf("icandidate=%d, maxneighbour=%d\n",icandidate, maxneighbour);
#endif
			

			if (bAVL_deb)
			{
				print_AVL(root);
				system("pause");
			}

			icountprohod++;

		} // Построение C/F разбиения. создано.

		//delete[] bmarkervisit;
		free(bmarkervisit);

		if (bprint_mesage_diagnostic) {
			if (n_a[ilevel - 1] == 0)  {
				printf("n_a is zero\n");
				system("pause");
			}
			printf("additional C=%3.1f\n", (doublerealT)(100.0*newCcount / n_a[ilevel - 1]));
			//system("pause");
		}

		if (bAVL)
		{
			// Освобождение оперативной памяти из под АВЛ дерева.
			// 12 декабря 2015.
			switch (id_tree)
			{
			case AVL_TREE_ID: clear_AVL(root);
				root = 0;
				break;
			case SPLAY_TREE_ID:
				clear_SPLAY(root_splay);
				root_splay = 0;
				break;
			default: clear_AVL(root);
				root = 0;
				break;
			}

		}


		// В методе стандартной интерполяции присутствует шаг уменьшения разреженности,
		// для того чтобы правильно аппроксимировать все F переменные C переменными надо
		// увеличить количество С переменных.
		integer ipromah = 0;
		integer ipromah_one = 0;
		integer ipromah_oneF = 0;

		integer iadditionalCstatistic = 0;

		bool bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]  ) {
				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				// старая версия до 10 января 2016.
				//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// Быстрый вариант без поиска, просто индексирование на основе "хеш-таблицы".
				// 10 января 2016. на основе хеширования.
				integer i_2 = row_startA[i_1];

				bool bvisit = false;
				//for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
				for (integer is0 = i_2; (is0 <= row_startA[Amat[i_2].i + 1] - 1); is0++) {
					if (Amat[is0].j != Amat[i_2].i) {
						bvisit = true;
						if (this_is_C_node[Amat[is0].j]  ) {
							icsos++;
						}
						else {
							ipromah++; // подсчитываем проблемы интерполяции 
						}
					}
				}

				if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.
				// Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
				if ((icsos == 0) && (bvisit)) {

					// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
					// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
					// поглощены агломератами внутренних узлов и всё было впорядке.
					// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

					// Нет С соседей, этот узел станет С узлом.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					// F node стал C_node!!! Идея стандартной интерполяции 
					// приводит к уменьшению разреженности оператора Галёркина.
					bweSholdbeContinue = true;
					newCcount++;
				}

				

				// 1 января 2015 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false) && (icsos == 1)) {
					// bvisit и так true т.к. icsos==1.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					bweSholdbeContinue = true;
				}

			}

			if (bprint_mesage_diagnostic) {
				if (bweSholdbeContinue) {
					printf(" prohod succseful\n");
				}
				else {
					printf("prohod empty\n");
				}
			}

		}




		// Нужно корректно обработать узлы Дирихле,
		// Если F узел окажется узлом Дирихле без соседей то его надо сделать С узлом,
		// Но узнать такой узел можно лишь в процессе выполнения алгоритма дальше по ходу исполнения.
		// Поэтому может потребоваться вернуться и начать заново (обратная связь).

		doublerealT* problem_conservation = nullptr;
		problem_conservation = new doublerealT[35 * n_a[ilevel - 1] + 1];
		if (problem_conservation == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for problem_conservation vector in my_agregat_amg5.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		for (integer i43 = 0; i43 < 35 * n_a[ilevel - 1] + 1; i43++) {
			problem_conservation[i43] = 0.0; // инициализация.
		}


		integer* C_numerate = nullptr;
		//C_numerate = new integer[n_a[ilevel - 1] + 1];
		C_numerate = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(C_numerate, "C_numerate", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		integer icounter = 1;
		integer icount1;
		integer numberofcoarcenodes;
		doublerealT* ap_coarse = nullptr;

		bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) { n_coarce++; }
			n_coarce--;


			// debug
			// проверка качества C/F разбиения.
			//doublerealT* exp1 = new doublerealT[n_a[ilevel - 1] + 1];
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) exp1[i_1] = 0.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) exp1[i_1] = 2.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]) exp1[i_1] = 1.0;
			//exporttecplot(exp1,n);
			//delete[] exp1;

			//printf("export ready");

			//system("pause");



			// C/F разбиение построено, самое время построить оператор интерполяции.
			// потом найти оператор проекции, как транспонированный оператор интерполяции.
			// Всё завершает построение матрицы нового сеточного уровня и можно запускать новый уровень.

			// Построение оператора интерполяции: 
			// coarse 2 fine.
			//P*coarse==fine


			// Занумеруем (упорядочим) узлы грубой сетки.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) C_numerate[i_1] = 0;
			icounter = 1;
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]  ) {
#if doubleintprecision == 1
				//printf("C ind= %lld", i_1); getchar();
#else
				//printf("C ind= %d", i_1); getchar();
#endif
				
				// отмечаем какие из узлов нового уровня вложенности являются граничными.
				integer iadd42 = 0;
				for (integer i42 = 0; i42 <= ilevel - 1; i42++) iadd42 += n_a[i42];
				bamg_bound[iadd42 + icounter] = bamg_bound[i_1+iadd42-n_a[ilevel-1]];

				C_numerate[i_1] = icounter;
				icounter++;
			}




			// C_numerate - перенумерация на множестве Coarse узлов.
			// Построение пролонгации для узлов которые составляют грубую сетку.
			icount1 = 1 + iaddR; // nnz_R
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]  ) {
				P[icount1].aij = 1.0;
				problem_conservation[icount1 - iaddR] = 1.0;
				P[icount1].i = (integer_mix_precision)(C_numerate[i_1]); // coarse number
				P[icount1].j = (integer_mix_precision)(i_1); // fine number.
				icount1++;

				if (icount1 >= nsizePR*n) {
					printf("memory error!!!\n");
					printf("not enough memory for the interpolation operator.\n");
					//system("PAUSE");
					//exit(1);
					deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
				}
			}

			// значение icount1 нужно далее.НЕ трогать !!!.
			numberofcoarcenodes = icount1 - 1 - iaddR;

			// Для модификации R  надо transpose(P)/ap.
			if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
				printf("countloc=%lld\n", numberofcoarcenodes);
#else
				printf("countloc=%d\n", numberofcoarcenodes);
#endif
				
				if (debug_reshime) system("pause");
			}

			//ap_coarse = new doublerealT[numberofcoarcenodes + 1];
			if (ap_coarse != nullptr) {
				free(ap_coarse);
				ap_coarse = nullptr;
			}
			ap_coarse = (doublerealT*)malloc((numberofcoarcenodes + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(ap_coarse, "ap_coarse", "classic_aglomerative_amg_5", (numberofcoarcenodes + 1));

			ap_coarse[0] = 0.0;




			// Для каждого С узла запоминаем в ap_coarse[C_numerate[i8]] 
			// модуль диагонального элемента.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_C_node[i8]  ) {
				// Старая версия до 10 января 2016. Время O(log2(nnz))
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// 10 января 2016 новая версия на основе хеширования. Время O(1).
				integer ii1 = row_startA[i8];
				// бинарный поиск должен гарантирует нахождение самого левого представителя.
				//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
#if doubleintprecision == 1
					//printf("i=%lld j=%lld Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#else
					//printf("i=%d j=%d Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#endif
					
					if (Amat[is0].j == Amat[ii1].i) {

						if (fabs(Amat[is0].aij) > RealMAXIMUM) {
							printf("perepolnenie error!");
							//getchar();
							system("pause");
						}
						ap_coarse[C_numerate[i8]] = fabs(Amat[is0].aij);
						//printf("find = %e", fabs(Amat[is0].aij));
					}
				}
				//printf("\n");
				//getchar();
			}

			// верно 2 октября.

			bool the_good_old_interpolation = true;

			if (the_good_old_interpolation) {

				// Старая добрая верная, проверенная интерполяция.
				// К тому же чрезвычайно простая.

				// my_amg_manager.number_interpolation_procedure == 0
				// 0
				if (my_amg_manager.number_interpolation_procedure == 0) {

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.

					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						// O(log2(nnz))
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// O(1)
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
										icsos++;
									}
								}
								else {
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


						// 1 января 2016 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {



							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all neighbour is F");
											//system("pause");
											//printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполяция.
										}
										else {

											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												P[icount1].j = (integer_mix_precision)(i8);
												P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
												}
											}

										}

									}
								}
							}

						}

					}
				}
				// my_amg_manager.number_interpolation_procedure == 1
				// 0
				if (my_amg_manager.number_interpolation_procedure == 1) {
					// Немного более экономичная по памяти. Коэффициент не превышал 3.

					// Прямая интерполяция с элементам непрямой.
					// Непрямая интерполяция применяется только для F узлов которые
					// не имеют С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.
					// Узел F не имеющий Strong C соседей, получает значение из Strong C соседей соседних Strong F узлов в
					// в результате сканирования списка Strong F соседей.
					// Если на встречаются два Strongly связанных F узла у которых в совокупности нет вообще ни одного Strong C соседа
					// то один из этих Strong F узлов тановится С узлом и сканирование списка сильных Strong F соседов данного узла F прекращается.
					// Потом мы повторн запускаем алгоритм построения с учётом уже добавленных С узлов.


					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						// O(log2(nnz))
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// O(1)
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j]  ) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all neighbour is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");

								//exit(1);
								// здесь нужна непрямая интерполяция.
								bool* empty_interpol = nullptr;
								//empty_interpol = new bool[icount_StronglyF];
								empty_interpol = (bool*)malloc(icount_StronglyF*sizeof(bool));
								handle_error<bool>(empty_interpol, "empty_interpol", "classic_aglomerative_amg_5", icount_StronglyF);

								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									empty_interpol[i_38] = false; // initialization
								}

								integer i_38_count = 0;

								bool bCinsert = false;

								// Сканируем сильных F соседей данного F узла для которого надо построить интерполяцию.
								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j]  ) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

												integer iFpoint = Amat[is0].j;
												doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
												// сканируем всех соседей iFpointeger 
												// чтобы найти среди них С узлы.

												// Идентифицируем локальный порог.
												doublerealT maxelem_threshold_loc = -1.0;
												//O(log2(nnz))
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												// O(1)
												integer ii1_loc = row_startA[iFpoint];
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														//if (this_is_C_node[Amat[is0_loc].j]  ) {
														// Будем рассматривать только действительно сильных C кандидатов второго уровня.
														if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
														//}
													}
												}


												// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

												// Найти соседей данного F-node которые C-node.
												integer icsos_loc = 0;
												bool bvisit_sumPloc = false;

												// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
												// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
												doublerealT sumP_loc = 0.0;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {




														if (this_is_C_node[Amat[is0_loc].j]  ) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																icsos_loc++;
																bvisit_sumPloc = true;
																empty_interpol[i_38_count] = true;
															}
														}
														else {
															// Подсчитываем количество соседей которые не являются С узлами.
															//ipromah_loc++; // подсчитываем проблемы интерполяции 
														}
													}
												}

												
												if (bvisit_sumPloc) {
													// В общем это двойная интерполяционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	P[icount1].j = (integer_mix_precision)(i8);
																	P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																	if (icount1 >= nsizePR*n) {
																		printf("memory error!!!\n");
																		printf("not enough memory for the interpolation operator.\n");
																		//system("PAUSE");
																		//exit(1);
																		deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																	}
																}
															}
														}
													}
												}
												else {
													// не было С соседей интерполяция может испытывать проблемы.
													// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
													// Данная проблема проявляется уже на втором уровне.
													//printf("problem situation");
													//getchar();
													this_is_F_node[iFpoint] = false;
													this_is_C_node[iFpoint] = true;
													bweSholdbeContinue = true;
													bCinsert = true;
													// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполлчяцию,
													// Иначе я боюсь мы можем добавить слишком много С узлов на грубосеточных уровнях.
													break;
													// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых уровнях сетки.

												}

												i_38_count++;

											}
										}
									}
								}

								if (!bCinsert) {
									// Ибиранее этой добавки даёт ускорение вместо 3мин 42с до 3мин 29с.

									bool bstandart_vjzov = true;
									for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
										// 3 января. На самом деле здесь хорошо бы посмотреть вариант
										// когда с не менее чем двух сторон интерполяция сработала, здесь 
										// же срабатывание было лишь с одной из сторон как минимум.
										if (empty_interpol[i_38]  ) {
											bstandart_vjzov = false;
										}
									}
									if (bstandart_vjzov) {
										this_is_F_node[i8] = false;
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
									}
								}

								free(empty_interpol);

							}



							else {

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j]  ) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												P[icount1].j = (integer_mix_precision)(i8);
												P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
												}
											}



										}
									}
								}
							} // standart

						} // i8


					}

				}

				// my_amg_manager.number_interpolation_procedure == 2
				// 0
				if (my_amg_manager.number_interpolation_procedure == 2) {
					// Немного более экономичная по памяти. Коэффициент не превышал 3.

					// Прямая интерполяция с элементам непрямой. Экспериментальный вариант. TODO.
					// Непрямая интерполяция применяется только для F узлов которые
					// не имеют С соседей или имеют недостаточное число С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.

					// Надо сохранить разреженность оператора Галёркина но при этом усилить интерполяцию.
					// Идея в том чтобы узел F имеющий лишь одного Strong С соседа обработать так чтобы у него было не менее 
					// двух  C соседей учитывая эффект непрямой интерполяции.


					ipromah = 0;
					ipromah_one = 0;
					ipromah_oneF = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j]  ) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполяцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}


						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all neighbour is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");

								//exit(1);
								// здесь нужна непрямая интерполяция.
								bool* empty_interpol = nullptr;
								//empty_interpol = new bool[icount_StronglyF];
								empty_interpol = (bool*)malloc(icount_StronglyF*sizeof(bool));
								handle_error<bool>(empty_interpol, "empty_interpol", "classic_aglomerative_amg_5", icount_StronglyF);

								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									empty_interpol[i_38] = false; // initialization
								}

								integer i_38_count = 0;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j]  ) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

												integer iFpoint = Amat[is0].j;
												doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
												// сканируем всех соседей iFpointeger 
												// чтобы найти среди них С узлы.

												// Идентифицируем локальный порог.
												doublerealT maxelem_threshold_loc = -1.0;
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												integer ii1_loc = row_startA[iFpoint];
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														//if (this_is_C_node[Amat[is0_loc].j]  ) {
														// Будем рассматривать только действительно сильных С кандидатов второго уровня.
														if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
														//}
													}
												}


												// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

												// Найти соседей данного F-node которые C-node.
												integer icsos_loc = 0;
												bool bvisit_sumPloc = false;

												// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
												// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
												doublerealT sumP_loc = 0.0;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {




														if (this_is_C_node[Amat[is0_loc].j]  ) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																icsos_loc++;
																bvisit_sumPloc = true;
																empty_interpol[i_38_count] = true;
															}
														}
														else {
															// Подсчитываем количество соседей которые не являются С узлами.
															//ipromah_loc++; // подсчитываем проблемы интерполяции 
														}
													}
												}


												if (bvisit_sumPloc) {
													// В общем это двойная интерполяционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	P[icount1].j = (integer_mix_precision)(i8);
																	P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																	if (icount1 >= nsizePR*n) {
																		printf("memory error!!!\n");
																		printf("not enough memory for the interpolation operator.\n");
																		//system("PAUSE");
																		//exit(1);
																		deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																	}
																}
															}
														}
													}
												}
												else {
													// не было С соседей интерполяция может испытывать проблемы.
													// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
													// Данная проблема проявляется уже на втором уровне вложенности.
													//printf("problem situation");
													//getchar();
													this_is_F_node[iFpoint] = false;
													this_is_C_node[iFpoint] = true;
													bweSholdbeContinue = true;
													// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполяцию,
													// Иначе я боюсь мы можем добавить слишком много С узлов на грубых уровнях влженности.
													break;
													// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых урвнях сетки.
												}

												i_38_count++;

											}
										}
									}
								}

								bool bstandart_vjzov = true;
								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									// 3 января. На самом деле здесь хорошо бы посмотреть вариант
									// когда с не менее чем двух сторон интерполяция сработала, здесь 
									// же срабатывание было лишь с одной из сторон как минимум.
									if (empty_interpol[i_38]  ) {
										bstandart_vjzov = false;
									}
								}
								if (bstandart_vjzov) {
									this_is_F_node[i8] = false;
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
								}

								free(empty_interpol);

							}
							else if ((icsos == 1) && (icsosF != 0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											if (this_is_C_node[Amat[is0].j]  ) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//	printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												else {
													// Это как раз единственная Strong C связь. 
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
														}
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {

													// Рассматриваем Strong F связи.

													// Смысл:
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpointeger 
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j]  ) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции 
															}
														}
													}

													// В общем это двойная интерполяционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	P[icount1].j = (integer_mix_precision)(i8);
																	P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																	if (icount1 >= nsizePR*n) {
																		printf("memory error!!!\n");
																		printf("not enough memory for the interpolation operator.\n");
																		//system("PAUSE");
																		//exit(1);
																		deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																	}
																}
															}
														}
													}


													//}
												}
										}
									}
								}
							}
							else {

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j]  ) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												P[icount1].j = (integer_mix_precision)(i8);
												P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
												}
											}



										}
									}
								}
							} // standart

						} // i8


					}

				}



				// my_amg_manager.number_interpolation_procedure == 3
				// 1
				// the begining
				if (my_amg_manager.number_interpolation_procedure == 3) {
					//theta = 0.24;
					// theta_strong_F iter_number time,s
					// 0.21 56 22.63
					// 0.22 55 21.769
					// 0.23 52 21.488
					// 0.24 52 21.741 == theta // optimum
					// 0.26 69 24.623
					doublerealT theta_strong_F = (doublerealT)(0.23); // оптимальный выбор.
					theta_strong_F = theta83; // 3 июля 2016


											  // четвёртая версия интерполяции.
					integer ioneStrongC_and_0_StrongF = 0;

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					//6interpolation 0.4 6.77 11 26 28.355
					//6interpolation 0.45 6.6 10 27 28.151
					//6interpolation 0.5 6.42 12 32 28.735
					//4interpolation 0.4 3.7  52 24.736 // best
					//4interpolation 0.3 3.78 13 59 27.525
					//4interpolation 0.5 3.61 12 55 25.533
					//4interpolation 0.45 3.65 10 63 30.24

					bool byes_add = false;
					// Быстрое добавление недостающих С узлов.
					if (1) {
						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						//doublerealT magic = 0.4; // 0.4 optimum


						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij)>maxelem_threshold_theta)) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
											   // Следующий случай назван "безнадёжным".
											   // Безнадёжный случай оставляется без изменений.
											   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
											   // интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}

							


							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							{
								// ДУМАТЬ.
								//if (1 || (icsos == 1)) { // 5_03_2017
									if ((icsos == 1) && (icsosF != 0)) {
										// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
										//
										//SumPall += sumP;

										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												// Нас интересуют только Strong связи.
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if ((Amat[is0].aij < 0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
													if (this_is_C_node[Amat[is0].j]  ) {

														// 20 января 2016.
														// По-моему этой ситуации вообще быть не может так как у нас 
														// заведомо один С сосед.
														if (fabs(sumP) < RealZERO) {
															//printf("error interpolation zero diagonal sumP.\n");
															//printf("Fnode all neighbour is F");
															//system("pause");
															//	printf("i8 is Dirichlet node\n");
															this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
															this_is_C_node[i8] = true;
															bweSholdbeContinue = true;
															iadditionalCstatistic++;
															byes_add = true; // Были добавления узлов.
																			 //exit(1);
																			 // здесь нужна непрямая интерполяция.
														}


													}

												}
											}
										}
									}
									else {

										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (this_is_C_node[Amat[is0].j]  ) {
												if (Amat[is0].j != Amat[ii1].i) {


													// 20 jan 2016.
													// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


													if (fabs(sumP) < RealZERO) {
														// Это случай когда вообще нет сильных С соседей.


														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all neighbour is F");
														//system("pause");
														//printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														byes_add = true; // Были добавления узлов.
																		 //exit(1);
																		 // здесь нужна непрямая интерполяция.
													}


												}
											}
										}
									}
								//}

							}


							//***



						}

					}



					if (!byes_add) {

						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						doublerealT magic = (doublerealT)(0.4); // 0.4 optimum
												//magic = 0.3; // 3 июля 2016 для конвективных задач
												// линейный прогноз не дает улучшений
												// ни по быстрдействию ни по числу V циклов.
												//magic = 0.5 - 0.2*ilevel / 12.0;
						magic = magic82;



						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							integer istr_etalon1 = Amat[ii1].i;
							integer iend_for1 = -1;
							for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
								iend_for1 = is0;
								if (Amat[is0].j != istr_etalon1) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							for (integer is0 = ii1; is0 <= iend_for1; is0++) {
								if (Amat[is0].j != istr_etalon1) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
											   // Следующий случай назван "безнадёжным".
											   // Безнадёжный случай оставляется без изменений.
											   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
											   // интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							if ((false) && (icsos == 1)) {
								this_is_F_node[i8] = false;
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
							}
							else {

								if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									SumPall += sumP;

									for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.


											if (this_is_C_node[Amat[is0].j]  ) {
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all neighbour is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполяция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
															P[icount1].j = (integer_mix_precision)(i8);
															P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															problem_conservation[icount1 - iaddR] = SumPall;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
															}
														}

													}
												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
													if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
														// Рассматриваем Strong F связи.

														// Смысл:
														// 



														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														// Это лишнее условие, ранее уже было проверено что мы имеем дело
														// с сильной F связью.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														integer istr_etalon = Amat[ii1_loc].i;
														integer iend_for = -1;
														for (integer is0_loc = ii1_loc; (is0_loc <= row_startA[istr_etalon + 1] - 1); is0_loc++) {
															iend_for = is0_loc;
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																if (Amat[is0_loc].j != istr_etalon) {
																	if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}

														doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
															if (Amat[is0_loc].j != istr_etalon) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																	if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

														// В общем это двойная интерполяционная сумма 
														//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																if (Amat[is0_loc].j != istr_etalon) {

																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
																	//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {
																	if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
																		P[icount1].j = (integer_mix_precision)(i8);
																		P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		problem_conservation[icount1 - iaddR] = sumP_loc;
																		icount1++;
																		if (icount1 >= nsizePR*n) {
																			printf("memory error!!!\n");
																			printf("not enough memory for the interpolation operator.\n");
																			//system("PAUSE");
																			//exit(1);
																			deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																		}
																	}
																}
															}
														}


														//}
													}
												}
										}

									}
								}
								else {

									if (1 && (icsos >= 4)) {
										// 13_10_2016 Это лишнее т.к. ниже по коду эти действия уже есть. Избыточный код.

										// Очень большое количество сильных С узлов. 
										// Это нужно использовать для интерполяции.
										//if (ilevel > 3) {
										//printf("horosho:  icsos>=4\n");
										//getchar();
										//}
										doublerealT SumPall7 = 0.0;
										SumPall7 += sumP;

										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												// Нас интересуют только Strong связи.


												if (this_is_C_node[Amat[is0].j]  ) {
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
													if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
														if (fabs(sumP) < RealZERO) {
															//printf("error interpolation zero diagonal sumP.\n");
															//printf("Fnode all neighbour is F");
															//system("pause");
															//	printf("i8 is Dirichlet node\n");
															this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
															this_is_C_node[i8] = true;
															bweSholdbeContinue = true;
															iadditionalCstatistic++;
															//exit(1);
															// здесь нужна непрямая интерполяция.
														}
														else {
															// Это как раз единственная Strong C связь. 
															// Внедиагональный элемент из множества С узлов.

															// Данная вставка должна существенно сохранять 
															// разреженность оператора Галёркина на глубоких 
															// сеточных уровнях.
															// Модификация 5 декабря 2015.
															//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
															//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
															if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
																P[icount1].j = (integer_mix_precision)(i8);
																P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
																//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																P[icount1].aij = fabs(Amat[is0].aij) / SumPall7;
																problem_conservation[icount1 - iaddR] = SumPall7;
																icount1++;
																if (icount1 >= nsizePR*n) {
																	printf("memory error!!!\n");
																	printf("not enough memory for the interpolation operator.\n");
																	//system("PAUSE");
																	//exit(1);
																	deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																}
															}

														}
													}
												}
											}
										}

									}
									else {

										// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
										// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
										// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
										// bmodify_interpol4_amg = false;
										// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
										bool bmodify_interpol4_amg = false;
										doublerealT magic2 = 0.5;
										//magic2 = magic83;

										// Подготовительный этап к усилению четвертой интерполяции 
										// Усиление интерполяции происходит без добавления новых С узлов.
										// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
										// имеется конечно.
										// Подготовительный этап заключается в определении положения is0_candidate самой сильной
										// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
										doublerealT sum1 = 0.0;
										integer is0_candidate = -1;

										// Эта ветвь никогда не активна.
										if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {

											for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
												if (Amat[is0].j != Amat[ii1].i) {
													if (this_is_C_node[Amat[is0].j]  ) {
														//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
														if ((Amat[is0].aij > 0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold_theta)) {
															if (fabs(Amat[is0].aij) > sum1) {
																sum1 = fabs(Amat[is0].aij);
																is0_candidate = is0;
															}
														}
													}
												}
											}

											if (sum1 / sumP < magic2) {
												// Если найденный элемент слишком слабый ничего не делаем с этим С,
												// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
												sum1 = 0.0;
												is0_candidate = -1;

												// Тогда ищем среди Weakly F узлов кандидата.
												for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
													if (Amat[is0].j != Amat[ii1].i) {
														if (this_is_F_node[Amat[is0].j]  ) {
															//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
															if ((Amat[is0].aij > 0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold_theta)) {
																if (fabs(Amat[is0].aij) > sum1) {
																	sum1 = fabs(Amat[is0].aij);
																	is0_candidate = is0;
																}
															}
														}
													}
												}

#if doubleintprecision == 1
												printf("C=%lld F=%lld div=%e\n", icsos, icsosF, sum1 / sumP);
#else
												printf("C=%d F=%d div=%e\n", icsos, icsosF, sum1 / sumP);
#endif
												
												//getchar();
												system("PAUSE");
												// такой узел F должен стать новым С узлом.
												if (sum1 / sumP >= magic2) {
													printf("plosho\n");
													//getchar();
													system("PAUSE");

													this_is_F_node[i8] = false; // Этот узел  станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													byes_add = true;
													iadditionalCstatistic++;

												}
												// Обязательный сброс перед рестартом чтобы не было деления на ноль.
												sum1 = 0.0;
												is0_candidate = -1;

											}
										}


										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												if (this_is_C_node[Amat[is0].j]  ) {



													if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
														// Мы усиливаем силу интерполяции без добавления новых узлов за
														// счёт одной дополнительной самой сильной Weakly C связи.
														// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

														ioneStrongC_and_0_StrongF++;
														if (is0_candidate != -1) {
															P[icount1].j = (integer_mix_precision)(i8);
															P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_candidate].j]);
															P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
															problem_conservation[icount1 - iaddR] = sumP + sum1;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
															}
														}

														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
															P[icount1].j = (integer_mix_precision)(i8);
															P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
															P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
															problem_conservation[icount1 - iaddR] = sumP + sum1;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
															}
														}
													}
													else {

														/*
														if (icsos == 1) {

														// при icsos == 1 величина icsosF всегда 0. это граничное условие наверно.
														#if doubleintprecision == 1
															printf("ilevel=%lld C=%lld F=%lld div=%e\n", ilevel, icsos, icsosF, sum1 / sumP);
														#else
															printf("ilevel=%d C=%d F=%d div=%e\n", ilevel, icsos, icsosF, sum1 / sumP);
														#endif
														
														if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
														printf("info load\n");
														}
														getchar();
														}
														*/

														if (fabs(sumP) < RealZERO) {
															//printf("error interpolation zero diagonal sumP.\n");
															//printf("Fnode all neighbour is F");
															//system("pause");
															//printf("i8 is Dirichlet node\n");
															this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
															this_is_C_node[i8] = true;
															bweSholdbeContinue = true;
															iadditionalCstatistic++;
															//exit(1);
															// здесь нужна непрямая интерполяция.
														}
														else {

															// Внедиагональный элемент из множества С узлов.

															// Данная вставка должна существенно сохранять 
															// разреженность оператора Галёркина на глубоких 
															// сеточных уровнях.
															// Модификация 5 декабря 2015.
															//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
															//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
															if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
																P[icount1].j = (integer_mix_precision)(i8);
																P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
																P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																problem_conservation[icount1 - iaddR] = sumP;
																icount1++;
																if (icount1 >= nsizePR*n) {
																	printf("memory error!!!\n");
																	printf("not enough memory for the interpolation operator.\n");
																	//system("PAUSE");
																	//exit(1);
																	deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																}
															}

														}

													}

												}
											}
										}
									}
								}

							}
						}

					}

#if doubleintprecision == 1
					//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
					//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif
					
					//system("pause");
				}
				// this is the end


				// my_amg_manager.number_interpolation_procedure == 7
				// 1
				// the begining
				if (my_amg_manager.number_interpolation_procedure == 7) {
					//theta = 0.24;
					// theta_strong_F iter_number time,s
					// 0.21 56 22.63
					// 0.22 55 21.769
					// 0.23 52 21.488
					// 0.24 52 21.741 == theta // optimum
					// 0.26 69 24.623
					doublerealT theta_strong_F = (doublerealT)(0.23); // оптимальный выбор.
					theta_strong_F = theta83; // 3 июля 2016


					// четвёртая версия интерполяции.
					integer ioneStrongC_and_0_StrongF = 0;

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					//6interpolation 0.4 6.77 11 26 28.355
					//6interpolation 0.45 6.6 10 27 28.151
					//6interpolation 0.5 6.42 12 32 28.735
					//4interpolation 0.4 3.7  52 24.736 // best
					//4interpolation 0.3 3.78 13 59 27.525
					//4interpolation 0.5 3.61 12 55 25.533
					//4interpolation 0.45 3.65 10 63 30.24

					bool byes_add = false;
					// Быстрое добавление недостающих С узлов.
					if (1) {
						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						//doublerealT magic = 0.4; // 0.4 optimum


						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							//pc - positive connections.
							doublerealT maxelem_thresholdpc = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_thresholdpc)) {
										maxelem_thresholdpc = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij)>maxelem_threshold_theta)) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}

							// Найти соседей данного F-node которые C-node.
							integer icsos_pc = 0;
							integer icsosF_pc = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP_pc = 0.0;
							doublerealT SumPall_pc = 0.0;
							integer icount_StronglyF_pc = 0;
							doublerealT maxelem_threshold_theta_pc = maxelem_thresholdpc*theta;
							doublerealT maxelem_threshold_theta_strong_F_pc = maxelem_thresholdpc*theta_strong_F;
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_thresholdpc*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_thresholdpc*theta) {
										if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij)>maxelem_threshold_theta_pc)) {
											sumP_pc += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos_pc++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											//if (fabs(Amat[is0].aij) > maxelem_thresholdpc*theta_strong_F) {
											if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_pc)) {
												SumPall_pc += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF_pc++;
												icsosF_pc++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							{
								// ДУМАТЬ.
								if (1||(icsos == 1)) { // 5_03_2017
									if ((icsos == 1) && (icsosF != 0)) {
										// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
										//
										//SumPall += sumP;

										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												// Нас интересуют только Strong связи.
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if ((Amat[is0].aij < 0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
													if (this_is_C_node[Amat[is0].j]  ) {

														// 20 января 2016.
														// По-моему этой ситуации вообще быть не может так как у нас 
														// заведомо один С сосед.
														if (fabs(sumP) < RealZERO) {
															//printf("error interpolation zero diagonal sumP.\n");
															//printf("Fnode all neighbour is F");
															//system("pause");
															//	printf("i8 is Dirichlet node\n");
															this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
															this_is_C_node[i8] = true;
															bweSholdbeContinue = true;
															iadditionalCstatistic++;
															byes_add = true; // Были добавления узлов.
															//exit(1);
															// здесь нужна непрямая интерполяция.
														}


													}

												}
											}
										}
									}
									else {

										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (this_is_C_node[Amat[is0].j]  ) {
												if (Amat[is0].j != Amat[ii1].i) {


													// 20 jan 2016.
													// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


													if (fabs(sumP) < RealZERO) {
														// Это случай когда вообще нет сильных С соседей.


														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all neighbour is F");
														//system("pause");
														//printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														byes_add = true; // Были добавления узлов.
														//exit(1);
														// здесь нужна непрямая интерполяция.
													}


												}
											}
										}
									}
								}

							}


							//***



						}

					}



					if (!byes_add) {

						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						doublerealT magic = (doublerealT)(0.4); // 0.4 optimum
						//magic = 0.3; // 3 июля 2016 для конвективных задач
						// линейный прогноз не дает улучшений
						// ни по быстрдействию ни по числу V циклов.
						//magic = 0.5 - 0.2*ilevel / 12.0;
						magic = magic82;



						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							integer istr_etalon1 = Amat[ii1].i;
							integer iend_for1 = -1;
							for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
								iend_for1 = is0;
								if (Amat[is0].j != istr_etalon1) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							for (integer is0 = ii1; is0 <= iend_for1; is0++) {
								if (Amat[is0].j != istr_etalon1) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							if ((false) && (icsos == 1)) {
								this_is_F_node[i8] = false;
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
							}
							else {

								if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									SumPall += sumP;

									for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.


											if (this_is_C_node[Amat[is0].j]  ) {
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all neighbour is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполяция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
															P[icount1].j = (integer_mix_precision)(i8);
															P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															problem_conservation[icount1 - iaddR] = SumPall;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
															}
														}

													}
												}

											}
											else
											if (this_is_F_node[Amat[is0].j]  ) {
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
												if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
													// Рассматриваем Strong F связи.

													// Смысл:
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpointeger 
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													integer istr_etalon = Amat[ii1_loc].i;
													integer iend_for = -1;
													for (integer is0_loc = ii1_loc; (is0_loc <= row_startA[istr_etalon + 1] - 1); is0_loc++) {
														iend_for = is0_loc;
														if (this_is_C_node[Amat[is0_loc].j]  ) {
															if (Amat[is0_loc].j != istr_etalon) {
																if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}

													doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
														if (Amat[is0_loc].j != istr_etalon) {




															if (this_is_C_node[Amat[is0_loc].j]  ) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции 
															}
														}
													}

													doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

													// В общем это двойная интерполяционная сумма 
													//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
														if (this_is_C_node[Amat[is0_loc].j]  ) {
															if (Amat[is0_loc].j != istr_etalon) {

																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
																//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {
																if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
																	P[icount1].j = (integer_mix_precision)(i8);
																	P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	problem_conservation[icount1 - iaddR] = sumP_loc;
																	icount1++;
																	if (icount1 >= nsizePR*n) {
																		printf("memory error!!!\n");
																		printf("not enough memory for the interpolation operator.\n");
																		//system("PAUSE");
																		//exit(1);
																		deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																	}
																}
															}
														}
													}


													//}
												}
											}
										}

									}
								}
								else {

									if (1&&(icsos >= 4)) {
										// 13_10_2016 Это лишнее т.к. ниже по коду эти действия уже есть. Избыточный код.

										// Очень большое количество сильных С узлов. 
										// Это нужно использовать для интерполяции.
										//if (ilevel > 3) {
											//printf("horosho:  icsos>=4\n");
											//getchar();
										//}
										doublerealT SumPall7 = 0.0;
										SumPall7 += sumP;

										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												// Нас интересуют только Strong связи.


												if (this_is_C_node[Amat[is0].j]  ) {
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
													if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
														if (fabs(sumP) < RealZERO) {
															//printf("error interpolation zero diagonal sumP.\n");
															//printf("Fnode all neighbour is F");
															//system("pause");
															//	printf("i8 is Dirichlet node\n");
															this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
															this_is_C_node[i8] = true;
															bweSholdbeContinue = true;
															iadditionalCstatistic++;
															//exit(1);
															// здесь нужна непрямая интерполяция.
														}
														else {
															// Это как раз единственная Strong C связь. 
															// Внедиагональный элемент из множества С узлов.

															// Данная вставка должна существенно сохранять 
															// разреженность оператора Галёркина на глубоких 
															// сеточных уровнях.
															// Модификация 5 декабря 2015.
															//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
															//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
															if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
																P[icount1].j = (integer_mix_precision)(i8);
																P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
																//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																P[icount1].aij = fabs(Amat[is0].aij) / SumPall7;
																problem_conservation[icount1 - iaddR] = SumPall7;
																icount1++;
																if (icount1 >= nsizePR*n) {
																	printf("memory error!!!\n");
																	printf("not enough memory for the interpolation operator.\n");
																	//system("PAUSE");
																	//exit(1);
																	deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																}
															}

														}
													}
												}
											}
										}

								}
								else {

								// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
								// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
								// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
								// bmodify_interpol4_amg = false;
								// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
								bool bmodify_interpol4_amg = false;
								doublerealT magic2 = 0.5;
								//magic2 = magic83;

								// Подготовительный этап к усилению четвертой интерполяции 
								// Усиление интерполяции происходит без добавления новых С узлов.
								// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
								// имеется конечно.
								// Подготовительный этап заключается в определении положения is0_candidate самой сильной
								// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
								doublerealT sum1 = 0.0;
								integer is0_candidate = -1;

								// Эта ветвь никогда не активна.
								if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {

									for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											if (this_is_C_node[Amat[is0].j]  ) {
												//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
												if ((Amat[is0].aij > 0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold_theta)) {
													if (fabs(Amat[is0].aij) > sum1) {
														sum1 = fabs(Amat[is0].aij);
														is0_candidate = is0;
													}
												}
											}
										}
									}

									if (sum1 / sumP < magic2) {
										// Если найденный элемент слишком слабый ничего не делаем с этим С,
										// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
										sum1 = 0.0;
										is0_candidate = -1;

										// Тогда ищем среди Weakly F узлов кандидата.
										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												if (this_is_F_node[Amat[is0].j]  ) {
													//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
													if ((Amat[is0].aij > 0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold_theta)) {
														if (fabs(Amat[is0].aij) > sum1) {
															sum1 = fabs(Amat[is0].aij);
															is0_candidate = is0;
														}
													}
												}
											}
										}

#if doubleintprecision == 1
										printf("C=%lld F=%lld div=%e\n", icsos, icsosF, sum1 / sumP);
#else
										printf("C=%d F=%d div=%e\n", icsos, icsosF, sum1 / sumP);
#endif
										
										//getchar();
										system("PAUSE");
										// такой узел F должен стать новым С узлом.
										if (sum1 / sumP >= magic2) {
											printf("plosho\n");
											//getchar();
											system("PAUSE");

											this_is_F_node[i8] = false; // Этот узел  станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											byes_add = true;
											iadditionalCstatistic++;

										}
										// Обязательный сброс перед рестартом чтобы не было деления на ноль.
										sum1 = 0.0;
										is0_candidate = -1;

									}
								}


								for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j]  ) {



											if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
												// Мы усиливаем силу интерполяции без добавления новых узлов за
												// счёт одной дополнительной самой сильной Weakly C связи.
												// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

												ioneStrongC_and_0_StrongF++;
												if (is0_candidate != -1) {
													P[icount1].j = (integer_mix_precision)(i8);
													P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_candidate].j]);
													P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
													problem_conservation[icount1 - iaddR] = sumP + sum1;
													icount1++;
													if (icount1 >= nsizePR*n) {
														printf("memory error!!!\n");
														printf("not enough memory for the interpolation operator.\n");
														//system("PAUSE");
														//exit(1);
														deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
													}
												}

												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
													P[icount1].j = (integer_mix_precision)(i8);
													P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
													P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
													problem_conservation[icount1 - iaddR] = sumP + sum1;
													icount1++;
													if (icount1 >= nsizePR*n) {
														printf("memory error!!!\n");
														printf("not enough memory for the interpolation operator.\n");
														//system("PAUSE");
														//exit(1);
														deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
													}
												}
											}
											else {

												/*
												if (icsos == 1) {

													// при icsos == 1 величина icsosF всегда 0. это граничное условие наверно.
													#if doubleintprecision == 1
														printf("ilevel=%lld C=%lld F=%lld div=%e\n", ilevel, icsos, icsosF, sum1 / sumP);
													#else
														printf("ilevel=%d C=%d F=%d div=%e\n", ilevel, icsos, icsosF, sum1 / sumP);
													#endif
													
													if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
														printf("info load\n");
													}
													getchar();
												}
												*/

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												else {

													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
													if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
														P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														problem_conservation[icount1 - iaddR] = sumP;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
														}
													}

												}

											}

										}
									}
								}
							}
								}

							}
						}

					}

#if doubleintprecision == 1
					//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
					//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif
					
					//system("pause");
				}
				// this is the end

				
				if (0) {
					// делаем как рекомендовал Falgout
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						
						//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.
						//theta = 0.24;
						doublerealT znamenatel = 0.0;
						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > theta*maxelem_threshold)) {
									// Strong connections
								}
								else {
									// Weakly connections
									znamenatel += Amat[is0].aij;
								}

							}
							else {
								// диагональный элемент.
								znamenatel += Amat[is0].aij;
							}
						}

						if (fabs(znamenatel) > 1.0e-30) {

							znamenatel = fabs(znamenatel);

							// Сумма всех Strong F соседей узла i8.
							doublerealT sumapF = 0.0;
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_F_node[Amat[is0].j]) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > theta*maxelem_threshold)) {
											// Strong connections
											sumapF += Amat[is0].aij;
										}
									}
								}
							}

							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]) {
										doublerealT wij = Amat[is0].aij;

										if (fabs(sumapF) > 1.0e-30) {
											// Перебираем всех Strong F соседей узла i.
											for (integer is0l = ii1; (is0l <= row_startA[Amat[ii1].i + 1] - 1); is0l++) {
												if (Amat[is0l].j != Amat[ii1].i) {
													if (this_is_F_node[Amat[is0l].j]) {
														if ((Amat[is0l].aij<0.0) && (fabs(Amat[is0l].aij) > theta*maxelem_threshold)) {
															// Strong connections
															// Текущий Strong F сосед.
															integer i9 = Amat[is0l].j;
															// Есть ли среди его соседей узел Amat[is0].j
															integer ii6 = row_startA[i9];
															doublerealT maxelm_threshold_magic = (doublerealT)(-1.0e37);
															for (integer is0s = ii6; (is0s <= row_startA[Amat[ii6].i + 1] - 1); is0s++) {
																if (Amat[is0s].j != Amat[ii6].i) {
																	if ((Amat[is0s].aij<0.0) && (fabs(Amat[is0s].aij)>maxelm_threshold_magic)) {
																		maxelm_threshold_magic = fabs(Amat[is0s].aij);
																	}
																}
															}

															for (integer is0s = ii6; (is0s <= row_startA[Amat[ii6].i + 1] - 1); is0s++) {
																if (Amat[is0s].j != Amat[ii6].i) {
																	if (Amat[is0s].j == Amat[is0].j) {
																		// Найдено.
																		if ((Amat[is0s].aij<0.0) && (fabs(Amat[is0s].aij) > 0.35*maxelm_threshold_magic)) {
																			// Теперь точно найдено.
																		     wij += (Amat[is0s].aij / sumapF)*Amat[is0l].aij;
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
										P[icount1].j = (integer_mix_precision)(i8);
										P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
										P[icount1].aij = -wij / znamenatel; // именно минус не забываем.
										problem_conservation[icount1 - iaddR] = znamenatel;
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
										}

									}
								}
							}
						}
						else {
							printf("zero  znamenatel in Falgout = %e\n", znamenatel);
							//getchar();
							system("PAUSE");
							exit(1);
						}
						if (znamenatel < 0.0) {
							printf("negative  znamenatel in Falgout = %e\n", znamenatel);
						}

					}
				}

				//my_amg_manager.number_interpolation_procedure == 4
				// 0
				if (my_amg_manager.number_interpolation_procedure == 4) {
					// пятая попытка.
					// показывает время 1.22 против времени в 1.36 в четвертой попытке.

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполяции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j]  ) {
								if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j]  ) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполяцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}



						// 1 января 2016 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if ((icsos == 1) && (icsosF != 0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											if (this_is_C_node[Amat[is0].j]  ) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//	printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												else {
													// Это как раз единственная Strong C связь. 
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
														}
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {

													// Рассматриваем Strong F связи.

													// Смысл:
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpointeger 
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j]  ) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции 
															}
														}
													}

													// В общем это двойная интерполяционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	P[icount1].j = (integer_mix_precision)(i8);
																	P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																	if (icount1 >= nsizePR*n) {
																		printf("memory error!!!\n");
																		printf("not enough memory for the interpolation operator.\n");
																		//system("PAUSE");
																		//exit(1);
																		deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																	}
																}
															}
														}
													}


													//}
												}
										}
									}
								}
							}
							else {

								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {

										if (this_is_C_node[Amat[is0].j]  ) {

											if (fabs(sumP) < RealZERO) {
												//printf("error interpolation zero diagonal sumP.\n");
												//printf("Fnode all neighbour is F");
												//system("pause");
												//printf("i8 is Dirichlet node\n");
												this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
												this_is_C_node[i8] = true;
												bweSholdbeContinue = true;
												iadditionalCstatistic++;
												//exit(1);
												// здесь нужна непрямая интерполяция.
											}
											else {

												// Внедиагональный элемент из множества С узлов.

												// Данная вставка должна существенно сохранять 
												// разреженность оператора Галёркина на глубоких 
												// сеточных уровнях.
												// Модификация 5 декабря 2015.
												//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
												if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
													P[icount1].j = (integer_mix_precision)(i8);
													P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
													P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
													//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
													icount1++;
													if (icount1 >= nsizePR*n) {
														printf("memory error!!!\n");
														printf("not enough memory for the interpolation operator.\n");
														//system("PAUSE");
														//exit(1);
														deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
													}
												}

											}

										}
										else
											if (this_is_F_node[Amat[is0].j]  ) {

												// Рассматриваем Strong F связи.
												// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
												// Смысл:
												//



												//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
												// Это лишнее условие, ранее уже было проверено что мы имеем дело
												// с сильной F связью.
												if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpoint
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j]  ) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции
															}
														}
													}

													// В общем это двойная интерполяционная сумма
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j]  ) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять
																// разреженность оператора Галёркина на глубоких
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	P[icount1].j = (integer_mix_precision)(i8);
																	P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																	if (icount1 >= nsizePR*n) {
																		printf("memory error!!!\n");
																		printf("not enough memory for the interpolation operator.\n");
																		//system("PAUSE");
																		//exit(1);
																		deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																	}
																}
															}
														}
													}


													//}
												}
											}


									}
								}
							}

						}

					}
				}


				// my_amg_manager.number_interpolation_procedure == 5
				// 0
				if (my_amg_manager.number_interpolation_procedure == 5) {

					bool byes_add = false;
					//  быстрая проверка на добавление.
					if (1) {
						// шестая попытка.
						// CGHV1J amg1r5 time 0.26
						// cl_agl_amg_v0_14 time:
						// magic  time number V cycles grid complexity
						// 0.25   0:48  29  6.55A
						// 0.3    0:45  28  6.19A 
						// 0.35  0:43   28  5.98A
						// 0.4   0:41   27  5.77A // отыграно 14% производительности.
						// tgf2023_10 amg1r5 time 1:00
						// cl_agl_amg_v0_14 time
						// magic  time number V cycles grid complexity
						// 0.25 1:49 27 3.61
						// 0.3 1:47 26 3.47
						// 0.35 1:46 27 3.51
						// 0.4 1:44 28 3.413 // отыграно 5% производительности.
						// Electric potencial in FET2 amg1r5 time 1:38
						// cl_agl_amg_v0_14 time:
						// magic  time number V cycles grid complexity
						// 0.25 3:19 36 6.65
						// 0.3 3:02 34 6.34
						// 0.35 2:52 33 6.091
						// 0.4 2:46 33 5.91 // отыграно 20% производительности.

						// magic=0.4 is optimum.11 jan 2016
						doublerealT magic = (doublerealT)(0.4); // 0.4

						// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
						// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
						// сильных F узлов.

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							 {

								 if ((icsos == 1) && (icsosF != 0)) {
									 // Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									 //
									 SumPall += sumP;

									 for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										 if (Amat[is0].j != Amat[ii1].i) {
											 // Нас интересуют только Strong связи.
											 if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												 if (this_is_C_node[Amat[is0].j]  ) {

													 if (fabs(sumP) < RealZERO) {
														 //printf("error interpolation zero diagonal sumP.\n");
														 //printf("Fnode all neighbour is F");
														 //system("pause");
														 //	printf("i8 is Dirichlet node\n");
														 this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														 this_is_C_node[i8] = true;
														 bweSholdbeContinue = true;
														 iadditionalCstatistic++;
														 byes_add = true;
														 //exit(1);
														 // здесь нужна непрямая интерполяция.
													 }


												 }

											 }
										 }
									 }
								 }
								 else {



									 for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										 if (Amat[is0].j != Amat[ii1].i) {

											 if (this_is_C_node[Amat[is0].j]  ) {

												 if (fabs(sumP) < RealZERO) {
													 //printf("error interpolation zero diagonal sumP.\n");
													 //printf("Fnode all neighbour is F");
													 //system("pause");
													 //printf("i8 is Dirichlet node\n");
													 this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													 this_is_C_node[i8] = true;
													 bweSholdbeContinue = true;
													 iadditionalCstatistic++;
													 byes_add = true;
													 //exit(1);
													 // здесь нужна непрямая интерполяция.
												 }


											 }



										 }
									 }



								 }

							 }

						}
					}


					// Проверка на добавление пройдена успешно, 
					// добавлений не было и можно интерполировать !!!.
					if (byes_add == false) {

						// шестая попытка.
						// CGHV1J amg1r5 time 0.26
						// cl_agl_amg_v0_14 time:
						// magic  time number V cycles grid complexity
						// 0.25   0:48  29  6.55A
						// 0.3    0:45  28  6.19A 
						// 0.35  0:43   28  5.98A
						// 0.4   0:41   27  5.77A // отыграно 14% производительности.
						// tgf2023_10 amg1r5 time 1:00
						// cl_agl_amg_v0_14 time
						// magic  time number V cycles grid complexity
						// 0.25 1:49 27 3.61
						// 0.3 1:47 26 3.47
						// 0.35 1:46 27 3.51
						// 0.4 1:44 28 3.413 // отыграно 5% производительности.
						// Electric potencial in FET2 amg1r5 time 1:38
						// cl_agl_amg_v0_14 time:
						// magic  time number V cycles grid complexity
						// 0.25 3:19 36 6.65
						// 0.3 3:02 34 6.34
						// 0.35 2:52 33 6.091
						// 0.4 2:46 33 5.91 // отыграно 20% производительности.

						// magic=0.4 is optimum.11 jan 2016
						doublerealT magic = (doublerealT)(0.4); // 0.4

						// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
						// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
						// сильных F узлов.

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполяции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j]  ) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j]  ) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполяцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							if ((false) && (icsos == 1)) {
								this_is_F_node[i8] = false;
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
							}
							else {

								if ((icsos == 1) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									SumPall += sumP;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												if (this_is_C_node[Amat[is0].j]  ) {

													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all neighbour is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполяция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
															P[icount1].j = (integer_mix_precision)(i8);
															P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
															}
														}

													}

												}
												else
													if (this_is_F_node[Amat[is0].j]  ) {

														// Рассматриваем Strong F связи.

														// Смысл:
														// 



														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														// Это лишнее условие, ранее уже было проверено что мы имеем дело
														// с сильной F связью.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														// В общем это двойная интерполяционная сумма 
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
																		P[icount1].j = (integer_mix_precision)(i8);
																		P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																		if (icount1 >= nsizePR*n) {
																			printf("memory error!!!\n");
																			printf("not enough memory for the interpolation operator.\n");
																			//system("PAUSE");
																			//exit(1);
																			deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																		}
																	}
																}
															}
														}


														//}
													}
											}
										}
									}
								}
								else {

									SumPall += sumP;
									doublerealT sum_ok = 0.0;
									bool bbackreturn = false;
									integer icount1_mem = icount1;
									bool* bbackrarr = nullptr;
									//bbackrarr = new bool[icount_StronglyF];
									bbackrarr = (bool*)malloc(icount_StronglyF*sizeof(bool));
									handle_error<bool>(bbackrarr, "bbackrarr", "classic_aglomerative_amg_5", icount_StronglyF);

									for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
										bbackrarr[i_63] = false;
									}
									integer icounter_bbackarr = -1;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {

											if (this_is_C_node[Amat[is0].j]  ) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all neighbour is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполяция.
												}
												else {

													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
														P[icount1].j = (integer_mix_precision)(i8);
														P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
														//P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														P[icount1].aij = fabs(Amat[is0].aij);
														sum_ok += fabs(Amat[is0].aij);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
														}
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j]  ) {

													// Рассматриваем Strong F связи.
													// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
													// Смысл:
													//



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

														icounter_bbackarr++;

														integer iFpoint = Amat[is0].j;
														//doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														doublerealT mult1 = fabs(Amat[is0].aij);
														// сканируем всех соседей iFpoint
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														icsos_loc = 0;
														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc1 = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j]  ) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
																		//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc)>maxelem_threshold*theta) {
																		sumP_loc1 += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																		//	}
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														if (icsos_loc > 0) {
															// В общем это двойная интерполяционная сумма
															for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
																if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																	if (this_is_C_node[Amat[is0_loc].j]  ) {
																		// Внедиагональный элемент из множества С узлов.

																		// Данная вставка должна существенно сохранять
																		// разреженность оператора Галёркина на глубоких
																		// сеточных уровнях.
																		// Модификация 5 декабря 2015.
																		//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																		//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
																			//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc) > maxelem_threshold*theta) {
																			P[icount1].j = (integer_mix_precision)(i8);
																			P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
																			//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																			//P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			P[icount1].aij = mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			sum_ok += mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			icount1++;
																			if (icount1 >= nsizePR*n) {
																				printf("memory error!!!\n");
																				printf("not enough memory for the interpolation operator.\n");
																				//system("PAUSE");
																				//exit(1);
																				deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																			}
																		}
																		//}
																	}
																}
															}
														}
														else {
															//bbackreturn = true;
															bbackrarr[icounter_bbackarr] = true;
														}


														//}
													}
												}


										}
									}


									//bbackreturn = true;
									//for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
									//if (!bbackrarr[i_63]) {
									//	bbackreturn = false;
									//}
									//}

									//if (bbackreturn) {
									// сильные F связи не дали результата, поэтому мы возвращаемся к исходному 
									// варианту интерполяции.
									//for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
									//P[i_95].aij = P[i_95].aij*SumPall / sumP;
									//}
									//}

									// Апосториорная коррекция
									for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
										P[i_95].aij = P[i_95].aij / sum_ok;
									}

									free(bbackrarr);

								}

							}

						}
					}

				}

			}
			else if (true) {


				// Экспериментальная интерполяция 1 января 2016.

				ipromah = 0;
				ipromah_one = 0;
				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
				for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

					// Нам нужен разреженный оператор Галёркина.
					// 5 декабря 2015 года мы попробуем увеличить разреженность
					// оператора интерполяции а значит и оператора Галёркина.
					doublerealT maxelem_threshold = -1.0;
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					integer ii1 = row_startA[i8];
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Наверно разумно что threshold определён по всей строке, а не только по С узлам в строке.
							//if (this_is_C_node[Amat[is0].j]  ) {
							if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
					// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					// Найти соседей данного F-node которые C-node.
					integer icsos = 0;

					doublerealT SumPall = 0.0;
					// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					doublerealT sumP = 0.0;
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {

							// Сумма вообще всех внедиагональных элементов.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								SumPall += fabs(Amat[is0].aij);
							}


							if (this_is_C_node[Amat[is0].j]  ) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									icsos++;
								}
							}
							else {
								// Подсчитываем количество соседей которые не являются С узлами.
								ipromah++; // подсчитываем проблемы интерполяции 
							}
						}
					}
					if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


					// 1 января 2015 Один сосед это недостаточно.
					// Поэтому в случае одного соседа делаем такой узел С узлом.
					if ((false) && (icsos == 1)) {
						this_is_F_node[i8] = false;
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
					}
					else {



						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j]  ) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all neighbour is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполяция.
									}
									else {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											P[icount1].j = (integer_mix_precision)(i8);
											P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j]  ) {

										// Смысл:
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

											integer iFpoint = Amat[is0].j;
											doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublerealT maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увеличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j]  ) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//ipromah_loc++; // подсчитываем проблемы интерполяции 
													}
												}
											}

											// В общем это двойная интерполяционная сумма 
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
															P[icount1].j = (integer_mix_precision)(i8);
															P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0_loc].j]);
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
															}
														}
													}
												}
											}


										}
									}
							}
						}

					}


				}
			}
			else {
				// От интерполяции зависит очень много поэтому
				// реализуем следующую экспериментальную идею интерполяции.
				// Эта интерполяция претендует быть единственно теоретически верной,
				// сделанной на основе литературных данных.


				ipromah = 0;
				ipromah_one = 0;
				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
				for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8]  ) {

					// Нам нужен разреженный оператор Галёркина.
					// 5 декабря 2015 года мы попробуем увеличить разреженность
					// оператора интерполяции а значит и оператора Галёркина.
					doublerealT maxelem_threshold = -1.0;
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					integer ii1 = row_startA[i8];
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Если закомментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j]  ) {
							if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
					// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					// Найти соседей данного F-node которые C-node.
					//integer icsos = 0;

					

					// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					// Для каждого такого члена суммы увеличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					doublerealT sumP = 0.0;
					doublerealT sumPindicator = 0.0;
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j]  ) {
								if ((Amat[is0].aij>0.0)||(fabs(Amat[is0].aij) <= maxelem_threshold*theta)) {
									// Weak connectors
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									//icsos++;
								}
								else {
									sumPindicator += fabs(Amat[is0].aij);
								}
							}
							else {
								// Подсчитываем количество соседей которые не являются С узлами.
								if ((Amat[is0].aij>0.0)||(fabs(Amat[is0].aij) <= maxelem_threshold*theta)) {
									// Weak connectors
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									//icsos++;
								}
								ipromah++; // подсчитываем проблемы интерполяции 
							}
						}
						else {
							// Диагональный элемент.
							sumP += fabs(Amat[is0].aij);
						}
					}
					//if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


					// 1 января 2015 Один сосед это недостаточно.
					// Поэтому в случае одного соседа делаем такой узел С узлом.
					//if ((false) && (icsos == 1)) {
					//this_is_F_node[i8] = false;
					//this_is_C_node[i8] = true;
					//bweSholdbeContinue = true;
					//}
					//else
					{

						if (fabs(sumPindicator) < RealZERO) {
							//printf("error interpolation zero diagonal sumP.\n");
							//printf("Fnode all neighbour is F");
							//system("pause");
							//printf("i8 is Dirichlet node\n");
							this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
							iadditionalCstatistic++;
							//exit(1);
							// здесь нужна непрямая интерполяция.

							// Мы не будем добалять С узлы, мы будем использовать непрямую интерполяцию.



						}
						else {

							integer icount1_frozen = icount1;

							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											// Strongly C connectors.

											P[icount1].j = (integer_mix_precision)(i8);
											P[icount1].i = (integer_mix_precision)(C_numerate[Amat[is0].j]);
											P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
											}
										}


									}
								}
							}

							integer ilength_n = icount1 - icount1_frozen;
							integer* jposition_in_P = nullptr;
							//jposition_in_P = new integer[ilength_n];
							jposition_in_P = (integer*)malloc(ilength_n*sizeof(integer));
							handle_error<integer>(jposition_in_P, "jposition_in_P", "classic_aglomerative_amg_5", ilength_n);



							integer i_97 = 0;

							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]  ) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											// Strongly C connections j position.
											jposition_in_P[i_97] = Amat[is0].j;
											i_97++;
										}
									}
								}
							}


							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_F_node[Amat[is0].j]  ) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											// Strong F connections
											doublerealT my_mult = fabs(Amat[is0].aij);
											integer iFpoint = Amat[is0].j;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];

											// Смотрим всех соседей узла iFpoint
											// если среди них окажутся сильные С соседи 
											// первоначально рассматриваемого узла Amat[ii1].i
											// то мы будем накапливать в сумматоре sum23 
											// модули значеий матрицы.
											doublerealT sum23 = 0.0;
											bool bvisit23 = false;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j]  ) {
														for (i_97 = 0; i_97 < ilength_n; i_97++) {
															if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																sum23 += fabs(Amat[is0_loc].aij);
																bvisit23 = true;
																break;
															}
														}
													}
												}
											}

											//if (fabs(sum23) > RealZERO) {
											if (bvisit23) {
												// мы точно не делим на ноль.

												// Сканируем всех соседей узла F.
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j]  ) {
															for (i_97 = 0; i_97 < ilength_n; i_97++) {
																if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																	//P[icount1_frozen + i_97].j = i8;
																	//P[icount1_frozen+i_97].i = C_numerate[Amat[is0].j];
																	P[icount1_frozen + i_97].aij += (my_mult*fabs(Amat[is0_loc].aij)) / (sumP*sum23);
																	break;
																}
															}
														}
													}
												}
											}


										}
									}
								}
							}

							//delete[] jposition_in_P;
							free(jposition_in_P);

						}

					}


				}
			}



			if (bweSholdbeContinue) {
				//delete[] ap_coarse;
				free(ap_coarse);
				ap_coarse = nullptr;
				if (bprint_mesage_diagnostic) {
					printf("obratnaq svqz restart...\n");
				}
			}

			if (bprint_mesage_diagnostic) {
				printf("addition C nodes procent %3.1f", (doublerealT)(100.0*iadditionalCstatistic / n_a[ilevel - 1]));
			}
			iadditionalCstatistic = 0;
			//system("pause");


		}

		nnzR = icount1 - iaddR;



		// нужно определить nnzR количество ненулевых элементов в матрице R и P.

		// оператор restriction построен и он упорядочен по i.
		// число ненулевых элементов nnzR-1.
		// P=Copy(R);
		integer iend_marker_position = iaddR + nnzR - 1;
		for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
			//R[ii] = P[ii];
			// 18 августа 2016 года.
			R[ii] = P[ii];
			//if (fabs(R[ii].aij - 1.0) > 1.0e-20) {
			//	printf("%e\n", R[ii].aij*problem_conservation[ii - iaddR]);
			//	getchar();
			//}
			//R[ii].aij *= problem_conservation[ii - iaddR];
			/*
			if (ilevel == 1) {
				// Первый уровень в 2D соответствует пятиточечному шаблону.
				R[ii].aij *= 1.0 / (2.0*2.0*2.0); // 3D coarcen by 2
			}
			else {
				// более глубокие уровни соответствуют девятиточечному шаблону в 2D.
				R[ii].aij *= 1.0/(6.0858);
			}
			*/
			//if ((ilevel == 2) && (ii >= iaddR + nnzR - 1-30)) {
#if doubleintprecision == 1
			//printf("ii=%lld aij=%e, i=%lld j=%lld\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#else
			//printf("ii=%d aij=%e, i=%d j=%d\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#endif
			
			//getchar();
			//}
		}

		// Этот оператор нужен для вычисления grid complexity для оператора 
		// интерполяции и проекции. Данная информация важна для оптимизации количества выделяемой памяти.
		if (ilevel - 1 == 0) {
			nnz_P_memo_0 = iend_marker_position - (iaddR + 1) + 1;
		}
		else {
			nnz_P_memo_all = iend_marker_position;
		}


		for (integer j85 = 1; j85 <= n_a[ilevel-1]; j85++) {
			flag85[j85] = false;
		}
		for (integer ii85 = 1 + iaddR; ii85 <= iaddR + nnzR - 1; ii85++) {
			if (flag85[P[ii85].j] == false) {
				integer jstr = P[ii85].j;
				integer ic85 = ii85;
				if ((ic85 + 1 <= n_a[ilevel - 1]) && (P[ic85 + 1].j == jstr)) {
					doublerealT minimum_aij = (doublerealT)(1.0e37);
					doublerealT maximum_aij = (doublerealT)(-1.0e37);
					while ((ic85 <= n_a[ilevel - 1]) && (P[ic85].j == jstr)) {

						//x_fine[jstr] += P[ic].aij*x_coarse[P[ic].i];
						if (P[ic85].aij > maximum_aij) {
							maximum_aij = P[ic85].aij;
						}
						if (P[ic85].aij < minimum_aij) {
							minimum_aij = P[ic85].aij;
						}

						//printf("aij=%e sum=%e\n", P[ic85].aij, problem_conservation[ii85 - iaddR]);
						
						ic85++;
					}
					//printf("end string\n");
					//getchar();
					ic85 = ii85;
					while ((ic85 <= n_a[ilevel - 1]) && (P[ic85].j == jstr)) {
						// Так определено в литературе.
						// Даёт хорошую стабильную норму лучше среди всех предыдущих,
						// но сходимость cfd резко испортилась.
						// изменение тестовой нормы (пока наилучшее):
						// 3.334269e-5
						// 5.273e-4
						// 9.4239e-4
						// 8.113e-4
						// Максимальный элемент  нормирован на единицу.
						// Prolongation на диагонали единица.
					   // P[ic85].aij = P[ic85].aij / maximum_aij;
						// Restriction сумма значений элементов в строке есть единица.
						//R[ic85].aij = R[ic85].aij;
						ic85++;
					}
				}

				flag85[P[ii85].j] = true;
			}
		}

		delete[] problem_conservation;
		// heapsort(P,key==j,iaddR+1,iaddR+nnzR - 1);

		/*
		// 10 января 2016. Эта сортировка не требуется.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
		// Быстрая сортировка Хоара.
		qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		*/


		// где то надо разделить на ap, т.к. 
		// R=P/ap. ????


		// heapsort(R,key==i,iaddR+1,iaddR+nnzR - 1);

		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(R, 1 + iaddR, iaddR + nnzR - 1, false, indx_comparei);
			}
			else {
				qs(R, 1 + iaddR, iaddR + nnzR - 1, indx_comparei);
			}
		}
		else {
			HeapSort(R, 1 + iaddR, iaddR + nnzR - 1,comparei);
		}


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("first level size n=%lld numberofcoarcenodes=%lld\n", n, numberofcoarcenodes);
#else
			printf("first level size n=%d numberofcoarcenodes=%d\n", n, numberofcoarcenodes);
#endif
			
		}

		// Корректировка диагонали restriction
		if (0) {
			// убрано 2 января 2015 года.
			// Убирание этого сомнительного шага дало сокращение 
			// времени счтёта для 1M неизвестных с 51с(131 итерация) до 42с (91 итерации).
			// на задаче tgf2023_01 включение данного шага приводит к расходимости вычислительного процесса.

			if (debug_reshime) system("pause");
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				flag[i_1] = false; // init flag.
			}

			for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
				if (flag[R[i_1].i] == false)
				{
					for (integer i_2 = i_1; (i_2 <= iaddR + nnzR - 1) && (R[i_2].i == R[i_1].i); i_2++) {
						if ((R[i_1].i<1) || (R[i_1].i>numberofcoarcenodes)) {
#if doubleintprecision == 1
#if INTEGER_MIX_PRECISION_IS_INT
							printf("error R[%lld].i=%d\n", i_1, R[i_1].i);
#else
							printf("error R[%d].i=%lld\n", i_1, R[i_1].i);
#endif
#else
							printf("error R[%d].i=%d\n", i_1, R[i_1].i);
#endif
							
							system("pause");
						}
						if (fabs(ap_coarse[R[i_1].i]) < divisionZERO) {
							printf("error division by zero\n");
							system("pause");
						}
						doublerealT delitel;
						if (ap_coarse[R[i_1].i] > 1.0) {
							// internal node
							delitel = (doublerealT)(0.5*ap_coarse[R[i_1].i]);
						}
						else {
							// Dirichlet
							delitel = ap_coarse[R[i_1].i];
						}
						R[i_2].aij = R[i_2].aij / (delitel);
					}
					flag[R[i_1].i] = true;
				}
			}
		}

		//delete[] ap_coarse;
		free(ap_coarse);





		// Сортировка А по j.
		//heapsort(Amat, key=j*n_a[ilevel - 1] + i, 1, nnz_a[ilevel - 1]);

		// Лишний код потомучто потом сразу же следует сортировка по i.
		/*
		// 7 января 2016. закомментировано.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sortj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		qsj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		}
		else {
		HeapSort_j(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/

		// MARKER GUSTAVSON

		// Нахождение матрицы грубосеточного уровня:
		// Acorse=R*Afine*P;
		// часть 1: R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", nnzR, nnz_a[ilevel - 1]);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", nnzR, nnz_a[ilevel - 1]);
#endif
			
		}

		integer istartAnew;


		// Фред Густавсон IBM 1978.
		// 23 октября 2015 года.

		// часть 1: R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]
		// Сортировка А по строкам.
		/*
		// 7 января 2016. Сортировка матрицы А была выполнена единожды при начале обработке данного уровня.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		}
		else {
		HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/
		// Преобразование к формату CRS.

		integer* row_ind_SR = nullptr;
		//row_ind_SR = new integer[numberofcoarcenodes + 1];
		row_ind_SR = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_SR, "row_ind_SR", "classic_aglomerative_amg_5", (numberofcoarcenodes + 1));

		integer* row_ind_ER = nullptr;
		//row_ind_ER = new integer[numberofcoarcenodes + 1];
		row_ind_ER = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_ER, "row_ind_ER", "classic_aglomerative_amg_5", (numberofcoarcenodes + 1));

		for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			row_ind_SR[i_1] = -1;
			row_ind_ER[i_1] = -2;
		}
		integer istart1 = 1 + iaddR;
		integer iend1 = nnzR - 1 + iaddR;
		for (integer i = 1; i <= icounter - 1; i++) {
			flag[i] = false;
		}
		for (integer ii = istart1; ii <= iend1; ii++) {
			if (flag[R[ii].i] == false) {
				integer istr = R[ii].i;
				integer ic = ii;
				integer kf = ic;

				while ((kf <= iend1) && (R[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_SR[istr] = ic;
				row_ind_ER[istr] = kf;
				flag[R[ii].i] = true;
			}
		}

		// Пустые строки просто отсутствуют.
		//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
		//if (row_ind_SR[i_1] == -1) {
#if doubleintprecision == 1
		//printf("empty string %lld\n", row_ind_ER[i_1]);
#else
		//printf("empty string %d\n", row_ind_ER[i_1]);
#endif
		
		//}
		//}

		integer* row_ind_SA = nullptr;
		//row_ind_SA = new integer[n_a[ilevel - 1] + 1];
		row_ind_SA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_SA, "row_ind_SA", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		integer* row_ind_EA = nullptr;
		//	row_ind_EA = new integer[n_a[ilevel - 1] + 1];
		row_ind_EA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_EA, "row_ind_EA", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		integer istart3 = 1 + iadd;
		integer iend3 = nnz_a[ilevel - 1] + iadd;
		for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
			flag[i] = false;
		}
		for (integer ii = istart3; ii <= iend3; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer kf = ic;

				while ((kf <= iend3) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_SA[istr] = ic;
				row_ind_EA[istr] = kf;
				flag[Amat[ii].i] = true;
			}
		}

		istartAnew = nnz_a[ilevel - 1] + 1 + iadd;

		// Данные используемые для частичного формирователя суммы.
		doublerealT* vector_sum = nullptr;
		//vector_sum = new doublerealT[n_a[ilevel - 1] + 1];
		vector_sum = (doublerealT*)malloc((n_a[ilevel - 1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		//bool* b_visit_vec_sum = new bool[n_a[ilevel - 1] + 1];
		//integer size_v = sizeof(doublerealT)*(1 + n_a[ilevel - 1]);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		integer* index_visit = nullptr;
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		integer index_size = 0;




		// Сканируем первый операнд построчно.
		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Начинаем обрабатывать новую строку.
			// Сброс формирователя суммы в ноль.
			//#pragma omp parallel for
			//for (integer i_2 = 1; i_2 <= n_a[ilevel - 1]; i_2++) {
			//vector_sum[i_2] = 0.0; // инициализация // 18.5
			//b_visit_vec_sum[i_2] = false;
			//}
			// Более быстрое обнуление
			// По времени в лучшем случае также. Но может сильно ухудшиться из-за занятости системной dll-ки.
			//memset(vector_sum, 0,size_v );

			node_AVL_Gus* root_Gus = 0;
#if 0
			if (0) {

				// линейный поиск очень медленный на больших размерностях.

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else if (0) {

				// закомментировано т.к. это медленная ветвь кода.
				// Ситуация такая. Ранее на небольших задачах до 1М включительно,
				// данная ветвь кода не показывала выигрыша в быстродействии и возможно 
				// даже была слегка медленее (совсем немного). 
				// Это быстрая часть кода на больших размерностях.
				// Гораздо лучше линейного поиска. Сейчас это подтверждается
				// на непрямой интерполяции при задаче в 3.2М неизвестных.
				// Там на линейный поиск в данном месте тратится не менее 80% фазы построения грубосеточных операторов.

				// На основе АВЛ
				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							root_Gus = insert_Gus(root_Gus, iaddind);
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else 
#endif
			{

				// на основе hash таблицы. 

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						//foundnow = isfound_Gus(root_Gus, iaddind);
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							//root_Gus = insert_Gus(root_Gus, iaddind);
							hash_table[iaddind] = true;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}


			doublerealT maxth = -1.0;
			if (0) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					hash_table[jstr] = false; // инициализируем hash таблицу для следующих проходов.
					if (istr != jstr) {
						// 14 января 2016.
						// Правильнее определить величину барьера только по внедиагональным элементам.
						if (fabs(vector_sum[jstr]) > maxth) maxth = vector_sum[jstr];
					}
				}
			}
			else {
				// 23 10 2016 Первый барьер полностью отключён.
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					hash_table[jstr] = false; // инициализируем hash таблицу для следующих проходов.
				}
			}

			/*
			if (nsizeA > istartAnew + index_size) {
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
			integer jstr = index_visit[i_6];
			if (istr != jstr) {
			// 5 декабря 2015. threshold.
			//if (fabs(vector_sum[jstr]) > 1.0e-30) {
			if (fabs(vector_sum[jstr]) > barjer*maxth) {
			Amat[istartAnew].aij = vector_sum[jstr];
			Amat[istartAnew].i = istr;
			Amat[istartAnew].j = jstr;
			istartAnew++;
			}
			}
			else {
			// диагональный элемент записываем обязательно.
			Amat[istartAnew].aij = vector_sum[jstr];
			Amat[istartAnew].i = istr;
			Amat[istartAnew].j = jstr;
			istartAnew++;
			}
			}
			}
			else {
			// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
			// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
			printf("Amat lack of memory\n");
			printf("yuo mast increase the size of the matrix Amat and restart solver\n");
			printf("please, press any key to exit.\n");
			system("pause");
			exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем
			// проверками.
			doublerealT barjer_maxth = barjer*maxth;
			doublerealT mbarjer_maxth = -barjer_maxth;
			if (nsizeA > istartAnew + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];

					doublerealT vs1 = vector_sum[jstr];
					if (0) {
						if ((vs1 < mbarjer_maxth) || (vs1 > barjer_maxth)) {
							//Amat[istartAnew].aij = vs1;
							//Amat[istartAnew].i = istr;
							//Amat[istartAnew].j = jstr;
							//istartAnew++;

							Ak1 Atemp;
							Atemp.aij = vs1;
							Atemp.i = (integer_mix_precision)(istr);
							Atemp.j = (integer_mix_precision)(jstr);
							Amat[istartAnew++] = Atemp;

						}
					}
					else {
						//Amat[istartAnew].aij = vs1;
						//Amat[istartAnew].i = istr;
						//Amat[istartAnew].j = jstr;
						//istartAnew++;

						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = (integer_mix_precision)(istr);
						Atemp.j = (integer_mix_precision)(jstr);
						Amat[istartAnew++] = Atemp;

					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			index_size = 0; // Сброс индикатора, строка обработана.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

		}



		//delete[] index_visit;
		//delete[] row_ind_SR;
		//delete[] row_ind_ER;
		//delete[] row_ind_SA;
		//delete[] row_ind_EA;
		//delete[] vector_sum;

		free(index_visit);
		free(row_ind_SR);
		free(row_ind_ER);
		free(row_ind_SA);
		free(row_ind_EA);
		free(vector_sum);


		// Сортировка А по i (оригинала.).
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);

		/*
		// Лишняя сортировка до этого уже была выполнена сортировка по i.
		// 7 января 2016.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		}
		else
		{
		HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/


		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
		//if (Amat[i_1].j < 0) {
		//	printf("error: negativ j index\n");
		//	system("pause");
		//}
#if doubleintprecision == 1
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}



		// Часть 2. [R*Afine]*P=Abuf*P.
		// Сортировка [R*А] по i.
		//heapsort(Amat, key=i*n_coarce + j, 1, nnz_a[ilevel - 1]);

		// В результате работы алгоритма разреженного матричного умножения по Густавсону,
		// мы и так имеем отсортированный по строкам результат, поэтому дополнительная 
		// сортировка не требуется. Это проверено 11 января 2016.
		// 11 января 2016.
		/*
		if (bqs) {
		// Обязательно нужна сортировка.
		if (bCounting_Sort) {
		Counting_Sort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		else {
		qs(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		}
		else {
		HeapSort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		*/



		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
		//if (Amat[i_1].j < 0) {
		//	printf("error: negativ j index\n");
		//	system("pause");
		//}
#if doubleintprecision == 1
		//-->	//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//-->	//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}




		/*
		// 10 января 2016. Данная сортировка не требуется.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
		qs(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		*/


		// Prolongation должна быть упорядочена по j.
		// Начальная позиция элементов матрицы грубосеточного уровня.
		integer istartAnew2 = istartAnew;



		// Быстрее этого кода на основе идеи слияния списков уже не будет.
		// 17 октября 2015. Нужно двигаться в сторону Писсанецки.
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#endif
			
		}



		// Фред Густавсон IBM 1978
		// В ядре кода Густавсона нету ни одного ветвления,
		// а мы знаем что в результате профайлинга предыдущих версий кода:
		// (наивный, слияние, Писсанецки) львиная доля вычислительной работы уходила
		// на сравнения (ветвления) в отношении примерно 30 к 1. 30 сравнений на одно суммирование.
		// 23 октября 2015 года.
		// 6 января 2016 года Добавлено АВЛ дерево.


		// Рабочая версия алгоритма Фреда Густавсона.
		// IBM 1978 Sparse Matrix multiplication.

		// Сортировка обязательно требуется.
		// Преобразование обоих матриц в формат CRS.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
			}
			else {
				qs(P, 1 + iaddR, iaddR + nnzR - 1, indx_comparej);
			}
		}
		else {
			HeapSort(P, 1 + iaddR, iaddR + nnzR - 1,comparej);
		}

		integer* row_ind_AS = nullptr;
		//row_ind_AS = new integer[numberofcoarcenodes + 1];
		row_ind_AS = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_AS, "row_ind_AS", "classic_aglomerative_amg_5", (numberofcoarcenodes + 1));

		integer* row_ind_AE = nullptr;
		//row_ind_AE = new integer[numberofcoarcenodes + 1];
		row_ind_AE = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_AE, "row_ind_AE", "classic_aglomerative_amg_5", (numberofcoarcenodes + 1));

		integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
		integer iend2 = istartAnew - 1;
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = istart2; ii <= iend2; ii++) {
			if (flag[Amat[ii].i] == false) {
				// сканируем построчно.
				integer istr = Amat[ii].i;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend2) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_AS[istr] = ic;
				row_ind_AE[istr] = kf;
				flag[Amat[ii].i] = true;

			}
		}

		integer* row_ind_PS = nullptr;
		//row_ind_PS = new integer[n_a[ilevel - 1] + 1];
		row_ind_PS = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_PS, "row_ind_PS", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		integer* row_ind_PE = nullptr;
		//row_ind_PE = new integer[n_a[ilevel - 1] + 1];
		row_ind_PE = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_PE, "row_ind_PE", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));


		// Инициализация чрезвычайно важна, т.к. 
		// обязательно присутствуют пустые строки которые
		// надо корректно обрабатывать.
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			row_ind_PS[ii] = -1; // инициализация.
			row_ind_PE[ii] = -2;
		}
		integer istart4 = 1 + iaddR;
		integer iend4 = nnzR - 1 + iaddR;
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = istart4; ii <= iend4; ii++) {
			if (flag[P[ii].j] == false) {
				// сканируем построчно.
				integer istr = P[ii].j;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend4) && (P[kf].j == istr)) {
					kf++;
				}
				kf--;
				row_ind_PS[istr] = ic;
				row_ind_PE[istr] = kf;
				flag[P[ii].j] = true;

			}
		}

		// Данный код подтверждает что обязательно присутствуют
		// пустые строки.
		//for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
		//if (row_ind_PS[ii] == -1) {
#if doubleintprecision == 1
		//printf("propusk string %lld\n", row_ind_PE[ii]);
#else
		//printf("propusk string %d\n", row_ind_PE[ii]);
#endif
		
		//getchar();
		//}
		//}

		// Накопитель результата.
		//vector_sum = new doublerealT[numberofcoarcenodes + 1];
		vector_sum = (doublerealT*)malloc((numberofcoarcenodes + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_5", (numberofcoarcenodes + 1));

		//integer size_v = sizeof(doublerealT)*(1 + numberofcoarcenodes);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		index_visit[0] = 0;
		index_size = 0;

		// Мы будем сканировать левый операнд построчно, а
		// после окончания обработки одной строки левого операнда
		// получать готовую строку результата.

		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Переход к новой строке, сброс накопителя результата.
			//#pragma omp parallel for
			//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			//vector_sum[i_1] = 0.0; // обнуление.
			//}
			// хоть профайлер и показывает что на memset тратиться меньше процессорного времени,
			// но там возникает системный вызов на который тратиться столько же времени что и раньше.
			// работа перекочевала из одного места в другое.
			// Более быстрое обнуление.
			//memset(vector_sum, 0, size_v);

			node_AVL_Gus* root_Gus = 0;

#if 0
			if (0) {
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику:
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else if (0) {

				// На основе АВЛ дерева.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						// Бинарный поиск в АВЛ дереве.
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							root_Gus = insert_Gus(root_Gus, iaddind);

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику:
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else
#endif
 {

				// На основе hash таблицы.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						// Бинарный поиск в АВЛ дереве.
						//foundnow = isfound_Gus(root_Gus, iaddind);
						// мгновенный поиск за O(1).
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							//root_Gus = insert_Gus(root_Gus, iaddind);
							// Мгновенная вставка в hash table за O(1).
							hash_table[iaddind] = true;

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику:
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}


			doublerealT maxth = -1.0;
			if (barjerA > 0.0) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					hash_table[jstr] = false; // initialization hash.
					if (istr != jstr) {
						// 14 января 2016 года.
						// Правильно определить барьер только по внедиагональным элементам.
						if (fabs(vector_sum[jstr]) > maxth) maxth = vector_sum[jstr];
					}
				}
			}
			else {
				// Игнорируем барьер А.
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					hash_table[jstr] = false; // initialization hash.
				}
			}

			/*
			if (nsizeA > istartAnew2 + index_size) {
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
			// 15 декабря 2015.
			// Если не принять специальных мер элементы не будут упорядочены
			// и двоичным поиском воспользоваться нельзя.
			//if (index_visit[i_6] < index_visit[i_6 - 1]) {
			//printf("Gipotesa uporqdochennosti in Fred Gustavson neverna\n");
			//system("pause");
			//}

			integer jstr = index_visit[i_6];
			if (istr != jstr) {
			// 5 декабря 2015 года. Сохранение разреженности.
			//if (fabs(vector_sum[jstr]) > 1.0e-30) {
			if (fabs(vector_sum[jstr]) > barjerA*maxth) {
			Amat[istartAnew2].aij = vector_sum[jstr];
			Amat[istartAnew2].i = istr;
			Amat[istartAnew2].j = jstr;
			istartAnew2++;
			}
			}
			else {
			Amat[istartAnew2].aij = vector_sum[jstr];
			Amat[istartAnew2].i = istr;
			Amat[istartAnew2].j = jstr;
			istartAnew2++;
			}
			}
			}
			else {
			// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
			// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
			printf("Amat lack of memory\n");
			printf("yuo mast increase the size of the matrix Amat and restart solver\n");
			printf("please, press any key to exit.\n");
			system("pause");
			exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем проверками.
			doublerealT barjerA_maxth = barjerA*maxth;
			doublerealT mbarjerA_maxth = -barjerA_maxth;
			if (nsizeA > istartAnew2 + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {

					integer jstr = index_visit[i_6];
					doublerealT vs1 = vector_sum[jstr];
					if (barjerA > 0.0) {
						// Барьер использовать можно, но главное чтобы 
						// спектральные характеристики усеченной матрицы соответствовали
						// спектральным характеристикам исходной Галёркинской матрицы.

						if ((vs1 < mbarjerA_maxth) || (vs1 > barjerA_maxth)) {
							Ak1 Atemp;
							Atemp.aij = vs1;
							Atemp.i = (integer_mix_precision)(istr);
							Atemp.j = (integer_mix_precision)(jstr);

							//Amat[istartAnew2].aij = vs1;
							//Amat[istartAnew2].i = istr;
							//Amat[istartAnew2].j = jstr;
							//istartAnew2++;

							Amat[istartAnew2++] = Atemp;

						}
					}
					else {
						// Игнорируем барьер А.

						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = (integer_mix_precision)(istr);
						Atemp.j = (integer_mix_precision)(jstr);

						//Amat[istartAnew2].aij = vs1;
						//Amat[istartAnew2].i = istr;
						//Amat[istartAnew2].j = jstr;
						//istartAnew2++;

						Amat[istartAnew2++] = Atemp;
					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			index_size = 0;
			// Освобождение памяти из под АВЛ дерева.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;
		}

		//delete[] vector_sum;
		//delete[] index_visit;
		free(vector_sum);
		free(index_visit);


		//delete[] row_ind_AS;
		//delete[] row_ind_AE;
		//delete[] row_ind_PS;
		//delete[] row_ind_PE;
		free(row_ind_AS);
		free(row_ind_AE);
		free(row_ind_PS);
		free(row_ind_PE);




		// Есть подозрение что это избыточный код и его не надо вызывать.
		// 13  декабря 2015.
		// Это полностью подтвердилось 13 декабря 2015 года.
		/*

		if (bqs)
		{
		if (bCounting_Sort) {
		Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else
		{
		// Быстрая сортировка Хоара.
		qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}

		*/

		// Копируем матрицу А следующего уровня влево вплотную к матице первоначального уровня.
		//integer icounter3 = 1;
		integer nsize = istartAnew2 - (istartAnew);
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd, i_2 = 1; i_2 <= nsize; i_1++, i_2++) {
			integer i_right_position = istartAnew - 1 + i_2;
			Amat[i_1] = Amat[i_right_position];
		}

		if (bprint_mesage_diagnostic) {
			printf("Prolongation is construct.\n");
			// Общее количество узлов не являющихся соседемя, но не С соседями 
#if doubleintprecision == 1
			printf("Error interpolation is count %lld\n", ipromah);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic ipromah_one=%lld iz nih kol-vo beznadechnjh %lld\n", ipromah_one, ipromah_oneF);
#else
			printf("Error interpolation is count %d\n", ipromah);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic ipromah_one=%d iz nih kol-vo beznadechnjh %d\n", ipromah_one, ipromah_oneF);
#endif
			
			//system("pause");
		}
		if (debug_reshime) system("pause");


		//delete[] C_numerate;
		free(C_numerate);

		nnz_aRP[ilevel - 1] = nnzR - 1;
		iaddR += nnzR - 1;
		n_a[ilevel] = icounter - 1;
		nnz_a[ilevel] = nsize;
		iadd += nnz_a[ilevel - 1];


		ilevel++;

		// сортировка А по i.
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		/*

		if (nnz_a[ilevel - 1] < heapsortsizelimit) {
		HeapSort(Amat, n_a[ilevel - 1], 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		Ak1* Aorig = &Amat[1 + iadd];
		MergeSort(Aorig, nnz_a[ilevel - 1]);
		Aorig = nullptr;
		}

		*/

#if doubleintprecision == 1
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%lld ",Amat[i_1].j);
		//}
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#else
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%d ",Amat[i_1].j);
		//}
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#endif
		


		//exit(1);
		if (bprint_mesage_diagnostic) {
			printf("one level construct OK.\n");
		}
		if (debug_reshime) system("pause");


		//printf("export b\n");
		//exporttecplot(b,n);

		//doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

		// restriction
		//restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
		//for (integer ii = 1; ii <= n_a[0]; ii++) {
		//b[ii] = 0.0;
		//}

		/*{
		doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		for (integer ii = 1; ii <= n_a[1]; ii++) {
		test_coarse[ii] = 0.0;
		}

		{
		doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		for (integer ii = 1; ii <= n_a[2]; ii++) {
		test_coarse1[ii] = 0.0;
		}

		prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		}

		prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		}
		*/
		//prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

		//exporttecplot(b, n);
		// proverka start
		// на сетке 81х81 проверка успешно проходится.

		/*
		printf("proverka start\n");
		// первый уровень вложенности.
		if (ilevel > 1) {
		for (integer i = 1; i <= n; i++) {
		flag[i] = false;
		}

		for (integer ii77 = nnz_a[0] + 1; ii77 <= nnz_a[0] + nnz_a[1]; ii77++) {
		if (flag[Amat[ii77].i] == false) {
		integer istr77 = Amat[ii77].i;
		integer ic77 = ii77;
		//integer icdiag = ii77;
		doublerealT ap = 0.0;
		//x[istr] = b[istr];
		while ((ic77 <= nnz_a[0] + nnz_a[1]) && (Amat[ic77].i == istr77)) {
		if (Amat[ic77].j != istr77) {
		//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
		}
		else {
		ap = Amat[ic77].aij;
		//icdiag = ic77;
		}
		ic77++;
		}
		if (fabs(ap) < RealZERO) {
		#if doubleintprecision == 1
			printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr77);
		#else
			printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr77);
		#endif
		
		system("PAUSE");
		//exit(1);
		}

		flag[Amat[ii77].i] = true;

		}
		}
		}
		*/

		//проверка конец

		//delete[] count_neighbour;
		free(count_neighbour);
		//delete[] row_startA;
		free(row_startA);

	}// иерархия сеток построена.

	ilevel--;
	if (n_a[ilevel] < 5) {
		// Чтобы не было последних уровней где меньше 5 узлов сетки.
		ilevel--;
	}

	// Вычисляем и запоминаем grid complexity:
	// grid complexity - операторная сложность.
	doublereal dr_grid_complexity = (((double)(1.0*iadd)) / ((double)(1.0*nnz_a[0])));

	if (bprint_mesage_diagnostic) {
		printf("grid complexity is %1.2f\n", dr_grid_complexity);
		printf("Prolongation operator complexity is %1.2f %1.2f\n", (1.0*nnz_P_memo_all / nnz_P_memo_0), (1.0*nnz_P_memo_all/n_a[0]));
		doublereal sizegb = 16 * iadd / 1.0e9;
		printf("memory usage is %e Gb. reserved %e Gb. ratio is equal = %e\n", sizegb, 16 * nsizeA / 1.0e9, sizegb / (16 * nsizeA / 1.0e9));
	}

	if (bji) {
		delete[] Atemp;
		Atemp = nullptr;
	}

	// 31.224s [50.986] 2D m=81 debug x64 acumulqtor
	// 13.792 [18.156] 2D m=81 realese x64 acumulqtor
	// 8.028s 2D m=81 debug x64 rozetka
	// 3.827 2D m=81 realese x64 rozetka

	if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
		printf("ilevel=%lld\n", ilevel);
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%lld]=%lld nnz_a[%lld]=%lld nnz_a[%lld]/n_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], i_1, i_1, (integer)(nnz_a[i_1] / n_a[i_1]));
		}
#else
		printf("ilevel=%d\n", ilevel);
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%d]=%d nnz_a[%d]=%d nnz_a[%d]/n_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1], i_1, i_1, (integer)(nnz_a[i_1] / n_a[i_1]));
		}
#endif
		
		printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	}
	if (debug_reshime) system("pause");
	//system("pause");
	//exit(1);

	printf("memory optimization 13 november 2016.\n");
	printf("ierarhion matrix Amat...");
	// Уменьшение памяти отводимой под хранение матрицы А.
	// Матрица должна занимать в памяти не более чем под неё нужно и не мегабайтом больше.
	if (Amat != nullptr) {
		Ak1* Amat_tmp= (Ak1*)realloc(Amat, (iadd + 2) * sizeof(Ak1));
		if (Amat_tmp == nullptr) {
			printf("application crash for Amat. Please send message on email: kirill7785@mail.ru\n");
			system("pause");
			exit(1);
		}
		else {
			Amat = Amat_tmp;
		}
		Amat_tmp = nullptr;
	}
	
	printf(" 1 of 3 compleated.  OK!! ierarhion matrix Amat realloc successfully...\n");

	printf("Prolongation ierarhion...\n");
	if (P != nullptr) {
		Ak1* P_tmp= (Ak1*)realloc(P, ((integer)(nnz_P_memo_all)+2) * sizeof(Ak1));
		if (P_tmp == nullptr) {
			printf("application crash for P. Please send message on email: kirill7785@mail.ru\n");
			system("pause");
			exit(1);
		}
		else {
			P = P_tmp;
		}
		P_tmp = nullptr;
	}
	
	printf("2 of 3 compleated. OK!! ierarhion matrix Prolongation realloc successfully...\n");

	printf("Restriction ierarhion...\n");
	if (R != nullptr) {
		Ak1* R_tmp= (Ak1*)realloc(R, ((integer)(nnz_P_memo_all)+2) * sizeof(Ak1));
		if (R_tmp == nullptr) {
			printf("application crash for R. Please send message on email: kirill7785@mail.ru\n");
			system("pause");
			exit(1);
		}
		else {
			R = R_tmp;
		}
		R_tmp = nullptr;
	}
	
	printf("3 of 3 compleated. OK!! ierarhion matrix Restriction realloc successfully...\n");
	printf("memory optimization successfully.\n");



	/*
	//exporttecplot(b,n);

	doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

	// restriction
	restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
	for (integer ii = 1; ii <= n_a[0]; ii++) {
	b[ii] = 0.0;
	}

	{
	doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

	// restriction
	restriction(R, 1+nnz_aRP[0], nnz_aRP[0]+nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	for (integer ii = 1; ii <= n_a[1]; ii++) {
	test_coarse[ii] = 0.0;
	}

	{
	doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

	// restriction
	restriction(R, 1 + nnz_aRP[0]+nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1]+nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	for (integer ii = 1; ii <= n_a[2]; ii++) {
	test_coarse1[ii] = 0.0;
	}

	prolongation(P, 1 + nnz_aRP[0]+ nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	}

	prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	}

	prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

	exporttecplot(b, n);
	*/

	// подготовка матрицы к cycling:
	/*
	// smoother.
	// 1 september 2015.
	void seidel(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
	{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	doublerealT ap = 0.0;
	x[istr] = b[istr];
	while ((ic<=iend)&&(Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else ap = Amat[ic].aij;
	ic++;
	}
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld",istr);
	#else
		printf("zero diagonal elements in string %d",istr);
	#endif
	
	getchar();
	exit(1);
	}
	else {
	x[istr] /= ap;
	}
	flag[Amat[ii].i] = true;
	}
	}


	} // seidel


	*/

	/*
	// Т.к. деление очень медленное то мы поделим лишь один раз.
	doublerealT *diag0 = new doublerealT[n_a[0] + 1];
	doublerealT *diag1=nullptr;
	if (ilevel > 1) {
	diag1 = new doublerealT[n_a[1] + 1];
	}
	doublerealT *diag2=nullptr;
	if (ilevel > 2) {
	diag2 = new doublerealT[n_a[2] + 1];
	}
	doublerealT *diag3 = nullptr;
	if (ilevel > 3) {
	diag3 = new doublerealT[n_a[3] + 1];
	}
	doublerealT *diag4 = nullptr;
	if (ilevel > 4) {
	diag4 = new doublerealT[n_a[4] + 1];
	}
	doublerealT *diag5 = nullptr;
	if (ilevel > 5) {
	diag5 = new doublerealT[n_a[5] + 1];
	}
	doublerealT *diag6 = nullptr;
	if (ilevel > 6) {
	diag6 = new doublerealT[n_a[6] + 1];
	}
	doublerealT *diag7 = nullptr;
	if (ilevel > 7) {
	diag7 = new doublerealT[n_a[7] + 1];
	}
	doublerealT *diag8 = nullptr;
	if (ilevel > 8) {
	diag8 = new doublerealT[n_a[8] + 1];
	}
	doublerealT *diag9 = nullptr;
	if (ilevel > 9) {
	diag9 = new doublerealT[n_a[9] + 1];
	}
	doublerealT *diag10 = nullptr;
	if (ilevel > 10) {
	diag10 = new doublerealT[n_a[10] + 1];
	}
	doublerealT *diag11 = nullptr;
	if (ilevel > 11) {
	diag11 = new doublerealT[n_a[11] + 1];
	}
	doublerealT *diag12 = nullptr;
	if (ilevel > 12) {
	diag12 = new doublerealT[n_a[12] + 1];
	}
	doublerealT *diag13 = nullptr;
	if (ilevel > 13) {
	diag13 = new doublerealT[n_a[13] + 1];
	}
	doublerealT *diag14 = nullptr;
	if (ilevel > 14) {
	diag14 = new doublerealT[n_a[14] + 1];
	}
	doublerealT *diag15 = nullptr;
	if (ilevel > 15) {
	diag15 = new doublerealT[n_a[15] + 1];
	}
	doublerealT *diag16 = nullptr;
	if (ilevel > 16) {
	diag16 = new doublerealT[n_a[16] + 1];
	}
	*/

	// Т.к. деление очень медленное то мы поделим лишь один раз.
	doublerealT *diag0 = nullptr;
	//diag0 = new doublerealT[n_a[0] + 1];
	diag0 = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(diag0, "diag0", "classic_aglomerative_amg_5", (n_a[0] + 1));

	doublerealT *diag1 = nullptr;
	if (ilevel > 1) {
		//diag1 = new doublerealT[n_a[1] + 1];
		diag1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag1, "diag1", "classic_aglomerative_amg_5", (n_a[1] + 1));
	}
	doublerealT *diag2 = nullptr;
	if (ilevel > 2) {
		//diag2 = new doublerealT[n_a[2] + 1];
		diag2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag2, "diag2", "classic_aglomerative_amg_5", (n_a[2] + 1));
	}
	doublerealT *diag3 = nullptr;
	if (ilevel > 3) {
		//diag3 = new doublerealT[n_a[3] + 1];
		diag3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag3, "diag3", "classic_aglomerative_amg_5", (n_a[3] + 1));
	}
	doublerealT *diag4 = nullptr;
	if (ilevel > 4) {
		//diag4 = new doublerealT[n_a[4] + 1];
		diag4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag4, "diag4", "classic_aglomerative_amg_5", (n_a[4] + 1));
	}
	doublerealT *diag5 = nullptr;
	if (ilevel > 5) {
		//diag5 = new doublerealT[n_a[5] + 1];
		diag5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag5, "diag5", "classic_aglomerative_amg_5", (n_a[5] + 1));
	}
	doublerealT *diag6 = nullptr;
	if (ilevel > 6) {
		//diag6 = new doublerealT[n_a[6] + 1];
		diag6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag6, "diag6", "classic_aglomerative_amg_5", (n_a[6] + 1));
	}
	doublerealT *diag7 = nullptr;
	if (ilevel > 7) {
		//diag7 = new doublerealT[n_a[7] + 1];
		diag7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag7, "diag7", "classic_aglomerative_amg_5", (n_a[7] + 1));
	}
	doublerealT *diag8 = nullptr;
	if (ilevel > 8) {
		// diag8 = new doublerealT[n_a[8] + 1];
		diag8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag8, "diag8", "classic_aglomerative_amg_5", (n_a[8] + 1));
	}
	doublerealT *diag9 = nullptr;
	if (ilevel > 9) {
		// diag9 = new doublerealT[n_a[9] + 1];
		diag9 = (doublerealT*)malloc((n_a[9] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag9, "diag9", "classic_aglomerative_amg_5", (n_a[9] + 1));
	}
	doublerealT *diag10 = nullptr;
	if (ilevel > 10) {
		// diag10 = new doublerealT[n_a[10] + 1];
		diag10 = (doublerealT*)malloc((n_a[10] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag10, "diag10", "classic_aglomerative_amg_5", (n_a[10] + 1));
	}
	doublerealT *diag11 = nullptr;
	if (ilevel > 11) {
		// diag11 = new doublerealT[n_a[11] + 1];
		diag11 = (doublerealT*)malloc((n_a[11] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag11, "diag11", "classic_aglomerative_amg_5", (n_a[11] + 1));
	}
	doublerealT *diag12 = nullptr;
	if (ilevel > 12) {
		// diag12 = new doublerealT[n_a[12] + 1];
		diag12 = (doublerealT*)malloc((n_a[12] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag12, "diag12", "classic_aglomerative_amg_5", (n_a[12] + 1));
	}
	doublerealT *diag13 = nullptr;
	if (ilevel > 13) {
		// diag13 = new doublerealT[n_a[13] + 1];
		diag13 = (doublerealT*)malloc((n_a[13] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag13, "diag13", "classic_aglomerative_amg_5", (n_a[13] + 1));
	}
	doublerealT *diag14 = nullptr;
	if (ilevel > 14) {
		// diag14 = new doublerealT[n_a[14] + 1];
		diag14 = (doublerealT*)malloc((n_a[14] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag14, "diag14", "classic_aglomerative_amg_5", (n_a[14] + 1));
	}
	doublerealT *diag15 = nullptr;
	if (ilevel > 15) {
		// diag15 = new doublerealT[n_a[15] + 1];
		diag15 = (doublerealT*)malloc((n_a[15] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag15, "diag15", "classic_aglomerative_amg_5", (n_a[15] + 1));
	}
	doublerealT *diag16 = nullptr;
	if (ilevel > 16) {
		// diag16 = new doublerealT[n_a[16] + 1];
		diag16 = (doublerealT*)malloc((n_a[16] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag16, "diag16", "classic_aglomerative_amg_5", (n_a[16] + 1));
	}
	doublerealT *diag17 = nullptr;
	if (ilevel > 17) {
		// diag17 = new doublerealT[n_a[17] + 1];
		diag17 = (doublerealT*)malloc((n_a[17] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag17, "diag17", "classic_aglomerative_amg_5", (n_a[17] + 1));
	}
	doublerealT *diag18 = nullptr;
	if (ilevel > 18) {
		// diag18 = new doublerealT[n_a[18] + 1];
		diag18 = (doublerealT*)malloc((n_a[18] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag18, "diag18", "classic_aglomerative_amg_5", (n_a[18] + 1));
	}

	bnested_desection_global_amg = nullptr;
	bool *nested_desection0 = nullptr;
	bool *nested_desection1 = nullptr;
	bool *nested_desection2 = nullptr;
	bool *nested_desection3 = nullptr;
	bool *nested_desection4 = nullptr;
	bool *nested_desection5 = nullptr;
	bool *nested_desection6 = nullptr;
	bool *nested_desection7 = nullptr;
	bool *nested_desection8 = nullptr;
	bool *nested_desection9 = nullptr;
	bool *nested_desection10 = nullptr;
	bool *nested_desection11 = nullptr;
	bool *nested_desection12 = nullptr;
	bool *nested_desection13 = nullptr;
	bool *nested_desection14 = nullptr;
	bool *nested_desection15 = nullptr;
	bool *nested_desection16 = nullptr;
	bool *nested_desection17 = nullptr;
	bool *nested_desection18 = nullptr;
	if (!bonly_serial) {
		// nested desection start
		bnested_desection_global_amg = (bool*)malloc((n_a[0] + 1)*sizeof(bool));
		handle_error<bool>(bnested_desection_global_amg, "bnested_desection_global_amg", "classic_aglomerative_amg_5", (n_a[0] + 1));


		nested_desection0 = (bool*)malloc((n_a[0] + 1)*sizeof(bool));
		handle_error<bool>(nested_desection0, "nested_desection0", "classic_aglomerative_amg_5", (n_a[0] + 1));


		if (ilevel > 1) {
			nested_desection1 = (bool*)malloc((n_a[1] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection1, "nested_desection1", "classic_aglomerative_amg_5", (n_a[1] + 1));
		}

		if (ilevel > 2) {
			nested_desection2 = (bool*)malloc((n_a[2] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection2, "nested_desection2", "classic_aglomerative_amg_5", (n_a[2] + 1));
		}

		if (ilevel > 3) {
			nested_desection3 = (bool*)malloc((n_a[3] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection3, "nested_desection3", "classic_aglomerative_amg_5", (n_a[3] + 1));
		}

		if (ilevel > 4) {
			nested_desection4 = (bool*)malloc((n_a[4] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection4, "nested_desection4", "classic_aglomerative_amg_5", (n_a[4] + 1));
		}

		if (ilevel > 5) {
			nested_desection5 = (bool*)malloc((n_a[5] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection5, "nested_desection5", "classic_aglomerative_amg_5", (n_a[5] + 1));
		}

		if (ilevel > 6) {
			nested_desection6 = (bool*)malloc((n_a[6] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection6, "nested_desection6", "classic_aglomerative_amg_5", (n_a[6] + 1));
		}

		if (ilevel > 7) {
			nested_desection7 = (bool*)malloc((n_a[7] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection7, "nested_desection7", "classic_aglomerative_amg_5", (n_a[7] + 1));
		}

		if (ilevel > 8) {
			nested_desection8 = (bool*)malloc((n_a[8] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection8, "nested_desection8", "classic_aglomerative_amg_5", (n_a[8] + 1));
		}

		if (ilevel > 9) {
			nested_desection9 = (bool*)malloc((n_a[9] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection9, "nested_desection9", "classic_aglomerative_amg_5", (n_a[9] + 1));
		}

		if (ilevel > 10) {
			nested_desection10 = (bool*)malloc((n_a[10] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection10, "nested_desection10", "classic_aglomerative_amg_5", (n_a[10] + 1));
		}

		if (ilevel > 11) {
			nested_desection11 = (bool*)malloc((n_a[11] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection11, "nested_desection11", "classic_aglomerative_amg_5", (n_a[11] + 1));
		}

		if (ilevel > 12) {
			nested_desection12 = (bool*)malloc((n_a[12] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection12, "nested_desection12", "classic_aglomerative_amg_5", (n_a[12] + 1));
		}

		if (ilevel > 13) {
			nested_desection13 = (bool*)malloc((n_a[13] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection13, "nested_desection13", "classic_aglomerative_amg_5", (n_a[13] + 1));
		}

		if (ilevel > 14) {
			nested_desection14 = (bool*)malloc((n_a[14] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection14, "nested_desection14", "classic_aglomerative_amg_5", (n_a[14] + 1));
		}

		if (ilevel > 15) {
			nested_desection15 = (bool*)malloc((n_a[15] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection15, "nested_desection15", "classic_aglomerative_amg_5", (n_a[15] + 1));
		}

		if (ilevel > 16) {
			nested_desection16 = (bool*)malloc((n_a[16] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection16, "nested_desection16", "classic_aglomerative_amg_5", (n_a[16] + 1));
		}

		if (ilevel > 17) {
			nested_desection17 = (bool*)malloc((n_a[17] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection17, "nested_desection17", "classic_aglomerative_amg_5", (n_a[17] + 1));
		}

		if (ilevel > 18) {
			nested_desection18 = (bool*)malloc((n_a[18] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection18, "nested_desection18", "classic_aglomerative_amg_5", (n_a[18] + 1));
		}
	}
	// nested_desection_end

	integer *row_ptr_start = nullptr;
	const integer isize_row_ptr = 4 * n_a[0] + 1;
	//row_ptr_start = new integer[4 * n_a[0] + 1];
	row_ptr_start = (integer*)malloc((isize_row_ptr)*sizeof(integer));
	handle_error<integer>(row_ptr_start, " row_ptr_start", "classic_aglomerative_amg_5", (isize_row_ptr));

	integer *row_ptr_end = nullptr;
	//row_ptr_end = new integer[4 * n_a[0] + 1];
	row_ptr_end = (integer*)malloc((isize_row_ptr)*sizeof(integer));
	handle_error<integer>(row_ptr_end, " row_ptr_end", "classic_aglomerative_amg_5", (isize_row_ptr));

	LEVEL_ADDITIONAL_DATA* milu2 = nullptr;
	// инициализация.
	init_level_additional_data(milu2, ilevel);

	// ILU0
	LEVEL_ADDITIONAL_DATA0* milu0 = nullptr;
	// инициализация.
	init_level_additional_data(milu0, ilevel);

	// Освобождение общей памяти в ILU буффере.
	if (milu_gl_buffer.alu_copy != nullptr) delete[] milu_gl_buffer.alu_copy;
	if (milu_gl_buffer.jlu_copy != nullptr) delete[] milu_gl_buffer.jlu_copy;
	if (milu_gl_buffer.ju_copy != nullptr) delete[] milu_gl_buffer.ju_copy;
	milu_gl_buffer.alu_copy = nullptr;
	milu_gl_buffer.jlu_copy = nullptr;
	milu_gl_buffer.ju_copy = nullptr;

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = 1; ii <= nnz_a[0]; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			integer icdiag = ii;
			if (istr >= isize_row_ptr) {
#if doubleintprecision == 1
				printf("need to increase isize_row_ptr %lld", istr);
#else
				printf("need to increase isize_row_ptr %d", istr);
#endif
				
				//getchar();
				system("PAUSE");
				exit(1);
			}
			row_ptr_start[istr] = ii;
			doublerealT ap = 0.0; // значение на диагонали.
			//x[istr] = b[istr];
			while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					// Все внедиагональные элементы должны быть строго отрицательны.
					// Если это не так то надо выдавать предупреждение о логической ошибке пользователю.
					if (Amat[ic].aij >= 0.0) {
#if doubleintprecision == 1
						printf("polochitelnji vnediagonalnj element %e in matrix level 0 in string %lld...\n", Amat[ic].aij, istr);
#else
						printf("polochitelnji vnediagonalnj element %e in matrix level 0 in string %d...\n", Amat[ic].aij, istr);
#endif
						
						system("PAUSE");
					}
				}
				else {
					// дмагональный элемент строго положителен.
					ap = Amat[ic].aij;
					icdiag = ic;
				}
				ic++;
			}
			if (istr >= isize_row_ptr) {
#if doubleintprecision == 1
				printf("need to increase isize_row_ptr %lld", istr);
#else
				printf("need to increase isize_row_ptr %d", istr);
#endif
				
				//getchar();
				system("PAUSE");
				exit(1);
			}
			row_ptr_end[istr] = ic - 1;
			if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld in basic matrix", istr);
#else
				printf("zero diagonal elements in string %d in basic matrix", istr);
#endif
				
				system("PAUSE");
				exit(1);
			}
			else {
				//x[istr] /= ap;
			}

			flag[Amat[ii].i] = true;
			Ak1 temp = Amat[ii];
			Amat[ii] = Amat[icdiag];
			Amat[icdiag] = temp;
			if (bmemory_savings) {
				// По исходному номеру получаем текущий,
				// но теперь два текущих поменялись.
				the_original_order_of_values[the_original_order_of_values_reverse[ii]] = icdiag;
				the_original_order_of_values[the_original_order_of_values_reverse[icdiag]] = ii;
			}


			diag0[Amat[ii].i] = ap; // для ускорения вычисления невязки.
			Amat[ii].aij = (real_mix_precision)(1.0 / ap); // умножение быстрей деления.
		}
	}

	if (bILU2smoother == 2) {
		// ILU2
		printf("apply ilu2 smoother for number 0 level\n");
		equation3DtoCRSRUMBA1(milu2[0], true, Amat, 1, n_a[0], row_ptr_start, row_ptr_end, 0, 0);
	}
	if (bILU2smoother == 1) {
		// ILU0
		printf("apply ilu0 smoother for number 0 level\n");
		equation3DtoCRSRUMBA0(milu0[0], true, Amat, 1, n_a[0], row_ptr_start, row_ptr_end, 0, 0);
	}
	bool bstop = false;


	// 14 сентября 2015 понедельник четвёртый уровень вложенности.
	// Уровни вложенности с первого по седьмой сразу. 12.07.2016.

	// Заголовочная надпись:
	if (bprint_mesage_diagnostic) {
		printf("1. positive connections %% 2. max positive/ diagonal %%\n");
	}

	for (integer ilevel_detector = 1; ilevel_detector <= 20; ilevel_detector++) {

		// Обработка матрицы действует до седьмого уровня включительно, но
		// сбор статистики желательно сделать для всех уровней.
		const integer istop_level_scan = 18;

		if (ilevel > ilevel_detector) {

			doublerealT inum_vnediagonal_all = 0.0;
			doublerealT inum_only_positive_vnediagonal = 0.0;
			doublerealT memo_diagonal_element = 0.0;
			doublerealT max_positive_connections_element = -1.0;
			doublerealT ratio_positive_connections_by_diagonalelement = -1.0;
			doublerealT ratio_positive_connections_by_diagonalelement_avg = 0.0;


			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}
			integer ist = 1;
			for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
				ist += nnz_a[ilev];
			}
			integer iend = 0;
			for (integer ilev = 0; ilev <= ilevel_detector; ilev++) {
				iend += nnz_a[ilev];
			}
			double dn_num = 0.0;
			for (integer ii = ist; ii <= iend; ii++) {
				if (flag[Amat[ii].i] == false) {
					dn_num += 1.0;
					max_positive_connections_element = -1.0;
					integer istr = Amat[ii].i;
					integer ic = ii;
					integer icdiag = ii;
					integer istart_row_ptr = istr;
					for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
						istart_row_ptr += n_a[ilev];
					}
					if (istart_row_ptr >= isize_row_ptr) {
#if doubleintprecision == 1
						printf("need to increase isize_row_ptr %lld", istart_row_ptr);
#else
						printf("need to increase isize_row_ptr %d", istart_row_ptr);
#endif
						
						//getchar();
						system("PAUSE");
						exit(1);
					}
					if (ilevel_detector <= istop_level_scan) {
						row_ptr_start[istart_row_ptr] = ii;
					}
					doublerealT ap = 0.0;
					//x[istr] = b[istr];
					while ((ic <= iend) && (Amat[ic].i == istr)) {
						if (Amat[ic].j != istr) {
							//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
							inum_vnediagonal_all += 1.0;
							// Все внедиагональные элементы должны быть строго отрицательны.
							// Если это не так то надо выдавать предупреждение о логической ошибке пользователю.
							if (Amat[ic].aij >= 0.0) {
#if doubleintprecision == 1
								//printf("polochitelnji vnediagonalnj element %e in matrix level %lld in string %lld...\n", Amat[ic].aij, ilevel_detector, istr);
#else
								//printf("polochitelnji vnediagonalnj element %e in matrix level %d in string %d...\n", Amat[ic].aij, ilevel_detector, istr);
#endif
									//system("PAUSE");
								inum_only_positive_vnediagonal += 1.0;

								// Определение величины максимальной внедиагональной связи.
								if (max_positive_connections_element < Amat[ic].aij) {
									max_positive_connections_element = Amat[ic].aij;
								}
							}
						}
						else {
							ap = Amat[ic].aij;
							memo_diagonal_element = ap;
							icdiag = ic;
						}
						ic++;
					}
					if (istart_row_ptr >= isize_row_ptr) {
#if doubleintprecision == 1
						printf("need to increase isize_row_ptr %lld", istart_row_ptr);
#else
						printf("need to increase isize_row_ptr %d", istart_row_ptr);
#endif
						
						//getchar();
						system("PAUSE");
						exit(1);
					}
					if (ilevel_detector <= istop_level_scan) {
						row_ptr_end[istart_row_ptr] = ic - 1;
					}
					if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
						printf("zero diagonal elements in string %lld in level %lld matrix", istr, ilevel);
#else
						printf("zero diagonal elements in string %d in level %d matrix", istr, ilevel);
#endif
						

						system("PAUSE");
						exit(1);
					}
					else {
						//x[istr] /= ap;
					}
					ratio_positive_connections_by_diagonalelement_avg += max_positive_connections_element / memo_diagonal_element;
					if (ratio_positive_connections_by_diagonalelement < max_positive_connections_element / memo_diagonal_element) {
						ratio_positive_connections_by_diagonalelement = max_positive_connections_element / memo_diagonal_element;

					}
					flag[Amat[ii].i] = true;
					if (ilevel_detector <= istop_level_scan) {
						Ak1 temp = Amat[ii];
						Amat[ii] = Amat[icdiag];
						Amat[icdiag] = temp;
						switch (ilevel_detector) {
						case 1: diag1[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 2: diag2[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 3: diag3[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 4: diag4[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 5: diag5[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 6: diag6[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 7: diag7[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 8: diag8[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 9: diag9[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 10: diag10[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 11: diag11[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 12: diag12[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 13: diag13[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 14: diag14[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 15: diag15[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 16: diag16[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 17: diag17[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 18: diag18[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						default: printf("ilevel_detector incorrect\n");
							//getchar();
							system("PAUSE");
							break;
						}

						Amat[ii].aij = (real_mix_precision)(1.0 / ap); // умножение быстрей деления.
					}
				}
			}

			integer iadd_now = 0;
			for (integer i54 = 1; i54 <= ilevel_detector; i54++) {
				iadd_now += n_a[i54 - 1];
			}
			
			if (ilevel_detector <= istop_level_scan) {
				if (bILU2smoother == 2) {
#if doubleintprecision == 1
					printf("apply ilu2 smoother for number %lld level\n", ilevel_detector);
#else
					printf("apply ilu2 smoother for number %d level\n", ilevel_detector);
#endif
					
					equation3DtoCRSRUMBA1(milu2[ilevel_detector], true,
						Amat, 1, n_a[ilevel_detector], row_ptr_start, row_ptr_end, iadd_now, ilevel_detector);
				}
			}
			if (ilevel_detector <= istop_level_scan) {
				if (bILU2smoother == 1) {
					// ILU0
#if doubleintprecision == 1
					printf("apply ilu0 smoother for number %lld level\n", ilevel_detector);
#else
					printf("apply ilu0 smoother for number %d level\n", ilevel_detector);
#endif
					
					// iadd_now=n_a[0]+...+n_a[ilevel_detector-1];
					equation3DtoCRSRUMBA0(milu0[ilevel_detector], true,
						Amat, 1, n_a[ilevel_detector], row_ptr_start, row_ptr_end, iadd_now, ilevel_detector);
				}
			}


			// statistic log:
			if (bprint_mesage_diagnostic) {
				//printf("procent positive connections %e \n", 100.0*inum_only_positive_vnediagonal / inum_vnediagonal_all);
				//printf("the ratio of the maximum positive connections to the diagonal\n");
				//printf("element in the row, in procent %e\n", 100.0*ratio_positive_connections_by_diagonalelement);
				//printf("\n");
#if doubleintprecision == 1
				printf("%lld %e  %e%% %e%%\n", ilevel_detector, 100.0*inum_only_positive_vnediagonal / inum_vnediagonal_all, 100.0*ratio_positive_connections_by_diagonalelement, 100.0*ratio_positive_connections_by_diagonalelement_avg / dn_num);
#else
				printf("%d %e  %e%% %e%%\n", ilevel_detector, 100.0*inum_only_positive_vnediagonal / inum_vnediagonal_all, 100.0*ratio_positive_connections_by_diagonalelement, 100.0*ratio_positive_connections_by_diagonalelement_avg / dn_num);
#endif
				
				
			}
		}


	}

	if (bstop) exit(1);

	if (bILU2smoother > 0) {
		// Пауза только в случае применения ILU декомпозиции.
		//system("PAUSE");
		if (bILU2smoother == 2) {
			// Осторожно возможно код быстро устареет.
			// Выделение оперативной памяти под централизованное хранилище 
			// для ILU.
			memory_allocation_apostoriory_buffer_ilu(milu2, ilevel - 1);
		}
	}


	// закомментировАННЫЙ КОД ОТНОСИТСЯ К УСТАРЕВШЕМУ. 
	// 4 ноября 2016 прописано 15 уровней вложенности.



	// восьмой уровень вложенности.
	/*
	if (ilevel > 8) {
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + 1;
	integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
	for (integer ii = ist; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	integer icdiag = ii;
	row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ii;
	doublerealT ap = 0.0;
	//x[istr] = b[istr];
	while ((ic <= iend) && (Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else {
	ap = Amat[ic].aij;
	icdiag = ic;
	}
	ic++;
	}
	row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ic - 1;
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld in level 7 matrix", istr);
	#else
		printf("zero diagonal elements in string %d in level 7 matrix", istr);
	#endif
	
	system("PAUSE");
	exit(1);
	}
	else {
	//x[istr] /= ap;
	}

	flag[Amat[ii].i] = true;
	Ak1 temp = Amat[ii];
	Amat[ii] = Amat[icdiag];
	Amat[icdiag] = temp;
	diag8[Amat[ii].i] = ap; // для ускорения вычисления невязки.
	Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
	}
	}
	}
	*/


	if (!bonly_serial) {
		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 0.
		// nested_desection0
		nested_desection_patch(Amat, n_a[0], nested_desection0, row_ptr_start, row_ptr_end, 0);
		if (bprint_mesage_diagnostic) {
			printf("part1\n");
		}


		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 1.
		// nested_desection1
		if (ilevel > 1) {
			nested_desection_patch(Amat, n_a[1], nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
			if (bprint_mesage_diagnostic) {
				printf("part2\n");
			}
		}
		if (ilevel > 2) {
			nested_desection_patch(Amat, n_a[2], nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
			if (bprint_mesage_diagnostic) {
				printf("part3\n");
			}
		}
		if (ilevel > 3) {
			nested_desection_patch(Amat, n_a[3], nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
			if (bprint_mesage_diagnostic) {
				printf("part4\n");
			}
		}
		if (ilevel > 4) {
			nested_desection_patch(Amat, n_a[4], nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
			if (bprint_mesage_diagnostic) {
				printf("part5\n");
			}
		}
		if (ilevel > 5) {
			nested_desection_patch(Amat, n_a[5], nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
			if (bprint_mesage_diagnostic) {
				printf("part6\n");
			}
		}
		if (ilevel > 6) {
			nested_desection_patch(Amat, n_a[6], nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
			if (bprint_mesage_diagnostic) {
				printf("part7\n");
			}
		}
		if (ilevel > 7) {
			nested_desection_patch(Amat, n_a[7], nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
			if (bprint_mesage_diagnostic) {
				printf("part8 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 8) {
			nested_desection_patch(Amat, n_a[8], nested_desection8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
			if (bprint_mesage_diagnostic) {
				printf("part9 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 9) {
			nested_desection_patch(Amat, n_a[9], nested_desection9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
			if (bprint_mesage_diagnostic) {
				printf("part10 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 10) {
			nested_desection_patch(Amat, n_a[10], nested_desection10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
			if (bprint_mesage_diagnostic) {
				printf("part11 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 11) {
			nested_desection_patch(Amat, n_a[11], nested_desection11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
			if (bprint_mesage_diagnostic) {
				printf("part12 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 12) {
			nested_desection_patch(Amat, n_a[12], nested_desection12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
			if (bprint_mesage_diagnostic) {
				printf("part13 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 13) {
			nested_desection_patch(Amat, n_a[13], nested_desection13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
			if (bprint_mesage_diagnostic) {
				printf("part14 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 14) {
			nested_desection_patch(Amat, n_a[14], nested_desection14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
			if (bprint_mesage_diagnostic) {
				printf("part15 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 15) {
			nested_desection_patch(Amat, n_a[15], nested_desection15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
			if (bprint_mesage_diagnostic) {
				printf("part16 \n");
				printf("nested desection is finish\n");
			}
		}
	}


	// smoother.
	// 9 september 2015.
	// q - quick.
	// seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
	//void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer* &row_ptr_start, integer* &row_ptr_end, integer iadd)
	//{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	//integer startpos = istartq + iadd;
	//integer endpos = iendq+iadd;
	//for (integer ii = startpos; ii <= endpos; ii++) {
	//integer istr = ii - iadd;
	//x[istr] = b[istr];
	//for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
	//{
	//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
	//}
	//x[istr] *= Amat[row_ptr_start[ii]].aij;
	//}


	//} // seidelq

	// Освобождение памяти используемой на этапе построения иерархии матриц.

	//delete[] this_is_C_node;
	//delete[] this_is_F_node;
	if (this_is_C_node!=nullptr) {
	   free(this_is_C_node);
	   this_is_C_node=nullptr;
	}
	if (this_is_F_node!=nullptr) {
	   free(this_is_F_node);
       this_is_F_node=nullptr;
	}
	//delete[] hash_table;
	free(hash_table);
	free(hash_table2);
	//delete[] istack;
	//delete[] istack2;
	free(istack);
	free(istack2);


	if (bprint_mesage_diagnostic) {
		printf("cycling: V cycle.\n");
#if doubleintprecision == 1
		printf("level=%lld\n", ilevel);
#else
		printf("level=%d\n", ilevel);
#endif
		
		printf("multigrid R.P.Fedorenko 1961.\n");
		printf("standart aglomerative algebraic multigrid method.\n");
	}
	if (debug_reshime) system("pause");
	//exit(1);

	// 10 11 21 multigrid tutorial Вильм Бригг.
	// Высокорейнольдсовое обтекание квадрата в DavisTest,
	// решатель работал на x-компоненте скорости. Сетка сгущалась
	// к поверхности квадрата достаточно сильно. Это дало расходимость
	// amg v0.08 решателя на данной задаче с параметрами nu1=4, nu2=3.
	// Параметры nu1=8, nu2=7 обеспечили сходимость вычислительного процесса.

	// Возможно имеет смысл сделать управляемый выход из сглаживателя, допустим
	// если невязка опустилась ниже первоначальной в 0.1 раз то имеет смысл досрочно 
	// оборвать итерации сглаживателя.


	// nu1=0; nu2=2; nFinestSweeps=2 is recomended 
	// Masashi Imano. Optimization of parameter setting for GAMG
	// solver in simple solver. 
	// Aug 26th 2012. OpeanFOAM study. 
	// nu1=0 имеем расходимость на BSK Dmitrii.
	// nFinestSweeps=2 имеем расходимость на BSK Dmitrii.
	// BSK Dmitrii сходится при nu1=1, nu2=2, nFinestSweeps=3.

	integer nu1 = 1; // minimum value 1 // 4 // 8
	integer nu2 = 2; // minimum value 2 // 3 // 7

	// на задаче Finned Heat Sync из первого туториала Icepak была обнаружена расходимость 
	// для Y скорости и поправки давления. При этом обтекание куба отлично считалось на равномерной
	// сетки с nu1=1, nu2=2 даже при весьма больших числах Рейнольдса.
	// при nu1=10, nu2=10 скорости разрешаются хорошо и проблем с ними нет, но поправка давления по прежнему даёт сбой.
	// при nu==20 сбой всё равно есть.
	// не помогло.
	//nu1 = 40;
	//nu2 = 40;

	integer nFinestSweeps = 2;

	// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
	// Т.к. есть трудносходящиеся задачи, то этинастройки должны помоч.
	nu1 = my_amg_manager.nu1;
	nu2 = my_amg_manager.nu2;
	nFinestSweeps = my_amg_manager.nFinnest;

	//if (iVar == PAM) {
	//nFinestSweeps = 300;
	//nu1 = 0;
	//nu2 = 20;
	//}
	// для Finner Heat Sink надо усилить сглаживания.
	// Это не помогает будет перенаправление на другой алгоритм.
	//if (iVar == PAM) {
	//nu1 = 3;
	//nu2 = 3;
	//nFinestSweeps = 6;
	//}
	const bool btheoryGuideANSYSFluent = false;
	if (iVar != PAM) {
		if (btheoryGuideANSYSFluent) {
			// Так написано в Theory Guide ANSYS Fluent.
			nu1 = 0;
			nu2 = 1;
			nFinestSweeps = 1;
		}
	}



	// Двойной вакуумный промежуток вызывает проблемы сходимости:
	//nu1 = 10;
	//nu2 = 20;

	// Смысл этих параметров в том что они экономят ресурсы процессора
	// в теории осуществляя досрочный выход из пред и пост сглаживаний.
	// Т.е. параметры nu1,nu2 задаются с запасом и алгоритм сам использует
	// сколько ему взять итераций для оптимальной работы (сходимости). 
	// Пользователь не ломает голову какие задавать параметры nu1, nu2 
	// а задаёт их верхние предельные значения. 
	doublerealT process_flow_beta = (doublerealT)(0.7);
	doublerealT process_flow_alpha = (doublerealT)(0.1);
	bool process_flow_logic = false;

	if (process_flow_logic) {
		nu1 = 40;
		nu2 = 40;
	}

	if (bprint_mesage_diagnostic) {
		printf("grid complexity is %1.2f\n", dr_grid_complexity);
		printf("Prolongation operator complexity is %1.2f  %1.2f\n", (1.0*nnz_P_memo_all / nnz_P_memo_0), (1.0*nnz_P_memo_all/n_a[0]));
#if doubleintprecision == 1
		printf("nu1=%lld, nu2=%lld\n", nu1, nu2);
#else
		printf("nu1=%d, nu2=%d\n", nu1, nu2);
#endif
		
	}

	//ilevel = 1; //debug
	doublerealT rho = 1.0;
	doublerealT dres = 1.0;
	integer iiter = 1;
	//const doublerealT tolerance = 1.0e-12;
	// 13 февраля 2016 калибруем точность солвера с целью ускорения получения результата.
	// Т.к. нам ненужна точность выше чем десятая доля градуса по температуре.
	// начальное значение невязки составляет примерно 7000.0.
	doublerealT tolerance = (doublerealT)(0.0001); // точность выхода по классическому определению L2 нормы.
	tolerance = (doublerealT)(1.0e-26); // 16 августа 2016.
	tolerance = (doublerealT)(1.0e-8); // КОСМОС unsteady 14_10_2016.
	// 23 октября 2016
	if (bSIMPLErun_now_for_temperature) {
		// Решаем cfd задачи.
		// Сходится только с этим критерием выхода по невязке.
		tolerance = (doublerealT)(1.0e-8);
	}


	doublerealT *residual_fine = nullptr;
	//residual_fine = new doublerealT[n_a[0] + 1];
	doublerealT *residual_coarse = nullptr;
	doublerealT* error_approx_coarse = nullptr;
	doublerealT *residual_fine1 = nullptr;
	doublerealT *residual_coarse1 = nullptr;
	doublerealT* error_approx_coarse1 = nullptr;
	doublerealT *error_approx_fine1 = nullptr;
	doublerealT *residual_fine2 = nullptr;
	doublerealT *residual_coarse2 = nullptr;
	doublerealT* error_approx_coarse2 = nullptr;
	doublerealT *error_approx_fine2 = nullptr;
	doublerealT *residual_fine3 = nullptr;
	doublerealT *residual_coarse3 = nullptr;
	doublerealT* error_approx_coarse3 = nullptr;
	doublerealT *error_approx_fine3 = nullptr;
	doublerealT *residual_fine4 = nullptr;
	doublerealT *residual_coarse4 = nullptr;
	doublerealT *error_approx_coarse4 = nullptr;
	doublerealT *error_approx_fine4 = nullptr;
	doublerealT *residual_fine5 = nullptr;
	doublerealT *residual_coarse5 = nullptr;
	doublerealT* error_approx_coarse5 = nullptr;
	doublerealT *error_approx_fine5 = nullptr;
	doublerealT *residual_fine6 = nullptr;
	doublerealT *residual_coarse6 = nullptr;
	doublerealT* error_approx_coarse6 = nullptr;
	doublerealT *error_approx_fine6 = nullptr;
	doublerealT *residual_fine7 = nullptr;
	doublerealT *residual_coarse7 = nullptr;
	doublerealT* error_approx_coarse7 = nullptr;
	doublerealT *error_approx_fine7 = nullptr;
	doublerealT *residual_fine8 = nullptr;
	doublerealT *residual_coarse8 = nullptr;
	doublerealT* error_approx_coarse8 = nullptr;
	doublerealT *error_approx_fine8 = nullptr;
	doublerealT *residual_fine9 = nullptr;
	doublerealT *residual_coarse9 = nullptr;
	doublerealT* error_approx_coarse9 = nullptr;
	doublerealT *error_approx_fine9 = nullptr;
	doublerealT *residual_fine10 = nullptr;
	doublerealT *residual_coarse10 = nullptr;
	doublerealT* error_approx_coarse10 = nullptr;
	doublerealT *error_approx_fine10 = nullptr;
	doublerealT *residual_fine11 = nullptr;
	doublerealT *residual_coarse11 = nullptr;
	doublerealT* error_approx_coarse11 = nullptr;
	doublerealT *error_approx_fine11 = nullptr;
	doublerealT *residual_fine12 = nullptr;
	doublerealT *residual_coarse12 = nullptr;
	doublerealT* error_approx_coarse12 = nullptr;
	doublerealT *error_approx_fine12 = nullptr;
	doublerealT *residual_fine13 = nullptr;
	doublerealT *residual_coarse13 = nullptr;
	doublerealT* error_approx_coarse13 = nullptr;
	doublerealT *error_approx_fine13 = nullptr;
	doublerealT *residual_fine14 = nullptr;
	doublerealT *residual_coarse14 = nullptr;
	doublerealT* error_approx_coarse14 = nullptr;
	doublerealT *error_approx_fine14 = nullptr;
	doublerealT *residual_fine15 = nullptr;
	doublerealT *residual_coarse15 = nullptr;
	doublerealT* error_approx_coarse15 = nullptr;
	doublerealT *error_approx_fine15 = nullptr;
	doublerealT *residual_fine16 = nullptr;
	doublerealT *residual_coarse16 = nullptr;
	doublerealT* error_approx_coarse16 = nullptr;
	doublerealT *error_approx_fine16 = nullptr;
	doublerealT *residual_fine17 = nullptr;
	doublerealT *residual_coarse17 = nullptr;
	doublerealT* error_approx_coarse17 = nullptr;
	doublerealT *error_approx_fine17 = nullptr;
	doublerealT *residual_fine18 = nullptr;
	doublerealT *residual_coarse18 = nullptr;
	doublerealT* error_approx_coarse18 = nullptr;
	doublerealT *error_approx_fine18 = nullptr;


	/*
	residual_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	if (residual_fine == nullptr) {
	// недостаточно памяти на данном оборудовании.
	printf("Problem: not enough memory on your equipment for residual_fine in classic_aglomerative_amg2 my_agregat_amg...\n");
	printf("Please any key to exit...\n");
	//getchar();
	system("pause");
	exit(1);
	}
	if (ilevel > 1) {
	residual_coarse = new doublerealT[n_a[1] + 1];
	error_approx_coarse = new doublerealT[n_a[1] + 1];
	if (ilevel > 2) {
	// residual
	residual_fine1 = new doublerealT[n_a[1] + 1];
	residual_coarse1 = new doublerealT[n_a[2] + 1];
	error_approx_coarse1 = new doublerealT[n_a[2] + 1];
	error_approx_fine1 = new doublerealT[n_a[1] + 1];
	if (ilevel > 3) {
	// residual
	residual_fine2 = new doublerealT[n_a[2] + 1];
	residual_coarse2 = new doublerealT[n_a[3] + 1];
	error_approx_coarse2 = new doublerealT[n_a[3] + 1];
	error_approx_fine2 = new doublerealT[n_a[2] + 1];
	if (ilevel > 4) {
	// residual
	residual_fine3 = new doublerealT[n_a[3] + 1];
	residual_coarse3 = new doublerealT[n_a[4] + 1];
	error_approx_coarse3 = new doublerealT[n_a[4] + 1];
	error_approx_fine3 = new doublerealT[n_a[3] + 1];
	if (ilevel > 5) {
	// residual
	residual_fine4 = new doublerealT[n_a[4] + 1];
	residual_coarse4 = new doublerealT[n_a[5] + 1];
	error_approx_coarse4 = new doublerealT[n_a[5] + 1];
	error_approx_fine4 = new doublerealT[n_a[4] + 1];
	if (ilevel > 6) {
	// residual
	residual_fine5 = new doublerealT[n_a[5] + 1];
	residual_coarse5 = new doublerealT[n_a[6] + 1];
	error_approx_coarse5 = new doublerealT[n_a[6] + 1];
	error_approx_fine5 = new doublerealT[n_a[5] + 1];
	if (ilevel > 7) {
	// residual
	residual_fine6 = new doublerealT[n_a[6] + 1];
	residual_coarse6 = new doublerealT[n_a[7] + 1];
	error_approx_coarse6 = new doublerealT[n_a[7] + 1];
	error_approx_fine6 = new doublerealT[n_a[6] + 1];
	if (ilevel > 8) {
	// residual
	residual_fine7 = new doublerealT[n_a[7] + 1];
	residual_coarse7 = new doublerealT[n_a[8] + 1];
	error_approx_coarse7 = new doublerealT[n_a[8] + 1];
	error_approx_fine7 = new doublerealT[n_a[7] + 1];
	if (ilevel > 9) {
	// residual
	residual_fine8 = new doublerealT[n_a[8] + 1];
	residual_coarse8 = new doublerealT[n_a[9] + 1];
	error_approx_coarse8 = new doublerealT[n_a[9] + 1];
	error_approx_fine8 = new doublerealT[n_a[8] + 1];
	if (ilevel > 10) {
	// residual
	residual_fine9 = new doublerealT[n_a[9] + 1];
	residual_coarse9 = new doublerealT[n_a[10] + 1];
	error_approx_coarse9 = new doublerealT[n_a[10] + 1];
	error_approx_fine9 = new doublerealT[n_a[9] + 1];
	if (ilevel > 11) {
	// residual
	residual_fine10 = new doublerealT[n_a[10] + 1];
	residual_coarse10 = new doublerealT[n_a[11] + 1];
	error_approx_coarse10 = new doublerealT[n_a[11] + 1];
	error_approx_fine10 = new doublerealT[n_a[10] + 1];
	if (ilevel > 12) {
	// residual
	residual_fine11 = new doublerealT[n_a[11] + 1];
	residual_coarse11 = new doublerealT[n_a[12] + 1];
	error_approx_coarse11 = new doublerealT[n_a[12] + 1];
	error_approx_fine11 = new doublerealT[n_a[11] + 1];
	if (ilevel > 13) {
	// residual
	residual_fine12 = new doublerealT[n_a[12] + 1];
	residual_coarse12 = new doublerealT[n_a[13] + 1];
	error_approx_coarse12 = new doublerealT[n_a[13] + 1];
	error_approx_fine12 = new doublerealT[n_a[12] + 1];
	if (ilevel > 14) {
	// residual
	residual_fine13 = new doublerealT[n_a[13] + 1];
	residual_coarse13 = new doublerealT[n_a[14] + 1];
	error_approx_coarse13 = new doublerealT[n_a[14] + 1];
	error_approx_fine13 = new doublerealT[n_a[13] + 1];
	if (ilevel > 15) {
	// residual
	residual_fine14 = new doublerealT[n_a[14] + 1];
	residual_coarse14 = new doublerealT[n_a[15] + 1];
	error_approx_coarse14 = new doublerealT[n_a[15] + 1];
	error_approx_fine14 = new doublerealT[n_a[14] + 1];
	if (ilevel > 16) {
	// residual
	residual_fine15 = new doublerealT[n_a[15] + 1];
	residual_coarse15 = new doublerealT[n_a[16] + 1];
	error_approx_coarse15 = new doublerealT[n_a[16] + 1];
	error_approx_fine15 = new doublerealT[n_a[15] + 1];
	if (ilevel > 17) {
	// residual
	residual_fine16 = new doublerealT[n_a[16] + 1];
	residual_coarse16 = new doublerealT[n_a[17] + 1];
	error_approx_coarse16 = new doublerealT[n_a[17] + 1];
	error_approx_fine16 = new doublerealT[n_a[16] + 1];
	if (ilevel > 18) {
	// residual
	residual_fine17 = new doublerealT[n_a[17] + 1];
	residual_coarse17 = new doublerealT[n_a[18] + 1];
	error_approx_coarse17 = new doublerealT[n_a[18] + 1];
	error_approx_fine17 = new doublerealT[n_a[17] + 1];
	if (ilevel > 19) {
	// residual
	residual_fine18 = new doublerealT[n_a[18] + 1];
	residual_coarse18 = new doublerealT[n_a[19] + 1];
	error_approx_coarse18 = new doublerealT[n_a[19] + 1];
	error_approx_fine18 = new doublerealT[n_a[18] + 1];
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
	*/

	// лучше выделять оперативную память небольшими блоками т.к.
	// оперативная память фрагментирована системными dll и
	// большого свободного блока может не найтись.


	residual_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(residual_fine, "residual_fine", "classic_aglomerative_amg_5", (n_a[0] + 1));

	if (ilevel > 1) {
		//residual_coarse = new doublerealT[n_a[1] + 1];
		residual_coarse = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(residual_coarse, "residual_coarse", "classic_aglomerative_amg_5", (n_a[1] + 1));

		//error_approx_coarse = new doublerealT[n_a[1] + 1];
		error_approx_coarse = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(error_approx_coarse, "error_approx_coarse", "classic_aglomerative_amg_5", (n_a[1] + 1));


		// residual
		//residual_fine1 = new doublerealT[n_a[1] + 1];
		residual_fine1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(residual_fine1, "residual_fine1", "classic_aglomerative_amg_5", (n_a[1] + 1));

		if (ilevel > 2) {

			//residual_coarse1 = new doublerealT[n_a[2] + 1];
			residual_coarse1 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(residual_coarse1, "residual_coarse1", "classic_aglomerative_amg_5", (n_a[2] + 1));

			//error_approx_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_coarse1 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_coarse1, "error_approx_coarse1", "classic_aglomerative_amg_5", (n_a[2] + 1));

			//error_approx_fine1 = new doublerealT[n_a[1] + 1];
			error_approx_fine1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_fine1, "error_approx_fine1", "classic_aglomerative_amg_5", (n_a[1] + 1));


			// residual
			//residual_fine2 = new doublerealT[n_a[2] + 1];
			residual_fine2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(residual_fine2, "residual_fine2", "classic_aglomerative_amg_5", (n_a[2] + 1));

			if (ilevel > 3) {

				//residual_coarse2 = new doublerealT[n_a[3] + 1];
				residual_coarse2 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(residual_coarse2, "residual_coarse2", "classic_aglomerative_amg_5", (n_a[3] + 1));

				//error_approx_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_coarse2 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(error_approx_coarse2, "error_approx_coarse2", "classic_aglomerative_amg_5", (n_a[3] + 1));

				//error_approx_fine2 = new doublerealT[n_a[2] + 1];
				error_approx_fine2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(error_approx_fine2, "error_approx_fine2", "classic_aglomerative_amg_5", (n_a[2] + 1));


				// residual
				//residual_fine3 = new doublerealT[n_a[3] + 1];
				residual_fine3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(residual_fine3, "residual_fine3", "classic_aglomerative_amg_5", (n_a[3] + 1));

				if (ilevel > 4) {

					//residual_coarse3 = new doublerealT[n_a[4] + 1];
					residual_coarse3 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(residual_coarse3, "residual_coarse3", "classic_aglomerative_amg_5", (n_a[4] + 1));

					//error_approx_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_coarse3 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(error_approx_coarse3, "error_approx_coarse3", "classic_aglomerative_amg_5", (n_a[4] + 1));

					//error_approx_fine3 = new doublerealT[n_a[3] + 1];
					error_approx_fine3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(error_approx_fine3, "error_approx_fine3", "classic_aglomerative_amg_5", (n_a[3] + 1));


					// residual
					//residual_fine4 = new doublerealT[n_a[4] + 1];
					residual_fine4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(residual_fine4, "residual_fine4", "classic_aglomerative_amg_5", (n_a[4] + 1));

					if (ilevel > 5) {

						//residual_coarse4 = new doublerealT[n_a[5] + 1];
						residual_coarse4 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(residual_coarse4, "residual_coarse4", "classic_aglomerative_amg_5", (n_a[5] + 1));

						//error_approx_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_coarse4 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(error_approx_coarse4, "error_approx_coarse4", "classic_aglomerative_amg_5", (n_a[5] + 1));

						//error_approx_fine4 = new doublerealT[n_a[4] + 1];
						error_approx_fine4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(error_approx_fine4, "error_approx_fine4", "classic_aglomerative_amg_5", (n_a[4] + 1));


						// residual
						//residual_fine5 = new doublerealT[n_a[5] + 1];
						residual_fine5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(residual_fine5, "residual_fine5", "classic_aglomerative_amg_5", (n_a[5] + 1));

						if (ilevel > 6) {

							//residual_coarse5 = new doublerealT[n_a[6] + 1];
							residual_coarse5 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(residual_coarse5, "residual_coarse5", "classic_aglomerative_amg_5", (n_a[6] + 1));

							//error_approx_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_coarse5 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(error_approx_coarse5, "error_approx_coarse5", "classic_aglomerative_amg_5", (n_a[6] + 1));

							//error_approx_fine5 = new doublerealT[n_a[5] + 1];
							error_approx_fine5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(error_approx_fine5, "error_approx_fine5", "classic_aglomerative_amg_5", (n_a[5] + 1));


							// residual
							//residual_fine6 = new doublerealT[n_a[6] + 1];
							residual_fine6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(residual_fine6, "residual_fine6", "classic_aglomerative_amg_5", (n_a[6] + 1));

							if (ilevel > 7) {

								//residual_coarse6 = new doublerealT[n_a[7] + 1];
								residual_coarse6 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(residual_coarse6, "residual_coarse6", "classic_aglomerative_amg_5", (n_a[7] + 1));

								//error_approx_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_coarse6 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(error_approx_coarse6, "error_approx_coarse6", "classic_aglomerative_amg_5", (n_a[7] + 1));

								//error_approx_fine6 = new doublerealT[n_a[6] + 1];
								error_approx_fine6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(error_approx_fine6, "error_approx_fine6", "classic_aglomerative_amg_5", (n_a[6] + 1));


								// residual
								//residual_fine7 = new doublerealT[n_a[7] + 1];
								residual_fine7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(residual_fine7, "residual_fine7", "classic_aglomerative_amg_5", (n_a[7] + 1));

								if (ilevel > 8) {
									//residual_coarse7 = new doublerealT[n_a[8] + 1];
									residual_coarse7 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(residual_coarse7, "residual_coarse7", "classic_aglomerative_amg_5", (n_a[8] + 1));

									//error_approx_coarse7 = new doublerealT[n_a[8] + 1];
									error_approx_coarse7 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(error_approx_coarse7, "error_approx_coarse7", "classic_aglomerative_amg_5", (n_a[8] + 1));

									//error_approx_fine7 = new doublerealT[n_a[7] + 1];
									error_approx_fine7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(error_approx_fine7, "error_approx_fine7", "classic_aglomerative_amg_5", (n_a[7] + 1));


									// residual
									//residual_fine8 = new doublerealT[n_a[8] + 1];
									residual_fine8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(residual_fine8, "residual_fine8", "classic_aglomerative_amg_5", (n_a[8] + 1));

									if (ilevel > 9) {
										//residual_coarse8 = new doublerealT[n_a[9] + 1];
										residual_coarse8 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(residual_coarse8, "residual_coarse8", "classic_aglomerative_amg_5", (n_a[9] + 1));

										//error_approx_coarse8 = new doublerealT[n_a[9] + 1];
										error_approx_coarse8 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(error_approx_coarse8, "error_approx_coarse8", "classic_aglomerative_amg_5", (n_a[9] + 1));

										//error_approx_fine8 = new doublerealT[n_a[8] + 1];
										error_approx_fine8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(error_approx_fine8, "error_approx_fine8", "classic_aglomerative_amg_5", (n_a[8] + 1));


										// residual
										//residual_fine9 = new doublerealT[n_a[9] + 1];
										residual_fine9 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(residual_fine9, "residual_fine9", "classic_aglomerative_amg_5", (n_a[9] + 1));

										if (ilevel > 10) {

											//residual_coarse9 = new doublerealT[n_a[10] + 1];
											residual_coarse9 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(residual_coarse9, "residual_coarse9", "classic_aglomerative_amg_5", (n_a[10] + 1));

											//error_approx_coarse9 = new doublerealT[n_a[10] + 1];
											error_approx_coarse9 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(error_approx_coarse9, "error_approx_coarse9", "classic_aglomerative_amg_5", (n_a[10] + 1));

											//error_approx_fine9 = new doublerealT[n_a[9] + 1];
											error_approx_fine9 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(error_approx_fine9, "error_approx_fine9", "classic_aglomerative_amg_5", (n_a[9] + 1));


											// residual
											//residual_fine10 = new doublerealT[n_a[10] + 1];
											residual_fine10 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(residual_fine10, "residual_fine10", "classic_aglomerative_amg_5", (n_a[10] + 1));

											if (ilevel > 11) {

												//residual_coarse10 = new doublerealT[n_a[11] + 1];
												residual_coarse10 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(residual_coarse10, "residual_coarse10", "classic_aglomerative_amg_5", (n_a[11] + 1));

												//error_approx_coarse10 = new doublerealT[n_a[11] + 1];
												error_approx_coarse10 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(error_approx_coarse10, "error_approx_coarse10", "classic_aglomerative_amg_5", (n_a[11] + 1));

												//error_approx_fine10 = new doublerealT[n_a[10] + 1];
												error_approx_fine10 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(error_approx_fine10, "error_approx_fine10", "classic_aglomerative_amg_5", (n_a[10] + 1));


												// residual
												//residual_fine11 = new doublerealT[n_a[11] + 1];
												residual_fine11 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(residual_fine11, "residual_fine11", "classic_aglomerative_amg_5", (n_a[11] + 1));

												if (ilevel > 12) {

													//residual_coarse11 = new doublerealT[n_a[12] + 1];
													residual_coarse11 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(residual_coarse11, "residual_coarse11", "classic_aglomerative_amg_5", (n_a[12] + 1));

													//error_approx_coarse11 = new doublerealT[n_a[12] + 1];
													error_approx_coarse11 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(error_approx_coarse11, "error_approx_coarse11", "classic_aglomerative_amg_5", (n_a[12] + 1));

													//error_approx_fine11 = new doublerealT[n_a[11] + 1];
													error_approx_fine11 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(error_approx_fine11, "error_approx_fine11", "classic_aglomerative_amg_5", (n_a[11] + 1));


													// residual
													//residual_fine12 = new doublerealT[n_a[12] + 1];
													residual_fine12 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(residual_fine12, "residual_fine12", "classic_aglomerative_amg_5", (n_a[12] + 1));

													if (ilevel > 13) {

														//residual_coarse12 = new doublerealT[n_a[13] + 1];
														residual_coarse12 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(residual_coarse12, "residual_coarse12", "classic_aglomerative_amg_5", (n_a[13] + 1));

														//error_approx_coarse12 = new doublerealT[n_a[13] + 1];
														error_approx_coarse12 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(error_approx_coarse12, "error_approx_coarse12", "classic_aglomerative_amg_5", (n_a[13] + 1));

														//error_approx_fine12 = new doublerealT[n_a[12] + 1];
														error_approx_fine12 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(error_approx_fine12, "error_approx_fine12", "classic_aglomerative_amg_5", (n_a[12] + 1));


														// residual
														//residual_fine13 = new doublerealT[n_a[13] + 1];
														residual_fine13 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(residual_fine13, "residual_fine13", "classic_aglomerative_amg_5", (n_a[13] + 1));

														if (ilevel > 14) {

															//residual_coarse13 = new doublerealT[n_a[14] + 1];
															residual_coarse13 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(residual_coarse13, "residual_coarse13", "classic_aglomerative_amg_5", (n_a[14] + 1));

															//error_approx_coarse13 = new doublerealT[n_a[14] + 1];
															error_approx_coarse13 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(error_approx_coarse13, "error_approx_coarse13", "classic_aglomerative_amg_5", (n_a[14] + 1));

															//error_approx_fine13 = new doublerealT[n_a[13] + 1];
															error_approx_fine13 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(error_approx_fine13, "error_approx_fine13", "classic_aglomerative_amg_5", (n_a[13] + 1));


															// residual
															//residual_fine14 = new doublerealT[n_a[14] + 1];
															residual_fine14 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(residual_fine14, "residual_fine14", "classic_aglomerative_amg_5", (n_a[14] + 1));

															if (ilevel > 15) {

																//residual_coarse14 = new doublerealT[n_a[15] + 1];
																residual_coarse14 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(residual_coarse14, "residual_coarse14", "classic_aglomerative_amg_5", (n_a[15] + 1));

																//error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																error_approx_coarse14 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(error_approx_coarse14, "error_approx_coarse14", "classic_aglomerative_amg_5", (n_a[15] + 1));

																//error_approx_fine14 = new doublerealT[n_a[14] + 1];
																error_approx_fine14 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(error_approx_fine14, "error_approx_fine14", "classic_aglomerative_amg_5", (n_a[14] + 1));


																// residual
																//residual_fine15 = new doublerealT[n_a[15] + 1];
																residual_fine15 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(residual_fine15, "residual_fine15", "classic_aglomerative_amg_5", (n_a[15] + 1));

																if (ilevel > 16) {

																	//residual_coarse15 = new doublerealT[n_a[16] + 1];
																	residual_coarse15 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(residual_coarse15, "residual_coarse15", "classic_aglomerative_amg_5", (n_a[16] + 1));

																	//error_approx_coarse15 = new doublerealT[n_a[16] + 1];
																	error_approx_coarse15 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(error_approx_coarse15, "error_approx_coarse15", "classic_aglomerative_amg_5", (n_a[16] + 1));

																	//error_approx_fine15 = new doublerealT[n_a[15] + 1];
																	error_approx_fine15 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(error_approx_fine15, "error_approx_fine15", "classic_aglomerative_amg_5", (n_a[15] + 1));


																	// residual
																	//residual_fine16 = new doublerealT[n_a[16] + 1];
																	residual_fine16 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(residual_fine16, "residual_fine16", "classic_aglomerative_amg_5", (n_a[16] + 1));

																	if (ilevel > 17) {

																		//residual_coarse16 = new doublerealT[n_a[17] + 1];
																		residual_coarse16 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(residual_coarse16, "residual_coarse16", "classic_aglomerative_amg_5", (n_a[17] + 1));

																		//error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																		error_approx_coarse16 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(error_approx_coarse16, "error_approx_coarse16", "classic_aglomerative_amg_5", (n_a[17] + 1));

																		//error_approx_fine16 = new doublerealT[n_a[16] + 1];
																		error_approx_fine16 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(error_approx_fine16, "error_approx_fine16", "classic_aglomerative_amg_5", (n_a[16] + 1));


																		// residual
																		//residual_fine17 = new doublerealT[n_a[17] + 1];
																		residual_fine17 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(residual_fine17, "residual_fine17", "classic_aglomerative_amg_5", (n_a[17] + 1));

																		if (ilevel > 18) {
																			//residual_coarse17 = new doublerealT[n_a[18] + 1];
																			residual_coarse17 = (doublerealT*)malloc((n_a[18] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(residual_coarse17, "residual_coarse17", "classic_aglomerative_amg_5", (n_a[18] + 1));

																			//error_approx_coarse17 = new doublerealT[n_a[18] + 1];
																			error_approx_coarse17 = (doublerealT*)malloc((n_a[18] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(error_approx_coarse17, "error_approx_coarse17", "classic_aglomerative_amg_5", (n_a[18] + 1));

																			//error_approx_fine17 = new doublerealT[n_a[17] + 1];
																			error_approx_fine17 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(error_approx_fine17, "error_approx_fine17", "classic_aglomerative_amg_5", (n_a[17] + 1));

																			// residual
																			//residual_fine18 = new doublerealT[n_a[18] + 1];
																			residual_fine18 = (doublerealT*)malloc((n_a[18] + 1) * sizeof(doublerealT));
																			handle_error<doublerealT>(residual_fine18, "residual_fine18", "classic_aglomerative_amg_5", (n_a[18] + 1));

																			if (ilevel > 19) {
																				//residual_coarse18 = new doublerealT[n_a[19] + 1];
																				residual_coarse18 = (doublerealT*)malloc((n_a[19] + 1) * sizeof(doublerealT));
																				handle_error<doublerealT>(residual_coarse18, "residual_coarse18", "classic_aglomerative_amg_5", (n_a[19] + 1));

																				//error_approx_coarse18 = new doublerealT[n_a[19] + 1];
																				error_approx_coarse18 = (doublerealT*)malloc((n_a[19] + 1) * sizeof(doublerealT));
																				handle_error<doublerealT>(error_approx_coarse18, "error_approx_coarse18", "classic_aglomerative_amg_5", (n_a[19] + 1));

																				//error_approx_fine18 = new doublerealT[n_a[18] + 1];
																				error_approx_fine18 = (doublerealT*)malloc((n_a[18] + 1) * sizeof(doublerealT));
																				handle_error<doublerealT>(error_approx_fine18, "error_approx_fine18", "classic_aglomerative_amg_5", (n_a[18] + 1));
																			}

																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	doublerealT *error_approx_fine = nullptr;
	//error_approx_fine = new doublerealT[n_a[0] + 1];
	error_approx_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(error_approx_fine, "error_approx_fine", "classic_aglomerative_amg_5", (n_a[0] + 1));



	// 2 jan 2016. 
	integer igam = 1; // 1-V; 2-W
	// надо увеличивать nu1, nu2 с 1,2 до 5 наверно.
	//const INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14 imyinit = INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT; // ZERO_INIT optimum

	doublerealT* x_copy = nullptr;
	x_copy = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(x_copy, "x_copy", "classic_aglomerative_amg_5", (n_a[0] + 1));

	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_copy[i47] = (doublerealT)(x[i47]);
		//x_copy[i47] = 0.0; // 28.07.2016
	}

	doublerealT* x_best_search = nullptr;
	x_best_search = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(x_best_search, "x_best_search", "classic_aglomerative_amg_5", (n_a[0] + 1));

	doublerealT res_best_search = (doublerealT)(1e37);
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search[i47] = (doublerealT)(x[i47]);
		//x_best_search[i47] = 0.0; // 28.07.2016
	}


	// Для поправки давления возникает задача когда на всех границах стоит условие Неймана,
	// это приводит к тому что метод работает бесконечно долго и не может сойтись, поэтому нужно 
	// заложить критерий останова по превышению количества допустимых итераций (не более 1000 итераций).
	// 1000 итераций это очень долго поэтому для поправки давления надо подобрать разумное количество 
	// итераций т.к. от этого существенным образом зависит быстродействие гидродинамического алгоритма.
	integer iter_limit = 0;
	integer istop_porog_reconst = 5000;// 50

	bool ret_value = false;
	doublerealT dres_previos = (doublerealT)(1.0e37);
	integer icount_bad_convergence_Vcycles = 0;
	integer i_count_stagnation = 0;
	doublerealT res0start = (doublerealT)(1.0e-36);
	bool bfirst_divergence = true;

	residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
	doublerealT dres_initial = norma(residual_fine, n_a[0]);
	integer iflag_cont = 1;
	if (iVar != PAM) {
		dres = fabs(dres_initial);

		if (iVar != TEMP) {
			if (dres < dterminatedTResudual) {
				// Вектор и так точно удовлетворяет решению, его не надо уточнять из решения СЛАУ.
				iflag_cont = 0;
			}
		}
		else {
			if (dres < 1.0e-4*dterminatedTResudual) {
				// Вектор и так точно удовлетворяет решению, его не надо уточнять из решения СЛАУ.
				iflag_cont = 0;
			}
		}
	}
	iflag_cont = 1;
	if (bprint_mesage_diagnostic) {
		// start residual.
#if doubleintprecision == 1
		printf("%d %e rho=%e\n", 0, dres_initial, dres_initial / rho);
#else
		printf("%d %e rho=%e\n", 0, dres_initial, dres_initial / rho);
#endif
		
	}

	integer count_iter_for_film_coef = 0;
	// Если число расходимостей превысит оговорённую константу то произойдёт выход из алгоритма.
	integer i_signal_break_pam_opening = 0;
	// x хорошее значение.
	const integer i_limit_signal_pam_break_opening = 1000;
	doublerealT delta_old_iter = 1.0e10;

	// диагностическое сообщение какую переменную мы решаем.
	if (bprint_mesage_diagnostic) {
		switch (iVar) {
		case PAM: printf("PAM\n");  break;
		case VELOCITY_X_COMPONENT:  printf("VX\n"); break;
		case VELOCITY_Y_COMPONENT:  printf("VY\n"); break;
		case VELOCITY_Z_COMPONENT:  printf("VZ\n"); break;
		case TEMP:  printf("TEMP\n"); break;
		}
	}
	else {/*
		switch (iVar) {
		case PAM: printf("PAM	");  break;
		case VX:  printf("VX	"); break;
		case VY:  printf("VY	"); break;
		case VZ:  printf("VZ	"); break;
		case TEMP:  printf("TEMP\n"); break;
		}*/
#if doubleintprecision == 1
		switch (iVar) {
			// модуль ВУМ с радиатором жидкостного охлаждения ilevel_VX_VY_VZ=10, ilevel_PAM=5 или 6.

		case PAM: printf("PAM level=%lld CopA=%e CopP=%e %lld %lld %lld %lld %lld\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]);  break;
		case VELOCITY_X_COMPONENT:  printf("VX level=%lld CopA=%e CopP=%e %lld %lld %lld %lld %lld\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VELOCITY_Y_COMPONENT:  printf("VY level=%lld CopA=%e CopP=%e %lld %lld %lld %lld %lld\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VELOCITY_Z_COMPONENT:  printf("VZ level=%lld CopA=%e CopP=%e %lld %lld %lld %lld %lld\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case TEMP:  printf("TEMP level=%lld CopA=%e CopP=%e %lld %lld %lld %lld %lld\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		}
#else
		switch (iVar) {
			// модуль ВУМ с радиатором жидкостного охлаждения ilevel_VX_VY_VZ=10, ilevel_PAM=5 или 6.

		case PAM: printf("PAM level=%d CopA=%e CopP=%e %d %d %d %d %d\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]);  break;
		case VELOCITY_X_COMPONENT:  printf("VX level=%d CopA=%e CopP=%e %d %d %d %d %d\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VELOCITY_Y_COMPONENT:  printf("VY level=%d CopA=%e CopP=%e %d %d %d %d %d\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VELOCITY_Z_COMPONENT:  printf("VZ level=%d CopA=%e CopP=%e %d %d %d %d %d\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case TEMP:  printf("TEMP level=%d CopA=%e CopP=%e %d %d %d %d %d\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		}
#endif
		

	}
	//getchar();

	//if (iVar == PAM) {// бред
	//for (integer iter = 0; iter < 2; iter++) {
	//seidelq(Amat, 1, n_a[0], b, x, row_ptr_start, row_ptr_end, 0);
	//}
	//}
	integer icount_V_cycle = 0;


	doublerealT dres_initial_ = (doublerealT)(1e-6);
	//ilevel = 3;
	// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
	// Т.к. есть трудносходящиеся задачи, то этинастройки должны помоч.
	// Отсекаем уровни которые выше порогового значения указанного пользователем.
	//if (ilevel > my_amg_manager.maximum_levels) {
		//ilevel = my_amg_manager.maximum_levels;
	//}

	ilevel -= my_amg_manager.maximum_delete_levels;

	doublerealT maxold = (doublerealT)(-1.0e30);
	for (integer i = 1; i <= n_a[0]; i++) {
		if (x[i] > maxold) maxold = (doublerealT)(x[i]);
	}

	doublerealT* x_best_search2 = new doublerealT[n_a[0] + 1];
	doublerealT* x_best_search_init = new doublerealT[n_a[0] + 1];
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search_init[i47] = (doublerealT)(x[i47]);
	}



	//for (integer iprohod = 0; iprohod < 20; iprohod++) {
	while ((iflag_cont==1) && (dres>tolerance)) {

		
		if (bPhysics_stop  ) {
			if (icount_V_cycle > 0) {
				doublerealT maxnew = (doublerealT)(-1.0e30);
				for (integer i = 1; i <= n_a[0]; i++) {
					if (x[i] > maxnew) maxnew = (doublerealT)(x[i]);
				}
				if (iVar == TOTALDEFORMATIONVAR) {
					if ((fabs(dres) < 1.0e-2) && (fabs(maxnew - maxold) < 1.0e-9)) {
						//printf("break bPhysics_stop, dres<1e-2 && (fabs(maxnew - maxold) < 1.0e-9)\n");
						break;
					}
					else {
						maxold = maxnew;
					}
				}
				else {
					if ((fabs(dres) < 1.0e-2) && (fabs(maxnew - maxold) < 0.0005)) {
						break;
					}
					else {
						maxold = maxnew;
					}
				}

			}
		}


		if (fabs(dres / rho)<1.0) {
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x_best_search2[i47] = (doublerealT)(x[i47]);
			}
		}

		//getchar();
		icount_V_cycle++;
		//if (icount_V_cycle > 8) break;
		count_iter_for_film_coef++;
		// В случае задачи Ньютона - Рихмана, Стефана-Больцмана и миксового условия не итерируем до конца обрываем, 
		// т.к. нам требуется частая пересборка матрицы. 13 марта 2016.
		// Для космических задач этот прерыватель просто необходим 14 октября 2016.
		if (((adiabatic_vs_heat_transfer_coeff > DEFAULT_CABINET_BOUNDARY_CONDITION::ADIABATIC_WALL_BC) ||
			(breakRUMBAcalc_for_nonlinear_boundary_condition)) && (count_iter_for_film_coef>125)) break;


		if (iter_limit == 5000) {
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x[i47] = x_copy[i47];
			}
			//printf("amg divergence detected...\n");
			//getchar();
			break;
		}

		if (iter_limit == 1) {
			// начальная невязка.
			res0start = fabs(dres);
		}


		if (fabs(dres) < res_best_search)
		{
			// Запоминаем лучшую попытку.
			res_best_search = fabs(dres);
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x_best_search[i47] = (doublerealT)(x[i47]);
			}
		}

		if (0&&(icount_V_cycle == 2)) {
			// именно 2 должна фигурировать иначе сходимости не будет совсем.
			if (bSIMPLErun_now_for_temperature) {
				// Мы решаем уравнения Навье-Стокса.
				// Выходим в том случае если невязка стала на 4 
				// порядка меньше чем начальная.
				// 1.0e-1 нет сходимости.
				// 1.0e-3 нет сходимости.
				// 1.0e-4 неплохо но есть всплеск на 43 итерации.
				// 1.0e-5 два всплеска (один в самом конце).
				tolerance = (doublerealT)(1.0e-4*dres);//1e-4
				dres_initial_ = dres;
			}
			else {
				tolerance = (doublerealT)(1.0e-4);// Отдельное решение уравнения теплопроводности.
			}
		}
		if (dres < (doublerealT)(1.0e-14)) break; // 1.0e-14 не повлияло.
		if (iVar == PAM) {
			// Этот кусок кода предназначен для того чтобы не было болтанки или всплесков:
			// когда на текущей итерации сошлось очень хорошо допустим на порядок,
			// а на следующей сошлось лишь на 0.33 т.е. хуже и это вызывает всплеск, 
			// нарушение монотоности при сходимости.
			// 0.37
			//if (fabs(dres / dres_initial_) < 0.1) break;
		}

		/*
		if (iVar == PAM) {
		if (fabs(dres) < 1.0) {
		// Идея в том что нам нужна хоть какая-то поправка давления,
		// всё лучше чем тождественно нулевое распределение.
		// невязка при этом у нас менеее 1.0 что гарантирует что мы не сильно улетели.
		for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search[i47] = x[i47];
		}
		}
		}
		*/

		// debug 7 июня 2016
		//if (iter_limit > 300) {
		//printf("amg divergense detected...9 june 2016\n");
		//system("pause");
		//break;
		//}

		/*
		// 100
		if (iter_limit > 5000) { // Finned Heat Sink


			
			if (bfirst_divergence) {
				iter_limit = 3;
				nu1 += 2;
				nu2 += 2;
				nFinestSweeps += 2;
				bfirst_divergence = false;
			}
			else {
				if ((fabs(res_best_search / res0start) < 0.23) && (fabs(res_best_search) < 1.0e-3*sqrt(n_a[0]))) {
					// Если невязка меньше первоначальной на два порядка.
					// Обратное копирование и выход и алгоритма.
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				else if ((fabs(res_best_search / res0start) <= 1.0) && (fabs(res_best_search) < 1.0e-4*sqrt(n_a[0]))) {
					// Если невязка меньше первоначальной на два порядка.
					// Обратное копирование и выход и алгоритма.
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				// Обратное копирование и выход и алгоритма.
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = x_best_search[i47];
				}
				break;
				// Эта ветвь кода вообще никогда не вызовется.
				printf("Fatal amg error: Strong divergence amg solver...%e \n", fabs(res_best_search / res0start));
				printf("res_best_search=%e, res0start=%e\n", fabs(res_best_search), fabs(res0start));
				printf("BiCGStab+ILU2 is start now...\n");
				printf("please wait...");
				system("pause");
				break; // досрочный выход из while цикла.
			}
		}
		*/
		iter_limit++;

		if (fabs(dres) < fabs(dres_previos)) {
			// все нормально процесс сходится.
			icount_bad_convergence_Vcycles = 0;
		}
		else {
			icount_bad_convergence_Vcycles++;
		}

		//if (_finite(dres) == 0) {
		//if (fabs(dres) > 1.0e30)
		//{
		//printf("\ndivergence AMG detected...solver will be restart... please wait... ... ...\n");
		//printf("\a\a\a\a\a\a\a\a");
		//system("pause");
		//exit(1);
		//return true;
		//for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		//	x[i47] = x_copy[i47];
		//}
		//if (iter_limit > 100) {
		//	ret_value = true;
		//	break;
		//}
		//else {
		// Увеличение количества сглаживающих итераций ни коим образом не 
		// исправляет факт расходимости. 
		//	nu1++;
		//	nu2++;
		//	nFinestSweeps++;
		// По видимому надо действовать очень тонкой настройкой параметра верхней релаксации omega optimal.
		// Настройка omega optimal должна быть самообучающейся (адаптированной к задаче).
		//}
		//}
		/*
		if ((icount_bad_convergence_Vcycles >= istop_porog_reconst) || (fabs(dres) / sqrt(n_a[0]) > 1.0e30)) {
			// детектировано 10 шагов расходимости подряд по-видимому метод расходится.
			// Также о расходимости говорит невязка большая 1.0e30.

			//if (fabs(dres) < 1.0e-3) break; // Будем считать сходимость достигнута успешно.
			if ((fabs(res_best_search / res0start) < 1.0e-1) && (fabs(dres) / sqrt(n_a[0]) < 1.0e-3)) {
				// Если невязка меньше первоначальной на два порядка.
				// Обратное копирование и выход и алгоритма.
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = x_best_search[i47];
				}
				break;
			}
			i_count_stagnation++;

			printf("\ndivergence AMG detected...solver will be restart... please wait... ... ...\n");
			//printf("\a\a\a\a\a\a\a\a");
			//system("pause");
			//exit(1);
			//return true;
			if (i_count_stagnation < 20) {
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					//x[i47] = x_copy[i47];
					x[i47] = x_best_search[i47]; // лучшее найденное решение
				}
			}
			if (i_count_stagnation == 20 || i_count_stagnation == 21) gold_const = 0.2;
			if ((i_count_stagnation >= 20) && (i_count_stagnation < 30)) {
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					//x[i47] = x_copy[i47];
					// Можно еще единократно немного улучшить nu1 и nu2.
					doublerealT signumnow = 1.0;
					if (rand() % 2 == 0) signumnow = -1.0;
					x[i47] = signumnow *1.0*(rand() % 90 + 10) / 100.0; // Случайное число в интервале от 0 до 1.
				}
			}
			if (i_count_stagnation == 30 || i_count_stagnation == 31) gold_const = 0.2;
			if (i_count_stagnation >= 30) {
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = 1.0;
				}
			}
			if (bproblem_amg_convergence1) {
				if (bproblem_amg_convergence2) {
					if (bproblem_amg_convergence3) {
						// выход к вызову BiCGStab+ILU2.
						ret_value = true;
						break;
					}
					else {
						// смена omega.
						bproblem_amg_convergence3 = true;
						icount_bad_convergence_Vcycles = 0;
						buffers3omega = dres / dres_previos;
						printf("buffers1omega=%1.4f, buffers2omega=%1.4f, buffers3omega=%1.4f\n", buffers1omega, buffers2omega, buffers3omega);
					}
				}
				else {
					// смена omega.
					bproblem_amg_convergence2 = true;
					icount_bad_convergence_Vcycles = 0;
					buffers2omega = dres / dres_previos;
					printf("buffers1omega=%1.4f, buffers2omega=%1.4f\n", buffers1omega, buffers2omega);
					//istop_porog_reconst += 50; // 10, 20, 30, 40
					// Увеличение количества сглаживающих итераций ничего не даёт.
					//nu1++;
					//nu2++;
					//nFinestSweeps++;
				}
			}
			else {

				bproblem_amg_convergence1 = true; // переход с SOR на стабильный Зейдель.
				icount_bad_convergence_Vcycles = 0;
				buffers1omega = dres / dres_previos;
			}
		}
		*/

		dres_previos = dres;


		doublerealT R0_0 = 0.0;
		doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
			R0_0 = norma(residual_fine, n_a[0]);
			Rprev_0 = R0_0;

			// smother
			integer iter = 0;
			for (iter = 0; iter < nu1; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
				//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
				residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
				Rnext_0 = norma(residual_fine, n_a[0]);
				// this is process flow logic
				if (Rnext_0 > process_flow_beta*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nu1) {
				printf("level 0 limit presmother iteration is reached\n");
			}

		}
		else {
			// smoother
			for (integer iter = 0; iter < nu1; iter++) {
				//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					if (bILU2smoother == 1) {
						// ILU0
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
						residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu0[0].zbuf[i43 + 1] = residual_fine[i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu0[0].zbuf, milu0[0].zbuf2, milu0[0]);
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							x[i43 + 1] += milu0[0].zbuf2[i43 + 1];
						}
					}
					else if (bILU2smoother == 2) {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
						residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu2[0].zbuf[i43 + 1] = residual_fine[i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu2[0].zbuf, milu2[0].zbuf2, milu2[0]);
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							x[i43 + 1] += milu2[0].zbuf2[i43 + 1];
						}
					}
					else {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
					}
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
			}
		}

		//exporttecplot(x, n);

		move_down(nu1, nu2);

		if (!process_flow_logic) {
			// residual_r
			//doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
			//residual(Amat, 1, nnz_a[0], x, b, flag, n_a[0], residual_fine);
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
		}
		dres = norma(residual_fine, n_a[0]);
		ret74 += fabs(dres);
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("%lld %e rho=%e\n", iiter, dres, dres / rho);
#else
			printf("%d %e rho=%e\n", iiter, dres, dres / rho);
#endif
			
			if (fabs(1.0 - fabs(dres / rho)) < 1.0e-3) {
				printf("stagnation in amg solver determinate ...\n");
				// 28_10_2016.
				// Осуществляем досрочный выход из итерирования, 
				// т.к. невязка перестала меняться.
				break;
			}
		}
		iiter++;
		// 28.07.2016
		if (fabs(dres) > 1.0e7) {
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x[i47] = x_best_search[i47];
			}
			//printf("amg divergence detected.");
			//getchar();
			break;
		}

		if (1&&(iVar == PAM)) {
			if ((fabs(dres / rho) > 0.99999) || (fabs(dres) > 1.0e7)) {
				// Выход из мультигрида ести достигнуто 20 циклов расходимости.
				delta_old_iter = fabs(dres);
				i_signal_break_pam_opening++;
				if (i_signal_break_pam_opening > i_limit_signal_pam_break_opening) {
#if doubleintprecision == 1
					printf("iter = %lld\n", iiter);
#else
					printf("iter = %d\n", iiter);
#endif
					
					// Обратное копирование и выход и алгоритма.
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				if (i_signal_break_pam_opening > 50) {
				//	signal_omega_correct = true;
				}
			}
		}
		if (signal_omega_correct) {
			//getchar();
			system("PAUSE");
		}

		//rho=norma(residual_fine, n_a[0]);
		rho = dres;

		//if (iprohod%5==0) getchar();
		if (ilevel > 1) {

			//doublerealT *residual_coarse = new doublerealT[n_a[1] + 1];
		
			for (integer ii = 1; ii <= n_a[1]; ii++) {
				residual_coarse[ii] = 0.0;
			}

			//exporttecplotxy360T_3D_part2amg(residual_fine, false, 1);

			// restriction
			// из residual fine получает residual coarce.
			restriction(R, 1, nnz_aRP[0], flag, residual_fine, residual_coarse, n_a[0], n_a[1]);

			// Amat*e=r;
			//doublerealT* error_approx_coarse = new doublerealT[n_a[1] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
			{
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] = 0.0;
				}
			}


if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
			{
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] = (rand() / ((doublerealT)RAND_MAX));
				}
			}



			for (integer i_37 = 1; i_37 <= igam; i_37++) {
				doublerealT R0_1 = 0.0;
				doublerealT Rprev_1 = 0.0, Rnext_1 = 0.0;
				if (process_flow_logic) {
					// calculate initial residual.
					//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
					residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

					R0_1 = norma(residual_fine1, n_a[1]);
					Rprev_1 = R0_1;

					// smother
					integer iter = 0;
					for (iter = 0; iter < nu1; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}

						//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
						residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

						Rnext_1 = norma(residual_fine1, n_a[1]);
						// this is process flow logic
						if (Rnext_1 > process_flow_beta*Rprev_1) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_1 = Rnext_1;
						}
					}

					if (iter == nu1) {
						printf("level 1 limit presmother iteration is reached\n");
					}

				}
				else {

					// pre smothing
					for (integer iter = 0; iter < nu1; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
						if (bonly_serial) {
							if (bILU2smoother == 1) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
								residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu0[1].zbuf[i43 + 1] = residual_fine1[i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu0[1].zbuf, milu0[1].zbuf2, milu0[1]);
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[i43 + 1] += (doublerealT)(milu0[1].zbuf2[i43 + 1]);
								}


							}
							else if (1 && bILU2smoother == 2) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
								residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu2[1].zbuf[i43 + 1] = residual_fine1[i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu2[1].zbuf, milu2[1].zbuf2, milu2[1]);
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[i43 + 1] += (doublerealT)(milu2[1].zbuf2[i43 + 1]);
								}


							}
							else {
								seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
							}
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}
					}
				}

				move_down(nu1, nu2);


				if (ilevel > 2) {
					// residual
					if (!process_flow_logic) {
						//doublerealT *residual_fine1 = new doublerealT[n_a[1] + 1];
						//residual(Amat, 1+2*nnz_a[0], 2*nnz_a[0]+nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1], residual_fine1);
						//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
						residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);
						//residualqspeshial(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
					}

					//doublerealT *residual_coarse1 = new doublerealT[n_a[2] + 1];


					/*
					doublerealT* residual_fine_for_plot = new doublerealT[n_a[0] + 1];
					for (integer i_4 = 0; i_4 <= n_a[0]; i_4++) {
						residual_fine_for_plot[i_4] = 0.0;
					}
					// restriction
					exporttecplotxy360T_3D_part2amg(residual_fine, false, 1);
					// из residual fine получает residual coarce.
					prolongation(P, 1, nnz_aRP[0], flag, residual_fine_for_plot, residual_coarse, n_a[0], n_a[1]);
					exporttecplotxy360T_3D_part2amg(residual_fine_for_plot, false, 1);
					restriction(R, 1, nnz_aRP[0], flag, residual_fine_for_plot, residual_coarse, n_a[0], n_a[1]);
					prolongation(P, 1, nnz_aRP[0], flag, residual_fine_for_plot, residual_coarse, n_a[0], n_a[1]);
					exporttecplotxy360T_3D_part2amg(residual_fine_for_plot, false, 1);
					restriction(R, 1, nnz_aRP[0], flag, residual_fine_for_plot, residual_coarse, n_a[0], n_a[1]);
					prolongation(P, 1, nnz_aRP[0], flag, residual_fine_for_plot, residual_coarse, n_a[0], n_a[1]);
					exporttecplotxy360T_3D_part2amg(residual_fine_for_plot, false, 1);


					delete[] residual_fine_for_plot;
					*/


					// restriction
					restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, residual_fine1, residual_coarse1, n_a[1], n_a[2]);

					// Amat*e=r;
					//doublerealT* error_approx_coarse1 = new doublerealT[n_a[2] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
					{
						for (integer ii = 1; ii <= n_a[2]; ii++) {
							error_approx_coarse1[ii] = 0.0;
						}
					}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
					{
						for (integer ii = 1; ii <= n_a[2]; ii++) {
							error_approx_coarse1[ii] = (rand() / ((doublerealT)RAND_MAX));
						}
					}


					//for (integer i_37 = 1; i_37 <= igam; i_37++)
				{
					doublerealT R0_2 = 0.0;
					doublerealT Rprev_2 = 0.0, Rnext_2 = 0.0;
					if (process_flow_logic) {
						// calculate initial residual.
						//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

						R0_2 = norma(residual_fine2, n_a[2]);
						Rprev_2 = R0_2;

						// smother
						integer iter = 0;
						for (iter = 0; iter < nu1; iter++) {
							//quick seidel
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}

							//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
							residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

							Rnext_2 = norma(residual_fine2, n_a[2]);
							// this is process flow logic
							if (Rnext_2 > process_flow_beta*Rprev_2) {
								// Смысл модификации в том что мы экономим итерации на пресмутере.
								break; // досрочно опускаемся на следующий уровень если он есть конечно.
							}
							else {
								Rprev_2 = Rnext_2;
							}
						}

						if (iter == nu1) {
							printf("level 2 limit presmother iteration is reached\n");
						}

					}
					else {

						// pre smothing
						for (integer iter = 0; iter < nu1; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
							if (bonly_serial) {
								if (bILU2smoother == 1) {
									seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
									residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										milu0[2].zbuf[i43 + 1] = residual_fine2[i43 + 1];
									}
									lusol_1patchforRUMBA(n_a[2], milu0[2].zbuf, milu0[2].zbuf2, milu0[2]);
									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										error_approx_coarse1[i43 + 1] += (doublerealT)(milu0[2].zbuf2[i43 + 1]);
									}
								}
								else if (1 && bILU2smoother == 2) {
									seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
									residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										milu2[2].zbuf[i43 + 1] = residual_fine2[i43 + 1];
									}
									lusol_1patchforRUMBA(n_a[2], milu2[2].zbuf, milu2[2].zbuf2, milu2[2]);
									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										error_approx_coarse1[i43 + 1] += (doublerealT)(milu2[2].zbuf2[i43 + 1]);
									}
								}
								else {
									seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
								}
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
						}

					}

					move_down(nu1, nu2);

					if (ilevel > 3) {
						// residual
						if (!process_flow_logic) {
							//doublerealT *residual_fine2 = new doublerealT[n_a[2] + 1];
							//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2], residual_fine2);
							//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
							residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);
							//residualqspeshial(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						}

						//doublerealT *residual_coarse2 = new doublerealT[n_a[3] + 1];

						// restriction
						restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, residual_fine2, residual_coarse2, n_a[2], n_a[3]);

						// Amat*e=r;
						//doublerealT* error_approx_coarse2 = new doublerealT[n_a[3] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
						{
							for (integer ii = 1; ii <= n_a[3]; ii++) {
								error_approx_coarse2[ii] = 0.0;
							}
						}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
						{
							for (integer ii = 1; ii <= n_a[3]; ii++) {
								error_approx_coarse2[ii] = (rand() / ((doublerealT)RAND_MAX));
							}
						}

						//for (integer i_37 = 1; i_37 <= igam; i_37++)
					{
						doublerealT R0_3 = 0.0;
						doublerealT Rprev_3 = 0.0, Rnext_3 = 0.0;
						if (process_flow_logic) {
							// calculate initial residual.
							//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
							residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);


							R0_3 = norma(residual_fine3, n_a[3]);
							Rprev_3 = R0_3;

							// smother
							integer iter = 0;
							for (iter = 0; iter < nu1; iter++) {
								//quick seidel
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
								residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);


								Rnext_3 = norma(residual_fine3, n_a[3]);
								// this is process flow logic
								if (Rnext_3 > process_flow_beta*Rprev_3) {
									// Смысл модификации в том что мы экономим итерации на пресмутере.
									break; // досрочно опускаемся на следующий уровень если он есть конечно.
								}
								else {
									Rprev_3 = Rnext_3;
								}
							}

							if (iter == nu1) {
								printf("level 3 limit presmother iteration is reached\n");
							}

						}
						else {
							// pre smothing
							for (integer iter = 0; iter < nu1; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
								if (bonly_serial) {
									if (bILU2smoother == 1) {
										seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
										residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);

										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											milu0[3].zbuf[i43 + 1] = residual_fine3[i43 + 1];
										}
										lusol_1patchforRUMBA(n_a[3], milu0[3].zbuf, milu0[3].zbuf2, milu0[3]);
										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											error_approx_coarse2[i43 + 1] += (doublerealT)(milu0[3].zbuf2[i43 + 1]);
										}
									}
									else if (1 && bILU2smoother == 2) {
										seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
										residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);

										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											milu2[3].zbuf[i43 + 1] = residual_fine3[i43 + 1];
										}
										lusol_1patchforRUMBA(n_a[3], milu2[3].zbuf, milu2[3].zbuf2, milu2[3]);
										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											error_approx_coarse2[i43 + 1] += (doublerealT)(milu2[3].zbuf2[i43 + 1]);
										}
									}
									else {
										seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
									}
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
							}
						}


						move_down(nu1, nu2);


						if (ilevel > 4) {
							// residual
							if (!process_flow_logic) {
								//doublerealT *residual_fine3 = new doublerealT[n_a[3] + 1];
								//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3], residual_fine3);
								//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
								residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);

								//speshial
								//residualqspeshial(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
							}


							//doublerealT *residual_coarse3 = new doublerealT[n_a[4] + 1];

							// restriction
							restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, residual_fine3, residual_coarse3, n_a[3], n_a[4]);

							// Amat*e=r;
							//doublerealT* error_approx_coarse3 = new doublerealT[n_a[4] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
							{
								for (integer ii = 1; ii <= n_a[4]; ii++) {
									error_approx_coarse3[ii] = 0.0;
								}
							}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
							{
								for (integer ii = 1; ii <= n_a[4]; ii++) {
									error_approx_coarse3[ii] = (rand() / ((doublerealT)RAND_MAX));
								}
							}


							//for (integer i_37 = 1; i_37 <= igam; i_37++) 
						{
							doublerealT R0_4 = 0.0;
							doublerealT Rprev_4 = 0.0, Rnext_4 = 0.0;
							if (process_flow_logic) {
								// calculate initial residual.
								//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
								residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);


								R0_4 = norma(residual_fine4, n_a[4]);
								Rprev_4 = R0_4;

								// smother
								integer iter = 0;
								for (iter = 0; iter < nu1; iter++) {
									//quick seidel
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}

									//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
									residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);


									Rnext_4 = norma(residual_fine4, n_a[4]);
									// this is process flow logic
									if (Rnext_4 > process_flow_beta*Rprev_4) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_4 = Rnext_4;
									}
								}

								if (iter == nu1) {
									printf("level 4 limit presmother iteration is reached\n");
								}

							}
							else {
								// pre smothing
								for (integer iter = 0; iter < nu1; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
									if (bonly_serial) {
										if (bILU2smoother == 1) {
											seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
											residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);

											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												milu0[4].zbuf[i43 + 1] = residual_fine4[i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[4], milu0[4].zbuf, milu0[4].zbuf2, milu0[4]);
											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												error_approx_coarse3[i43 + 1] += (doublerealT)(milu0[4].zbuf2[i43 + 1]);
											}
										}
										else if (1 && bILU2smoother == 2) {
											seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
											residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);

											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												milu2[4].zbuf[i43 + 1] = residual_fine4[i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[4], milu2[4].zbuf, milu2[4].zbuf2, milu2[4]);
											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												error_approx_coarse3[i43 + 1] += (doublerealT)(milu2[4].zbuf2[i43 + 1]);
											}
										}
										else {
											seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
										}
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
								}
							}


							move_down(nu1, nu2);

							if (ilevel > 5) {
								// residual
								if (!process_flow_logic) {
									//doublerealT *residual_fine4 = new doublerealT[n_a[4] + 1];
									//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4], residual_fine4);
									//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
									residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);

									//speshial 14 september 2015.
									//residualqspeshial(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
								}


								//doublerealT *residual_coarse4 = new doublerealT[n_a[5] + 1];

								// restriction
								restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, residual_fine4, residual_coarse4, n_a[4], n_a[5]);

								// Amat*e=r;
								//doublerealT* error_approx_coarse4 = new doublerealT[n_a[5] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
								{
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] = 0.0;
									}
								}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
								{
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] = (rand() / ((doublerealT)RAND_MAX));
									}
								}


								// pre smothing
								//for (integer i_37 = 1; i_37 <= igam; i_37++)
							{
								doublerealT R0_5 = 0.0;
								doublerealT Rprev_5 = 0.0, Rnext_5 = 0.0;
								if (process_flow_logic) {
									// calculate initial residual.
									//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
									residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);



									R0_5 = norma(residual_fine5, n_a[5]);
									Rprev_5 = R0_5;

									// smother
									integer iter = 0;
									for (iter = 0; iter < nu1; iter++) {
										//quick seidel
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
										else {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}

										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);


										Rnext_5 = norma(residual_fine5, n_a[5]);
										// this is process flow logic
										if (Rnext_5 > process_flow_beta*Rprev_5) {
											// Смысл модификации в том что мы экономим итерации на пресмутере.
											break; // досрочно опускаемся на следующий уровень если он есть конечно.
										}
										else {
											Rprev_5 = Rnext_5;
										}
									}

									if (iter == nu1) {
										printf("level 5 limit presmother iteration is reached\n");
									}

								}
								else {
									for (integer iter = 0; iter < nu1; iter++) {
										//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
										if (bonly_serial) {
											if (bILU2smoother == 1) {
												seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
												residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);

												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													milu0[5].zbuf[i43 + 1] = residual_fine5[i43 + 1];
												}
												lusol_1patchforRUMBA(n_a[5], milu0[5].zbuf, milu0[5].zbuf2, milu0[5]);
												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													error_approx_coarse4[i43 + 1] += (doublerealT)(milu0[5].zbuf2[i43 + 1]);
												}
											}
											else if (1 && bILU2smoother == 2) {
												seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
												residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);

												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													milu2[5].zbuf[i43 + 1] = residual_fine5[i43 + 1];
												}
												lusol_1patchforRUMBA(n_a[5], milu2[5].zbuf, milu2[5].zbuf2, milu2[5]);
												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													error_approx_coarse4[i43 + 1] += (doublerealT)(milu2[5].zbuf2[i43 + 1]);
												}
											}
											else {
												seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
											}
										}
										else {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
									}
								}


								move_down(nu1, nu2);

								if (ilevel > 6) {
									// residual
									if (!process_flow_logic) {
										//doublerealT *residual_fine5 = new doublerealT[n_a[5] + 1];
										//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5], residual_fine5);
										//if (ilevel <= 15) {
										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);

										//}
										//else {
										// приводит к расходимости.
										//speshial 14 september 2015.
										// это уже приводит к увеличению числа итераций на примере сетки в 1млн узлов. остановимся.
										//residualqspeshial(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										//}
									}

									//doublerealT *residual_coarse5 = new doublerealT[n_a[6] + 1];

									// restriction
									restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, residual_fine5, residual_coarse5, n_a[5], n_a[6]);

									// Amat*e=r;
									//doublerealT* error_approx_coarse5 = new doublerealT[n_a[6] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
									{
										for (integer ii = 1; ii <= n_a[6]; ii++) {
											error_approx_coarse5[ii] = 0.0;
										}
									}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
									{
										for (integer ii = 1; ii <= n_a[6]; ii++) {
											error_approx_coarse5[ii] = (rand() / ((doublerealT)RAND_MAX));
										}
									}


									//for (integer i_37 = 1; i_37 <= igam; i_37++) 
									{
										// pre smothing

										doublerealT R0_6 = 0.0;
										doublerealT Rprev_6 = 0.0, Rnext_6 = 0.0;
										if (process_flow_logic) {
											// calculate initial residual.
											//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
											residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);



											R0_6 = norma(residual_fine6, n_a[6]);
											Rprev_6 = R0_6;

											// smother
											integer iter = 0;
											for (iter = 0; iter < nu1; iter++) {
												//quick seidel
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}

												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);


												Rnext_6 = norma(residual_fine6, n_a[6]);
												// this is process flow logic
												if (Rnext_6 > process_flow_beta*Rprev_6) {
													// Смысл модификации в том что мы экономим итерации на пресмутере.
													break; // досрочно опускаемся на следующий уровень если он есть конечно.
												}
												else {
													Rprev_6 = Rnext_6;
												}
											}

											if (iter == nu1) {
												printf("level 6 limit presmother iteration is reached\n");
											}

										}
										else {
											for (integer iter = 0; iter < nu1; iter++) {
												//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
												if (bonly_serial) {
													if (bILU2smoother == 1) {
														seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
														residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);

														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															milu0[6].zbuf[i43 + 1] = residual_fine6[i43 + 1];
														}
														lusol_1patchforRUMBA(n_a[6], milu0[6].zbuf, milu0[6].zbuf2, milu0[6]);
														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															error_approx_coarse5[i43 + 1] += (doublerealT)(milu0[6].zbuf2[i43 + 1]);
														}
													}
													else if (1 && bILU2smoother == 2) {
														seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
														residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);

														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															milu2[6].zbuf[i43 + 1] = residual_fine6[i43 + 1];
														}
														lusol_1patchforRUMBA(n_a[6], milu2[6].zbuf, milu2[6].zbuf2, milu2[6]);
														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															error_approx_coarse5[i43 + 1] += (doublerealT)(milu2[6].zbuf2[i43 + 1]);
														}
													}
													else {
														seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
													}
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
											}
										}


										move_down(nu1, nu2);

										if (ilevel > 7) {
											// residual
											if (!process_flow_logic) {
												//doublerealT *residual_fine6 = new doublerealT[n_a[6] + 1];
												//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] +2*nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6], residual_fine6);
												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);
											}

											//doublerealT *residual_coarse6 = new doublerealT[n_a[7] + 1];

											// restriction
											restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, residual_fine6, residual_coarse6, n_a[6], n_a[7]);

											// Amat*e=r;
											//doublerealT* error_approx_coarse6 = new doublerealT[n_a[7] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
											{
												for (integer ii = 1; ii <= n_a[7]; ii++) {
													error_approx_coarse6[ii] = 0.0;
												}
											}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
											{
												for (integer ii = 1; ii <= n_a[7]; ii++) {
													error_approx_coarse6[ii] = (rand() / ((doublerealT)RAND_MAX));
												}
											}


											//for (integer i_37 = 1; i_37 <= igam; i_37++) 
											{

												// pre smothing


												doublerealT R0_7 = 0.0;
												doublerealT Rprev_7 = 0.0, Rnext_7 = 0.0;
												if (process_flow_logic) {
													// calculate initial residual.
													//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
													residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);



													R0_7 = norma(residual_fine7, n_a[7]);
													Rprev_7 = R0_7;

													// smother
													integer iter = 0;
													for (iter = 0; iter < nu1; iter++) {
														//quick seidel
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}

														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);


														Rnext_7 = norma(residual_fine7, n_a[7]);
														// this is process flow logic
														if (Rnext_7 > process_flow_beta*Rprev_7) {
															// Смысл модификации в том что мы экономим итерации на пресмутере.
															break; // досрочно опускаемся на следующий уровень если он есть конечно.
														}
														else {
															Rprev_7 = Rnext_7;
														}
													}

													if (iter == nu1) {
														printf("level 7 limit presmother iteration is reached\n");
													}

												}
												else {
													for (integer iter = 0; iter < nu1; iter++) {
														if (bonly_serial) {
															if (bILU2smoother == 1) {
																seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
																residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);

																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	milu0[7].zbuf[i43 + 1] = residual_fine7[i43 + 1];
																}
																lusol_1patchforRUMBA(n_a[7], milu0[7].zbuf, milu0[7].zbuf2, milu0[7]);
																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	error_approx_coarse6[i43 + 1] += (doublerealT)(milu0[7].zbuf2[i43 + 1]);
																}

															}
															else if (1 && bILU2smoother == 2) {
																seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
																residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);

																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	milu2[7].zbuf[i43 + 1] = residual_fine7[i43 + 1];
																}
																lusol_1patchforRUMBA(n_a[7], milu2[7].zbuf, milu2[7].zbuf2, milu2[7]);
																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	error_approx_coarse6[i43 + 1] += (doublerealT)(milu2[7].zbuf2[i43 + 1]);
																}

															}
															else {
																seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
															}
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
													}
												}


												move_down(nu1, nu2);

												if (ilevel > 8) {
													// residual
													if (!process_flow_logic) {
														//doublerealT *residual_fine7 = new doublerealT[n_a[7] + 1];
														//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7], residual_fine7);
														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);

													}


													//doublerealT *residual_coarse7 = new doublerealT[n_a[8] + 1];

													// restriction
													restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, residual_fine7, residual_coarse7, n_a[7], n_a[8]);

													// Amat*e=r;
													//doublerealT* error_approx_coarse7 = new doublerealT[n_a[8] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
													{
														for (integer ii = 1; ii <= n_a[8]; ii++) {
															error_approx_coarse7[ii] = 0.0;
														}
													}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
													{
														for (integer ii = 1; ii <= n_a[8]; ii++) {
															error_approx_coarse7[ii] = (rand() / ((doublerealT)RAND_MAX));
														}
													}


													//for (integer i_37 = 1; i_37 <= igam; i_37++)
													{
														// pre smothing
														doublerealT R0_8 = 0.0;
														doublerealT Rprev_8 = 0.0, Rnext_8 = 0.0;
														if (process_flow_logic) {
															// calculate initial residual.
															//residualq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8);
															residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);



															R0_8 = norma(residual_fine8, n_a[8]);
															Rprev_8 = R0_8;

															// smother
															integer iter = 0;
															for (iter = 0; iter < nu1; iter++) {
																//quick seidel
																if (bonly_serial) {
																	seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																}
																else {
																	seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, nested_desection8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																}

																//residualq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7], residual_fine8);
																residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);


																Rnext_8 = norma(residual_fine8, n_a[8]);
																// this is process flow logic
																if (Rnext_8 > process_flow_beta*Rprev_8) {
																	// Смысл модификации в том что мы экономим итерации на пресмутере.
																	break; // досрочно опускаемся на следующий уровень если он есть конечно.
																}
																else {
																	Rprev_8 = Rnext_8;
																}
															}

															if (iter == nu1) {
																printf("level 8 limit presmother iteration is reached\n");
															}

														}
														else {
															for (integer iter = 0; iter < nu1; iter++) {
																if (bonly_serial) {
																	if (bILU2smoother == 1) {
																		seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																		residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);

																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			milu0[8].zbuf[i43 + 1] = residual_fine8[i43 + 1];
																		}
																		lusol_1patchforRUMBA(n_a[8], milu0[8].zbuf, milu0[8].zbuf2, milu0[8]);
																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			error_approx_coarse7[i43 + 1] += (doublerealT)(milu0[8].zbuf2[i43 + 1]);
																		}

																	}
																	else if (1 && bILU2smoother == 2) {
																		seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																		residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);

																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			milu2[8].zbuf[i43 + 1] = residual_fine8[i43 + 1];
																		}
																		lusol_1patchforRUMBA(n_a[8], milu2[8].zbuf, milu2[8].zbuf2, milu2[8]);
																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			error_approx_coarse7[i43 + 1] += (doublerealT)(milu2[8].zbuf2[i43 + 1]);
																		}

																	}
																	else {
																		seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																	}
																}
																else {
																	seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, nested_desection8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																}
															}
														}


														move_down(nu1, nu2);


														if (ilevel > 9) {
															// residual
															if (!process_flow_logic) {
																//doublerealT *residual_fine8 = new doublerealT[n_a[8] + 1];
																//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8], residual_fine8);
																//residualq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8);
																residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);
															}


															//doublerealT *residual_coarse8 = new doublerealT[n_a[9] + 1];

															// restriction
															restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8], flag, residual_fine8, residual_coarse8, n_a[8], n_a[9]);


															// Amat*e=r;
															//doublerealT* error_approx_coarse8 = new doublerealT[n_a[9] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
															{
																for (integer ii = 1; ii <= n_a[9]; ii++) {
																	error_approx_coarse8[ii] = 0.0;
																}
															}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
															{
																for (integer ii = 1; ii <= n_a[9]; ii++) {
																	error_approx_coarse8[ii] = (rand() / ((doublerealT)RAND_MAX));
																}
															}


															//for (integer i_37 = 1; i_37 <= igam; i_37++) 
															{
																// pre smothing
																doublerealT R0_9 = 0.0;
																doublerealT Rprev_9 = 0.0, Rnext_9 = 0.0;
																if (process_flow_logic) {
																	// calculate initial residual.
																	//residualq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8], residual_fine9);
																	residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);



																	R0_9 = norma(residual_fine9, n_a[9]);
																	Rprev_9 = R0_9;

																	// smother
																	integer iter = 0;
																	for (iter = 0; iter < nu1; iter++) {
																		//quick seidel
																		if (bonly_serial) {
																			seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																		}
																		else {
																			seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, nested_desection9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																		}

																		//residualq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8], residual_fine9);
																		residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);


																		Rnext_9 = norma(residual_fine9, n_a[9]);
																		// this is process flow logic
																		if (Rnext_9 > process_flow_beta*Rprev_9) {
																			// Смысл модификации в том что мы экономим итерации на пресмутере.
																			break; // досрочно опускаемся на следующий уровень если он есть конечно.
																		}
																		else {
																			Rprev_9 = Rnext_9;
																		}
																	}

																	if (iter == nu1) {
																		printf("level 9 limit presmother iteration is reached\n");
																	}

																}
																else {
																	for (integer iter = 0; iter < nu1; iter++) {
																		if (bonly_serial) {
																			if (bILU2smoother == 1) {
																				seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																				residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);

																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					milu0[9].zbuf[i43 + 1] = residual_fine9[i43 + 1];
																				}
																				lusol_1patchforRUMBA(n_a[9], milu0[9].zbuf, milu0[9].zbuf2, milu0[9]);
																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					error_approx_coarse8[i43 + 1] += (doublerealT)(milu0[9].zbuf2[i43 + 1]);
																				}

																			}
																			else if (1 && bILU2smoother == 2) {
																				seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																				residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);

																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					milu2[9].zbuf[i43 + 1] = residual_fine9[i43 + 1];
																				}
																				lusol_1patchforRUMBA(n_a[9], milu2[9].zbuf, milu2[9].zbuf2, milu2[9]);
																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					error_approx_coarse8[i43 + 1] += (doublerealT)(milu2[9].zbuf2[i43 + 1]);
																				}

																			}
																			else {
																				seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																			}
																		}
																		else {
																			seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, nested_desection9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																		}
																	}
																}


																// точное решение на подробном уровне лишь замедляет время счёта и нисколько не
																// улучшает сходимость.



																move_down(nu1, nu2);

																if (ilevel > 10) {
																	// 8 сентября 2015 РИМИНИ пляж 

																	// residual
																	if (!process_flow_logic) {
																		//doublerealT *residual_fine9 = new doublerealT[n_a[9] + 1];
																		//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9], error_approx_coarse8, residual_coarse8, flag, n_a[9], residual_fine9);
																		//residualq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8], residual_fine9);
																		residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);
																	}

																	//doublerealT *residual_coarse9 = new doublerealT[n_a[10] + 1];

																	// restriction
																	restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9], flag, residual_fine9, residual_coarse9, n_a[9], n_a[10]);



																	// Amat*e=r;
																	//doublerealT* error_approx_coarse9 = new doublerealT[n_a[10] + 1];


if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																	{
																		for (integer ii = 1; ii <= n_a[10]; ii++) {
																			error_approx_coarse9[ii] = 0.0;
																		}
																	}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																	{
																		for (integer ii = 1; ii <= n_a[10]; ii++) {
																			error_approx_coarse9[ii] = (rand() / ((doublerealT)RAND_MAX));
																		}
																	}


																	//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																	{
																		// pre smothing
																		doublerealT R0_10 = 0.0;
																		doublerealT Rprev_10 = 0.0, Rnext_10 = 0.0;
																		if (process_flow_logic) {
																			// calculate initial residual.
																			//residualq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9], residual_fine10);
																			residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);



																			R0_10 = norma(residual_fine10, n_a[10]);
																			Rprev_10 = R0_10;

																			// smother
																			integer iter = 0;
																			for (iter = 0; iter < nu1; iter++) {
																				//quick seidel
																				if (bonly_serial) {
																					seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																				}
																				else {
																					seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, nested_desection10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																				}

																				//residualq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9], residual_fine10);
																				residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);


																				Rnext_10 = norma(residual_fine10, n_a[10]);
																				// this is process flow logic
																				if (Rnext_10 > process_flow_beta*Rprev_10) {
																					// Смысл модификации в том что мы экономим итерации на пресмутере.
																					break; // досрочно опускаемся на следующий уровень если он есть конечно.
																				}
																				else {
																					Rprev_10 = Rnext_10;
																				}
																			}

																			if (iter == nu1) {
																				printf("level 10 limit presmother iteration is reached\n");
																			}

																		}
																		else {
																			for (integer iter = 0; iter < nu1; iter++) {
																				if (bonly_serial) {
																					if (bILU2smoother == 1) {
																						seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																						residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);

																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							milu0[10].zbuf[i43 + 1] = residual_fine10[i43 + 1];
																						}
																						lusol_1patchforRUMBA(n_a[10], milu0[10].zbuf, milu0[10].zbuf2, milu0[10]);
																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							error_approx_coarse9[i43 + 1] += (doublerealT)(milu0[10].zbuf2[i43 + 1]);
																						}

																					}
																					else if (1 && bILU2smoother == 2) {
																						seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																						residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);

																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							milu2[10].zbuf[i43 + 1] = residual_fine10[i43 + 1];
																						}
																						lusol_1patchforRUMBA(n_a[10], milu2[10].zbuf, milu2[10].zbuf2, milu2[10]);
																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							error_approx_coarse9[i43 + 1] += (doublerealT)(milu2[10].zbuf2[i43 + 1]);
																						}

																					}
																					else {
																						seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																					}
																				}
																				else {
																					seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, nested_desection10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																				}
																			}
																		}

																		// до 11 уровня вроде всё верно 3 января 2016

																		move_down(nu1, nu2);

																		if (ilevel > 11) {
																			// 8 сентября 2015 РИМИНИ пляж 

																			// residual
																			if (!process_flow_logic) {
																				//doublerealT *residual_fine10 = new doublerealT[n_a[10] + 1];
																				//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10], error_approx_coarse9, residual_coarse9, flag, n_a[10], residual_fine10);
																				//residualq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9], residual_fine10);
																				residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);
																			}

																			//doublerealT *residual_coarse10 = new doublerealT[n_a[11] + 1];

																			// restriction
																			restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10], flag, residual_fine10, residual_coarse10, n_a[10], n_a[11]);


																			
																			// Amat*e=r;
																			//doublerealT* error_approx_coarse10 = new doublerealT[n_a[11] + 1];


if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																			{
																				for (integer ii = 1; ii <= n_a[11]; ii++) {
																					error_approx_coarse10[ii] = 0.0;
																				}
																			}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																			{
																				for (integer ii = 1; ii <= n_a[11]; ii++) {
																					error_approx_coarse10[ii] = (rand() / ((doublerealT)RAND_MAX));
																				}
																			}


																			//for (integer i_37 = 1; i_37 <= igam; i_37++)
																			{
																				// pre smothing
																				doublerealT R0_11 = 0.0;
																				doublerealT Rprev_11 = 0.0, Rnext_11 = 0.0;
																				if (process_flow_logic) {
																					// calculate initial residual.
																					//residualq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10], residual_fine11);
																					residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);



																					R0_11 = norma(residual_fine11, n_a[11]);
																					Rprev_11 = R0_11;

																					// smother
																					integer iter = 0;
																					for (iter = 0; iter < nu1; iter++) {
																						//quick seidel
																						if (bonly_serial) {
																							seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																						}
																						else {
																							seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, nested_desection11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																						}

																						//residualq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9]+ n_a[10], residual_fine11);
																						residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);


																						Rnext_11 = norma(residual_fine11, n_a[11]);
																						// this is process flow logic
																						if (Rnext_11 > process_flow_beta*Rprev_11) {
																							// Смысл модификации в том что мы экономим итерации на пресмутере.
																							break; // досрочно опускаемся на следующий уровень если он есть конечно.
																						}
																						else {
																							Rprev_11 = Rnext_11;
																						}
																					}

																					if (iter == nu1) {
																						printf("level 11 limit presmother iteration is reached\n");
																					}

																				}
																				else {
																					for (integer iter = 0; iter < nu1; iter++) {
																						if (bonly_serial) {
																							if (bILU2smoother == 1) {
																								seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																								residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);

																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									milu0[11].zbuf[i43 + 1] = residual_fine11[i43 + 1];
																								}
																								lusol_1patchforRUMBA(n_a[11], milu0[11].zbuf, milu0[11].zbuf2, milu0[11]);
																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									error_approx_coarse10[i43 + 1] += (doublerealT)(milu0[11].zbuf2[i43 + 1]);
																								}

																							}
																							else if (1 && bILU2smoother == 2) {
																								seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																								residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);

																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									milu2[11].zbuf[i43 + 1] = residual_fine11[i43 + 1];
																								}
																								lusol_1patchforRUMBA(n_a[11], milu2[11].zbuf, milu2[11].zbuf2, milu2[11]);
																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									error_approx_coarse10[i43 + 1] += (doublerealT)(milu2[11].zbuf2[i43 + 1]);
																								}

																							}
																							else {
																								seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																							}
																						}
																						else {
																							seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, nested_desection11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																						}
																					}
																				}

																				move_down(nu1, nu2);

																				if (ilevel > 12) {
																					// 11 сентября 2015 РИМИНИ пляж 

																					// residual
																					if (!process_flow_logic) {
																						//doublerealT *residual_fine11 = new doublerealT[n_a[11] + 1];
																						//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11], error_approx_coarse10, residual_coarse10, flag, n_a[11], residual_fine11);
																						//residualq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10], residual_fine11);
																						residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);
																					}

																					//doublerealT *residual_coarse11 = new doublerealT[n_a[12] + 1];

																					// restriction
																					restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11], flag, residual_fine11, residual_coarse11, n_a[11], n_a[12]);



																					// Amat*e=r;
																					//doublerealT* error_approx_coarse11 = new doublerealT[n_a[12] + 1];

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																					{
																						for (integer ii = 1; ii <= n_a[12]; ii++) {
																							error_approx_coarse11[ii] = 0.0;
																						}
																					}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																					{
																						for (integer ii = 1; ii <= n_a[12]; ii++) {
																							error_approx_coarse11[ii] = (rand() / ((doublerealT)RAND_MAX));
																						}
																					}


																					//for (integer i_37 = 1; i_37 <= igam; i_37++)
																					{
																						// pre smothing
																						doublerealT R0_12 = 0.0;
																						doublerealT Rprev_12 = 0.0, Rnext_12 = 0.0;
																						if (process_flow_logic) {
																							// calculate initial residual.
																							//residualq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11], residual_fine12);
																							residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);



																							R0_12 = norma(residual_fine12, n_a[12]);
																							Rprev_12 = R0_12;

																							// smother
																							integer iter = 0;
																							for (iter = 0; iter < nu1; iter++) {
																								//quick seidel
																								if (bonly_serial) {
																									seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																								}
																								else {
																									seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, nested_desection12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																								}

																								//residualq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12);
																								residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);


																								Rnext_12 = norma(residual_fine12, n_a[12]);
																								// this is process flow logic
																								if (Rnext_12 > process_flow_beta*Rprev_12) {
																									// Смысл модификации в том что мы экономим итерации на пресмутере.
																									break; // досрочно опускаемся на следующий уровень если он есть конечно.
																								}
																								else {
																									Rprev_12 = Rnext_12;
																								}
																							}

																							if (iter == nu1) {
																								printf("level 12 limit presmother iteration is reached\n");
																							}

																						}
																						else {
																							for (integer iter = 0; iter < nu1; iter++) {
																								if (bonly_serial) {
																									if (bILU2smoother == 1) {
																										seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																										residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);

																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											milu0[12].zbuf[i43 + 1] = residual_fine12[i43 + 1];
																										}
																										lusol_1patchforRUMBA(n_a[12], milu0[12].zbuf, milu0[12].zbuf2, milu0[12]);
																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											error_approx_coarse11[i43 + 1] += (doublerealT)(milu0[12].zbuf2[i43 + 1]);
																										}

																									}
																									else if (1 && bILU2smoother == 2) {
																										seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																										residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);

																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											milu2[12].zbuf[i43 + 1] = residual_fine12[i43 + 1];
																										}
																										lusol_1patchforRUMBA(n_a[12], milu2[12].zbuf, milu2[12].zbuf2, milu2[12]);
																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											error_approx_coarse11[i43 + 1] += (doublerealT)(milu2[12].zbuf2[i43 + 1]);
																										}

																									}
																									else {
																										seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																									}
																								}
																								else {
																									seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, nested_desection12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																								}
																							}
																						}

																						move_down(nu1, nu2);

																						if (ilevel > 13) {
																							// 11 сентября 2015 РИМИНИ пляж 

																							// residual
																							if (!process_flow_logic) {
																								//doublerealT *residual_fine12 = new doublerealT[n_a[12] + 1];
																								//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12], error_approx_coarse11, residual_coarse11, flag, n_a[12], residual_fine12);
																								//residualq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11], residual_fine12);
																								residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);
																							}

																							//doublerealT *residual_coarse12 = new doublerealT[n_a[13] + 1];

																							// restriction
																							restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12], flag, residual_fine12, residual_coarse12, n_a[12], n_a[13]);



																							// Amat*e=r;
																							//doublerealT* error_approx_coarse12 = new doublerealT[n_a[13] + 1];

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																							{
																								for (integer ii = 1; ii <= n_a[13]; ii++) {
																									error_approx_coarse12[ii] = 0.0;
																								}
																							}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																							{
																								for (integer ii = 1; ii <= n_a[13]; ii++) {
																									error_approx_coarse12[ii] = (rand() / ((doublerealT)RAND_MAX));
																								}
																							}


																							//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																							{
																								// pre smothing
																								doublerealT R0_13 = 0.0;
																								doublerealT Rprev_13 = 0.0, Rnext_13 = 0.0;
																								if (process_flow_logic) {
																									// calculate initial residual.
																									//residualq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12], residual_fine13);
																									residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);



																									R0_13 = norma(residual_fine13, n_a[13]);
																									Rprev_13 = R0_13;

																									// smother
																									integer iter = 0;
																									for (iter = 0; iter < nu1; iter++) {
																										//quick seidel
																										if (bonly_serial) {
																											seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																										}
																										else {
																											seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, nested_desection13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																										}

																										//residualq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13);
																										residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);


																										Rnext_13 = norma(residual_fine13, n_a[13]);
																										// this is process flow logic
																										if (Rnext_13 > process_flow_beta*Rprev_13) {
																											// Смысл модификации в том что мы экономим итерации на пресмутере.
																											break; // досрочно опускаемся на следующий уровень если он есть конечно.
																										}
																										else {
																											Rprev_13 = Rnext_13;
																										}
																									}

																									if (iter == nu1) {
																										printf("level 13 limit presmother iteration is reached\n");
																									}

																								}
																								else {
																									for (integer iter = 0; iter < nu1; iter++) {
																										if (bonly_serial) {
																											if (bILU2smoother == 1) {
																												seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																												residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);

																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													milu0[13].zbuf[i43 + 1] = residual_fine13[i43 + 1];
																												}
																												lusol_1patchforRUMBA(n_a[13], milu0[13].zbuf, milu0[13].zbuf2, milu0[13]);
																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													error_approx_coarse12[i43 + 1] += (doublerealT)(milu0[13].zbuf2[i43 + 1]);
																												}

																											}
																											else if (1 && bILU2smoother == 2) {
																												seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																												residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);

																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													milu2[13].zbuf[i43 + 1] = residual_fine13[i43 + 1];
																												}
																												lusol_1patchforRUMBA(n_a[13], milu2[13].zbuf, milu2[13].zbuf2, milu2[13]);
																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													error_approx_coarse12[i43 + 1] += (doublerealT)(milu2[13].zbuf2[i43 + 1]);
																												}

																											}
																											else {
																												seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																											}
																										}
																										else {
																											seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, nested_desection13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																										}
																									}
																								}


																								move_down(nu1, nu2);

																								if (ilevel > 14) {
																									// 11 сентября 2015 РИМИНИ пляж 

																									// residual
																									if (!process_flow_logic) {
																										//doublerealT *residual_fine13 = new doublerealT[n_a[13] + 1];
																										//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13], error_approx_coarse12, residual_coarse12, flag, n_a[13], residual_fine13);
																										//residualq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12], residual_fine13);
																										residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);
																									}

																									//doublerealT *residual_coarse13 = new doublerealT[n_a[14] + 1];

																									// restriction
																									restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13], flag, residual_fine13, residual_coarse13, n_a[13], n_a[14]);


																									// Amat*e=r;
																									//doublerealT* error_approx_coarse13 = new doublerealT[n_a[14] + 1];

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																									{
																										for (integer ii = 1; ii <= n_a[14]; ii++) {
																											error_approx_coarse13[ii] = 0.0;
																										}
																									}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																									{
																										for (integer ii = 1; ii <= n_a[14]; ii++) {
																											error_approx_coarse13[ii] = (rand() / ((doublerealT)RAND_MAX));
																										}
																									}



																									//for (integer i_37 = 1; i_37 <= igam; i_37++)
																									{
																										// pre smothing
																										doublerealT R0_14 = 0.0;
																										doublerealT Rprev_14 = 0.0, Rnext_14 = 0.0;
																										if (process_flow_logic) {
																											// calculate initial residual.
																											//residualq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13], residual_fine14);
																											residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);



																											R0_14 = norma(residual_fine14, n_a[14]);
																											Rprev_14 = R0_14;

																											// smother
																											integer iter = 0;
																											for (iter = 0; iter < nu1; iter++) {
																												//quick seidel
																												if (bonly_serial) {
																													seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																												}
																												else {
																													seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, nested_desection14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																												}

																												//residualq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]+ n_a[13], residual_fine14);
																												residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);


																												Rnext_14 = norma(residual_fine14, n_a[14]);
																												// this is process flow logic
																												if (Rnext_14 > process_flow_beta*Rprev_14) {
																													// Смысл модификации в том что мы экономим итерации на пресмутере.
																													break; // досрочно опускаемся на следующий уровень если он есть конечно.
																												}
																												else {
																													Rprev_14 = Rnext_14;
																												}
																											}

																											if (iter == nu1) {
																												printf("level 14 limit presmother iteration is reached\n");
																											}

																										}
																										else {
																											for (integer iter = 0; iter < nu1; iter++) {
																												if (bonly_serial) {
																													if (bILU2smoother == 1) {
																														seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																														residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);

																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															milu0[14].zbuf[i43 + 1] = residual_fine14[i43 + 1];
																														}
																														lusol_1patchforRUMBA(n_a[14], milu0[14].zbuf, milu0[14].zbuf2, milu0[14]);
																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															error_approx_coarse13[i43 + 1] += (doublerealT)(milu0[14].zbuf2[i43 + 1]);
																														}

																													}
																													else if (1 && bILU2smoother == 2) {
																														seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																														residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);

																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															milu2[14].zbuf[i43 + 1] = residual_fine14[i43 + 1];
																														}
																														lusol_1patchforRUMBA(n_a[14], milu2[14].zbuf, milu2[14].zbuf2, milu2[14]);
																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															error_approx_coarse13[i43 + 1] += (doublerealT)(milu2[14].zbuf2[i43 + 1]);
																														}

																													}
																													else {
																														seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																													}
																												}
																												else {
																													seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, nested_desection14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																												}
																											}
																										}


																										move_down(nu1, nu2);

																										if (ilevel > 15) {
																											// 14 сентября 2015 Москва на работе в пн. 

																											// residual
																											if (!process_flow_logic) {
																												//doublerealT *residual_fine14 = new doublerealT[n_a[14] + 1];
																												//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14], error_approx_coarse13, residual_coarse13, flag, n_a[14], residual_fine14);
																												//residualq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13], residual_fine14);
																												residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);
																											}

																											//doublerealT *residual_coarse14 = new doublerealT[n_a[15] + 1];

																											// restriction
																											restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14], flag, residual_fine14, residual_coarse14, n_a[14], n_a[15]);

																											// Amat*e=r;
																											//doublerealT* error_approx_coarse14 = new doublerealT[n_a[15] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																											{
																												for (integer ii = 1; ii <= n_a[15]; ii++) {
																													error_approx_coarse14[ii] = 0.0;
																												}
																											}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																											{
																												for (integer ii = 1; ii <= n_a[15]; ii++) {
																													error_approx_coarse14[ii] = (rand() / ((doublerealT)RAND_MAX));
																												}
																											}


																											//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																											{
																												// pre smothing
																												doublerealT R0_15 = 0.0;
																												doublerealT Rprev_15 = 0.0, Rnext_15 = 0.0;
																												if (process_flow_logic) {
																													// calculate initial residual.
																													//residualq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14], residual_fine15);
																													residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);



																													R0_15 = norma(residual_fine15, n_a[15]);
																													Rprev_15 = R0_15;

																													// smother
																													integer iter = 0;
																													for (iter = 0; iter < nu1; iter++) {
																														//quick seidel
																														if (bonly_serial) {
																															seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																														}
																														else {
																															seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, nested_desection15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																														}

																														//residualq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]+ n_a[13]+ n_a[14], residual_fine15);
																														residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);


																														Rnext_15 = norma(residual_fine15, n_a[15]);
																														// this is process flow logic
																														if (Rnext_15 > process_flow_beta*Rprev_15) {
																															// Смысл модификации в том что мы экономим итерации на пресмутере.
																															break; // досрочно опускаемся на следующий уровень если он есть конечно.
																														}
																														else {
																															Rprev_15 = Rnext_15;
																														}
																													}

																													if (iter == nu1) {
																														printf("level 15 limit presmother iteration is reached\n");
																													}

																												}
																												else {
																													for (integer iter = 0; iter < nu1; iter++) {
																														if (bonly_serial) {
																															if (bILU2smoother == 1) {
																																seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																																residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);

																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	milu0[15].zbuf[i43 + 1] = residual_fine15[i43 + 1];
																																}
																																lusol_1patchforRUMBA(n_a[15], milu0[15].zbuf, milu0[15].zbuf2, milu0[15]);
																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	error_approx_coarse15[i43 + 1] += (doublerealT)(milu0[15].zbuf2[i43 + 1]);
																																}

																															}
																															else if (1 && bILU2smoother == 2) {
																																seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																																residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);

																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	milu2[15].zbuf[i43 + 1] = residual_fine15[i43 + 1];
																																}
																																lusol_1patchforRUMBA(n_a[15], milu2[15].zbuf, milu2[15].zbuf2, milu2[15]);
																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	error_approx_coarse14[i43 + 1] += (doublerealT)(milu2[15].zbuf2[i43 + 1]);
																																}

																															}
																															else {
																																seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																															}
																														}
																														else {
																															seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, nested_desection15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																														}
																													}
																												}


																												move_down(nu1, nu2);

																												if (ilevel > 16) {
																													// 10 октября 2015. 

																													// residual
																													if (!process_flow_logic) {
																														//doublerealT *residual_fine15 = new doublerealT[n_a[15] + 1];
																														//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15], error_approx_coarse14, residual_coarse14, flag, n_a[15], residual_fine15);
																														//residualq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14], residual_fine15);
																														residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);
																													}

																													//doublerealT *residual_coarse15 = new doublerealT[n_a[16] + 1];

																													// restriction
																													restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15], flag, residual_fine15, residual_coarse15, n_a[15], n_a[16]);

																													
																													// Amat*e=r;
																													//doublerealT* error_approx_coarse15 = new doublerealT[n_a[16] + 1];

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																													{
																														for (integer ii = 1; ii <= n_a[16]; ii++) {
																															error_approx_coarse15[ii] = 0.0;
																														}
																													}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																													{
																														for (integer ii = 1; ii <= n_a[16]; ii++) {
																															error_approx_coarse15[ii] = (rand() / ((doublerealT)RAND_MAX));
																														}
																													}


																													//for (integer i_37 = 1; i_37 <= igam; i_37++)
																													{
																														// pre smothing
																														doublerealT R0_16 = 0.0;
																														doublerealT Rprev_16 = 0.0, Rnext_16 = 0.0;
																														if (process_flow_logic) {
																															// calculate initial residual.
																															//residualq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15], residual_fine16);
																															residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);



																															R0_16 = norma(residual_fine16, n_a[16]);
																															Rprev_16 = R0_16;

																															// smother
																															integer iter = 0;
																															for (iter = 0; iter < nu1; iter++) {
																																//quick seidel
																																if (bonly_serial) {
																																	seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																}
																																else {
																																	seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, nested_desection16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																}

																																//residualq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]+ n_a[13]+ n_a[14]+ n_a[15], residual_fine16);
																																residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);


																																Rnext_16 = norma(residual_fine16, n_a[16]);
																																// this is process flow logic
																																if (Rnext_16 > process_flow_beta*Rprev_16) {
																																	// Смысл модификации в том что мы экономим итерации на пресмутере.
																																	break; // досрочно опускаемся на следующий уровень если он есть конечно.
																																}
																																else {
																																	Rprev_16 = Rnext_16;
																																}
																															}

																															if (iter == nu1) {
																																printf("level 16 limit presmother iteration is reached\n");
																															}

																														}
																														else {
																															for (integer iter = 0; iter < nu1; iter++) {
																																if (bonly_serial) {
																																	if (bILU2smoother == 1) {
																																		seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																		residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);

																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			milu0[16].zbuf[i43 + 1] = residual_fine16[i43 + 1];
																																		}
																																		lusol_1patchforRUMBA(n_a[16], milu0[16].zbuf, milu0[16].zbuf2, milu0[16]);
																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			error_approx_coarse16[i43 + 1] += (doublerealT)(milu0[16].zbuf2[i43 + 1]);
																																		}

																																	}
																																	else if (1 && bILU2smoother == 2) {
																																		seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																		residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);

																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			milu2[16].zbuf[i43 + 1] = residual_fine16[i43 + 1];
																																		}
																																		lusol_1patchforRUMBA(n_a[16], milu2[16].zbuf, milu2[16].zbuf2, milu2[16]);
																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			error_approx_coarse15[i43 + 1] += (doublerealT)(milu2[16].zbuf2[i43 + 1]);
																																		}

																																	}
																																	else {
																																		seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																	}
																																}
																																else {
																																	seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, nested_desection16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																}
																															}
																														}


																														move_down(nu1, nu2);

																														if (ilevel > 17) {
																															// 10 октября 2015. 

																															// residual
																															if (!process_flow_logic) {
																																//doublerealT *residual_fine16 = new doublerealT[n_a[16] + 1];
																																//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15]+ nnz_a[16], error_approx_coarse15, residual_coarse15, flag, n_a[16], residual_fine16);
																																//residualq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15], residual_fine16);
																																residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);
																															}

																															
																															//doublerealT *residual_coarse16 = new doublerealT[n_a[17] + 1];

																															// restriction
																															restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16], flag, residual_fine16, residual_coarse16, n_a[16], n_a[17]);

																																																														
																															// Amat*e=r;
																															//doublerealT* error_approx_coarse16 = new doublerealT[n_a[17] + 1];
if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																															{
																																for (integer ii = 1; ii <= n_a[17]; ii++) {
																																	error_approx_coarse16[ii] = 0.0;
																																}
																															}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																															{
																																for (integer ii = 1; ii <= n_a[17]; ii++) {
																																	error_approx_coarse16[ii] = (rand() / ((doublerealT)RAND_MAX));
																																}
																															}



																															//for (integer i_37 = 1; i_37 <= igam; i_37++)
																															{
																																// pre smothing
																																doublerealT R0_17 = 0.0;
																																doublerealT Rprev_17 = 0.0, Rnext_17 = 0.0;
																																if (process_flow_logic) {
																																	// calculate initial residual.
																																	//residualq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16], residual_fine17);
																																	residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);



																																	R0_17 = norma(residual_fine17, n_a[17]);
																																	Rprev_17 = R0_17;

																																	// smother
																																	integer iter = 0;
																																	for (iter = 0; iter < nu1; iter++) {
																																		//quick seidel
																																		if (bonly_serial) {
																																			seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																		}
																																		else {
																																			seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, nested_desection17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																		}

																																		//residualq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16], residual_fine17);
																																		residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);


																																		Rnext_17 = norma(residual_fine17, n_a[17]);
																																		// this is process flow logic
																																		if (Rnext_17 > process_flow_beta*Rprev_17) {
																																			// Смысл модификации в том что мы экономим итерации на пресмутере.
																																			break; // досрочно опускаемся на следующий уровень если он есть конечно.
																																		}
																																		else {
																																			Rprev_17 = Rnext_17;
																																		}
																																	}

																																	if (iter == nu1) {
																																		printf("level 17 limit presmother iteration is reached\n");
																																	}

																																}
																																else {
																																	for (integer iter = 0; iter < nu1; iter++) {
																																		if (bonly_serial) {
																																			if (bILU2smoother == 1) {
																																				seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																				residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);

																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					milu0[17].zbuf[i43 + 1] = residual_fine17[i43 + 1];
																																				}
																																				lusol_1patchforRUMBA(n_a[17], milu0[17].zbuf, milu0[17].zbuf2, milu0[17]);
																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					error_approx_coarse17[i43 + 1] += (doublerealT)(milu0[17].zbuf2[i43 + 1]);
																																				}

																																			}
																																			else if (1 && bILU2smoother == 2) {
																																				seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																				residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);

																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					milu2[17].zbuf[i43 + 1] = residual_fine17[i43 + 1];
																																				}
																																				lusol_1patchforRUMBA(n_a[17], milu2[17].zbuf, milu2[17].zbuf2, milu2[17]);
																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					error_approx_coarse16[i43 + 1] += (doublerealT)(milu2[17].zbuf2[i43 + 1]);
																																				}

																																			}
																																			else {
																																				seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																			}
																																		}
																																		else {
																																			seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, nested_desection17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																		}
																																	}
																																}

																																move_down(nu1, nu2);


																																if (ilevel > 18) {
																																	// 5 декабря 2015. 

																																	// residual
																																	if (!process_flow_logic) {
																																		//doublerealT *residual_fine17 = new doublerealT[n_a[17] + 1];
																																		//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15]+ nnz_a[16], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15]+ nnz_a[16]+ nnz_a[17], error_approx_coarse16, residual_coarse16, flag, n_a[17], residual_fine17);
																																		//residualq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16], residual_fine17);
																																		residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);
																																	}

																																	//doublerealT *residual_coarse17 = new doublerealT[n_a[18] + 1];

																																	// restriction
																																	restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17], flag, residual_fine17, residual_coarse17, n_a[17], n_a[18]);


																																	// Amat*e=r;
																																	//doublerealT* error_approx_coarse17 = new doublerealT[n_a[18] + 1];

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::ZERO_INIT)
																																	{
																																		for (integer ii = 1; ii <= n_a[18]; ii++) {
																																			error_approx_coarse17[ii] = 0.0;
																																		}
																																	}

if (imyinit == INIT_SELECTOR_CASE_CAMG_RUMBAv_0_14::RANDOM_INIT)
																																	{
																																		for (integer ii = 1; ii <= n_a[18]; ii++) {
																																			error_approx_coarse17[ii] = (rand() / ((doublerealT)RAND_MAX));
																																		}
																																	}



																																	//for (integer i_37 = 1; i_37 <= igam; i_37++)
																																	{
																																		// pre smothing
																																		doublerealT R0_18 = 0.0;
																																		doublerealT Rprev_18 = 0.0, Rnext_18 = 0.0;
																																		if (process_flow_logic) {
																																			// calculate initial residual.
																																			//residualq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16]+ n_a[17], residual_fine18);
																																			residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);



																																			R0_18 = norma(residual_fine18, n_a[18]);
																																			Rprev_18 = R0_18;

																																			// smother
																																			integer iter = 0;
																																			for (iter = 0; iter < nu1; iter++) {
																																				//quick seidel
																																				if (bonly_serial) {
																																					seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																				}
																																				else {
																																					seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, nested_desection18, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																				}

																																				//residualq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16]+ n_a[17], residual_fine18);
																																				residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);


																																				Rnext_18 = norma(residual_fine18, n_a[18]);
																																				// this is process flow logic
																																				if (Rnext_18 > process_flow_beta*Rprev_18) {
																																					// Смысл модификации в том что мы экономим итерации на пресмутере.
																																					break; // досрочно опускаемся на следующий уровень если он есть конечно.
																																				}
																																				else {
																																					Rprev_18 = Rnext_18;
																																				}
																																			}

																																			if (iter == nu1) {
																																				printf("level 18 limit presmother iteration is reached\n");
																																			}

																																		}
																																		else {
																																			for (integer iter = 0; iter < nu1; iter++) {
																																				if (bonly_serial) {
																																					if (bILU2smoother == 1) {
																																						seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																						residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);

																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							milu0[18].zbuf[i43 + 1] = residual_fine18[i43 + 1];
																																						}
																																						lusol_1patchforRUMBA(n_a[18], milu0[18].zbuf, milu0[18].zbuf2, milu0[18]);
																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							error_approx_coarse18[i43 + 1] += (doublerealT)(milu0[18].zbuf2[i43 + 1]);
																																						}

																																					}
																																					else if (1 && bILU2smoother == 2) {
																																						seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																						residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);

																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							milu2[18].zbuf[i43 + 1] = residual_fine18[i43 + 1];
																																						}
																																						lusol_1patchforRUMBA(n_a[18], milu2[18].zbuf, milu2[18].zbuf2, milu2[18]);
																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							error_approx_coarse17[i43 + 1] += (doublerealT)(milu2[18].zbuf2[i43 + 1]);
																																						}

																																					}
																																					else {
																																						seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																					}
																																				}
																																				else {
																																					seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, nested_desection18, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																				}
																																			}
																																		}

																																		// ЭТО сердцевина SOLUTION PHASE.

																																		// post smothing
																																		// doublerealT R0_18 = 0.0;
																																		///doublerealT Rprev_18 = 0.0, Rnext_18 = 0.0;
																																		if (process_flow_logic) {
																																			// calculate initial residual.
																																			//residualq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16]+ n_a[17], residual_fine18);



																																			//Rprev_18 = norma(residual_fine18, n_a[18]);


																																			// smother
																																			integer iter = 0;
																																			for (iter = 0; iter < nu2; iter++) {
																																				//quick seidel
																																				if (bonly_serial) {
																																					seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																				}
																																				else {
																																					seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, nested_desection18, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																				}

																																				//residualq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16]+ n_a[17], residual_fine18);
																																				residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);


																																				Rnext_18 = norma(residual_fine18, n_a[18]);
																																				// this is process flow logic
																																				if (Rnext_18 < process_flow_alpha*R0_18) {
																																					// Смысл модификации в том что мы экономим итерации на пресмутере.
																																					break; // досрочно опускаемся на следующий уровень если он есть конечно.
																																				}
																																				else {
																																					Rprev_18 = Rnext_18;
																																				}
																																			}

																																			if (iter == nu2) {
																																				printf("level 18 limit postsmother iteration is reached\n");
																																			}

																																		}
																																		else {
																																			for (integer iter = 0; iter < nu2; iter++) {
																																				if (bonly_serial) {


																																					if (bILU2smoother == 1) {
																																						seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																						residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);

																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							milu0[18].zbuf[i43 + 1] = residual_fine18[i43 + 1];
																																						}
																																						lusol_1patchforRUMBA(n_a[18], milu0[18].zbuf, milu0[18].zbuf2, milu0[18]);
																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							error_approx_coarse17[i43 + 1] += (doublerealT)(milu0[18].zbuf2[i43 + 1]);
																																						}
																																					}
																																					else if (1 && bILU2smoother == 2) {
																																						seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																						residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);

																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							milu2[18].zbuf[i43 + 1] = residual_fine18[i43 + 1];
																																						}
																																						lusol_1patchforRUMBA(n_a[18], milu2[18].zbuf, milu2[18].zbuf2, milu2[18]);
																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							error_approx_coarse17[i43 + 1] += (doublerealT)(milu2[18].zbuf2[i43 + 1]);
																																						}
																																					}
																																					else {
																																						seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																					}
																																				}
																																				else {
																																					seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, nested_desection18, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																				}
																																			}
																																		}


																																	}

																																	// prolongation
																																	// residual_r
																																	//doublerealT *error_approx_fine17 = new doublerealT[n_a[17] + 1];
																																	for (integer ii = 1; ii <= n_a[17]; ii++) {
																																		error_approx_fine17[ii] = 0.0;
																																	}


																																	prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17], flag, error_approx_fine17, error_approx_coarse17, n_a[17], n_a[18]);

																																	
																																	// correction
																																	for (integer ii = 1; ii <= n_a[17]; ii++) {
																																		error_approx_coarse16[ii] += error_approx_fine17[ii];
																																	}

																																	// free
																																	//delete[] error_approx_fine17;
																																	//delete[] error_approx_coarse17;
																																	//delete[] residual_coarse17;
																																	//delete[] residual_fine17;

																																}



																																// post smothing
																																// doublerealT R0_17 = 0.0;
																																///doublerealT Rprev_17 = 0.0, Rnext_17 = 0.0;
																																if (process_flow_logic) {
																																	// calculate initial residual.
																																	//residualq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16], residual_fine17);



																																	//Rprev_17 = norma(residual_fine17, n_a[17]);


																																	// smother
																																	integer iter = 0;
																																	for (iter = 0; iter < nu2; iter++) {
																																		//quick seidel
																																		if (bonly_serial) {
																																			seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																		}
																																		else {
																																			seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, nested_desection17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																		}

																																		//residualq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16], residual_fine17);
																																		residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);


																																		Rnext_17 = norma(residual_fine17, n_a[17]);
																																		// this is process flow logic
																																		if (Rnext_17 < process_flow_alpha*R0_17) {
																																			// Смысл модификации в том что мы экономим итерации на пресмутере.
																																			break; // досрочно опускаемся на следующий уровень если он есть конечно.
																																		}
																																		else {
																																			Rprev_17 = Rnext_17;
																																		}
																																	}

																																	if (iter == nu2) {
																																		printf("level 17 limit postsmother iteration is reached\n");
																																	}

																																}
																																else {
																																	for (integer iter = 0; iter < nu2; iter++) {
																																		if (bonly_serial) {


																																			if (bILU2smoother == 1) {
																																				seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																				residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);

																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					milu0[17].zbuf[i43 + 1] = residual_fine17[i43 + 1];
																																				}
																																				lusol_1patchforRUMBA(n_a[17], milu0[17].zbuf, milu0[17].zbuf2, milu0[17]);
																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					error_approx_coarse16[i43 + 1] += (doublerealT)(milu0[17].zbuf2[i43 + 1]);
																																				}
																																			}
																																			else if (1 && bILU2smoother == 2) {
																																				seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																				residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);

																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					milu2[17].zbuf[i43 + 1] = residual_fine17[i43 + 1];
																																				}
																																				lusol_1patchforRUMBA(n_a[17], milu2[17].zbuf, milu2[17].zbuf2, milu2[17]);
																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					error_approx_coarse16[i43 + 1] += (doublerealT)(milu2[17].zbuf2[i43 + 1]);
																																				}
																																			}
																																			else {
																																				seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																			}
																																		}
																																		else {
																																			seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, nested_desection17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																		}
																																	}
																																}
																															}
																															move_up(nu1, nu2);

																															// prolongation
																															// residual_r
																															//doublerealT *error_approx_fine16 = new doublerealT[n_a[16] + 1];
																															for (integer ii = 1; ii <= n_a[16]; ii++) {
																																error_approx_fine16[ii] = 0.0;
																															}


																															prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16], flag, error_approx_fine16, error_approx_coarse16, n_a[16], n_a[17]);

																															
																															// correction
																															for (integer ii = 1; ii <= n_a[16]; ii++) {
																																error_approx_coarse15[ii] += error_approx_fine16[ii];
																															}

																															// free
																															//delete[] error_approx_fine16;
																															//delete[] error_approx_coarse16;
																															//delete[] residual_coarse16;
																															//delete[] residual_fine16;

																														}


																														// post smothing
																														// doublerealT R0_16 = 0.0;
																														///doublerealT Rprev_16 = 0.0, Rnext_16 = 0.0;
																														if (process_flow_logic) {
																															// calculate initial residual.
																															//residualq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15], residual_fine16);



																															//Rprev_16 = norma(residual_fine16, n_a[16]);


																															// smother
																															integer iter = 0;
																															for (iter = 0; iter < nu2; iter++) {
																																//quick seidel
																																if (bonly_serial) {
																																	seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																}
																																else {
																																	seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, nested_desection16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																}

																																//residualq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15], residual_fine16);
																																residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);


																																Rnext_16 = norma(residual_fine16, n_a[16]);
																																// this is process flow logic
																																if (Rnext_16 < process_flow_alpha*R0_16) {
																																	// Смысл модификации в том что мы экономим итерации на пресмутере.
																																	break; // досрочно опускаемся на следующий уровень если он есть конечно.
																																}
																																else {
																																	Rprev_16 = Rnext_16;
																																}
																															}

																															if (iter == nu2) {
																																printf("level 16 limit postsmother iteration is reached\n");
																															}

																														}
																														else {
																															for (integer iter = 0; iter < nu2; iter++) {
																																if (bonly_serial) {


																																	if (bILU2smoother == 1) {
																																		seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																		residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);

																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			milu0[16].zbuf[i43 + 1] = residual_fine16[i43 + 1];
																																		}
																																		lusol_1patchforRUMBA(n_a[16], milu0[16].zbuf, milu0[16].zbuf2, milu0[16]);
																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			error_approx_coarse15[i43 + 1] += (doublerealT)(milu0[16].zbuf2[i43 + 1]);
																																		}
																																	}
																																	else if (1 && bILU2smoother == 2) {
																																		seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																		residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);

																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			milu2[16].zbuf[i43 + 1] = residual_fine16[i43 + 1];
																																		}
																																		lusol_1patchforRUMBA(n_a[16], milu2[16].zbuf, milu2[16].zbuf2, milu2[16]);
																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			error_approx_coarse15[i43 + 1] += (doublerealT)(milu2[16].zbuf2[i43 + 1]);
																																		}
																																	}
																																	else {
																																		seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																	}
																																}
																																else {
																																	seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, nested_desection16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																}
																															}
																														}



																													}
																													move_up(nu1, nu2);

																													// prolongation
																													// residual_r
																													//doublerealT *error_approx_fine15 = new doublerealT[n_a[15] + 1];
																													for (integer ii = 1; ii <= n_a[15]; ii++) {
																														error_approx_fine15[ii] = 0.0;
																													}


																													prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15], flag, error_approx_fine15, error_approx_coarse15, n_a[15], n_a[16]);

																													
																													// correction
																													for (integer ii = 1; ii <= n_a[15]; ii++) {
																														error_approx_coarse14[ii] += error_approx_fine15[ii];
																													}

																													// free
																													//delete[] error_approx_fine15;
																													//delete[] error_approx_coarse15;
																													//delete[] residual_coarse15;
																													//delete[] residual_fine15;

																												}

																												// post smothing
																												// doublerealT R0_15 = 0.0;
																												///doublerealT Rprev_15 = 0.0, Rnext_15 = 0.0;
																												if (process_flow_logic) {
																													// calculate initial residual.
																													//residualq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14], residual_fine15);



																													//Rprev_15 = norma(residual_fine15, n_a[15]);


																													// smother
																													integer iter = 0;
																													for (iter = 0; iter < nu2; iter++) {
																														//quick seidel
																														if (bonly_serial) {
																															seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																														}
																														else {
																															seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, nested_desection15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																														}

																														//residualq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14], residual_fine15);
																														residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);


																														Rnext_15 = norma(residual_fine15, n_a[15]);
																														// this is process flow logic
																														if (Rnext_15 < process_flow_alpha*R0_15) {
																															// Смысл модификации в том что мы экономим итерации на пресмутере.
																															break; // досрочно опускаемся на следующий уровень если он есть конечно.
																														}
																														else {
																															Rprev_15 = Rnext_15;
																														}
																													}

																													if (iter == nu2) {
																														printf("level 15 limit postsmother iteration is reached\n");
																													}

																												}
																												else {
																													for (integer iter = 0; iter < nu2; iter++) {
																														if (bonly_serial) {


																															if (bILU2smoother == 1) {
																																seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																																residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);

																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	milu0[15].zbuf[i43 + 1] = residual_fine15[i43 + 1];
																																}
																																lusol_1patchforRUMBA(n_a[15], milu0[15].zbuf, milu0[15].zbuf2, milu0[15]);
																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	error_approx_coarse14[i43 + 1] += (doublerealT)(milu0[15].zbuf2[i43 + 1]);
																																}
																															}
																															else if (1 && bILU2smoother == 2) {
																																seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																																residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);

																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	milu2[15].zbuf[i43 + 1] = residual_fine15[i43 + 1];
																																}
																																lusol_1patchforRUMBA(n_a[15], milu2[15].zbuf, milu2[15].zbuf2, milu2[15]);
																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	error_approx_coarse14[i43 + 1] += (doublerealT)(milu2[15].zbuf2[i43 + 1]);
																																}
																															}
																															else {
																																seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																															}
																														}
																														else {
																															seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, nested_desection15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																														}
																													}
																												}


																											}
																											move_up(nu1, nu2);

																											// prolongation
																											// residual_r
																											//doublerealT *error_approx_fine14 = new doublerealT[n_a[14] + 1];
																											for (integer ii = 1; ii <= n_a[14]; ii++) {
																												error_approx_fine14[ii] = 0.0;
																											}


																											prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14], flag, error_approx_fine14, error_approx_coarse14, n_a[14], n_a[15]);

																											
																											// correction
																											for (integer ii = 1; ii <= n_a[14]; ii++) {
																												error_approx_coarse13[ii] += error_approx_fine14[ii];
																											}

																											// free
																											//delete[] error_approx_fine14;
																											//delete[] error_approx_coarse14;
																											//delete[] residual_coarse14;
																											//delete[] residual_fine14;

																										}


																										// post smothing
																										// doublerealT R0_14 = 0.0;
																										///doublerealT Rprev_14 = 0.0, Rnext_14 = 0.0;
																										if (process_flow_logic) {
																											// calculate initial residual.
																											//residualq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13], residual_fine14);



																											//Rprev_14 = norma(residual_fine14, n_a[14]);


																											// smother
																											integer iter = 0;
																											for (iter = 0; iter < nu2; iter++) {
																												//quick seidel
																												if (bonly_serial) {
																													seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																												}
																												else {
																													seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, nested_desection14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																												}

																												//residualq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13], residual_fine14);
																												residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);


																												Rnext_14 = norma(residual_fine14, n_a[14]);
																												// this is process flow logic
																												if (Rnext_14 < process_flow_alpha*R0_14) {
																													// Смысл модификации в том что мы экономим итерации на пресмутере.
																													break; // досрочно опускаемся на следующий уровень если он есть конечно.
																												}
																												else {
																													Rprev_14 = Rnext_14;
																												}
																											}

																											if (iter == nu2) {
																												printf("level 14 limit postsmother iteration is reached\n");
																											}

																										}
																										else {
																											for (integer iter = 0; iter < nu2; iter++) {
																												if (bonly_serial) {


																													if (bILU2smoother == 1) {
																														seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																														residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);

																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															milu0[14].zbuf[i43 + 1] = residual_fine14[i43 + 1];
																														}
																														lusol_1patchforRUMBA(n_a[14], milu0[14].zbuf, milu0[14].zbuf2, milu0[14]);
																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															error_approx_coarse13[i43 + 1] += (doublerealT)(milu0[14].zbuf2[i43 + 1]);
																														}
																													}
																													else if (1 && bILU2smoother == 2) {
																														seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																														residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);

																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															milu2[14].zbuf[i43 + 1] = residual_fine14[i43 + 1];
																														}
																														lusol_1patchforRUMBA(n_a[14], milu2[14].zbuf, milu2[14].zbuf2, milu2[14]);
																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															error_approx_coarse13[i43 + 1] += (doublerealT)(milu2[14].zbuf2[i43 + 1]);
																														}
																													}
																													else {
																														seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																													}
																												}
																												else {
																													seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, nested_desection14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																												}
																											}
																										}


																									}

																									move_up(nu1, nu2);

																									// prolongation
																									// residual_r
																									//doublerealT *error_approx_fine13 = new doublerealT[n_a[13] + 1];
																									for (integer ii = 1; ii <= n_a[13]; ii++) {
																										error_approx_fine13[ii] = 0.0;
																									}

#if doubleintprecision == 1
																									//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																									//printf("error_approx_coarse13[%lld]=%e\n",ii, error_approx_coarse13[ii]);

																									//printf("residual_coarse13[%lld]=%e\n", ii, residual_coarse13[ii]);
																									//getchar();
																									//}
																									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																									//if (ii % 20 == 0) getchar();
																									//}
#else
																									//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																									//printf("error_approx_coarse13[%d]=%e\n",ii, error_approx_coarse13[ii]);

																									//printf("residual_coarse13[%d]=%e\n", ii, residual_coarse13[ii]);
																									//getchar();
																									//}
																									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																									//if (ii % 20 == 0) getchar();
																									//}
#endif
																									

																									prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13], flag, error_approx_fine13, error_approx_coarse13, n_a[13], n_a[14]);

																																																		
																									// correction
																									for (integer ii = 1; ii <= n_a[13]; ii++) {
																										error_approx_coarse12[ii] += error_approx_fine13[ii];
																									}

																									// free
																									//delete[] error_approx_fine13;
																									//delete[] error_approx_coarse13;
																									//delete[] residual_coarse13;
																									//delete[] residual_fine13;

																								}


																								// post smothing
																								// doublerealT R0_13 = 0.0;
																								///doublerealT Rprev_13 = 0.0, Rnext_13 = 0.0;
																								if (process_flow_logic) {
																									// calculate initial residual.
																									//residualq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12], residual_fine13);



																									//Rprev_13 = norma(residual_fine13, n_a[13]);


																									// smother
																									integer iter = 0;
																									for (iter = 0; iter < nu2; iter++) {
																										//quick seidel
																										if (bonly_serial) {
																											seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																										}
																										else {
																											seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, nested_desection13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																										}

																										//residualq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12], residual_fine13);
																										residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);


																										Rnext_13 = norma(residual_fine13, n_a[13]);
																										// this is process flow logic
																										if (Rnext_13 < process_flow_alpha*R0_13) {
																											// Смысл модификации в том что мы экономим итерации на пресмутере.
																											break; // досрочно опускаемся на следующий уровень если он есть конечно.
																										}
																										else {
																											Rprev_13 = Rnext_13;
																										}
																									}

																									if (iter == nu2) {
																										printf("level 13 limit postsmother iteration is reached\n");
																									}

																								}
																								else {
																									for (integer iter = 0; iter < nu2; iter++) {
																										if (bonly_serial) {


																											if (bILU2smoother == 1) {
																												seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																												residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);

																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													milu0[13].zbuf[i43 + 1] = residual_fine13[i43 + 1];
																												}
																												lusol_1patchforRUMBA(n_a[13], milu0[13].zbuf, milu0[13].zbuf2, milu0[13]);
																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													error_approx_coarse12[i43 + 1] += (doublerealT)(milu0[13].zbuf2[i43 + 1]);
																												}
																											}
																											else if (1 && bILU2smoother == 2) {
																												seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																												residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);

																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													milu2[13].zbuf[i43 + 1] = residual_fine13[i43 + 1];
																												}
																												lusol_1patchforRUMBA(n_a[13], milu2[13].zbuf, milu2[13].zbuf2, milu2[13]);
																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													error_approx_coarse12[i43 + 1] += (doublerealT)(milu2[13].zbuf2[i43 + 1]);
																												}
																											}
																											else {
																												seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																											}
																										}
																										else {
																											seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, nested_desection13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																										}
																									}
																								}
																							}

																							move_up(nu1, nu2);

																							// prolongation
																							// residual_r
																							//doublerealT *error_approx_fine12 = new doublerealT[n_a[12] + 1];
																							for (integer ii = 1; ii <= n_a[12]; ii++) {
																								error_approx_fine12[ii] = 0.0;
																							}

#if doubleintprecision == 1
																							//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
																							//printf("error_approx_coarse12[%lld]=%e\n",ii, error_approx_coarse12[ii]);

																							//printf("residual_coarse12[%lld]=%e\n", ii, residual_coarse12[ii]);
																							//getchar();
																							//}
																							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
																							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																							//if (ii % 20 == 0) getchar();
																							//}
#else
																							//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
																							//printf("error_approx_coarse12[%d]=%e\n",ii, error_approx_coarse12[ii]);

																							//printf("residual_coarse12[%d]=%e\n", ii, residual_coarse12[ii]);
																							//getchar();
																							//}
																							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
																							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																							//if (ii % 20 == 0) getchar();
																							//}
#endif

																							

																							prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12], flag, error_approx_fine12, error_approx_coarse12, n_a[12], n_a[13]);
																		

																							// correction
																							for (integer ii = 1; ii <= n_a[12]; ii++) {
																								error_approx_coarse11[ii] += error_approx_fine12[ii];
																							}

																							// free
																							//delete[] error_approx_fine12;
																							//delete[] error_approx_coarse12;
																							//delete[] residual_coarse12;
																							//delete[] residual_fine12;

																						}



																						// post smothing
																						//doublerealT R0_12 = 0.0;
																						///doublerealT Rprev_12 = 0.0, Rnext_12 = 0.0;
																						if (process_flow_logic) {
																							// calculate initial residual.
																							//residualq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11], residual_fine12);



																							//Rprev_12 = norma(residual_fine12, n_a[12]);


																							// smother
																							integer iter = 0;
																							for (iter = 0; iter < nu2; iter++) {
																								//quick seidel
																								if (bonly_serial) {
																									seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																								}
																								else {
																									seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, nested_desection12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																								}

																								//residualq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11], residual_fine12);
																								residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);


																								Rnext_12 = norma(residual_fine12, n_a[12]);
																								// this is process flow logic
																								if (Rnext_12 < process_flow_alpha*R0_12) {
																									// Смысл модификации в том что мы экономим итерации на пресмутере.
																									break; // досрочно опускаемся на следующий уровень если он есть конечно.
																								}
																								else {
																									Rprev_12 = Rnext_12;
																								}
																							}

																							if (iter == nu2) {
																								printf("level 12 limit postsmother iteration is reached\n");
																							}

																						}
																						else {
																							for (integer iter = 0; iter < nu2; iter++) {
																								if (bonly_serial) {


																									if (bILU2smoother == 1) {
																										seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																										residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);

																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											milu0[12].zbuf[i43 + 1] = residual_fine12[i43 + 1];
																										}
																										lusol_1patchforRUMBA(n_a[12], milu0[12].zbuf, milu0[12].zbuf2, milu0[12]);
																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											error_approx_coarse11[i43 + 1] += (doublerealT)(milu0[12].zbuf2[i43 + 1]);
																										}
																									}
																									else if (1 && bILU2smoother == 2) {
																										seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																										residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);

																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											milu2[12].zbuf[i43 + 1] = residual_fine12[i43 + 1];
																										}
																										lusol_1patchforRUMBA(n_a[12], milu2[12].zbuf, milu2[12].zbuf2, milu2[12]);
																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											error_approx_coarse11[i43 + 1] += (doublerealT)(milu2[12].zbuf2[i43 + 1]);
																										}
																									}
																									else {
																										seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																									}
																								}
																								else {
																									seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, nested_desection12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																								}
																							}
																						}
																					}
																					move_up(nu1, nu2);

																					// prolongation
																					// residual_r
																					//doublerealT *error_approx_fine11 = new doublerealT[n_a[11] + 1];
																					for (integer ii = 1; ii <= n_a[11]; ii++) {
																						error_approx_fine11[ii] = 0.0;
																					}

#if doubleintprecision == 1
																					//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
																					//printf("error_approx_coarse11[%lld]=%e\n",ii, error_approx_coarse11[ii]);

																					//printf("residual_coarse11[%lld]=%e\n", ii, residual_coarse11[ii]);
																					//getchar();
																					//}
																					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
																					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																					//if (ii % 20 == 0) getchar();
																					//}
#else
																					//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
																					//printf("error_approx_coarse11[%d]=%e\n",ii, error_approx_coarse11[ii]);

																					//printf("residual_coarse11[%d]=%e\n", ii, residual_coarse11[ii]);
																					//getchar();
																					//}
																					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
																					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																					//if (ii % 20 == 0) getchar();
																					//}
#endif

																					

																					prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11], flag, error_approx_fine11, error_approx_coarse11, n_a[11], n_a[12]);
																					
																					
																					// correction
																					for (integer ii = 1; ii <= n_a[11]; ii++) {
																						error_approx_coarse10[ii] += error_approx_fine11[ii];
																					}

																					// free
																					//delete[] error_approx_fine11;
																					//delete[] error_approx_coarse11;
																					//delete[] residual_coarse11;
																					//delete[] residual_fine11;

																				}


																				// post smothing
																				//doublerealT R0_11 = 0.0;
																				///doublerealT Rprev_11 = 0.0, Rnext_11 = 0.0;
																				if (process_flow_logic) {
																					// calculate initial residual.
																					//residualq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10], residual_fine11);



																					//Rprev_11 = norma(residual_fine11, n_a[11]);


																					// smother
																					integer iter = 0;
																					for (iter = 0; iter < nu2; iter++) {
																						//quick seidel
																						if (bonly_serial) {
																							seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																						}
																						else {
																							seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, nested_desection11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																						}

																						//residualq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10], residual_fine11);
																						residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);


																						Rnext_11 = norma(residual_fine11, n_a[11]);
																						// this is process flow logic
																						if (Rnext_11 < process_flow_alpha*R0_11) {
																							// Смысл модификации в том что мы экономим итерации на пресмутере.
																							break; // досрочно опускаемся на следующий уровень если он есть конечно.
																						}
																						else {
																							Rprev_11 = Rnext_11;
																						}
																					}

																					if (iter == nu2) {
																						printf("level 11 limit postsmother iteration is reached\n");
																					}

																				}
																				else {
																					for (integer iter = 0; iter < nu2; iter++) {
																						if (bonly_serial) {


																							if (bILU2smoother == 1) {
																								seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																								residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);

																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									milu0[11].zbuf[i43 + 1] = residual_fine11[i43 + 1];
																								}
																								lusol_1patchforRUMBA(n_a[11], milu0[11].zbuf, milu0[11].zbuf2, milu0[11]);
																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									error_approx_coarse10[i43 + 1] += (doublerealT)(milu0[11].zbuf2[i43 + 1]);
																								}
																							}
																							else if (1 && bILU2smoother == 2) {
																								seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																								residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);

																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									milu2[11].zbuf[i43 + 1] = residual_fine11[i43 + 1];
																								}
																								lusol_1patchforRUMBA(n_a[11], milu2[11].zbuf, milu2[11].zbuf2, milu2[11]);
																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									error_approx_coarse10[i43 + 1] += (doublerealT)(milu2[11].zbuf2[i43 + 1]);
																								}
																							}
																							else {
																								seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																							}
																						}
																						else {
																							seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, nested_desection11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																						}
																					}
																				}
																				
																			}
																			move_up(nu1, nu2);

																			// prolongation
																			// residual_r
																			//doublerealT *error_approx_fine10 = new doublerealT[n_a[10] + 1];
																			for (integer ii = 1; ii <= n_a[10]; ii++) {
																				error_approx_fine10[ii] = 0.0;
																			}

#if doubleintprecision == 1
																			//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
																			//printf("error_approx_coarse10[%lld]=%e\n",ii, error_approx_coarse10[ii]);

																			//printf("residual_coarse10[%lld]=%e\n", ii, residual_coarse10[ii]);
																			//getchar();
																			//}
																			//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
																			//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																			//if (ii % 20 == 0) getchar();
																			//}
#else
																			//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
																			//printf("error_approx_coarse10[%d]=%e\n",ii, error_approx_coarse10[ii]);

																			//printf("residual_coarse10[%d]=%e\n", ii, residual_coarse10[ii]);
																			//getchar();
																			//}
																			//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
																			//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																			//if (ii % 20 == 0) getchar();
																			//}
#endif

																			

																			prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10], flag, error_approx_fine10, error_approx_coarse10, n_a[10], n_a[11]);

																			
																			// correction
																			for (integer ii = 1; ii <= n_a[10]; ii++) {
																				error_approx_coarse9[ii] += error_approx_fine10[ii];
																			}

																			// free
																			//delete[] error_approx_fine10;
																			//delete[] error_approx_coarse10;
																			//delete[] residual_coarse10;
																			//delete[] residual_fine10;

																		}



																		// post smothing
																		//doublerealT R0_10 = 0.0;
																		///doublerealT Rprev_10 = 0.0, Rnext_10 = 0.0;
																		if (process_flow_logic) {
																			// calculate initial residual.
																			//residualq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9], residual_fine10);



																			//Rprev_10 = norma(residual_fine10, n_a[10]);


																			// smother
																			integer iter = 0;
																			for (iter = 0; iter < nu2; iter++) {
																				//quick seidel
																				if (bonly_serial) {
																					seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																				}
																				else {
																					seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, nested_desection10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																				}

																				//residualq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9], residual_fine10);
																				residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);


																				Rnext_10 = norma(residual_fine10, n_a[10]);
																				// this is process flow logic
																				if (Rnext_10 < process_flow_alpha*R0_10) {
																					// Смысл модификации в том что мы экономим итерации на пресмутере.
																					break; // досрочно опускаемся на следующий уровень если он есть конечно.
																				}
																				else {
																					Rprev_10 = Rnext_10;
																				}
																			}

																			if (iter == nu2) {
																				printf("level 10 limit postsmother iteration is reached\n");
																			}

																		}
																		else {
																			for (integer iter = 0; iter < nu2; iter++) {
																				if (bonly_serial) {


																					if (bILU2smoother == 1) {
																						seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																						residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);

																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							milu0[10].zbuf[i43 + 1] = residual_fine10[i43 + 1];
																						}
																						lusol_1patchforRUMBA(n_a[10], milu0[10].zbuf, milu0[10].zbuf2, milu0[10]);
																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							error_approx_coarse9[i43 + 1] += (doublerealT)(milu0[10].zbuf2[i43 + 1]);
																						}
																					}
																					else if (1 && bILU2smoother == 2) {
																						seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																						residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);

																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							milu2[10].zbuf[i43 + 1] = residual_fine10[i43 + 1];
																						}
																						lusol_1patchforRUMBA(n_a[10], milu2[10].zbuf, milu2[10].zbuf2, milu2[10]);
																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							error_approx_coarse9[i43 + 1] += (doublerealT)(milu2[10].zbuf2[i43 + 1]);
																						}
																					}
																					else {
																						seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																					}
																				}
																				else {
																					seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, nested_desection10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																				}
																			}
																		}
																		
																	}

																	move_up(nu1, nu2);

																	// prolongation
																	// residual_r
																	//doublerealT *error_approx_fine9 = new doublerealT[n_a[9] + 1];
																	for (integer ii = 1; ii <= n_a[9]; ii++) {
																		error_approx_fine9[ii] = 0.0;
																	}

#if doubleintprecision == 1
																	//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
																	//printf("error_approx_coarse9[%lld]=%e\n",ii, error_approx_coarse9[ii]);

																	//printf("residual_coarse9[%lld]=%e\n", ii, residual_coarse9[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
																	//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#else
																	//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
																	//printf("error_approx_coarse9[%d]=%e\n",ii, error_approx_coarse9[ii]);

																	//printf("residual_coarse9[%d]=%e\n", ii, residual_coarse9[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
																	//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#endif

																	

																	prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9], flag, error_approx_fine9, error_approx_coarse9, n_a[9], n_a[10]);

																	
																	// correction
																	for (integer ii = 1; ii <= n_a[9]; ii++) {
																		error_approx_coarse8[ii] += error_approx_fine9[ii];
																	}

																	// free
																	//delete[] error_approx_fine9;
																	//delete[] error_approx_coarse9;
																	//delete[] residual_coarse9;
																	//delete[] residual_fine9;

																}

																// post smothing
																//doublerealT R0_9 = 0.0;
																///doublerealT Rprev_9 = 0.0, Rnext_9 = 0.0;
																if (process_flow_logic) {
																	// calculate initial residual.
																	//residualq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9);



																	//Rprev_9 = norma(residual_fine9, n_a[9]);


																	// smother
																	integer iter = 0;
																	for (iter = 0; iter < nu2; iter++) {
																		//quick seidel
																		if (bonly_serial) {
																			seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																		}
																		else {
																			seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, nested_desection9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																		}

																		//residualq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8], residual_fine9);
																		residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);


																		Rnext_9 = norma(residual_fine9, n_a[9]);
																		// this is process flow logic
																		if (Rnext_9 < process_flow_alpha*R0_9) {
																			// Смысл модификации в том что мы экономим итерации на пресмутере.
																			break; // досрочно опускаемся на следующий уровень если он есть конечно.
																		}
																		else {
																			Rprev_9 = Rnext_9;
																		}
																	}

																	if (iter == nu2) {
																		printf("level 9 limit postsmother iteration is reached\n");
																	}

																}
																else {
																	for (integer iter = 0; iter < nu2; iter++) {
																		if (bonly_serial) {


																			if (bILU2smoother == 1) {
																				seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																				residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);

																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					milu0[9].zbuf[i43 + 1] = residual_fine9[i43 + 1];
																				}
																				lusol_1patchforRUMBA(n_a[9], milu0[9].zbuf, milu0[9].zbuf2, milu0[9]);
																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					error_approx_coarse8[i43 + 1] += (doublerealT)(milu0[9].zbuf2[i43 + 1]);
																				}
																			}
																			else if (1 && bILU2smoother == 2) {
																				seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																				residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);

																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					milu2[9].zbuf[i43 + 1] = residual_fine9[i43 + 1];
																				}
																				lusol_1patchforRUMBA(n_a[9], milu2[9].zbuf, milu2[9].zbuf2, milu2[9]);
																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					error_approx_coarse8[i43 + 1] += (doublerealT)(milu2[9].zbuf2[i43 + 1]);
																				}
																			}
																			else {
																				seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																			}
																		}
																		else {
																			seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, nested_desection9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																		}
																	}
																}


															}

															move_up(nu1, nu2);

															// prolongation
															// residual_r
															//doublerealT *error_approx_fine8 = new doublerealT[n_a[8] + 1];
															for (integer ii = 1; ii <= n_a[8]; ii++) {
																error_approx_fine8[ii] = 0.0;
															}

#if doubleintprecision == 1
															//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
															//printf("error_approx_coarse8[%lld]=%e\n",ii, error_approx_coarse8[ii]);

															//printf("residual_coarse8[%lld]=%e\n", ii, residual_coarse8[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
															//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#else
															//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
															//printf("error_approx_coarse8[%d]=%e\n",ii, error_approx_coarse8[ii]);

															//printf("residual_coarse8[%d]=%e\n", ii, residual_coarse8[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
															//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#endif

															

															prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8], flag, error_approx_fine8, error_approx_coarse8, n_a[8], n_a[9]);



															// correction
															for (integer ii = 1; ii <= n_a[8]; ii++) {
																error_approx_coarse7[ii] += error_approx_fine8[ii];
															}

															// free
															//delete[] error_approx_fine8;
															//delete[] error_approx_coarse8;
															//delete[] residual_coarse8;
															//delete[] residual_fine8;

														}




														// post smothing
														//doublerealT R0_8 = 0.0;
														//doublerealT Rprev_8 = 0.0, Rnext_8 = 0.0;
														if (process_flow_logic) {
															// calculate initial residual.
															//residualq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8);



															//Rprev_8 = norma(residual_fine8, n_a[8]);


															// smother
															integer iter = 0;
															for (iter = 0; iter < nu2; iter++) {
																//quick seidel
																if (bonly_serial) {
																	seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																}
																else {
																	seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, nested_desection8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																}

																//residualq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7], residual_fine8);
																residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);


																Rnext_8 = norma(residual_fine8, n_a[8]);
																// this is process flow logic
																if (Rnext_8 < process_flow_alpha*R0_8) {
																	// Смысл модификации в том что мы экономим итерации на пресмутере.
																	break; // досрочно опускаемся на следующий уровень если он есть конечно.
																}
																else {
																	Rprev_8 = Rnext_8;
																}
															}

															if (iter == nu2) {
																printf("level 8 limit postsmother iteration is reached\n");
															}

														}
														else {
															for (integer iter = 0; iter < nu2; iter++) {
																if (bonly_serial) {
																	if (bILU2smoother == 1) {
																		seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																		residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);

																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			milu0[8].zbuf[i43 + 1] = residual_fine8[i43 + 1];
																		}
																		lusol_1patchforRUMBA(n_a[8], milu0[8].zbuf, milu0[8].zbuf2, milu0[8]);
																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			error_approx_coarse7[i43 + 1] += (doublerealT)(milu0[8].zbuf2[i43 + 1]);
																		}
																	}
																	else if (1 && bILU2smoother == 2) {
																		seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																		residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);

																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			milu2[8].zbuf[i43 + 1] = residual_fine8[i43 + 1];
																		}
																		lusol_1patchforRUMBA(n_a[8], milu2[8].zbuf, milu2[8].zbuf2, milu2[8]);
																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			error_approx_coarse7[i43 + 1] += (doublerealT)(milu2[8].zbuf2[i43 + 1]);
																		}
																	}
																	else {
																		seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																	}
																}
																else {
																	seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, nested_desection8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																}
															}
														}

													}
													move_up(nu1, nu2);

													// prolongation
													// residual_r
													//doublerealT *error_approx_fine7 = new doublerealT[n_a[7] + 1];
													for (integer ii = 1; ii <= n_a[7]; ii++) {
														error_approx_fine7[ii] = 0.0;
													}

#if doubleintprecision == 1
													//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
													//printf("error_approx_coarse7[%lld]=%e\n",ii, error_approx_coarse7[ii]);

													//printf("residual_coarse7[%lld]=%e\n", ii, residual_coarse7[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
													//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#else
													//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
													//printf("error_approx_coarse7[%d]=%e\n",ii, error_approx_coarse7[ii]);

													//printf("residual_coarse7[%d]=%e\n", ii, residual_coarse7[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
													//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#endif

													

													prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, error_approx_fine7, error_approx_coarse7, n_a[7], n_a[8]);

													// correction
													for (integer ii = 1; ii <= n_a[7]; ii++) {
														error_approx_coarse6[ii] += error_approx_fine7[ii];
													}

													// free
													//delete[] error_approx_fine7;
													//delete[] error_approx_coarse7;
													//delete[] residual_coarse7;
													//delete[] residual_fine7;

												}

												// post smothing
												//doublerealT R0_7 = 0.0;
												//doublerealT Rprev_7 = 0.0, Rnext_7 = 0.0;
												if (process_flow_logic) {
													// calculate initial residual.
													//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);



													//Rprev_7 = norma(residual_fine7, n_a[7]);


													// smother
													integer iter = 0;
													for (iter = 0; iter < nu2; iter++) {
														//quick seidel
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}

														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);


														Rnext_7 = norma(residual_fine7, n_a[7]);
														// this is process flow logic
														if (Rnext_7 < process_flow_alpha*R0_7) {
															// Смысл модификации в том что мы экономим итерации на пресмутере.
															break; // досрочно опускаемся на следующий уровень если он есть конечно.
														}
														else {
															Rprev_7 = Rnext_7;
														}
													}

													if (iter == nu2) {
														printf("level 7 limit postsmother iteration is reached\n");
													}

												}
												else {
													for (integer iter = 0; iter < nu2; iter++) {
														if (bonly_serial) {
															if (bILU2smoother == 1) {
																seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
																residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);

																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	milu0[7].zbuf[i43 + 1] = residual_fine7[i43 + 1];
																}
																lusol_1patchforRUMBA(n_a[7], milu0[7].zbuf, milu0[7].zbuf2, milu0[7]);
																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	error_approx_coarse6[i43 + 1] += (doublerealT)(milu0[7].zbuf2[i43 + 1]);
																}
															}
															else if (1 && bILU2smoother == 2) {
																seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
																residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);

																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	milu2[7].zbuf[i43 + 1] = residual_fine7[i43 + 1];
																}
																lusol_1patchforRUMBA(n_a[7], milu2[7].zbuf, milu2[7].zbuf2, milu2[7]);
																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	error_approx_coarse6[i43 + 1] += (doublerealT)(milu2[7].zbuf2[i43 + 1]);
																}
															}
															else {
																seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
															}
													    }
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
													}
												}
											}

											move_up(nu1, nu2);


											// prolongation
											// residual_r
											//doublerealT *error_approx_fine6 = new doublerealT[n_a[6] + 1];
											for (integer ii = 1; ii <= n_a[6]; ii++) {
												error_approx_fine6[ii] = 0.0;
											}

#if doubleintprecision == 1
											//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
											//printf("error_approx_coarse6[%lld]=%e\n",ii, error_approx_coarse6[ii]);

											//printf("residual_coarse6[%lld]=%e\n", ii, residual_coarse6[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
											//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#else
											//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
											//printf("error_approx_coarse6[%d]=%e\n",ii, error_approx_coarse6[ii]);

											//printf("residual_coarse6[%d]=%e\n", ii, residual_coarse6[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
											//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#endif

											

											prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, error_approx_fine6, error_approx_coarse6, n_a[6], n_a[7]);

											// correction
											for (integer ii = 1; ii <= n_a[6]; ii++) {
												error_approx_coarse5[ii] += error_approx_fine6[ii];
											}

											// free
											//delete[] error_approx_fine6;
											//delete[] error_approx_coarse6;
											//delete[] residual_coarse6;
											//delete[] residual_fine6;

										}



										// post smothing
										if (process_flow_logic) {
											// calculate initial residual.
											//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);



											//Rprev_6 = norma(residual_fine6, n_a[6]);


											// smother
											integer iter = 0;
											for (iter = 0; iter < nu2; iter++) {
												//quick seidel
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}

												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);



												Rnext_6 = norma(residual_fine6, n_a[6]);
												// this is process flow logic
												if (Rnext_6 < process_flow_alpha*R0_6) {
													// Смысл модификации в том что мы экономим итерации на пресмутере.
													break; // досрочно опускаемся на следующий уровень если он есть конечно.
												}
												else {
													Rprev_6 = Rnext_6;
												}
											}

											if (iter == nu2) {
												printf("level 6 limit postsmother iteration is reached\n");
											}

										}
										else {
											for (integer iter = 0; iter < nu2; iter++) {
												if (bonly_serial) {
													if (bILU2smoother == 1) {
														seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
														residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);

														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															milu0[6].zbuf[i43 + 1] = residual_fine6[i43 + 1];
														}
														lusol_1patchforRUMBA(n_a[6], milu0[6].zbuf, milu0[6].zbuf2, milu0[6]);
														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															error_approx_coarse5[i43 + 1] += (doublerealT)(milu0[6].zbuf2[i43 + 1]);
														}
													}
													else if (1 && bILU2smoother == 2) {
														seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
														residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);

														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															milu2[6].zbuf[i43 + 1] = residual_fine6[i43 + 1];
														}
														lusol_1patchforRUMBA(n_a[6], milu2[6].zbuf, milu2[6].zbuf2, milu2[6]);
														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															error_approx_coarse5[i43 + 1] += (doublerealT)(milu2[6].zbuf2[i43 + 1]);
														}
													}
													else {
														seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
													}
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
											}
										}
									}

									move_up(nu1, nu2);

									// prolongation
									// residual_r
									//doublerealT *error_approx_fine5 = new doublerealT[n_a[5] + 1];
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_fine5[ii] = 0.0;
									}


#if doubleintprecision == 1
									//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
									//printf("error_approx_coarse5[%lld]=%e\n",ii, error_approx_coarse5[ii]);

									//printf("residual_coarse5[%lld]=%e\n", ii, residual_coarse5[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#else
									//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
									//printf("error_approx_coarse5[%d]=%e\n",ii, error_approx_coarse5[ii]);

									//printf("residual_coarse5[%d]=%e\n", ii, residual_coarse5[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#endif

									

									prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, error_approx_fine5, error_approx_coarse5, n_a[5], n_a[6]);

									// correction
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] += error_approx_fine5[ii];
									}

									// free
									//delete[] error_approx_fine5;
									//delete[] error_approx_coarse5;
									//delete[] residual_coarse5;
									//delete[] residual_fine5;

								}



								// post smothing
								if (process_flow_logic) {
									// calculate initial residual.
									//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] , residual_fine5);



									//Rprev_5 = norma(residual_fine5, n_a[5]);


									// smother
									integer iter = 0;
									for (iter = 0; iter < nu2; iter++) {
										//quick seidel
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
										else {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}

										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] , residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);


										Rnext_5 = norma(residual_fine5, n_a[5]);
										// this is process flow logic
										if (Rnext_5 < process_flow_alpha*R0_5) {
											// Смысл модификации в том что мы экономим итерации на пресмутере.
											break; // досрочно опускаемся на следующий уровень если он есть конечно.
										}
										else {
											Rprev_5 = Rnext_5;
										}
									}

									if (iter == nu2) {
										printf("level 5 limit postsmother iteration is reached\n");
									}

								}
								else {
									for (integer iter = 0; iter < nu2; iter++) {
										if (bonly_serial) {
											if (bILU2smoother == 1) {
												seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
												residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);

												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													milu0[5].zbuf[i43 + 1] = residual_fine5[i43 + 1];
												}
												lusol_1patchforRUMBA(n_a[5], milu0[5].zbuf, milu0[5].zbuf2, milu0[5]);
												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													error_approx_coarse4[i43 + 1] += (doublerealT)(milu0[5].zbuf2[i43 + 1]);
												}
											}
											else if (1 && bILU2smoother == 2) {
												seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
												residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);

												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													milu2[5].zbuf[i43 + 1] = residual_fine5[i43 + 1];
												}
												lusol_1patchforRUMBA(n_a[5], milu2[5].zbuf, milu2[5].zbuf2, milu2[5]);
												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													error_approx_coarse4[i43 + 1] += (doublerealT)(milu2[5].zbuf2[i43 + 1]);
												}
											}
											else {
												seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
											}
										}
										else
										{
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
									}
								}
							}

							move_up(nu1, nu2);

							// prolongation
							// residual_r
							//doublerealT *error_approx_fine4 = new doublerealT[n_a[4] + 1];
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_fine4[ii] = 0.0;
							}

#if doubleintprecision == 1
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%lld]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%lld]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#else
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%d]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%d]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#endif

							

							prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, error_approx_fine4, error_approx_coarse4, n_a[4], n_a[5]);

							// correction
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] += error_approx_fine4[ii];
							}

							// free
							//delete[] error_approx_fine4;
							//delete[] error_approx_coarse4;
							//delete[] residual_coarse4;
							//delete[] residual_fine4;

							}




							// post smothing
							if (process_flow_logic) {


								// smother
								integer iter = 0;
								for (iter = 0; iter < nu2; iter++) {
									//quick seidel
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}

									//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] , residual_fine4);
									residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);


									Rnext_4 = norma(residual_fine4, n_a[4]);
									// this is process flow logic
									if (Rnext_4 < process_flow_alpha*R0_4) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_4 = Rnext_4;
									}
								}

								if (iter == nu2) {
									printf("level 4 limit postsmother iteration is reached\n");
								}

							}
							else {
								for (integer iter = 0; iter < nu2; iter++) {
									if (bonly_serial) {
										if (bILU2smoother == 1) {
											seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
											residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);

											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												milu0[4].zbuf[i43 + 1] = residual_fine4[i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[4], milu0[4].zbuf, milu0[4].zbuf2, milu0[4]);
											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												error_approx_coarse3[i43 + 1] += (doublerealT)(milu0[4].zbuf2[i43 + 1]);
											}
										}
										else if (1 && bILU2smoother == 2) {
											seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
											residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);

											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												milu2[4].zbuf[i43 + 1] = residual_fine4[i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[4], milu2[4].zbuf, milu2[4].zbuf2, milu2[4]);
											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												error_approx_coarse3[i43 + 1] += (doublerealT)(milu2[4].zbuf2[i43 + 1]);
											}
										}
										else {
											seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
										}
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
								}
							}
						}
						move_up(nu1, nu2);

						// prolongation
						// residual_r
						//doublerealT *error_approx_fine3 = new doublerealT[n_a[3] + 1];
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_fine3[ii] = 0.0;
						}


#if doubleintprecision == 1
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%lld]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%lld]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#else
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%d]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%d]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#endif

						

						prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, error_approx_fine3, error_approx_coarse3, n_a[3], n_a[4]);

						// correction
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] += error_approx_fine3[ii];
						}

						// free
						//delete[] error_approx_fine3;
						//delete[] error_approx_coarse3;
						//delete[] residual_coarse3;
						//delete[] residual_fine3;

						}



						// post smothing
						if (process_flow_logic) {


							// smother
							integer iter = 0;
							for (iter = 0; iter < nu2; iter++) {
								//quick seidel
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}

								//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] , residual_fine3);
								residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);


								Rnext_3 = norma(residual_fine3, n_a[3]);
								// this is process flow logic
								if (Rnext_3 < process_flow_alpha*R0_3) {
									// Смысл модификации в том что мы экономим итерации на пресмутере.
									break; // досрочно опускаемся на следующий уровень если он есть конечно.
								}
								else {
									Rprev_3 = Rnext_3;
								}
							}

							if (iter == nu2) {
								printf("level 3 limit postsmother iteration is reached\n");
							}

						}
						else {
							for (integer iter = 0; iter < nu2; iter++) {
								if (bonly_serial) {
									if (bILU2smoother == 1) {
										// ILU0
										seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
										residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);

										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											milu0[3].zbuf[i43 + 1] = residual_fine3[i43 + 1];
										}
										lusol_1patchforRUMBA(n_a[3], milu0[3].zbuf, milu0[3].zbuf2, milu0[3]);
										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											error_approx_coarse2[i43 + 1] += (doublerealT)(milu0[3].zbuf2[i43 + 1]);
										}
									}
									else if (1 && bILU2smoother == 2) {
										seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
										residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);

										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											milu2[3].zbuf[i43 + 1] = residual_fine3[i43 + 1];
										}
										lusol_1patchforRUMBA(n_a[3], milu2[3].zbuf, milu2[3].zbuf2, milu2[3]);
										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											error_approx_coarse2[i43 + 1] += (doublerealT)(milu2[3].zbuf2[i43 + 1]);
										}
									}
									else {
										seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
									}
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
							}
						}
					}

					move_up(nu1, nu2);

					// prolongation
					// residual_r
					//doublerealT *error_approx_fine2 = new doublerealT[n_a[2] + 1];
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_fine2[ii] = 0.0;
					}

#if doubleintprecision == 1
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%lld]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%lld]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#else
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%d]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%d]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#endif

					

					prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, error_approx_fine2, error_approx_coarse2, n_a[2], n_a[3]);

					// correction
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] += error_approx_fine2[ii];
					}

					// free
					//delete[] error_approx_fine2;
					//delete[] error_approx_coarse2;
					//delete[] residual_coarse2;
					//delete[] residual_fine2;

					}


					// post smothing
					if (process_flow_logic) {


						// smother
						integer iter = 0;
						for (iter = 0; iter < nu2; iter++) {
							//quick seidel
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}

							//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
							residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);



							Rnext_2 = norma(residual_fine2, n_a[2]);
							// this is process flow logic
							if (Rnext_2 < process_flow_alpha*R0_2) {
								// Смысл модификации в том что мы экономим итерации на пресмутере.
								break; // досрочно опускаемся на следующий уровень если он есть конечно.
							}
							else {
								Rprev_2 = Rnext_2;
							}
						}

						if (iter == nu2) {
							printf("level 2 limit postsmother iteration is reached\n");
						}

					}
					else {
						for (integer iter = 0; iter < nu2; iter++) {
							if (bonly_serial) {
								if (bILU2smoother == 1) {
									seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
									residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										milu0[2].zbuf[i43 + 1] = residual_fine2[i43 + 1];
									}
									lusol_1patchforRUMBA(n_a[2], milu0[2].zbuf, milu0[2].zbuf2, milu0[2]);
									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										error_approx_coarse1[i43 + 1] += (doublerealT)(milu0[2].zbuf2[i43 + 1]);
									}
								}
								else if (1 && bILU2smoother == 2) {
									seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
									residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										milu2[2].zbuf[i43 + 1] = residual_fine2[i43 + 1];
									}
									lusol_1patchforRUMBA(n_a[2], milu2[2].zbuf, milu2[2].zbuf2, milu2[2]);
									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										error_approx_coarse1[i43 + 1] += (doublerealT)(milu2[2].zbuf2[i43 + 1]);
									}
								}
								else {
									seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
								}
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
						}
					}
				}

				move_up(nu1, nu2);

				// prolongation
				// residual_r
				//doublerealT *error_approx_fine1 = new doublerealT[n_a[1] + 1];
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_fine1[ii] = 0.0;
				}

#if doubleintprecision == 1
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%lld]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%lld]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#else
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%d]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%d]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#endif

				

				prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, error_approx_fine1, error_approx_coarse1, n_a[1], n_a[2]);

				// correction
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] += error_approx_fine1[ii];
				}

				// free
				//delete[] error_approx_fine1;
				//delete[] error_approx_coarse1;
				//delete[] residual_coarse1;
				//delete[] residual_fine1;

				}



				// post smothing
				if (process_flow_logic) {


					// smother
					integer iter = 0;
					for (iter = 0; iter < nu2; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}

						//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0] , residual_fine1);
						residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);


						Rnext_1 = norma(residual_fine1, n_a[1]);
						// this is process flow logic
						if (Rnext_1 < process_flow_alpha*R0_1) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_1 = Rnext_1;
						}
					}

					if (iter == nu2) {
						printf("level 1 limit postsmother iteration is reached\n");
					}

				}
				else {
					for (integer iter = 0; iter < nu2; iter++) {
						if (bonly_serial) {
							if (bILU2smoother == 1) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
								residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu0[1].zbuf[i43 + 1] = residual_fine1[i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu0[1].zbuf, milu0[1].zbuf2, milu0[1]);
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[i43 + 1] += (doublerealT)(milu0[1].zbuf2[i43 + 1]);
								}
							}
							else if (1 && bILU2smoother == 2) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
								residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu2[1].zbuf[i43 + 1] = residual_fine1[i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu2[1].zbuf, milu2[1].zbuf2, milu2[1]);
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[i43 + 1] += (doublerealT)(milu2[1].zbuf2[i43 + 1]);
								}
							}
							else {
								seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
							}
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}
					}
				}
			}

			move_up(nu1, nu2);

			// prolongation
			// residual_r
			//doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				error_approx_fine[ii] = 0.0;
			}

			prolongation(P, 1, nnz_aRP[0], flag, error_approx_fine, error_approx_coarse, n_a[0], n_a[1]);

			//exporttecplotxy360T_3D_part2amg(x, false, 1);
			//exporttecplotxy360T_3D_part2amg(error_approx_fine, false, 1);

			// correction
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				x[ii] += error_approx_fine[ii];
			}
			//exporttecplotxy360T_3D_part2amg(x, false, 1);
			// free
			//delete[] error_approx_fine;
			//delete[] error_approx_coarse;
			//delete[] residual_coarse;
			//delete[] residual_fine;
		}



		//doublerealT R0_0 = 0.0;
		//doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		// post smothing
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
			Rprev_0 = norma(residual_fine, n_a[0]);

			// smother
			integer iter = 0;
			for (iter = 0; iter < nFinestSweeps; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
				//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
				residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
				Rnext_0 = norma(residual_fine, n_a[0]);
				// this is process flow logic
				if (Rnext_0 < process_flow_alpha*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nFinestSweeps) {
				printf("level 0 limit postsmother iteration is reached\n");
			}

		}
		else {
			// nFinnestSweeps new logic 14 jan 2016.
			// smother
			for (integer iter = 0; iter < nFinestSweeps; iter++) {
				//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					if (bILU2smoother == 1) {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
						residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);

						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu0[0].zbuf[i43 + 1] = residual_fine[i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu0[0].zbuf, milu0[0].zbuf2, milu0[0]);
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							x[i43 + 1] += milu0[0].zbuf2[i43 + 1];
						}
					}
					else if (bILU2smoother == 2) {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
						residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);

						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu2[0].zbuf[i43 + 1] = residual_fine[i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu2[0].zbuf, milu2[0].zbuf2, milu2[0]);
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							x[i43 + 1] += milu2[0].zbuf2[i43 + 1];
						}
					}
					else {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
					}
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
			}
		}


		//if (bfirst_start_nonlinear_process) {
		// Во избежании расходимости по начальному условию в двойном 
		// вакуумном промежутке.
		//bfirst_start_nonlinear_process = false;
		//break;
		//}
		if (iVar != PAM) {
			if (btheoryGuideANSYSFluent) break; // Делаем лишь один V  цикл.
		}
		//system("pause");
	}

	if (debug_reshime) system("pause");
	//system("pause");

	// Внимание: именно эта строчка обеспечивает сходимость.
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x[i47] = x_best_search[i47];
	}

	bool identiti = true;
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		if (fabs(x[i47] - x_best_search_init[i47]) > 1e-5) {
			identiti = false;
		}
	}
	if (identiti) {
		// если техника x_best_search вообще не дала результатов.
		for (integer i47 = 1; i47 <= n_a[0]; i47++) {
			x[i47] = x_best_search2[i47];
		}
	}

	// free
	delete[] x_best_search2;
	delete[] x_best_search_init;

	// free
	/*
	delete[] diag0;
	delete[] error_approx_fine;
	if (ilevel > 1) {
	delete[] diag1;
	delete[] error_approx_coarse;
	delete[] residual_coarse;
	if (ilevel > 2) {
	// free
	delete[] diag2;
	delete[] error_approx_fine1;
	delete[] error_approx_coarse1;
	delete[] residual_coarse1;
	delete[] residual_fine1;
	if (ilevel > 3) {
	// free
	delete[] diag3;
	delete[] error_approx_fine2;
	delete[] error_approx_coarse2;
	delete[] residual_coarse2;
	delete[] residual_fine2;
	if (ilevel > 4) {
	// free
	delete[] diag4;
	delete[] error_approx_fine3;
	delete[] error_approx_coarse3;
	delete[] residual_coarse3;
	delete[] residual_fine3;
	if (ilevel > 5) {
	// free
	delete[] diag5;
	delete[] error_approx_fine4;
	delete[] error_approx_coarse4;
	delete[] residual_coarse4;
	delete[] residual_fine4;
	if (ilevel > 6) {
	// free
	delete[] diag6;
	delete[] error_approx_fine5;
	delete[] error_approx_coarse5;
	delete[] residual_coarse5;
	delete[] residual_fine5;
	if (ilevel > 7) {
	// free
	delete[] diag7;
	delete[] error_approx_fine6;
	delete[] error_approx_coarse6;
	delete[] residual_coarse6;
	delete[] residual_fine6;
	if (ilevel > 8) {
	// free
	delete[] diag8;
	delete[] error_approx_fine7;
	delete[] error_approx_coarse7;
	delete[] residual_coarse7;
	delete[] residual_fine7;
	if (ilevel > 9) {
	// free
	delete[] diag9;
	delete[] error_approx_fine8;
	delete[] error_approx_coarse8;
	delete[] residual_coarse8;
	delete[] residual_fine8;
	if (ilevel > 10) {
	// free
	delete[] diag10;
	delete[] error_approx_fine9;
	delete[] error_approx_coarse9;
	delete[] residual_coarse9;
	delete[] residual_fine9;
	if (ilevel > 11) {
	// free
	delete[] diag11;
	delete[] error_approx_fine10;
	delete[] error_approx_coarse10;
	delete[] residual_coarse10;
	delete[] residual_fine10;
	if (ilevel > 12) {
	// free
	delete[] diag12;
	delete[] error_approx_fine11;
	delete[] error_approx_coarse11;
	delete[] residual_coarse11;
	delete[] residual_fine11;
	if (ilevel > 13) {
	// free
	delete[] diag13;
	delete[] error_approx_fine12;
	delete[] error_approx_coarse12;
	delete[] residual_coarse12;
	delete[] residual_fine12;
	if (ilevel > 14) {
	// free
	delete[] diag14;
	delete[] error_approx_fine13;
	delete[] error_approx_coarse13;
	delete[] residual_coarse13;
	delete[] residual_fine13;
	if (ilevel > 15) {
	// free
	delete[] diag15;
	delete[] error_approx_fine14;
	delete[] error_approx_coarse14;
	delete[] residual_coarse14;
	delete[] residual_fine14;
	if (ilevel > 16) {
	// free
	delete[] diag16;
	delete[] error_approx_fine15;
	delete[] error_approx_coarse15;
	delete[] residual_coarse15;
	delete[] residual_fine15;
	if (ilevel > 17) {
	// free
	delete[] diag17;
	delete[] error_approx_fine16;
	delete[] error_approx_coarse16;
	delete[] residual_coarse16;
	delete[] residual_fine16;
	if (ilevel > 18) {
	// free
	delete[] diag18;
	delete[] error_approx_fine17;
	delete[] error_approx_coarse17;
	delete[] residual_coarse17;
	delete[] residual_fine17;
	// free
	//delete[] diag19;
	delete[] error_approx_fine18;
	delete[] error_approx_coarse18;
	delete[] residual_coarse18;
	delete[] residual_fine18;
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	*/

	// Мы могли искусственно понизить количетсво уровней и значит память из кучи потеряется.
	// Здесь важно выполнить полное освобождение оперативной памяти из под всех имеющихся уровней. 
	// Поэтомуна данном этапе номеру уровня присваивается максимально возможное значение 11 ноября 2016.
integer ilevel_memo = ilevel; // Запоминаем текущее число уровней.
ilevel = 200;
// free
if (diag0 != nullptr) {
	free(diag0);
	diag0 = nullptr;
}
if (bnested_desection_global_amg != nullptr) {
	free(bnested_desection_global_amg);  // Глобальная память.
	bnested_desection_global_amg = nullptr;
}
if (nested_desection0 != nullptr) {
	free(nested_desection0);
	nested_desection0 = nullptr;
}
if (error_approx_fine != nullptr) {
	free(error_approx_fine);
	error_approx_fine = nullptr;
}
if (ilevel_memo > 1) {
	if (diag1 != nullptr) {
		free(diag1);
		diag1 = nullptr;
	}
	if (nested_desection1 != nullptr) {
		free(nested_desection1);
		nested_desection1 = nullptr;
	}
	if (error_approx_coarse != nullptr) {
		free(error_approx_coarse);
		error_approx_coarse = nullptr;
	}
	if (residual_coarse != nullptr) {
		free(residual_coarse);
		residual_coarse = nullptr;
	}
	if (residual_fine1 != nullptr) {
		free(residual_fine1);
		residual_fine1 = nullptr;
	}
	if (ilevel_memo > 2) {
		// free
		if (diag2 != nullptr) {
			free(diag2);
			diag2 = nullptr;
		}
		if (nested_desection2 != nullptr) {
			free(nested_desection2);
			nested_desection2 = nullptr;
		}
		if (error_approx_fine1 != nullptr) {
			free(error_approx_fine1);
			error_approx_fine1 = nullptr;
		}
		if (error_approx_coarse1 != nullptr) {
			free(error_approx_coarse1);
			error_approx_coarse1 = nullptr;
		}
		if (residual_coarse1 != nullptr) {
			free(residual_coarse1);
			residual_coarse1 = nullptr;
		}
		if (residual_fine2 != nullptr) {
			free(residual_fine2);
			residual_fine2 = nullptr;
		}
		if (ilevel_memo > 3) {
			// free
			if (diag3 != nullptr) {
				free(diag3);
				diag3 = nullptr;
			}
			if (nested_desection3 != nullptr) {
				free(nested_desection3);
				nested_desection3 = nullptr;
			}
			if (error_approx_fine2 != nullptr) {
				free(error_approx_fine2);
				error_approx_fine2 = nullptr;
			}
			if (error_approx_coarse2 != nullptr) {
				free(error_approx_coarse2);
				error_approx_coarse2 = nullptr;
			}
			if (residual_coarse2 != nullptr) {
				free(residual_coarse2);
				residual_coarse2 = nullptr;
			}
			if (residual_fine3 != nullptr) {
				free(residual_fine3);
				residual_fine3 = nullptr;
			}
			if (ilevel_memo > 4) {
				// free
				if (diag4 != nullptr) {
					free(diag4);
					diag4 = nullptr;
				}
				if (nested_desection4 != nullptr) {
					free(nested_desection4);
					nested_desection4 = nullptr;
				}
				if (error_approx_fine3 != nullptr) {
					free(error_approx_fine3);
					error_approx_fine3 = nullptr;
				}
				if (error_approx_coarse3 != nullptr) {
					free(error_approx_coarse3);
					error_approx_coarse3 = nullptr;
				}
				if (residual_coarse3 != nullptr) {
					free(residual_coarse3);
					residual_coarse3 = nullptr;
				}
				free(residual_fine4);
				if (ilevel_memo > 5) {
					// free
					if (diag5 != nullptr) {
						free(diag5);
						diag5 = nullptr;
					}
					if (nested_desection5 != nullptr) {
						free(nested_desection5);
						nested_desection5 = nullptr;
					}
					if (error_approx_fine4 != nullptr) {
						free(error_approx_fine4);
						error_approx_fine4 = nullptr;
					}
					if (error_approx_coarse4 != nullptr) {
						free(error_approx_coarse4);
						error_approx_coarse4 = nullptr;
					}
					if (residual_coarse4 != nullptr) {
						free(residual_coarse4);
						residual_coarse4 = nullptr;
					}

					free(residual_fine5);
					if (ilevel_memo > 6) {
						// free
						if (diag6 != nullptr) {
							free(diag6);
							diag6 = nullptr;
						}
						if (nested_desection6 != nullptr) {
							free(nested_desection6);
							nested_desection6 = nullptr;
						}

						if (error_approx_fine5 != nullptr) {
							free(error_approx_fine5);
							error_approx_fine5 = nullptr;
						}
						if (error_approx_coarse5 != nullptr) {
							free(error_approx_coarse5);
							error_approx_coarse5 = nullptr;
						}
						if (residual_coarse5 != nullptr) {
							free(residual_coarse5);
							residual_coarse5 = nullptr;
						}

						free(residual_fine6);
						if (ilevel_memo > 7) {
							// free
							if (diag7 != nullptr) {
								free(diag7);
								diag7 = nullptr;
							}
							if (nested_desection7 != nullptr) {
								free(nested_desection7);
								nested_desection7 = nullptr;
							}
							if (error_approx_fine6 != nullptr) {
								free(error_approx_fine6);
								error_approx_fine6 = nullptr;
							}
							if (error_approx_coarse6 != nullptr) {
								free(error_approx_coarse6);
								error_approx_coarse6 = nullptr;
							}

							if (residual_coarse6 != nullptr) {
								free(residual_coarse6);
								residual_coarse6 = nullptr;
							}

							free(residual_fine7);
							if (ilevel_memo > 8) {
								// free
								if (diag8 != nullptr) {
									free(diag8);
									diag8 = nullptr;
								}
								if (nested_desection8 != nullptr) {
									free(nested_desection8);
									nested_desection8 = nullptr;
								}
								if (error_approx_fine7 != nullptr) {
									free(error_approx_fine7);
									error_approx_fine7 = nullptr;
								}
								if (error_approx_coarse7 != nullptr) {
									free(error_approx_coarse7);
									error_approx_coarse7 = nullptr;
								}
								if (residual_coarse7 != nullptr) {
									free(residual_coarse7);
									residual_coarse7 = nullptr;
								}

								free(residual_fine8);
								if (ilevel_memo > 9) {
									// free
									if (diag9 != nullptr) {
										free(diag9);
										diag9 = nullptr;
									}
									if (nested_desection9 != nullptr) {
										free(nested_desection9);
										nested_desection9 = nullptr;
									}
									if (error_approx_fine8 != nullptr) {
										free(error_approx_fine8);
										error_approx_fine8 = nullptr;
									}
									if (error_approx_coarse8 != nullptr) {
										free(error_approx_coarse8);
										error_approx_coarse8 = nullptr;
									}
									if (residual_coarse8 != nullptr) {
										free(residual_coarse8);
										residual_coarse8 = nullptr;
									}

									free(residual_fine9);
									if (ilevel_memo > 10) {
										// free
										if (diag10 != nullptr) {
											free(diag10);
											diag10 = nullptr;
										}
										if (nested_desection10 != nullptr) {
											free(nested_desection10);
											nested_desection10 = nullptr;
										}
										if (error_approx_fine9 != nullptr) {
											free(error_approx_fine9);
											error_approx_fine9 = nullptr;
										}
										if (error_approx_coarse9 != nullptr) {
											free(error_approx_coarse9);
											error_approx_coarse9 = nullptr;
										}
										if (residual_coarse9 != nullptr) {
											free(residual_coarse9);
											residual_coarse9 = nullptr;
										}

										free(residual_fine10);
										if (ilevel_memo > 11) {
											// free
											if (diag11 != nullptr) {
												free(diag11);
												diag11 = nullptr;
											}
											if (nested_desection11 != nullptr) {
												free(nested_desection11);
												nested_desection11 = nullptr;
											}
											if (error_approx_fine10 != nullptr) {
												free(error_approx_fine10);
												error_approx_fine10 = nullptr;
											}
											if (error_approx_coarse10 != nullptr) {
												free(error_approx_coarse10);
												error_approx_coarse10 = nullptr;
											}
											if (residual_coarse10 != nullptr) {
												free(residual_coarse10);
												residual_coarse10 = nullptr;
											}

											free(residual_fine11);
											if (ilevel_memo > 12) {
												// free
												if (diag12 != nullptr) {
													free(diag12);
													diag12 = nullptr;
												}
												if (nested_desection12 != nullptr) {
													free(nested_desection12);
													nested_desection12 = nullptr;
												}
												if (error_approx_fine11 != nullptr) {
													free(error_approx_fine11);
													error_approx_fine11 = nullptr;
												}
												if (error_approx_coarse11 != nullptr) {
													free(error_approx_coarse11);
													error_approx_coarse11 = nullptr;
												}
												if (residual_coarse11 != nullptr) {
													free(residual_coarse11);
													residual_coarse11 = nullptr;
												}

												free(residual_fine12);
												if (ilevel_memo > 13) {
													// free
													if (diag13 != nullptr) {
														free(diag13);
														diag13 = nullptr;
													}
													if (nested_desection13 != nullptr) {
														free(nested_desection13);
														nested_desection13 = nullptr;
													}
													if (error_approx_fine12 != nullptr) {
														free(error_approx_fine12);
														error_approx_fine12 = nullptr;
													}
													if (error_approx_coarse12 != nullptr) {
														free(error_approx_coarse12);
														error_approx_coarse12 = nullptr;
													}
													if (residual_coarse12 != nullptr) {
														free(residual_coarse12);
														residual_coarse12 = nullptr;
													}

													free(residual_fine13);
													if (ilevel_memo > 14) {
														// free
														if (diag14 != nullptr) {
															free(diag14);
															diag14 = nullptr;
														}
														if (nested_desection14 != nullptr) {
															free(nested_desection14);
															nested_desection14 = nullptr;
														}
														if (error_approx_fine13 != nullptr) {
															free(error_approx_fine13);
															error_approx_fine13 = nullptr;
														}
														if (error_approx_coarse13 != nullptr) {
															free(error_approx_coarse13);
															error_approx_coarse13 = nullptr;
														}
														if (residual_coarse13 != nullptr) {
															free(residual_coarse13);
															residual_coarse13 = nullptr;
														}

														free(residual_fine14);
														if (ilevel_memo > 15) {
															// free
															if (diag15 != nullptr) {
																free(diag15);
																diag15 = nullptr;
															}
															if (nested_desection15 != nullptr) {
																free(nested_desection15);
																nested_desection15 = nullptr;
															}
															if (error_approx_fine14 != nullptr) {
																free(error_approx_fine14);
																error_approx_fine14 = nullptr;
															}
															if (error_approx_coarse14 != nullptr) {
																free(error_approx_coarse14);
																error_approx_coarse14 = nullptr;
															}
															if (residual_coarse14 != nullptr) {
																free(residual_coarse14);
																residual_coarse14 = nullptr;
															}
															free(residual_fine15);
															if (ilevel_memo > 16) {
																// free
																if (diag16 != nullptr) {
																	free(diag16);
																	diag16 = nullptr;
																}
																if (nested_desection16 != nullptr) {
																	free(nested_desection16);
																	nested_desection16 = nullptr;
																}
																if (error_approx_fine15 != nullptr) {
																	free(error_approx_fine15);
																	error_approx_fine15 = nullptr;
																}

																if (error_approx_coarse15 != nullptr) {
																	free(error_approx_coarse15);
																	error_approx_coarse15 = nullptr;
																}
																if (residual_coarse15 != nullptr) {
																	free(residual_coarse15);
																	residual_coarse15 = nullptr;
																}

																free(residual_fine16);
																if (ilevel_memo > 17) {
																	// free
																	if (diag17 != nullptr) {
																		free(diag17);
																		diag17 = nullptr;
																	}
																	if (nested_desection17 != nullptr) {
																		free(nested_desection17);
																		nested_desection17 = nullptr;
																	}
																	if (error_approx_fine16 != nullptr) {
																		free(error_approx_fine16);
																		error_approx_fine16 = nullptr;
																	}
																	if (error_approx_coarse16 != nullptr) {
																		free(error_approx_coarse16);
																		error_approx_coarse16 = nullptr;
																	}
																	if (residual_coarse16 != nullptr) {
																		free(residual_coarse16);
																		residual_coarse16 = nullptr;
																	}
																	free(residual_fine17);
																	if (ilevel_memo > 18) {
																		// free
																		if (diag18 != nullptr) {
																			free(diag18);
																			diag18 = nullptr;
																		}
																		if (nested_desection18 != nullptr) {
																			free(nested_desection18);
																			nested_desection18 = nullptr;
																		}
																		if (error_approx_fine17 != nullptr) {
																			free(error_approx_fine17);
																			error_approx_fine17 = nullptr;
																		}

																		if (error_approx_coarse17 != nullptr) {
																			free(error_approx_coarse17);
																			error_approx_coarse17 = nullptr;
																		}

																		if (residual_coarse17 != nullptr) {
																			free(residual_coarse17);
																			residual_coarse17 = nullptr;
																		}

																		free(residual_fine18);
																		if (ilevel_memo > 19) {
																			// free
																			//if (diag19 != nullptr) {
																			//  free(diag19);
																			// diag19 = nullptr;
																			//}
																			//if (nested_desection19 != nullptr) {
																			// free(nested_desection19);
																			//}
																			if (error_approx_fine18 != nullptr) {
																				free(error_approx_fine18);
																				error_approx_fine18 = nullptr;
																			}
																			if (error_approx_coarse18 != nullptr) {
																				free(error_approx_coarse18);
																				error_approx_coarse18 = nullptr;
																			}
																			if (residual_coarse18 != nullptr) {
																				free(residual_coarse18);
																				residual_coarse18 = nullptr;
																			}

																			//free(residual_fine19);
																		}

																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
ilevel = ilevel_memo;


// Для ускорения паралельной версии пролонгации 1.08.2021.
freeQuickProlongation();

    // освобождение оперативной памяти.
    free_level_additional_data(milu0, ilevel);
    free_level_additional_data(milu2, ilevel);

   // Освобождение общей памяти в ILU буффере.
   if (milu_gl_buffer.alu_copy != nullptr) delete[] milu_gl_buffer.alu_copy;
   if (milu_gl_buffer.jlu_copy != nullptr) delete[] milu_gl_buffer.jlu_copy;
   if (milu_gl_buffer.ju_copy != nullptr) delete[] milu_gl_buffer.ju_copy;
   milu_gl_buffer.alu_copy = nullptr;
   milu_gl_buffer.jlu_copy = nullptr;
   milu_gl_buffer.ju_copy = nullptr;

   //delete[] residual_fine;
   if (residual_fine != nullptr) {
   	  free(residual_fine);
	  residual_fine = nullptr;
   }

   //delete[] row_ptr_start;
   //delete[] row_ptr_end;
   if (row_ptr_start != nullptr) {
	   free(row_ptr_start);
	   row_ptr_start = nullptr;
   }
   if (row_ptr_end != nullptr) {
	   free(row_ptr_end);
	   row_ptr_end = nullptr;
   }


   //delete[] flag_shadow;
   if (flag_shadow != nullptr) {
 	  free(flag_shadow);
	  flag_shadow = nullptr;
   }

   //delete[] flag;
   if (flag != nullptr) {
	  free(flag);
      flag = nullptr;
   }

   //delete[] flag85;
   if (flag85 != nullptr) {
	   free(flag85);
	   flag85 = nullptr;
   }

   if (x_copy != nullptr) {
	   free(x_copy);
	   x_copy = nullptr;
   }
   if (x_best_search != nullptr) {
      free(x_best_search);
      x_best_search = nullptr;
    }
	
    // Для подстраховки:

    if (row_ptr_start != nullptr) {
	    free(row_ptr_start);
    	row_ptr_start = nullptr;
    }
    if (row_ptr_end != nullptr) {
	    free(row_ptr_end);
	    row_ptr_end = nullptr;
    }

	if (x_jacoby_buffer != nullptr) {
		delete[] x_jacoby_buffer;
		x_jacoby_buffer = nullptr;
	}

	//return false;
	return ret_value;

} // classic_aglomerative_amg5



/*
  // 9 декабря 2015 для 3D повидимому требуется АВЛ дерево, т.к. в 3D 
  // очень большое число соседей. Начинаем разработку такого кода.
  // 21 окт 2015. Нужно реализовать Писсанецки и Густавсона, поиск можно сделать через хеш.
  // 6 september 2015 кажется заработало.
integer main()
//integer _tmain(integer argc, _TCHAR* argv[])
{

	// тестирование АВЛ дерева 12 декабря 2015.
	//test_AVL();

	//errno_t err;
	//FILE* fp;
	//err = fopen_s(&fp, "report_stat.txt", "a");

	//doublerealT mul_theta = 0.131; // 0.111 optimal 20step
	//for (integer i_1 = 1; i_1 <= 120; i_1++) {
	//mul_theta -= 0.001;
	//fprintf_s(fp, "%1.5f ", mul_theta);
	//for (integer i_2 = 1; i_2 <= 5; i_2++) {

	//float ts = clock();



	// Тестовая обвязка.
	// недостаток данного тестирования отсутствие условий Неймана, условий задания ненулевого теплового потока.
	// Отсутствие сборки на примере матрицы полученной аппроксимацией конвективной задачи с одной из противопоточных схем.
	// 14 сентября 2015 года реальное тестирование на примере расчёта теплового сопротивления транзисторной структуры, 
	// вставляем код в AliceFlow.

	// Условия Неймана действительно сильно замедляют сходимость. Пока можно сказать что константа 1/16  не подходит и с ней 
	// алгоритм расходится.


	// 30min 25s 40x40x40. (7min 50s Писанецки) (1min 18s , 3min 32s Густавсон) (1min 04s Густавсон от сети)
	// 6min 201x201 5.40 lite and quick  15 it
	// 201x201  37.132, 35.761
	// Густавсон ускорение 50.0% по сравнению с версией 0.04.
	// 1.01min 121x121 v0_03time=29.983, v0_04time=20.116; PGO=19.695. (v0_05=12.136 Густавсон).

	// m=81; 9.3Mb.
	// m=101; 14.3Mb.
	// speed up 38%
	// Идея Писсанецки ускорила код на 15% от версии 0.04.
	// time cube (40) 33.54s 
	// Сравнение быстродействия cube(40) от сети:
	// 3D 1min 12s. (11 iteracii)
	// 2D  1000  28.5c
	// 3D 120 36.1% 34%  11min. 
	integer m = 120; // 37.6с     (Слияние 2.24-2.29min) (2.02-2.07 Писсанецки).
	doublerealT h = 1.0 / (m - 1);
	doublerealT h2 = h*h;

	// 4040

	doublerealT theta = 0.25; // Контроль числа сильных связей между переменными.

	const integer dim_2D = 0;

	// 8 декабря 2015 Единый параметр theta=0.25 и для 2D и для 3D. 
	switch (dim_2D) {
	case 1: theta = 0.25; break; // 2D
	case 0: theta = 0.25; break; // 3D
	}

	Ak1* Amat = nullptr;
	//Ak1* Atemp = nullptr;
	//Ak1* Atemp2 = nullptr;
	Ak1* R = nullptr;
	Ak1* P = nullptr;
	integer n, nnz;
	doublerealT* x = nullptr;
	doublerealT* b = nullptr;

	if (0) {
		// 18 ноября реальное тестирование с привлечением кода DavisTestDelphi.

		FILE* fp;
		errno_t err;
		if ((err = fopen_s(&fp, "amg_input.txt", "r")) != 0) {
			printf("error input file: amg_input.txt \n");
			//getchar();
			system("pause");
			exit(1);
		}
		else {
			integer din = 0;
			float fin = 0.0;

			#if doubleintprecision == 1
				fscanf_s(fp, "%lld", &din);
				n = din;
				printf("%lld\n", n);
			#else
				fscanf_s(fp, "%d", &din);
				n = din;
				printf("%d\n", n);
			#endif

			
			system("pause");
			x = new doublerealT[n + 1]; // решение.
			for (integer i = 0; i <= n; i++) x[i] = 0.0; // инициалзация.

			b = new doublerealT[n + 1]; // Правая часть.
			b[0] = 0.0;
			for (integer i_1 = 1; i_1 <= n; i_1++) {
				fscanf_s(fp, "%f", &fin);
				b[i_1] = fin;
			}
			#if doubleintprecision == 1
				fscanf_s(fp, "%lld", &din);
				nnz = din;
				printf("nnz=%lld\n", nnz);
			#else
				fscanf_s(fp, "%d", &din);
				nnz = din;
				printf("nnz=%d\n", nnz);
			#endif

			
			system("pause");
			// 31 aug 2015
			Amat = new Ak1[8 * nnz + 1];
			//Atemp = new Ak1[3 * nnz + 1];
			//Atemp2 = new Ak1[3 * nnz + 1];
			R = new Ak1[10 * n + 1];
			P = new Ak1[10 * n + 1];
			integer i_2 = 1;
			for (integer i_1 = 1; i_1 <= nnz; i_1++) {
				fscanf_s(fp, "%f", &fin);
				if (fabs(fin) > 1.0e-30) {
					Amat[i_2].aij = fin;
					#if doubleintprecision == 1
						fscanf_s(fp, "%lld", &din);
						Amat[i_2].i = din;
						fscanf_s(fp, "%lld", &din);
					#else
						fscanf_s(fp, "%d", &din);
						Amat[i_2].i = din;
						fscanf_s(fp, "%d", &din);
					#endif
					
					Amat[i_2].j = din;
					i_2++;
				}
				else {
				#if doubleintprecision == 1
					fscanf_s(fp, "%lld", &din);
					fscanf_s(fp, "%lld", &din);
				#else
					fscanf_s(fp, "%d", &din);
					fscanf_s(fp, "%d", &din);
				#endif
					
				}
			}
			nnz = i_2 - 1;
			#if doubleintprecision == 1
				printf("nnz=%lld\n", nnz);
			#else
				printf("nnz=%d\n", nnz);
			#endif
			
			system("pause");

			fclose(fp);
			classic_aglomerative_amg2(Amat, nnz, n, R, P,  x, b, theta);
		}
	}
	else {


		if (dim_2D) {
			// Finite Volume Method matrix assemble. 6 september 2015

			#if doubleintprecision == 1
				printf("%lldx%lld\n", m, m);
			#else
				printf("%dx%d\n", m, m);
			#endif
			



			n = m*m;
			nnz = 5 * ((m - 2)*(m - 2)) + 4 + 4 * (m - 2);
			#if doubleintprecision == 1
				printf("nnz=%lld\n", nnz);
			#else
				printf("nnz=%d\n", nnz);
			#endif
			
			//getchar();

			// 31 aug 2015
			Amat = new Ak1[8 * nnz + 1];
			//Atemp = new Ak1[3 * nnz + 1];
			//Atemp2 = new Ak1[3 * nnz + 1];
			R = new Ak1[10 * n + 1];
			P = new Ak1[10 * n + 1];
			// 19684 3*n+1.
			#if doubleintprecision == 1
				//printf("%lld",3*n+1);
			#else
				//printf("%d",3*n+1);
			#endif
			
			//getchar();
			integer ic = 1;
			for (integer i = 1; i <= m; i++) {
				for (integer j = 1; j <= m; j++) {
					if ((i > 1) && (j > 1) && (i < m) && (j < m)) {
						//Amat[ic].aij = 4.0 / h2;
						Amat[ic].aij = 4.0; // h/h
						Amat[ic].i = (i - 1)*m + j;
						Amat[ic].j = (i - 1)*m + j;
						ic++;
						//Amat[ic].aij = -1.0 / h2;
						Amat[ic].aij = -1.0;
						Amat[ic].i = (i - 1)*m + j;
						Amat[ic].j = (i - 1)*m + j + 1;
						ic++;
						//Amat[ic].aij = -1.0 / h2;
						Amat[ic].aij = -1.0;
						Amat[ic].i = (i - 1)*m + j;
						Amat[ic].j = (i - 1)*m + j - 1;
						ic++;
						//Amat[ic].aij = -1.0 / h2;
						Amat[ic].aij = -1.0;
						Amat[ic].i = (i - 1)*m + j;
						Amat[ic].j = (i - 1)*m + j + m;
						ic++;
						//Amat[ic].aij = -1.0 / h2;
						Amat[ic].aij = -1.0;
						Amat[ic].i = (i - 1)*m + j;
						Amat[ic].j = (i - 1)*m + j - m;
						ic++;
					}
					if (((i == m) && (j == m)) || ((i == m) && (j == 1)) || ((i == 1) && (j == m)) || ((i == 1) && (j == 1)) || ((i == 1) && (j > 1) && (j < m)) || ((i == m) && (j>1) && (j < m)) || ((j == 1) && (i>1) && (i < m)) || ((j == m) && (i>1) && (i < m))) {
						Amat[ic].aij = 1.0;
						Amat[ic].i = (i - 1)*m + j;
						Amat[ic].j = (i - 1)*m + j;
						ic++;

					}
				}
			}

			#if doubleintprecision == 1
				printf("nnz=%lld ic-1=%lld\n", nnz, ic - 1);
			#else
				printf("nnz=%d ic-1=%d\n", nnz, ic - 1);
			#endif
			


			x = new doublerealT[n + 1]; // решение.
			for (integer i = 0; i <= n; i++) x[i] = 0.0;
			b = new doublerealT[n + 1]; // Правая часть.

			ic = 1;
			for (integer i = 1; i <= m; i++) {
				for (integer j = 1; j <= m; j++) {
					if ((i > 1) && (j > 1) && (i < m) && (j < m)) {
						b[ic++] = 8.0*M_PI*M_PI*sin(2 * M_PI*(i - 1)*h)*sin(2 * M_PI*(j - 1)*h)*h2;
					}
					if (((i == m) && (j == m)) || ((i == m) && (j == 1)) || ((i == 1) && (j == m)) || ((i == 1) && (j == 1)) || ((i == 1) && (j > 1) && (j < m)) || ((i == m) && (j>1) && (j < m)) || ((j == 1) && (i>1) && (i < m)) || ((j == m) && (i>1) && (i < m))) {
						b[ic++] = sin(2 * M_PI*(i - 1)*h)*sin(2 * M_PI*(j - 1)*h);
					}
				}
			}

		}
		else {
			// 6 сентября пляж РИМИНИ

			// Finite volume method matrix assemble. 
			// volume = h2*h; Square=h2; delta_x=delta_y=delta_z=h;
			// диагональный член положителен остальные отрицательны.

			// 3D
			n = m*m*m;
			nnz = 7 * ((m - 2)*(m - 2)*(m - 2)) + 8 + 6 * (m - 2)*(m - 2) + 12 * (m - 2);
			// куб: 8 вершин, 12 рёбер, 6 граней.

			#if doubleintprecision == 1
				printf("%lldx%lldx%lld\n", m, m, m);
				printf("nnz=%lld\n", nnz);
			#else
				printf("%dx%dx%d\n", m, m, m);
				printf("nnz=%d\n", nnz);
			#endif
			

			// 31 aug 2015
			// 6 3 3 с запасом. реально 4.52 2.26 2.26
			// real size 22.6 on thermal resistance.
			Amat = new Ak1[(integer)(13 * nnz) + 1]; // 6
												 // Иногда на следующем уровне вложенности число ненулевых элементов больше чем 
												 // в начальной матрице.
												 // real size 9.4 for resistor thermal resistor.
												 // 
												 //Atemp = new Ak1[3 * nnz + 1];
												 // real size 9.4 for resistor thermal resistor.
												 //Atemp2 = new Ak1[3 * nnz + 1];
			R = new Ak1[(integer)(10 * n) + 1]; // 3*nnz 2.4
			P = new Ak1[(integer)(10 * n) + 1]; // 3*nnz 2.4
			integer ic = 1;
			for (integer i = 1; i <= m; i++) {
				for (integer j = 1; j <= m; j++) {
					for (integer k = 1; k <= m; k++) {
						if ((i > 1) && (j > 1) && (k > 1) && (i < m) && (j < m) && (k < m)) {
							Amat[ic].aij = 6.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j;
							ic++;
							Amat[ic].aij = -1.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j + 1;
							ic++;
							Amat[ic].aij = -1.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j - 1;
							ic++;
							Amat[ic].aij = -1.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j + m;
							ic++;
							Amat[ic].aij = -1.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j - m;
							ic++;
							Amat[ic].aij = -1.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j + m*m;
							ic++;
							Amat[ic].aij = -1.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j - m*m;
							ic++;
						}
						else {
							//if (((i == m) && (j == m)) || ((i == m) && (j == 1)) || ((i == 1) && (j == m)) || ((i == 1) && (j == 1)) || ((i == 1) && (j > 1) && (j < m)) || ((i == m) && (j>1) && (j < m)) || ((j == 1) && (i>1) && (i < m)) || ((j == m) && (i>1) && (i < m))) {
							Amat[ic].aij = 1.0;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j;
							ic++;

						}
					}
				}
			}

			#if doubleintprecision == 1
				printf("nnz=%lld ic-1=%lld\n", nnz, ic - 1);
			#else
				printf("nnz=%d ic-1=%d\n", nnz, ic - 1);
			#endif
			


			x = new doublerealT[n + 1]; // решение.
			for (integer i = 0; i <= n; i++) x[i] = 0.0; // инициалзация.
			b = new doublerealT[n + 1]; // Правая часть.

			ic = 1;
			for (integer i = 1; i <= m; i++) {
				for (integer j = 1; j <= m; j++) {
					for (integer k = 1; k <= m; k++) {
						if ((i > 1) && (j > 1) && (k > 1) && (i < m) && (j < m) && (k < m)) {
							b[ic++] = 16.0*M_PI*M_PI*M_PI*sin(2 * M_PI*(i - 1)*h)*sin(2 * M_PI*(j - 1)*h)*sin(2 * M_PI*(k - 1)*h)*h2*h;
						}
						else {
							//if (((i == m) && (j == m)) || ((i == m) && (j == 1)) || ((i == 1) && (j == m)) || ((i == 1) && (j == 1)) || ((i == 1) && (j>1) && (j < m)) || ((i == m) && (j>1) && (j < m)) || ((j == 1) && (i>1) && (i < m)) || ((j == m) && (i>1) && (i < m))) {
							b[ic++] = sin(2 *M_PI*(k - 1)*h)*sin(2 * M_PI*(i - 1)*h)*sin(2 *M_PI*(j - 1)*h);
						}
					}
				}
			}
		}

		classic_aglomerative_amg2(Amat, nnz, n, R, P,  x, b, theta);
	}



	// m in 3D memorysize mb
	// 21  14.8Mb
	// 31  49.7Mb
	// 41  119.4Mb

	//getchar();
	delete[] Amat;
	delete[] R;
	delete[] P;
	//delete[] Atemp;
	//delete[] Atemp2;
	delete[] x;
	delete[] b;

	// 2D m=81 debug от акумулятора. 
	// nu1=1 nu2=0 47.904
	// nu1=1 nu2=1 34.548
	// nu1=2 nu2=1 29.465
	// nu1=2 nu2=2 27.76
	// 2D m=81 realese от акумулятора.
	// nu1=2 nu2=1 8.898
	// nu1=2 nu2=2 8.109
	// nu1=3 nu2=2 7.247
	// nu1=3 nu2=3 6.962
	// nu1=4 nu2=3 6.555 6.799
	// seidelq 1 level
	// nu1=4 nu2=3 5.691 5.605 
	// от сети.
	// seidelq 2 level
	// nu1=4 nu2=3 1.121 1.9 1.672
	// 1.9 792 0.982
	// 1.174 273 0.94248 // оставлен residual на втором левеле а не residualq.
	// от аккумулятора.
	// nu1=4 nu2=3 3.412  оставлен residual на втором левеле а не residualq.
	// nu1=4 nu2=3 5.503 residualq.
	// оставлен residual на втором левеле а не residualq.
	// m=81 12 level
	// nu1=4 nu2=3 2.916 3.081 2.899 2.89
	// nu1=4 nu2=3 2.487  (третий патч 1.715)


	// от акумулятора 1.091
	//(msvcr120.dll 3.94 2.06 2.33 3.1) 1.234 1.072
	// 2.893 2.788 2.892 2.8 2.814
	// m=121 от акумулятора. 13 level.
	// 2.556 2.546 2.627 2.533 2.602 2.501 2.542 2.487 2.589 5.131
	// 1.686 1.742 от сети. 1.763
	// m=221 2D 14 level
	// 33.857 32.649 (6.809s 3 патча. 6.984).


	// m=24 3D от сети
	// без патча 957мс.
	// без патча m=48 8.713c. с патчем 5.7s. 110тыс узлов.

	// etalon 27s. или 36с. от сети. etalon 47s от аккумулятора.
	// m=100 3D 1 million nodes
	// 15 level 117 iteration.
	// 2 min 42s. в 6 раз медленнее.
	// 47.16s от сети. 47.276
	//system("pause");

	// time
	// 1000x1000  1min 19s. 16 iteracii
	// 1000x1000 1min 28s 19 iteracii
	// 1000x1000 1 min 26 s 23 iteracii
	// 1M 0.5Gb 3D 100x100x100 11min 31s 200 iteracii
	// 1.7M 1.8Gb  3D 120x120x120 25min 317 iteracii
	//float t_calc = clock() - ts;
	//fprintf_s(fp, " %1.8f", t_calc);
	//}
	//fprintf_s(fp, "\n");
	//}

	//fclose(fp);
	return 0;
}

*/


// Здесь содержится обвязка вызывающая РУМБА.
// локальное выделение памяти:всё внутри, многократные alloc и free.
// РУМБА для решения задачи напряженно-деформированнного состояния.
// Нет сходимости. Дата успешного подключения 24 сентября 2017.
void my_agr_amg_loc_memory_Stress_old(SIMPLESPARSE &sparseM, integer n,
	doublereal* &dV, doublereal* &dX0,
	QuickMemVorst& m, BLOCK* &b, int &lb, 
	int *& whot_is_block)
{

	// 11 января 2016. классический агломеративный алгебраический многосеточный метод.
	// Это моя собственная разработка РУМБА 0.14.
	//if (iVar != PAM) {
	//doublereal theta82 = 0.24;
	//doublereal theta83 = 0.23;
	//doublereal magic82 = 0.4;
	//doublereal magic83 = 0.5; 
	//doublereal ret74 = 0.0;
	//-->doublereal theta82 = 0.24;// 0.25; //0.24
	//-->doublereal theta83 = 0.23;// 0.25; // 0.23
	// 0.3 0.4 0.44 0.45  0.5
	// 16  25   38        17
	//--->doublereal magic82 = 0.4; // 0.35; // 0.4 // 0.43
	//----->doublereal magic83 = 0.4;// 0.35; // 0.42

	doublereal theta82 = my_amg_manager.theta;
	doublereal theta83 = my_amg_manager.theta;
	doublereal magic82 = my_amg_manager.magic;
	doublereal magic83 = my_amg_manager.magic;

	doublereal ret74 = 0.0;

	my_amg_manager.theta = (real_mix_precision)(my_amg_manager.theta_Stress);
	my_amg_manager.maximum_delete_levels = my_amg_manager.maximum_delete_levels_Stress;
	my_amg_manager.nFinnest = my_amg_manager.nFinnest_Stress;
	my_amg_manager.nu1 = my_amg_manager.nu1_Stress;
	my_amg_manager.nu2 = my_amg_manager.nu2_Stress;
	my_amg_manager.memory_size = my_amg_manager.memory_size_Stress;
	my_amg_manager.ilu2_smoother = my_amg_manager.ilu2_smoother_Stress;
	my_amg_manager.icoarseningtype = my_amg_manager.icoarseningStress; // standart vs RS 2.
	my_amg_manager.istabilization = my_amg_manager.istabilizationStress; // Stabilization: 0 - none, 1 - bicgstab + amg (РУМБА).
	my_amg_manager.magic = my_amg_manager.F_to_F_Stress; // magic
	my_amg_manager.number_interpolation_procedure = my_amg_manager.number_interpolation_procedure_Stress;
	my_amg_manager.iCFalgorithm_and_data_structure=my_amg_manager.iCFalgorithm_and_data_structure_Stress;
	my_amg_manager.iprint_log = my_amg_manager.iprint_log_Stress;
	my_amg_manager.itruncation_interpolation = my_amg_manager.itruncation_interpolation_Stress;
	my_amg_manager.truncation_interpolation = my_amg_manager.truncation_interpolation_Stress;
	my_amg_manager.gold_const = my_amg_manager.gold_const_Stress;
	my_amg_manager.b_gmres = my_amg_manager.b_gmresStress;
	my_amg_manager.bMatrixPortrait = my_amg_manager.bStressMatrixPortrait;
	my_amg_manager.bcf_reorder = my_amg_manager.bcf_reorder_Stress;
	my_amg_manager.bthreshold_auto = my_amg_manager.bthreshold_Stress_auto;


	// Замер времени.
	unsigned int calculation_main_start_time; // начало счёта мс.
	unsigned int calculation_main_end_time; // окончание счёта мс.

	calculation_main_start_time = clock(); // момент начала счёта.

#ifdef _OPENMP
	
	int i_my_num_core_parallelesation = omp_get_max_threads();
	omp_set_num_threads(8); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#else
	int i_my_num_core_parallelesation = 1;
#endif

	doublereal nonzeroEPS = 1e-37; // для отделения вещественного нуля

	// На случай если память не была выделена.
	if (dX0 == nullptr) {
		dX0 = new doublereal[n];
		for (integer i = 0; i<n; i++) {
			dX0[i] = 0.0;
		}
	}

	//const integer id = 0;

	simplesparsetoCRS(sparseM, m.val, m.col_ind, m.row_ptr, n); // преобразование матрицы из одного формата хранения в другой.
																//m.ballocCRScfd = true;
	simplesparsefree(sparseM, n);

	integer ierr = 0;
	//doublereal eps = 1.0e-12; // рекомендуемое значение которого достаточно. 

	ierr = 0; // изначальное состояние безошибочное.
			  // Порог точности решения СЛАУ. Значение 1.0E-12 достаточно что проверено в ANSYS icepak.
	//eps = 1.0e-12; // рекомендуемое значение которого достаточно. 

				   // Требования к оперативной памяти.
				   /*     VECTOR         NEEDED LENGTH (GUESS) */
				   /*       Amat               3*NNA + 5*NNU */
				   /*       JA              3*NNA + 5*NNU */
				   /*       IA              2.2*NNU */
				   /*       U               2.2*NNU */
				   /*       F               2.2*NNU */
				   /*       IG              5.4*NNU */

	integer nna = 0;
	for (integer k = 0; k < m.row_ptr[n]; k++) {

		if (fabs(m.val[k]) > nonzeroEPS) {
			nna++;
		}
	}
	//printf("nna=%d istinnoe=%d\n", nna, m.row_ptr[n]);
	//getchar();
	//integer nna = m.row_ptr[n]; // количество ненулевых элементов в матрице СЛАУ.



	integer nnu = n; // число неизвестных.

					 // данная константа работоспособна вплоть до размерностей сетки равных 34млн 463тысячи 250узлов.
					 //doublerealT rsize=1.51; // 1048416
					 // Вынужденные течения достаточно 2.5.
					 // значения 3.5 недостаточно для 8 модулей Пионер. 
	//doublerealT rsize = 4.5; // на задаче Концевого Ю.А. Электростатика со столбиком в случае сетки со сгущением достаточно 2.0.
	/*
	integer nda = 0; // память под вектор значений матрицы слау.
	nda = (integer)(rsize*(3 * (nna)+5 * (nnu)));
	integer ndia = 0;
	ndia = (integer)(rsize*2.2*(nnu));
	integer ndja = 0;
	ndja = (integer)(rsize*(3 * (nna)+5 * (nnu)));
	integer ndu = 0;
	ndu = (integer)(rsize*2.2*(nnu));
	integer ndf = 0;
	ndf = (integer)(rsize*2.2*(nnu));
	integer ndig = 0;
	ndig = (integer)(rsize*5.4*(nnu));
	*/


	/*     CLASS 3 - PARAMETERS: */

	/*     LEVELX   -   MAXIMUM NUMBER OF MG-LEVELS TO BE CREATED (>=1). */

	/*     IFIRST   -   PARAMETER FOR FIRST APPROXIMATION. */

	/*                  1ST DIGIT OF IFIRST: NOT USED; HAS TO BE NON-ZERO. */

	/*                  2ND DIGIT OF IFIRST  --  ITYPU: */
	/*                    =0: NO SETTING OF FIRST APPROXIMATION, */
	/*                    =1: FIRST APPROXIMATION CONSTANT TO ZERO, */
	/*                    =2: FIRST APPROXIMATION CONSTANT TO ONE, */
	/*                    =3: FIRST APPROXIMATION IS RANDOM FUNCTION WITH */
	/*                        THE CONCRETE RANDOM SEQUENCE BEING DETERMINED */
	/*                        BY THE FOLLWING DIGITS. */

	/*                  REST OF IFIRST  --  RNDU: */
	/*                    DETERMINES THE CONCRETE RANDOM SEQUENCE USED IN */
	/*                    THE CASE ITYPU=3. (IFIRST=13 IS EQUIVALENT TO */
	/*                    IFIRST=1372815) */

	/*     NCYC     -   INTEGER PARAMETER DESCRIBING THE TYPE OF CYCLE TO BE */
	/*                  USED AND THE NUMBER OF CYCLES TO BE PERFORMED. */

	/*                  1ST DIGIT OF NCYC  --  IGAM: */
	/*                    =1: V -CYCLE, */
	/*                    =2: V*-CYCLE, */
	/*                    =3: F -CYCLE, */
	/*                    =4: W -CYCLE. */
	/*                  IF NCYC IS NEGATIV, THEN THE APPROXIMATION OF THE */
	/*                  PROBLEM ON THE SECOND FINEST GRID IS COMPUTED BY */
	/*                  IGAM V-CYCLES ON THAT PARTICULAR GRID. */

	/*                  2ND DIGIT OF NCYC  --  ICGR: */
	/*                    =0: NO CONJUGATE GRADIENT, */
	/*                    =1: CONJUGATE GRADIENT (ONLY FIRST STEP OF CG), */
	/*                    =2: CONJUGATE GRADIENT (FULL CG). */

	/*                  3RD DIGIT OF NCYC  --  ICONV: */
	/*                    CONVERGENCE CRITERION FOR THE USER-DEFINED PROBLEM */
	/*                    (FINEST GRID): */
	/*                    =1: PERFORM Amat FIXED NUMBER OF CYCLES AS GIVEN BY */
	/*                        NCYCLE (SEE BELOW) */
	/*                    =2: STOP, IF  ||RES|| < EPS */
	/*                    =3: STOP, IF  ||RES|| < EPS * |F| */
	/*                    =4: STOP, IF  ||RES|| < EPS * |U| * |DIAG| */
	/*                    WITH ||RES|| = L2-NORM OF RESIDUAL, */
	/*                           EPS     (SEE INPUT PARAMETER EPS) */
	/*                           |F|   = SUPREMUM NORM OF RIGHT HAND SIDE */
	/*                           |U|   = SUPREMUM NORM OF SOLUTION */
	/*                         |DIAG|  = MAXIMAL DIAGONAL ENTRY IN MATRIX L */
	/*                    NOTE THAT IN ANY CASE THE SOLUTION PROCESS STOPS */
	/*                    AFTER AT MOST NCYCLE CYCLES. */

	/*                  REST OF NCYC  --  NCYCLE: */
	/*                    MAXIMAL NUMBER OF CYCLES TO BE PERFORMED (>0) OR */
	/*                    NCYCLE=0: NO CYCLING. */

	/*     EPS      -   CONVERGENCE CRITERION FOR SOLUTION PROCESS: (SEE */
	/*                  PARAMETER NCYC). NOTE THAT NO MORE THAN NCYCLE CYCLES */
	/*                  ARE PERFORMED, REGARDLESS OF EPS. */

	/*     MADAPT   -   INTEGER VALUE SPECIFYING THE CHOICE OF COARSEST */
	/*                  GRID IN CYCLING: */

	/*                  1ST DIGIT OF MADAPT  --  MSEL: */
	/*                    =1: IN CYCLING, ALL GRIDS CONSTRUCTED IN THE SETUP */
	/*                        PHASE ARE USED WITHOUT CHECK. */
	/*                    =2: THE NUMBER OF GRIDS IS AUTOMATICALLY REDUCED */
	/*                        IF THE CONVERGENCE FACTOR ON THE COARSER GRIDS */
	/*                        IS FOUND TO BE LARGER THAN Amat GIVEN VALUE FAC */
	/*                        (SEE BELOW). */

	/*                  REST OF MADAPT  --  FAC */
	/*                        THE REST OF MADAPT DEFINES THE FRACTIONAL PART */
	/*                        OF Amat REAL NUMBER FAC BETWEEN 0.1 AND 0.99, E.G. */
	/*                        MADAPT=258 MEANS MSEL=2 AND FAC=0.58. IF MADAPT */
	/*                        CONSISTS OF ONLY ONE DIGIT, FAC IS SET TO 0.7 */
	/*                        BY DEFAULT. */


	/*     NRD      -   PARAMETER DESCRIBING RELAXATION (DOWNWARDS): */

	/*                  1ST DIGIT OF NRD: NOT USED; HAS TO BE NON-ZERO. */

	/*                  2ND DIGIT OF NRD  --  NRDX: */
	/*                    ACTUAL NUMBER OF SMOOTHING STEPS TO BE PERFORMED */
	/*                    THE TYPE OF WHICH IS GIVEN BY THE FOLLOWING DIGITS */

	/*                  FOLLOWING DIGITS  --  ARRAY NRDTYP: */
	/*                    =1: RELAXATION OVER THE F-POINTS ONLY */
	/*                    =2: FULL GS SWEEP */
	/*                    =3: RELAXATION OVER THE C-POINTS ONLY */
	/*                    =4: FULL MORE COLOR SWEEP, HIGHEST COLOR FIRST */

	/*     NSOLCO   -   PARAMETER CONTROLLING THE SOLUTION ON COARSEST GRID: */

	/*                  1ST DIGIT  --  NSC: */
	/*                    =1: GAUSS-SEIDEL METHOD */
	/*                    =2: DIRECT SOLVER (YALE SMP) */

	/*                  REST OF NSOLCO  --  NRCX: (ONLY IF NSC=1) */
	/*                  NUMBER OF GS SWEEPS ON COARSEST GRID (>=0). */
	/*                  IF NRCX=0, THEN AS MANY GS SWEEPS ARE PERFORMED */
	/*                  AS ARE NEEDED TO REDUCE THE RESIDUAL BY TWO ORDERS */
	/*                  OF MAGNITUDE. (MAXIMAL 100 RELAXATION SWEEPS) */

	/*     NRU      -   PARAMETER FOR RELAXATION (UPWARDS), ANALOGOUS TO NRD. */

	/*         -------------------------------------------------------------- */

	/*     CLASS 4 - PARAMETERS: */

	/*     ECG1,ECG2-   REAL PARAMETERS AFFECTING THE CREATION OF COARSER */
	/*     EWT2     -   GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
	/*                  THE CHOICE OF THESE PARAMETERS DEPENDS ON */
	/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

	/*     NWT      -   INTEGER PARAMETER AFFECTING THE CREATION OF COARSER */
	/*                  GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
	/*                  THE CHOICE OF THIS PARAMETER DEPENDS ON */
	/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

	/*     NTR      -   PARAMETER CONTROLLING COARSE-GRID OPERATOR TRUNCATION */
	/*                    =0: PAIRS OF ZEROES ARE REMOVED FROM COARSE GRID */
	/*                        OPERATORS */
	/*                    =1: NO COARSE-GRID OPERATOR TRUNCATION */



	/*     STANDARD CHOICES OF PARAMETERS (AS FAR AS MEANINGFUL): */

	/*          ISWTCH = 4 */
	/*          IOUT   = 12 */
	/*          IPRINT = 10606 */

	/*          LEVELX = 25 */
	/*          IFIRST = 13 */
	/*          NCYC   = 10110 */
	/*          EPS    = 1.D-12 */
	/*          MADAPT = 27 */
	/*          NRD    = 1131 */
	/*          NSOLCO = 110 */
	/*          NRU    = 1131 */

	/*          ECG1   = 0. */
	/*          ECG2   = 0.25 */
	/*          EWT2   = 0.35 */
	/*          NWT    = 2 */
	/*          NTR    = 0 */



	// рекомедуемые параметры по дефолту.
/*
	integer iswtch = 0;
	iswtch = 4;
	integer iout = 0;
	iout = 13; // 13 обеспечивает печать изменения невязки в процессе счёта.
	integer iprint = 0;
	iprint = 10606;
	integer levelx = 0;
	levelx = 25;
	integer ifirst = 0;
	// начальное приближение:
	// 0 - используется из вне.
	// 1 - нулевое.
	// 2 - единицы.
	// 3 - случайная последовательность.
	ifirst = 13;//13 по умолчанию.
				//ifirst=11; // нулевое начальное приближение.
				//ifirst=10; // вроде как начальное приближение берётся из dX0.
				// но 10 никоим образом не улучшает сходимость.
	integer ncyc = 0;
	ncyc = 10110;
	integer madapt = 0;
	madapt = 27;
	integer nrd = 0;
	nrd = 1131;
	integer nsolco = 0;
	nsolco = 110;
	integer nru = 0;
	nru = 1131;
	doublereal ecg1 = 0.0;
	ecg1 = 0.0;
	doublereal ecg2 = 0.0;
	ecg2 = 0.25;
	doublereal ewt2 = 0.0;
	ewt2 = 0.35;
	integer nwt = 0;
	nwt = 2;
	integer ntr = 0;
	ntr = 0;

	integer matrix = 0;
	matrix = 11; // symmetric SPD.
				 //matrix = 22;
	ncyc = 10199;
	*/

    Ak1* Amat = nullptr;
    Ak1* R = nullptr;
    Ak1* P = nullptr;
    //Ak1* Atemp = nullptr;
    //Ak1* Atemp2 = nullptr;
    doublereal* rthdsd_amg = nullptr;
    doublereal* result_amg = nullptr;
    // 18 августа 2016
    // граничные узлы требуют особой обработки.
    // true - граничный узел, false - внутренний.
    bool* bamg_bound = nullptr;

	// allocate memory.
	// allocate memory 2 jan 2016.
	// BSK Dmitrii 3.012  (2.892 для прямой интерполяции с элементами непрямой). 
	// tgf series no metalization
	// tgf2023-2_01 2.64 643mb
	// tgf2023-2-02 2.58 988mb
	// tgf2023-2-05 2.44 2022mb
	// tgf2023-2-20 3.58 2967mb
	// CGHV1J metalization 3.133 (2.84 для прямой интерполяции с элементами непрямой). 
	// тор Докторович 2.89
	// Концевой 3.05
	// Концевой со столбиком 3.7М 2.97 (6.0 у amg1r5) 4110.6Мb.
	// Вывод: максимальное значение 3.15 а значит значения 4 должно хватить с запасом У amg1r5 максимальное значение 9.0.
	// Можно сказать что данный amg требует вдвое меньше памяти по сравнению с amg1r5.
	// Была найдена статья в интернете которая подтверждала что константа памяти у amg1r5 равна 8.
	// Также был найден ряд статей в которых подтверждается констата близкая к 3 для CAMG.
	// Amat = new Ak1[(integer)(7 * nna) + 1]; // 6 // 45 // 4
	// памяти надо много для 6 варианта интерполяции.
	// 9,35,35 28
	integer nsizeA = ((integer)(9 * nna) + 1);
	integer nsizePR = 35;

	if (bPhysics_PTBSH_memory  ) {
		// ПТБШ.
		// printf("bPhysics_PTBSH_memory==true\n");
		nsizeA = ((integer)(4 * nna) + 1);
		nsizePR = 13;
	}

	// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
	// Т.к. есть трудносходящиеся задачи, то эти настройки должны помоч.
	// Истина в том что количество потребляемой оперативной памяти очень сильно зависит от особеностей
	// пользовательской геометрии (того что пользователь начертил в интерфейсе).
	// Иногда достаточно 4 размеров матрицы, а иногда нехватает и 12. Каждая новая задача должна настраиваться 
	// в идеале индивидуально, если пользователь хочет выжить максимум из своего оборудования.
	nsizeA = ((integer)(my_amg_manager.memory_size * nna) + 1);
	if (my_amg_manager.iprint_log == 1) {
#if doubleintprecision == 1
		printf("memory size const is=%lld\n", my_amg_manager.memory_size);
#else
		printf("memory size const is=%d\n", my_amg_manager.memory_size);
#endif

	}
	nsizePR = 35;
	if (bonly_solid_calculation) {
		// 31 октября 2016.
		// По моим замерам с надёжным запасом в 30% для всех твёрдотельных 
		// задач должно хватить значения 12.
		nsizePR = 12;
	}

	// Требует заголовочного файла windows.h
	// Зависимый от ОС Windows код.
	//MEMORYSTATUSEX statex;
	//statex.dwLength = sizeof(statex);
	//GlobalMemoryStatusEx(&statex);
	//char divisor[2] = "M";
	//if (my_amg_manager.iprint_log == 1) {
		//printf("physical memory is %lld total  %sbytes \n", statex.ullTotalPhys / (1024 * 1024), divisor);
		//printf("%ld %% of memory is in use.\n", statex.dwMemoryLoad);
		//printf("required %lld %sbytes\n", (integer)(((nsizeA / (1024 * 1024)) * sizeof(Ak1) + 2 * (((nsizePR / (1024 * 1024))* nnu) + 1) * sizeof(Ak1))), divisor);
		//system("pause");
	//}

	Amat = (Ak1*)malloc(nsizeA * sizeof(Ak1));  // 9
	char c1[5] = "Amat";
	char c2[22] = "my_agr_amg_loc_memory";
	char c3[11] = "bamg_bound";
	handle_error<Ak1>(Amat, c1, c2, (nsizeA));


	bamg_bound = new bool[((nsizePR * nnu) + 1)];
	handle_error<bool>(bamg_bound, c3, c2, ((nsizePR * nnu) + 1));


	// real size 9.4 for resistor.
	// 
	/*
	Atemp = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
	if (Atemp == nullptr) {
	// недостаточно памяти на данном оборудовании.
	printf("Problem: not enough memory on your equipment for Atemp matrix in my_agregat_amg.cpp algorithm...\n");
	printf("Please any key to exit...\n");
	//getchar();
	system("pause");
	exit(1);
	}
	// real size 9.4 for resistor.
	Atemp2 = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
	if (Atemp2 == nullptr) {
	// недостаточно памяти на данном оборудовании.
	printf("Problem: not enough memory on your equipment for Atemp2 matrix in my_agregat_amg.cpp algorithm...\n");
	printf("Please any key to exit...\n");
	//getchar();
	system("pause");
	exit(1);
	}
	*/

	//result_amg = new doublerealT[nnu + 1];
	result_amg = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
	char c4[11] = "result_amg";
	handle_error<doublereal>(result_amg, c4, c2, (nnu + 1));


	//rthdsd_amg = new doublerealT[nnu + 1];
	rthdsd_amg = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
	char c5[11] = "rthdsd_amg";
	handle_error<doublereal>(rthdsd_amg, c5, c2, (nnu + 1));



	// правая часть.
	/*
	for (integer i = 0; i < nnu; i++) {
	rthdsd_amg[i] = 0.0;
	if (i<maxelm + maxbound) {
	// обязательно нужно проверить была ли выделена оперативная память.
	rthdsd_amg[i + 1] = dV[i];
	}
	}
	rthdsd_amg[0] = 0.0;
	*/
	/*
	// вектор решения.
	for (integer i = 0; i < nnu; i++) {
	result_amg[i] = 0.0;
	if (i<maxelm + maxbound) {
	// обязательно нужно проверить была ли выделена оперативная память.
	result_amg[i + 1] = dX0[i];
	}
	}
	result_amg[0] = 0.0;
	*/

	// см. equation3DtoCRS.

    integer ik = 0; // счётчик ненулевых элементов СЛАУ
	const integer id = 1;

	//if (iVar == PAM) {
	//printf("alpharelax=%e\n", alpharelax);
	//	getchar();
	//}


	for (integer k = 0; k <= n; k++) {
		bamg_bound[k] = false;
	}

	

	//R = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
	R = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
	char c6[2] = "R";
	handle_error<Ak1>(R, c6, c2, ((nsizePR * nnu) + 1));

	//P = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
	P = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
	char c7[2] = "P";
	handle_error<Ak1>(P, c7, c2, ((nsizePR * nnu) + 1));

	// Блок инициализации нулём, возможно будет работоспособно и без него.

	



	// начальное приближение.
	for (integer i = 0; i < nnu; i++) {
		
		    result_amg[i+id] = 0.0;
			// обязательно нужно проверить была ли выделена оперативная память. 
			result_amg[i + id] = dX0[i];
		
	}

	// правая часть.
	for (integer i = 0; i < nnu; i++) {
		 rthdsd_amg[i+id] = 0.0;		
		 // обязательно нужно проверить была ли выделена оперативная память. 
		 rthdsd_amg[i + id] = dV[i];
	}

	


	// см. equation3DtoCRS.

	ik = 0; // счётчик ненулевых элементов СЛАУ

					// для внутренних узлов расчётной области:
	for (integer k = 0; k < n; k++) {

		integer idiagonal_first_ik = ik;

		//сканируем строку.
		for (integer k1 = m.row_ptr[k]; k1 < m.row_ptr[k + 1]; k1++) {

			if (fabs(m.val[k1]) > nonzeroEPS) {
				if (m.col_ind[k1] != k) {
					// Внедиагональный элемент
					Amat[ik + 1 + id].aij = (real_mix_precision)(m.val[k1]);
					Amat[ik + 1 + id].j = (integer_mix_precision)(m.col_ind[k1] + 1);
					Amat[ik + 1 + id].i = (integer_mix_precision)(k + 1);
					ik++;
				}
				else {
					// диагональный элемент
					Amat[idiagonal_first_ik + id].aij = (real_mix_precision)(m.val[k1]);
					Amat[idiagonal_first_ik + id].j = (integer_mix_precision)(m.col_ind[k1] + 1);
					Amat[idiagonal_first_ik + id].i= (integer_mix_precision)(m.col_ind[k1] + 1);
					//ik++;
				}
			}
		}
		ik++;

	}

	/*
	for (integer k = 0; k < n; k++) {
	//сканируем строку.
	for (integer k1 = m.row_ptr[k]; k1 < m.row_ptr[k + 1]; k1++) {
	printf("val=%e col_ind=%d row_ptr=%d\n",a[k1+id],ja[k1+id],ia[k]);
	}
	getchar();
	}
	*/

	// в каждой строке элементы отсортированы по номерам столбцов:
	// Но диагональный элемент всегда на первом месте в строке матрицы.
	integer imove = 0;
	if (id == 0) {
		imove = -1;
	}


	// сортировка ненужна порядок следования любой, но главное чтобы первый в строке был имено диагональный элемент.
	//for (integer k=0; k<(maxelm+maxbound); k++) QuickSortCSIR_amg(ja, a, ia[k+1]+1+imove, ia[k+2]-1+imove); // первый элемент всегда диагональный.
	//for (integer k=0; k<(maxelm+maxbound); k++) QuickSortCSIR_amg(ja, a, ia[k+1]+imove, ia[k+2]-1+imove); 

	

	//printf("getready ...");
	//getchar();
	// amg - особенно хорош для поправки давления в SIMPLE алгоритме.
	// свой алгоритм 2015 года.


	//aggregative_amg(Amat, nna, nnu, R, P, result_amg, rthdsd_amg);

	//printf("allocation memory is Ok. start ready...\n");
	//system("pause");
	doublereal theta = 0.24; // 3D // 0.25 по литературным  данным. 0.24 оптимально из практики (реальное тестирование).
							 //theta = 0.5; // может поможет  для конвективных задач
	doublereal* x_copy = nullptr;
	x_copy = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
	char c8[7] = "x_copy";
	handle_error<doublereal>(x_copy, c8, c2, (nnu + 1));

	for (integer i47 = 1; i47 <= nnu; i47++) {
		x_copy[i47] = result_amg[i47];
	}

	//doublereal theta83 = 0.23;
	//doublereal magic82 = 0.4;
	//doublereal magic83 = 0.5; 
	//doublereal ret74 = 0.0;
	bool bdivergence_detected = false;


	
	// режим экономии оперативной памяти.
	bool bmemory_savings = false;

	integer  maxelm_out = n;// это для radiosity patch.Излучение в вакуумном промежутке.
	// iVar нужен для настройки BiCGStab.
	integer iVar = TOTALDEFORMATIONVAR;

	

	//if (iswitchsolveramg_vs_BiCGstab_plus_ILU2 == 7) {
     	real_mix_precision theta82f = (real_mix_precision)theta82, theta83f = (real_mix_precision)theta83, magic82f = (real_mix_precision)magic82, magic83f = (real_mix_precision)magic83, ret74f = (real_mix_precision)ret74;
		//bdivergence_detected = classic_aglomerative_amg4<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm_out);
		bdivergence_detected = classic_aglomerative_amg4<real_mix_precision>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, theta82f, theta83f, magic82f, magic83f, ret74f, iVar, bmemory_savings, b, lb, maxelm_out, whot_is_block);
		//bdivergence_detected = classic_aglomerative_amg6<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm_out);

		//}
	//else {
		//bdivergence_detected = classic_aglomerative_amg5<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings);
		//bdivergence_detected = classic_aglomerative_amg5<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings);
	//}



		
		// Работа amg была успешна.
		for (integer i47 = 1; i47 <= nnu; i47++) {
			result_amg[i47] = x_copy[i47];
		}
		
		if (x_copy != nullptr) {
			free(x_copy);
			x_copy = nullptr;
		}

		//system("pause");



		// возвращаем решение СЛАУ.
		// вектор решения. 
		for (integer i = 0; i < nnu; i++) {
			if (i<n) {
				// обязательно нужно проверить была ли выделена оперативная память. 
				dX0[i] = result_amg[i + 1];
			}
		}



		if (R != nullptr) {
			//delete[] R;
			free(R);
		}
		if (P != nullptr) {
			//delete[] P;
			free(P);
		}
		if (bamg_bound != nullptr) {
			delete[] bamg_bound;
			bamg_bound = nullptr;
		}
		//if (Atemp != nullptr) {
		//delete[] Atemp;
		//}
		//if (Atemp2 != nullptr) {
		//delete[] Atemp2;
		//}
		if (result_amg != nullptr) {
			//delete[] result_amg;
			free(result_amg);
		}
		if (rthdsd_amg != nullptr) {
			//delete[] rthdsd_amg;
			free(rthdsd_amg);
		}		


		// освобождение памяти.
		if (Amat != nullptr) {
			//delete[] Amat;
			free(Amat);
			Amat = nullptr;
		}	


	calculation_main_end_time = clock();
	calculation_vorst_seach_time += calculation_main_end_time - calculation_main_start_time;

#ifdef _OPENMP
	omp_set_num_threads(i_my_num_core_parallelesation);
#endif
	///getchar();

}//my_agr_amg_loc_memory_Stress_old

// Здесь содержится обвязка вызывающая РУМБА.
// локальное выделение памяти:всё внутри, многократные alloc и free.
// РУМБА для решения задачи напряженно-деформированнного состояния.
// Нет сходимости. Дата успешного подключения 24 сентября 2017.
void my_agr_amg_loc_memory_Stress(SIMPLESPARSE &sparseM, integer n,
	doublereal* &dV, doublereal* &dX0,
	QuickMemVorst& m, BLOCK* &b, int &lb, WALL* &w, int &lw,
	bool* &bondary, integer iVarloc, int * &whot_is_block)
{

	// 11 января 2016. классический агломеративный алгебраический многосеточный метод.
	// Это моя собственная разработка РУМБА 0.14.
	//if (iVar != PAM) {
	//doublereal theta82 = 0.24;
	//doublereal theta83 = 0.23;
	//doublereal magic82 = 0.4;
	//doublereal magic83 = 0.5; 
	//doublereal ret74 = 0.0;
	//-->doublereal theta82 = 0.24;// 0.25; //0.24
	//-->doublereal theta83 = 0.23;// 0.25; // 0.23
	// 0.3 0.4 0.44 0.45  0.5
	// 16  25   38        17
	//--->doublereal magic82 = 0.4; // 0.35; // 0.4 // 0.43
	//----->doublereal magic83 = 0.4;// 0.35; // 0.42

	real_mix_precision ret74 = 0.0;

	if (iVarloc == TEMP) {
		my_amg_manager.theta = (real_mix_precision)(my_amg_manager.theta_Temperature);
		my_amg_manager.maximum_delete_levels = my_amg_manager.maximum_delete_levels_Temperature;
		my_amg_manager.nFinnest = my_amg_manager.nFinnest_Temperature;
		my_amg_manager.nu1 = my_amg_manager.nu1_Temperature;
		my_amg_manager.nu2 = my_amg_manager.nu2_Temperature;
		my_amg_manager.memory_size = my_amg_manager.memory_size_Temperature;
		//my_amg_manager.memory_size = 5.0; // вместо 9.0 даёт понижение используемой ОЗУ на 15.6%.
		my_amg_manager.ilu2_smoother = my_amg_manager.ilu2_smoother_Temperature;
		my_amg_manager.icoarseningtype = my_amg_manager.icoarseningTemp; // standart vs RS 2.
		my_amg_manager.istabilization = my_amg_manager.istabilizationTemp; // Stabilization: 0 - none, 1 - bicgstab + amg (РУМБА), 2 - FGMRes + amg (РУМБА).
		my_amg_manager.magic = my_amg_manager.F_to_F_Temperature; // magic
		my_amg_manager.number_interpolation_procedure = my_amg_manager.number_interpolation_procedure_Temperature;
		my_amg_manager.iCFalgorithm_and_data_structure = my_amg_manager.iCFalgorithm_and_data_structure_Temperature;
		my_amg_manager.iprint_log = my_amg_manager.iprint_log_Temperature;
		my_amg_manager.itruncation_interpolation = my_amg_manager.itruncation_interpolation_Temperature;
		my_amg_manager.truncation_interpolation = my_amg_manager.truncation_interpolation_Temperature;
		my_amg_manager.gold_const = my_amg_manager.gold_const_Temperature;
		my_amg_manager.b_gmres = my_amg_manager.b_gmresTemp;
		my_amg_manager.bMatrixPortrait = my_amg_manager.bTemperatureMatrixPortrait;
		my_amg_manager.bcf_reorder = my_amg_manager.bcf_reorder_Temperature;
		my_amg_manager.bthreshold_auto = my_amg_manager.bthreshold_Temperature_auto;
	}
	if (iVarloc == TOTALDEFORMATION) {
		my_amg_manager.theta = (real_mix_precision)(my_amg_manager.theta_Stress);
		my_amg_manager.maximum_delete_levels = my_amg_manager.maximum_delete_levels_Stress;
		my_amg_manager.nFinnest = my_amg_manager.nFinnest_Stress;
		my_amg_manager.nu1 = my_amg_manager.nu1_Stress;
		my_amg_manager.nu2 = my_amg_manager.nu2_Stress;
		my_amg_manager.memory_size = my_amg_manager.memory_size_Stress;
		my_amg_manager.ilu2_smoother = my_amg_manager.ilu2_smoother_Stress;
		my_amg_manager.icoarseningtype = my_amg_manager.icoarseningStress; // standart vs RS 2.
		my_amg_manager.istabilization = my_amg_manager.istabilizationStress; // Stabilization: 0 - none, 1 - bicgstab + amg (РУМБА).
		my_amg_manager.magic = my_amg_manager.F_to_F_Stress; // magic
		my_amg_manager.number_interpolation_procedure = my_amg_manager.number_interpolation_procedure_Stress;
		my_amg_manager.iCFalgorithm_and_data_structure = my_amg_manager.iCFalgorithm_and_data_structure_Stress;
		my_amg_manager.iprint_log = my_amg_manager.iprint_log_Stress;
		my_amg_manager.itruncation_interpolation = my_amg_manager.itruncation_interpolation_Stress;
		my_amg_manager.truncation_interpolation = my_amg_manager.truncation_interpolation_Stress;
		my_amg_manager.gold_const = my_amg_manager.gold_const_Stress;
		my_amg_manager.b_gmres = my_amg_manager.b_gmresStress;
		my_amg_manager.bMatrixPortrait = my_amg_manager.bStressMatrixPortrait;
		my_amg_manager.bcf_reorder = my_amg_manager.bcf_reorder_Stress;
		my_amg_manager.bthreshold_auto = my_amg_manager.bthreshold_Stress_auto;
	}

	


	// Замер времени.
	unsigned int calculation_main_start_time; // начало счёта мс.
	unsigned int calculation_main_end_time; // окончание счёта мс.

	calculation_main_start_time = clock(); // момент начала счёта.
#ifdef _OPENMP
	int i_my_num_core_parallelesation = omp_get_max_threads();
	omp_set_num_threads(number_cores()); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#else
	int i_my_num_core_parallelesation = 1;
#endif

	doublereal nonzeroEPS = 1e-37; // для отделения вещественного нуля

	// На случай если память не была выделена.
	if (dX0 == nullptr) {
		dX0 = new doublereal[n];
		for (integer i = 0; i < n; i++) {
			dX0[i] = 0.0;
		}
	}

	//const integer id = 0;

	// инициализация
	// Память выделяется внутри:
#if !bStableVersion
	
	ell_to_CRS(m.val, m.col_ind, m.row_ptr, n); // преобразование матрицы из одного формата хранения в другой.


	for (int i = 0; i < n; ++i) {
		delete[] data_ell[i];
		delete[] coll_ell[i];
	}
	delete[] data_ell;
	delete[] coll_ell;

#else

	simplesparsetoCRS(sparseM, m.val, m.col_ind, m.row_ptr, n); // преобразование матрицы из одного формата хранения в другой.
																//m.ballocCRScfd = true;
	simplesparsefree(sparseM, n);

#endif

	integer ierr = 0;
	//doublereal eps = 1.0e-12;

	ierr = 0; // изначальное состояние безошибочное.
			  // Порог точности решения СЛАУ. Значение 1.0E-12 достаточно что проверено в ANSYS icepak.
	//eps = 1.0e-12; // рекомендуемое значение которого достаточно. 

				   // Требования к оперативной памяти.
				   /*     VECTOR         NEEDED LENGTH (GUESS) */
				   /*       Amat               3*NNA + 5*NNU */
				   /*       JA              3*NNA + 5*NNU */
				   /*       IA              2.2*NNU */
				   /*       U               2.2*NNU */
				   /*       F               2.2*NNU */
				   /*       IG              5.4*NNU */

	integer nna = 0;
	for (integer k = 0; k < m.row_ptr[n]; k++) {

		if (fabs(m.val[k]) > nonzeroEPS) {
			nna++;
		}
	}
	//printf("nna=%d istinnoe=%d\n", nna, m.row_ptr[n]);
	//getchar();
	//integer nna = m.row_ptr[n]; // количество ненулевых элементов в матрице СЛАУ.



	integer nnu = n; // число неизвестных.

					 // данная константа работоспособна вплоть до размерностей сетки равных 34млн 463тысячи 250узлов.
					 //doublerealT rsize=1.51; // 1048416
					 // Вынужденные течения достаточно 2.5.
					 // значения 3.5 недостаточно для 8 модулей Пионер. 
	//doublerealT rsize = 4.5; // на задаче Концевого Ю.А. Электростатика со столбиком в случае сетки со сгущением достаточно 2.0.
	/*
	integer nda = 0; // память под вектор значений матрицы слау.
	nda = (integer)(rsize*(3 * (nna)+5 * (nnu)));
	integer ndia = 0;
	ndia = (integer)(rsize*2.2*(nnu));
	integer ndja = 0;
	ndja = (integer)(rsize*(3 * (nna)+5 * (nnu)));
	integer ndu = 0;
	ndu = (integer)(rsize*2.2*(nnu));
	integer ndf = 0;
	ndf = (integer)(rsize*2.2*(nnu));
	integer ndig = 0;
	ndig = (integer)(rsize*5.4*(nnu));
	*/


	/*     CLASS 3 - PARAMETERS: */

	/*     LEVELX   -   MAXIMUM NUMBER OF MG-LEVELS TO BE CREATED (>=1). */

	/*     IFIRST   -   PARAMETER FOR FIRST APPROXIMATION. */

	/*                  1ST DIGIT OF IFIRST: NOT USED; HAS TO BE NON-ZERO. */

	/*                  2ND DIGIT OF IFIRST  --  ITYPU: */
	/*                    =0: NO SETTING OF FIRST APPROXIMATION, */
	/*                    =1: FIRST APPROXIMATION CONSTANT TO ZERO, */
	/*                    =2: FIRST APPROXIMATION CONSTANT TO ONE, */
	/*                    =3: FIRST APPROXIMATION IS RANDOM FUNCTION WITH */
	/*                        THE CONCRETE RANDOM SEQUENCE BEING DETERMINED */
	/*                        BY THE FOLLWING DIGITS. */

	/*                  REST OF IFIRST  --  RNDU: */
	/*                    DETERMINES THE CONCRETE RANDOM SEQUENCE USED IN */
	/*                    THE CASE ITYPU=3. (IFIRST=13 IS EQUIVALENT TO */
	/*                    IFIRST=1372815) */

	/*     NCYC     -   INTEGER PARAMETER DESCRIBING THE TYPE OF CYCLE TO BE */
	/*                  USED AND THE NUMBER OF CYCLES TO BE PERFORMED. */

	/*                  1ST DIGIT OF NCYC  --  IGAM: */
	/*                    =1: V -CYCLE, */
	/*                    =2: V*-CYCLE, */
	/*                    =3: F -CYCLE, */
	/*                    =4: W -CYCLE. */
	/*                  IF NCYC IS NEGATIV, THEN THE APPROXIMATION OF THE */
	/*                  PROBLEM ON THE SECOND FINEST GRID IS COMPUTED BY */
	/*                  IGAM V-CYCLES ON THAT PARTICULAR GRID. */

	/*                  2ND DIGIT OF NCYC  --  ICGR: */
	/*                    =0: NO CONJUGATE GRADIENT, */
	/*                    =1: CONJUGATE GRADIENT (ONLY FIRST STEP OF CG), */
	/*                    =2: CONJUGATE GRADIENT (FULL CG). */

	/*                  3RD DIGIT OF NCYC  --  ICONV: */
	/*                    CONVERGENCE CRITERION FOR THE USER-DEFINED PROBLEM */
	/*                    (FINEST GRID): */
	/*                    =1: PERFORM Amat FIXED NUMBER OF CYCLES AS GIVEN BY */
	/*                        NCYCLE (SEE BELOW) */
	/*                    =2: STOP, IF  ||RES|| < EPS */
	/*                    =3: STOP, IF  ||RES|| < EPS * |F| */
	/*                    =4: STOP, IF  ||RES|| < EPS * |U| * |DIAG| */
	/*                    WITH ||RES|| = L2-NORM OF RESIDUAL, */
	/*                           EPS     (SEE INPUT PARAMETER EPS) */
	/*                           |F|   = SUPREMUM NORM OF RIGHT HAND SIDE */
	/*                           |U|   = SUPREMUM NORM OF SOLUTION */
	/*                         |DIAG|  = MAXIMAL DIAGONAL ENTRY IN MATRIX L */
	/*                    NOTE THAT IN ANY CASE THE SOLUTION PROCESS STOPS */
	/*                    AFTER AT MOST NCYCLE CYCLES. */

	/*                  REST OF NCYC  --  NCYCLE: */
	/*                    MAXIMAL NUMBER OF CYCLES TO BE PERFORMED (>0) OR */
	/*                    NCYCLE=0: NO CYCLING. */

	/*     EPS      -   CONVERGENCE CRITERION FOR SOLUTION PROCESS: (SEE */
	/*                  PARAMETER NCYC). NOTE THAT NO MORE THAN NCYCLE CYCLES */
	/*                  ARE PERFORMED, REGARDLESS OF EPS. */

	/*     MADAPT   -   INTEGER VALUE SPECIFYING THE CHOICE OF COARSEST */
	/*                  GRID IN CYCLING: */

	/*                  1ST DIGIT OF MADAPT  --  MSEL: */
	/*                    =1: IN CYCLING, ALL GRIDS CONSTRUCTED IN THE SETUP */
	/*                        PHASE ARE USED WITHOUT CHECK. */
	/*                    =2: THE NUMBER OF GRIDS IS AUTOMATICALLY REDUCED */
	/*                        IF THE CONVERGENCE FACTOR ON THE COARSER GRIDS */
	/*                        IS FOUND TO BE LARGER THAN Amat GIVEN VALUE FAC */
	/*                        (SEE BELOW). */

	/*                  REST OF MADAPT  --  FAC */
	/*                        THE REST OF MADAPT DEFINES THE FRACTIONAL PART */
	/*                        OF Amat REAL NUMBER FAC BETWEEN 0.1 AND 0.99, E.G. */
	/*                        MADAPT=258 MEANS MSEL=2 AND FAC=0.58. IF MADAPT */
	/*                        CONSISTS OF ONLY ONE DIGIT, FAC IS SET TO 0.7 */
	/*                        BY DEFAULT. */


	/*     NRD      -   PARAMETER DESCRIBING RELAXATION (DOWNWARDS): */

	/*                  1ST DIGIT OF NRD: NOT USED; HAS TO BE NON-ZERO. */

	/*                  2ND DIGIT OF NRD  --  NRDX: */
	/*                    ACTUAL NUMBER OF SMOOTHING STEPS TO BE PERFORMED */
	/*                    THE TYPE OF WHICH IS GIVEN BY THE FOLLOWING DIGITS */

	/*                  FOLLOWING DIGITS  --  ARRAY NRDTYP: */
	/*                    =1: RELAXATION OVER THE F-POINTS ONLY */
	/*                    =2: FULL GS SWEEP */
	/*                    =3: RELAXATION OVER THE C-POINTS ONLY */
	/*                    =4: FULL MORE COLOR SWEEP, HIGHEST COLOR FIRST */

	/*     NSOLCO   -   PARAMETER CONTROLLING THE SOLUTION ON COARSEST GRID: */

	/*                  1ST DIGIT  --  NSC: */
	/*                    =1: GAUSS-SEIDEL METHOD */
	/*                    =2: DIRECT SOLVER (YALE SMP) */

	/*                  REST OF NSOLCO  --  NRCX: (ONLY IF NSC=1) */
	/*                  NUMBER OF GS SWEEPS ON COARSEST GRID (>=0). */
	/*                  IF NRCX=0, THEN AS MANY GS SWEEPS ARE PERFORMED */
	/*                  AS ARE NEEDED TO REDUCE THE RESIDUAL BY TWO ORDERS */
	/*                  OF MAGNITUDE. (MAXIMAL 100 RELAXATION SWEEPS) */

	/*     NRU      -   PARAMETER FOR RELAXATION (UPWARDS), ANALOGOUS TO NRD. */

	/*         -------------------------------------------------------------- */

	/*     CLASS 4 - PARAMETERS: */

	/*     ECG1,ECG2-   REAL PARAMETERS AFFECTING THE CREATION OF COARSER */
	/*     EWT2     -   GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
	/*                  THE CHOICE OF THESE PARAMETERS DEPENDS ON */
	/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

	/*     NWT      -   INTEGER PARAMETER AFFECTING THE CREATION OF COARSER */
	/*                  GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
	/*                  THE CHOICE OF THIS PARAMETER DEPENDS ON */
	/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

	/*     NTR      -   PARAMETER CONTROLLING COARSE-GRID OPERATOR TRUNCATION */
	/*                    =0: PAIRS OF ZEROES ARE REMOVED FROM COARSE GRID */
	/*                        OPERATORS */
	/*                    =1: NO COARSE-GRID OPERATOR TRUNCATION */



	/*     STANDARD CHOICES OF PARAMETERS (AS FAR AS MEANINGFUL): */

	/*          ISWTCH = 4 */
	/*          IOUT   = 12 */
	/*          IPRINT = 10606 */

	/*          LEVELX = 25 */
	/*          IFIRST = 13 */
	/*          NCYC   = 10110 */
	/*          EPS    = 1.D-12 */
	/*          MADAPT = 27 */
	/*          NRD    = 1131 */
	/*          NSOLCO = 110 */
	/*          NRU    = 1131 */

	/*          ECG1   = 0. */
	/*          ECG2   = 0.25 */
	/*          EWT2   = 0.35 */
	/*          NWT    = 2 */
	/*          NTR    = 0 */



	// рекомедуемые параметры по дефолту.
/*
	integer iswtch = 0;
	iswtch = 4;
	integer iout = 0;
	iout = 13; // 13 обеспечивает печать изменения невязки в процессе счёта.
	integer iprint = 0;
	iprint = 10606;
	integer levelx = 0;
	levelx = 25;
	integer ifirst = 0;
	// начальное приближение:
	// 0 - используется из вне.
	// 1 - нулевое.
	// 2 - единицы.
	// 3 - случайная последовательность.
	ifirst = 13;//13 по умолчанию.
				//ifirst=11; // нулевое начальное приближение.
				//ifirst=10; // вроде как начальное приближение берётся из dX0.
				// но 10 никоим образом не улучшает сходимость.
	integer ncyc = 0;
	ncyc = 10110;
	integer madapt = 0;
	madapt = 27;
	integer nrd = 0;
	nrd = 1131;
	integer nsolco = 0;
	nsolco = 110;
	integer nru = 0;
	nru = 1131;
	doublereal ecg1 = 0.0;
	ecg1 = 0.0;
	doublereal ecg2 = 0.0;
	ecg2 = 0.25;
	doublereal ewt2 = 0.0;
	ewt2 = 0.35;
	integer nwt = 0;
	nwt = 2;
	integer ntr = 0;
	ntr = 0;

	integer matrix = 0;
	matrix = 11; // symmetric SPD.
				 //matrix = 22;
	ncyc = 10199;
	*/

    Ak2 Amat;
    Amat.i= nullptr;
	Amat.j = nullptr;
	Amat.aij = nullptr;
	Amat.abs_aij = nullptr;

	//Ak1* R = nullptr;
	//Ak1* P = nullptr;
	//Ak1* Atemp = nullptr;
	//Ak1* Atemp2 = nullptr;
	doublereal* rthdsd_amg = nullptr;
	doublereal* result_amg = nullptr;
	// 18 августа 2016
	// граничные узлы требуют особой обработки.
	// true - граничный узел, false - внутренний.
	bool* bamg_bound = nullptr;

	// allocate memory.
	// allocate memory 2 jan 2016.
	// BSK Dmitrii 3.012  (2.892 для прямой интерполяции с элементами непрямой). 
	// tgf series no metalization
	// tgf2023-2_01 2.64 643mb
	// tgf2023-2-02 2.58 988mb
	// tgf2023-2-05 2.44 2022mb
	// tgf2023-2-20 3.58 2967mb
	// CGHV1J metalization 3.133 (2.84 для прямой интерполяции с элементами непрямой). 
	// тор Докторович 2.89
	// Концевой 3.05
	// Концевой со столбиком 3.7М 2.97 (6.0 у amg1r5) 4110.6Мb.
	// Вывод: максимальное значение 3.15 а значит значения 4 должно хватить с запасом У amg1r5 максимальное значение 9.0.
	// Можно сказать что данный amg требует вдвое меньше памяти по сравнению с amg1r5.
	// Была найдена статья в интернете которая подтверждала что константа памяти у amg1r5 равна 8.
	// Также был найден ряд статей в которых подтверждается констата близкая к 3 для CAMG.
	//Amat = new Ak1[(integer)(7 * nna) + 1]; // 6 // 45 // 4
	// памяти надо много для 6 варианта интерполяции.
	// 9,35,35 28
	integer nsizeA = ((integer)(9 * nna) + 1);
	integer nsizePR = 35;

	if (bPhysics_PTBSH_memory  ) {
		// ПТБШ.
		//printf("bPhysics_PTBSH_memory==true\n");
		nsizeA = ((integer)(4 * nna) + 1);
		nsizePR = 13;
	}

	// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
	// Т.к. есть трудносходящиеся задачи, то эти настройки должны помоч.
	// Истина в том что количество потребляемой оперативной памяти очень сильно зависит от особеностей
	// пользовательской геометрии (того что пользователь начертил в интерфейсе).
	// Иногда достаточно 4 размеров матрицы, а иногда нехватает и 12. Каждая новая задача должна настраиваться 
	// в идеале индивидуально, если пользователь хочет выжить максимум из своего оборудования.
	nsizeA = ((integer)(my_amg_manager.memory_size * nna) + 1);
	if (my_amg_manager.iprint_log == 1) {
#if doubleintprecision == 1
		printf("memory size const is=%lld\n", my_amg_manager.memory_size);
#else
		printf("memory size const is=%d\n", my_amg_manager.memory_size);
#endif

	}
	nsizePR = 35;
	if (bonly_solid_calculation) {
		// 31 октября 2016.
		// По моим замерам с надёжным запасом в 30% для всех твёрдотельных 
		// задач должно хватить значения 12.
		nsizePR = 12;
	}

	// Требует заголовочного файла windows.h
	// Зависимый от ОС Windows код.
	//MEMORYSTATUSEX statex;
	//statex.dwLength = sizeof(statex);
	//GlobalMemoryStatusEx(&statex);
	//char divisor[2] = "M";
	//if (my_amg_manager.iprint_log == 1) {
		//printf("physical memory is %lld total  %sbytes \n", statex.ullTotalPhys / (1024 * 1024), divisor);
		//printf("%ld %% of memory is in use.\n", statex.dwMemoryLoad);
		//printf("required %lld %sbytes\n", (integer)(((nsizeA / (1024 * 1024)) * sizeof(Ak1) + 2 * (((nsizePR / (1024 * 1024))* nnu) + 1) * sizeof(Ak1))), divisor);
		//system("pause");
	//}

	Amat.i = (integer_mix_precision*)malloc(nsizeA * sizeof(integer_mix_precision));  // 9
	char c1[5] = "Amat";
	char c2[22] = "my_agr_amg_loc_memory";
	char c3[11] = "bamg_bound";
	handle_error<integer_mix_precision>(Amat.i, c1, c2, (nsizeA));
	Amat.j = (integer_mix_precision*)malloc(nsizeA * sizeof(integer_mix_precision));  // 9
	handle_error<integer_mix_precision>(Amat.j, c1, c2, (nsizeA));
	Amat.aij = (real_mix_precision*)malloc(nsizeA * sizeof(real_mix_precision));  // 9
	handle_error<real_mix_precision>(Amat.aij, c1, c2, (nsizeA));
	Amat.abs_aij = (real_mix_precision*)malloc(nsizeA * sizeof(real_mix_precision));  // 9
	handle_error<real_mix_precision>(Amat.abs_aij, c1, c2, (nsizeA));

	bamg_bound = new bool[((nsizePR * nnu) + 1)];
	handle_error<bool>(bamg_bound, c3, c2, ((nsizePR * nnu) + 1));


	// real size 9.4 for resistor.
	// 
	/*
	Atemp = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
	if (Atemp == nullptr) {
	// недостаточно памяти на данном оборудовании.
	printf("Problem: not enough memory on your equipment for Atemp matrix in my_agregat_amg.cpp algorithm...\n");
	printf("Please any key to exit...\n");
	//getchar();
	system("pause");
	exit(1);
	}
	// real size 9.4 for resistor.
	Atemp2 = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
	if (Atemp2 == nullptr) {
	// недостаточно памяти на данном оборудовании.
	printf("Problem: not enough memory on your equipment for Atemp2 matrix in my_agregat_amg.cpp algorithm...\n");
	printf("Please any key to exit...\n");
	//getchar();
	system("pause");
	exit(1);
	}
	*/

	//result_amg = new doublerealT[nnu + 1];
	result_amg = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
	char c4[11] = "result_amg";
	handle_error<doublereal>(result_amg, c4, c2, (nnu + 1));


	//rthdsd_amg = new doublerealT[nnu + 1];
	rthdsd_amg = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
	char c5[11] = "rthdsd_amg";
	handle_error<doublereal>(rthdsd_amg, c5, c2, (nnu + 1));



	// правая часть.
	/*
	for (integer i = 0; i < nnu; i++) {
	rthdsd_amg[i] = 0.0;
	if (i<maxelm + maxbound) {
	// обязательно нужно проверить была ли выделена оперативная память.
	rthdsd_amg[i + 1] = dV[i];
	}
	}
	rthdsd_amg[0] = 0.0;
	*/
	/*
	// вектор решения.
	for (integer i = 0; i < nnu; i++) {
	result_amg[i] = 0.0;
	if (i<maxelm + maxbound) {
	// обязательно нужно проверить была ли выделена оперативная память.
	result_amg[i + 1] = dX0[i];
	}
	}
	result_amg[0] = 0.0;
	*/

	// см. equation3DtoCRS.

	integer ik = 0; // счётчик ненулевых элементов СЛАУ
	const integer id = 1;

	//if (iVar == PAM) {
	//printf("alpharelax=%e\n", alpharelax);
	//	getchar();
	//}


	for (integer k = 0; k <= n; k++) {
		bamg_bound[k] = false;
	}



	//R = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
	//R = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
	//char c6[2] = "R";
	//handle_error<Ak1>(R, c6, c2, ((nsizePR * nnu) + 1));

	//P = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
	//P = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
	//char c7[2] = "P";
	//handle_error<Ak1>(P, c7, c2, ((nsizePR * nnu) + 1));

	


	doublereal alpharelax = 1.0;

	// Это не специальная нелинейная версия кода amg1r5 CAMG.
	for (integer k = 0; k < lw; k++) {
		if ((w[k].ifamily == WALL_BOUNDARY_CONDITION::STEFAN_BOLCMAN_FAMILY) ||
			(w[k].ifamily == WALL_BOUNDARY_CONDITION::NEWTON_RICHMAN_FAMILY)) {
			alpharelax = 0.99999; // Для того чтобы решение СЛАУ сходилось.
			// 0.9999 - недостаточное значение, температуры не те получаются.
		}
	}

	if ((adiabatic_vs_heat_transfer_coeff == DEFAULT_CABINET_BOUNDARY_CONDITION::NEWTON_RICHMAN_BC) ||
		(adiabatic_vs_heat_transfer_coeff == DEFAULT_CABINET_BOUNDARY_CONDITION::STEFAN_BOLCMAN_BC) ||
		(adiabatic_vs_heat_transfer_coeff == DEFAULT_CABINET_BOUNDARY_CONDITION::MIX_CONDITION_BC)) {
		alpharelax = 0.99999; // Для того чтобы решение СЛАУ сходилось.
		// 0.9999 - недостаточное значение, температуры не те получаются.
	}


	for (integer i = 0; i < n; i++) {

		for (integer j = m.row_ptr[i]; j < m.row_ptr[i + 1]; j++) {
			if (m.col_ind[j] == i) {
				// диагональ.
				if (((bondary != nullptr) && (!bondary[i])) &&
					(m.row_ptr[i + 1] > m.row_ptr[i] + 1)) {
					// Релаксация к предыдущему значению.

					dV[i] += (1.0 - alpharelax) * m.val[j] * dX0[i] / alpharelax;

					m.val[j] = (m.val[j] / alpharelax);
				}

				//debug
				//std::cout << "col_buffer[j]=" << col_ind[j] << std::endl;
				//system("pause");
			}
		}
	}


	// Блок инициализации нулём, возможно будет работоспособно и без него.

	// начальное приближение.
	for (integer i = 0; i < nnu; i++) {

		result_amg[i + id] = 0.0;
		// обязательно нужно проверить была ли выделена оперативная память. 
		result_amg[i + id] = dX0[i];

	}

	// правая часть.
	for (integer i = 0; i < nnu; i++) {
		rthdsd_amg[i + id] = 0.0;
		// обязательно нужно проверить была ли выделена оперативная память. 
		rthdsd_amg[i + id] = dV[i];
	}

	


	// см. equation3DtoCRS.

	ik = 0; // счётчик ненулевых элементов СЛАУ

					// для внутренних узлов расчётной области:
	for (integer k = 0; k < n; k++) {

		integer idiagonal_first_ik = ik;

		//сканируем строку.
		for (integer k1 = m.row_ptr[k]; k1 < m.row_ptr[k + 1]; k1++) {

			if (fabs(m.val[k1]) > nonzeroEPS) {
				if (m.col_ind[k1] != k) {
					// Внедиагональный элемент
					Amat.aij[ik + 1 + id] = (real_mix_precision)(m.val[k1]);
					Amat.j[ik + 1 + id] = (integer_mix_precision)(m.col_ind[k1] + 1);
					Amat.i[ik + 1 + id] = (integer_mix_precision)(k + 1);
					ik++;
				}
				else {
					// диагональный элемент
					Amat.aij[idiagonal_first_ik + id] = (real_mix_precision)(m.val[k1]);
					Amat.j[idiagonal_first_ik + id] = (integer_mix_precision)(m.col_ind[k1] + 1);
					Amat.i[idiagonal_first_ik + id] = (integer_mix_precision)(m.col_ind[k1] + 1);
					//ik++;
				}
			}
		}
		ik++;

	}

	/*
	for (integer k = 0; k < n; k++) {
	//сканируем строку.
	for (integer k1 = m.row_ptr[k]; k1 < m.row_ptr[k + 1]; k1++) {
	printf("val=%e col_ind=%d row_ptr=%d\n",a[k1+id],ja[k1+id],ia[k]);
	}
	getchar();
	}
	*/

	// в каждой строке элементы отсортированы по номерам столбцов:
	// Но диагональный элемент всегда на первом месте в строке матрицы.
	integer imove = 0;
	if (id == 0) {
		imove = -1;
	}


	// сортировка ненужна порядок следования любой, но главное чтобы первый в строке был имено диагональный элемент.
	//for (integer k=0; k<(maxelm+maxbound); k++) QuickSortCSIR_amg(ja, a, ia[k+1]+1+imove, ia[k+2]-1+imove); // первый элемент всегда диагональный.
	//for (integer k=0; k<(maxelm+maxbound); k++) QuickSortCSIR_amg(ja, a, ia[k+1]+imove, ia[k+2]-1+imove); 



	//printf("getready ...");
	//getchar();
	// amg - особенно хорош для поправки давления в SIMPLE алгоритме.
	// свой алгоритм 2015 года.


	//aggregative_amg(Amat, nna, nnu, R, P, result_amg, rthdsd_amg);

	//printf("allocation memory is Ok. start ready...\n");
	//system("pause");
	doublereal theta = 0.24; // 3D // 0.25 по литературным  данным. 0.24 оптимально из практики (реальное тестирование).
							 //theta = 0.5; // может поможет  для конвективных задач
	doublereal* x_copy = nullptr;
	x_copy = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
	char c8[7] = "x_copy";
	handle_error<doublereal>(x_copy, c8, c2, (nnu + 1));

	for (integer i47 = 1; i47 <= nnu; i47++) {
		x_copy[i47] = result_amg[i47];
	}

	//doublereal theta83 = 0.23;
	//doublereal magic82 = 0.4;
	//doublereal magic83 = 0.5; 
	//doublereal ret74 = 0.0;
	bool bdivergence_detected = false;



	// режим экономии оперативной памяти.
	bool bmemory_savings = false;

	integer  maxelm_out = n;// это для radiosity patch.Излучение в вакуумном промежутке.
	// iVar нужен для настройки BiCGStab.
	integer iVar = TOTALDEFORMATIONVAR;



	//if (iswitchsolveramg_vs_BiCGstab_plus_ILU2 == 7) {
		//bdivergence_detected = classic_aglomerative_amg4<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm_out);
		//bdivergence_detected = classic_aglomerative_amg4<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm_out);
	
	if (bamg_bound != nullptr) {
		delete[] bamg_bound;
		bamg_bound = nullptr;
	}

	bdivergence_detected = classic_aglomerative_amg6<doublereal>(Amat, nsizeA, nna, nnu,  x_copy, rthdsd_amg,  ret74, iVar, bmemory_savings, b, lb, maxelm_out, whot_is_block);

	if (bdivergence_detected) {
		printf("Recomended: Setup one thread and Gauss-Seidel smoother.\n");
		printf("amg solver divergence detected...\n");
		system("PAUSE");
		exit(1);
	}

	//}
    //else {
	    //bdivergence_detected = classic_aglomerative_amg5<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings);
	    //bdivergence_detected = classic_aglomerative_amg5<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings);
    //}




	// Работа amg была успешна.
	for (integer i47 = 1; i47 <= nnu; i47++) {
		result_amg[i47] = x_copy[i47];
	}

	if (x_copy != nullptr) {
		free(x_copy);
		x_copy = nullptr;
	}

	//system("pause");



	// возвращаем решение СЛАУ.
	// вектор решения. 
	for (integer i = 0; i < nnu; i++) {
		if (i < n) {
			// обязательно нужно проверить была ли выделена оперативная память. 
			dX0[i] = result_amg[i + 1];
		}
	}



	//if (R != nullptr) {
		//delete[] R;
		//free(R);
	//}
	//if (P != nullptr) {
		//delete[] P;
		//free(P);
	//}
	if (bamg_bound != nullptr) {
		delete[] bamg_bound;
		bamg_bound = nullptr;
	}
	//if (Atemp != nullptr) {
	//delete[] Atemp;
	//}
	//if (Atemp2 != nullptr) {
	//delete[] Atemp2;
	//}
	if (result_amg != nullptr) {
		//delete[] result_amg;
		free(result_amg);
	}
	if (rthdsd_amg != nullptr) {
		//delete[] rthdsd_amg;
		free(rthdsd_amg);
	}


	// освобождение памяти.
	if (Amat.i != nullptr) {
		//delete[] Amat.i;
		free(Amat.i);
		Amat.i = nullptr;
	}
	if (Amat.j != nullptr) {
		//delete[] Amat.j;
		free(Amat.j);
		Amat.j = nullptr;
	}
	if (Amat.aij != nullptr) {
		//delete[] Amat.aij;
		free(Amat.aij);
		Amat.aij = nullptr;
	}
	if (Amat.abs_aij != nullptr) {
		//delete[] Amat.aij;
		free(Amat.abs_aij);
		Amat.abs_aij = nullptr;
	}

	calculation_main_end_time = clock();
	calculation_vorst_seach_time += calculation_main_end_time - calculation_main_start_time;

#ifdef _OPENMP
	omp_set_num_threads(i_my_num_core_parallelesation);
#endif

	///getchar();

}//my_agr_amg_loc_memory_Stress


// Здесь содержится обвязка вызывающая РУМБА v0_14 решатель.
// локальное выделение памяти:всё внутри, многократные alloc и free.
void my_agr_amg_loc_memory_old(equation3D* &sl, equation3D_bon* &slb,
	int maxelm, int maxbound,
	doublereal *dV, doublereal* &dX0,
	doublereal alpharelax, integer iVar, bool bLRfree, QuickMemVorst& m,
	doublereal &theta82, doublereal &theta83, doublereal &magic82,
	doublereal &magic83, real_mix_precision &ret74, BLOCK* b, int lb,
	int* &ifrontregulationgl, int* &ibackregulationgl,
	SOURCE* &s_loc, int &ls, WALL* &w, int &lw,
	int * &whot_is_block)
{
#ifdef _OPENMP
	int i_my_num_core_parallelesation = omp_get_max_threads();
	omp_set_num_threads(8); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#else
	int i_my_num_core_parallelesation = 1;
#endif
	// Замер времени.
	unsigned int calculation_main_start_time; // начало счёта мс.
	unsigned int calculation_main_end_time; // окончание счёта мс.

	calculation_main_start_time = clock(); // момент начала счёта.

	
	// режим экономии оперативной памяти.
	bool bmemory_savings = true; // true работает только с counting Sort.
	switch (my_amg_manager.imySortAlgorithm) {
	case MY_SORT_ALGORITHM::COUNTING_SORT:
		bmemory_savings = true;
		break;
	case MY_SORT_ALGORITHM::QUICK_SORT: case MY_SORT_ALGORITHM::HEAP_SORT: case MY_SORT_ALGORITHM::TIM_SORT:
		bmemory_savings = false;
		break;
	default:
		bmemory_savings = true;
		break;
	}

	// На случай если память не была выделена.
	if (dX0 == nullptr) {
		dX0 = new doublereal[maxelm + maxbound];
		if (dX0 == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for dX0 my_agregat_amg.cpp...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}
		for (integer i = 0; i<maxelm + maxbound; i++) {
			dX0[i] = 0.0;
		}
		printf("allocation memory for dX0... Ok. dX0 initialization 0.0 value.\n");
	}


	doublereal tmaxloc = -272.15e6;
	for (integer i = 0; i<maxelm; i++) tmaxloc = fmax(tmaxloc, dX0[i]);
	if (iVar==TEMP) {
		printf("Intermediate maximum temperature in default interior\n");
		printf("is equal %e degrees Celsius.\n", tmaxloc);
	}
	doublereal tminloc = 1.0e7;
	for (integer i = 0; i<maxelm; i++) tminloc = fmin(tminloc, dX0[i]);
	if (iVar==TEMP) {
		printf("Intermediate minimum temperature in default interior\n");
		printf("is equal %e degrees Celsius.\n", tminloc);
	}


	const doublereal nonzeroEPS = 1.0e-37; // для отделения вещественного нуля
	doublereal res_sum = 0.0;
	res_sum = 0.0;
	for (integer i = 0; i<maxelm; i++) {
		// внутренность матрицы.
		doublereal buf = 0.0;
		buf = (sl[i].ap*dX0[sl[i].iP] - dV[sl[i].iP]);
		if ((sl[i].iB>-1) && (fabs(sl[i].ab) > nonzeroEPS)) buf -= sl[i].ab*dX0[sl[i].iB];
		if ((sl[i].iE>-1) && (fabs(sl[i].ae) > nonzeroEPS)) buf -= sl[i].ae*dX0[sl[i].iE];
		if ((sl[i].iN>-1) && (fabs(sl[i].an) > nonzeroEPS)) buf -= sl[i].an*dX0[sl[i].iN];
		if ((sl[i].iS>-1) && (fabs(sl[i].as) > nonzeroEPS)) buf -= sl[i].as*dX0[sl[i].iS];
		if ((sl[i].iT>-1) && (fabs(sl[i].at) > nonzeroEPS)) buf -= sl[i].at*dX0[sl[i].iT];
		if ((sl[i].iW>-1) && (fabs(sl[i].aw) > nonzeroEPS)) buf -= sl[i].aw*dX0[sl[i].iW];
		// Дополнение на АЛИС сетке.
		if ((sl[i].iB2>-1) && (fabs(sl[i].ab2) > nonzeroEPS)) buf -= sl[i].ab2*dX0[sl[i].iB2];
		if ((sl[i].iE2>-1) && (fabs(sl[i].ae2) > nonzeroEPS)) buf -= sl[i].ae2*dX0[sl[i].iE2];
		if ((sl[i].iN2>-1) && (fabs(sl[i].an2) > nonzeroEPS)) buf -= sl[i].an2*dX0[sl[i].iN2];
		if ((sl[i].iS2>-1) && (fabs(sl[i].as2) > nonzeroEPS)) buf -= sl[i].as2*dX0[sl[i].iS2];
		if ((sl[i].iT2>-1) && (fabs(sl[i].at2) > nonzeroEPS)) buf -= sl[i].at2*dX0[sl[i].iT2];
		if ((sl[i].iW2>-1) && (fabs(sl[i].aw2) > nonzeroEPS)) buf -= sl[i].aw2*dX0[sl[i].iW2];

		if ((sl[i].iB3>-1) && (fabs(sl[i].ab3) > nonzeroEPS)) buf -= sl[i].ab3*dX0[sl[i].iB3];
		if ((sl[i].iE3>-1) && (fabs(sl[i].ae3) > nonzeroEPS)) buf -= sl[i].ae3*dX0[sl[i].iE3];
		if ((sl[i].iN3>-1) && (fabs(sl[i].an3) > nonzeroEPS)) buf -= sl[i].an3*dX0[sl[i].iN3];
		if ((sl[i].iS3>-1) && (fabs(sl[i].as3) > nonzeroEPS)) buf -= sl[i].as3*dX0[sl[i].iS3];
		if ((sl[i].iT3>-1) && (fabs(sl[i].at3) > nonzeroEPS)) buf -= sl[i].at3*dX0[sl[i].iT3];
		if ((sl[i].iW3>-1) && (fabs(sl[i].aw3) > nonzeroEPS)) buf -= sl[i].aw3*dX0[sl[i].iW3];

		if ((sl[i].iB4>-1) && (fabs(sl[i].ab4) > nonzeroEPS)) buf -= sl[i].ab4*dX0[sl[i].iB4];
		if ((sl[i].iE4>-1) && (fabs(sl[i].ae4) > nonzeroEPS)) buf -= sl[i].ae4*dX0[sl[i].iE4];
		if ((sl[i].iN4>-1) && (fabs(sl[i].an4) > nonzeroEPS)) buf -= sl[i].an4*dX0[sl[i].iN4];
		if ((sl[i].iS4>-1) && (fabs(sl[i].as4) > nonzeroEPS)) buf -= sl[i].as4*dX0[sl[i].iS4];
		if ((sl[i].iT4>-1) && (fabs(sl[i].at4) > nonzeroEPS)) buf -= sl[i].at4*dX0[sl[i].iT4];
		if ((sl[i].iW4>-1) && (fabs(sl[i].aw4) > nonzeroEPS)) buf -= sl[i].aw4*dX0[sl[i].iW4];

		buf *= buf;
		res_sum += buf;
	}
	for (integer i = 0; i<maxbound; i++) {
		// граничные узлы.
		doublereal buf = 0.0;
		buf = slb[i].aw*dX0[slb[i].iW] - dV[slb[i].iW];
		if ((slb[i].iI>-1) && (fabs(slb[i].ai) > nonzeroEPS)) buf -= slb[i].ai*dX0[slb[i].iI];
		buf *= buf;
		res_sum += buf;
	}
	res_sum = sqrt(res_sum);
	printf("input diagnostic residual =%e\n",res_sum);

	if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) {
		if (res_sum > 20.0) {
			printf("Speed diagnostic problem analysys....\n");
		}
	}

	//printf("residual start=%1.4e\n",res_sum);
	//getchar();

	// результаты тестирования
	// задача, начальная невязка , значение евклидовой нормы невязки при которой решение является полученным.
	// tgf01 5.4357e-1 1.0209e-11
	// CGHV1J с метализацией 3.3667e-1 5.0712e-12
	// tgf02 7.6872e-11 1.434e-11
	// tgf05 1.0871e+0  2.2895e-11
	// резистор на 1мм поликоре 5.0e-2 4.9174e-14
	//Diamond ZUb 4 4.0016e-1  4.64444e-11
	// DiamondZUB 4.0016e-1 1.1443e-8
	// NXP100 4.3399e+0  7.8347e-11 (для решения хватило 8Гб ОЗУ.)

	doublereal res_sum_previos = 1.05*finish_residual;
	if ((adiabatic_vs_heat_transfer_coeff > DEFAULT_CABINET_BOUNDARY_CONDITION::ADIABATIC_WALL_BC) ||
		(breakRUMBAcalc_for_nonlinear_boundary_condition)) {
		// Надо пересобирать матрицу и запускать всё по новой т.к. задача 
		// существенно нелинейна.

		// Работает задача Ньютона Рихмана или
		// Стефана Больцмана или миксовая.
		res_sum_previos = 1.0e-12;
	}

	//if (res_sum>1.0E-10) 
	if (res_sum>res_sum_previos) // защита от повторного холостого запуска экономит время конечного пользователя.
	{

		//yes_print_amg=false;
		//yes_print_amg = false;





		integer ierr = 0;
		//doublereal eps = 1.0e-12;

		ierr = 0; // изначальное состояние безошибочное.
				  // Порог точности решения СЛАУ. Значение 1.0E-12 достаточно что проверено в ANSYS icepak.
		//eps = 1.0e-12; // рекомендуемое значение которого достаточно. 

					   // Требования к оперативной памяти.
					   /*     VECTOR         NEEDED LENGTH (GUESS) */
					   /*       Amat               3*NNA + 5*NNU */
					   /*       JA              3*NNA + 5*NNU */
					   /*       IA              2.2*NNU */
					   /*       U               2.2*NNU */
					   /*       F               2.2*NNU */
					   /*       IG              5.4*NNU */


		integer nna = 0; // количество ненулевых элементов в матрице СЛАУ.


						 // подсчёт числа ненулевых элементов в матрице.
		nna = 0;
		for (integer i = 0; i<maxelm; i++) {
			// внутренность матрицы.
			if ((sl[i].iB>-1) && (fabs(sl[i].ab) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE>-1) && (fabs(sl[i].ae) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN>-1) && (fabs(sl[i].an) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS>-1) && (fabs(sl[i].as) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT>-1) && (fabs(sl[i].at) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW>-1) && (fabs(sl[i].aw) > nonzeroEPS)) (nna)++;
			if ((sl[i].iP>-1) && (fabs(sl[i].ap) > nonzeroEPS)) (nna)++;

			// Дополнение на АЛИС сетке:
			if ((sl[i].iB2>-1) && (fabs(sl[i].ab2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE2>-1) && (fabs(sl[i].ae2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN2>-1) && (fabs(sl[i].an2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS2>-1) && (fabs(sl[i].as2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT2>-1) && (fabs(sl[i].at2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW2>-1) && (fabs(sl[i].aw2) > nonzeroEPS)) (nna)++;

			if ((sl[i].iB3>-1) && (fabs(sl[i].ab3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE3>-1) && (fabs(sl[i].ae3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN3>-1) && (fabs(sl[i].an3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS3>-1) && (fabs(sl[i].as3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT3>-1) && (fabs(sl[i].at3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW3>-1) && (fabs(sl[i].aw3) > nonzeroEPS)) (nna)++;

			if ((sl[i].iB4>-1) && (fabs(sl[i].ab4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE4>-1) && (fabs(sl[i].ae4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN4>-1) && (fabs(sl[i].an4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS4>-1) && (fabs(sl[i].as4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT4>-1) && (fabs(sl[i].at4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW4>-1) && (fabs(sl[i].aw4) > nonzeroEPS)) (nna)++;

		}
		for (integer i = 0; i<maxbound; i++) {
			// граничные узлы.
			if ((slb[i].iW>-1) && (fabs(slb[i].aw) > nonzeroEPS)) (nna)++;
			if ((slb[i].iI>-1) && (fabs(slb[i].ai) > nonzeroEPS)) (nna)++;
		}

		integer nnu = 0; // число неизвестных.
		nnu = maxelm + maxbound;

		/*
		// Рекомендуемые по умолчанию параметры.
		integer nda=0; // память под вектор значений матрицы слау.
		nda=3*(nna)+5*(nnu);
		integer ndia=0;
		ndia=(integer)(2.2*(nnu));
		integer ndja=0;
		ndja=3*(nna)+5*(nnu);
		integer ndu=0;
		ndu=(integer)(2.2*(nnu));
		integer ndf=0;
		ndf=(integer)(2.2*(nnu));
		integer ndig=0;
		ndig=(integer)(5.4*(nnu));
		*/

		/*
		// в двое больше памяти чем рекомендовано.
		integer nda=0; // память под вектор значений матрицы слау.
		nda=6*(nna)+10*(nnu);
		integer ndia=0;
		ndia=(integer)(4.4*(nnu));
		integer ndja=0;
		ndja=6*(nna)+10*(nnu);
		integer ndu=0;
		ndu=(integer)(4.4*(nnu));
		integer ndf=0;
		ndf=(integer)(4.4*(nnu));
		integer ndig=0;
		ndig=(integer)(10.8*(nnu));
		*/

		// данная константа работоспособна вплоть до размерностей сетки равных 34млн 463тысячи 250узлов.
		//doublereal rsize=1.51; // 1048416
		// Вынужденные течения достаточно 2.5. 
		// на задаче Концевого Ю.А. Электростатика со столбиком в случае сетки со сгущением достаточно 2.0.


		Ak1* Amat = nullptr;
		Ak1* R = nullptr;
		Ak1* P = nullptr;
		//Ak1* Atemp = nullptr;
		//Ak1* Atemp2 = nullptr;
		doublereal* rthdsd_amg = nullptr;
		doublereal* result_amg = nullptr;
		// 18 августа 2016
		// граничные узлы требуют особой обработки.
		// true - граничный узел, false - внутренний.
		bool* bamg_bound = nullptr;




		/*     CLASS 3 - PARAMETERS: */

		/*     LEVELX   -   MAXIMUM NUMBER OF MG-LEVELS TO BE CREATED (>=1). */

		/*     IFIRST   -   PARAMETER FOR FIRST APPROXIMATION. */

		/*                  1ST DIGIT OF IFIRST: NOT USED; HAS TO BE NON-ZERO. */

		/*                  2ND DIGIT OF IFIRST  --  ITYPU: */
		/*                    =0: NO SETTING OF FIRST APPROXIMATION, */
		/*                    =1: FIRST APPROXIMATION CONSTANT TO ZERO, */
		/*                    =2: FIRST APPROXIMATION CONSTANT TO ONE, */
		/*                    =3: FIRST APPROXIMATION IS RANDOM FUNCTION WITH */
		/*                        THE CONCRETE RANDOM SEQUENCE BEING DETERMINED */
		/*                        BY THE FOLLWING DIGITS. */

		/*                  REST OF IFIRST  --  RNDU: */
		/*                    DETERMINES THE CONCRETE RANDOM SEQUENCE USED IN */
		/*                    THE CASE ITYPU=3. (IFIRST=13 IS EQUIVALENT TO */
		/*                    IFIRST=1372815) */

		/*     NCYC     -   INTEGER PARAMETER DESCRIBING THE TYPE OF CYCLE TO BE */
		/*                  USED AND THE NUMBER OF CYCLES TO BE PERFORMED. */

		/*                  1ST DIGIT OF NCYC  --  IGAM: */
		/*                    =1: V -CYCLE, */
		/*                    =2: V*-CYCLE, */
		/*                    =3: F -CYCLE, */
		/*                    =4: W -CYCLE. */
		/*                  IF NCYC IS NEGATIV, THEN THE APPROXIMATION OF THE */
		/*                  PROBLEM ON THE SECOND FINEST GRID IS COMPUTED BY */
		/*                  IGAM V-CYCLES ON THAT PARTICULAR GRID. */

		/*                  2ND DIGIT OF NCYC  --  ICGR: */
		/*                    =0: NO CONJUGATE GRADIENT, */
		/*                    =1: CONJUGATE GRADIENT (ONLY FIRST STEP OF CG), */
		/*                    =2: CONJUGATE GRADIENT (FULL CG). */

		/*                  3RD DIGIT OF NCYC  --  ICONV: */
		/*                    CONVERGENCE CRITERION FOR THE USER-DEFINED PROBLEM */
		/*                    (FINEST GRID): */
		/*                    =1: PERFORM Amat FIXED NUMBER OF CYCLES AS GIVEN BY */
		/*                        NCYCLE (SEE BELOW) */
		/*                    =2: STOP, IF  ||RES|| < EPS */
		/*                    =3: STOP, IF  ||RES|| < EPS * |F| */
		/*                    =4: STOP, IF  ||RES|| < EPS * |U| * |DIAG| */
		/*                    WITH ||RES|| = L2-NORM OF RESIDUAL, */
		/*                           EPS     (SEE INPUT PARAMETER EPS) */
		/*                           |F|   = SUPREMUM NORM OF RIGHT HAND SIDE */
		/*                           |U|   = SUPREMUM NORM OF SOLUTION */
		/*                         |DIAG|  = MAXIMAL DIAGONAL ENTRY IN MATRIX L */
		/*                    NOTE THAT IN ANY CASE THE SOLUTION PROCESS STOPS */
		/*                    AFTER AT MOST NCYCLE CYCLES. */

		/*                  REST OF NCYC  --  NCYCLE: */
		/*                    MAXIMAL NUMBER OF CYCLES TO BE PERFORMED (>0) OR */
		/*                    NCYCLE=0: NO CYCLING. */

		/*     EPS      -   CONVERGENCE CRITERION FOR SOLUTION PROCESS: (SEE */
		/*                  PARAMETER NCYC). NOTE THAT NO MORE THAN NCYCLE CYCLES */
		/*                  ARE PERFORMED, REGARDLESS OF EPS. */

		/*     MADAPT   -   INTEGER VALUE SPECIFYING THE CHOICE OF COARSEST */
		/*                  GRID IN CYCLING: */

		/*                  1ST DIGIT OF MADAPT  --  MSEL: */
		/*                    =1: IN CYCLING, ALL GRIDS CONSTRUCTED IN THE SETUP */
		/*                        PHASE ARE USED WITHOUT CHECK. */
		/*                    =2: THE NUMBER OF GRIDS IS AUTOMATICALLY REDUCED */
		/*                        IF THE CONVERGENCE FACTOR ON THE COARSER GRIDS */
		/*                        IS FOUND TO BE LARGER THAN Amat GIVEN VALUE FAC */
		/*                        (SEE BELOW). */

		/*                  REST OF MADAPT  --  FAC */
		/*                        THE REST OF MADAPT DEFINES THE FRACTIONAL PART */
		/*                        OF Amat REAL NUMBER FAC BETWEEN 0.1 AND 0.99, E.G. */
		/*                        MADAPT=258 MEANS MSEL=2 AND FAC=0.58. IF MADAPT */
		/*                        CONSISTS OF ONLY ONE DIGIT, FAC IS SET TO 0.7 */
		/*                        BY DEFAULT. */


		/*     NRD      -   PARAMETER DESCRIBING RELAXATION (DOWNWARDS): */

		/*                  1ST DIGIT OF NRD: NOT USED; HAS TO BE NON-ZERO. */

		/*                  2ND DIGIT OF NRD  --  NRDX: */
		/*                    ACTUAL NUMBER OF SMOOTHING STEPS TO BE PERFORMED */
		/*                    THE TYPE OF WHICH IS GIVEN BY THE FOLLOWING DIGITS */

		/*                  FOLLOWING DIGITS  --  ARRAY NRDTYP: */
		/*                    =1: RELAXATION OVER THE F-POINTS ONLY */
		/*                    =2: FULL GS SWEEP */
		/*                    =3: RELAXATION OVER THE C-POINTS ONLY */
		/*                    =4: FULL MORE COLOR SWEEP, HIGHEST COLOR FIRST */

		/*     NSOLCO   -   PARAMETER CONTROLLING THE SOLUTION ON COARSEST GRID: */

		/*                  1ST DIGIT  --  NSC: */
		/*                    =1: GAUSS-SEIDEL METHOD */
		/*                    =2: DIRECT SOLVER (YALE SMP) */

		/*                  REST OF NSOLCO  --  NRCX: (ONLY IF NSC=1) */
		/*                  NUMBER OF GS SWEEPS ON COARSEST GRID (>=0). */
		/*                  IF NRCX=0, THEN AS MANY GS SWEEPS ARE PERFORMED */
		/*                  AS ARE NEEDED TO REDUCE THE RESIDUAL BY TWO ORDERS */
		/*                  OF MAGNITUDE. (MAXIMAL 100 RELAXATION SWEEPS) */

		/*     NRU      -   PARAMETER FOR RELAXATION (UPWARDS), ANALOGOUS TO NRD. */

		/*         -------------------------------------------------------------- */

		/*     CLASS 4 - PARAMETERS: */

		/*     ECG1,ECG2-   REAL PARAMETERS AFFECTING THE CREATION OF COARSER */
		/*     EWT2     -   GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
		/*                  THE CHOICE OF THESE PARAMETERS DEPENDS ON */
		/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

		/*     NWT      -   INTEGER PARAMETER AFFECTING THE CREATION OF COARSER */
		/*                  GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
		/*                  THE CHOICE OF THIS PARAMETER DEPENDS ON */
		/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

		/*     NTR      -   PARAMETER CONTROLLING COARSE-GRID OPERATOR TRUNCATION */
		/*                    =0: PAIRS OF ZEROES ARE REMOVED FROM COARSE GRID */
		/*                        OPERATORS */
		/*                    =1: NO COARSE-GRID OPERATOR TRUNCATION */



		/*     STANDARD CHOICES OF PARAMETERS (AS FAR AS MEANINGFUL): */

		/*          ISWTCH = 4 */
		/*          IOUT   = 12 */
		/*          IPRinteger = 10606 */

		/*          LEVELX = 25 */
		/*          IFIRST = 13 */
		/*          NCYC   = 10110 */
		/*          EPS    = 1.D-12 */
		/*          MADAPT = 27 */
		/*          NRD    = 1131 */
		/*          NSOLCO = 110 */
		/*          NRU    = 1131 */

		/*          ECG1   = 0. */
		/*          ECG2   = 0.25 */
		/*          EWT2   = 0.35 */
		/*          NWT    = 2 */
		/*          NTR    = 0 */



		// рекомедуемые параметры по дефолту.
		/*
		integer iswtch = 0;
		iswtch = 4;
		integer iout = 0;
		iout = 12;
		integer iprinteger = 0;
		iprinteger = 10606;
		integer levelx = 0;
		levelx = 25;
		integer ifirst = 0;
		// начальное приближение:
		// 0 - используется из вне.
		// 1 - нулевое.
		// 2 - единицы.
		// 3 - случайная последовательность.
		ifirst = 13;//13 по умолчанию.
		//ifirst=11; // нулевое начальное приближение.
		//ifirst=10; // вроде как начальное приближение берётся из dX0.
		// но 10 никоим образом не улучшает сходимость.
		integer ncyc = 0;
		ncyc = 10110;
		integer madapt = 0;
		madapt = 27;
		integer nrd = 0;
		nrd = 1131;
		integer nsolco = 0;
		nsolco = 110;
		integer nru = 0;
		nru = 1131;
		doublereal ecg1 = 0.0;
		ecg1 = 0.0;
		doublereal ecg2 = 0.0;
		ecg2 = 0.25;
		doublereal ewt2 = 0.0;
		ewt2 = 0.35;
		integer nwt = 0;
		nwt = 2;
		integer ntr = 0;
		ntr = 0;

		integer matrix = 0;
		//matrix=11; // symmetric SPD.
		matrix = 22;

		if ((iVar == PAM) && (bLRfree)) {
		//printf("work amg1r5\n");
		//getchar();
		// Симметричная положительно определённая матрица это такая матрица
		// которая возникает для поправки давления при решении вязких несжимаемых уравнений Навье-Стокса в
		// случае задач: каверна, тест Валь-Девиса. Для задач промышленного масштаба это всякие естественные
		// конвекции охлаждающие висящие в воздухе без контакта с теплоотводом греющиеся изделия.
		// Это особый специфический класс задач.
		matrix = 11;
		}
		*/
       // для прямой интерполяции с элементами непрямой можно выставить коэффициент 3 и освободить память из под 
       // исходной матрицы (для той структуры на которой была выполнена сборка матрицы изначально). 

		// allocate memory 2 jan 2016.
        // BSK Dmitrii 3.012  (2.892 для прямой интерполяции с элементами непрямой). 
        // tgf series no metalization
        // tgf2023-2_01 2.64 643mb
        // tgf2023-2-02 2.58 988mb
        // tgf2023-2-05 2.44 2022mb
        // tgf2023-2-20 3.58 2967mb
        // CGHV1J metalization 3.133 (2.84 для прямой интерполяции с элементами непрямой). 
        // тор Докторович 2.89
        // Концевой 3.05
        // Концевой со столбиком 3.7М 2.97 (6.0 у amg1r5) 4110.6Мb.
        // Вывод: максимальное значение 3.15 а значит значения 4 должно хватить с запасом У amg1r5 максимальное значение 9.0.
        // Можно сказать что данный amg требует вдвое меньше памяти по сравнению с amg1r5.
        // Была найдена статья в интернете которая подтверждала что константа памяти у amg1r5 равна 8.
        // Также был найден ряд статей в которых подтверждается констата близкая к 3 для CAMG.
		//Amat = new Ak1[(integer)(7 * nna) + 1]; // 6 // 45 // 4
        // памяти надо много для 6 варианта интерполяции.
// 9,35,35 28
        integer nsizeA = ((integer)(9 * nna) + 1);
		integer nsizePR = 35;

		if (bPhysics_PTBSH_memory==true) {
			// ПТБШ.
			//printf("bPhysics_PTBSH_memory==true\n");
			nsizeA = ((integer)(4 * nna) + 1);
			nsizePR = 13;
		}

		// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
		// Т.к. есть трудносходящиеся задачи, то эти настройки должны помоч.
		// Истина в том что количество потребляемой оперативной памяти очень сильно зависит от особеностей
		// пользовательской геометрии (того что пользователь начертил в интерфейсе).
		// Иногда достаточно 4 размеров матрицы, а иногда нехватает и 12. Каждая новая задача должна настраиваться 
		// в идеале индивидуально, если пользователь хочет выжить максимум из своего оборудования.
		nsizeA = ((integer)(my_amg_manager.memory_size * nna) + 1);
		if (my_amg_manager.iprint_log == 1) {
#if doubleintprecision == 1
			printf("memory size const is=%lld\n", my_amg_manager.memory_size);
#else
			printf("memory size const is=%d\n", my_amg_manager.memory_size);
#endif
			
		}
		nsizePR = 35;
		if (bonly_solid_calculation) {
			// 31 октября 2016.
			// По моим замерам с надёжным запасом в 30% для всех твёрдотельных 
			// задач должно хватить значения 12.
			nsizePR = 12;
		}

		// Требует заголовочного файла windows.h
		// Зависимый от ОС Windows код.
		//MEMORYSTATUSEX statex;
		//statex.dwLength = sizeof(statex);
		//GlobalMemoryStatusEx(&statex);
		//char divisor[2] = "M";
		//if (my_amg_manager.iprint_log == 1) {
			//printf("physical memory is %lld total  %sbytes \n", statex.ullTotalPhys / (1024 * 1024), divisor);
			//printf("%ld %% of memory is in use.\n", statex.dwMemoryLoad);
			//printf("required %lld %sbytes\n", (integer)((nsizeA / (1024 * 1024)) * sizeof(Ak1) + 2 * (((nsizePR / (1024 * 1024))* nnu) + 1) * sizeof(Ak1)), divisor);
			//system("pause");
		//}

		char c1[22] = "my_agr_amg_loc_memory";
		char c2[5] = "Amat";
		Amat = (Ak1*)malloc(nsizeA*sizeof(Ak1));  // 9
		handle_error<Ak1>(Amat, c2, c1, (nsizeA));
		
		char c0[11] = "bamg_bound";
		bamg_bound = new bool[((nsizePR * nnu) + 1)];
		handle_error<bool>(bamg_bound, c0, c1, ((nsizePR * nnu) + 1));
		
		
		// real size 9.4 for resistor.
		// 
		/*
		Atemp = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
		if (Atemp == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for Atemp matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		// real size 9.4 for resistor.
		Atemp2 = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
		if (Atemp2 == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for Atemp2 matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		*/

		//result_amg = new doublereal[nnu + 1];
		result_amg = (doublereal*)malloc((nnu + 1)*sizeof(doublereal));
		char c3[11] = "result_amg";
		handle_error<doublereal>(result_amg, c3, c1, (nnu + 1));
		

		//rthdsd_amg = new doublereal[nnu + 1];
		rthdsd_amg = (doublereal*)malloc((nnu + 1)*sizeof(doublereal));
		char c4[11] = "rthdsd_amg";
		handle_error<doublereal>(rthdsd_amg,c4 , c1, (nnu + 1));
		


		// правая часть.
		/*
		for (integer i = 0; i < nnu; i++) {
		rthdsd_amg[i] = 0.0;
		if (i<maxelm + maxbound) {
		// обязательно нужно проверить была ли выделена оперативная память.
		rthdsd_amg[i + 1] = dV[i];
		}
		}
		rthdsd_amg[0] = 0.0;
		*/
		/*
		// вектор решения.
		for (integer i = 0; i < nnu; i++) {
		result_amg[i] = 0.0;
		if (i<maxelm + maxbound) {
		// обязательно нужно проверить была ли выделена оперативная память.
		result_amg[i + 1] = dX0[i];
		}
		}
		result_amg[0] = 0.0;
		*/

		// см. equation3DtoCRS.

		integer ik = 0; // счётчик ненулевых элементов СЛАУ
		integer id = 1;

		//if (iVar == PAM) {
			//printf("alpharelax=%e\n", alpharelax);
		//	getchar();
		//}
		
		integer* icompression = nullptr;
		doublereal* rcompressionb = nullptr;
		if (bmemory_savings &&(!b_on_adaptive_local_refinement_mesh)) {
			icompression= (integer*)malloc((7*maxelm + 1) * sizeof(integer)); // +1 запас.
			char c5[13] = "icompression";
			handle_error<integer>(icompression, c5, c1, (7 * maxelm + 1));
			for (integer i_1 = 0; i_1 < (7 * maxelm + 1); i_1++) {
				icompression[i_1] = -1;
			}
			rcompressionb= (doublereal*)malloc(( maxelm + 1) * sizeof(doublereal)); // +1 запас.
			char c6[14] = "rcompressionb";
			handle_error<doublereal>(rcompressionb,c6, c1, (maxelm + 1));
			for (integer i_1 = 0; i_1 < (maxelm); i_1++) {
				rcompressionb[i_1] = sl[i_1].b;
			}
		}

		integer iscan1 = 0;
		//printf("alpharelax=%e\n", alpharelax);
		//getchar();
		// для внутренних узлов расчётной области:
		for (integer k = 0; k<maxelm; k++) {
			//printf("%e %e %e %e %e %e %e\n", sl[k].ap / alpharelax, -sl[k].ae, -sl[k].aw, -sl[k].an, -sl[k].as, -sl[k].at, -sl[k].ab);
			//system("pause");

			if (fabs(sl[k].ap) > nonzeroEPS) {
				Amat[ik + id].aij = (real_mix_precision)(sl[k].ap / alpharelax);
				Amat[ik + id].j = sl[k].iP + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				bamg_bound[Amat[ik + id].i] = false;
				rthdsd_amg[sl[k].iP + 1] = dV[sl[k].iP];
				result_amg[sl[k].iP + 1] = dX0[sl[k].iP];
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iE>-1) && (fabs(sl[k].ae) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].ae);
				Amat[ik + id].j = sl[k].iE + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iN>-1) && (fabs(sl[k].an) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].an);
				Amat[ik + id].j = sl[k].iN + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iT>-1) && (fabs(sl[k].at) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].at);
				Amat[ik + id].j = sl[k].iT + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iS>-1) && (fabs(sl[k].as) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].as);
				Amat[ik + id].j = sl[k].iS + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iW>-1) && (fabs(sl[k].aw) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].aw);
				Amat[ik + id].j = sl[k].iW + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iB>-1) && (fabs(sl[k].ab) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].ab);
				Amat[ik + id].j = sl[k].iB + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			// icompression - применяется только для структурированной сетки.
			// Дополнение на АЛИС сетке:
			if ((sl[k].iE2>-1) && (fabs(sl[k].ae2) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].ae2);
				Amat[ik + id].j = sl[k].iE2 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iN2>-1) && (fabs(sl[k].an2) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].an2);
				Amat[ik + id].j = sl[k].iN2 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iT2>-1) && (fabs(sl[k].at2) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].at2);
				Amat[ik + id].j = sl[k].iT2 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iS2>-1) && (fabs(sl[k].as2) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].as2);
				Amat[ik + id].j = sl[k].iS2 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iW2>-1) && (fabs(sl[k].aw2) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].aw2);
				Amat[ik + id].j = sl[k].iW2 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iB2>-1) && (fabs(sl[k].ab2) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].ab2);
				Amat[ik + id].j = sl[k].iB2 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}

			if ((sl[k].iE3>-1) && (fabs(sl[k].ae3) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].ae3);
				Amat[ik + id].j = sl[k].iE3 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iN3>-1) && (fabs(sl[k].an3) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].an3);
				Amat[ik + id].j = sl[k].iN3 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iT3>-1) && (fabs(sl[k].at3) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].at3);
				Amat[ik + id].j = sl[k].iT3 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iS3>-1) && (fabs(sl[k].as3) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].as3);
				Amat[ik + id].j = sl[k].iS3 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iW3>-1) && (fabs(sl[k].aw3) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].aw3);
				Amat[ik + id].j = sl[k].iW3 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iB3>-1) && (fabs(sl[k].ab3) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].ab3);
				Amat[ik + id].j = sl[k].iB3 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}

			if ((sl[k].iE4>-1) && (fabs(sl[k].ae4) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].ae4);
				Amat[ik + id].j = sl[k].iE4 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iN4>-1) && (fabs(sl[k].an4) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].an4);
				Amat[ik + id].j = sl[k].iN4 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;				
			}
			if ((sl[k].iT4>-1) && (fabs(sl[k].at4) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].at4);
				Amat[ik + id].j = sl[k].iT4 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iS4>-1) && (fabs(sl[k].as4) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].as4);
				Amat[ik + id].j = sl[k].iS4 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iW4>-1) && (fabs(sl[k].aw4) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].aw4);
				Amat[ik + id].j = sl[k].iW4 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iB4>-1) && (fabs(sl[k].ab4) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-sl[k].ab4);
				Amat[ik + id].j = sl[k].iB4 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}

		}

		
		
		// для внутренних узлов расчётной области:
		for (integer k = 0; k<maxbound; k++) {
			if (fabs(slb[k].aw) > nonzeroEPS) {
				// val[ik]=slb[k].aw/alpharelax;
				Amat[ik + id].aij = (real_mix_precision)(slb[k].aw); // релаксация для граничных узлов не применяется.
											/*if ((slb[k].iI>-1) && (fabs(slb[k].ai) > nonzeroEPS)) {
											// Внимание !!! было произведено тестирование: один вариант был с нижней релаксацией для граничных узлов,
											// а второй вариант был без нижней релаксации на граничных узлах. Было выяснено, что для сходимости
											// более благоприятен вариант без нижней релаксации на граничных узлах.
											// Данное изменение согласовано с функцией solve.

											val[ik]/=alpharelax; // Если условия Неймана то нижняя релаксация.
											}*/
				Amat[ik + id].j = slb[k].iW + 1;
				Amat[ik + id].i = slb[k].iW + 1; // dirichlet
				if (!((slb[k].iI > -1) && (fabs(slb[k].ai) > nonzeroEPS))) {
					// Dirichlet value.
					// Значения Дирихле мы сразу априорно помещаем в C nodes.
					//bamg_bound[Amat[ik + id].i] = true;
					// Это глупость. Наоборот все узлы Дирихле становятся С узлами сразу.
				}
				else {
					// Neiman.
					// Условия Неймана при построении C/F разбиения обрабатываем как обычно как внутренний узел.
					bamg_bound[Amat[ik + id].i] = false;
				}
				rthdsd_amg[slb[k].iW + 1] = dV[slb[k].iW];
				result_amg[slb[k].iW + 1] = dX0[slb[k].iW];
				ik++;
			}
			if ((slb[k].iI>-1) && (fabs(slb[k].ai) > nonzeroEPS)) {
				Amat[ik + id].aij = (real_mix_precision)(-slb[k].ai);
				Amat[ik + id].j = slb[k].iI + 1;
				Amat[ik + id].i = slb[k].iW + 1;
				//rthdsd_amg[slb[k].iW + 1] = dV[slb[k].iW];
				//result_amg[slb[k].iW + 1] = dX0[slb[k].iW];
				// Это очень важный вопрос и он требует проверки !

				ik++;
			}

		}


		for (integer k = 0; k <= maxelm + maxbound; k++) {
			bamg_bound[k] = false;
		}

		// Освободим немного памяти.
		// Т.к. мы оперируем в мультигриде в девять раз большим объёмом памяти то это уничтожение не является
		// чем-то медленным по сравнению с ресурсами мультигрида.
		if (bmemory_savings &&(!b_on_adaptive_local_refinement_mesh)) {
			// Только в случае структурированной сетки  мы компрессируем исходную матрицу чтобы высвободить оперативную память.
			delete[] sl;
			sl = nullptr;
		}
		//delete[] slb;
		//slb = nullptr;

		//R = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
		R = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
		char c7[2] = "R";
		handle_error<Ak1>(R, c7, c1, ((nsizePR * nnu) + 1));
	     	
		//P = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
		P = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
		char c8[2] = "P";
		handle_error<Ak1>(P, c8, c1, ((nsizePR * nnu) + 1));


		// TODO: 
		// нужно акуратно прописать выделения и уничтожения памяти с учётом того что было сделано в BiCGStabP.

		// Экономим 1 размер матрицы для мультигрида.
		//delete[] sl;
		//delete[] slb;



		//printf("getready ...");
		//getchar();
		// amg - особенно хорош для поправки давления в SIMPLE алгоритме.
		// свой алгоритм 2015 года.


		//aggregative_amg(Amat, nna, nnu, R, P, result_amg, rthdsd_amg);

		//printf("allocation memory is Ok. start ready...\n");
		//system("pause");
		doublereal theta = 0.24; // 3D // 0.25 по литературным  данным. 0.24 оптимально из практики (реальное тестирование).
		//theta = 0.5; // может поможет  для конвективных задач
		doublereal* x_copy = nullptr;
		x_copy = (doublereal*)malloc((nnu + 1)*sizeof(doublereal));
		char c9[7] = "x_copy";
		handle_error<doublereal>(x_copy, c9,c1, (nnu + 1));

		for (integer i47 = 1; i47 <= nnu; i47++) {
			x_copy[i47] = result_amg[i47];
		}

		//doublereal theta83 = 0.23;
		//doublereal magic82 = 0.4;
		//doublereal magic83 = 0.5; 
		//doublereal ret74 = 0.0;
		bool bdivergence_detected = false;


		//Внимание можно использовать только double, с float сходимости нет.
		if (iswitchsolveramg_vs_BiCGstab_plus_ILU2 == 7) {
			//float theta82f=(float)theta82, theta83f= (float)theta83, magic82f= (float)magic82, magic83f= (float)magic83, ret74f= (float)ret74;
			real_mix_precision theta82f = (real_mix_precision)theta82, theta83f = (real_mix_precision)theta83, magic82f = (real_mix_precision)magic82, magic83f = (real_mix_precision)magic83, ret74f = (real_mix_precision)ret74;
			bdivergence_detected = classic_aglomerative_amg4<real_mix_precision>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg,  theta82f, theta83f, magic82f, magic83f, ret74f, iVar, bmemory_savings,b, lb, maxelm, whot_is_block);
			//bdivergence_detected = classic_aglomerative_amg6<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm);
		}
		else {
			//float theta82f = (float)theta82, theta83f = (float)theta83, magic82f = (float)magic82, magic83f = (float)magic83, ret74f = (float)ret74;
			real_mix_precision theta82f = (real_mix_precision)theta82, theta83f = (real_mix_precision)theta83, magic82f = (real_mix_precision)magic82, magic83f = (real_mix_precision)magic83, ret74f = (real_mix_precision)ret74;
			//bdivergence_detected = classic_aglomerative_amg5<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82f, theta83f, magic82f, magic83f, ret74f, iVar, bmemory_savings);
			bdivergence_detected = classic_aglomerative_amg5<real_mix_precision>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82f, theta83f, magic82f, magic83f, ret74, iVar, bmemory_savings);
		}
		// если работа amg была неудачна то мы не портим переполнение рабочий вектор результата.
		// Перенаправление на стабильную версию алгоритма.
		if (bdivergence_detected) {
			//system("pause");
			integer maxit = 2000;
			bool bprintmessage = false;
			integer* icol_stub = nullptr;
			Bi_CGStab_internal3(sl, slb, maxelm, maxbound, dV, dX0, maxit, alpharelax, bprintmessage, iVar, m, ifrontregulationgl, ibackregulationgl, b, lb, s_loc, ls, 100000000,icol_stub, 0, false,w,lw);
		}
		else
		{
			// Работа amg была успешна.
			for (integer i47 = 1; i47 <= nnu; i47++) {
				result_amg[i47] = x_copy[i47];
			}
		}
		if (x_copy != nullptr) {
			free(x_copy);
			x_copy = nullptr;
		}

	    //system("pause");

		

		// возвращаем решение СЛАУ.
		// вектор решения. 
		for (integer i = 0; i < nnu; i++) {
			if (i<maxelm + maxbound) {
				// обязательно нужно проверить была ли выделена оперативная память. 
				dX0[i] = result_amg[i + 1];
			}
		}

		
		
		if (R != nullptr) {
			//delete[] R;
			free(R);
		}
		if (P != nullptr) {
		    //delete[] P;
			free(P);
		}
		if (bamg_bound != nullptr) {
			delete[] bamg_bound;
			bamg_bound = nullptr;
		}
		//if (Atemp != nullptr) {
			//delete[] Atemp;
		//}
		//if (Atemp2 != nullptr) {
			//delete[] Atemp2;
		//}
		if (result_amg != nullptr) {
			//delete[] result_amg;
			free(result_amg);
		}
		if (rthdsd_amg != nullptr) {
			//delete[] rthdsd_amg;
			free(rthdsd_amg);
		}

		if (bmemory_savings &&(!b_on_adaptive_local_refinement_mesh)) {
			sl = new equation3D[maxelm]; // коэффициенты матрицы СЛАУ для внутренних КО.
			if (sl == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for slau temperature constr struct...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}
		}


		/*
		slb = new equation3D_bon[maxbound]; // коэффициенты матрицы СЛАУ для граничных КО
		if (slb == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for slau boundary temperature constr struct...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		*/
		if (bmemory_savings &&(!b_on_adaptive_local_refinement_mesh)) {
			// Разархивация исходной матрицы А в первоначальном формате.
			// Предполагается что матрица на структурированной декартовой прямоугольной сетке.
			// Как бы мы не пытались здесь, но матрица не сохраняемая в файл не подлежит здесь восстановлению,
			// а операция записи в файл чрезвычайно медленная.
			for (integer k = 0; k < maxelm; k++) {
				
				sl[k].bB2 = false;
				sl[k].bB3 = false;
				sl[k].bB4 = false;
				sl[k].bE2 = false;
				sl[k].bE3 = false;
				sl[k].bE4 = false;
				sl[k].bN2 = false;
				sl[k].bN3 = false;
				sl[k].bN4 = false;
				sl[k].bT2 = false;
				sl[k].bT3 = false;
				sl[k].bT4 = false;
				sl[k].bW2 = false;
				sl[k].bW3 = false;
				sl[k].bW4 = false;
				sl[k].bS2 = false;
				sl[k].bS3 = false;
				sl[k].bS4 = false;
				
				sl[k].iB = -1;
				sl[k].iB2 = -1;
				sl[k].iB3 = -1;
				sl[k].iB4 = -1;
				sl[k].iE = -1;
				sl[k].iE2 = -1;
				sl[k].iE3 = -1;
				sl[k].iE4 = -1;
				sl[k].iN = -1;
				sl[k].iN2 = -1;
				sl[k].iN3 = -1;
				sl[k].iN4 = -1;
				sl[k].iS = -1;
				sl[k].iS2 = -1;
				sl[k].iS3 = -1;
				sl[k].iS4 = -1;
				sl[k].iT = -1;
				sl[k].iT2 = -1;
				sl[k].iT3 = -1;
				sl[k].iT4 = -1;
				sl[k].iW = -1;
				sl[k].iW2 = -1;
				sl[k].iW3 = -1;
				sl[k].iW4 = -1;
				sl[k].ab = 0.0;
				sl[k].ae = 0.0;
				sl[k].an = 0.0;
				sl[k].as = 0.0;
				sl[k].at = 0.0;
				sl[k].aw = 0.0;
				sl[k].ab2 = 0.0;
				sl[k].ae2 = 0.0;
				sl[k].an2 = 0.0;
				sl[k].as2 = 0.0;
				sl[k].at2 = 0.0;
				sl[k].aw2 = 0.0;
				sl[k].ab3 = 0.0;
				sl[k].ae3 = 0.0;
				sl[k].an3 = 0.0;
				sl[k].as3 = 0.0;
				sl[k].at3 = 0.0;
				sl[k].aw3 = 0.0;
				sl[k].ab4 = 0.0;
				sl[k].ae4 = 0.0;
				sl[k].an4 = 0.0;
				sl[k].as4 = 0.0;
				sl[k].at4 = 0.0;
				sl[k].aw4 = 0.0;
				sl[k].ap = 0.0;
				integer iadd = 7 * k;
				sl[k].b = rcompressionb[k];
				//p e n t s w b
				sl[k].ap = 1.0/Amat[the_original_order_of_values[icompression[iadd + 0]]].aij;
				sl[k].iP = Amat[the_original_order_of_values[icompression[iadd + 0]]].i - 1;
				if (icompression[iadd + 1] > -1) {
					// E
					sl[k].ae = -Amat[the_original_order_of_values[icompression[iadd + 1]]].aij;
					sl[k].iE = Amat[the_original_order_of_values[icompression[iadd + 1]]].j - 1;
				}
				if (icompression[iadd + 2] > -1) {
					// N
					sl[k].an = -Amat[the_original_order_of_values[icompression[iadd + 2]]].aij;
					sl[k].iN = Amat[the_original_order_of_values[icompression[iadd + 2]]].j - 1;
				}
				if (icompression[iadd + 3] > -1) {
					// T
					sl[k].at = -Amat[the_original_order_of_values[icompression[iadd + 3]]].aij;
					sl[k].iT = Amat[the_original_order_of_values[icompression[iadd + 3]]].j - 1;
				}
				if (icompression[iadd + 4] > -1) {
					// S
					sl[k].as = -Amat[the_original_order_of_values[icompression[iadd + 4]]].aij;
					sl[k].iS = Amat[the_original_order_of_values[icompression[iadd + 4]]].j - 1;
				}
				if (icompression[iadd + 5] > -1) {
					// W
					sl[k].aw = -Amat[the_original_order_of_values[icompression[iadd + 5]]].aij;
					sl[k].iW = Amat[the_original_order_of_values[icompression[iadd + 5]]].j - 1;
				}
				if (icompression[iadd + 6] > -1) {
					// B
					sl[k].ab = -Amat[the_original_order_of_values[icompression[iadd + 6]]].aij;
					sl[k].iB = Amat[the_original_order_of_values[icompression[iadd + 6]]].j - 1;
				}

				//if ((k == 6867418)||(k==68675507)) {
					//printf("ap=%e aw=%e ae=%e as=%e an=%e ab=%e at=%e \n", sl[k].ap, sl[k].aw, sl[k].ae, sl[k].as, sl[k].an, sl[k].ab, sl[k].at);
					//getchar();
				//}
			}

			if (icompression != nullptr) free(icompression);
			icompression = nullptr;
			
			if (rcompressionb != nullptr) free(rcompressionb);
			rcompressionb = nullptr;

			

		}

		if (the_original_order_of_values != nullptr) {
			free(the_original_order_of_values);
			the_original_order_of_values = nullptr;
		}
		if (the_original_order_of_values_reverse != nullptr) {
			free(the_original_order_of_values_reverse);
			the_original_order_of_values_reverse = nullptr;
		}

		/*
		for (integer i1 = 0; i1 < maxbound; i1++) {
			slb[i1].iI = -1;
			slb[i1].ai = 0.0;
			slb[i1].aw = 0.0;
		}
		// Если это раскоментировать то res_sum надо извлекать из нутра мультигрида.
		*/

		
		// освобождение памяти.
		if (Amat != nullptr) {
			//delete[] Amat;
			free(Amat);
			Amat = nullptr;
		}

		res_sum = 0.0;
		for (integer i1 = 0; i1<maxelm; i1++) {
			// внутренность матрицы.
			doublereal buf = 0.0;
			buf = (sl[i1].ap*dX0[sl[i1].iP] - dV[sl[i1].iP]);
			if ((sl[i1].iB>-1) && (fabs(sl[i1].ab) > nonzeroEPS)) buf -= sl[i1].ab*dX0[sl[i1].iB];
			if ((sl[i1].iE>-1) && (fabs(sl[i1].ae) > nonzeroEPS)) buf -= sl[i1].ae*dX0[sl[i1].iE];
			if ((sl[i1].iN>-1) && (fabs(sl[i1].an) > nonzeroEPS)) buf -= sl[i1].an*dX0[sl[i1].iN];
			if ((sl[i1].iS>-1) && (fabs(sl[i1].as) > nonzeroEPS)) buf -= sl[i1].as*dX0[sl[i1].iS];
			if ((sl[i1].iT>-1) && (fabs(sl[i1].at) > nonzeroEPS)) buf -= sl[i1].at*dX0[sl[i1].iT];
			if ((sl[i1].iW>-1) && (fabs(sl[i1].aw) > nonzeroEPS)) buf -= sl[i1].aw*dX0[sl[i1].iW];

			// Дополнение на АЛИС сетке:
			if ((sl[i1].iB2>-1) && (fabs(sl[i1].ab2) > nonzeroEPS)) buf -= sl[i1].ab2*dX0[sl[i1].iB2];
			if ((sl[i1].iE2>-1) && (fabs(sl[i1].ae2) > nonzeroEPS)) buf -= sl[i1].ae2*dX0[sl[i1].iE2];
			if ((sl[i1].iN2>-1) && (fabs(sl[i1].an2) > nonzeroEPS)) buf -= sl[i1].an2*dX0[sl[i1].iN2];
			if ((sl[i1].iS2>-1) && (fabs(sl[i1].as2) > nonzeroEPS)) buf -= sl[i1].as2*dX0[sl[i1].iS2];
			if ((sl[i1].iT2>-1) && (fabs(sl[i1].at2) > nonzeroEPS)) buf -= sl[i1].at2*dX0[sl[i1].iT2];
			if ((sl[i1].iW2>-1) && (fabs(sl[i1].aw2) > nonzeroEPS)) buf -= sl[i1].aw2*dX0[sl[i1].iW2];

			// Дополнение на АЛИС сетке:
			if ((sl[i1].iB3>-1) && (fabs(sl[i1].ab3) > nonzeroEPS)) buf -= sl[i1].ab3*dX0[sl[i1].iB3];
			if ((sl[i1].iE3>-1) && (fabs(sl[i1].ae3) > nonzeroEPS)) buf -= sl[i1].ae3*dX0[sl[i1].iE3];
			if ((sl[i1].iN3>-1) && (fabs(sl[i1].an3) > nonzeroEPS)) buf -= sl[i1].an3*dX0[sl[i1].iN3];
			if ((sl[i1].iS3>-1) && (fabs(sl[i1].as3) > nonzeroEPS)) buf -= sl[i1].as3*dX0[sl[i1].iS3];
			if ((sl[i1].iT3>-1) && (fabs(sl[i1].at3) > nonzeroEPS)) buf -= sl[i1].at3*dX0[sl[i1].iT3];
			if ((sl[i1].iW3>-1) && (fabs(sl[i1].aw3) > nonzeroEPS)) buf -= sl[i1].aw3*dX0[sl[i1].iW3];

			// Дополнение на АЛИС сетке:
			if ((sl[i1].iB4>-1) && (fabs(sl[i1].ab4) > nonzeroEPS)) buf -= sl[i1].ab4*dX0[sl[i1].iB4];
			if ((sl[i1].iE4>-1) && (fabs(sl[i1].ae4) > nonzeroEPS)) buf -= sl[i1].ae4*dX0[sl[i1].iE4];
			if ((sl[i1].iN4>-1) && (fabs(sl[i1].an4) > nonzeroEPS)) buf -= sl[i1].an4*dX0[sl[i1].iN4];
			if ((sl[i1].iS4>-1) && (fabs(sl[i1].as4) > nonzeroEPS)) buf -= sl[i1].as4*dX0[sl[i1].iS4];
			if ((sl[i1].iT4>-1) && (fabs(sl[i1].at4) > nonzeroEPS)) buf -= sl[i1].at4*dX0[sl[i1].iT4];
			if ((sl[i1].iW4>-1) && (fabs(sl[i1].aw4) > nonzeroEPS)) buf -= sl[i1].aw4*dX0[sl[i1].iW4];

			buf *= buf;
			res_sum += buf;
		}
		for (integer i1 = 0; i1<maxbound; i1++) {
			// граничные узлы.
			doublereal buf = 0.0;
			buf = slb[i1].aw*dX0[slb[i1].iW] - dV[slb[i1].iW];
			if ((slb[i1].iI>-1) && (fabs(slb[i1].ai) > nonzeroEPS)) buf -= slb[i1].ai*dX0[slb[i1].iI];
			buf *= buf;
			res_sum += buf;
		}
		res_sum = sqrt(res_sum);
		printf("output diagnostic residual =%e\n", res_sum);
		//printf("residual finish=%1.4e\n",res_sum);
		//getchar();
		if (bsolid_static_only) {
			// используется только для теплопередачи в твёрдом теле для ускорения
			// решения задачи - защита от рестарта.
			finish_residual = res_sum; // значение невязки решённой задачи.
		}

	}

	/*doublerealT fsum1 = 0.0, fsum2 = 0.0;

	// внутренние контрольные объёмы.
	for (integer i = 0; i<maxelm; i++) {
		// числитель
		doublerealT sE, sW, sN, sS, sT, sB;
		if (sl[i].iE>-1) sE = sl[i].ae*dX0[sl[i].iE]; else sE = 0.0;
		if (sl[i].iW>-1) sW = sl[i].aw*dX0[sl[i].iW]; else sW = 0.0;
		if (sl[i].iN>-1) sN = sl[i].an*dX0[sl[i].iN]; else sN = 0.0;
		if (sl[i].iS>-1) sS = sl[i].as*dX0[sl[i].iS]; else sS = 0.0;
		if (sl[i].iT>-1) sT = sl[i].at*dX0[sl[i].iT]; else sT = 0.0;
		if (sl[i].iB>-1) sB = sl[i].ab*dX0[sl[i].iB]; else sB = 0.0;

		doublerealT sE2, sW2, sN2, sS2, sT2, sB2;
		if (sl[i].iE2>-1) sE2 = sl[i].ae2*dX0[sl[i].iE2]; else sE2 = 0.0;
		if (sl[i].iW2>-1) sW2 = sl[i].aw2*dX0[sl[i].iW2]; else sW2 = 0.0;
		if (sl[i].iN2>-1) sN2 = sl[i].an2*dX0[sl[i].iN2]; else sN2 = 0.0;
		if (sl[i].iS2>-1) sS2 = sl[i].as2*dX0[sl[i].iS2]; else sS2 = 0.0;
		if (sl[i].iT2>-1) sT2 = sl[i].at2*dX0[sl[i].iT2]; else sT2 = 0.0;
		if (sl[i].iB2>-1) sB2 = sl[i].ab2*dX0[sl[i].iB2]; else sB2 = 0.0;

		doublerealT sE3, sW3, sN3, sS3, sT3, sB3;
		if (sl[i].iE3>-1) sE3 = sl[i].ae3*dX0[sl[i].iE3]; else sE3 = 0.0;
		if (sl[i].iW3>-1) sW3 = sl[i].aw3*dX0[sl[i].iW3]; else sW3 = 0.0;
		if (sl[i].iN3>-1) sN3 = sl[i].an3*dX0[sl[i].iN3]; else sN3 = 0.0;
		if (sl[i].iS3>-1) sS3 = sl[i].as3*dX0[sl[i].iS3]; else sS3 = 0.0;
		if (sl[i].iT3>-1) sT3 = sl[i].at3*dX0[sl[i].iT3]; else sT3 = 0.0;
		if (sl[i].iB3>-1) sB3 = sl[i].ab3*dX0[sl[i].iB3]; else sB3 = 0.0;

		doublerealT sE4, sW4, sN4, sS4, sT4, sB4;
		if (sl[i].iE4>-1) sE4 = sl[i].ae4*dX0[sl[i].iE4]; else sE4 = 0.0;
		if (sl[i].iW4>-1) sW4 = sl[i].aw4*dX0[sl[i].iW4]; else sW4 = 0.0;
		if (sl[i].iN4>-1) sN4 = sl[i].an4*dX0[sl[i].iN4]; else sN4 = 0.0;
		if (sl[i].iS4>-1) sS4 = sl[i].as4*dX0[sl[i].iS4]; else sS4 = 0.0;
		if (sl[i].iT4>-1) sT4 = sl[i].at4*dX0[sl[i].iT4]; else sT4 = 0.0;
		if (sl[i].iB4>-1) sB4 = sl[i].ab4*dX0[sl[i].iB4]; else sB4 = 0.0;

		fsum1 += fabs(sE + sW + sN + sS + sT + sB + sE2 + sW2 + sN2 + sS2 + sT2 + sB2 + sE3 + sW3 + sN3 + sS3 + sT3 + sB3 + sE4 + sW4 + sN4 + sS4 + sT4 + sB4 +sl[i].b - sl[i].ap*dX0[sl[i].iP]);
		fsum2 += fabs(sl[i].ap*dX0[sl[i].iP]); // знаменатель.
	}//ok
	*/

	calculation_main_end_time = clock();
	calculation_vorst_seach_time += calculation_main_end_time - calculation_main_start_time;

#ifdef _OPENMP
	omp_set_num_threads(i_my_num_core_parallelesation);
#endif
	///getchar();
} // my_agr_amg_loc_memory_old


// Здесь содержится обвязка вызывающая РУМБА v0_14 решатель.
// локальное выделение памяти:всё внутри, многократные alloc и free.
void my_agr_amg_loc_memory(equation3D* &sl, equation3D_bon* &slb,
	int maxelm, int maxbound,
	doublereal *dV, doublereal* &dX0,
	doublereal alpharelax, integer iVar, bool bLRfree, QuickMemVorst& m,
	real_mix_precision &ret74, BLOCK* b, int lb,
	int* &ifrontregulationgl, int* &ibackregulationgl,
	SOURCE* &s_loc, int &ls, integer inumber_iteration_SIMPLE,
	WALL* &w, int &lw, int * &whot_is_block)
{

	

#ifdef _OPENMP
	unsigned int nthreads = number_cores();
	int i_my_num_core_parallelesation = omp_get_max_threads();
	omp_set_num_threads(nthreads); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#else
	int i_my_num_core_parallelesation = 1;
#endif

	// Замер времени.
	unsigned int calculation_main_start_time; // начало счёта мс.
	unsigned int calculation_main_end_time; // окончание счёта мс.

	calculation_main_start_time = clock(); // момент начала счёта.


	// режим экономии оперативной памяти.
	bool bmemory_savings = true; // true работает только с counting Sort.
	switch (my_amg_manager.imySortAlgorithm) {
	case  MY_SORT_ALGORITHM::COUNTING_SORT :
		bmemory_savings = true;
		break;
	case MY_SORT_ALGORITHM::QUICK_SORT :
		bmemory_savings = false;
		break;
	case MY_SORT_ALGORITHM::HEAP_SORT:
		bmemory_savings = false;
		break;
	case MY_SORT_ALGORITHM::TIM_SORT :
		bmemory_savings = false;
		break;
	default:
		bmemory_savings = true;
		break;
	}
	if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)||(iVar == PAM)||(iVar==TEMP)||
		(iVar== NUSHA)||(iVar== TURBULENT_KINETIK_ENERGY)||(iVar== TURBULENT_SPECIFIC_DISSIPATION_RATE_OMEGA) ||
		(iVar == TURBULENT_KINETIK_ENERGY_STD_K_EPS) || (iVar == TURBULENT_DISSIPATION_RATE_EPSILON_STD_K_EPS)||
		(iVar == GAMMA_LANGTRY_MENTER)||(iVar == RE_THETA_LANGTRY_MENTER)) {
		// 4.05.2019 Обнаружено что гидродинамические невязки неправильно
		// отображаются, портятся искажаются при включенной опции 
		// bmemory_savings==true. После ее выключения невязки стали отображаться 
		// корректно. Причина аномалии пока неясна.
		bmemory_savings = false; // Должно быть false для всех переменных.
	}


	// На случай если память не была выделена.
	if (dX0 == nullptr) {
		dX0 = new doublereal[maxelm + maxbound];
		if (dX0 == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for dX0 my_agregat_amg.cpp...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}
		for (integer i = 0; i < maxelm + maxbound; i++) {
			dX0[i] = 0.0;
		}
		printf("allocation memory for dX0... Ok. dX0 initialization 0.0 value.\n");
	}


	doublereal tmaxloc = -272.15e6;
	for (integer i = 0; i < maxelm; i++) tmaxloc = fmax(tmaxloc, dX0[i]);
	if (iVar == TEMP) {
		printf("Intermediate maximum temperature in default interior\n");
		printf("is equal %e degrees Celsius.\n", tmaxloc);
	}
	doublereal tminloc = 1.0e7;
	for (integer i = 0; i < maxelm; i++) tminloc = fmin(tminloc, dX0[i]);
	if (iVar == TEMP) {
		printf("Intermediate minimum temperature in default interior\n");
		printf("is equal %e degrees Celsius.\n", tminloc);
	}


	const doublereal nonzeroEPS = 1.0e-37; // для отделения вещественного нуля
	doublereal res_sum = 0.0;
	res_sum = 0.0;
	for (integer i = 0; i < maxelm; i++) {
		// внутренность матрицы.
		doublereal buf = 0.0;
		buf = (sl[i].ap*dX0[sl[i].iP] - dV[sl[i].iP]);
		if ((sl[i].iB > -1) && (sl[i].ab > nonzeroEPS)) buf -= sl[i].ab*dX0[sl[i].iB];
		if ((sl[i].iE > -1) && (sl[i].ae > nonzeroEPS)) buf -= sl[i].ae*dX0[sl[i].iE];
		if ((sl[i].iN > -1) && (sl[i].an > nonzeroEPS)) buf -= sl[i].an*dX0[sl[i].iN];
		if ((sl[i].iS > -1) && (sl[i].as > nonzeroEPS)) buf -= sl[i].as*dX0[sl[i].iS];
		if ((sl[i].iT > -1) && (sl[i].at > nonzeroEPS)) buf -= sl[i].at*dX0[sl[i].iT];
		if ((sl[i].iW > -1) && (sl[i].aw > nonzeroEPS)) buf -= sl[i].aw*dX0[sl[i].iW];
		// Дополнение на АЛИС сетке.
		if ((sl[i].iB2 > -1) && (sl[i].ab2 > nonzeroEPS)) buf -= sl[i].ab2*dX0[sl[i].iB2];
		if ((sl[i].iE2 > -1) && (sl[i].ae2 > nonzeroEPS)) buf -= sl[i].ae2*dX0[sl[i].iE2];
		if ((sl[i].iN2 > -1) && (sl[i].an2 > nonzeroEPS)) buf -= sl[i].an2*dX0[sl[i].iN2];
		if ((sl[i].iS2 > -1) && (sl[i].as2 > nonzeroEPS)) buf -= sl[i].as2*dX0[sl[i].iS2];
		if ((sl[i].iT2 > -1) && (sl[i].at2 > nonzeroEPS)) buf -= sl[i].at2*dX0[sl[i].iT2];
		if ((sl[i].iW2 > -1) && (sl[i].aw2 > nonzeroEPS)) buf -= sl[i].aw2*dX0[sl[i].iW2];

		if ((sl[i].iB3 > -1) && (sl[i].ab3 > nonzeroEPS)) buf -= sl[i].ab3*dX0[sl[i].iB3];
		if ((sl[i].iE3 > -1) && (sl[i].ae3 > nonzeroEPS)) buf -= sl[i].ae3*dX0[sl[i].iE3];
		if ((sl[i].iN3 > -1) && (sl[i].an3 > nonzeroEPS)) buf -= sl[i].an3*dX0[sl[i].iN3];
		if ((sl[i].iS3 > -1) && (sl[i].as3 > nonzeroEPS)) buf -= sl[i].as3*dX0[sl[i].iS3];
		if ((sl[i].iT3 > -1) && (sl[i].at3 > nonzeroEPS)) buf -= sl[i].at3*dX0[sl[i].iT3];
		if ((sl[i].iW3 > -1) && (sl[i].aw3 > nonzeroEPS)) buf -= sl[i].aw3*dX0[sl[i].iW3];

		if ((sl[i].iB4 > -1) && (sl[i].ab4 > nonzeroEPS)) buf -= sl[i].ab4*dX0[sl[i].iB4];
		if ((sl[i].iE4 > -1) && (sl[i].ae4 > nonzeroEPS)) buf -= sl[i].ae4*dX0[sl[i].iE4];
		if ((sl[i].iN4 > -1) && (sl[i].an4 > nonzeroEPS)) buf -= sl[i].an4*dX0[sl[i].iN4];
		if ((sl[i].iS4 > -1) && (sl[i].as4 > nonzeroEPS)) buf -= sl[i].as4*dX0[sl[i].iS4];
		if ((sl[i].iT4 > -1) && (sl[i].at4 > nonzeroEPS)) buf -= sl[i].at4*dX0[sl[i].iT4];
		if ((sl[i].iW4 > -1) && (sl[i].aw4 > nonzeroEPS)) buf -= sl[i].aw4*dX0[sl[i].iW4];

		buf *= buf;
		res_sum += buf;
	}
	for (integer i = 0; i < maxbound; i++) {
		// граничные узлы.
		doublereal buf = 0.0;
		buf = slb[i].aw*dX0[slb[i].iW] - dV[slb[i].iW];
		if ((slb[i].iI > -1) && (fabs(slb[i].ai) > nonzeroEPS)) buf -= slb[i].ai*dX0[slb[i].iI];
		buf *= buf;
		res_sum += buf;
	}
	res_sum = sqrt(res_sum);
	if (my_amg_manager.iprint_log == 1) {
		printf("input diagnostic residual =%e\n", res_sum);
	}

	if ((iVar == VELOCITY_X_COMPONENT) || (iVar == VELOCITY_Y_COMPONENT) || (iVar == VELOCITY_Z_COMPONENT)) {
		if (res_sum > 20.0) {
			printf("Speed diagnostic problem analysys....\n");
		}
	}
	if ((iVar == NUSHA) || (iVar == TURBULENT_KINETIK_ENERGY) || (iVar == TURBULENT_SPECIFIC_DISSIPATION_RATE_OMEGA) ||
		(iVar == TURBULENT_KINETIK_ENERGY_STD_K_EPS) || (iVar == TURBULENT_DISSIPATION_RATE_EPSILON_STD_K_EPS) ||
		(iVar == GAMMA_LANGTRY_MENTER) || (iVar == RE_THETA_LANGTRY_MENTER)) {
		if (res_sum > 20.0) {
			printf("Turbulent equations diagnostic problem analysys....\n");
		}
	}
	//printf("residual start=%1.4e\n",res_sum);
	//getchar();

	// результаты тестирования
	// задача, начальная невязка , значение евклидовой нормы невязки при которой решение является полученным.
	// tgf01 5.4357e-1 1.0209e-11
	// CGHV1J с метализацией 3.3667e-1 5.0712e-12
	// tgf02 7.6872e-11 1.434e-11
	// tgf05 1.0871e+0  2.2895e-11
	// резистор на 1мм поликоре 5.0e-2 4.9174e-14
	//Diamond ZUb 4 4.0016e-1  4.64444e-11
	// DiamondZUB 4.0016e-1 1.1443e-8
	// NXP100 4.3399e+0  7.8347e-11 (для решения хватило 8Гб ОЗУ.)

	doublereal res_sum_previos = 1.05*finish_residual;
	if ((adiabatic_vs_heat_transfer_coeff > DEFAULT_CABINET_BOUNDARY_CONDITION::ADIABATIC_WALL_BC) || 
		(breakRUMBAcalc_for_nonlinear_boundary_condition)) {
		// Надо пересобирать матрицу и запускать всё по новой т.к. задача 
		// существенно нелинейна.

		// Работает задача Ньютона Рихмана или
		// Стефана Больцмана или миксовая.
		res_sum_previos = 1.0e-12;
		
	}
	else {
		// Надо в любом случае сделать повторный запуск так как теплопроводности 
		// зависящие от температуры были изменены.
		// лог при вызове повторной сборки с измененными теплопроводностями. 
		//input diagnostic residual =1.779463e+01
		//res_sum = 1.779463e+01 res_sum_previos = 1.833335e+01
		// Т.е. чтобы запуск произошел нужно искуственно уменьшить 
		// значение res_sum_previos.
		res_sum_previos = res_sum_previos / 2.0;
	}

	//printf("res_sum=%e res_sum_previos=%e\n", res_sum, res_sum_previos);
	//system("pause");

	//if (res_sum>1.0E-10) 
	if (res_sum > res_sum_previos) // защита от повторного холостого запуска экономит время конечного пользователя.
	{

		//yes_print_amg=false;
		//yes_print_amg = false;

		

		if (iVar == TEMP) {

			

			// Это не специальная нелинейная версия кода amg1r5 CAMG.
			for (integer k = 0; k < lw; k++) {
				if ((w[k].ifamily == WALL_BOUNDARY_CONDITION::STEFAN_BOLCMAN_FAMILY) ||
					(w[k].ifamily == WALL_BOUNDARY_CONDITION::NEWTON_RICHMAN_FAMILY)) {
					alpharelax = 0.99999; // Для того чтобы СЛАУ сходилась.
					// 0.9999 - недостаточное значение, температуры не те получаются.
				}
			}
			if ((adiabatic_vs_heat_transfer_coeff == DEFAULT_CABINET_BOUNDARY_CONDITION::NEWTON_RICHMAN_BC) ||
				(adiabatic_vs_heat_transfer_coeff == DEFAULT_CABINET_BOUNDARY_CONDITION::STEFAN_BOLCMAN_BC) ||
				(adiabatic_vs_heat_transfer_coeff == DEFAULT_CABINET_BOUNDARY_CONDITION::MIX_CONDITION_BC)) {
				alpharelax = 0.99999;
			}
			//if (adiabatic_vs_heat_transfer_coeff == ADIABATIC_WALL_BC) {
			//printf("ADIABATIC WALL BC"); getchar();
			//}			

		}


		integer ierr = 0;
		//doublereal eps = 1.0e-12;

		ierr = 0; // изначальное состояние безошибочное.
				  // Порог точности решения СЛАУ. Значение 1.0E-12 достаточно что проверено в ANSYS icepak.
		//eps = 1.0e-12; // рекомендуемое значение которого достаточно. 

					   // Требования к оперативной памяти.
					   /*     VECTOR         NEEDED LENGTH (GUESS) */
					   /*       Amat               3*NNA + 5*NNU */
					   /*       JA              3*NNA + 5*NNU */
					   /*       IA              2.2*NNU */
					   /*       U               2.2*NNU */
					   /*       F               2.2*NNU */
					   /*       IG              5.4*NNU */


		integer nna = 0; // количество ненулевых элементов в матрице СЛАУ.


						 // подсчёт числа ненулевых элементов в матрице.
		nna = 0;
		for (integer i = 0; i < maxelm; i++) {
			// внутренность матрицы.
			if ((sl[i].iB > -1) && (fabs(sl[i].ab) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE > -1) && (fabs(sl[i].ae) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN > -1) && (fabs(sl[i].an) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS > -1) && (fabs(sl[i].as) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT > -1) && (fabs(sl[i].at) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW > -1) && (fabs(sl[i].aw) > nonzeroEPS)) (nna)++;
			if ((sl[i].iP > -1) && (fabs(sl[i].ap) > nonzeroEPS)) (nna)++;

			// Дополнение на АЛИС сетке:
			if ((sl[i].iB2 > -1) && (fabs(sl[i].ab2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE2 > -1) && (fabs(sl[i].ae2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN2 > -1) && (fabs(sl[i].an2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS2 > -1) && (fabs(sl[i].as2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT2 > -1) && (fabs(sl[i].at2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW2 > -1) && (fabs(sl[i].aw2) > nonzeroEPS)) (nna)++;

			if ((sl[i].iB3 > -1) && (fabs(sl[i].ab3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE3 > -1) && (fabs(sl[i].ae3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN3 > -1) && (fabs(sl[i].an3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS3 > -1) && (fabs(sl[i].as3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT3 > -1) && (fabs(sl[i].at3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW3 > -1) && (fabs(sl[i].aw3) > nonzeroEPS)) (nna)++;

			if ((sl[i].iB4 > -1) && (fabs(sl[i].ab4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE4 > -1) && (fabs(sl[i].ae4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN4 > -1) && (fabs(sl[i].an4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS4 > -1) && (fabs(sl[i].as4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT4 > -1) && (fabs(sl[i].at4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW4 > -1) && (fabs(sl[i].aw4) > nonzeroEPS)) (nna)++;

		}
		for (integer i = 0; i < maxbound; i++) {
			// граничные узлы.
			if ((slb[i].iW > -1) && (fabs(slb[i].aw) > nonzeroEPS)) (nna)++;
			if ((slb[i].iI > -1) && (fabs(slb[i].ai) > nonzeroEPS)) (nna)++;
		}

		integer nnu = 0; // число неизвестных.
		nnu = maxelm + maxbound;

		/*
		// Рекомендуемые по умолчанию параметры.
		integer nda=0; // память под вектор значений матрицы слау.
		nda=3*(nna)+5*(nnu);
		integer ndia=0;
		ndia=(integer)(2.2*(nnu));
		integer ndja=0;
		ndja=3*(nna)+5*(nnu);
		integer ndu=0;
		ndu=(integer)(2.2*(nnu));
		integer ndf=0;
		ndf=(integer)(2.2*(nnu));
		integer ndig=0;
		ndig=(integer)(5.4*(nnu));
		*/

		/*
		// в двое больше памяти чем рекомендовано.
		integer nda=0; // память под вектор значений матрицы слау.
		nda=6*(nna)+10*(nnu);
		integer ndia=0;
		ndia=(integer)(4.4*(nnu));
		integer ndja=0;
		ndja=6*(nna)+10*(nnu);
		integer ndu=0;
		ndu=(integer)(4.4*(nnu));
		integer ndf=0;
		ndf=(integer)(4.4*(nnu));
		integer ndig=0;
		ndig=(integer)(10.8*(nnu));
		*/

		// данная константа работоспособна вплоть до размерностей сетки равных 34млн 463тысячи 250узлов.
		//doublereal rsize=1.51; // 1048416
		// Вынужденные течения достаточно 2.5. 
		// на задаче Концевого Ю.А. Электростатика со столбиком в случае сетки со сгущением достаточно 2.0.


		Ak2 Amat;
		Amat.i = nullptr;
		Amat.j = nullptr;
		Amat.aij = nullptr;
		Amat.abs_aij = nullptr;
		//Ak1* R = nullptr;
		//Ak1* P = nullptr;
		//Ak1* Atemp = nullptr;
		//Ak1* Atemp2 = nullptr;
		doublereal* rthdsd_amg = nullptr;
		doublereal* result_amg = nullptr;
		// 18 августа 2016
		// граничные узлы требуют особой обработки.
		// true - граничный узел, false - внутренний.
		bool* bamg_bound = nullptr;




		/*     CLASS 3 - PARAMETERS: */

		/*     LEVELX   -   MAXIMUM NUMBER OF MG-LEVELS TO BE CREATED (>=1). */

		/*     IFIRST   -   PARAMETER FOR FIRST APPROXIMATION. */

		/*                  1ST DIGIT OF IFIRST: NOT USED; HAS TO BE NON-ZERO. */

		/*                  2ND DIGIT OF IFIRST  --  ITYPU: */
		/*                    =0: NO SETTING OF FIRST APPROXIMATION, */
		/*                    =1: FIRST APPROXIMATION CONSTANT TO ZERO, */
		/*                    =2: FIRST APPROXIMATION CONSTANT TO ONE, */
		/*                    =3: FIRST APPROXIMATION IS RANDOM FUNCTION WITH */
		/*                        THE CONCRETE RANDOM SEQUENCE BEING DETERMINED */
		/*                        BY THE FOLLWING DIGITS. */

		/*                  REST OF IFIRST  --  RNDU: */
		/*                    DETERMINES THE CONCRETE RANDOM SEQUENCE USED IN */
		/*                    THE CASE ITYPU=3. (IFIRST=13 IS EQUIVALENT TO */
		/*                    IFIRST=1372815) */

		/*     NCYC     -   INTEGER PARAMETER DESCRIBING THE TYPE OF CYCLE TO BE */
		/*                  USED AND THE NUMBER OF CYCLES TO BE PERFORMED. */

		/*                  1ST DIGIT OF NCYC  --  IGAM: */
		/*                    =1: V -CYCLE, */
		/*                    =2: V*-CYCLE, */
		/*                    =3: F -CYCLE, */
		/*                    =4: W -CYCLE. */
		/*                  IF NCYC IS NEGATIV, THEN THE APPROXIMATION OF THE */
		/*                  PROBLEM ON THE SECOND FINEST GRID IS COMPUTED BY */
		/*                  IGAM V-CYCLES ON THAT PARTICULAR GRID. */

		/*                  2ND DIGIT OF NCYC  --  ICGR: */
		/*                    =0: NO CONJUGATE GRADIENT, */
		/*                    =1: CONJUGATE GRADIENT (ONLY FIRST STEP OF CG), */
		/*                    =2: CONJUGATE GRADIENT (FULL CG). */

		/*                  3RD DIGIT OF NCYC  --  ICONV: */
		/*                    CONVERGENCE CRITERION FOR THE USER-DEFINED PROBLEM */
		/*                    (FINEST GRID): */
		/*                    =1: PERFORM Amat FIXED NUMBER OF CYCLES AS GIVEN BY */
		/*                        NCYCLE (SEE BELOW) */
		/*                    =2: STOP, IF  ||RES|| < EPS */
		/*                    =3: STOP, IF  ||RES|| < EPS * |F| */
		/*                    =4: STOP, IF  ||RES|| < EPS * |U| * |DIAG| */
		/*                    WITH ||RES|| = L2-NORM OF RESIDUAL, */
		/*                           EPS     (SEE INPUT PARAMETER EPS) */
		/*                           |F|   = SUPREMUM NORM OF RIGHT HAND SIDE */
		/*                           |U|   = SUPREMUM NORM OF SOLUTION */
		/*                         |DIAG|  = MAXIMAL DIAGONAL ENTRY IN MATRIX L */
		/*                    NOTE THAT IN ANY CASE THE SOLUTION PROCESS STOPS */
		/*                    AFTER AT MOST NCYCLE CYCLES. */

		/*                  REST OF NCYC  --  NCYCLE: */
		/*                    MAXIMAL NUMBER OF CYCLES TO BE PERFORMED (>0) OR */
		/*                    NCYCLE=0: NO CYCLING. */

		/*     EPS      -   CONVERGENCE CRITERION FOR SOLUTION PROCESS: (SEE */
		/*                  PARAMETER NCYC). NOTE THAT NO MORE THAN NCYCLE CYCLES */
		/*                  ARE PERFORMED, REGARDLESS OF EPS. */

		/*     MADAPT   -   INTEGER VALUE SPECIFYING THE CHOICE OF COARSEST */
		/*                  GRID IN CYCLING: */

		/*                  1ST DIGIT OF MADAPT  --  MSEL: */
		/*                    =1: IN CYCLING, ALL GRIDS CONSTRUCTED IN THE SETUP */
		/*                        PHASE ARE USED WITHOUT CHECK. */
		/*                    =2: THE NUMBER OF GRIDS IS AUTOMATICALLY REDUCED */
		/*                        IF THE CONVERGENCE FACTOR ON THE COARSER GRIDS */
		/*                        IS FOUND TO BE LARGER THAN Amat GIVEN VALUE FAC */
		/*                        (SEE BELOW). */

		/*                  REST OF MADAPT  --  FAC */
		/*                        THE REST OF MADAPT DEFINES THE FRACTIONAL PART */
		/*                        OF Amat REAL NUMBER FAC BETWEEN 0.1 AND 0.99, E.G. */
		/*                        MADAPT=258 MEANS MSEL=2 AND FAC=0.58. IF MADAPT */
		/*                        CONSISTS OF ONLY ONE DIGIT, FAC IS SET TO 0.7 */
		/*                        BY DEFAULT. */


		/*     NRD      -   PARAMETER DESCRIBING RELAXATION (DOWNWARDS): */

		/*                  1ST DIGIT OF NRD: NOT USED; HAS TO BE NON-ZERO. */

		/*                  2ND DIGIT OF NRD  --  NRDX: */
		/*                    ACTUAL NUMBER OF SMOOTHING STEPS TO BE PERFORMED */
		/*                    THE TYPE OF WHICH IS GIVEN BY THE FOLLOWING DIGITS */

		/*                  FOLLOWING DIGITS  --  ARRAY NRDTYP: */
		/*                    =1: RELAXATION OVER THE F-POINTS ONLY */
		/*                    =2: FULL GS SWEEP */
		/*                    =3: RELAXATION OVER THE C-POINTS ONLY */
		/*                    =4: FULL MORE COLOR SWEEP, HIGHEST COLOR FIRST */

		/*     NSOLCO   -   PARAMETER CONTROLLING THE SOLUTION ON COARSEST GRID: */

		/*                  1ST DIGIT  --  NSC: */
		/*                    =1: GAUSS-SEIDEL METHOD */
		/*                    =2: DIRECT SOLVER (YALE SMP) */

		/*                  REST OF NSOLCO  --  NRCX: (ONLY IF NSC=1) */
		/*                  NUMBER OF GS SWEEPS ON COARSEST GRID (>=0). */
		/*                  IF NRCX=0, THEN AS MANY GS SWEEPS ARE PERFORMED */
		/*                  AS ARE NEEDED TO REDUCE THE RESIDUAL BY TWO ORDERS */
		/*                  OF MAGNITUDE. (MAXIMAL 100 RELAXATION SWEEPS) */

		/*     NRU      -   PARAMETER FOR RELAXATION (UPWARDS), ANALOGOUS TO NRD. */

		/*         -------------------------------------------------------------- */

		/*     CLASS 4 - PARAMETERS: */

		/*     ECG1,ECG2-   REAL PARAMETERS AFFECTING THE CREATION OF COARSER */
		/*     EWT2     -   GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
		/*                  THE CHOICE OF THESE PARAMETERS DEPENDS ON */
		/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

		/*     NWT      -   INTEGER PARAMETER AFFECTING THE CREATION OF COARSER */
		/*                  GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
		/*                  THE CHOICE OF THIS PARAMETER DEPENDS ON */
		/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

		/*     NTR      -   PARAMETER CONTROLLING COARSE-GRID OPERATOR TRUNCATION */
		/*                    =0: PAIRS OF ZEROES ARE REMOVED FROM COARSE GRID */
		/*                        OPERATORS */
		/*                    =1: NO COARSE-GRID OPERATOR TRUNCATION */



		/*     STANDARD CHOICES OF PARAMETERS (AS FAR AS MEANINGFUL): */

		/*          ISWTCH = 4 */
		/*          IOUT   = 12 */
		/*          IPRinteger = 10606 */

		/*          LEVELX = 25 */
		/*          IFIRST = 13 */
		/*          NCYC   = 10110 */
		/*          EPS    = 1.D-12 */
		/*          MADAPT = 27 */
		/*          NRD    = 1131 */
		/*          NSOLCO = 110 */
		/*          NRU    = 1131 */

		/*          ECG1   = 0. */
		/*          ECG2   = 0.25 */
		/*          EWT2   = 0.35 */
		/*          NWT    = 2 */
		/*          NTR    = 0 */



		// рекомедуемые параметры по дефолту.
		/*
		integer iswtch = 0;
		iswtch = 4;
		integer iout = 0;
		iout = 12;
		integer iprinteger = 0;
		iprinteger = 10606;
		integer levelx = 0;
		levelx = 25;
		integer ifirst = 0;
		// начальное приближение:
		// 0 - используется из вне.
		// 1 - нулевое.
		// 2 - единицы.
		// 3 - случайная последовательность.
		ifirst = 13;//13 по умолчанию.
		//ifirst=11; // нулевое начальное приближение.
		//ifirst=10; // вроде как начальное приближение берётся из dX0.
		// но 10 никоим образом не улучшает сходимость.
		integer ncyc = 0;
		ncyc = 10110;
		integer madapt = 0;
		madapt = 27;
		integer nrd = 0;
		nrd = 1131;
		integer nsolco = 0;
		nsolco = 110;
		integer nru = 0;
		nru = 1131;
		doublereal ecg1 = 0.0;
		ecg1 = 0.0;
		doublereal ecg2 = 0.0;
		ecg2 = 0.25;
		doublereal ewt2 = 0.0;
		ewt2 = 0.35;
		integer nwt = 0;
		nwt = 2;
		integer ntr = 0;
		ntr = 0;

		integer matrix = 0;
		//matrix=11; // symmetric SPD.
		matrix = 22;

		if ((iVar == PAM) && (bLRfree)) {
		//printf("work amg1r5\n");
		//getchar();
		// Симметричная положительно определённая матрица это такая матрица
		// которая возникает для поправки давления при решении вязких несжимаемых уравнений Навье-Стокса в
		// случае задач: каверна, тест Валь-Девиса. Для задач промышленного масштаба это всякие естественные
		// конвекции охлаждающие висящие в воздухе без контакта с теплоотводом греющиеся изделия.
		// Это особый специфический класс задач.
		matrix = 11;
		}
		*/
		// для прямой интерполяции с элементами непрямой можно выставить коэффициент 3 и освободить память из под 
		// исходной матрицы (для той структуры на которой была выполнена сборка матрицы изначально). 

		 // allocate memory 2 jan 2016.
		 // BSK Dmitrii 3.012  (2.892 для прямой интерполяции с элементами непрямой). 
		 // tgf series no metalization
		 // tgf2023-2_01 2.64 643mb
		 // tgf2023-2-02 2.58 988mb
		 // tgf2023-2-05 2.44 2022mb
		 // tgf2023-2-20 3.58 2967mb
		 // CGHV1J metalization 3.133 (2.84 для прямой интерполяции с элементами непрямой). 
		 // тор Докторович 2.89
		 // Концевой 3.05
		 // Концевой со столбиком 3.7М 2.97 (6.0 у amg1r5) 4110.6Мb.
		 // Вывод: максимальное значение 3.15 а значит значения 4 должно хватить с запасом У amg1r5 максимальное значение 9.0.
		 // Можно сказать что данный amg требует вдвое меньше памяти по сравнению с amg1r5.
		 // Была найдена статья в интернете которая подтверждала что константа памяти у amg1r5 равна 8.
		 // Также был найден ряд статей в которых подтверждается констата близкая к 3 для CAMG.
		 //Amat = new Ak1[(integer)(7 * nna) + 1]; // 6 // 45 // 4
		 // памяти надо много для 6 варианта интерполяции.
 // 9,35,35 28
		integer nsizeA = ((integer)(9 * nna) + 1);
		integer nsizePR = 12;// 35;

		if (bPhysics_PTBSH_memory  ) {
			// ПТБШ.
			//printf("bPhysics_PTBSH_memory==true\n");
			nsizeA = ((integer)(4 * nna) + 1);
			//nsizePR = 13;
		}

		// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
		// Т.к. есть трудносходящиеся задачи, то эти настройки должны помоч.
		// Истина в том что количество потребляемой оперативной памяти очень сильно зависит от особеностей
		// пользовательской геометрии (того что пользователь начертил в интерфейсе).
		// Иногда достаточно 4 размеров матрицы, а иногда нехватает и 12. Каждая новая задача должна настраиваться 
		// в идеале индивидуально, если пользователь хочет выжить максимум из своего оборудования.
		nsizeA = ((integer)(my_amg_manager.memory_size * nna) + 1);
		if (my_amg_manager.iprint_log == 1) {
#if doubleintprecision == 1
			printf("memory size const is=%lld\n", my_amg_manager.memory_size);
#else
			printf("memory size const is=%d\n", my_amg_manager.memory_size);
#endif

		}
		//nsizePR = 35;
		if (bonly_solid_calculation) {
			// 31 октября 2016.
			// По моим замерам с надёжным запасом в 30% для всех твёрдотельных 
			// задач должно хватить значения 12.
			//nsizePR = 12;
		}

#ifndef VISUAL_TUDIO_2008_COMPILLER

		// Требует заголовочного файла windows.h
		// Зависимый от ОС Windows код.
		//MEMORYSTATUSEX statex;
		//statex.dwLength = sizeof(statex);
		//GlobalMemoryStatusEx(&statex);
		//char divisor[2] = "M";
		//if (my_amg_manager.iprint_log == 1) {
			//printf("physical memory is %lld total  %sbytes \n", statex.ullTotalPhys / (1024*1024), divisor);
			//printf("%ld %% of memory is in use.\n", statex.dwMemoryLoad);
			//printf("required %lld %sbytes\n", (integer)(((nsizeA / (1024*1024)) * sizeof(Ak1) + 2 * (((nsizePR / (1024*1024))* nnu) + 1) * sizeof(Ak1))),divisor);
			//system("pause");
		//}
#endif

//system("PAUSE");


		char c1[22] = "my_agr_amg_loc_memory";
		char c2[5] = "Amat";
		Amat.i = (integer_mix_precision*)malloc(nsizeA * sizeof(integer_mix_precision));  // 9
		handle_error<integer_mix_precision>(Amat.i, c2, c1, (nsizeA));
		if (my_amg_manager.iprint_log == 1) {
			printf("i alloc succseful...\n");
		}
		Amat.j = (integer_mix_precision*)malloc(nsizeA * sizeof(integer_mix_precision));  // 9
		handle_error<integer_mix_precision>(Amat.j, c2, c1, (nsizeA));
		if (my_amg_manager.iprint_log == 1) {
			printf("j alloc succseful...\n");
		}
		Amat.aij = (real_mix_precision*)malloc(nsizeA * sizeof(real_mix_precision));  // 9
		handle_error<real_mix_precision>(Amat.aij, c2, c1, (nsizeA));
		if (my_amg_manager.iprint_log == 1) {
			printf("aij alloc succseful...\n");
		}
		Amat.abs_aij = (real_mix_precision*)malloc(nsizeA * sizeof(real_mix_precision));  // 9
		handle_error<real_mix_precision>(Amat.abs_aij, c2, c1, (nsizeA));
		if (my_amg_manager.iprint_log == 1) {
			printf("abs_aij alloc succseful...\n");
		}


		char c0[11] = "bamg_bound";
		bamg_bound = new bool[((nsizePR * nnu) + 1)];
		handle_error<bool>(bamg_bound, c0, c1, ((nsizePR * nnu) + 1));
		if (my_amg_manager.iprint_log == 1) {
			printf("bamg_bound alloc succseful...\n");
		}

		// real size 9.4 for resistor.
		// 
		/*
		Atemp = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
		if (Atemp == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for Atemp matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		// real size 9.4 for resistor.
		Atemp2 = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
		if (Atemp2 == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for Atemp2 matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		*/

		//result_amg = new doublereal[nnu + 1];
		result_amg = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
		char c3[11] = "result_amg";
		handle_error<doublereal>(result_amg, c3, c1, (nnu + 1));
		if (my_amg_manager.iprint_log == 1) {
			printf("result_amg alloc succseful...\n");
		}

		//rthdsd_amg = new doublereal[nnu + 1];
		rthdsd_amg = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
		char c4[11] = "rthdsd_amg";
		handle_error<doublereal>(rthdsd_amg, c4, c1, (nnu + 1));
		if (my_amg_manager.iprint_log == 1) {
			printf("rthdsd_amg alloc succseful...\n");
		}



		// правая часть.
		/*
		for (integer i = 0; i < nnu; i++) {
		rthdsd_amg[i] = 0.0;
		if (i<maxelm + maxbound) {
		// обязательно нужно проверить была ли выделена оперативная память.
		rthdsd_amg[i + 1] = dV[i];
		}
		}
		rthdsd_amg[0] = 0.0;
		*/
		/*
		// вектор решения.
		for (integer i = 0; i < nnu; i++) {
		result_amg[i] = 0.0;
		if (i<maxelm + maxbound) {
		// обязательно нужно проверить была ли выделена оперативная память.
		result_amg[i + 1] = dX0[i];
		}
		}
		result_amg[0] = 0.0;
		*/

		// см. equation3DtoCRS.

		integer ik = 0; // счётчик ненулевых элементов СЛАУ
		integer id = 1;

		//if (iVar == PAM) {
			//printf("alpharelax=%e\n", alpharelax);
		//	getchar();
		//}

		integer* icompression = nullptr;
		doublereal* rcompressionb = nullptr;
		if (bmemory_savings && (!b_on_adaptive_local_refinement_mesh)) {
			icompression = (integer*)malloc((7 * maxelm + 1) * sizeof(integer)); // +1 запас.
			char c5[13] = "icompression";
			handle_error<integer>(icompression, c5, c1, (7 * maxelm + 1));
			for (integer i_1 = 0; i_1 < (7 * maxelm + 1); i_1++) {
				icompression[i_1] = -1;
			}
			printf("icompression alloc succseful...\n");
			rcompressionb = (doublereal*)malloc((maxelm + 1) * sizeof(doublereal)); // +1 запас.
			char c6[14] = "rcompressionb";
			handle_error<doublereal>(rcompressionb, c6, c1, (maxelm + 1));
			for (integer i_1 = 0; i_1 < (maxelm); i_1++) {
				rcompressionb[i_1] = sl[i_1].b;
			}
			printf("rcompressionb alloc succseful...\n");
		}

		integer iscan1 = 0;
		//printf("alpharelax=%e\n", alpharelax);
		//getchar();
		// для внутренних узлов расчётной области:
		for (integer k = 0; k < maxelm; k++) {
			//printf("%e %e %e %e %e %e %e\n", sl[k].ap / alpharelax, -sl[k].ae, -sl[k].aw, -sl[k].an, -sl[k].as, -sl[k].at, -sl[k].ab);
			//system("pause");

			if (fabs(sl[k].ap) > nonzeroEPS) {
				if (iVar == TEMP) {
					if (bSIMPLErun_now_for_natural_convection) {
						// Гидродинамическая задача при alpharelax=1.0;
						Amat.aij[ik + id] = (real_mix_precision)(sl[k].ap / alpharelax);
						rthdsd_amg[sl[k].iP + 1] = dV[sl[k].iP];
					}
					else {
						// Теплопередача в твёрдом теле.
						dV[sl[k].iP] += (1.0 - alpharelax)*sl[k].ap*dX0[sl[k].iP] / alpharelax;
						rthdsd_amg[sl[k].iP + 1] = dV[sl[k].iP];
						Amat.aij[ik + id] = (real_mix_precision)(sl[k].ap / alpharelax);
						sl[k].ap = sl[k].ap / alpharelax;
					}
				}
				else {
					// Скорость давление.
					Amat.aij[ik + id] = (real_mix_precision)(sl[k].ap / alpharelax);
					rthdsd_amg[sl[k].iP + 1] = dV[sl[k].iP];
				}

				Amat.j[ik + id] = sl[k].iP + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				bamg_bound[Amat.i[ik + id]] = false;
				
				result_amg[sl[k].iP + 1] = dX0[sl[k].iP];
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iE > -1) && (fabs(sl[k].ae) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].ae);
				Amat.j[ik + id] = sl[k].iE + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iN > -1) && (fabs(sl[k].an) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].an);
				Amat.j[ik + id] = sl[k].iN + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iT > -1) && (fabs(sl[k].at) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].at);
				Amat.j[ik + id] = sl[k].iT + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iS > -1) && (fabs(sl[k].as) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].as);
				Amat.j[ik + id] = sl[k].iS + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iW > -1) && (fabs(sl[k].aw) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].aw);
				Amat.j[ik + id] = sl[k].iW + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iB > -1) && (fabs(sl[k].ab) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].ab);
				Amat.j[ik + id] = sl[k].iB + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != nullptr) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			// icompression - применяется только для структурированной сетки.
			// Дополнение на АЛИС сетке:
			if ((sl[k].iE2 > -1) && (fabs(sl[k].ae2) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].ae2);
				Amat.j[ik + id] = sl[k].iE2 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iN2 > -1) && (fabs(sl[k].an2) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].an2);
				Amat.j[ik + id] = sl[k].iN2 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iT2 > -1) && (fabs(sl[k].at2) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].at2);
				Amat.j[ik + id] = sl[k].iT2 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iS2 > -1) && (fabs(sl[k].as2) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].as2);
				Amat.j[ik + id] = sl[k].iS2 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iW2 > -1) && (fabs(sl[k].aw2) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].aw2);
				Amat.j[ik + id] = sl[k].iW2 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iB2 > -1) && (fabs(sl[k].ab2) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].ab2);
				Amat.j[ik + id] = sl[k].iB2 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}

			if ((sl[k].iE3 > -1) && (fabs(sl[k].ae3) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].ae3);
				Amat.j[ik + id] = sl[k].iE3 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iN3 > -1) && (fabs(sl[k].an3) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].an3);
				Amat.j[ik + id] = sl[k].iN3 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iT3 > -1) && (fabs(sl[k].at3) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].at3);
				Amat.j[ik + id] = sl[k].iT3 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iS3 > -1) && (fabs(sl[k].as3) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].as3);
				Amat.j[ik + id] = sl[k].iS3 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iW3 > -1) && (fabs(sl[k].aw3) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].aw3);
				Amat.j[ik + id] = sl[k].iW3 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iB3 > -1) && (fabs(sl[k].ab3) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].ab3);
				Amat.j[ik + id] = sl[k].iB3 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}

			if ((sl[k].iE4 > -1) && (fabs(sl[k].ae4) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].ae4);
				Amat.j[ik + id] = sl[k].iE4 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iN4 > -1) && (fabs(sl[k].an4) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].an4);
				Amat.j[ik + id] = sl[k].iN4 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iT4 > -1) && (fabs(sl[k].at4) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].at4);
				Amat.j[ik + id] = sl[k].iT4 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iS4 > -1) && (fabs(sl[k].as4) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].as4);
				Amat.j[ik + id] = sl[k].iS4 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iW4 > -1) && (fabs(sl[k].aw4) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].aw4);
				Amat.j[ik + id] = sl[k].iW4 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iB4 > -1) && (fabs(sl[k].ab4) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-sl[k].ab4);
				Amat.j[ik + id] = sl[k].iB4 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}

		}



		// для внутренних узлов расчётной области:
		for (integer k = 0; k < maxbound; k++) {
			if (fabs(slb[k].aw) > nonzeroEPS) {
				// val[ik]=slb[k].aw/alpharelax;
				Amat.aij[ik + id] = (real_mix_precision)(slb[k].aw); // релаксация для граничных узлов не применяется.
											/*if ((slb[k].iI>-1) && (fabs(slb[k].ai) > nonzeroEPS)) {
											// Внимание !!! было произведено тестирование: один вариант был с нижней релаксацией для граничных узлов,
											// а второй вариант был без нижней релаксации на граничных узлах. Было выяснено, что для сходимости
											// более благоприятен вариант без нижней релаксации на граничных узлах.
											// Данное изменение согласовано с функцией solve.

											val[ik]/=alpharelax; // Если условия Неймана то нижняя релаксация.
											}*/
				Amat.j[ik + id] = slb[k].iW + 1;
				Amat.i[ik + id] = slb[k].iW + 1; // dirichlet
				if (!((slb[k].iI > -1) && (fabs(slb[k].ai) > nonzeroEPS))) {
					// Dirichlet value.
					// Значения Дирихле мы сразу априорно помещаем в C nodes.
					//bamg_bound[Amat[ik + id].i] = true;
					// Это глупость. Наоборот все узлы Дирихле становятся С узлами сразу.
				}
				else {
					// Neiman.
					// Условия Неймана при построении C/F разбиения обрабатываем как обычно как внутренний узел.
					bamg_bound[Amat.i[ik + id]] = false;
				}
				rthdsd_amg[slb[k].iW + 1] = dV[slb[k].iW];
				result_amg[slb[k].iW + 1] = dX0[slb[k].iW];
				ik++;
			}
			if ((slb[k].iI > -1) && (fabs(slb[k].ai) > nonzeroEPS)) {
				Amat.aij[ik + id] = (real_mix_precision)(-slb[k].ai);
				Amat.j[ik + id] = slb[k].iI + 1;
				Amat.i[ik + id] = slb[k].iW + 1;
				//rthdsd_amg[slb[k].iW + 1] = dV[slb[k].iW];
				//result_amg[slb[k].iW + 1] = dX0[slb[k].iW];
				// Это очень важный вопрос и он требует проверки !

				ik++;
			}

		}


		for (integer k = 0; k <= maxelm + maxbound; k++) {
			bamg_bound[k] = false;
		}

		// Освободим немного памяти.
		// Т.к. мы оперируем в мультигриде в девять раз большим объёмом памяти то это уничтожение не является
		// чем-то медленным по сравнению с ресурсами мультигрида.
		if (bmemory_savings && (!b_on_adaptive_local_refinement_mesh)) {
			// Только в случае структурированной сетки  мы компрессируем исходную матрицу чтобы высвободить оперативную память.
			delete[] sl;
			sl = nullptr;
		}
		//delete[] slb;
		//slb = nullptr;

		//R = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
		//R = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
		//char c7[2] = "R";
		//handle_error<Ak1>(R, c7, c1, ((nsizePR * nnu) + 1));

		//P = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
		//P = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
		//char c8[2] = "P";
		//handle_error<Ak1>(P, c8, c1, ((nsizePR * nnu) + 1));


		// TODO: 
		// нужно акуратно прописать выделения и уничтожения памяти с учётом того что было сделано в BiCGStabP.

		// Экономим 1 размер матрицы для мультигрида.
		//delete[] sl;
		//delete[] slb;



		//printf("getready ...");
		//getchar();
		// amg - особенно хорош для поправки давления в SIMPLE алгоритме.
		// свой алгоритм 2015 года.


		//aggregative_amg(Amat, nna, nnu, R, P, result_amg, rthdsd_amg);

		//printf("allocation memory is Ok. start ready...\n");
		//system("pause");
		doublereal theta = 0.24; // 3D // 0.25 по литературным  данным. 0.24 оптимально из практики (реальное тестирование).
		//theta = 0.5; // может поможет  для конвективных задач
		doublereal* x_copy = nullptr;
		x_copy = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
		char c9[7] = "x_copy";
		handle_error<doublereal>(x_copy, c9, c1, (nnu + 1));

		for (integer i47 = 1; i47 <= nnu; i47++) {
			x_copy[i47] = result_amg[i47];
		}
		if (my_amg_manager.iprint_log == 1) {
			printf("x_copy alloc succseful...\n");
		}

		//doublereal theta83 = 0.23;
		//doublereal magic82 = 0.4;
		//doublereal magic83 = 0.5; 
		//doublereal ret74 = 0.0;
		bool bdivergence_detected = false;


		//Внимание можно использовать только double, с float сходимости нет.
		if (iswitchsolveramg_vs_BiCGstab_plus_ILU2 == 7) {
			if (bamg_bound != nullptr) {
				delete[] bamg_bound;
				bamg_bound = nullptr;
			}

			//float theta82f=(float)theta82, theta83f= (float)theta83, magic82f= (float)magic82, magic83f= (float)magic83, ret74f= (float)ret74;
			//doublereal theta82f = (doublereal)theta82, theta83f = (doublereal)theta83, magic82f = (doublereal)magic82, magic83f = (doublereal)magic83, ret74f = (doublereal)ret74;
			//bdivergence_detected = classic_aglomerative_amg4<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg,  theta82f, theta83f, magic82f, magic83f, ret74f, iVar, bmemory_savings,b, lb, maxelm);
			if (my_amg_manager.iprint_log == 1) {
				printf("start Classic Algebraic MultiGrid RUMBA v.0.14...\n");
			}
			bdivergence_detected = classic_aglomerative_amg6<real_mix_precision>(Amat, nsizeA,  nna, nnu, x_copy, rthdsd_amg,  ret74, iVar, bmemory_savings, b, lb, maxelm, whot_is_block);
		}
		else {
			//float theta82f = (float)theta82, theta83f = (float)theta83, magic82f = (float)magic82, magic83f = (float)magic83, ret74f = (float)ret74;
			//doublereal theta82f = (doublereal)theta82, theta83f = (doublereal)theta83, magic82f = (doublereal)magic82, magic83f = (doublereal)magic83, ret74f = (doublereal)ret74;
			//bdivergence_detected = classic_aglomerative_amg5<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82f, theta83f, magic82f, magic83f, ret74f, iVar, bmemory_savings);
			//---->bdivergence_detected = classic_aglomerative_amg5<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings);
		}
		// если работа amg была неудачна то мы не портим переполнение рабочий вектор результата.
		// Перенаправление на стабильную версию алгоритма.
		if (bdivergence_detected) {
			//system("pause");
			integer maxit = 2000;
			bool bprintmessage = false;
			integer* icol_stub = nullptr;
			Bi_CGStab_internal3(sl, slb, maxelm, maxbound, dV, dX0, maxit, alpharelax, bprintmessage, iVar, m, ifrontregulationgl, ibackregulationgl, b, lb, s_loc, ls, inumber_iteration_SIMPLE, icol_stub, 0, false, w, lw);
		}
		else
		{
			// Работа amg была успешна.
			for (integer i47 = 1; i47 <= nnu; i47++) {
				result_amg[i47] = x_copy[i47];
			}
		}
		if (x_copy != nullptr) {
			free(x_copy);
			x_copy = nullptr;
		}

		//system("pause");



		// возвращаем решение СЛАУ.
		// вектор решения. 
		for (integer i = 0; i < nnu; i++) {
			if (i < maxelm + maxbound) {
				// обязательно нужно проверить была ли выделена оперативная память. 
				dX0[i] = result_amg[i + 1];
			}
		}



		//if (R != nullptr) {
			//delete[] R;
			//free(R);
		//}
		//if (P != nullptr) {
			//delete[] P;
			//free(P);
		//}
		if (bamg_bound != nullptr) {
			delete[] bamg_bound;
			bamg_bound = nullptr;
		}
		//if (Atemp != nullptr) {
			//delete[] Atemp;
		//}
		//if (Atemp2 != nullptr) {
			//delete[] Atemp2;
		//}
		if (result_amg != nullptr) {
			//delete[] result_amg;
			free(result_amg);
		}
		if (rthdsd_amg != nullptr) {
			//delete[] rthdsd_amg;
			free(rthdsd_amg);
		}

		if (bmemory_savings && (!b_on_adaptive_local_refinement_mesh)) {
			sl = new equation3D[maxelm]; // коэффициенты матрицы СЛАУ для внутренних КО.
			if (sl == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for slau temperature constr struct...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}
		}


		/*
		slb = new equation3D_bon[maxbound]; // коэффициенты матрицы СЛАУ для граничных КО
		if (slb == nullptr) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem: not enough memory on your equipment for slau boundary temperature constr struct...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		*/
		if (bmemory_savings && (!b_on_adaptive_local_refinement_mesh)) {
			// Разархивация исходной матрицы А в первоначальном формате.
			// Предполагается что матрица на структурированной декартовой прямоугольной сетке.
			// Как бы мы не пытались здесь, но матрица не сохраняемая в файл не подлежит здесь восстановлению,
			// а операция записи в файл чрезвычайно медленная.
			for (int k = 0; k < maxelm; k++) {
				
				sl[k].bB2 = false;
				sl[k].bB3 = false;
				sl[k].bB4 = false;
				sl[k].bE2 = false;
				sl[k].bE3 = false;
				sl[k].bE4 = false;
				sl[k].bN2 = false;
				sl[k].bN3 = false;
				sl[k].bN4 = false;
				sl[k].bT2 = false;
				sl[k].bT3 = false;
				sl[k].bT4 = false;
				sl[k].bW2 = false;
				sl[k].bW3 = false;
				sl[k].bW4 = false;
				sl[k].bS2 = false;
				sl[k].bS3 = false;
				sl[k].bS4 = false;

				sl[k].iB = -1;
				sl[k].iB2 = -1;
				sl[k].iB3 = -1;
				sl[k].iB4 = -1;
				sl[k].iE = -1;
				sl[k].iE2 = -1;
				sl[k].iE3 = -1;
				sl[k].iE4 = -1;
				sl[k].iN = -1;
				sl[k].iN2 = -1;
				sl[k].iN3 = -1;
				sl[k].iN4 = -1;
				sl[k].iS = -1;
				sl[k].iS2 = -1;
				sl[k].iS3 = -1;
				sl[k].iS4 = -1;
				sl[k].iT = -1;
				sl[k].iT2 = -1;
				sl[k].iT3 = -1;
				sl[k].iT4 = -1;
				sl[k].iW = -1;
				sl[k].iW2 = -1;
				sl[k].iW3 = -1;
				sl[k].iW4 = -1;
				sl[k].ab = 0.0;
				sl[k].ae = 0.0;
				sl[k].an = 0.0;
				sl[k].as = 0.0;
				sl[k].at = 0.0;
				sl[k].aw = 0.0;
				sl[k].ab2 = 0.0;
				sl[k].ae2 = 0.0;
				sl[k].an2 = 0.0;
				sl[k].as2 = 0.0;
				sl[k].at2 = 0.0;
				sl[k].aw2 = 0.0;
				sl[k].ab3 = 0.0;
				sl[k].ae3 = 0.0;
				sl[k].an3 = 0.0;
				sl[k].as3 = 0.0;
				sl[k].at3 = 0.0;
				sl[k].aw3 = 0.0;
				sl[k].ab4 = 0.0;
				sl[k].ae4 = 0.0;
				sl[k].an4 = 0.0;
				sl[k].as4 = 0.0;
				sl[k].at4 = 0.0;
				sl[k].aw4 = 0.0;
				sl[k].ap = 0.0;
				integer iadd = 7 * k;
				sl[k].b = rcompressionb[k];
				//p e n t s w b
				sl[k].ap = 1.0 / Amat.aij[the_original_order_of_values[icompression[iadd + 0]]];
				//sl[k].iP = Amat.i[the_original_order_of_values[icompression[iadd + 0]]] - 1;
				sl[k].iP = k;
				//if (Amat.i[the_original_order_of_values[icompression[iadd + 0]]] - 1 != k) {
					//printf("non comparison\n");
					//getchar();
				//}
				if (icompression[iadd + 1] > -1) {
					// E
					sl[k].ae = -Amat.aij[the_original_order_of_values[icompression[iadd + 1]]];
					sl[k].iE = Amat.j[the_original_order_of_values[icompression[iadd + 1]]] - 1;
				}
				if (icompression[iadd + 2] > -1) {
					// N
					sl[k].an = -Amat.aij[the_original_order_of_values[icompression[iadd + 2]]];
					sl[k].iN = Amat.j[the_original_order_of_values[icompression[iadd + 2]]] - 1;
				}
				if (icompression[iadd + 3] > -1) {
					// T
					sl[k].at = -Amat.aij[the_original_order_of_values[icompression[iadd + 3]]];
					sl[k].iT = Amat.j[the_original_order_of_values[icompression[iadd + 3]]] - 1;
				}
				if (icompression[iadd + 4] > -1) {
					// S
					sl[k].as = -Amat.aij[the_original_order_of_values[icompression[iadd + 4]]];
					sl[k].iS = Amat.j[the_original_order_of_values[icompression[iadd + 4]]] - 1;
				}
				if (icompression[iadd + 5] > -1) {
					// W
					sl[k].aw = -Amat.aij[the_original_order_of_values[icompression[iadd + 5]]];
					sl[k].iW = Amat.j[the_original_order_of_values[icompression[iadd + 5]]] - 1;
				}
				if (icompression[iadd + 6] > -1) {
					// B
					sl[k].ab = -Amat.aij[the_original_order_of_values[icompression[iadd + 6]]];
					sl[k].iB = Amat.j[the_original_order_of_values[icompression[iadd + 6]]] - 1;
				}

				//if ((k == 6867418)||(k==68675507)) {
					//printf("ap=%e aw=%e ae=%e as=%e an=%e ab=%e at=%e \n", sl[k].ap, sl[k].aw, sl[k].ae, sl[k].as, sl[k].an, sl[k].ab, sl[k].at);
					//getchar();
				//}
			}

			if (icompression != nullptr) free(icompression);
			icompression = nullptr;

			if (rcompressionb != nullptr) free(rcompressionb);
			rcompressionb = nullptr;



		}

		if (the_original_order_of_values != nullptr) {
			free(the_original_order_of_values);
			the_original_order_of_values = nullptr;
		}
		if (the_original_order_of_values_reverse != nullptr) {
			free(the_original_order_of_values_reverse);
			the_original_order_of_values_reverse = nullptr;
		}

		/*
		for (integer i1 = 0; i1 < maxbound; i1++) {
			slb[i1].iI = -1;
			slb[i1].ai = 0.0;
			slb[i1].aw = 0.0;
		}
		// Если это раскоментировать то res_sum надо извлекать из нутра мультигрида.
		*/


		// освобождение памяти.
		if (Amat.i != nullptr) {
			//delete[] Amat;
			free(Amat.i);
			Amat.i = nullptr;
		}
		if (Amat.j != nullptr) {
			//delete[] Amat;
			free(Amat.j);
			Amat.j = nullptr;
		}
		if (Amat.aij != nullptr) {
			//delete[] Amat;
			free(Amat.aij);
			Amat.aij = nullptr;
		}
		if (Amat.abs_aij != nullptr) {
			//delete[] Amat;
			free(Amat.abs_aij);
			Amat.abs_aij = nullptr;
		}

		res_sum = 0.0;
		for (integer i1 = 0; i1 < maxelm; i1++) {
			// внутренность матрицы.
			doublereal buf = 0.0;
			buf = (sl[i1].ap*dX0[sl[i1].iP] - dV[sl[i1].iP]);
			if ((sl[i1].iB > -1) && (fabs(sl[i1].ab) > nonzeroEPS)) buf -= sl[i1].ab*dX0[sl[i1].iB];
			if ((sl[i1].iE > -1) && (fabs(sl[i1].ae) > nonzeroEPS)) buf -= sl[i1].ae*dX0[sl[i1].iE];
			if ((sl[i1].iN > -1) && (fabs(sl[i1].an) > nonzeroEPS)) buf -= sl[i1].an*dX0[sl[i1].iN];
			if ((sl[i1].iS > -1) && (fabs(sl[i1].as) > nonzeroEPS)) buf -= sl[i1].as*dX0[sl[i1].iS];
			if ((sl[i1].iT > -1) && (fabs(sl[i1].at) > nonzeroEPS)) buf -= sl[i1].at*dX0[sl[i1].iT];
			if ((sl[i1].iW > -1) && (fabs(sl[i1].aw) > nonzeroEPS)) buf -= sl[i1].aw*dX0[sl[i1].iW];

			// Дополнение на АЛИС сетке:
			if ((sl[i1].iB2 > -1) && (fabs(sl[i1].ab2) > nonzeroEPS)) buf -= sl[i1].ab2*dX0[sl[i1].iB2];
			if ((sl[i1].iE2 > -1) && (fabs(sl[i1].ae2) > nonzeroEPS)) buf -= sl[i1].ae2*dX0[sl[i1].iE2];
			if ((sl[i1].iN2 > -1) && (fabs(sl[i1].an2) > nonzeroEPS)) buf -= sl[i1].an2*dX0[sl[i1].iN2];
			if ((sl[i1].iS2 > -1) && (fabs(sl[i1].as2) > nonzeroEPS)) buf -= sl[i1].as2*dX0[sl[i1].iS2];
			if ((sl[i1].iT2 > -1) && (fabs(sl[i1].at2) > nonzeroEPS)) buf -= sl[i1].at2*dX0[sl[i1].iT2];
			if ((sl[i1].iW2 > -1) && (fabs(sl[i1].aw2) > nonzeroEPS)) buf -= sl[i1].aw2*dX0[sl[i1].iW2];

			// Дополнение на АЛИС сетке:
			if ((sl[i1].iB3 > -1) && (fabs(sl[i1].ab3) > nonzeroEPS)) buf -= sl[i1].ab3*dX0[sl[i1].iB3];
			if ((sl[i1].iE3 > -1) && (fabs(sl[i1].ae3) > nonzeroEPS)) buf -= sl[i1].ae3*dX0[sl[i1].iE3];
			if ((sl[i1].iN3 > -1) && (fabs(sl[i1].an3) > nonzeroEPS)) buf -= sl[i1].an3*dX0[sl[i1].iN3];
			if ((sl[i1].iS3 > -1) && (fabs(sl[i1].as3) > nonzeroEPS)) buf -= sl[i1].as3*dX0[sl[i1].iS3];
			if ((sl[i1].iT3 > -1) && (fabs(sl[i1].at3) > nonzeroEPS)) buf -= sl[i1].at3*dX0[sl[i1].iT3];
			if ((sl[i1].iW3 > -1) && (fabs(sl[i1].aw3) > nonzeroEPS)) buf -= sl[i1].aw3*dX0[sl[i1].iW3];

			// Дополнение на АЛИС сетке:
			if ((sl[i1].iB4 > -1) && (fabs(sl[i1].ab4) > nonzeroEPS)) buf -= sl[i1].ab4*dX0[sl[i1].iB4];
			if ((sl[i1].iE4 > -1) && (fabs(sl[i1].ae4) > nonzeroEPS)) buf -= sl[i1].ae4*dX0[sl[i1].iE4];
			if ((sl[i1].iN4 > -1) && (fabs(sl[i1].an4) > nonzeroEPS)) buf -= sl[i1].an4*dX0[sl[i1].iN4];
			if ((sl[i1].iS4 > -1) && (fabs(sl[i1].as4) > nonzeroEPS)) buf -= sl[i1].as4*dX0[sl[i1].iS4];
			if ((sl[i1].iT4 > -1) && (fabs(sl[i1].at4) > nonzeroEPS)) buf -= sl[i1].at4*dX0[sl[i1].iT4];
			if ((sl[i1].iW4 > -1) && (fabs(sl[i1].aw4) > nonzeroEPS)) buf -= sl[i1].aw4*dX0[sl[i1].iW4];

			buf *= buf;
			res_sum += buf;
		}
		for (integer i1 = 0; i1 < maxbound; i1++) {
			// граничные узлы.
			doublereal buf = 0.0;
			buf = slb[i1].aw*dX0[slb[i1].iW] - dV[slb[i1].iW];
			if ((slb[i1].iI > -1) && (fabs(slb[i1].ai) > nonzeroEPS)) buf -= slb[i1].ai*dX0[slb[i1].iI];
			buf *= buf;
			res_sum += buf;
		}
		res_sum = sqrt(res_sum);
		if (my_amg_manager.iprint_log == 1) {
			printf("output diagnostic residual =%e\n", res_sum);
		}
		//printf("residual finish=%1.4e\n",res_sum);
		//getchar();
		if (bsolid_static_only) {
			// используется только для теплопередачи в твёрдом теле для ускорения
			// решения задачи - защита от рестарта.
			finish_residual = res_sum; // значение невязки решённой задачи.
		}

	}

	/*doublerealT fsum1 = 0.0, fsum2 = 0.0;

	// внутренние контрольные объёмы.
	for (integer i = 0; i<maxelm; i++) {
		// числитель
		doublerealT sE, sW, sN, sS, sT, sB;
		if (sl[i].iE>-1) sE = sl[i].ae*dX0[sl[i].iE]; else sE = 0.0;
		if (sl[i].iW>-1) sW = sl[i].aw*dX0[sl[i].iW]; else sW = 0.0;
		if (sl[i].iN>-1) sN = sl[i].an*dX0[sl[i].iN]; else sN = 0.0;
		if (sl[i].iS>-1) sS = sl[i].as*dX0[sl[i].iS]; else sS = 0.0;
		if (sl[i].iT>-1) sT = sl[i].at*dX0[sl[i].iT]; else sT = 0.0;
		if (sl[i].iB>-1) sB = sl[i].ab*dX0[sl[i].iB]; else sB = 0.0;

		doublerealT sE2, sW2, sN2, sS2, sT2, sB2;
		if (sl[i].iE2>-1) sE2 = sl[i].ae2*dX0[sl[i].iE2]; else sE2 = 0.0;
		if (sl[i].iW2>-1) sW2 = sl[i].aw2*dX0[sl[i].iW2]; else sW2 = 0.0;
		if (sl[i].iN2>-1) sN2 = sl[i].an2*dX0[sl[i].iN2]; else sN2 = 0.0;
		if (sl[i].iS2>-1) sS2 = sl[i].as2*dX0[sl[i].iS2]; else sS2 = 0.0;
		if (sl[i].iT2>-1) sT2 = sl[i].at2*dX0[sl[i].iT2]; else sT2 = 0.0;
		if (sl[i].iB2>-1) sB2 = sl[i].ab2*dX0[sl[i].iB2]; else sB2 = 0.0;

		doublerealT sE3, sW3, sN3, sS3, sT3, sB3;
		if (sl[i].iE3>-1) sE3 = sl[i].ae3*dX0[sl[i].iE3]; else sE3 = 0.0;
		if (sl[i].iW3>-1) sW3 = sl[i].aw3*dX0[sl[i].iW3]; else sW3 = 0.0;
		if (sl[i].iN3>-1) sN3 = sl[i].an3*dX0[sl[i].iN3]; else sN3 = 0.0;
		if (sl[i].iS3>-1) sS3 = sl[i].as3*dX0[sl[i].iS3]; else sS3 = 0.0;
		if (sl[i].iT3>-1) sT3 = sl[i].at3*dX0[sl[i].iT3]; else sT3 = 0.0;
		if (sl[i].iB3>-1) sB3 = sl[i].ab3*dX0[sl[i].iB3]; else sB3 = 0.0;

		doublerealT sE4, sW4, sN4, sS4, sT4, sB4;
		if (sl[i].iE4>-1) sE4 = sl[i].ae4*dX0[sl[i].iE4]; else sE4 = 0.0;
		if (sl[i].iW4>-1) sW4 = sl[i].aw4*dX0[sl[i].iW4]; else sW4 = 0.0;
		if (sl[i].iN4>-1) sN4 = sl[i].an4*dX0[sl[i].iN4]; else sN4 = 0.0;
		if (sl[i].iS4>-1) sS4 = sl[i].as4*dX0[sl[i].iS4]; else sS4 = 0.0;
		if (sl[i].iT4>-1) sT4 = sl[i].at4*dX0[sl[i].iT4]; else sT4 = 0.0;
		if (sl[i].iB4>-1) sB4 = sl[i].ab4*dX0[sl[i].iB4]; else sB4 = 0.0;

		fsum1 += fabs(sE + sW + sN + sS + sT + sB + sE2 + sW2 + sN2 + sS2 + sT2 + sB2 + sE3 + sW3 + sN3 + sS3 + sT3 + sB3 + sE4 + sW4 + sN4 + sS4 + sT4 + sB4 +sl[i].b - sl[i].ap*dX0[sl[i].iP]);
		fsum2 += fabs(sl[i].ap*dX0[sl[i].iP]); // знаменатель.
	}//ok
	*/

	calculation_main_end_time = clock();
	calculation_vorst_seach_time += calculation_main_end_time - calculation_main_start_time;

#ifdef _OPENMP
	omp_set_num_threads(i_my_num_core_parallelesation);
#endif
	///getchar();
} // my_agr_amg_loc_memory


/*
program output // пример из pamg.

multilevel_solver
Number of Levels: 6
Operator Complexity: 2.198
Grid Complexity: 1.666
Coarse Solver: 'pinv2'
level   unknowns     nonzeros
0       250000      1248000[45.50%]
1       125000      1121002[40.87%]
2        31252       280662[10.23%]
3         7825        70657[2.58%]
4         1937        17973[0.66%]
5          484         4728[0.17%]

residual norm is 1.86112114946e-06
*/


#endif /* MY_AGREGAT_AMG_CPP*/